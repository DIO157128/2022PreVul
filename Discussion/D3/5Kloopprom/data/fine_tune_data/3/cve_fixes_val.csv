,source,target,group
0,"buggy line: # endif ip += sizeof ( uint64_t ) ;cwe id:CWE-416context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ;  char * identifier ;  char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;  while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif  break ;  case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS )  {   r1 . o = function -> return_obj ;  push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; }  yr_modules_unload_all ( context ) ;  yr_free ( stack ) ; return result ; }",# endif assert ( sp == 0 ) ;ip += sizeof ( uint64_t ) ;,2167
1,"buggy line: # endif  break ;case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ;cwe id:CWE-416context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ;  char * identifier ;  char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;  while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif  break ;  case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS )  {   r1 . o = function -> return_obj ;  push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; }  yr_modules_unload_all ( context ) ;  yr_free ( stack ) ; return result ; }",# endif break ;case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ;,2167
2,"buggy line: if ( result == ERROR_SUCCESS )  {r1 . o = function -> return_obj ;push ( r1 ) ;}else {stop = TRUE ;}cwe id:CWE-416context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ;  char * identifier ;  char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;  while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif  break ;  case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS )  {   r1 . o = function -> return_obj ;  push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; }  yr_modules_unload_all ( context ) ;  yr_free ( stack ) ; return result ; }","if ( result == ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & r1 . o ) ;if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ;stop = ( result != ERROR_SUCCESS ) ;push ( r1 ) ;",2167
3,"buggy line: yr_modules_unload_all ( context ) ;yr_free ( stack ) ;cwe id:CWE-416context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ;  char * identifier ;  char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;  while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif  break ;  case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS )  {   r1 . o = function -> return_obj ;  push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; }  yr_modules_unload_all ( context ) ;  yr_free ( stack ) ; return result ; }","obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ;while ( obj_ptr != NULL ) {yr_object_destroy ( * obj_ptr ) ;obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ;}yr_arena_destroy ( obj_arena ) ;yr_modules_unload_all ( context ) ;yr_free ( stack ) ;",2167
4,"buggy line: res = ctx -> iface -> dec . get_si ( ctx -> priv -> alg_priv , si ) ;}cwe id:CWE-119context: vpx_codec_err_t vpx_codec_get_stream_info ( vpx_codec_ctx_t * ctx , vpx_codec_stream_info_t * si ) { vpx_codec_err_t res ; if ( ! ctx || ! si || si -> sz < sizeof ( vpx_codec_stream_info_t ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { si -> w = 0 ; si -> h = 0 ;  res = ctx -> iface -> dec . get_si ( ctx -> priv -> alg_priv , si ) ;  } return SAVE_STATUS ( ctx , res ) ; }","res = ctx -> iface -> dec . get_si ( get_alg_priv ( ctx ) , si ) ;}",2168
5,"buggy line: static void nsc_encode_subsampling ( NSC_CONTEXT * context )  {BYTE * co_dst ;BYTE * cg_dst ;INT8 * co_src0 ;INT8 * co_src1 ;INT8 * cg_src0 ;INT8 * cg_src1 ;UINT32 tempHeight ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;for ( y = 0 ;y ++ )  {co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ;cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ;co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ;co_src1 = co_src0 + tempWidth ;cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ;cg_src1 = cg_src0 + tempWidth ;for ( x = 0 ;cwe id:CWE-787context:  static void nsc_encode_subsampling ( NSC_CONTEXT * context )  { UINT16 x ; UINT16 y ;  BYTE * co_dst ;  BYTE * cg_dst ; INT8 * co_src0 ; INT8 * co_src1 ; INT8 * cg_src0 ; INT8 * cg_src1 ; UINT32 tempWidth ;  UINT32 tempHeight ;  tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; tempHeight = ROUND_UP_TO ( context -> height , 2 ) ;  for ( y = 0 ; y < tempHeight >> 1 ; y ++ )  {  co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ;   cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ;   co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ;   co_src1 = co_src0 + tempWidth ;   cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ;   cg_src1 = cg_src0 + tempWidth ;  for ( x = 0 ; x < tempWidth >> 1 ; x ++ ) { * co_dst ++ = ( BYTE ) ( ( ( INT16 ) * co_src0 + ( INT16 ) * ( co_src0 + 1 ) + ( INT16 ) * co_src1 + ( INT16 ) * ( co_src1 + 1 ) ) >> 2 ) ; * cg_dst ++ = ( BYTE ) ( ( ( INT16 ) * cg_src0 + ( INT16 ) * ( cg_src0 + 1 ) + ( INT16 ) * cg_src1 + ( INT16 ) * ( cg_src1 + 1 ) ) >> 2 ) ; co_src0 += 2 ; co_src1 += 2 ; cg_src0 += 2 ; cg_src1 += 2 ; } }  } ","static BOOL nsc_encode_subsampling ( NSC_CONTEXT * context ) {UINT32 tempHeight ;if ( ! context ) return FALSE ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;if ( tempHeight == 0 ) return FALSE ;if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ;for ( y = 0 ;y ++ ) {BYTE * co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ;BYTE * cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ;const INT8 * co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ;const INT8 * co_src1 = co_src0 + tempWidth ;const INT8 * cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ;const INT8 * cg_src1 = cg_src0 + tempWidth ;for ( x = 0 ;",2169
6,"buggy line: }cwe id:CWE-787context:  static void nsc_encode_subsampling ( NSC_CONTEXT * context )  { UINT16 x ; UINT16 y ;  BYTE * co_dst ;  BYTE * cg_dst ; INT8 * co_src0 ; INT8 * co_src1 ; INT8 * cg_src0 ; INT8 * cg_src1 ; UINT32 tempWidth ;  UINT32 tempHeight ;  tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; tempHeight = ROUND_UP_TO ( context -> height , 2 ) ;  for ( y = 0 ; y < tempHeight >> 1 ; y ++ )  {  co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ;   cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ;   co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ;   co_src1 = co_src0 + tempWidth ;   cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ;   cg_src1 = cg_src0 + tempWidth ;  for ( x = 0 ; x < tempWidth >> 1 ; x ++ ) { * co_dst ++ = ( BYTE ) ( ( ( INT16 ) * co_src0 + ( INT16 ) * ( co_src0 + 1 ) + ( INT16 ) * co_src1 + ( INT16 ) * ( co_src1 + 1 ) ) >> 2 ) ; * cg_dst ++ = ( BYTE ) ( ( ( INT16 ) * cg_src0 + ( INT16 ) * ( cg_src0 + 1 ) + ( INT16 ) * cg_src1 + ( INT16 ) * ( cg_src1 + 1 ) ) >> 2 ) ; co_src0 += 2 ; co_src1 += 2 ; cg_src0 += 2 ; cg_src1 += 2 ; } }  } ",return TRUE ;},2169
7,"buggy line: static ngx_int_t  ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r )  {ngx_table_elt_t * header ;ngx_list_part_t * part ;ngx_uint_t i ;if ( ngx_list_init ( & sr -> headers_in . headers , sr -> pool , 20 , sizeof ( ngx_table_elt_t ) ) != NGX_OK ) {dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" ,   ( int ) r -> headers_in . headers . part . nelts ) ;part = & r -> headers_in . headers . part ;if ( part -> next == NULL ) {break ;dd ( ""setting<S2SV_blank>request<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ;}dd ( ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" ,  ( int ) r -> headers_in . headers . part . nelts ) ;return NGX_OK ;cwe id:CWE-444context: static ngx_int_t  ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r )  {  ngx_table_elt_t * header ;  ngx_list_part_t * part ;  ngx_uint_t i ;  if ( ngx_list_init ( & sr -> headers_in . headers , sr -> pool , 20 , sizeof ( ngx_table_elt_t ) ) != NGX_OK ) { return NGX_ERROR ; }  dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" ,   ( int ) r -> headers_in . headers . part . nelts ) ;  part = & r -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) {  if ( part -> next == NULL ) {  break ; } part = part -> next ; header = part -> elts ; i = 0 ; } dd ( ""setting<S2SV_blank>request<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; }  }  dd ( ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" ,  ( int ) r -> headers_in . headers . part . nelts ) ;  return NGX_OK ; }","static ngx_int_t ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * pr , int pr_not_chunked ) {ngx_table_elt_t * clh , * header ;ngx_list_part_t * part ;ngx_uint_t i ;u_char * p ;off_t len ;dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) pr -> headers_in . headers . part . nelts ) ;if ( ngx_list_init ( & sr -> headers_in . headers , sr -> pool , 20 , sizeof ( ngx_table_elt_t ) ) != NGX_OK ) {if ( sr -> request_body && ! pr_not_chunked ) {len = sr -> request_body -> buf ? ngx_buf_size ( sr -> request_body -> buf ) : 0 ;clh = ngx_list_push ( & sr -> headers_in . headers ) ;if ( clh == NULL ) {break ;}part = part -> next ;header = part -> elts ;i = 0 ;}dd ( ""setting<S2SV_blank>request<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ;if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) {return NGX_ERROR ;}clh -> hash = ngx_http_lua_content_length_hash ;clh -> key = ngx_http_lua_content_length_header_key ;clh -> lowcase_key = ngx_pnalloc ( sr -> pool , clh -> key . len ) ;if ( clh -> lowcase_key == NULL ) {return NGX_ERROR ;}ngx_strlow ( clh -> lowcase_key , clh -> key . data , clh -> key . len ) ;p = ngx_palloc ( sr -> pool , NGX_OFF_T_LEN ) ;if ( p == NULL ) {return NGX_ERROR ;}clh -> value . data = p ;clh -> value . len = ngx_sprintf ( clh -> value . data , ""%O"" , len ) - clh -> value . data ;sr -> headers_in . content_length = clh ;sr -> headers_in . content_length_n = len ;dd ( ""sr<S2SV_blank>crafted<S2SV_blank>content-length:<S2SV_blank>%.*s"" , ( int ) pr -> headers_in . content_length -> value . len , sr -> headers_in . content_length -> value . data ) ;}part = & pr -> headers_in . headers . part ;if ( part -> next == NULL ) {break ;if ( ! pr_not_chunked && header [ i ] . key . len == sizeof ( ""Content-Length"" ) - 1 && ngx_strncasecmp ( header [ i ] . key . data , ( u_char * ) ""Content-Length"" , sizeof ( ""Content-Length"" ) - 1 ) == 0 ) {continue ;}dd ( ""sr<S2SV_blank>copied<S2SV_blank>req<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ;}dd ( ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) r -> headers_in . headers . part . nelts ) ;return NGX_OK ;",2170
8,"buggy line: MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ;const int tmp_col_min = x -> mv_col_min ;int step_param = cpi -> sf . reduce_first_step_size +  ( cpi -> speed < 8 ? ( cpi -> speed > 5 ? 1 : 0 ) : 2 ) ;step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ;vp9_set_mv_search_range ( x , ref_mv ) ;vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , & v_fn_ptr , 0 ,  ref_mv , dst_mv ) ;{int distortion ;unsigned int sse ;cpi -> find_fractional_mv_step ( x , dst_mv , ref_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit ,  & v_fn_ptr , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion ,   & sse ) ;}cwe id:CWE-119context: static unsigned int do_16x16_motion_iteration ( VP9_COMP * cpi , const MV * ref_mv , MV * dst_mv , int mb_row , int mb_col ) {  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ;  vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ;  const int tmp_col_min = x -> mv_col_min ; const int tmp_col_max = x -> mv_col_max ; const int tmp_row_min = x -> mv_row_min ; const int tmp_row_max = x -> mv_row_max ; MV ref_full ;  int step_param = cpi -> sf . reduce_first_step_size +  ( cpi -> speed < 8 ? ( cpi -> speed > 5 ? 1 : 0 ) : 2 ) ;  step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ;  vp9_set_mv_search_range ( x , ref_mv ) ; ref_full . col = ref_mv -> col >> 3 ; ref_full . row = ref_mv -> row >> 3 ;  vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , & v_fn_ptr , 0 ,  ref_mv , dst_mv ) ; { int distortion ; unsigned int sse ; cpi -> find_fractional_mv_step ( x , dst_mv , ref_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit ,  & v_fn_ptr , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion ,   & sse ) ;  } xd -> mi [ 0 ] -> mbmi . mode = NEWMV ; xd -> mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv = * dst_mv ; vp9_build_inter_predictors_sby ( xd , mb_row , mb_col , BLOCK_16X16 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ;  return vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride ,   xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride ,  INT_MAX ) ; }","MACROBLOCK * const x = & cpi -> td . mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ;const vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ;const int tmp_col_min = x -> mv_col_min ;int cost_list [ 5 ] ;int step_param = mv_sf -> reduce_first_step_size ;step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ;vp9_set_mv_search_range ( x , ref_mv ) ;vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ;}",2171
9,"buggy line: return vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride ,   xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride ,  INT_MAX ) ;cwe id:CWE-119context: static unsigned int do_16x16_motion_iteration ( VP9_COMP * cpi , const MV * ref_mv , MV * dst_mv , int mb_row , int mb_col ) {  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ;  vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ;  const int tmp_col_min = x -> mv_col_min ; const int tmp_col_max = x -> mv_col_max ; const int tmp_row_min = x -> mv_row_min ; const int tmp_row_max = x -> mv_row_max ; MV ref_full ;  int step_param = cpi -> sf . reduce_first_step_size +  ( cpi -> speed < 8 ? ( cpi -> speed > 5 ? 1 : 0 ) : 2 ) ;  step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ;  vp9_set_mv_search_range ( x , ref_mv ) ; ref_full . col = ref_mv -> col >> 3 ; ref_full . row = ref_mv -> row >> 3 ;  vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , & v_fn_ptr , 0 ,  ref_mv , dst_mv ) ; { int distortion ; unsigned int sse ; cpi -> find_fractional_mv_step ( x , dst_mv , ref_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit ,  & v_fn_ptr , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion ,   & sse ) ;  } xd -> mi [ 0 ] -> mbmi . mode = NEWMV ; xd -> mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv = * dst_mv ; vp9_build_inter_predictors_sby ( xd , mb_row , mb_col , BLOCK_16X16 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ;  return vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride ,   xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride ,  INT_MAX ) ; }","return vpx_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride ) ;",2171
10,"buggy line: int secure_decrypt ( void * data , unsigned int data_length , int is_signed )  {at91_aes_key_size_t key_size ;unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ;init_keys ( & key_size , cipher_key , cmac_key , iv ) ;at91_aes_init ( ) ;if ( is_signed ) {if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ;fixed_length = at91_aes_roundup ( data_length ) ;cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ;if ( ! consttime_memequal ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) goto exit ;}if ( at91_aes_cbc ( data_length , data , data , 0 , key_size , cipher_key , iv ) ) goto exit ;rc = 0 ;exit : at91_aes_cleanup ( ) ;memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ;memset ( cipher_key , 0 , sizeof ( cipher_key ) ) ;memset ( iv , 0 , sizeof ( iv ) ) ;cwe id:CWE-326context:  int secure_decrypt ( void * data , unsigned int data_length , int is_signed )  {  at91_aes_key_size_t key_size ;  unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ; unsigned int iv [ AT91_AES_IV_SIZE_WORD ] ; unsigned int computed_cmac [ AT91_AES_BLOCK_SIZE_WORD ] ; unsigned int fixed_length ; const unsigned int * cmac ; int rc = - 1 ;  init_keys ( & key_size , cipher_key , cmac_key , iv ) ;  at91_aes_init ( ) ; if ( is_signed ) { if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ; fixed_length = at91_aes_roundup ( data_length ) ; cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ; if ( ! consttime_memequal ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) goto exit ; } if ( at91_aes_cbc ( data_length , data , data , 0 , key_size , cipher_key , iv ) ) goto exit ; rc = 0 ; exit : at91_aes_cleanup ( ) ;  memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ;  memset ( cipher_key , 0 , sizeof ( cipher_key ) ) ; memset ( iv , 0 , sizeof ( iv ) ) ; return rc ; }","static int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) {at91_aes_key_size_t key_size ;unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ;# if defined ( CONFIG_AES_KEY_SIZE_128 ) key_size = AT91_AES_KEY_SIZE_128 ;# elif defined ( CONFIG_AES_KEY_SIZE_192 ) key_size = AT91_AES_KEY_SIZE_192 ;# elif defined ( CONFIG_AES_KEY_SIZE_256 ) key_size = AT91_AES_KEY_SIZE_256 ;# else # error ""bad<S2SV_blank>AES<S2SV_blank>key<S2SV_blank>size"" # endif at91_aes_init ( ) ;",2172
11,"buggy line: cwe id:CWE-119context: int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ;  o = 2 ;  } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ;  for ( j = 0 ; j < nelements ; j ++ , i ++ ) {  uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }","if ( nelements == 0 ) {DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\\goto out ;}",2173
12,"buggy line: o = 2 ;}cwe id:CWE-119context: int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ;  o = 2 ;  } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ;  for ( j = 0 ; j < nelements ; j ++ , i ++ ) {  uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }",o = 2 ;},2173
13,"buggy line: for ( j = 0 ;j < nelements ;uint32_t l = CDF_GETUINT32 ( q , o ) ;cwe id:CWE-119context: int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ;  o = 2 ;  } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ;  for ( j = 0 ; j < nelements ; j ++ , i ++ ) {  uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }","for ( j = 0 ;j < nelements && i < sh . sh_properties ;uint32_t l = CDF_GETUINT32 ( q , o ) ;",2173
14,"buggy line: default :  assert ( 0 ) ;}cwe id:CWE-617context: static void update_bar_address ( struct vmctx * ctx , struct pci_vdev * dev , uint64_t addr , int idx , int type , bool ignore_reg_unreg ) { bool decode = false ; uint64_t orig_addr = dev -> bar [ idx ] . addr ; if ( ! ignore_reg_unreg ) { if ( dev -> bar [ idx ] . type == PCIBAR_IO ) decode = porten ( dev ) ; else decode = memen ( dev ) ; } if ( decode ) unregister_bar ( dev , idx ) ; switch ( type ) { case PCIBAR_IO : case PCIBAR_MEM32 : dev -> bar [ idx ] . addr = addr ; break ; case PCIBAR_MEM64 : dev -> bar [ idx ] . addr &= ~ 0xffffffffUL ; dev -> bar [ idx ] . addr |= addr ; break ; case PCIBAR_MEMHI64 : dev -> bar [ idx ] . addr &= 0xffffffff ; dev -> bar [ idx ] . addr |= addr ; break ; default :  assert ( 0 ) ;  } if ( decode ) register_bar ( dev , idx ) ; if ( dev -> dev_ops -> vdev_update_bar_map && decode ) dev -> dev_ops -> vdev_update_bar_map ( ctx , dev , idx , orig_addr ) ; }","default : pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\\return ;}",2174
15,"buggy line: cwe id:CWE-119context: static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ; int number_extensionss = 0 ; MagickBooleanType status ; RectangleInfo page ; register ssize_t i ; register unsigned char * p ; size_t delay , dispose , duration , global_colors , image_count , iterations , one ; ssize_t count , opacity ; unsigned char background , c , flag , * global_colormap , header [ MaxTextExtent ] , magick [ 12 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 6 , magick ) ; if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) magick , ""GIF87"" , 5 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""GIF89"" , 5 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; page . width = ReadBlobLSBShort ( image ) ; page . height = ReadBlobLSBShort ( image ) ; flag = ( unsigned char ) ReadBlobByte ( image ) ; background = ( unsigned char ) ReadBlobByte ( image ) ; c = ( unsigned char ) ReadBlobByte ( image ) ; one = 1 ; global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ; global_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( global_colors , 256 ) , 3UL * sizeof ( * global_colormap ) ) ; if ( global_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) count = ReadBlob ( image , ( size_t ) ( 3 * global_colors ) , global_colormap ) ; delay = 0 ; dispose = 0 ; duration = 0 ; iterations = 1 ; opacity = ( - 1 ) ; image_count = 0 ; meta_image = AcquireImage ( image_info ) ; for ( ; ; ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) break ; if ( c == ( unsigned char ) ';' ) break ; if ( c == ( unsigned char ) '!' ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadExtensionBlock"" ) ; } switch ( c ) { case 0xf9 : { while ( ReadBlobBlock ( image , header ) != 0 ) ; dispose = ( size_t ) ( header [ 0 ] >> 2 ) ; delay = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ; if ( ( ssize_t ) ( header [ 0 ] & 0x01 ) == 0x01 ) opacity = ( ssize_t ) header [ 3 ] ; break ; } case 0xfe : { char * comments ; size_t length ; comments = AcquireString ( ( char * ) NULL ) ; for ( length = 0 ; ; length += count ) { count = ( ssize_t ) ReadBlobBlock ( image , header ) ; if ( count == 0 ) break ; header [ count ] = '\\0' ; ( void ) ConcatenateString ( & comments , ( const char * ) header ) ; } ( void ) SetImageProperty ( meta_image , ""comment"" , comments ) ; comments = DestroyString ( comments ) ; break ; } case 0xff : { MagickBooleanType loop ; loop = MagickFalse ; if ( ReadBlobBlock ( image , header ) != 0 ) loop = LocaleNCompare ( ( char * ) header , ""NETSCAPE2.0"" , 11 ) == 0 ? MagickTrue : MagickFalse ; if ( loop != MagickFalse ) { while ( ReadBlobBlock ( image , header ) != 0 ) iterations = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ; break ; } else { char name [ MaxTextExtent ] ; int block_length , info_length , reserved_length ; MagickBooleanType i8bim , icc , iptc , magick ; StringInfo * profile ; unsigned char * info ; icc = LocaleNCompare ( ( char * ) header , ""ICCRGBG1012"" , 11 ) == 0 ? MagickTrue : MagickFalse ; magick = LocaleNCompare ( ( char * ) header , ""ImageMagick"" , 11 ) == 0 ? MagickTrue : MagickFalse ; i8bim = LocaleNCompare ( ( char * ) header , ""MGK8BIM0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; iptc = LocaleNCompare ( ( char * ) header , ""MGKIPTC0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; number_extensionss ++ ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Reading<S2SV_blank>GIF<S2SV_blank>application<S2SV_blank>extension"" ) ; info = ( unsigned char * ) AcquireQuantumMemory ( 255UL , sizeof ( * info ) ) ; reserved_length = 255 ; for ( info_length = 0 ; ; ) { block_length = ( int ) ReadBlobBlock ( image , & info [ info_length ] ) ; if ( block_length == 0 ) break ; info_length += block_length ; if ( info_length > ( reserved_length - 255 ) ) { reserved_length += 4096 ; info = ( unsigned char * ) ResizeQuantumMemory ( info , ( size_t ) reserved_length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } profile = BlobToStringInfo ( info , ( size_t ) info_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( i8bim != MagickFalse ) ( void ) CopyMagickString ( name , ""8bim"" , sizeof ( name ) ) ; else if ( icc != MagickFalse ) ( void ) CopyMagickString ( name , ""icc"" , sizeof ( name ) ) ; else if ( iptc != MagickFalse ) ( void ) CopyMagickString ( name , ""iptc"" , sizeof ( name ) ) ; else if ( magick != MagickFalse ) { ( void ) CopyMagickString ( name , ""magick"" , sizeof ( name ) ) ; image -> gamma = StringToDouble ( ( char * ) info + 6 , ( char * * ) NULL ) ; } else ( void ) FormatLocaleString ( name , sizeof ( name ) , ""gif:%.11s"" , header ) ; info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; if ( magick == MagickFalse ) ( void ) SetImageProfile ( meta_image , name , profile ) ; profile = DestroyStringInfo ( profile ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>profile<S2SV_blank>name=%s"" , name ) ; } break ; } default : { while ( ReadBlobBlock ( image , header ) != 0 ) ; break ; } } } if ( c != ( unsigned char ) ',' ) continue ; if ( image_count != 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; } image_count ++ ; meta_image -> scene = image -> scene ; CloneImageProperties ( image , meta_image ) ; DestroyImageProperties ( meta_image ) ; CloneImageProfiles ( image , meta_image ) ; DestroyImageProfiles ( meta_image ) ; image -> storage_class = PseudoClass ; image -> compression = LZWCompression ; page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ; page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; image -> depth = 8 ; flag = ( unsigned char ) ReadBlobByte ( image ) ; image -> interlace = BitSet ( ( int ) flag , 0x40 ) != 0 ? GIFInterlace : NoInterlace ; image -> colors = BitSet ( ( int ) flag , 0x80 ) == 0 ? global_colors : one << ( ( size_t ) ( flag & 0x07 ) + 1 ) ; if ( opacity >= ( ssize_t ) image -> colors ) opacity = ( - 1 ) ; image -> page . width = page . width ; image -> page . height = page . height ; image -> page . y = page . y ; image -> page . x = page . x ; image -> delay = delay ; image -> iterations = iterations ; image -> ticks_per_second = 100 ; image -> dispose = ( DisposeType ) dispose ; image -> matte = opacity >= 0 ? MagickTrue : MagickFalse ; delay = 0 ; dispose = 0 ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; } if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } if ( BitSet ( ( int ) flag , 0x80 ) == 0 ) { p = global_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) { image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ; image -> transparent_color = image -> colormap [ opacity ] ; } } image -> background_color = image -> colormap [ MagickMin ( background , image -> colors - 1 ) ] ; } else { unsigned char * colormap ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , 3 * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } count = ReadBlob ( image , ( 3 * image -> colors ) * sizeof ( * colormap ) , colormap ) ; if ( count != ( ssize_t ) ( 3 * image -> colors ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ; } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } if ( image -> gamma == 1.0 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) if ( IsGrayPixel ( image -> colormap + i ) == MagickFalse ) break ; ( void ) SetImageColorspace ( image , i == ( ssize_t ) image -> colors ? GRAYColorspace : RGBColorspace ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;  if ( image_info -> ping != MagickFalse )  status = PingGIFImage ( image ) ; else status = DecodeImage ( image , opacity ) ; if ( ( image_info -> ping == MagickFalse ) && ( status == MagickFalse ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } duration += image -> delay * image -> iterations ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; opacity = ( - 1 ) ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) image -> scene - 1 , image -> scene ) ; if ( status == MagickFalse ) break ; } image -> duration = duration ; meta_image = DestroyImage ( meta_image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",2175
16,"buggy line: if ( image_info -> ping != MagickFalse )  status = PingGIFImage ( image ) ;cwe id:CWE-119context: static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ; int number_extensionss = 0 ; MagickBooleanType status ; RectangleInfo page ; register ssize_t i ; register unsigned char * p ; size_t delay , dispose , duration , global_colors , image_count , iterations , one ; ssize_t count , opacity ; unsigned char background , c , flag , * global_colormap , header [ MaxTextExtent ] , magick [ 12 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 6 , magick ) ; if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) magick , ""GIF87"" , 5 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""GIF89"" , 5 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; page . width = ReadBlobLSBShort ( image ) ; page . height = ReadBlobLSBShort ( image ) ; flag = ( unsigned char ) ReadBlobByte ( image ) ; background = ( unsigned char ) ReadBlobByte ( image ) ; c = ( unsigned char ) ReadBlobByte ( image ) ; one = 1 ; global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ; global_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( global_colors , 256 ) , 3UL * sizeof ( * global_colormap ) ) ; if ( global_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) count = ReadBlob ( image , ( size_t ) ( 3 * global_colors ) , global_colormap ) ; delay = 0 ; dispose = 0 ; duration = 0 ; iterations = 1 ; opacity = ( - 1 ) ; image_count = 0 ; meta_image = AcquireImage ( image_info ) ; for ( ; ; ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) break ; if ( c == ( unsigned char ) ';' ) break ; if ( c == ( unsigned char ) '!' ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadExtensionBlock"" ) ; } switch ( c ) { case 0xf9 : { while ( ReadBlobBlock ( image , header ) != 0 ) ; dispose = ( size_t ) ( header [ 0 ] >> 2 ) ; delay = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ; if ( ( ssize_t ) ( header [ 0 ] & 0x01 ) == 0x01 ) opacity = ( ssize_t ) header [ 3 ] ; break ; } case 0xfe : { char * comments ; size_t length ; comments = AcquireString ( ( char * ) NULL ) ; for ( length = 0 ; ; length += count ) { count = ( ssize_t ) ReadBlobBlock ( image , header ) ; if ( count == 0 ) break ; header [ count ] = '\\0' ; ( void ) ConcatenateString ( & comments , ( const char * ) header ) ; } ( void ) SetImageProperty ( meta_image , ""comment"" , comments ) ; comments = DestroyString ( comments ) ; break ; } case 0xff : { MagickBooleanType loop ; loop = MagickFalse ; if ( ReadBlobBlock ( image , header ) != 0 ) loop = LocaleNCompare ( ( char * ) header , ""NETSCAPE2.0"" , 11 ) == 0 ? MagickTrue : MagickFalse ; if ( loop != MagickFalse ) { while ( ReadBlobBlock ( image , header ) != 0 ) iterations = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ; break ; } else { char name [ MaxTextExtent ] ; int block_length , info_length , reserved_length ; MagickBooleanType i8bim , icc , iptc , magick ; StringInfo * profile ; unsigned char * info ; icc = LocaleNCompare ( ( char * ) header , ""ICCRGBG1012"" , 11 ) == 0 ? MagickTrue : MagickFalse ; magick = LocaleNCompare ( ( char * ) header , ""ImageMagick"" , 11 ) == 0 ? MagickTrue : MagickFalse ; i8bim = LocaleNCompare ( ( char * ) header , ""MGK8BIM0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; iptc = LocaleNCompare ( ( char * ) header , ""MGKIPTC0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; number_extensionss ++ ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Reading<S2SV_blank>GIF<S2SV_blank>application<S2SV_blank>extension"" ) ; info = ( unsigned char * ) AcquireQuantumMemory ( 255UL , sizeof ( * info ) ) ; reserved_length = 255 ; for ( info_length = 0 ; ; ) { block_length = ( int ) ReadBlobBlock ( image , & info [ info_length ] ) ; if ( block_length == 0 ) break ; info_length += block_length ; if ( info_length > ( reserved_length - 255 ) ) { reserved_length += 4096 ; info = ( unsigned char * ) ResizeQuantumMemory ( info , ( size_t ) reserved_length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } profile = BlobToStringInfo ( info , ( size_t ) info_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( i8bim != MagickFalse ) ( void ) CopyMagickString ( name , ""8bim"" , sizeof ( name ) ) ; else if ( icc != MagickFalse ) ( void ) CopyMagickString ( name , ""icc"" , sizeof ( name ) ) ; else if ( iptc != MagickFalse ) ( void ) CopyMagickString ( name , ""iptc"" , sizeof ( name ) ) ; else if ( magick != MagickFalse ) { ( void ) CopyMagickString ( name , ""magick"" , sizeof ( name ) ) ; image -> gamma = StringToDouble ( ( char * ) info + 6 , ( char * * ) NULL ) ; } else ( void ) FormatLocaleString ( name , sizeof ( name ) , ""gif:%.11s"" , header ) ; info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; if ( magick == MagickFalse ) ( void ) SetImageProfile ( meta_image , name , profile ) ; profile = DestroyStringInfo ( profile ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>profile<S2SV_blank>name=%s"" , name ) ; } break ; } default : { while ( ReadBlobBlock ( image , header ) != 0 ) ; break ; } } } if ( c != ( unsigned char ) ',' ) continue ; if ( image_count != 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; } image_count ++ ; meta_image -> scene = image -> scene ; CloneImageProperties ( image , meta_image ) ; DestroyImageProperties ( meta_image ) ; CloneImageProfiles ( image , meta_image ) ; DestroyImageProfiles ( meta_image ) ; image -> storage_class = PseudoClass ; image -> compression = LZWCompression ; page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ; page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; image -> depth = 8 ; flag = ( unsigned char ) ReadBlobByte ( image ) ; image -> interlace = BitSet ( ( int ) flag , 0x40 ) != 0 ? GIFInterlace : NoInterlace ; image -> colors = BitSet ( ( int ) flag , 0x80 ) == 0 ? global_colors : one << ( ( size_t ) ( flag & 0x07 ) + 1 ) ; if ( opacity >= ( ssize_t ) image -> colors ) opacity = ( - 1 ) ; image -> page . width = page . width ; image -> page . height = page . height ; image -> page . y = page . y ; image -> page . x = page . x ; image -> delay = delay ; image -> iterations = iterations ; image -> ticks_per_second = 100 ; image -> dispose = ( DisposeType ) dispose ; image -> matte = opacity >= 0 ? MagickTrue : MagickFalse ; delay = 0 ; dispose = 0 ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; } if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } if ( BitSet ( ( int ) flag , 0x80 ) == 0 ) { p = global_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) { image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ; image -> transparent_color = image -> colormap [ opacity ] ; } } image -> background_color = image -> colormap [ MagickMin ( background , image -> colors - 1 ) ] ; } else { unsigned char * colormap ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , 3 * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } count = ReadBlob ( image , ( 3 * image -> colors ) * sizeof ( * colormap ) , colormap ) ; if ( count != ( ssize_t ) ( 3 * image -> colors ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ; } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } if ( image -> gamma == 1.0 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) if ( IsGrayPixel ( image -> colormap + i ) == MagickFalse ) break ; ( void ) SetImageColorspace ( image , i == ( ssize_t ) image -> colors ? GRAYColorspace : RGBColorspace ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;  if ( image_info -> ping != MagickFalse )  status = PingGIFImage ( image ) ; else status = DecodeImage ( image , opacity ) ; if ( ( image_info -> ping == MagickFalse ) && ( status == MagickFalse ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } duration += image -> delay * image -> iterations ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; opacity = ( - 1 ) ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) image -> scene - 1 , image -> scene ) ; if ( status == MagickFalse ) break ; } image -> duration = duration ; meta_image = DestroyImage ( meta_image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",if ( image_info -> ping != MagickFalse ) status = PingGIFImage ( image ) ;,2175
17,"buggy line: if ( ! adis -> buffer )  return - ENOMEM ;tx = adis -> buffer + burst_length ;tx [ 0 ] = ADIS_READ_REG ( adis -> burst -> reg_cmd ) ;cwe id:CWE-401context: static int adis_update_scan_mode_burst ( struct iio_dev * indio_dev , const unsigned long * scan_mask ) { struct adis * adis = iio_device_get_drvdata ( indio_dev ) ; unsigned int burst_length ; u8 * tx ; burst_length = ( indio_dev -> num_channels - 1 ) * sizeof ( u16 ) ; burst_length += adis -> burst -> extra_len ; adis -> xfer = kcalloc ( 2 , sizeof ( * adis -> xfer ) , GFP_KERNEL ) ; if ( ! adis -> xfer ) return - ENOMEM ; adis -> buffer = kzalloc ( burst_length + sizeof ( u16 ) , GFP_KERNEL ) ;  if ( ! adis -> buffer )  return - ENOMEM ;  tx = adis -> buffer + burst_length ;  tx [ 0 ] = ADIS_READ_REG ( adis -> burst -> reg_cmd ) ; tx [ 1 ] = 0 ; adis -> xfer [ 0 ] . tx_buf = tx ; adis -> xfer [ 0 ] . bits_per_word = 8 ; adis -> xfer [ 0 ] . len = 2 ; adis -> xfer [ 1 ] . rx_buf = adis -> buffer ; adis -> xfer [ 1 ] . bits_per_word = 8 ; adis -> xfer [ 1 ] . len = burst_length ; spi_message_init ( & adis -> msg ) ; spi_message_add_tail ( & adis -> xfer [ 0 ] , & adis -> msg ) ; spi_message_add_tail ( & adis -> xfer [ 1 ] , & adis -> msg ) ; return 0 ; }",if ( ! adis -> buffer ) {kfree ( adis -> xfer ) ;adis -> xfer = NULL ;return - ENOMEM ;}tx = adis -> buffer + burst_length ;tx [ 0 ] = ADIS_READ_REG ( adis -> burst -> reg_cmd ) ;,2176
18,"buggy line: dst_reg -> id = ptr_reg -> id ;switch ( opcode ) {cwe id:CWE-190context: static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u8 opcode = BPF_OP ( insn -> code ) ; u32 dst = insn -> dst_reg ; dst_reg = & regs [ dst ] ; if ( WARN_ON_ONCE ( known && ( smin_val != smax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>sbounds\\n"" ) ; return - EINVAL ; } if ( WARN_ON_ONCE ( known && ( umin_val != umax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>ubounds\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_MAP_VALUE_OR_NULL ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_MAP_VALUE_OR_NULL<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == CONST_PTR_TO_MAP ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>CONST_PTR_TO_MAP<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_PACKET_END ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_PACKET_END<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } dst_reg -> type = ptr_reg -> type ;  dst_reg -> id = ptr_reg -> id ;  switch ( opcode ) { case BPF_ADD : if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> range = 0 ; } break ; case BPF_SUB : if ( dst_reg == off_reg ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> range = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; }  __update_reg_bounds ( dst_reg ) ;  __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","dst_reg -> id = ptr_reg -> id ;if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL ;switch ( opcode ) {",2177
19,"buggy line: cwe id:CWE-190context: static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u8 opcode = BPF_OP ( insn -> code ) ; u32 dst = insn -> dst_reg ; dst_reg = & regs [ dst ] ; if ( WARN_ON_ONCE ( known && ( smin_val != smax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>sbounds\\n"" ) ; return - EINVAL ; } if ( WARN_ON_ONCE ( known && ( umin_val != umax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>ubounds\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_MAP_VALUE_OR_NULL ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_MAP_VALUE_OR_NULL<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == CONST_PTR_TO_MAP ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>CONST_PTR_TO_MAP<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_PACKET_END ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_PACKET_END<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } dst_reg -> type = ptr_reg -> type ;  dst_reg -> id = ptr_reg -> id ;  switch ( opcode ) { case BPF_ADD : if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> range = 0 ; } break ; case BPF_SUB : if ( dst_reg == off_reg ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> range = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; }  __update_reg_bounds ( dst_reg ) ;  __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;",2177
20,"buggy line: __update_reg_bounds ( dst_reg ) ;__reg_deduce_bounds ( dst_reg ) ;cwe id:CWE-190context: static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u8 opcode = BPF_OP ( insn -> code ) ; u32 dst = insn -> dst_reg ; dst_reg = & regs [ dst ] ; if ( WARN_ON_ONCE ( known && ( smin_val != smax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>sbounds\\n"" ) ; return - EINVAL ; } if ( WARN_ON_ONCE ( known && ( umin_val != umax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>ubounds\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_MAP_VALUE_OR_NULL ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_MAP_VALUE_OR_NULL<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == CONST_PTR_TO_MAP ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>CONST_PTR_TO_MAP<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_PACKET_END ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_PACKET_END<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } dst_reg -> type = ptr_reg -> type ;  dst_reg -> id = ptr_reg -> id ;  switch ( opcode ) { case BPF_ADD : if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> range = 0 ; } break ; case BPF_SUB : if ( dst_reg == off_reg ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> range = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; }  __update_reg_bounds ( dst_reg ) ;  __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }",__update_reg_bounds ( dst_reg ) ;__reg_deduce_bounds ( dst_reg ) ;,2177
21,"buggy line: Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;cwe id:CWE-269context: void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) {  Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ;  return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , "".cfg"" ) ; Com_Printf ( ""Writing<S2SV_blank>%s.\\n"" , filename ) ; Com_WriteConfigToFile ( filename ) ; }","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;}if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) {Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".cfg\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;",2178
22,"buggy line: usleep ( 250000 ) ;return 0 ;cwe id:CWE-284context: static int adev_open_output_stream ( struct audio_hw_device * dev , audio_io_handle_t handle , audio_devices_t devices , audio_output_flags_t flags , struct audio_config * config , struct audio_stream_out * * stream_out , const char * address ) { struct a2dp_audio_device * a2dp_dev = ( struct a2dp_audio_device * ) dev ; struct a2dp_stream_out * out ; int ret = 0 ; int i ; UNUSED ( address ) ; UNUSED ( handle ) ; UNUSED ( devices ) ; UNUSED ( flags ) ; INFO ( ""opening<S2SV_blank>output"" ) ; out = ( struct a2dp_stream_out * ) calloc ( 1 , sizeof ( struct a2dp_stream_out ) ) ; if ( ! out ) return - ENOMEM ; out -> stream . common . get_sample_rate = out_get_sample_rate ; out -> stream . common . set_sample_rate = out_set_sample_rate ; out -> stream . common . get_buffer_size = out_get_buffer_size ; out -> stream . common . get_channels = out_get_channels ; out -> stream . common . get_format = out_get_format ; out -> stream . common . set_format = out_set_format ; out -> stream . common . standby = out_standby ; out -> stream . common . dump = out_dump ; out -> stream . common . set_parameters = out_set_parameters ; out -> stream . common . get_parameters = out_get_parameters ; out -> stream . common . add_audio_effect = out_add_audio_effect ; out -> stream . common . remove_audio_effect = out_remove_audio_effect ; out -> stream . get_latency = out_get_latency ; out -> stream . set_volume = out_set_volume ; out -> stream . write = out_write ; out -> stream . get_render_position = out_get_render_position ; out -> stream . get_presentation_position = out_get_presentation_position ; a2dp_stream_common_init ( & out -> common ) ; out -> common . cfg . channel_flags = AUDIO_STREAM_DEFAULT_CHANNEL_FLAG ; out -> common . cfg . format = AUDIO_STREAM_DEFAULT_FORMAT ; out -> common . cfg . rate = AUDIO_STREAM_DEFAULT_RATE ; if ( config ) { config -> format = out_get_format ( ( const struct audio_stream * ) & out -> stream ) ; config -> sample_rate = out_get_sample_rate ( ( const struct audio_stream * ) & out -> stream ) ; config -> channel_mask = out_get_channels ( ( const struct audio_stream * ) & out -> stream ) ; } * stream_out = & out -> stream ; a2dp_dev -> output = out ; a2dp_open_ctrl_path ( & out -> common ) ; if ( out -> common . ctrl_fd == AUDIO_SKT_DISCONNECTED ) { ERROR ( ""ctrl<S2SV_blank>socket<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>connect<S2SV_blank>(%s)"" , strerror ( errno ) ) ; ret = - 1 ; goto err_open ; } DEBUG ( ""success"" ) ;  usleep ( 250000 ) ;  return 0 ; err_open : free ( out ) ; * stream_out = NULL ; a2dp_dev -> output = NULL ; ERROR ( ""failed"" ) ; return ret ; }",TEMP_FAILURE_RETRY ( usleep ( 250000 ) ) ;return 0 ;,2179
23,"buggy line: static void update_mv_probs ( vp9_prob * p , int n , vp9_reader * r ) {int i ;++ i )  if ( vp9_read ( r , MV_UPDATE_PROB ) )   p [ i ] = ( vp9_read_literal ( r , 7 ) << 1 ) | 1 ;}cwe id:CWE-119context:  static void update_mv_probs ( vp9_prob * p , int n , vp9_reader * r ) {  int i ; for ( i = 0 ; i < n ; ++ i )  if ( vp9_read ( r , MV_UPDATE_PROB ) )   p [ i ] = ( vp9_read_literal ( r , 7 ) << 1 ) | 1 ;  }","static void update_mv_probs ( vpx_prob * p , int n , vpx_reader * r ) {int i ;+ i )  if ( vp9_read ( r , MV_UPDATE_PROB ) )   p [ i ] = ( vp9_read_literal ( r , 7 ) << 1 ) | 1 ;++ i ) if ( vpx_read ( r , MV_UPDATE_PROB ) ) p [ i ] = ( vpx_read_literal ( r , 7 ) << 1 ) | 1 ;}",2180
24,"buggy line: if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) )  return - EFAULT ;cwe id:CWE-20context: static int get_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; u32 off ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ;  if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) )  return - EFAULT ; return 0 ; }","if ( validate_core_offset ( reg ) ) return - EINVAL ;if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) return - EFAULT ;",2181
25,buggy line: mk_vhost_close ( sr ) ;}cwe id:CWE-20context: void mk_request_free ( struct session_request * sr ) { if ( sr -> fd_file > 0 ) {  mk_vhost_close ( sr ) ;  } if ( sr -> headers . location ) { mk_mem_free ( sr -> headers . location ) ; } if ( sr -> uri_processed . data != sr -> uri . data ) { mk_ptr_free ( & sr -> uri_processed ) ; } if ( sr -> real_path . data != sr -> real_path_static ) { mk_ptr_free ( & sr -> real_path ) ; } },if ( sr -> fd_is_fdt == MK_TRUE ) {mk_vhost_close ( sr ) ;}else {close ( sr -> fd_file ) ;}},2182
26,"buggy line: while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) {i ++ ;cwe id:CWE-125context: GF_Err urn_Read ( GF_Box * s , GF_BitStream * bs ) { u32 i , to_read ; char * tmpName ; GF_DataEntryURNBox * ptr = ( GF_DataEntryURNBox * ) s ; if ( ! ptr -> size ) return GF_OK ; to_read = ( u32 ) ptr -> size ; tmpName = ( char * ) gf_malloc ( sizeof ( char ) * to_read ) ; if ( ! tmpName ) return GF_OUT_OF_MEM ; gf_bs_read_data ( bs , tmpName , to_read ) ; i = 0 ;  while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) {  i ++ ; } if ( i == to_read ) { gf_free ( tmpName ) ; return GF_ISOM_INVALID_FILE ; } if ( i == to_read - 1 ) { ptr -> nameURN = tmpName ; ptr -> location = NULL ; return GF_OK ; } ptr -> nameURN = ( char * ) gf_malloc ( sizeof ( char ) * ( i + 1 ) ) ; if ( ! ptr -> nameURN ) { gf_free ( tmpName ) ; return GF_OUT_OF_MEM ; } ptr -> location = ( char * ) gf_malloc ( sizeof ( char ) * ( to_read - i - 1 ) ) ; if ( ! ptr -> location ) { gf_free ( tmpName ) ; gf_free ( ptr -> nameURN ) ; ptr -> nameURN = NULL ; return GF_OUT_OF_MEM ; } memcpy ( ptr -> nameURN , tmpName , i + 1 ) ; memcpy ( ptr -> location , tmpName + i + 1 , ( to_read - i - 1 ) ) ; gf_free ( tmpName ) ; return GF_OK ; }",while ( ( i < to_read ) && ( tmpName [ i ] != 0 ) ) {i ++ ;,2183
27,"buggy line: int err = 0 ;ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\\cwe id:CWE-362context: static int ext4_split_extent_at ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , ext4_lblk_t split , int split_flag , int flags ) { ext4_fsblk_t newblock ; ext4_lblk_t ee_block ; struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex2 = NULL ; unsigned int ee_len , depth ;  int err = 0 ;  ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\n"" , inode -> i_ino , ( unsigned long long ) split ) ; ext4_ext_show_leaf ( inode , path ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; newblock = split - ee_block + ext4_ext_pblock ( ex ) ; BUG_ON ( split < ee_block || split >= ( ee_block + ee_len ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( split == ee_block ) { if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) ext4_ext_mark_uninitialized ( ex ) ; else ext4_ext_mark_initialized ( ex ) ; if ( ! ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } memcpy ( & orig_ex , ex , sizeof ( orig_ex ) ) ; ex -> ee_len = cpu_to_le16 ( split - ee_block ) ; if ( split_flag & EXT4_EXT_MARK_UNINIT1 ) ext4_ext_mark_uninitialized ( ex ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto fix_extent_len ; ex2 = & newex ; ex2 -> ee_block = cpu_to_le32 ( split ) ; ex2 -> ee_len = cpu_to_le16 ( ee_len - ( split - ee_block ) ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) ext4_ext_mark_uninitialized ( ex2 ) ; err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err == - ENOSPC && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) {  err = ext4_ext_zeroout ( inode , & orig_ex ) ;  if ( err ) goto fix_extent_len ; ex -> ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; fix_extent_len : ex -> ee_len = orig_ex . ee_len ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }","int err = 0 ;BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) ;ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\\",2184
28,"buggy line: err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;cwe id:CWE-362context: static int ext4_split_extent_at ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , ext4_lblk_t split , int split_flag , int flags ) { ext4_fsblk_t newblock ; ext4_lblk_t ee_block ; struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex2 = NULL ; unsigned int ee_len , depth ;  int err = 0 ;  ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\n"" , inode -> i_ino , ( unsigned long long ) split ) ; ext4_ext_show_leaf ( inode , path ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; newblock = split - ee_block + ext4_ext_pblock ( ex ) ; BUG_ON ( split < ee_block || split >= ( ee_block + ee_len ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( split == ee_block ) { if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) ext4_ext_mark_uninitialized ( ex ) ; else ext4_ext_mark_initialized ( ex ) ; if ( ! ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } memcpy ( & orig_ex , ex , sizeof ( orig_ex ) ) ; ex -> ee_len = cpu_to_le16 ( split - ee_block ) ; if ( split_flag & EXT4_EXT_MARK_UNINIT1 ) ext4_ext_mark_uninitialized ( ex ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto fix_extent_len ; ex2 = & newex ; ex2 -> ee_block = cpu_to_le32 ( split ) ; ex2 -> ee_len = cpu_to_le16 ( ee_len - ( split - ee_block ) ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) ext4_ext_mark_uninitialized ( ex2 ) ; err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err == - ENOSPC && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) {  err = ext4_ext_zeroout ( inode , & orig_ex ) ;  if ( err ) goto fix_extent_len ; ex -> ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; fix_extent_len : ex -> ee_len = orig_ex . ee_len ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }","if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) {if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ;else err = ext4_ext_zeroout ( inode , ex ) ;}else err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;",2184
29,"buggy line: long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;cwe id:CWE-189context: static __inline__ void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ;  long rem ;   value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;  value -> tv_usec = rem / NSEC_PER_USEC ; }","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",2185
30,"buggy line: hndl = sock_diag_lock_handler ( req -> sdiag_family ) ;if ( hndl == NULL ) err = - ENOENT ;cwe id:CWE-20context: static int __sock_diag_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh ) { int err ; struct sock_diag_req * req = nlmsg_data ( nlh ) ; const struct sock_diag_handler * hndl ; if ( nlmsg_len ( nlh ) < sizeof ( * req ) ) return - EINVAL ;  hndl = sock_diag_lock_handler ( req -> sdiag_family ) ;  if ( hndl == NULL ) err = - ENOENT ; else err = hndl -> dump ( skb , nlh ) ; sock_diag_unlock_handler ( hndl ) ; return err ; }",if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;hndl = sock_diag_lock_handler ( req -> sdiag_family ) ;if ( hndl == NULL ) err = - ENOENT ;,2186
31,"buggy line: if ( sk -> sk_state & PPPOX_BOUND )  goto end ;msg -> msg_namelen = 0 ;cwe id:CWE-20context: static int pppol2tp_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int err ; struct sk_buff * skb ; struct sock * sk = sock -> sk ; err = - EIO ; if ( sk -> sk_state & PPPOX_BOUND )  goto end ;  msg -> msg_namelen = 0 ; err = 0 ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) goto end ; if ( len > skb -> len ) len = skb -> len ; else if ( len < skb -> len ) msg -> msg_flags |= MSG_TRUNC ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , len ) ; if ( likely ( err == 0 ) ) err = len ; kfree_skb ( skb ) ; end : return err ; }",if ( sk -> sk_state & PPPOX_BOUND ) goto end ;,2187
32,"buggy line: static void  l2tp_bearer_type_print ( netdissect_options * ndo , const u_char * dat )  {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_ANALOG_MASK ) {cwe id:CWE-125context: static void  l2tp_bearer_type_print ( netdissect_options * ndo , const u_char * dat )  {  const uint32_t * ptr = ( const uint32_t * ) dat ;  if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_ANALOG_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_DIGITAL_MASK ) { ND_PRINT ( ( ndo , ""D"" ) ) ; } }","static void l2tp_bearer_type_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_ANALOG_MASK ) {",2188
33,"buggy line: case 16 :  # line 94 ""hex_grammar.y""  {# line 1023 ""hex_grammar.c"" break ;case 17 :  # line 95 ""hex_grammar.y""  {# line 1029 ""hex_grammar.c"" break ;case 18 :  # line 96 ""hex_grammar.y""  {# line 1035 ""hex_grammar.c"" break ;case 19 :  # line 97 ""hex_grammar.y""  {# line 1041 ""hex_grammar.c"" break ;case 21 :  # line 100 ""hex_grammar.y""  {# line 1047 ""hex_grammar.c"" break ;case 22 :  # line 99 ""hex_grammar.y""  {# line 1053 ""hex_grammar.c"" break ;case 23 :  # line 98 ""hex_grammar.y""  {# line 1059 ""hex_grammar.c"" break ;cwe id:CWE-674context: static void yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = ""Deleting"" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 16 :  # line 94 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1023 ""hex_grammar.c"" break ; case 17 :  # line 95 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1029 ""hex_grammar.c"" break ; case 18 :  # line 96 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1035 ""hex_grammar.c"" break ; case 19 :  # line 97 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1041 ""hex_grammar.c"" break ; case 21 :  # line 100 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1047 ""hex_grammar.c"" break ; case 22 :  # line 99 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1053 ""hex_grammar.c"" break ; case 23 :  # line 98 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 ""hex_grammar.c"" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }","case 16 : # line 101 ""hex_grammar.y"" {# line 1030 ""hex_grammar.c"" break ;case 17 : # line 102 ""hex_grammar.y"" {# line 1036 ""hex_grammar.c"" break ;case 18 : # line 103 ""hex_grammar.y"" {# line 1042 ""hex_grammar.c"" break ;case 19 : # line 104 ""hex_grammar.y"" {# line 1048 ""hex_grammar.c"" break ;case 21 : # line 107 ""hex_grammar.y"" {# line 1054 ""hex_grammar.c"" break ;case 22 : # line 106 ""hex_grammar.y"" {# line 1060 ""hex_grammar.c"" break ;case 23 : # line 105 ""hex_grammar.y"" {# line 1066 ""hex_grammar.c"" break ;",2189
34,"buggy line: if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) {pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\\cwe id:CWE-125context: static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , const struct assoc_array_ops * ops , const void * index_key , struct assoc_array_walk_result * result ) { struct assoc_array_shortcut * shortcut , * new_s0 ; struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; struct assoc_array_ptr * ptr ; unsigned long dissimilarity , base_seg , blank ; size_t keylen ; bool have_meta ; int level , diff ; int slot , next_slot , free_slot , i , j ; node = result -> terminal_node . node ; level = result -> terminal_node . level ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; pr_devel ( ""-->%s()\\n"" , __func__ ) ; free_slot = - 1 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( ! ptr ) { free_slot = i ; continue ; }  if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) {  pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\n"" , i ) ; edit -> leaf_p = & node -> slots [ i ] ; edit -> dead_leaf = node -> slots [ i ] ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[replace]\\n"" , __func__ ) ; return true ; } } if ( free_slot >= 0 ) { pr_devel ( ""insert<S2SV_blank>in<S2SV_blank>free<S2SV_blank>slot<S2SV_blank>%d\\n"" , free_slot ) ; edit -> leaf_p = & node -> slots [ free_slot ] ; edit -> adjust_count_on = node ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert]\\n"" , __func__ ) ; return true ; } new_n0 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n0 ) return false ; edit -> new_meta [ 0 ] = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n1 ) return false ; edit -> new_meta [ 1 ] = assoc_array_node_to_ptr ( new_n1 ) ; pr_devel ( ""no<S2SV_blank>spare<S2SV_blank>slots\\n"" ) ; have_meta = false ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( assoc_array_ptr_is_meta ( ptr ) ) { edit -> segment_cache [ i ] = 0xff ; have_meta = true ; continue ; } base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } if ( have_meta ) { pr_devel ( ""have<S2SV_blank>meta\\n"" ) ; goto split_node ; } dissimilarity = 0 ; base_seg = edit -> segment_cache [ 0 ] ; for ( i = 1 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) dissimilarity |= edit -> segment_cache [ i ] ^ base_seg ; pr_devel ( ""only<S2SV_blank>leaves;<S2SV_blank>dissimilarity=%lx\\n"" , dissimilarity ) ; if ( ( dissimilarity & ASSOC_ARRAY_FAN_MASK ) == 0 ) { if ( ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ^ base_seg ) == 0 ) goto all_leaves_cluster_together ; goto present_leaves_cluster_but_not_new_leaf ; } split_node : pr_devel ( ""split<S2SV_blank>node\\n"" ) ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; do_split_node : pr_devel ( ""do_split_node\\n"" ) ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> nr_leaves_on_branch = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { slot = edit -> segment_cache [ i ] ; if ( slot != 0xff ) for ( j = i + 1 ; j < ASSOC_ARRAY_FAN_OUT + 1 ; j ++ ) if ( edit -> segment_cache [ j ] == slot ) goto found_slot_for_multiple_occupancy ; } found_slot_for_multiple_occupancy : pr_devel ( ""same<S2SV_blank>slot:<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>[%02x]\\n"" , i , j , slot ) ; BUG_ON ( i >= ASSOC_ARRAY_FAN_OUT ) ; BUG_ON ( j >= ASSOC_ARRAY_FAN_OUT + 1 ) ; BUG_ON ( slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n1 -> parent_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) new_n0 -> slots [ i ] = node -> slots [ i ] ; else new_n0 -> slots [ i ] = NULL ; BUG_ON ( new_n0 -> slots [ slot ] != NULL ) ; new_n0 -> slots [ slot ] = assoc_array_node_to_ptr ( new_n1 ) ; free_slot = - 1 ; next_slot = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) continue ; if ( edit -> segment_cache [ i ] == slot ) { new_n1 -> slots [ next_slot ++ ] = node -> slots [ i ] ; new_n1 -> nr_leaves_on_branch ++ ; } else { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; new_n0 -> slots [ free_slot ] = node -> slots [ i ] ; } } pr_devel ( ""filtered:<S2SV_blank>f=%x<S2SV_blank>n=%x\\n"" , free_slot , next_slot ) ; if ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] != slot ) { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; edit -> leaf_p = & new_n0 -> slots [ free_slot ] ; edit -> adjust_count_on = new_n0 ; } else { edit -> leaf_p = & new_n1 -> slots [ next_slot ++ ] ; edit -> adjust_count_on = new_n1 ; } BUG_ON ( next_slot <= 1 ) ; edit -> set_backpointers_to = assoc_array_node_to_ptr ( new_n0 ) ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( edit -> segment_cache [ i ] == 0xff ) { ptr = node -> slots [ i ] ; BUG_ON ( assoc_array_ptr_is_leaf ( ptr ) ) ; if ( assoc_array_ptr_is_node ( ptr ) ) { side = assoc_array_ptr_to_node ( ptr ) ; edit -> set_backpointers [ i ] = & side -> back_pointer ; } else { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; edit -> set_backpointers [ i ] = & shortcut -> back_pointer ; } } } ptr = node -> back_pointer ; if ( ! ptr ) edit -> set [ 0 ] . ptr = & edit -> array -> root ; else if ( assoc_array_ptr_is_node ( ptr ) ) edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( ptr ) -> slots [ node -> parent_slot ] ; else edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_shortcut ( ptr ) -> next_node ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[split<S2SV_blank>node]\\n"" , __func__ ) ; return true ; present_leaves_cluster_but_not_new_leaf : pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ; new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; edit -> adjust_count_on = new_n0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) new_n1 -> slots [ i ] = node -> slots [ i ] ; new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ; edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ; edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\n"" , __func__ ) ; return true ; all_leaves_cluster_together : pr_devel ( ""all<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>together\\n"" ) ; diff = INT_MAX ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { int x = ops -> diff_objects ( assoc_array_ptr_to_leaf ( node -> slots [ i ] ) , index_key ) ; if ( x < diff ) { BUG_ON ( x < 0 ) ; diff = x ; } } BUG_ON ( diff == INT_MAX ) ; BUG_ON ( diff < level + ASSOC_ARRAY_LEVEL_STEP ) ; keylen = round_up ( diff , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s0 = kzalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s0 ) return false ; edit -> new_meta [ 2 ] = assoc_array_shortcut_to_ptr ( new_s0 ) ; edit -> set [ 0 ] . to = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_s0 -> back_pointer = node -> back_pointer ; new_s0 -> parent_slot = node -> parent_slot ; new_s0 -> next_node = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_n0 -> parent_slot = 0 ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; new_s0 -> skip_to_level = level = diff & ~ ASSOC_ARRAY_LEVEL_STEP_MASK ; pr_devel ( ""skip_to_level<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[diff<S2SV_blank>%d]\\n"" , level , diff ) ; BUG_ON ( level <= 0 ) ; for ( i = 0 ; i < keylen ; i ++ ) new_s0 -> index_key [ i ] = ops -> get_key_chunk ( index_key , i * ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; blank = ULONG_MAX << ( level & ASSOC_ARRAY_KEY_CHUNK_MASK ) ; pr_devel ( ""blank<S2SV_blank>off<S2SV_blank>[%zu]<S2SV_blank>%d:<S2SV_blank>%lx\\n"" , keylen - 1 , level , blank ) ; new_s0 -> index_key [ keylen - 1 ] &= ~ blank ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } base_seg = ops -> get_key_chunk ( index_key , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = base_seg & ASSOC_ARRAY_FAN_MASK ; goto do_split_node ; }","if ( assoc_array_ptr_is_leaf ( ptr ) && ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) {pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\\",2190
35,"buggy line: if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) {return MSPACK_ERR_SEEK ;}}num_chunks = chm -> last_pmgl - x + 1 ;if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) {return MSPACK_ERR_NOMEMORY ;errors = 0 ;while ( num_chunks -- ) {if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) {sys -> free ( chunk ) ;return MSPACK_ERR_READ ;if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ;if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) {sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small"" ) ;if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) {sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ;}p = & chunk [ pmgl_Entries ] ;end = & chunk [ chm -> chunk_size - 2 ] ;num_entries = EndGetI16 ( end ) ;while ( num_entries -- ) {READ_ENCINT ( name_len ) ;if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ;name = p ;p += name_len ;READ_ENCINT ( section ) ;READ_ENCINT ( offset ) ;READ_ENCINT ( length ) ;if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ;if ( ( offset == 0 ) && ( length == 0 ) ) {if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == \'/\' ) ) continue ;}if ( section > 1 ) {sys -> message ( fh , ""invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\\\'%u\\\'."" , section ) ;continue ;}if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) {sys -> free ( chunk ) ;return MSPACK_ERR_NOMEMORY ;}fi -> next = NULL ;fi -> filename = ( char * ) & fi [ 1 ] ;fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ;fi -> offset = offset ;fi -> length = length ;sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ;fi -> filename [ name_len ] = \'\\\\0\' ;if ( name [ 0 ] == \':\' && name [ 1 ] == \':\' ) {if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) {if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . content = fi ;}else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) {chm -> sec1 . control = fi ;}else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . spaninfo = fi ;}}}cwe id:CWE-119context: static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mschmd_header * chm , int entire ) { unsigned int section , name_len , x , errors , num_chunks ; unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; struct mschmd_file * fi , * link = NULL ; off_t offset , length ; int num_entries ; chm -> files = NULL ; chm -> sysfiles = NULL ; chm -> chunk_cache = NULL ; chm -> sec0 . base . chm = chm ; chm -> sec0 . base . id = 0 ; chm -> sec1 . base . chm = chm ; chm -> sec1 . base . id = 1 ; chm -> sec1 . content = NULL ; chm -> sec1 . control = NULL ; chm -> sec1 . spaninfo = NULL ; chm -> sec1 . rtable = NULL ; if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { return MSPACK_ERR_READ ; } if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { return MSPACK_ERR_SIGNATURE ; } if ( memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { D ( ( ""incorrect<S2SV_blank>GUIDs"" ) ) return MSPACK_ERR_SIGNATURE ; } chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; if ( chm -> version > 3 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>CHM<S2SV_blank>version<S2SV_blank>><S2SV_blank>3"" ) ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { return MSPACK_ERR_READ ; } chm -> dir_offset = sys -> tell ( fh ) ; chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; if ( chm -> version < 3 ) { chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; } if ( chm -> sec0 . offset > chm -> length ) { D ( ( ""content<S2SV_blank>section<S2SV_blank>begins<S2SV_blank>after<S2SV_blank>file<S2SV_blank>has<S2SV_blank>ended"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { D ( ( ""chunk<S2SV_blank>size<S2SV_blank>not<S2SV_blank>large<S2SV_blank>enough"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks == 0 ) { D ( ( ""no<S2SV_blank>chunks"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks > 100000 ) { D ( ( ""more<S2SV_blank>than<S2SV_blank>100,000<S2SV_blank>chunks"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { D ( ( ""chunks<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>entire<S2SV_blank>file"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>two"" ) ; } if ( chm -> first_pmgl != 0 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>first<S2SV_blank>PMGL<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>not<S2SV_blank>zero"" ) ; } if ( chm -> first_pmgl > chm -> last_pmgl ) { D ( ( ""first<S2SV_blank>pmgl<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>after<S2SV_blank>last<S2SV_blank>pmgl<S2SV_blank>chunk"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root >= chm -> num_chunks ) { D ( ( ""index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ! entire ) { return MSPACK_ERR_OK ; } if ( ( x = chm -> first_pmgl ) != 0 ) { if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { return MSPACK_ERR_SEEK ; } } num_chunks = chm -> last_pmgl - x + 1 ; if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { return MSPACK_ERR_NOMEMORY ; } errors = 0 ; while ( num_chunks -- ) { if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { sys -> free ( chunk ) ; return MSPACK_ERR_READ ; } if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small"" ) ; } if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) { sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ; } p = & chunk [ pmgl_Entries ] ; end = & chunk [ chm -> chunk_size - 2 ] ; num_entries = EndGetI16 ( end ) ; while ( num_entries -- ) { READ_ENCINT ( name_len ) ; if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ; name = p ; p += name_len ; READ_ENCINT ( section ) ; READ_ENCINT ( offset ) ; READ_ENCINT ( length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ; if ( ( offset == 0 ) && ( length == 0 ) ) { if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; } if ( section > 1 ) { sys -> message ( fh , ""invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\'%u\'."" , section ) ; continue ; } if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { sys -> free ( chunk ) ; return MSPACK_ERR_NOMEMORY ; } fi -> next = NULL ; fi -> filename = ( char * ) & fi [ 1 ] ; fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; fi -> offset = offset ; fi -> length = length ; sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; fi -> filename [ name_len ] = '\\0' ; if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) {  if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) {   if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) {   chm -> sec1 . content = fi ;  }  else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) {   chm -> sec1 . control = fi ;  }  else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) {   chm -> sec1 . spaninfo = fi ;  } else if ( memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { chm -> sec1 . rtable = fi ;  }  } fi -> next = chm -> sysfiles ; chm -> sysfiles = fi ; } else { if ( link ) link -> next = fi ; else chm -> files = fi ; link = fi ; } } chunk_end : if ( num_entries >= 0 ) { D ( ( ""chunk<S2SV_blank>ended<S2SV_blank>before<S2SV_blank>all<S2SV_blank>entries<S2SV_blank>could<S2SV_blank>be<S2SV_blank>read"" ) ) errors ++ ; } } sys -> free ( chunk ) ; return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; }","if ( name_len == 40 && memcmp ( name , content_name , 40 ) == 0 ) {if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . content = fi ;else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) {chm -> sec1 . control = fi ;else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . spaninfo = fi ;}}",2191
36,"buggy line: const char * args [ 11 ] ;{cwe id:CWE-59context: int main ( int argc , char * * argv ) { setlocale ( LC_ALL , """" ) ; # if ENABLE_NLS bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; # endif abrt_init ( argv ) ; const char * program_usage_string = _ ( ""&<S2SV_blank>[-y]<S2SV_blank>[-i<S2SV_blank>BUILD_IDS_FILE|-i<S2SV_blank>-]<S2SV_blank>[-e<S2SV_blank>PATH[:PATH]...]\\n"" ""\\t[-r<S2SV_blank>REPO]\\n"" ""\\n"" ""Installs<S2SV_blank>debuginfo<S2SV_blank>packages<S2SV_blank>for<S2SV_blank>all<S2SV_blank>build-ids<S2SV_blank>listed<S2SV_blank>in<S2SV_blank>BUILD_IDS_FILE<S2SV_blank>to\\n"" ""ABRT<S2SV_blank>system<S2SV_blank>cache."" ) ; enum { OPT_v = 1 << 0 , OPT_y = 1 << 1 , OPT_i = 1 << 2 , OPT_e = 1 << 3 , OPT_r = 1 << 4 , OPT_s = 1 << 5 , } ; const char * build_ids = ""build_ids"" ; const char * exact = NULL ; const char * repo = NULL ; const char * size_mb = NULL ; struct options program_options [ ] = { OPT__VERBOSE ( & g_verbose ) , OPT_BOOL ( 'y' , ""yes"" , NULL , _ ( ""Noninteractive,<S2SV_blank>assume<S2SV_blank>\'Yes\'<S2SV_blank>to<S2SV_blank>all<S2SV_blank>questions"" ) ) , OPT_STRING ( 'i' , ""ids"" , & build_ids , ""BUILD_IDS_FILE"" , _ ( ""-<S2SV_blank>means<S2SV_blank>STDIN,<S2SV_blank>default:<S2SV_blank>build_ids"" ) ) , OPT_STRING ( 'e' , ""exact"" , & exact , ""EXACT"" , _ ( ""Download<S2SV_blank>only<S2SV_blank>specified<S2SV_blank>files"" ) ) , OPT_STRING ( 'r' , ""repo"" , & repo , ""REPO"" , _ ( ""Pattern<S2SV_blank>to<S2SV_blank>use<S2SV_blank>when<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>repos,<S2SV_blank>default:<S2SV_blank>*debug*"" ) ) , OPT_STRING ( 's' , ""size_mb"" , & size_mb , ""SIZE_MB"" , _ ( ""Ignored<S2SV_blank>option"" ) ) , OPT_END ( ) } ; const unsigned opts = parse_opts ( argc , argv , program_options , program_usage_string ) ; const gid_t egid = getegid ( ) ; const gid_t rgid = getgid ( ) ; const uid_t euid = geteuid ( ) ; const gid_t ruid = getuid ( ) ; char * build_ids_self_fd = NULL ; if ( strcmp ( ""-"" , build_ids ) != 0 ) { if ( setregid ( egid , rgid ) < 0 ) perror_msg_and_die ( ""setregid(egid,<S2SV_blank>rgid)"" ) ; if ( setreuid ( euid , ruid ) < 0 ) perror_msg_and_die ( ""setreuid(euid,<S2SV_blank>ruid)"" ) ; const int build_ids_fd = open ( build_ids , O_RDONLY ) ; if ( setregid ( rgid , egid ) < 0 ) perror_msg_and_die ( ""setregid(rgid,<S2SV_blank>egid)"" ) ; if ( setreuid ( ruid , euid ) < 0 ) perror_msg_and_die ( ""setreuid(ruid,<S2SV_blank>euid)"" ) ; if ( build_ids_fd < 0 ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'"" , build_ids ) ; build_ids_self_fd = xasprintf ( ""/proc/self/fd/%d"" , build_ids_fd ) ; }  const char * args [ 11 ] ;  { const char * verbs [ ] = { """" , ""-v"" , ""-vv"" , ""-vvv"" } ; unsigned i = 0 ; args [ i ++ ] = EXECUTABLE ; args [ i ++ ] = ""--ids"" ; args [ i ++ ] = ( build_ids_self_fd != NULL ) ? build_ids_self_fd : ""-"" ; if ( g_verbose > 0 ) args [ i ++ ] = verbs [ g_verbose <= 3 ? g_verbose : 3 ] ; if ( ( opts & OPT_y ) ) args [ i ++ ] = ""-y"" ; if ( ( opts & OPT_e ) ) { args [ i ++ ] = ""--exact"" ; args [ i ++ ] = exact ; } if ( ( opts & OPT_r ) ) { args [ i ++ ] = ""--repo"" ; args [ i ++ ] = repo ; }  args [ i ++ ] = ""--"" ;  args [ i ] = NULL ; } if ( egid != rgid ) IGNORE_RESULT ( setregid ( egid , egid ) ) ; if ( euid != ruid ) { IGNORE_RESULT ( setreuid ( euid , euid ) ) ; # if 1 static const char * whitelist [ ] = { ""REPORT_CLIENT_SLAVE"" , ""LANG"" , } ; const size_t wlsize = sizeof ( whitelist ) / sizeof ( char * ) ; char * setlist [ sizeof ( whitelist ) / sizeof ( char * ) ] = { 0 } ; char * p = NULL ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( ( p = getenv ( whitelist [ i ] ) ) != NULL ) setlist [ i ] = xstrdup ( p ) ; clearenv ( ) ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( setlist [ i ] != NULL ) { xsetenv ( whitelist [ i ] , setlist [ i ] ) ; free ( setlist [ i ] ) ; } # else static const char forbid [ ] = ""LD_LIBRARY_PATH"" ""\\0"" ""LD_PRELOAD"" ""\\0"" ""LD_TRACE_LOADED_OBJECTS"" ""\\0"" ""LD_BIND_NOW"" ""\\0"" ""LD_AOUT_LIBRARY_PATH"" ""\\0"" ""LD_AOUT_PRELOAD"" ""\\0"" ""LD_NOWARN"" ""\\0"" ""LD_KEEPDIR"" ""\\0"" ; const char * p = forbid ; do { unsetenv ( p ) ; p += strlen ( p ) + 1 ; } while ( * p ) ; # endif char path_env [ ] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:"" BIN_DIR "":"" SBIN_DIR ; if ( euid != 0 ) strcpy ( path_env , ""PATH=/usr/bin:/bin:"" BIN_DIR ) ; putenv ( path_env ) ; umask ( 0022 ) ; }  execvp ( EXECUTABLE , ( char * * ) args ) ;  error_msg_and_die ( ""Can\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;  } ","char tmp_directory [ ] = LARGE_DATA_TMP_DIR ""/abrt-tmp-debuginfo.XXXXXX"" ;if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ;log_info ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ;const char * args [ 13 ] ;{args [ i ++ ] = ""--tmpdir"" ;args [ i ++ ] = tmp_directory ;",2192
37,"buggy line: args [ i ++ ] = ""--"" ;args [ i ] = NULL ;cwe id:CWE-59context: int main ( int argc , char * * argv ) { setlocale ( LC_ALL , """" ) ; # if ENABLE_NLS bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; # endif abrt_init ( argv ) ; const char * program_usage_string = _ ( ""&<S2SV_blank>[-y]<S2SV_blank>[-i<S2SV_blank>BUILD_IDS_FILE|-i<S2SV_blank>-]<S2SV_blank>[-e<S2SV_blank>PATH[:PATH]...]\\n"" ""\\t[-r<S2SV_blank>REPO]\\n"" ""\\n"" ""Installs<S2SV_blank>debuginfo<S2SV_blank>packages<S2SV_blank>for<S2SV_blank>all<S2SV_blank>build-ids<S2SV_blank>listed<S2SV_blank>in<S2SV_blank>BUILD_IDS_FILE<S2SV_blank>to\\n"" ""ABRT<S2SV_blank>system<S2SV_blank>cache."" ) ; enum { OPT_v = 1 << 0 , OPT_y = 1 << 1 , OPT_i = 1 << 2 , OPT_e = 1 << 3 , OPT_r = 1 << 4 , OPT_s = 1 << 5 , } ; const char * build_ids = ""build_ids"" ; const char * exact = NULL ; const char * repo = NULL ; const char * size_mb = NULL ; struct options program_options [ ] = { OPT__VERBOSE ( & g_verbose ) , OPT_BOOL ( 'y' , ""yes"" , NULL , _ ( ""Noninteractive,<S2SV_blank>assume<S2SV_blank>\'Yes\'<S2SV_blank>to<S2SV_blank>all<S2SV_blank>questions"" ) ) , OPT_STRING ( 'i' , ""ids"" , & build_ids , ""BUILD_IDS_FILE"" , _ ( ""-<S2SV_blank>means<S2SV_blank>STDIN,<S2SV_blank>default:<S2SV_blank>build_ids"" ) ) , OPT_STRING ( 'e' , ""exact"" , & exact , ""EXACT"" , _ ( ""Download<S2SV_blank>only<S2SV_blank>specified<S2SV_blank>files"" ) ) , OPT_STRING ( 'r' , ""repo"" , & repo , ""REPO"" , _ ( ""Pattern<S2SV_blank>to<S2SV_blank>use<S2SV_blank>when<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>repos,<S2SV_blank>default:<S2SV_blank>*debug*"" ) ) , OPT_STRING ( 's' , ""size_mb"" , & size_mb , ""SIZE_MB"" , _ ( ""Ignored<S2SV_blank>option"" ) ) , OPT_END ( ) } ; const unsigned opts = parse_opts ( argc , argv , program_options , program_usage_string ) ; const gid_t egid = getegid ( ) ; const gid_t rgid = getgid ( ) ; const uid_t euid = geteuid ( ) ; const gid_t ruid = getuid ( ) ; char * build_ids_self_fd = NULL ; if ( strcmp ( ""-"" , build_ids ) != 0 ) { if ( setregid ( egid , rgid ) < 0 ) perror_msg_and_die ( ""setregid(egid,<S2SV_blank>rgid)"" ) ; if ( setreuid ( euid , ruid ) < 0 ) perror_msg_and_die ( ""setreuid(euid,<S2SV_blank>ruid)"" ) ; const int build_ids_fd = open ( build_ids , O_RDONLY ) ; if ( setregid ( rgid , egid ) < 0 ) perror_msg_and_die ( ""setregid(rgid,<S2SV_blank>egid)"" ) ; if ( setreuid ( ruid , euid ) < 0 ) perror_msg_and_die ( ""setreuid(ruid,<S2SV_blank>euid)"" ) ; if ( build_ids_fd < 0 ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'"" , build_ids ) ; build_ids_self_fd = xasprintf ( ""/proc/self/fd/%d"" , build_ids_fd ) ; }  const char * args [ 11 ] ;  { const char * verbs [ ] = { """" , ""-v"" , ""-vv"" , ""-vvv"" } ; unsigned i = 0 ; args [ i ++ ] = EXECUTABLE ; args [ i ++ ] = ""--ids"" ; args [ i ++ ] = ( build_ids_self_fd != NULL ) ? build_ids_self_fd : ""-"" ; if ( g_verbose > 0 ) args [ i ++ ] = verbs [ g_verbose <= 3 ? g_verbose : 3 ] ; if ( ( opts & OPT_y ) ) args [ i ++ ] = ""-y"" ; if ( ( opts & OPT_e ) ) { args [ i ++ ] = ""--exact"" ; args [ i ++ ] = exact ; } if ( ( opts & OPT_r ) ) { args [ i ++ ] = ""--repo"" ; args [ i ++ ] = repo ; }  args [ i ++ ] = ""--"" ;  args [ i ] = NULL ; } if ( egid != rgid ) IGNORE_RESULT ( setregid ( egid , egid ) ) ; if ( euid != ruid ) { IGNORE_RESULT ( setreuid ( euid , euid ) ) ; # if 1 static const char * whitelist [ ] = { ""REPORT_CLIENT_SLAVE"" , ""LANG"" , } ; const size_t wlsize = sizeof ( whitelist ) / sizeof ( char * ) ; char * setlist [ sizeof ( whitelist ) / sizeof ( char * ) ] = { 0 } ; char * p = NULL ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( ( p = getenv ( whitelist [ i ] ) ) != NULL ) setlist [ i ] = xstrdup ( p ) ; clearenv ( ) ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( setlist [ i ] != NULL ) { xsetenv ( whitelist [ i ] , setlist [ i ] ) ; free ( setlist [ i ] ) ; } # else static const char forbid [ ] = ""LD_LIBRARY_PATH"" ""\\0"" ""LD_PRELOAD"" ""\\0"" ""LD_TRACE_LOADED_OBJECTS"" ""\\0"" ""LD_BIND_NOW"" ""\\0"" ""LD_AOUT_LIBRARY_PATH"" ""\\0"" ""LD_AOUT_PRELOAD"" ""\\0"" ""LD_NOWARN"" ""\\0"" ""LD_KEEPDIR"" ""\\0"" ; const char * p = forbid ; do { unsetenv ( p ) ; p += strlen ( p ) + 1 ; } while ( * p ) ; # endif char path_env [ ] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:"" BIN_DIR "":"" SBIN_DIR ; if ( euid != 0 ) strcpy ( path_env , ""PATH=/usr/bin:/bin:"" BIN_DIR ) ; putenv ( path_env ) ; umask ( 0022 ) ; }  execvp ( EXECUTABLE , ( char * * ) args ) ;  error_msg_and_die ( ""Can\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;  } ","args [ i ++ ] = ""--"" ;args [ i ] = NULL ;",2192
38,"buggy line: cwe id:CWE-59context: int main ( int argc , char * * argv ) { setlocale ( LC_ALL , """" ) ; # if ENABLE_NLS bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; # endif abrt_init ( argv ) ; const char * program_usage_string = _ ( ""&<S2SV_blank>[-y]<S2SV_blank>[-i<S2SV_blank>BUILD_IDS_FILE|-i<S2SV_blank>-]<S2SV_blank>[-e<S2SV_blank>PATH[:PATH]...]\\n"" ""\\t[-r<S2SV_blank>REPO]\\n"" ""\\n"" ""Installs<S2SV_blank>debuginfo<S2SV_blank>packages<S2SV_blank>for<S2SV_blank>all<S2SV_blank>build-ids<S2SV_blank>listed<S2SV_blank>in<S2SV_blank>BUILD_IDS_FILE<S2SV_blank>to\\n"" ""ABRT<S2SV_blank>system<S2SV_blank>cache."" ) ; enum { OPT_v = 1 << 0 , OPT_y = 1 << 1 , OPT_i = 1 << 2 , OPT_e = 1 << 3 , OPT_r = 1 << 4 , OPT_s = 1 << 5 , } ; const char * build_ids = ""build_ids"" ; const char * exact = NULL ; const char * repo = NULL ; const char * size_mb = NULL ; struct options program_options [ ] = { OPT__VERBOSE ( & g_verbose ) , OPT_BOOL ( 'y' , ""yes"" , NULL , _ ( ""Noninteractive,<S2SV_blank>assume<S2SV_blank>\'Yes\'<S2SV_blank>to<S2SV_blank>all<S2SV_blank>questions"" ) ) , OPT_STRING ( 'i' , ""ids"" , & build_ids , ""BUILD_IDS_FILE"" , _ ( ""-<S2SV_blank>means<S2SV_blank>STDIN,<S2SV_blank>default:<S2SV_blank>build_ids"" ) ) , OPT_STRING ( 'e' , ""exact"" , & exact , ""EXACT"" , _ ( ""Download<S2SV_blank>only<S2SV_blank>specified<S2SV_blank>files"" ) ) , OPT_STRING ( 'r' , ""repo"" , & repo , ""REPO"" , _ ( ""Pattern<S2SV_blank>to<S2SV_blank>use<S2SV_blank>when<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>repos,<S2SV_blank>default:<S2SV_blank>*debug*"" ) ) , OPT_STRING ( 's' , ""size_mb"" , & size_mb , ""SIZE_MB"" , _ ( ""Ignored<S2SV_blank>option"" ) ) , OPT_END ( ) } ; const unsigned opts = parse_opts ( argc , argv , program_options , program_usage_string ) ; const gid_t egid = getegid ( ) ; const gid_t rgid = getgid ( ) ; const uid_t euid = geteuid ( ) ; const gid_t ruid = getuid ( ) ; char * build_ids_self_fd = NULL ; if ( strcmp ( ""-"" , build_ids ) != 0 ) { if ( setregid ( egid , rgid ) < 0 ) perror_msg_and_die ( ""setregid(egid,<S2SV_blank>rgid)"" ) ; if ( setreuid ( euid , ruid ) < 0 ) perror_msg_and_die ( ""setreuid(euid,<S2SV_blank>ruid)"" ) ; const int build_ids_fd = open ( build_ids , O_RDONLY ) ; if ( setregid ( rgid , egid ) < 0 ) perror_msg_and_die ( ""setregid(rgid,<S2SV_blank>egid)"" ) ; if ( setreuid ( ruid , euid ) < 0 ) perror_msg_and_die ( ""setreuid(ruid,<S2SV_blank>euid)"" ) ; if ( build_ids_fd < 0 ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'"" , build_ids ) ; build_ids_self_fd = xasprintf ( ""/proc/self/fd/%d"" , build_ids_fd ) ; }  const char * args [ 11 ] ;  { const char * verbs [ ] = { """" , ""-v"" , ""-vv"" , ""-vvv"" } ; unsigned i = 0 ; args [ i ++ ] = EXECUTABLE ; args [ i ++ ] = ""--ids"" ; args [ i ++ ] = ( build_ids_self_fd != NULL ) ? build_ids_self_fd : ""-"" ; if ( g_verbose > 0 ) args [ i ++ ] = verbs [ g_verbose <= 3 ? g_verbose : 3 ] ; if ( ( opts & OPT_y ) ) args [ i ++ ] = ""-y"" ; if ( ( opts & OPT_e ) ) { args [ i ++ ] = ""--exact"" ; args [ i ++ ] = exact ; } if ( ( opts & OPT_r ) ) { args [ i ++ ] = ""--repo"" ; args [ i ++ ] = repo ; }  args [ i ++ ] = ""--"" ;  args [ i ] = NULL ; } if ( egid != rgid ) IGNORE_RESULT ( setregid ( egid , egid ) ) ; if ( euid != ruid ) { IGNORE_RESULT ( setreuid ( euid , euid ) ) ; # if 1 static const char * whitelist [ ] = { ""REPORT_CLIENT_SLAVE"" , ""LANG"" , } ; const size_t wlsize = sizeof ( whitelist ) / sizeof ( char * ) ; char * setlist [ sizeof ( whitelist ) / sizeof ( char * ) ] = { 0 } ; char * p = NULL ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( ( p = getenv ( whitelist [ i ] ) ) != NULL ) setlist [ i ] = xstrdup ( p ) ; clearenv ( ) ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( setlist [ i ] != NULL ) { xsetenv ( whitelist [ i ] , setlist [ i ] ) ; free ( setlist [ i ] ) ; } # else static const char forbid [ ] = ""LD_LIBRARY_PATH"" ""\\0"" ""LD_PRELOAD"" ""\\0"" ""LD_TRACE_LOADED_OBJECTS"" ""\\0"" ""LD_BIND_NOW"" ""\\0"" ""LD_AOUT_LIBRARY_PATH"" ""\\0"" ""LD_AOUT_PRELOAD"" ""\\0"" ""LD_NOWARN"" ""\\0"" ""LD_KEEPDIR"" ""\\0"" ; const char * p = forbid ; do { unsetenv ( p ) ; p += strlen ( p ) + 1 ; } while ( * p ) ; # endif char path_env [ ] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:"" BIN_DIR "":"" SBIN_DIR ; if ( euid != 0 ) strcpy ( path_env , ""PATH=/usr/bin:/bin:"" BIN_DIR ) ; putenv ( path_env ) ; umask ( 0022 ) ; }  execvp ( EXECUTABLE , ( char * * ) args ) ;  error_msg_and_die ( ""Can\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;  } ","pid_t pid = fork ( ) ;if ( pid < 0 ) perror_msg_and_die ( ""fork"" ) ;if ( pid == 0 ) {",2192
39,"buggy line: execvp ( EXECUTABLE , ( char * * ) args ) ;error_msg_and_die ( ""Can\\\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;}cwe id:CWE-59context: int main ( int argc , char * * argv ) { setlocale ( LC_ALL , """" ) ; # if ENABLE_NLS bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; # endif abrt_init ( argv ) ; const char * program_usage_string = _ ( ""&<S2SV_blank>[-y]<S2SV_blank>[-i<S2SV_blank>BUILD_IDS_FILE|-i<S2SV_blank>-]<S2SV_blank>[-e<S2SV_blank>PATH[:PATH]...]\\n"" ""\\t[-r<S2SV_blank>REPO]\\n"" ""\\n"" ""Installs<S2SV_blank>debuginfo<S2SV_blank>packages<S2SV_blank>for<S2SV_blank>all<S2SV_blank>build-ids<S2SV_blank>listed<S2SV_blank>in<S2SV_blank>BUILD_IDS_FILE<S2SV_blank>to\\n"" ""ABRT<S2SV_blank>system<S2SV_blank>cache."" ) ; enum { OPT_v = 1 << 0 , OPT_y = 1 << 1 , OPT_i = 1 << 2 , OPT_e = 1 << 3 , OPT_r = 1 << 4 , OPT_s = 1 << 5 , } ; const char * build_ids = ""build_ids"" ; const char * exact = NULL ; const char * repo = NULL ; const char * size_mb = NULL ; struct options program_options [ ] = { OPT__VERBOSE ( & g_verbose ) , OPT_BOOL ( 'y' , ""yes"" , NULL , _ ( ""Noninteractive,<S2SV_blank>assume<S2SV_blank>\'Yes\'<S2SV_blank>to<S2SV_blank>all<S2SV_blank>questions"" ) ) , OPT_STRING ( 'i' , ""ids"" , & build_ids , ""BUILD_IDS_FILE"" , _ ( ""-<S2SV_blank>means<S2SV_blank>STDIN,<S2SV_blank>default:<S2SV_blank>build_ids"" ) ) , OPT_STRING ( 'e' , ""exact"" , & exact , ""EXACT"" , _ ( ""Download<S2SV_blank>only<S2SV_blank>specified<S2SV_blank>files"" ) ) , OPT_STRING ( 'r' , ""repo"" , & repo , ""REPO"" , _ ( ""Pattern<S2SV_blank>to<S2SV_blank>use<S2SV_blank>when<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>repos,<S2SV_blank>default:<S2SV_blank>*debug*"" ) ) , OPT_STRING ( 's' , ""size_mb"" , & size_mb , ""SIZE_MB"" , _ ( ""Ignored<S2SV_blank>option"" ) ) , OPT_END ( ) } ; const unsigned opts = parse_opts ( argc , argv , program_options , program_usage_string ) ; const gid_t egid = getegid ( ) ; const gid_t rgid = getgid ( ) ; const uid_t euid = geteuid ( ) ; const gid_t ruid = getuid ( ) ; char * build_ids_self_fd = NULL ; if ( strcmp ( ""-"" , build_ids ) != 0 ) { if ( setregid ( egid , rgid ) < 0 ) perror_msg_and_die ( ""setregid(egid,<S2SV_blank>rgid)"" ) ; if ( setreuid ( euid , ruid ) < 0 ) perror_msg_and_die ( ""setreuid(euid,<S2SV_blank>ruid)"" ) ; const int build_ids_fd = open ( build_ids , O_RDONLY ) ; if ( setregid ( rgid , egid ) < 0 ) perror_msg_and_die ( ""setregid(rgid,<S2SV_blank>egid)"" ) ; if ( setreuid ( ruid , euid ) < 0 ) perror_msg_and_die ( ""setreuid(ruid,<S2SV_blank>euid)"" ) ; if ( build_ids_fd < 0 ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'"" , build_ids ) ; build_ids_self_fd = xasprintf ( ""/proc/self/fd/%d"" , build_ids_fd ) ; }  const char * args [ 11 ] ;  { const char * verbs [ ] = { """" , ""-v"" , ""-vv"" , ""-vvv"" } ; unsigned i = 0 ; args [ i ++ ] = EXECUTABLE ; args [ i ++ ] = ""--ids"" ; args [ i ++ ] = ( build_ids_self_fd != NULL ) ? build_ids_self_fd : ""-"" ; if ( g_verbose > 0 ) args [ i ++ ] = verbs [ g_verbose <= 3 ? g_verbose : 3 ] ; if ( ( opts & OPT_y ) ) args [ i ++ ] = ""-y"" ; if ( ( opts & OPT_e ) ) { args [ i ++ ] = ""--exact"" ; args [ i ++ ] = exact ; } if ( ( opts & OPT_r ) ) { args [ i ++ ] = ""--repo"" ; args [ i ++ ] = repo ; }  args [ i ++ ] = ""--"" ;  args [ i ] = NULL ; } if ( egid != rgid ) IGNORE_RESULT ( setregid ( egid , egid ) ) ; if ( euid != ruid ) { IGNORE_RESULT ( setreuid ( euid , euid ) ) ; # if 1 static const char * whitelist [ ] = { ""REPORT_CLIENT_SLAVE"" , ""LANG"" , } ; const size_t wlsize = sizeof ( whitelist ) / sizeof ( char * ) ; char * setlist [ sizeof ( whitelist ) / sizeof ( char * ) ] = { 0 } ; char * p = NULL ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( ( p = getenv ( whitelist [ i ] ) ) != NULL ) setlist [ i ] = xstrdup ( p ) ; clearenv ( ) ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( setlist [ i ] != NULL ) { xsetenv ( whitelist [ i ] , setlist [ i ] ) ; free ( setlist [ i ] ) ; } # else static const char forbid [ ] = ""LD_LIBRARY_PATH"" ""\\0"" ""LD_PRELOAD"" ""\\0"" ""LD_TRACE_LOADED_OBJECTS"" ""\\0"" ""LD_BIND_NOW"" ""\\0"" ""LD_AOUT_LIBRARY_PATH"" ""\\0"" ""LD_AOUT_PRELOAD"" ""\\0"" ""LD_NOWARN"" ""\\0"" ""LD_KEEPDIR"" ""\\0"" ; const char * p = forbid ; do { unsetenv ( p ) ; p += strlen ( p ) + 1 ; } while ( * p ) ; # endif char path_env [ ] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:"" BIN_DIR "":"" SBIN_DIR ; if ( euid != 0 ) strcpy ( path_env , ""PATH=/usr/bin:/bin:"" BIN_DIR ) ; putenv ( path_env ) ; umask ( 0022 ) ; }  execvp ( EXECUTABLE , ( char * * ) args ) ;  error_msg_and_die ( ""Can\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;  } ","int status ;if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( ""waitpid"" ) ;if ( rmdir ( tmp_directory ) >= 0 ) log_info ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ;else if ( errno != ENOENT ) perror_msg ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ;if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ;if ( WIFSIGNALED ( status ) ) error_msg_and_die ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , WTERMSIG ( status ) ) ;error_msg_and_die ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ;}execvp ( EXECUTABLE , ( char * * ) args ) ;error_msg_and_die ( ""Can\\\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;}",2192
40,"buggy line: newinet -> inet_daddr = ireq -> rmt_addr ;newinet -> opt = ireq -> opt ;ireq -> opt = NULL ;cwe id:CWE-362context: struct sock * dccp_v4_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet_request_sock * ireq ; struct inet_sock * newinet ; struct sock * newsk ; if ( sk_acceptq_is_full ( sk ) ) goto exit_overflow ; if ( dst == NULL && ( dst = inet_csk_route_req ( sk , req ) ) == NULL ) goto exit ; newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto exit_nonewsk ; sk_setup_caps ( newsk , dst ) ; newinet = inet_sk ( newsk ) ; ireq = inet_rsk ( req ) ; newinet -> inet_daddr = ireq -> rmt_addr ; newinet -> inet_rcv_saddr = ireq -> loc_addr ; newinet -> inet_saddr = ireq -> loc_addr ;  newinet -> opt = ireq -> opt ;  ireq -> opt = NULL ; newinet -> mc_index = inet_iif ( skb ) ; newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ; newinet -> inet_id = jiffies ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto exit ; } __inet_hash_nolisten ( newsk , NULL ) ; return newsk ; exit_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; exit_nonewsk : dst_release ( dst ) ; exit : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }",newinet -> inet_opt = ireq -> rmt_addr ;newinet -> opt = ireq -> opt ;ireq -> opt = NULL ;,2193
41,"buggy line: if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p - addr_len - ETHERTYPE_LEN , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ;cwe id:CWE-125context: u_int fr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { int ret ; uint16_t extracted_ethertype ; u_int dlci ; u_int addr_len ; uint16_t nlpid ; u_int hdr_len ; uint8_t flags [ 4 ] ; ret = parse_q922_addr ( ndo , p , & dlci , & addr_len , flags , length ) ; if ( ret == - 1 ) goto trunc ; if ( ret == 0 ) { ND_PRINT ( ( ndo , ""Q.922,<S2SV_blank>invalid<S2SV_blank>address"" ) ) ; return 0 ; } ND_TCHECK ( p [ addr_len ] ) ; if ( length < addr_len + 1 ) goto trunc ; if ( p [ addr_len ] != LLC_UI && dlci != 0 ) { if ( ! ND_TTEST2 ( p [ addr_len ] , 2 ) || length < addr_len + 2 ) { ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ; } else { extracted_ethertype = EXTRACT_16BITS ( p + addr_len ) ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , extracted_ethertype ) ; if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p - addr_len - ETHERTYPE_LEN , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ; else return addr_len + 2 ; } } ND_TCHECK ( p [ addr_len + 1 ] ) ; if ( length < addr_len + 2 ) goto trunc ; if ( p [ addr_len + 1 ] == 0 ) { if ( addr_len != 3 ) ND_PRINT ( ( ndo , ""Pad!<S2SV_blank>"" ) ) ; hdr_len = addr_len + 1 + 1 + 1 ; } else { if ( addr_len == 3 ) ND_PRINT ( ( ndo , ""No<S2SV_blank>pad!<S2SV_blank>"" ) ) ; hdr_len = addr_len + 1 + 1 ; } ND_TCHECK ( p [ hdr_len - 1 ] ) ; if ( length < hdr_len ) goto trunc ; nlpid = p [ hdr_len - 1 ] ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , nlpid ) ; p += hdr_len ; length -= hdr_len ; switch ( nlpid ) { case NLPID_IP : ip_print ( ndo , p , length ) ; break ; case NLPID_IP6 : ip6_print ( ndo , p , length ) ; break ; case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS :  isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ;  break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length , ndo -> ndo_snapend - p , NULL , NULL , 0 ) == 0 ) { if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , hdr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p - hdr_len , length + hdr_len ) ; } break ; case NLPID_Q933 : q933_print ( ndo , p , length ) ; break ; case NLPID_MFR : frf15_print ( ndo , p , length ) ; break ; case NLPID_PPP : ppp_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , addr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_xflag ) ND_DEFAULTPRINT ( p , length ) ; } return hdr_len ; trunc : ND_PRINT ( ( ndo , ""[|fr]"" ) ) ; return 0 ; }","if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ;",2194
42,"buggy line: case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS :  isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ;break ;cwe id:CWE-125context: u_int fr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { int ret ; uint16_t extracted_ethertype ; u_int dlci ; u_int addr_len ; uint16_t nlpid ; u_int hdr_len ; uint8_t flags [ 4 ] ; ret = parse_q922_addr ( ndo , p , & dlci , & addr_len , flags , length ) ; if ( ret == - 1 ) goto trunc ; if ( ret == 0 ) { ND_PRINT ( ( ndo , ""Q.922,<S2SV_blank>invalid<S2SV_blank>address"" ) ) ; return 0 ; } ND_TCHECK ( p [ addr_len ] ) ; if ( length < addr_len + 1 ) goto trunc ; if ( p [ addr_len ] != LLC_UI && dlci != 0 ) { if ( ! ND_TTEST2 ( p [ addr_len ] , 2 ) || length < addr_len + 2 ) { ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ; } else { extracted_ethertype = EXTRACT_16BITS ( p + addr_len ) ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , extracted_ethertype ) ; if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p - addr_len - ETHERTYPE_LEN , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ; else return addr_len + 2 ; } } ND_TCHECK ( p [ addr_len + 1 ] ) ; if ( length < addr_len + 2 ) goto trunc ; if ( p [ addr_len + 1 ] == 0 ) { if ( addr_len != 3 ) ND_PRINT ( ( ndo , ""Pad!<S2SV_blank>"" ) ) ; hdr_len = addr_len + 1 + 1 + 1 ; } else { if ( addr_len == 3 ) ND_PRINT ( ( ndo , ""No<S2SV_blank>pad!<S2SV_blank>"" ) ) ; hdr_len = addr_len + 1 + 1 ; } ND_TCHECK ( p [ hdr_len - 1 ] ) ; if ( length < hdr_len ) goto trunc ; nlpid = p [ hdr_len - 1 ] ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , nlpid ) ; p += hdr_len ; length -= hdr_len ; switch ( nlpid ) { case NLPID_IP : ip_print ( ndo , p , length ) ; break ; case NLPID_IP6 : ip6_print ( ndo , p , length ) ; break ; case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS :  isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ;  break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length , ndo -> ndo_snapend - p , NULL , NULL , 0 ) == 0 ) { if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , hdr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p - hdr_len , length + hdr_len ) ; } break ; case NLPID_Q933 : q933_print ( ndo , p , length ) ; break ; case NLPID_MFR : frf15_print ( ndo , p , length ) ; break ; case NLPID_PPP : ppp_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , addr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_xflag ) ND_DEFAULTPRINT ( p , length ) ; } return hdr_len ; trunc : ND_PRINT ( ( ndo , ""[|fr]"" ) ) ; return 0 ; }","case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS : isoclns_print ( ndo , p - 1 , length + 1 ) ;break ;case NLPID_SNAP : if ( snap_print ( ndo , p , length , ndo -> ndo_snapend - p + 1 ) ;break ;",2194
43,"buggy line: return 1 ;}cwe id:CWE-295context: int luaopen_x509 ( lua_State * L ) { auxiliar_newclass ( L , ""openssl.x509"" , x509_funcs ) ; lua_newtable ( L ) ; luaL_setfuncs ( L , R , 0 ) ; openssl_register_xname ( L ) ; lua_setfield ( L , - 2 , ""name"" ) ; openssl_register_xattribute ( L ) ; lua_setfield ( L , - 2 , ""attribute"" ) ; openssl_register_xextension ( L ) ; lua_setfield ( L , - 2 , ""extension"" ) ; openssl_register_xstore ( L ) ; lua_setfield ( L , - 2 , ""store"" ) ; openssl_register_xalgor ( L ) ; lua_setfield ( L , - 2 , ""algor"" ) ; luaopen_x509_req ( L ) ; lua_setfield ( L , - 2 , ""req"" ) ; luaopen_x509_crl ( L ) ; lua_setfield ( L , - 2 , ""crl"" ) ; lua_pushliteral ( L , ""version"" ) ; lua_pushliteral ( L , MYVERSION ) ; lua_settable ( L , - 3 ) ;  return 1 ;  }","# if OPENSSL_VERSION_NUMBER > 0x10002000L lua_pushliteral ( L , ""check_flag"" ) ;lua_newtable ( L ) ;auxiliar_enumerate ( L , - 1 , check_flags_const ) ;lua_settable ( L , - 3 ) ;# endif return 1 ;}",2195
44,"buggy line: struct perf_event_context * ctx = event -> ctx ;struct task_struct * task = ctx -> task ;if ( ! task ) {cpu_function_call ( event -> cpu , __perf_event_enable , event ) ;return ;raw_spin_lock_irq ( & ctx -> lock ) ;if ( event -> state >= PERF_EVENT_STATE_INACTIVE ) goto out ;if ( event -> state == PERF_EVENT_STATE_ERROR ) event -> state = PERF_EVENT_STATE_OFF ;retry : if ( ! ctx -> is_active ) {__perf_event_mark_enabled ( event ) ;goto out ;}cwe id:CWE-264context: void perf_event_enable ( struct perf_event * event ) {  struct perf_event_context * ctx = event -> ctx ;  struct task_struct * task = ctx -> task ; if ( ! task ) { cpu_function_call ( event -> cpu , __perf_event_enable , event ) ; return ; } raw_spin_lock_irq ( & ctx -> lock ) ; if ( event -> state >= PERF_EVENT_STATE_INACTIVE ) goto out ; if ( event -> state == PERF_EVENT_STATE_ERROR ) event -> state = PERF_EVENT_STATE_OFF ; retry : if ( ! ctx -> is_active ) { __perf_event_mark_enabled ( event ) ;  goto out ;  } raw_spin_unlock_irq ( & ctx -> lock ) ; if ( ! task_function_call ( task , __perf_event_enable , event ) ) return ; raw_spin_lock_irq ( & ctx -> lock ) ; if ( ctx -> is_active && event -> state == PERF_EVENT_STATE_OFF ) { task = ctx -> task ; goto retry ; } out : raw_spin_unlock_irq ( & ctx -> lock ) ; }",struct perf_event_context * ctx ;ctx = perf_event_ctx_lock ( event ) ;goto out ;,2196
45,"buggy line: static int  validate_event ( struct pmu_hw_events * hw_events ,  struct perf_event * event ) {struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ;struct hw_perf_event fake_event = event -> hw ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF )  return 1 ;return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;}cwe id:CWE-264context: static int  validate_event ( struct pmu_hw_events * hw_events ,  struct perf_event * event ) {  struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ;  struct hw_perf_event fake_event = event -> hw ; struct pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1 ;  if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF )  return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ;  return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;  }","static int validate_event ( struct pmu * pmu , struct pmu_hw_events * hw_events , struct perf_event * event ) {struct arm_pmu * armpmu ;struct hw_perf_event fake_event = event -> hw ;if ( event -> pmu != pmu ) return 0 ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;armpmu = to_arm_pmu ( event -> pmu ) ;return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;}",2197
46,"buggy line: BOOL ret = FALSE ;WCHAR * data = NULL ;goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}data = NULL ;ret = TRUE ;out : free ( data ) ;return ret ;}cwe id:CWE-415context: static BOOL GetStartupData ( HANDLE pipe , STARTUP_DATA * sud ) { size_t size , len ;  BOOL ret = FALSE ;  WCHAR * data = NULL ; DWORD bytes , read ; bytes = PeekNamedPipeAsync ( pipe , 1 , & exit_event ) ; if ( bytes == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( ""PeekNamedPipeAsync<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""PeekNamedPipeAsync"" ) ;  goto out ;  } size = bytes / sizeof ( * data ) ; if ( size == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( ""malformed<S2SV_blank>startup<S2SV_blank>data:<S2SV_blank>1<S2SV_blank>byte<S2SV_blank>received"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ;  goto out ;  } data = malloc ( bytes ) ; if ( data == NULL ) { MsgToEventLog ( M_SYSERR , TEXT ( ""malloc<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""malloc"" ) ;  goto out ;  } read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ; if ( bytes != read ) { MsgToEventLog ( M_SYSERR , TEXT ( ""ReadPipeAsync<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""ReadPipeAsync"" ) ;  goto out ;  } if ( data [ size - 1 ] != 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>is<S2SV_blank>not<S2SV_blank>NULL<S2SV_blank>terminated"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ;  goto out ;  } sud -> directory = data ; len = wcslen ( sud -> directory ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>working<S2SV_blank>directory"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ;  goto out ;  } sud -> options = sud -> directory + len ; len = wcslen ( sud -> options ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>command<S2SV_blank>line<S2SV_blank>options"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ;  goto out ;  } sud -> std_input = sud -> options + len ;  data = NULL ;   ret = TRUE ;  out : free ( data ) ;  return ret ;  }",WCHAR * data = NULL ;goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}return TRUE ;err : sud -> directory = NULL ;free ( data ) ;return FALSE ;},2198
47,"buggy line: u8 opcode = BPF_OP ( insn -> code ) ;dst_reg = & regs [ dst ] ;cwe id:CWE-189context: static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_func_state * state = vstate -> frame [ vstate -> curframe ] ; struct bpf_reg_state * regs = state -> regs , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u32 dst = insn -> dst_reg , src = insn -> src_reg ;  u8 opcode = BPF_OP ( insn -> code ) ;  dst_reg = & regs [ dst ] ; if ( ( known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } switch ( ptr_reg -> type ) { case PTR_TO_MAP_VALUE_OR_NULL : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case CONST_PTR_TO_MAP : case PTR_TO_PACKET_END : case PTR_TO_SOCKET : case PTR_TO_SOCKET_OR_NULL : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited\\n"" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case PTR_TO_MAP_VALUE : if ( ! env -> allow_ptr_leaks && ! known && ( smin_val < 0 ) != ( smax_val < 0 ) ) { verbose ( env , ""R%d<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>scalar<S2SV_blank>with<S2SV_blank>mixed<S2SV_blank>signed<S2SV_blank>bounds,<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>it<S2SV_blank>prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , off_reg == dst_reg ? dst : src ) ; return - EACCES ; } default : break ; } dst_reg -> type = ptr_reg -> type ; dst_reg -> id = ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL ; switch ( opcode ) { case BPF_ADD :  if ( known && ( ptr_reg -> off + smin_val ==  ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> raw = 0 ; } break ; case BPF_SUB :  if ( dst_reg == off_reg ) {  verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> raw = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; __update_reg_bounds ( dst_reg ) ; __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; if ( ! env -> allow_ptr_leaks ) { if ( dst_reg -> type == PTR_TO_MAP_VALUE && check_map_access ( env , dst , dst_reg -> off , 1 , false ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>of<S2SV_blank>map<S2SV_blank>value<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>"" ""prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , dst ) ; return - EACCES ; } else if ( dst_reg -> type == PTR_TO_STACK && check_stack_access ( env , dst_reg , dst_reg -> off + dst_reg -> var_off . value , 1 ) ) { verbose ( env , ""R%d<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>"" ""prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , dst ) ; return - EACCES ; } } return 0 ; }",u8 opcode = BPF_OP ( insn -> code ) ;int ret ;dst_reg = & regs [ dst ] ;,2199
48,"buggy line: case BPF_ADD :  if ( known && ( ptr_reg -> off + smin_val ==  ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) {cwe id:CWE-189context: static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_func_state * state = vstate -> frame [ vstate -> curframe ] ; struct bpf_reg_state * regs = state -> regs , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u32 dst = insn -> dst_reg , src = insn -> src_reg ;  u8 opcode = BPF_OP ( insn -> code ) ;  dst_reg = & regs [ dst ] ; if ( ( known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } switch ( ptr_reg -> type ) { case PTR_TO_MAP_VALUE_OR_NULL : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case CONST_PTR_TO_MAP : case PTR_TO_PACKET_END : case PTR_TO_SOCKET : case PTR_TO_SOCKET_OR_NULL : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited\\n"" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case PTR_TO_MAP_VALUE : if ( ! env -> allow_ptr_leaks && ! known && ( smin_val < 0 ) != ( smax_val < 0 ) ) { verbose ( env , ""R%d<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>scalar<S2SV_blank>with<S2SV_blank>mixed<S2SV_blank>signed<S2SV_blank>bounds,<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>it<S2SV_blank>prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , off_reg == dst_reg ? dst : src ) ; return - EACCES ; } default : break ; } dst_reg -> type = ptr_reg -> type ; dst_reg -> id = ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL ; switch ( opcode ) { case BPF_ADD :  if ( known && ( ptr_reg -> off + smin_val ==  ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> raw = 0 ; } break ; case BPF_SUB :  if ( dst_reg == off_reg ) {  verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> raw = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; __update_reg_bounds ( dst_reg ) ; __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; if ( ! env -> allow_ptr_leaks ) { if ( dst_reg -> type == PTR_TO_MAP_VALUE && check_map_access ( env , dst , dst_reg -> off , 1 , false ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>of<S2SV_blank>map<S2SV_blank>value<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>"" ""prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , dst ) ; return - EACCES ; } else if ( dst_reg -> type == PTR_TO_STACK && check_stack_access ( env , dst_reg , dst_reg -> off + dst_reg -> var_off . value , 1 ) ) { verbose ( env , ""R%d<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>"" ""prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , dst ) ; return - EACCES ; } } return 0 ; }","case BPF_ADD : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\\return ret ;}if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) {",2199
49,"buggy line: case BPF_SUB :  if ( dst_reg == off_reg ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\\cwe id:CWE-189context: static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_func_state * state = vstate -> frame [ vstate -> curframe ] ; struct bpf_reg_state * regs = state -> regs , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u32 dst = insn -> dst_reg , src = insn -> src_reg ;  u8 opcode = BPF_OP ( insn -> code ) ;  dst_reg = & regs [ dst ] ; if ( ( known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } switch ( ptr_reg -> type ) { case PTR_TO_MAP_VALUE_OR_NULL : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case CONST_PTR_TO_MAP : case PTR_TO_PACKET_END : case PTR_TO_SOCKET : case PTR_TO_SOCKET_OR_NULL : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited\\n"" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case PTR_TO_MAP_VALUE : if ( ! env -> allow_ptr_leaks && ! known && ( smin_val < 0 ) != ( smax_val < 0 ) ) { verbose ( env , ""R%d<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>scalar<S2SV_blank>with<S2SV_blank>mixed<S2SV_blank>signed<S2SV_blank>bounds,<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>it<S2SV_blank>prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , off_reg == dst_reg ? dst : src ) ; return - EACCES ; } default : break ; } dst_reg -> type = ptr_reg -> type ; dst_reg -> id = ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL ; switch ( opcode ) { case BPF_ADD :  if ( known && ( ptr_reg -> off + smin_val ==  ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> raw = 0 ; } break ; case BPF_SUB :  if ( dst_reg == off_reg ) {  verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> raw = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; __update_reg_bounds ( dst_reg ) ; __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; if ( ! env -> allow_ptr_leaks ) { if ( dst_reg -> type == PTR_TO_MAP_VALUE && check_map_access ( env , dst , dst_reg -> off , 1 , false ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>of<S2SV_blank>map<S2SV_blank>value<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>"" ""prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , dst ) ; return - EACCES ; } else if ( dst_reg -> type == PTR_TO_STACK && check_stack_access ( env , dst_reg , dst_reg -> off + dst_reg -> var_off . value , 1 ) ) { verbose ( env , ""R%d<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>"" ""prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , dst ) ; return - EACCES ; } } return 0 ; }","case BPF_SUB : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\\return ret ;}if ( dst_reg == off_reg ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\\",2199
50,"buggy line: struct mb_cache_entry * ce = NULL ;int error = 0 ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;# define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ;ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev ,  bs -> bh -> b_blocknr ) ;if ( ce ) {mb_cache_entry_free ( ce ) ;ce = NULL ;}}unlock_buffer ( bs -> bh ) ;if ( error == - EFSCORRUPTED ) goto bad_block ;if ( ! error ) error = ext4_handle_dirty_xattr_block ( handle , inode , bs -> bh ) ;if ( error ) goto cleanup ;goto inserted ;}else {int offset = ( char * ) s -> here - bs -> bh -> b_data ;unlock_buffer ( bs -> bh ) ;if ( ce ) {mb_cache_entry_release ( ce ) ;ce = NULL ;}cwe id:CWE-19context: static int ext4_xattr_block_set ( handle_t * handle , struct inode * inode , struct ext4_xattr_info * i , struct ext4_xattr_block_find * bs ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; struct ext4_xattr_search * s = & bs -> s ;  struct mb_cache_entry * ce = NULL ;  int error = 0 ;  struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;  # define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ; if ( s -> base ) {  ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev ,  bs -> bh -> b_blocknr ) ; BUFFER_TRACE ( bs -> bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , bs -> bh ) ; if ( error ) goto cleanup ; lock_buffer ( bs -> bh ) ; if ( header ( s -> base ) -> h_refcount == cpu_to_le32 ( 1 ) ) {  if ( ce ) {  mb_cache_entry_free ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , ""modifying<S2SV_blank>in-place"" ) ; error = ext4_xattr_set_entry ( i , s ) ; if ( ! error ) { if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; ext4_xattr_cache_insert ( ext4_mb_cache , bs -> bh ) ; } unlock_buffer ( bs -> bh ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( ! error ) error = ext4_handle_dirty_xattr_block ( handle , inode , bs -> bh ) ; if ( error ) goto cleanup ; goto inserted ; } else { int offset = ( char * ) s -> here - bs -> bh -> b_data ; unlock_buffer ( bs -> bh ) ;  if ( ce ) {  mb_cache_entry_release ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , ""cloning"" ) ; s -> base = kmalloc ( bs -> bh -> b_size , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; memcpy ( s -> base , BHDR ( bs -> bh ) , bs -> bh -> b_size ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> here = ENTRY ( s -> base + offset ) ; s -> end = s -> base + bs -> bh -> b_size ; } } else { s -> base = kzalloc ( sb -> s_blocksize , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; header ( s -> base ) -> h_magic = cpu_to_le32 ( EXT4_XATTR_MAGIC ) ; header ( s -> base ) -> h_blocks = cpu_to_le32 ( 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; s -> here = ENTRY ( header ( s -> base ) + 1 ) ; s -> end = s -> base + sb -> s_blocksize ; } error = ext4_xattr_set_entry ( i , s ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; inserted : if ( ! IS_LAST_ENTRY ( s -> first ) ) { new_bh = ext4_xattr_cache_find ( inode , header ( s -> base ) , & ce ) ; if ( new_bh ) { if ( new_bh == bs -> bh ) ea_bdebug ( new_bh , ""keeping"" ) ; else { error = dquot_alloc_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; if ( error ) goto cleanup ; BUFFER_TRACE ( new_bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , new_bh ) ; if ( error ) goto cleanup_dquot ; lock_buffer ( new_bh ) ;  le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;  ea_bdebug ( new_bh , ""reusing;<S2SV_blank>refcount<S2SV_blank>now=%d"" , le32_to_cpu ( BHDR ( new_bh ) -> h_refcount ) ) ; unlock_buffer ( new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup_dquot ; }  mb_cache_entry_release ( ce ) ;  ce = NULL ; } else if ( bs -> bh && s -> base == bs -> bh -> b_data ) { ea_bdebug ( bs -> bh , ""keeping<S2SV_blank>this<S2SV_blank>block"" ) ; new_bh = bs -> bh ; get_bh ( new_bh ) ; } else { ext4_fsblk_t goal , block ; goal = ext4_group_first_block_no ( sb , EXT4_I ( inode ) -> i_block_group ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) goal = goal & EXT4_MAX_BLOCK_FILE_PHYS ; block = ext4_new_meta_blocks ( handle , inode , goal , 0 , NULL , & error ) ; if ( error ) goto cleanup ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) BUG_ON ( block > EXT4_MAX_BLOCK_FILE_PHYS ) ; ea_idebug ( inode , ""creating<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned long long ) block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { error = - ENOMEM ; getblk_failed : ext4_free_blocks ( handle , inode , NULL , block , 1 , EXT4_FREE_BLOCKS_METADATA ) ; goto cleanup ; } lock_buffer ( new_bh ) ; error = ext4_journal_get_create_access ( handle , new_bh ) ; if ( error ) { unlock_buffer ( new_bh ) ; error = - EIO ; goto getblk_failed ; } memcpy ( new_bh -> b_data , s -> base , new_bh -> b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; ext4_xattr_cache_insert ( ext4_mb_cache , new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup ; } } EXT4_I ( inode ) -> i_file_acl = new_bh ? new_bh -> b_blocknr : 0 ; if ( bs -> bh && bs -> bh != new_bh ) ext4_xattr_release_block ( handle , inode , bs -> bh ) ; error = 0 ; cleanup : if ( ce )  mb_cache_entry_release ( ce ) ;  brelse ( new_bh ) ; if ( ! ( bs -> bh && s -> base == bs -> bh -> b_data ) ) kfree ( s -> base ) ; return error ; cleanup_dquot : dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; goto cleanup ; bad_block : EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; goto cleanup ; # undef header }","struct mb2_cache_entry * ce = NULL ;int error = 0 ;struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;# define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ;__u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ;mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ;",2200
51,"buggy line: le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;ea_bdebug ( new_bh , ""reusing;mb_cache_entry_release ( ce ) ;ce = NULL ;cwe id:CWE-19context: static int ext4_xattr_block_set ( handle_t * handle , struct inode * inode , struct ext4_xattr_info * i , struct ext4_xattr_block_find * bs ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; struct ext4_xattr_search * s = & bs -> s ;  struct mb_cache_entry * ce = NULL ;  int error = 0 ;  struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;  # define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ; if ( s -> base ) {  ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev ,  bs -> bh -> b_blocknr ) ; BUFFER_TRACE ( bs -> bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , bs -> bh ) ; if ( error ) goto cleanup ; lock_buffer ( bs -> bh ) ; if ( header ( s -> base ) -> h_refcount == cpu_to_le32 ( 1 ) ) {  if ( ce ) {  mb_cache_entry_free ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , ""modifying<S2SV_blank>in-place"" ) ; error = ext4_xattr_set_entry ( i , s ) ; if ( ! error ) { if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; ext4_xattr_cache_insert ( ext4_mb_cache , bs -> bh ) ; } unlock_buffer ( bs -> bh ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( ! error ) error = ext4_handle_dirty_xattr_block ( handle , inode , bs -> bh ) ; if ( error ) goto cleanup ; goto inserted ; } else { int offset = ( char * ) s -> here - bs -> bh -> b_data ; unlock_buffer ( bs -> bh ) ;  if ( ce ) {  mb_cache_entry_release ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , ""cloning"" ) ; s -> base = kmalloc ( bs -> bh -> b_size , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; memcpy ( s -> base , BHDR ( bs -> bh ) , bs -> bh -> b_size ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> here = ENTRY ( s -> base + offset ) ; s -> end = s -> base + bs -> bh -> b_size ; } } else { s -> base = kzalloc ( sb -> s_blocksize , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; header ( s -> base ) -> h_magic = cpu_to_le32 ( EXT4_XATTR_MAGIC ) ; header ( s -> base ) -> h_blocks = cpu_to_le32 ( 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; s -> here = ENTRY ( header ( s -> base ) + 1 ) ; s -> end = s -> base + sb -> s_blocksize ; } error = ext4_xattr_set_entry ( i , s ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; inserted : if ( ! IS_LAST_ENTRY ( s -> first ) ) { new_bh = ext4_xattr_cache_find ( inode , header ( s -> base ) , & ce ) ; if ( new_bh ) { if ( new_bh == bs -> bh ) ea_bdebug ( new_bh , ""keeping"" ) ; else { error = dquot_alloc_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; if ( error ) goto cleanup ; BUFFER_TRACE ( new_bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , new_bh ) ; if ( error ) goto cleanup_dquot ; lock_buffer ( new_bh ) ;  le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;  ea_bdebug ( new_bh , ""reusing;<S2SV_blank>refcount<S2SV_blank>now=%d"" , le32_to_cpu ( BHDR ( new_bh ) -> h_refcount ) ) ; unlock_buffer ( new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup_dquot ; }  mb_cache_entry_release ( ce ) ;  ce = NULL ; } else if ( bs -> bh && s -> base == bs -> bh -> b_data ) { ea_bdebug ( bs -> bh , ""keeping<S2SV_blank>this<S2SV_blank>block"" ) ; new_bh = bs -> bh ; get_bh ( new_bh ) ; } else { ext4_fsblk_t goal , block ; goal = ext4_group_first_block_no ( sb , EXT4_I ( inode ) -> i_block_group ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) goal = goal & EXT4_MAX_BLOCK_FILE_PHYS ; block = ext4_new_meta_blocks ( handle , inode , goal , 0 , NULL , & error ) ; if ( error ) goto cleanup ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) BUG_ON ( block > EXT4_MAX_BLOCK_FILE_PHYS ) ; ea_idebug ( inode , ""creating<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned long long ) block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { error = - ENOMEM ; getblk_failed : ext4_free_blocks ( handle , inode , NULL , block , 1 , EXT4_FREE_BLOCKS_METADATA ) ; goto cleanup ; } lock_buffer ( new_bh ) ; error = ext4_journal_get_create_access ( handle , new_bh ) ; if ( error ) { unlock_buffer ( new_bh ) ; error = - EIO ; goto getblk_failed ; } memcpy ( new_bh -> b_data , s -> base , new_bh -> b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; ext4_xattr_cache_insert ( ext4_mb_cache , new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup ; } } EXT4_I ( inode ) -> i_file_acl = new_bh ? new_bh -> b_blocknr : 0 ; if ( bs -> bh && bs -> bh != new_bh ) ext4_xattr_release_block ( handle , inode , bs -> bh ) ; error = 0 ; cleanup : if ( ce )  mb_cache_entry_release ( ce ) ;  brelse ( new_bh ) ; if ( ! ( bs -> bh && s -> base == bs -> bh -> b_data ) ) kfree ( s -> base ) ; return error ; cleanup_dquot : dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; goto cleanup ; bad_block : EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; goto cleanup ; # undef header }","if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) {unlock_buffer ( new_bh ) ;dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ;brelse ( new_bh ) ;mb2_cache_entry_put ( ext4_mb_cache , ce ) ;ce = NULL ;new_bh = NULL ;goto inserted ;}le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;ea_bdebug ( new_bh , ""reusing;mb2_cache_entry_touch ( ext4_mb_cache , ce ) ;mb2_cache_entry_put ( ext4_mb_cache , ce ) ;ce = NULL ;",2200
52,"buggy line: cleanup : if ( ce )  mb_cache_entry_release ( ce ) ;brelse ( new_bh ) ;cwe id:CWE-19context: static int ext4_xattr_block_set ( handle_t * handle , struct inode * inode , struct ext4_xattr_info * i , struct ext4_xattr_block_find * bs ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; struct ext4_xattr_search * s = & bs -> s ;  struct mb_cache_entry * ce = NULL ;  int error = 0 ;  struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;  # define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ; if ( s -> base ) {  ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev ,  bs -> bh -> b_blocknr ) ; BUFFER_TRACE ( bs -> bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , bs -> bh ) ; if ( error ) goto cleanup ; lock_buffer ( bs -> bh ) ; if ( header ( s -> base ) -> h_refcount == cpu_to_le32 ( 1 ) ) {  if ( ce ) {  mb_cache_entry_free ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , ""modifying<S2SV_blank>in-place"" ) ; error = ext4_xattr_set_entry ( i , s ) ; if ( ! error ) { if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; ext4_xattr_cache_insert ( ext4_mb_cache , bs -> bh ) ; } unlock_buffer ( bs -> bh ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( ! error ) error = ext4_handle_dirty_xattr_block ( handle , inode , bs -> bh ) ; if ( error ) goto cleanup ; goto inserted ; } else { int offset = ( char * ) s -> here - bs -> bh -> b_data ; unlock_buffer ( bs -> bh ) ;  if ( ce ) {  mb_cache_entry_release ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , ""cloning"" ) ; s -> base = kmalloc ( bs -> bh -> b_size , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; memcpy ( s -> base , BHDR ( bs -> bh ) , bs -> bh -> b_size ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> here = ENTRY ( s -> base + offset ) ; s -> end = s -> base + bs -> bh -> b_size ; } } else { s -> base = kzalloc ( sb -> s_blocksize , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; header ( s -> base ) -> h_magic = cpu_to_le32 ( EXT4_XATTR_MAGIC ) ; header ( s -> base ) -> h_blocks = cpu_to_le32 ( 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; s -> here = ENTRY ( header ( s -> base ) + 1 ) ; s -> end = s -> base + sb -> s_blocksize ; } error = ext4_xattr_set_entry ( i , s ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; inserted : if ( ! IS_LAST_ENTRY ( s -> first ) ) { new_bh = ext4_xattr_cache_find ( inode , header ( s -> base ) , & ce ) ; if ( new_bh ) { if ( new_bh == bs -> bh ) ea_bdebug ( new_bh , ""keeping"" ) ; else { error = dquot_alloc_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; if ( error ) goto cleanup ; BUFFER_TRACE ( new_bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , new_bh ) ; if ( error ) goto cleanup_dquot ; lock_buffer ( new_bh ) ;  le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;  ea_bdebug ( new_bh , ""reusing;<S2SV_blank>refcount<S2SV_blank>now=%d"" , le32_to_cpu ( BHDR ( new_bh ) -> h_refcount ) ) ; unlock_buffer ( new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup_dquot ; }  mb_cache_entry_release ( ce ) ;  ce = NULL ; } else if ( bs -> bh && s -> base == bs -> bh -> b_data ) { ea_bdebug ( bs -> bh , ""keeping<S2SV_blank>this<S2SV_blank>block"" ) ; new_bh = bs -> bh ; get_bh ( new_bh ) ; } else { ext4_fsblk_t goal , block ; goal = ext4_group_first_block_no ( sb , EXT4_I ( inode ) -> i_block_group ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) goal = goal & EXT4_MAX_BLOCK_FILE_PHYS ; block = ext4_new_meta_blocks ( handle , inode , goal , 0 , NULL , & error ) ; if ( error ) goto cleanup ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) BUG_ON ( block > EXT4_MAX_BLOCK_FILE_PHYS ) ; ea_idebug ( inode , ""creating<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned long long ) block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { error = - ENOMEM ; getblk_failed : ext4_free_blocks ( handle , inode , NULL , block , 1 , EXT4_FREE_BLOCKS_METADATA ) ; goto cleanup ; } lock_buffer ( new_bh ) ; error = ext4_journal_get_create_access ( handle , new_bh ) ; if ( error ) { unlock_buffer ( new_bh ) ; error = - EIO ; goto getblk_failed ; } memcpy ( new_bh -> b_data , s -> base , new_bh -> b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; ext4_xattr_cache_insert ( ext4_mb_cache , new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup ; } } EXT4_I ( inode ) -> i_file_acl = new_bh ? new_bh -> b_blocknr : 0 ; if ( bs -> bh && bs -> bh != new_bh ) ext4_xattr_release_block ( handle , inode , bs -> bh ) ; error = 0 ; cleanup : if ( ce )  mb_cache_entry_release ( ce ) ;  brelse ( new_bh ) ; if ( ! ( bs -> bh && s -> base == bs -> bh -> b_data ) ) kfree ( s -> base ) ; return error ; cleanup_dquot : dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; goto cleanup ; bad_block : EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; goto cleanup ; # undef header }","cleanup : if ( ce ) mb2_cache_entry_put ( ext4_mb_cache , ce ) ;brelse ( new_bh ) ;",2200
53,"buggy line: static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags ,  struct in6_addr * addr , uint32_t * ifindex )  {unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ;struct iovec iovec ;cwe id:CWE-284context: static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags ,  struct in6_addr * addr , uint32_t * ifindex )  { struct sockaddr_in6 sin6 ;  unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ;  struct iovec iovec ; struct msghdr msghdr ; struct cmsghdr * cmsghdr ; ssize_t len ; iovec . iov_len = * buflen ; iovec . iov_base = buf ; memset ( & msghdr , 0 , sizeof ( msghdr ) ) ; msghdr . msg_name = & sin6 ; msghdr . msg_namelen = sizeof ( sin6 ) ; msghdr . msg_iov = & iovec ; msghdr . msg_iovlen = 1 ; msghdr . msg_control = cbuf ; msghdr . msg_controllen = sizeof ( cbuf ) ; len = recvmsg ( sockfd , & msghdr , flags ) ; if ( len == - 1 ) return - errno ; * buflen = len ; * ifindex = sin6 . sin6_scope_id ; for ( cmsghdr = CMSG_FIRSTHDR ( & msghdr ) ; cmsghdr ; cmsghdr = CMSG_NXTHDR ( & msghdr , cmsghdr ) ) {  if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 &&   cmsghdr -> cmsg_type == IPV6_PKTINFO &&  cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) { struct in6_pktinfo * pktinfo ; pktinfo = ( struct in6_pktinfo * ) CMSG_DATA ( cmsghdr ) ; * ifindex = pktinfo -> ipi6_ifindex ; }  }  * addr = sin6 . sin6_addr ; return 0 ; }","static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags , struct in6_addr * addr , uint32_t * ifindex , int * hoplimit ) {unsigned char cbuf [ 2 * CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ;struct iovec iovec ;",2201
54,"buggy line: if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 &&   cmsghdr -> cmsg_type == IPV6_PKTINFO &&  cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) {}* addr = sin6 . sin6_addr ;cwe id:CWE-284context: static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags ,  struct in6_addr * addr , uint32_t * ifindex )  { struct sockaddr_in6 sin6 ;  unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ;  struct iovec iovec ; struct msghdr msghdr ; struct cmsghdr * cmsghdr ; ssize_t len ; iovec . iov_len = * buflen ; iovec . iov_base = buf ; memset ( & msghdr , 0 , sizeof ( msghdr ) ) ; msghdr . msg_name = & sin6 ; msghdr . msg_namelen = sizeof ( sin6 ) ; msghdr . msg_iov = & iovec ; msghdr . msg_iovlen = 1 ; msghdr . msg_control = cbuf ; msghdr . msg_controllen = sizeof ( cbuf ) ; len = recvmsg ( sockfd , & msghdr , flags ) ; if ( len == - 1 ) return - errno ; * buflen = len ; * ifindex = sin6 . sin6_scope_id ; for ( cmsghdr = CMSG_FIRSTHDR ( & msghdr ) ; cmsghdr ; cmsghdr = CMSG_NXTHDR ( & msghdr , cmsghdr ) ) {  if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 &&   cmsghdr -> cmsg_type == IPV6_PKTINFO &&  cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) { struct in6_pktinfo * pktinfo ; pktinfo = ( struct in6_pktinfo * ) CMSG_DATA ( cmsghdr ) ; * ifindex = pktinfo -> ipi6_ifindex ; }  }  * addr = sin6 . sin6_addr ; return 0 ; }",if ( cmsghdr -> cmsg_level != IPPROTO_IPV6 ) continue ;switch ( cmsghdr -> cmsg_type ) {case IPV6_PKTINFO : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) {break ;case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) {int * val ;val = ( int * ) CMSG_DATA ( cmsghdr ) ;* hoplimit = * val ;}break ;}}* addr = sin6 . sin6_addr ;,2201
55,"buggy line: if ( mode > 0 ) {r = fchmod ( fd , mode ) ;cwe id:CWE-264context: int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; if ( fd < 0 ) return - errno ;  if ( mode > 0 ) {  r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }","if ( mode != MODE_INVALID ) {r = fchmod ( fd , mode ) ;",2202
56,"buggy line: struct address_space * mapping = inode -> i_mapping ;unsigned int blkbits = inode -> i_blkbits ;}if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) {ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ;if ( ret ) return ret ;cwe id:CWE-362context: static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ;  struct address_space * mapping = inode -> i_mapping ;  unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; }  if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) {  ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex ; } if ( max_blocks > 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;  truncate_pagecache_range ( inode , start , end - 1 ) ;  inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ;  ext4_inode_block_unlocked_dio ( inode ) ;  inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size ,  flags , mode ) ;  if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }",unsigned int blkbits = inode -> i_blkbits ;,2203
57,"buggy line: truncate_pagecache_range ( inode , start , end - 1 ) ;inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size ,  flags , mode ) ;if ( ret ) goto out_dio ;cwe id:CWE-362context: static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ;  struct address_space * mapping = inode -> i_mapping ;  unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; }  if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) {  ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex ; } if ( max_blocks > 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;  truncate_pagecache_range ( inode , start , end - 1 ) ;  inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ;  ext4_inode_block_unlocked_dio ( inode ) ;  inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size ,  flags , mode ) ;  if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }","ext4_inode_block_unlocked_dio ( inode ) ;ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , flags , mode ) ;up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;if ( ret ) goto out_dio ;",2203
58,"buggy line: j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ;if ( j < 0 ) goto partno ;len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ;j += PCI_VPD_INFO_FLD_HDR_SIZE ;if ( j + len > block_end ) goto partno ;memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ;strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ;}cwe id:CWE-119context: static void tg3_read_vpd ( struct tg3 * tp ) { u8 * vpd_data ; unsigned int block_end , rosize , len ; u32 vpdlen ; int j , i = 0 ; vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ) ; if ( ! vpd_data ) goto out_no_vpd ; i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ) ; if ( i < 0 ) goto out_not_found ; rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ) ; block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize ; i += PCI_VPD_LRDT_TAG_SIZE ; if ( block_end > vpdlen ) goto out_not_found ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ) ; if ( j > 0 ) { len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , ""1028"" , 4 ) ) goto partno ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ; if ( j < 0 ) goto partno ; len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end ) goto partno ;  memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ;   strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ;  } partno : i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ) ; if ( i < 0 ) goto out_not_found ; len = pci_vpd_info_field_size ( & vpd_data [ i ] ) ; i += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen ) goto out_not_found ; memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ) ; out_not_found : kfree ( vpd_data ) ; if ( tp -> board_part_number [ 0 ] ) return ; out_no_vpd : if ( tg3_asic_rev ( tp ) == ASIC_REV_5717 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717 || tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717_C ) strcpy ( tp -> board_part_number , ""BCM5717"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5718 ) strcpy ( tp -> board_part_number , ""BCM5718"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57780 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57780 ) strcpy ( tp -> board_part_number , ""BCM57780"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57760 ) strcpy ( tp -> board_part_number , ""BCM57760"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57790 ) strcpy ( tp -> board_part_number , ""BCM57790"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57788 ) strcpy ( tp -> board_part_number , ""BCM57788"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57765 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 ) strcpy ( tp -> board_part_number , ""BCM57761"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 ) strcpy ( tp -> board_part_number , ""BCM57765"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 ) strcpy ( tp -> board_part_number , ""BCM57781"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 ) strcpy ( tp -> board_part_number , ""BCM57785"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 ) strcpy ( tp -> board_part_number , ""BCM57791"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 ) strcpy ( tp -> board_part_number , ""BCM57795"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57766 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57762 ) strcpy ( tp -> board_part_number , ""BCM57762"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57766 ) strcpy ( tp -> board_part_number , ""BCM57766"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57782 ) strcpy ( tp -> board_part_number , ""BCM57782"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57786 ) strcpy ( tp -> board_part_number , ""BCM57786"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_5906 ) { strcpy ( tp -> board_part_number , ""BCM95906"" ) ; } else { nomatch : strcpy ( tp -> board_part_number , ""none"" ) ; } }","if ( len >= sizeof ( tp -> fw_ver , & vpd_data [ j ] , len ) ;strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ;}",2204
59,"buggy line: path -> mnt = mntget ( nd -> path . mnt ) ;if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ;follow_mount ( path ) ;error = 0 ;cwe id:CWE-59context: static int mountpoint_last ( struct nameidata * nd , struct path * path ) { int error = 0 ; struct dentry * dentry ; struct dentry * dir = nd -> path . dentry ; if ( nd -> flags & LOOKUP_RCU ) { if ( unlazy_walk ( nd , NULL ) ) { error = - ECHILD ; goto out ; } } nd -> flags &= ~ LOOKUP_PARENT ; if ( unlikely ( nd -> last_type != LAST_NORM ) ) { error = handle_dots ( nd , nd -> last_type ) ; if ( error ) goto out ; dentry = dget ( nd -> path . dentry ) ; goto done ; } mutex_lock ( & dir -> d_inode -> i_mutex ) ; dentry = d_lookup ( dir , & nd -> last ) ; if ( ! dentry ) { dentry = d_alloc ( dir , & nd -> last ) ; if ( ! dentry ) { error = - ENOMEM ; mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } dentry = lookup_real ( dir -> d_inode , dentry , nd -> flags ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) { mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } } mutex_unlock ( & dir -> d_inode -> i_mutex ) ; done : if ( ! dentry -> d_inode || d_is_negative ( dentry ) ) { error = - ENOENT ; dput ( dentry ) ; goto out ; } path -> dentry = dentry ;  path -> mnt = mntget ( nd -> path . mnt ) ;  if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ;  follow_mount ( path ) ;  error = 0 ; out : terminate_walk ( nd ) ; return error ; }","path -> mnt = nd -> path . mnt ) ;if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ;mntget ( path -> mnt ) ;follow_mount ( path ) ;error = 0 ;",2205
60,"buggy line: i ++ ;if ( file -> f_flags & O_NONBLOCK ) {cwe id:CWE-119context: static ssize_t wdm_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { int rv , cntr ; int i = 0 ; struct wdm_device * desc = file -> private_data ; rv = mutex_lock_interruptible ( & desc -> rlock ) ; if ( rv < 0 ) return - ERESTARTSYS ; cntr = ACCESS_ONCE ( desc -> length ) ; if ( cntr == 0 ) { desc -> read = 0 ; retry : if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; }  i ++ ;  if ( file -> f_flags & O_NONBLOCK ) { if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { rv = cntr ? cntr : - EAGAIN ; goto err ; } rv = 0 ; } else { rv = wait_event_interruptible ( desc -> wait , test_bit ( WDM_READ , & desc -> flags ) ) ; } if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } if ( test_bit ( WDM_RESETTING , & desc -> flags ) ) { rv = - EIO ; goto err ; } usb_mark_last_busy ( interface_to_usbdev ( desc -> intf ) ) ; if ( rv < 0 ) { rv = - ERESTARTSYS ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; if ( desc -> rerr ) { desc -> rerr = 0 ; spin_unlock_irq ( & desc -> iuspin ) ; rv = - EIO ; goto err ; } if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } if ( ! desc -> reslength ) { dev_dbg ( & desc -> intf -> dev , ""%s:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>-<S2SV_blank>clearing<S2SV_blank>WDM_READ\\n"" , __func__ ) ; clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } cntr = desc -> length ; spin_unlock_irq ( & desc -> iuspin ) ; } if ( cntr > count ) cntr = count ; rv = copy_to_user ( buffer , desc -> ubuf , cntr ) ; if ( rv > 0 ) { rv = - EFAULT ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; for ( i = 0 ; i < desc -> length - cntr ; i ++ ) desc -> ubuf [ i ] = desc -> ubuf [ i + cntr ] ; desc -> length -= cntr ; if ( ! desc -> length ) clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; rv = cntr ; err : mutex_unlock ( & desc -> rlock ) ; return rv ; }","if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) {clear_bit ( WDM_OVERFLOW , & desc -> flags ) ;rv = - ENOBUFS ;goto err ;}i ++ ;if ( file -> f_flags & O_NONBLOCK ) {",2206
61,"buggy line: enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , MICMD_MIIRD ) ;while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 )  {enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , 0 ) ;data = enc28j60ReadReg ( interface , ENC28J60_REG_MIRDL ) ;data |= enc28j60ReadReg ( interface , ENC28J60_REG_MIRDH ) << 8 ;return data ;cwe id:CWE-20context: uint16_t enc28j60ReadPhyReg ( NetInterface * interface , uint16_t address ) { uint16_t data ;  enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , MICMD_MIIRD ) ;   while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 )  { }  enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , 0 ) ;   data = enc28j60ReadReg ( interface , ENC28J60_REG_MIRDL ) ;   data |= enc28j60ReadReg ( interface , ENC28J60_REG_MIRDH ) << 8 ;  return data ; }","enc28j60WriteReg ( interface , ENC28J60_MIREGADR , address & REG_ADDR_MASK ) ;enc28j60WriteReg ( interface , ENC28J60_MICMD , ENC28J60_MICMD_MIIRD ) ;while ( ( enc28j60ReadReg ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY ) != 0 ) {enc28j60WriteReg ( interface , ENC28J60_MICMD , 0 ) ;data = enc28j60ReadReg ( interface , ENC28J60_MIRDL ) ;data |= enc28j60ReadReg ( interface , ENC28J60_MIRDH ) << 8 ;return data ;",2207
62,"buggy line: cwe id:CWE-000context: static void sas_revalidate_domain ( struct work_struct * work ) { int res = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; struct sas_ha_struct * ha = port -> ha ; struct domain_device * ddev = port -> port_dev ; mutex_lock ( & ha -> disco_mutex ) ; if ( test_bit ( SAS_HA_ATA_EH_ACTIVE , & ha -> state ) ) { SAS_DPRINTK ( ""REVALIDATION<S2SV_blank>DEFERRED<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; goto out ; } clear_bit ( DISCE_REVALIDATE_DOMAIN , & port -> disc . pending ) ; SAS_DPRINTK ( ""REVALIDATING<S2SV_blank>DOMAIN<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; if ( ddev && ( ddev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE || ddev -> dev_type == SAS_EDGE_EXPANDER_DEVICE ) ) res = sas_ex_revalidate_domain ( ddev ) ; SAS_DPRINTK ( ""done<S2SV_blank>REVALIDATING<S2SV_blank>DOMAIN<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>res<S2SV_blank>0x%x\\n"" , port -> id , task_pid_nr ( current ) , res ) ; out : mutex_unlock ( & ha -> disco_mutex ) ;  } ",sas_destruct_devices ( port ) ;sas_destruct_ports ( port ) ;sas_probe_devices ( port ) ;,2208
63,"buggy line: }cwe id:CWE-000context: static void sas_revalidate_domain ( struct work_struct * work ) { int res = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; struct sas_ha_struct * ha = port -> ha ; struct domain_device * ddev = port -> port_dev ; mutex_lock ( & ha -> disco_mutex ) ; if ( test_bit ( SAS_HA_ATA_EH_ACTIVE , & ha -> state ) ) { SAS_DPRINTK ( ""REVALIDATION<S2SV_blank>DEFERRED<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; goto out ; } clear_bit ( DISCE_REVALIDATE_DOMAIN , & port -> disc . pending ) ; SAS_DPRINTK ( ""REVALIDATING<S2SV_blank>DOMAIN<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; if ( ddev && ( ddev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE || ddev -> dev_type == SAS_EDGE_EXPANDER_DEVICE ) ) res = sas_ex_revalidate_domain ( ddev ) ; SAS_DPRINTK ( ""done<S2SV_blank>REVALIDATING<S2SV_blank>DOMAIN<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>res<S2SV_blank>0x%x\\n"" , port -> id , task_pid_nr ( current ) , res ) ; out : mutex_unlock ( & ha -> disco_mutex ) ;  } ",},2208
64,"buggy line: static int  mptctl_readtest ( unsigned long arg )  {MPT_ADAPTER * ioc ;int iocnum ;}if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||  ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_readtest()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;cwe id:CWE-362context: static int  mptctl_readtest ( unsigned long arg )  { struct mpt_ioctl_test __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_test karg ;  MPT_ADAPTER * ioc ;  int iocnum ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_test ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_readtest<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_test<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; }  if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||  ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_readtest()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_readtest<S2SV_blank>called.\\n"" , ioc -> name ) ) ; # ifdef MFCNT karg . chip_type = ioc -> mfcnt ; # else karg . chip_type = ioc -> pcidev -> device ; # endif strncpy ( karg . name , ioc -> name , MPT_MAX_NAME ) ; karg . name [ MPT_MAX_NAME - 1 ] = '\\0' ; strncpy ( karg . product , ioc -> prod_name , MPT_PRODUCT_LENGTH ) ; karg . product [ MPT_PRODUCT_LENGTH - 1 ] = '\\0' ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( struct mpt_ioctl_test ) ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_readtest<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_test<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } return 0 ; }","static int mptctl_readtest ( MPT_ADAPTER * ioc , unsigned long arg ) {",2209
65,"buggy line: static void choose_partitioning ( VP9_COMP * cpi ,  const TileInfo * const tile ,  int mi_row , int mi_col ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * x = & cpi -> mb ;MACROBLOCKD * xd = & cpi -> mb . e_mbd ;int i , j , k ;v64x64 vt ;uint8_t * s ;int_mv nearest_mv , near_mv ;const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ;vp9_zero ( vt ) ;set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;if ( xd -> mb_to_right_edge < 0 )  pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ;if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ;s = x -> plane [ 0 ] . src . buf ;sp = x -> plane [ 0 ] . src . stride ;if ( cm -> frame_type != KEY_FRAME ) {vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ;xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ;xd -> mi [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ;vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , xd -> mi [ 0 ] -> mbmi . ref_mvs [ LAST_FRAME ] , & nearest_mv , & near_mv ) ;xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = nearest_mv ;vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , BLOCK_64X64 ) ;dp = xd -> plane [ 0 ] . dst . stride ;}cwe id:CWE-119context:  static void choose_partitioning ( VP9_COMP * cpi ,  const TileInfo * const tile ,  int mi_row , int mi_col ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * x = & cpi -> mb ;   MACROBLOCKD * xd = & cpi -> mb . e_mbd ;   int i , j , k ;   v64x64 vt ;  uint8_t * s ; const uint8_t * d ; int sp ; int dp ; int pixels_wide = 64 , pixels_high = 64 ;  int_mv nearest_mv , near_mv ;  const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;  const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ;  vp9_zero ( vt ) ;  set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;   if ( xd -> mb_to_right_edge < 0 )  pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; s = x -> plane [ 0 ] . src . buf ; sp = x -> plane [ 0 ] . src . stride ; if ( cm -> frame_type != KEY_FRAME ) {  vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ;  xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ; xd -> mi [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ; vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , xd -> mi [ 0 ] -> mbmi . ref_mvs [ LAST_FRAME ] , & nearest_mv , & near_mv ) ; xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = nearest_mv ; vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , BLOCK_64X64 ) ; d = xd -> plane [ 0 ] . dst . buf ;  dp = xd -> plane [ 0 ] . dst . stride ;  } else { d = VP9_VAR_OFFS ; dp = 0 ; } for ( i = 0 ; i < 4 ; i ++ ) { const int x32_idx = ( ( i & 1 ) << 5 ) ; const int y32_idx = ( ( i >> 1 ) << 5 ) ;  for ( j = 0 ; j < 4 ; j ++ ) {  const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ;  const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ;  v16x16 * vst = & vt . split [ i ] . split [ j ] ;  for ( k = 0 ; k < 4 ; k ++ ) {   int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ;   int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ;   unsigned int sse = 0 ;  int sum = 0 ; if ( x_idx < pixels_wide && y_idx < pixels_high ) vp9_get_sse_sum_8x8 ( s + y_idx * sp + x_idx , sp , d + y_idx * dp + x_idx , dp , & sse , & sum ) ; fill_variance ( sse , sum , 64 , & vst -> split [ k ] . part_variances . none ) ; } } } for ( i = 0 ; i < 4 ; i ++ ) {  for ( j = 0 ; j < 4 ; j ++ ) {   fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ;  }  fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ;  }  fill_variance_tree ( & vt , BLOCK_64X64 ) ;   if ( ! set_vt_partitioning ( cpi , & vt , tile , BLOCK_64X64 ,   mi_row , mi_col , 8 ) ) {  for ( i = 0 ; i < 4 ; ++ i ) { const int x32_idx = ( ( i & 1 ) << 2 ) ; const int y32_idx = ( ( i >> 1 ) << 2 ) ;  if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , tile , BLOCK_32X32 ,   ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , 4 ) ) {  for ( j = 0 ; j < 4 ; ++ j ) { const int x16_idx = ( ( j & 1 ) << 1 ) ; const int y16_idx = ( ( j >> 1 ) << 1 ) ;  # define DISABLE_8X8_VAR_BASED_PARTITION  # ifdef DISABLE_8X8_VAR_BASED_PARTITION  if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows &&   mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) {  set_block_size ( cpi , tile , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , BLOCK_16X16 ) ; } else { for ( k = 0 ; k < 4 ; ++ k ) { const int x8_idx = ( k & 1 ) ; const int y8_idx = ( k >> 1 ) ;  set_block_size ( cpi , tile ,  ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ; } } # else  if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile ,  BLOCK_16X16 ,  ( mi_row + y32_idx + y16_idx ) ,   ( mi_col + x32_idx + x16_idx ) , 2 ) ) {  for ( k = 0 ; k < 4 ; ++ k ) { const int x8_idx = ( k & 1 ) ; const int y8_idx = ( k >> 1 ) ;  set_block_size ( cpi , tile ,  ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ; } }  # endif  } } } } }","static int choose_partitioning ( VP9_COMP * cpi , const TileInfo * const tile , MACROBLOCK * x = & cpi -> mb ;MACROBLOCKD * xd = & cpi -> mb . e_mbd ;int i , j , k , m ;v64x64 vt ;v16x16 vt2 [ 16 ] ;int force_split [ 21 ] ;uint8_t * s ;int64_t thresholds [ 4 ] = {cpi -> vbp_thresholds [ 0 ] , cpi -> vbp_thresholds [ 1 ] , cpi -> vbp_thresholds [ 2 ] , cpi -> vbp_thresholds [ 3 ] };const int is_key_frame = ( cm -> frame_type == KEY_FRAME ) ;const YV12_BUFFER_CONFIG * yv12_g = NULL ;unsigned int y_sad , y_sad_g ;const BLOCK_SIZE bsize = BLOCK_32X32 + ( mi_col + 4 < cm -> mi_cols ) * 2 + ( mi_row + 4 < cm -> mi_rows ) ;assert ( yv12 != NULL ) ;if ( ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . spatial_layer_id ) ) {yv12_g = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;}if ( yv12_g && yv12_g != yv12 && ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ) {vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ;mbmi -> ref_frame [ 0 ] = LAST_FRAME ;mbmi -> ref_frame [ 1 ] = NONE ;mbmi -> sb_type = BLOCK_64X64 ;mbmi -> mv [ 0 ] . as_int = 0 ;mbmi -> interp_filter = BILINEAR ;y_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ;if ( y_sad_g < y_sad ) {vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ;mbmi -> ref_frame [ 0 ] = GOLDEN_FRAME ;mbmi -> mv [ 0 ] . as_int = 0 ;y_sad = y_sad_g ;}else {x -> pred_mv [ LAST_FRAME ] = mbmi -> mv [ 0 ] . as_mv ;}vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , & cm -> seg , segment_id , cm -> base_qindex ) ;set_vbp_thresholds ( cpi , thresholds , q ) ;}}set_offsets ( cpi , tile , x , mi_row , mi_col , BLOCK_64X64 ) ;for ( i = 1 ;i <= 2 ;++ i ) {struct macroblock_plane * p = & x -> plane [ i ] ;struct macroblockd_plane * pd = & xd -> plane [ i ] ;const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ;if ( bs == BLOCK_INVALID ) uv_sad = UINT_MAX ;else uv_sad = cpi -> fn_ptr [ bs ] . sdf ( p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride ) ;x -> color_sensitivity [ i - 1 ] = uv_sad > ( y_sad >> 2 ) ;}dp = xd -> plane [ 0 ] . dst . stride ;if ( segment_id == CR_SEGMENT_ID_BASE && y_sad < cpi -> vbp_threshold_sad ) {const int block_width = num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ;const int block_height = num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ;if ( mi_col + block_width / 2 < cm -> mi_cols && mi_row + block_height / 2 < cm -> mi_rows ) {set_block_size ( cpi , x , xd , mi_row , mi_col , BLOCK_64X64 ) ;return 0 ;}}}else {d = VP9_VAR_OFFS ;dp = xd -> plane [ 0 ] . dst . stride ;}",2210
66,"buggy line: for ( j = 0 ;const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ;const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ;v16x16 * vst = & vt . split [ i ] . split [ j ] ;for ( k = 0 ;k < 4 ;k ++ ) {int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ;int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ;unsigned int sse = 0 ;int sum = 0 ;cwe id:CWE-119context:  static void choose_partitioning ( VP9_COMP * cpi ,  const TileInfo * const tile ,  int mi_row , int mi_col ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * x = & cpi -> mb ;   MACROBLOCKD * xd = & cpi -> mb . e_mbd ;   int i , j , k ;   v64x64 vt ;  uint8_t * s ; const uint8_t * d ; int sp ; int dp ; int pixels_wide = 64 , pixels_high = 64 ;  int_mv nearest_mv , near_mv ;  const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;  const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ;  vp9_zero ( vt ) ;  set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;   if ( xd -> mb_to_right_edge < 0 )  pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; s = x -> plane [ 0 ] . src . buf ; sp = x -> plane [ 0 ] . src . stride ; if ( cm -> frame_type != KEY_FRAME ) {  vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ;  xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ; xd -> mi [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ; vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , xd -> mi [ 0 ] -> mbmi . ref_mvs [ LAST_FRAME ] , & nearest_mv , & near_mv ) ; xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = nearest_mv ; vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , BLOCK_64X64 ) ; d = xd -> plane [ 0 ] . dst . buf ;  dp = xd -> plane [ 0 ] . dst . stride ;  } else { d = VP9_VAR_OFFS ; dp = 0 ; } for ( i = 0 ; i < 4 ; i ++ ) { const int x32_idx = ( ( i & 1 ) << 5 ) ; const int y32_idx = ( ( i >> 1 ) << 5 ) ;  for ( j = 0 ; j < 4 ; j ++ ) {  const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ;  const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ;  v16x16 * vst = & vt . split [ i ] . split [ j ] ;  for ( k = 0 ; k < 4 ; k ++ ) {   int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ;   int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ;   unsigned int sse = 0 ;  int sum = 0 ; if ( x_idx < pixels_wide && y_idx < pixels_high ) vp9_get_sse_sum_8x8 ( s + y_idx * sp + x_idx , sp , d + y_idx * dp + x_idx , dp , & sse , & sum ) ; fill_variance ( sse , sum , 64 , & vst -> split [ k ] . part_variances . none ) ; } } } for ( i = 0 ; i < 4 ; i ++ ) {  for ( j = 0 ; j < 4 ; j ++ ) {   fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ;  }  fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ;  }  fill_variance_tree ( & vt , BLOCK_64X64 ) ;   if ( ! set_vt_partitioning ( cpi , & vt , tile , BLOCK_64X64 ,   mi_row , mi_col , 8 ) ) {  for ( i = 0 ; i < 4 ; ++ i ) { const int x32_idx = ( ( i & 1 ) << 2 ) ; const int y32_idx = ( ( i >> 1 ) << 2 ) ;  if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , tile , BLOCK_32X32 ,   ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , 4 ) ) {  for ( j = 0 ; j < 4 ; ++ j ) { const int x16_idx = ( ( j & 1 ) << 1 ) ; const int y16_idx = ( ( j >> 1 ) << 1 ) ;  # define DISABLE_8X8_VAR_BASED_PARTITION  # ifdef DISABLE_8X8_VAR_BASED_PARTITION  if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows &&   mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) {  set_block_size ( cpi , tile , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , BLOCK_16X16 ) ; } else { for ( k = 0 ; k < 4 ; ++ k ) { const int x8_idx = ( k & 1 ) ; const int y8_idx = ( k >> 1 ) ;  set_block_size ( cpi , tile ,  ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ; } } # else  if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile ,  BLOCK_16X16 ,  ( mi_row + y32_idx + y16_idx ) ,   ( mi_col + x32_idx + x16_idx ) , 2 ) ) {  for ( k = 0 ; k < 4 ; ++ k ) { const int x8_idx = ( k & 1 ) ; const int y8_idx = ( k >> 1 ) ;  set_block_size ( cpi , tile ,  ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ; } }  # endif  } } } } }","const int i2 = i << 2 ;force_split [ i + 1 ] = 0 ;for ( j = 0 ;const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ;const int split_index = 5 + i2 + j ;const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ;v16x16 * vst = & vt . split [ i ] . split [ j ] ;force_split [ split_index ] = 0 ;variance4x4downsample [ i2 + j ] = 0 ;if ( ! is_key_frame ) {fill_variance_8x8avg ( s , sp , d , dp , x16_idx , y16_idx , vst , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ;fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ;get_variance ( & vt . split [ i ] . split [ j ] . part_variances . none ) ;if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 2 ] ) {force_split [ split_index ] = 1 ;force_split [ i + 1 ] = 1 ;force_split [ 0 ] = 1 ;}else if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 1 ] && ! cyclic_refresh_segment_id_boosted ( segment_id ) ) {int x8_idx = x16_idx + ( ( k & 1 ) << 3 ) ;int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ;unsigned int sse = 0 ;int sum = 0 ;",2210
67,"buggy line: for ( j = 0 ;fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ;}fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ;}fill_variance_tree ( & vt , BLOCK_64X64 ) ;if ( ! set_vt_partitioning ( cpi , & vt , tile , BLOCK_64X64 ,   mi_row , mi_col , 8 ) ) {for ( i = 0 ;if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , tile , BLOCK_32X32 ,   ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , 4 ) ) {for ( j = 0 ;const int y16_idx = ( ( j >> 1 ) << 1 ) ;# define DISABLE_8X8_VAR_BASED_PARTITION  # ifdef DISABLE_8X8_VAR_BASED_PARTITION  if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows &&   mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) {set_block_size ( cpi , tile , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , BLOCK_16X16 ) ;}else {const int y8_idx = ( k >> 1 ) ;set_block_size ( cpi , tile ,  ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ;}}# else  if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile ,  BLOCK_16X16 ,  ( mi_row + y32_idx + y16_idx ) ,   ( mi_col + x32_idx + x16_idx ) , 2 ) ) {for ( k = 0 ;set_block_size ( cpi , tile ,  ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ;# endif  }cwe id:CWE-119context:  static void choose_partitioning ( VP9_COMP * cpi ,  const TileInfo * const tile ,  int mi_row , int mi_col ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * x = & cpi -> mb ;   MACROBLOCKD * xd = & cpi -> mb . e_mbd ;   int i , j , k ;   v64x64 vt ;  uint8_t * s ; const uint8_t * d ; int sp ; int dp ; int pixels_wide = 64 , pixels_high = 64 ;  int_mv nearest_mv , near_mv ;  const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;  const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ;  vp9_zero ( vt ) ;  set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;   if ( xd -> mb_to_right_edge < 0 )  pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; s = x -> plane [ 0 ] . src . buf ; sp = x -> plane [ 0 ] . src . stride ; if ( cm -> frame_type != KEY_FRAME ) {  vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ;  xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ; xd -> mi [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ; vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , xd -> mi [ 0 ] -> mbmi . ref_mvs [ LAST_FRAME ] , & nearest_mv , & near_mv ) ; xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = nearest_mv ; vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , BLOCK_64X64 ) ; d = xd -> plane [ 0 ] . dst . buf ;  dp = xd -> plane [ 0 ] . dst . stride ;  } else { d = VP9_VAR_OFFS ; dp = 0 ; } for ( i = 0 ; i < 4 ; i ++ ) { const int x32_idx = ( ( i & 1 ) << 5 ) ; const int y32_idx = ( ( i >> 1 ) << 5 ) ;  for ( j = 0 ; j < 4 ; j ++ ) {  const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ;  const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ;  v16x16 * vst = & vt . split [ i ] . split [ j ] ;  for ( k = 0 ; k < 4 ; k ++ ) {   int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ;   int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ;   unsigned int sse = 0 ;  int sum = 0 ; if ( x_idx < pixels_wide && y_idx < pixels_high ) vp9_get_sse_sum_8x8 ( s + y_idx * sp + x_idx , sp , d + y_idx * dp + x_idx , dp , & sse , & sum ) ; fill_variance ( sse , sum , 64 , & vst -> split [ k ] . part_variances . none ) ; } } } for ( i = 0 ; i < 4 ; i ++ ) {  for ( j = 0 ; j < 4 ; j ++ ) {   fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ;  }  fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ;  }  fill_variance_tree ( & vt , BLOCK_64X64 ) ;   if ( ! set_vt_partitioning ( cpi , & vt , tile , BLOCK_64X64 ,   mi_row , mi_col , 8 ) ) {  for ( i = 0 ; i < 4 ; ++ i ) { const int x32_idx = ( ( i & 1 ) << 2 ) ; const int y32_idx = ( ( i >> 1 ) << 2 ) ;  if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , tile , BLOCK_32X32 ,   ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , 4 ) ) {  for ( j = 0 ; j < 4 ; ++ j ) { const int x16_idx = ( ( j & 1 ) << 1 ) ; const int y16_idx = ( ( j >> 1 ) << 1 ) ;  # define DISABLE_8X8_VAR_BASED_PARTITION  # ifdef DISABLE_8X8_VAR_BASED_PARTITION  if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows &&   mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) {  set_block_size ( cpi , tile , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , BLOCK_16X16 ) ; } else { for ( k = 0 ; k < 4 ; ++ k ) { const int x8_idx = ( k & 1 ) ; const int y8_idx = ( k >> 1 ) ;  set_block_size ( cpi , tile ,  ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ; } } # else  if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile ,  BLOCK_16X16 ,  ( mi_row + y32_idx + y16_idx ) ,   ( mi_col + x32_idx + x16_idx ) , 2 ) ) {  for ( k = 0 ; k < 4 ; ++ k ) { const int x8_idx = ( k & 1 ) ; const int y8_idx = ( k >> 1 ) ;  set_block_size ( cpi , tile ,  ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ; } }  # endif  } } } } }","const int i2 = i << 2 ;for ( j = 0 ;if ( variance4x4downsample [ i2 + j ] == 1 ) {v16x16 * vtemp = ( ! is_key_frame ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . part_variances . none ) ;if ( vt . split [ i ] . part_variances . none . variance > thresholds [ 1 ] ) {force_split [ i + 1 ] = 1 ;force_split [ 0 ] = 1 ;}}}if ( ! force_split [ 0 ] ) {fill_variance_tree ( & vtemp -> split [ m ] , BLOCK_8X8 ) ;fill_variance_tree ( vtemp , BLOCK_16X16 ) ;}}fill_variance_tree ( & vt , BLOCK_64X64 ) ;get_variance ( & vt . split [ j ] , BLOCK_16X16 ) ;}fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ;}fill_variance_tree ( & vt . part_variances . none ) ;}if ( mi_col + 8 > cm -> mi_cols || mi_row + 8 > cm -> mi_rows || ! set_vt_partitioning ( cpi , x , xd , & vt , BLOCK_64X64 , mi_row , mi_col , 8 ) ) {for ( i = 0 ;const int i2 = i << 2 ;if ( ! set_vt_partitioning ( cpi , x , xd , & vt . split [ i ] , BLOCK_32X32 , ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , thresholds [ 1 ] , BLOCK_16X16 , force_split [ i + 1 ] ) ) {for ( j = 0 ;v16x16 * vtemp = ( ! is_key_frame && variance4x4downsample [ i2 + j ] == 1 ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ;if ( ! set_vt_partitioning ( cpi , x , xd , vtemp , BLOCK_16X16 , mi_row + y32_idx + y16_idx , mi_col + x32_idx + x16_idx + 1 < cm -> mi_cols ) {set_block_size ( cpi , tile , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx , thresholds [ 2 ] , cpi -> vbp_bsize_min , force_split [ 5 + i2 + j ] ) ) {if ( use_4x4_partition ) {if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile , BLOCK_16X16 , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , 2 ) ) {for ( k = 0 ;set_block_size ( cpi , x , xd , & vtemp -> split [ k ] , BLOCK_8X8 , mi_row + y32_idx + y16_idx + y8_idx , mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ;}}return 0 ;",2210
68,"buggy line: static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de ,  struct inode * inode , int regard_xa )  {int cnt , sig ;struct inode * reloc ;if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ;init_rock_state ( & rs , inode ) ;setup_rock_ridge ( de , inode , & rs ) ;if ( regard_xa ) {rs . chr += 14 ;cwe id:CWE-20context: static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de ,  struct inode * inode , int regard_xa )  { int symlink_len = 0 ;  int cnt , sig ;  struct inode * reloc ; struct rock_ridge * rr ; int rootflag ; struct rock_state rs ; int ret = 0 ; if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ;  if ( regard_xa ) {  rs . chr += 14 ; rs . len -= 14 ; if ( rs . len < 0 ) rs . len = 0 ; } repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { # ifndef CONFIG_ZISOFS case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ; break ; # endif case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'E' , 'R' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ; { int p ; for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) printk ( ""%c"" , rr -> u . ER . data [ p ] ) ; } printk ( ""\\n"" ) ; break ; case SIG ( 'P' , 'X' ) : inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; break ; case SIG ( 'P' , 'N' ) : { int high , low ; high = isonum_733 ( rr -> u . PN . dev_high ) ; low = isonum_733 ( rr -> u . PN . dev_low ) ; if ( ( low & ~ 0xff ) && high == 0 ) { inode -> i_rdev = MKDEV ( low >> 8 , low & 0xff ) ; } else { inode -> i_rdev = MKDEV ( high , low ) ; } } break ; case SIG ( 'T' , 'F' ) : cnt = 0 ; if ( rr -> u . TF . flags & TF_CREATE ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_MODIFY ) { inode -> i_mtime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_mtime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ACCESS ) { inode -> i_atime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_atime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } break ; case SIG ( 'S' , 'L' ) : { int slen ; struct SL_component * slp ; struct SL_component * oldslp ; slen = rr -> len - 5 ; slp = & rr -> u . SL . link ; inode -> i_size = symlink_len ; while ( slen > 1 ) { rootflag = 0 ; switch ( slp -> flags & ~ 1 ) { case 0 : inode -> i_size += slp -> len ; break ; case 2 : inode -> i_size += 1 ; break ; case 4 : inode -> i_size += 2 ; break ; case 8 : rootflag = 1 ; inode -> i_size += 1 ; break ; default : printk ( ""Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>"" ""not<S2SV_blank>implemented\\n"" ) ; } slen -= slp -> len + 2 ; oldslp = slp ; slp = ( struct SL_component * ) ( ( ( char * ) slp ) + slp -> len + 2 ) ; if ( slen < 2 ) { if ( ( ( rr -> u . SL . flags & 1 ) != 0 ) && ( ( oldslp -> flags & 1 ) == 0 ) ) inode -> i_size += 1 ; break ; } if ( ! rootflag && ( oldslp -> flags & 1 ) == 0 ) inode -> i_size += 1 ; } } symlink_len = inode -> i_size ; break ; case SIG ( 'R' , 'E' ) : printk ( KERN_WARNING ""Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>"" ""relocated<S2SV_blank>directory\\n"" ) ; goto out ; case SIG ( 'C' , 'L' ) :  ISOFS_I ( inode ) -> i_first_extent =  isonum_733 ( rr -> u . CL . location ) ; reloc =  isofs_iget ( inode -> i_sb ,   ISOFS_I ( inode ) -> i_first_extent ,  0 ) ; if ( IS_ERR ( reloc ) ) { ret = PTR_ERR ( reloc ) ; goto out ; } inode -> i_mode = reloc -> i_mode ; set_nlink ( inode , reloc -> i_nlink ) ; inode -> i_uid = reloc -> i_uid ; inode -> i_gid = reloc -> i_gid ; inode -> i_rdev = reloc -> i_rdev ; inode -> i_size = reloc -> i_size ; inode -> i_blocks = reloc -> i_blocks ; inode -> i_atime = reloc -> i_atime ; inode -> i_ctime = reloc -> i_ctime ; inode -> i_mtime = reloc -> i_mtime ; iput ( reloc ) ; break ; # ifdef CONFIG_ZISOFS case SIG ( 'Z' , 'F' ) : { int algo ; if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) break ; algo = isonum_721 ( rr -> u . ZF . algorithm ) ; if ( algo == SIG ( 'p' , 'z' ) ) { int block_shift = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; if ( block_shift > 17 ) { printk ( KERN_WARNING ""isofs:<S2SV_blank>"" ""Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>"" ""size<S2SV_blank>of<S2SV_blank>2^%d\\n"" , block_shift ) ; } else { ISOFS_I ( inode ) -> i_file_format = isofs_file_compressed ; ISOFS_I ( inode ) -> i_format_parm [ 0 ] = isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; ISOFS_I ( inode ) -> i_format_parm [ 1 ] = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; inode -> i_size = isonum_733 ( rr -> u . ZF . real_size ) ; } } else { printk ( KERN_WARNING ""isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>"" ""algorithm:<S2SV_blank>%c%c\\n"" , rr -> u . ZF . algorithm [ 0 ] , rr -> u . ZF . algorithm [ 1 ] ) ; } break ; } # endif default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) ret = 0 ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }","static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de , struct inode * inode , int flags ) {int cnt , sig ;unsigned int reloc_block ;struct inode * reloc ;if ( flags & RR_REGARD_XA ) {rs . chr += 14 ;",2211
69,"buggy line: case SIG ( \'S\' , \'L\' ) : {cwe id:CWE-20context: static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de ,  struct inode * inode , int regard_xa )  { int symlink_len = 0 ;  int cnt , sig ;  struct inode * reloc ; struct rock_ridge * rr ; int rootflag ; struct rock_state rs ; int ret = 0 ; if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ;  if ( regard_xa ) {  rs . chr += 14 ; rs . len -= 14 ; if ( rs . len < 0 ) rs . len = 0 ; } repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { # ifndef CONFIG_ZISOFS case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ; break ; # endif case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'E' , 'R' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ; { int p ; for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) printk ( ""%c"" , rr -> u . ER . data [ p ] ) ; } printk ( ""\\n"" ) ; break ; case SIG ( 'P' , 'X' ) : inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; break ; case SIG ( 'P' , 'N' ) : { int high , low ; high = isonum_733 ( rr -> u . PN . dev_high ) ; low = isonum_733 ( rr -> u . PN . dev_low ) ; if ( ( low & ~ 0xff ) && high == 0 ) { inode -> i_rdev = MKDEV ( low >> 8 , low & 0xff ) ; } else { inode -> i_rdev = MKDEV ( high , low ) ; } } break ; case SIG ( 'T' , 'F' ) : cnt = 0 ; if ( rr -> u . TF . flags & TF_CREATE ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_MODIFY ) { inode -> i_mtime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_mtime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ACCESS ) { inode -> i_atime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_atime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } break ; case SIG ( 'S' , 'L' ) : { int slen ; struct SL_component * slp ; struct SL_component * oldslp ; slen = rr -> len - 5 ; slp = & rr -> u . SL . link ; inode -> i_size = symlink_len ; while ( slen > 1 ) { rootflag = 0 ; switch ( slp -> flags & ~ 1 ) { case 0 : inode -> i_size += slp -> len ; break ; case 2 : inode -> i_size += 1 ; break ; case 4 : inode -> i_size += 2 ; break ; case 8 : rootflag = 1 ; inode -> i_size += 1 ; break ; default : printk ( ""Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>"" ""not<S2SV_blank>implemented\\n"" ) ; } slen -= slp -> len + 2 ; oldslp = slp ; slp = ( struct SL_component * ) ( ( ( char * ) slp ) + slp -> len + 2 ) ; if ( slen < 2 ) { if ( ( ( rr -> u . SL . flags & 1 ) != 0 ) && ( ( oldslp -> flags & 1 ) == 0 ) ) inode -> i_size += 1 ; break ; } if ( ! rootflag && ( oldslp -> flags & 1 ) == 0 ) inode -> i_size += 1 ; } } symlink_len = inode -> i_size ; break ; case SIG ( 'R' , 'E' ) : printk ( KERN_WARNING ""Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>"" ""relocated<S2SV_blank>directory\\n"" ) ; goto out ; case SIG ( 'C' , 'L' ) :  ISOFS_I ( inode ) -> i_first_extent =  isonum_733 ( rr -> u . CL . location ) ; reloc =  isofs_iget ( inode -> i_sb ,   ISOFS_I ( inode ) -> i_first_extent ,  0 ) ; if ( IS_ERR ( reloc ) ) { ret = PTR_ERR ( reloc ) ; goto out ; } inode -> i_mode = reloc -> i_mode ; set_nlink ( inode , reloc -> i_nlink ) ; inode -> i_uid = reloc -> i_uid ; inode -> i_gid = reloc -> i_gid ; inode -> i_rdev = reloc -> i_rdev ; inode -> i_size = reloc -> i_size ; inode -> i_blocks = reloc -> i_blocks ; inode -> i_atime = reloc -> i_atime ; inode -> i_ctime = reloc -> i_ctime ; inode -> i_mtime = reloc -> i_mtime ; iput ( reloc ) ; break ; # ifdef CONFIG_ZISOFS case SIG ( 'Z' , 'F' ) : { int algo ; if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) break ; algo = isonum_721 ( rr -> u . ZF . algorithm ) ; if ( algo == SIG ( 'p' , 'z' ) ) { int block_shift = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; if ( block_shift > 17 ) { printk ( KERN_WARNING ""isofs:<S2SV_blank>"" ""Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>"" ""size<S2SV_blank>of<S2SV_blank>2^%d\\n"" , block_shift ) ; } else { ISOFS_I ( inode ) -> i_file_format = isofs_file_compressed ; ISOFS_I ( inode ) -> i_format_parm [ 0 ] = isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; ISOFS_I ( inode ) -> i_format_parm [ 1 ] = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; inode -> i_size = isonum_733 ( rr -> u . ZF . real_size ) ; } } else { printk ( KERN_WARNING ""isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>"" ""algorithm:<S2SV_blank>%c%c\\n"" , rr -> u . ZF . algorithm [ 0 ] , rr -> u . ZF . algorithm [ 1 ] ) ; } break ; } # endif default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) ret = 0 ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }","case SIG ( \'S\' , \'L\' ) : if ( flags & RR_RELOC_DE ) {printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\\goto eio ;}reloc_block = isonum_733 ( rr -> u . CL . location ) ;if ( reloc_block == {",2211
70,"buggy line: case SIG ( \'C\' , \'L\' ) :  ISOFS_I ( inode ) -> i_first_extent =  isonum_733 ( rr -> u . CL . location ) ;reloc =  isofs_iget ( inode -> i_sb ,   ISOFS_I ( inode ) -> i_first_extent ,  0 ) ;cwe id:CWE-20context: static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de ,  struct inode * inode , int regard_xa )  { int symlink_len = 0 ;  int cnt , sig ;  struct inode * reloc ; struct rock_ridge * rr ; int rootflag ; struct rock_state rs ; int ret = 0 ; if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ;  if ( regard_xa ) {  rs . chr += 14 ; rs . len -= 14 ; if ( rs . len < 0 ) rs . len = 0 ; } repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { # ifndef CONFIG_ZISOFS case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ; break ; # endif case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'E' , 'R' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ; { int p ; for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) printk ( ""%c"" , rr -> u . ER . data [ p ] ) ; } printk ( ""\\n"" ) ; break ; case SIG ( 'P' , 'X' ) : inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; break ; case SIG ( 'P' , 'N' ) : { int high , low ; high = isonum_733 ( rr -> u . PN . dev_high ) ; low = isonum_733 ( rr -> u . PN . dev_low ) ; if ( ( low & ~ 0xff ) && high == 0 ) { inode -> i_rdev = MKDEV ( low >> 8 , low & 0xff ) ; } else { inode -> i_rdev = MKDEV ( high , low ) ; } } break ; case SIG ( 'T' , 'F' ) : cnt = 0 ; if ( rr -> u . TF . flags & TF_CREATE ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_MODIFY ) { inode -> i_mtime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_mtime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ACCESS ) { inode -> i_atime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_atime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } break ; case SIG ( 'S' , 'L' ) : { int slen ; struct SL_component * slp ; struct SL_component * oldslp ; slen = rr -> len - 5 ; slp = & rr -> u . SL . link ; inode -> i_size = symlink_len ; while ( slen > 1 ) { rootflag = 0 ; switch ( slp -> flags & ~ 1 ) { case 0 : inode -> i_size += slp -> len ; break ; case 2 : inode -> i_size += 1 ; break ; case 4 : inode -> i_size += 2 ; break ; case 8 : rootflag = 1 ; inode -> i_size += 1 ; break ; default : printk ( ""Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>"" ""not<S2SV_blank>implemented\\n"" ) ; } slen -= slp -> len + 2 ; oldslp = slp ; slp = ( struct SL_component * ) ( ( ( char * ) slp ) + slp -> len + 2 ) ; if ( slen < 2 ) { if ( ( ( rr -> u . SL . flags & 1 ) != 0 ) && ( ( oldslp -> flags & 1 ) == 0 ) ) inode -> i_size += 1 ; break ; } if ( ! rootflag && ( oldslp -> flags & 1 ) == 0 ) inode -> i_size += 1 ; } } symlink_len = inode -> i_size ; break ; case SIG ( 'R' , 'E' ) : printk ( KERN_WARNING ""Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>"" ""relocated<S2SV_blank>directory\\n"" ) ; goto out ; case SIG ( 'C' , 'L' ) :  ISOFS_I ( inode ) -> i_first_extent =  isonum_733 ( rr -> u . CL . location ) ; reloc =  isofs_iget ( inode -> i_sb ,   ISOFS_I ( inode ) -> i_first_extent ,  0 ) ; if ( IS_ERR ( reloc ) ) { ret = PTR_ERR ( reloc ) ; goto out ; } inode -> i_mode = reloc -> i_mode ; set_nlink ( inode , reloc -> i_nlink ) ; inode -> i_uid = reloc -> i_uid ; inode -> i_gid = reloc -> i_gid ; inode -> i_rdev = reloc -> i_rdev ; inode -> i_size = reloc -> i_size ; inode -> i_blocks = reloc -> i_blocks ; inode -> i_atime = reloc -> i_atime ; inode -> i_ctime = reloc -> i_ctime ; inode -> i_mtime = reloc -> i_mtime ; iput ( reloc ) ; break ; # ifdef CONFIG_ZISOFS case SIG ( 'Z' , 'F' ) : { int algo ; if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) break ; algo = isonum_721 ( rr -> u . ZF . algorithm ) ; if ( algo == SIG ( 'p' , 'z' ) ) { int block_shift = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; if ( block_shift > 17 ) { printk ( KERN_WARNING ""isofs:<S2SV_blank>"" ""Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>"" ""size<S2SV_blank>of<S2SV_blank>2^%d\\n"" , block_shift ) ; } else { ISOFS_I ( inode ) -> i_file_format = isofs_file_compressed ; ISOFS_I ( inode ) -> i_format_parm [ 0 ] = isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; ISOFS_I ( inode ) -> i_format_parm [ 1 ] = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; inode -> i_size = isonum_733 ( rr -> u . ZF . real_size ) ; } } else { printk ( KERN_WARNING ""isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>"" ""algorithm:<S2SV_blank>%c%c\\n"" , rr -> u . ZF . algorithm [ 0 ] , rr -> u . ZF . algorithm [ 1 ] ) ; } break ; } # endif default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) ret = 0 ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }","case SIG ( \'C\' , \'L\' ) : ISOFS_I ( inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) {printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\\goto eio ;}ISOFS_I ( inode ) -> i_first_extent = reloc_block ;reloc = isofs_iget_reloc ( inode -> i_sb , ISOFS_I ( inode ) -> i_first_extent , 0 ) ;",2211
71,"buggy line: if ( regs && ! perf_exclude_event ( event , regs ) ) {if ( ! ( event -> attr . exclude_idle && current -> pid == 0 ) )  if ( perf_event_overflow ( event , 0 , & data , regs ) )  ret = HRTIMER_NORESTART ;cwe id:CWE-400context: static enum hrtimer_restart perf_swevent_hrtimer ( struct hrtimer * hrtimer ) { enum hrtimer_restart ret = HRTIMER_RESTART ; struct perf_sample_data data ; struct pt_regs * regs ; struct perf_event * event ; u64 period ; event = container_of ( hrtimer , struct perf_event , hw . hrtimer ) ; if ( event -> state != PERF_EVENT_STATE_ACTIVE ) return HRTIMER_NORESTART ; event -> pmu -> read ( event ) ; perf_sample_data_init ( & data , 0 ) ; data . period = event -> hw . last_period ; regs = get_irq_regs ( ) ; if ( regs && ! perf_exclude_event ( event , regs ) ) { if ( ! ( event -> attr . exclude_idle && current -> pid == 0 ) )  if ( perf_event_overflow ( event , 0 , & data , regs ) )  ret = HRTIMER_NORESTART ; } period = max_t ( u64 , 10000 , event -> hw . sample_period ) ; hrtimer_forward_now ( hrtimer , ns_to_ktime ( period ) ) ; return ret ; }","if ( regs && ! perf_exclude_event ( event , & data , regs ) ) ret = HRTIMER_NORESTART ;",2212
72,"buggy line: struct pstore * ps = get_info ( store ) ;uint32_t stride ;chunk_t next_free ;stride = ( ps -> exceptions_per_area + 1 ) ;next_free = ++ ps -> next_free ;if ( sector_div ( next_free , stride ) == 1 )  ps -> next_free ++ ;atomic_inc ( & ps -> pending_count ) ;cwe id:CWE-264context: static int persistent_prepare_exception ( struct dm_exception_store * store , struct dm_exception * e ) {  struct pstore * ps = get_info ( store ) ;  uint32_t stride ; chunk_t next_free ; sector_t size = get_dev_size ( dm_snap_cow ( store -> snap ) -> bdev ) ; if ( size < ( ( ps -> next_free + 1 ) * store -> chunk_size ) ) return - ENOSPC ; e -> new_chunk = ps -> next_free ;  stride = ( ps -> exceptions_per_area + 1 ) ;  next_free = ++ ps -> next_free ; if ( sector_div ( next_free , stride ) == 1 )  ps -> next_free ++ ;  atomic_inc ( & ps -> pending_count ) ; return 0 ; }","struct pstore * ps = get_info ( store ) ;ps -> next_free ;if ( sector_div ( next_free , stride ) == 1 ) ps -> next_free ++ ;skip_metadata ( ps ) ;atomic_inc ( & ps -> pending_count ) ;",2213
73,"buggy line: return - ETIMEDOUT ;}cwe id:CWE-401context: static int htc_setup_complete ( struct htc_target * target ) { struct sk_buff * skb ; struct htc_comp_msg * comp_msg ; int ret = 0 ; unsigned long time_left ; skb = alloc_skb ( 50 + sizeof ( struct htc_frame_hdr ) , GFP_ATOMIC ) ; if ( ! skb ) { dev_err ( target -> dev , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>send<S2SV_blank>buffer\\n"" ) ; return - ENOMEM ; } skb_reserve ( skb , sizeof ( struct htc_frame_hdr ) ) ; comp_msg = skb_put ( skb , sizeof ( struct htc_comp_msg ) ) ; comp_msg -> msg_id = cpu_to_be16 ( HTC_MSG_SETUP_COMPLETE_ID ) ; target -> htc_flags |= HTC_OP_START_WAIT ; ret = htc_issue_send ( target , skb , skb -> len , 0 , ENDPOINT0 ) ; if ( ret ) goto err ; time_left = wait_for_completion_timeout ( & target -> cmd_wait , HZ ) ; if ( ! time_left ) { dev_err ( target -> dev , ""HTC<S2SV_blank>start<S2SV_blank>timeout\\n"" ) ;  return - ETIMEDOUT ;  } return 0 ; err : kfree_skb ( skb ) ; return - EINVAL ; }",kfree_skb ( skb ) ;return - ETIMEDOUT ;},2214
74,"buggy line: fc = EXTRACT_LE_16BITS ( p ) ;seq = EXTRACT_LE_8BITS ( p + 2 ) ;p += 3 ;caplen -= 3 ;ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ;if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ;switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) {case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;break ;case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;return hdrlen ;case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}panid = EXTRACT_LE_16BITS ( p ) ;if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag )  ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ;p += 2 ;caplen -= 2 ;hdrlen += 2 ;cwe id:CWE-125context: u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag )  ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ;  p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen ; }",fc = EXTRACT_LE_16BITS ( p ) ) ) ;,2215
75,"buggy line: stmt_ty AsyncFunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq  * decorator_list , expr_ty returns , int lineno , int col_offset ,  int end_lineno , int end_col_offset , PyArena * arena ) {cwe id:CWE-125context: stmt_ty AsyncFunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq  * decorator_list , expr_ty returns , int lineno , int col_offset ,  int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! name ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>name<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFunctionDef"" ) ; return NULL ; } if ( ! args ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>args<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFunctionDef"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFunctionDef_kind ; p -> v . AsyncFunctionDef . name = name ; p -> v . AsyncFunctionDef . args = args ; p -> v . AsyncFunctionDef . body = body ; p -> v . AsyncFunctionDef . decorator_list = decorator_list ;  p -> v . AsyncFunctionDef . returns = returns ;  p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","stmt_ty AsyncFunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq * decorator_list , expr_ty returns , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",2216
76,"buggy line: p -> v . AsyncFunctionDef . returns = returns ;p -> lineno = lineno ;cwe id:CWE-125context: stmt_ty AsyncFunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq  * decorator_list , expr_ty returns , int lineno , int col_offset ,  int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! name ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>name<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFunctionDef"" ) ; return NULL ; } if ( ! args ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>args<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFunctionDef"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFunctionDef_kind ; p -> v . AsyncFunctionDef . name = name ; p -> v . AsyncFunctionDef . args = args ; p -> v . AsyncFunctionDef . body = body ; p -> v . AsyncFunctionDef . decorator_list = decorator_list ;  p -> v . AsyncFunctionDef . returns = returns ;  p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }",p -> v . AsyncFunctionDef . returns = returns ;p -> v . AsyncFunctionDef . type_comment = type_comment ;p -> lineno = lineno ;,2216
77,buggy line: frag = ( hm_fragment * ) item -> data ;OPENSSL_free ( frag -> fragment ) ;cwe id:CWE-119context: static void dtls1_clear_queues ( SSL * s ) { pitem * item = NULL ; hm_fragment * frag = NULL ; DTLS1_RECORD_DATA * rdata ; while ( ( item = pqueue_pop ( s -> d1 -> unprocessed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> processed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> sent_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ) != NULL ) {  frag = ( hm_fragment * ) item -> data ;  OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } },frag = ( hm_fragment * ) item -> data ;OPENSSL_free ( frag -> fragment ) ;,2217
78,"buggy line: if ( ( entry -> flags & SC_ASN1_UNSIGNED )  && obj [ 0 ] == 0x00 && objlen > 1 ) {objlen -- ;cwe id:CWE-119context: static int asn1_decode_entry ( sc_context_t * ctx , struct sc_asn1_entry * entry , const u8 * obj , size_t objlen , int depth ) { void * parm = entry -> parm ; int ( * callback_func ) ( sc_context_t * nctx , void * arg , const u8 * nobj , size_t nobjlen , int ndepth ) ; size_t * len = ( size_t * ) entry -> arg ; int r = 0 ; callback_func = parm ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""%*.*sdecoding<S2SV_blank>\'%s\',<S2SV_blank>raw<S2SV_blank>data:%s%s\\n"" , depth , depth , """" , entry -> name , sc_dump_hex ( obj , objlen > 16 ? 16 : objlen ) , objlen > 16 ? ""..."" : """" ) ; switch ( entry -> type ) { case SC_ASN1_STRUCT : if ( parm != NULL ) r = asn1_decode ( ctx , ( struct sc_asn1_entry * ) parm , obj , objlen , NULL , NULL , 0 , depth + 1 ) ; break ; case SC_ASN1_NULL : break ; case SC_ASN1_BOOLEAN : if ( parm != NULL ) { if ( objlen != 1 ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""invalid<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>length:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u\\n"" , objlen ) ; r = SC_ERROR_INVALID_ASN1_OBJECT ; } else * ( ( int * ) parm ) = obj [ 0 ] ? 1 : 0 ; } break ; case SC_ASN1_INTEGER : case SC_ASN1_ENUMERATED : if ( parm != NULL ) { r = sc_asn1_decode_integer ( obj , objlen , ( int * ) entry -> parm ) ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""%*.*sdecoding<S2SV_blank>\'%s\'<S2SV_blank>returned<S2SV_blank>%d\\n"" , depth , depth , """" , entry -> name , * ( ( int * ) entry -> parm ) ) ; } break ; case SC_ASN1_BIT_STRING_NI : case SC_ASN1_BIT_STRING : if ( parm != NULL ) { int invert = entry -> type == SC_ASN1_BIT_STRING ? 1 : 0 ; assert ( len != NULL ) ; if ( objlen < 1 ) { r = SC_ERROR_INVALID_ASN1_OBJECT ; break ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen - 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen - 1 ; parm = * buf ; } r = decode_bit_string ( obj , objlen , ( u8 * ) parm , * len , invert ) ; if ( r >= 0 ) { * len = r ; r = 0 ; } } break ; case SC_ASN1_BIT_FIELD : if ( parm != NULL ) r = decode_bit_field ( obj , objlen , ( u8 * ) parm , * len ) ; break ; case SC_ASN1_OCTET_STRING : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( ( entry -> flags & SC_ASN1_UNSIGNED )  && obj [ 0 ] == 0x00 && objlen > 1 ) {  objlen -- ; obj ++ ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_GENERALIZEDTIME : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_OBJECT : if ( parm != NULL ) r = sc_asn1_decode_object_id ( obj , objlen , ( struct sc_object_id * ) parm ) ; break ; case SC_ASN1_PRINTABLESTRING : case SC_ASN1_UTF8STRING : if ( parm != NULL ) { assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen + 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen + 1 ; parm = * buf ; } r = sc_asn1_decode_utf8string ( obj , objlen , ( u8 * ) parm , len ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { * len -= 1 ; } } break ; case SC_ASN1_PATH : if ( entry -> parm != NULL ) r = asn1_decode_path ( ctx , obj , objlen , ( sc_path_t * ) parm , depth ) ; break ; case SC_ASN1_PKCS15_ID : if ( entry -> parm != NULL ) { struct sc_pkcs15_id * id = ( struct sc_pkcs15_id * ) parm ; size_t c = objlen > sizeof ( id -> value ) ? sizeof ( id -> value ) : objlen ; memcpy ( id -> value , obj , c ) ; id -> len = c ; } break ; case SC_ASN1_PKCS15_OBJECT : if ( entry -> parm != NULL ) r = asn1_decode_p15_object ( ctx , obj , objlen , ( struct sc_asn1_pkcs15_object * ) parm , depth ) ; break ; case SC_ASN1_ALGORITHM_ID : if ( entry -> parm != NULL ) r = sc_asn1_decode_algorithm_id ( ctx , obj , objlen , ( struct sc_algorithm_id * ) parm , depth ) ; break ; case SC_ASN1_SE_INFO : if ( entry -> parm != NULL ) r = asn1_decode_se_info ( ctx , obj , objlen , ( sc_pkcs15_sec_env_info_t * * * ) entry -> parm , len , depth ) ; break ; case SC_ASN1_CALLBACK : if ( entry -> parm != NULL ) r = callback_func ( ctx , entry -> arg , obj , objlen , depth ) ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""invalid<S2SV_blank>ASN.1<S2SV_blank>type:<S2SV_blank>%d\\n"" , entry -> type ) ; return SC_ERROR_INVALID_ASN1_OBJECT ; } if ( r ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""decoding<S2SV_blank>of<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>\'%s\'<S2SV_blank>failed:<S2SV_blank>%s\\n"" , entry -> name , sc_strerror ( r ) ) ; return r ; } entry -> flags |= SC_ASN1_PRESENT ; return 0 ; }",if ( ( entry -> flags & SC_ASN1_UNSIGNED ) && objlen > 1 && obj [ 0 ] == 0x00 ) {objlen -- ;,2218
79,"buggy line: err |= get_user ( length , & up -> length ) ;up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ;cwe id:CWE-200context: static int do_video_set_spu_palette ( unsigned int fd , unsigned int cmd , struct compat_video_spu_palette __user * up ) { struct video_spu_palette __user * up_native ; compat_uptr_t palp ; int length , err ; err = get_user ( palp , & up -> palette ) ;  err |= get_user ( length , & up -> length ) ;  up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ; err = put_user ( compat_ptr ( palp ) , & up_native -> palette ) ; err |= put_user ( length , & up_native -> length ) ; if ( err ) return - EFAULT ; err = sys_ioctl ( fd , cmd , ( unsigned long ) up_native ) ; return err ; }","err |= get_user ( length , & up -> length ) ;if ( err ) return - EFAULT ;up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ;",2219
80,"buggy line: if ( map_data )  copy = true ;cwe id:CWE-416context: int blk_rq_map_user_iov ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , const struct iov_iter * iter , gfp_t gfp_mask ) { bool copy = false ; unsigned long align = q -> dma_pad_mask | queue_dma_alignment ( q ) ; struct bio * bio = NULL ; struct iov_iter i ; int ret ;  if ( map_data )  copy = true ; else if ( iov_iter_alignment ( iter ) & align ) copy = true ; else if ( queue_virt_boundary ( q ) ) copy = queue_virt_boundary ( q ) & iov_iter_gap_alignment ( iter ) ; i = * iter ; do { ret = __blk_rq_map_user_iov ( rq , map_data , & i , gfp_mask , copy ) ; if ( ret ) goto unmap_rq ; if ( ! bio ) bio = rq -> bio ; } while ( iov_iter_count ( & i ) ) ; if ( ! bio_flagged ( bio , BIO_USER_MAPPED ) ) rq -> cmd_flags |= REQ_COPY_USER ; return 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ;  rq -> bio = NULL ;  return - EINVAL ; }",if ( ! iter_is_iovec ( iter ) ) goto fail ;if ( map_data ) copy = true ;,2220
81,"buggy line: rq -> bio = NULL ;return - EINVAL ;cwe id:CWE-416context: int blk_rq_map_user_iov ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , const struct iov_iter * iter , gfp_t gfp_mask ) { bool copy = false ; unsigned long align = q -> dma_pad_mask | queue_dma_alignment ( q ) ; struct bio * bio = NULL ; struct iov_iter i ; int ret ;  if ( map_data )  copy = true ; else if ( iov_iter_alignment ( iter ) & align ) copy = true ; else if ( queue_virt_boundary ( q ) ) copy = queue_virt_boundary ( q ) & iov_iter_gap_alignment ( iter ) ; i = * iter ; do { ret = __blk_rq_map_user_iov ( rq , map_data , & i , gfp_mask , copy ) ; if ( ret ) goto unmap_rq ; if ( ! bio ) bio = rq -> bio ; } while ( iov_iter_count ( & i ) ) ; if ( ! bio_flagged ( bio , BIO_USER_MAPPED ) ) rq -> cmd_flags |= REQ_COPY_USER ; return 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ;  rq -> bio = NULL ;  return - EINVAL ; }",fail : rq -> bio = NULL ;return - EINVAL ;,2220
82,"buggy line: opt = xchg ( & np -> opt , NULL ) ;if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;pktopt = xchg ( & np -> pktoptions , NULL ) ;cwe id:CWE-264context: static int do_ipv6_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct net * net = sock_net ( sk ) ; int val , valbool ; int retv = - ENOPROTOOPT ; bool needs_rtnl = setsockopt_needs_rtnl ( optname ) ; if ( ! optval ) val = 0 ; else { if ( optlen >= sizeof ( int ) ) { if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; } else val = 0 ; } valbool = ( val != 0 ) ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_setsockopt ( sk , optname , optval , optlen ) ; if ( needs_rtnl ) rtnl_lock ( ) ; lock_sock ( sk ) ; switch ( optname ) { case IPV6_ADDRFORM : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val == PF_INET ) { struct ipv6_txoptions * opt ; struct sk_buff * pktopt ; if ( sk -> sk_type == SOCK_RAW ) break ; if ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_UDPLITE ) { struct udp_sock * up = udp_sk ( sk ) ; if ( up -> pending == AF_INET6 ) { retv = - EBUSY ; break ; } } else if ( sk -> sk_protocol != IPPROTO_TCP ) break ; if ( sk -> sk_state != TCP_ESTABLISHED ) { retv = - ENOTCONN ; break ; } if ( ipv6_only_sock ( sk ) || ! ipv6_addr_v4mapped ( & sk -> sk_v6_daddr ) ) { retv = - EADDRNOTAVAIL ; break ; } fl6_free_socklist ( sk ) ; ipv6_sock_mc_close ( sk ) ; sk_refcnt_debug_dec ( sk ) ; if ( sk -> sk_protocol == IPPROTO_TCP ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , & tcp_prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = & tcp_prot ; icsk -> icsk_af_ops = & ipv4_specific ; sk -> sk_socket -> ops = & inet_stream_ops ; sk -> sk_family = PF_INET ; tcp_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } else { struct proto * prot = & udp_prot ; if ( sk -> sk_protocol == IPPROTO_UDPLITE ) prot = & udplite_prot ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = prot ; sk -> sk_socket -> ops = & inet_dgram_ops ; sk -> sk_family = PF_INET ; }  opt = xchg ( & np -> opt , NULL ) ;  if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  pktopt = xchg ( & np -> pktoptions , NULL ) ; kfree_skb ( pktopt ) ; sk -> sk_destruct = inet_sock_destruct ; sk_refcnt_debug_inc ( sk ) ; module_put ( THIS_MODULE ) ; retv = 0 ; break ; } goto e_inval ; case IPV6_V6ONLY : if ( optlen < sizeof ( int ) || inet_sk ( sk ) -> inet_num ) goto e_inval ; sk -> sk_ipv6only = valbool ; retv = 0 ; break ; case IPV6_RECVPKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxinfo = valbool ; retv = 0 ; break ; case IPV6_2292PKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxoinfo = valbool ; retv = 0 ; break ; case IPV6_RECVHOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxhlim = valbool ; retv = 0 ; break ; case IPV6_2292HOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxohlim = valbool ; retv = 0 ; break ; case IPV6_RECVRTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . srcrt = valbool ; retv = 0 ; break ; case IPV6_2292RTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . osrcrt = valbool ; retv = 0 ; break ; case IPV6_RECVHOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . hopopts = valbool ; retv = 0 ; break ; case IPV6_2292HOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . ohopopts = valbool ; retv = 0 ; break ; case IPV6_RECVDSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . dstopts = valbool ; retv = 0 ; break ; case IPV6_2292DSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . odstopts = valbool ; retv = 0 ; break ; case IPV6_TCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < - 1 || val > 0xff ) goto e_inval ; if ( val == - 1 ) val = 0 ; np -> tclass = val ; retv = 0 ; break ; case IPV6_RECVTCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxtclass = valbool ; retv = 0 ; break ; case IPV6_FLOWINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxflow = valbool ; retv = 0 ; break ; case IPV6_RECVPATHMTU : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxpmtu = valbool ; retv = 0 ; break ; case IPV6_TRANSPARENT : if ( valbool && ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) { retv = - EPERM ; break ; } if ( optlen < sizeof ( int ) ) goto e_inval ; inet_sk ( sk ) -> transparent = valbool ; retv = 0 ; break ; case IPV6_RECVORIGDSTADDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxorigdstaddr = valbool ; retv = 0 ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; if ( optlen == 0 ) optval = NULL ; else if ( ! optval ) goto e_inval ; else if ( optlen < sizeof ( struct ipv6_opt_hdr ) || optlen & 0x7 || optlen > 8 * 255 ) goto e_inval ; retv = - EPERM ; if ( optname != IPV6_RTHDR && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) break ;  opt = ipv6_renew_options ( sk , np -> opt , optname ,  ( struct ipv6_opt_hdr __user * ) optval , optlen ) ; if ( IS_ERR ( opt ) ) { retv = PTR_ERR ( opt ) ; break ; } retv = - EINVAL ; if ( optname == IPV6_RTHDR && opt && opt -> srcrt ) { struct ipv6_rt_hdr * rthdr = opt -> srcrt ; switch ( rthdr -> type ) { # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) case IPV6_SRCRT_TYPE_2 : if ( rthdr -> hdrlen != 2 || rthdr -> segments_left != 1 ) goto sticky_done ; break ; # endif default : goto sticky_done ; } } retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; sticky_done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_PKTINFO : { struct in6_pktinfo pkt ; if ( optlen == 0 ) goto e_inval ; else if ( optlen < sizeof ( struct in6_pktinfo ) || ! optval ) goto e_inval ; if ( copy_from_user ( & pkt , optval , sizeof ( struct in6_pktinfo ) ) ) { retv = - EFAULT ; break ; } if ( sk -> sk_bound_dev_if && pkt . ipi6_ifindex != sk -> sk_bound_dev_if ) goto e_inval ; np -> sticky_pktinfo . ipi6_ifindex = pkt . ipi6_ifindex ; np -> sticky_pktinfo . ipi6_addr = pkt . ipi6_addr ; retv = 0 ; break ; } case IPV6_2292PKTOPTIONS : { struct ipv6_txoptions * opt = NULL ; struct msghdr msg ; struct flowi6 fl6 ; int junk ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; if ( optlen == 0 ) goto update ; retv = - EINVAL ; if ( optlen > 64 * 1024 ) break ; opt = sock_kmalloc ( sk , sizeof ( * opt ) + optlen , GFP_KERNEL ) ; retv = - ENOBUFS ; if ( ! opt ) break ; memset ( opt , 0 , sizeof ( * opt ) ) ;  opt -> tot_len = sizeof ( * opt ) + optlen ;  retv = - EFAULT ; if ( copy_from_user ( opt + 1 , optval , optlen ) ) goto done ; msg . msg_controllen = optlen ; msg . msg_control = ( void * ) ( opt + 1 ) ; retv = ip6_datagram_send_ctl ( net , sk , & msg , & fl6 , opt , & junk , & junk , & junk ) ; if ( retv ) goto done ; update : retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_UNICAST_HOPS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> hop_limit = val ; retv = 0 ; break ; case IPV6_MULTICAST_HOPS : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> mcast_hops = ( val == - 1 ? IPV6_DEFAULT_MCASTHOPS : val ) ; retv = 0 ; break ; case IPV6_MULTICAST_LOOP : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val != valbool ) goto e_inval ; np -> mc_loop = valbool ; retv = 0 ; break ; case IPV6_UNICAST_IF : { struct net_device * dev = NULL ; int ifindex ; if ( optlen != sizeof ( int ) ) goto e_inval ; ifindex = ( __force int ) ntohl ( ( __force __be32 ) val ) ; if ( ifindex == 0 ) { np -> ucast_oif = 0 ; retv = 0 ; break ; } dev = dev_get_by_index ( net , ifindex ) ; retv = - EADDRNOTAVAIL ; if ( ! dev ) break ; dev_put ( dev ) ; retv = - EINVAL ; if ( sk -> sk_bound_dev_if ) break ; np -> ucast_oif = ifindex ; retv = 0 ; break ; } case IPV6_MULTICAST_IF : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val ) { struct net_device * dev ; if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != val ) goto e_inval ; dev = dev_get_by_index ( net , val ) ; if ( ! dev ) { retv = - ENODEV ; break ; } dev_put ( dev ) ; } np -> mcast_oif = val ; retv = 0 ; break ; case IPV6_ADD_MEMBERSHIP : case IPV6_DROP_MEMBERSHIP : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EPROTO ; if ( inet_sk ( sk ) -> is_icsk ) break ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_ADD_MEMBERSHIP ) retv = ipv6_sock_mc_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; else retv = ipv6_sock_mc_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; break ; } case IPV6_JOIN_ANYCAST : case IPV6_LEAVE_ANYCAST : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_JOIN_ANYCAST ) retv = ipv6_sock_ac_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; else retv = ipv6_sock_ac_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; break ; } case MCAST_JOIN_GROUP : case MCAST_LEAVE_GROUP : { struct group_req greq ; struct sockaddr_in6 * psin6 ; if ( optlen < sizeof ( struct group_req ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & greq , optval , sizeof ( struct group_req ) ) ) break ; if ( greq . gr_group . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } psin6 = ( struct sockaddr_in6 * ) & greq . gr_group ; if ( optname == MCAST_JOIN_GROUP ) retv = ipv6_sock_mc_join ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; else retv = ipv6_sock_mc_drop ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; break ; } case MCAST_JOIN_SOURCE_GROUP : case MCAST_LEAVE_SOURCE_GROUP : case MCAST_BLOCK_SOURCE : case MCAST_UNBLOCK_SOURCE : { struct group_source_req greqs ; int omode , add ; if ( optlen < sizeof ( struct group_source_req ) ) goto e_inval ; if ( copy_from_user ( & greqs , optval , sizeof ( greqs ) ) ) { retv = - EFAULT ; break ; } if ( greqs . gsr_group . ss_family != AF_INET6 || greqs . gsr_source . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } if ( optname == MCAST_BLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 1 ; } else if ( optname == MCAST_UNBLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 0 ; } else if ( optname == MCAST_JOIN_SOURCE_GROUP ) { struct sockaddr_in6 * psin6 ; psin6 = ( struct sockaddr_in6 * ) & greqs . gsr_group ; retv = ipv6_sock_mc_join ( sk , greqs . gsr_interface , & psin6 -> sin6_addr ) ; if ( retv && retv != - EADDRINUSE ) break ; omode = MCAST_INCLUDE ; add = 1 ; } else { omode = MCAST_INCLUDE ; add = 0 ; } retv = ip6_mc_source ( add , omode , sk , & greqs ) ; break ; } case MCAST_MSFILTER : { struct group_filter * gsf ; if ( optlen < GROUP_FILTER_SIZE ( 0 ) ) goto e_inval ; if ( optlen > sysctl_optmem_max ) { retv = - ENOBUFS ; break ; } gsf = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! gsf ) { retv = - ENOBUFS ; break ; } retv = - EFAULT ; if ( copy_from_user ( gsf , optval , optlen ) ) { kfree ( gsf ) ; break ; } if ( gsf -> gf_numsrc >= 0x1ffffffU || gsf -> gf_numsrc > sysctl_mld_max_msf ) { kfree ( gsf ) ; retv = - ENOBUFS ; break ; } if ( GROUP_FILTER_SIZE ( gsf -> gf_numsrc ) > optlen ) { kfree ( gsf ) ; retv = - EINVAL ; break ; } retv = ip6_mc_msfilter ( sk , gsf ) ; kfree ( gsf ) ; break ; } case IPV6_ROUTER_ALERT : if ( optlen < sizeof ( int ) ) goto e_inval ; retv = ip6_ra_control ( sk , val ) ; break ; case IPV6_MTU_DISCOVER : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT ) goto e_inval ; np -> pmtudisc = val ; retv = 0 ; break ; case IPV6_MTU : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val && val < IPV6_MIN_MTU ) goto e_inval ; np -> frag_size = val ; retv = 0 ; break ; case IPV6_RECVERR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> recverr = valbool ; if ( ! val ) skb_queue_purge ( & sk -> sk_error_queue ) ; retv = 0 ; break ; case IPV6_FLOWINFO_SEND : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> sndflow = valbool ; retv = 0 ; break ; case IPV6_FLOWLABEL_MGR : retv = ipv6_flowlabel_opt ( sk , optval , optlen ) ; break ; case IPV6_IPSEC_POLICY : case IPV6_XFRM_POLICY : retv = - EPERM ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) break ; retv = xfrm_user_policy ( sk , optname , optval , optlen ) ; break ; case IPV6_ADDR_PREFERENCES : { unsigned int pref = 0 ; unsigned int prefmask = ~ 0 ; if ( optlen < sizeof ( int ) ) goto e_inval ; retv = - EINVAL ; switch ( val & ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP | IPV6_PREFER_SRC_PUBTMP_DEFAULT ) ) { case IPV6_PREFER_SRC_PUBLIC : pref |= IPV6_PREFER_SRC_PUBLIC ; break ; case IPV6_PREFER_SRC_TMP : pref |= IPV6_PREFER_SRC_TMP ; break ; case IPV6_PREFER_SRC_PUBTMP_DEFAULT : break ; case 0 : goto pref_skip_pubtmp ; default : goto e_inval ; } prefmask &= ~ ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP ) ; pref_skip_pubtmp : switch ( val & ( IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA ) ) { case IPV6_PREFER_SRC_HOME : break ; case IPV6_PREFER_SRC_COA : pref |= IPV6_PREFER_SRC_COA ; case 0 : goto pref_skip_coa ; default : goto e_inval ; } prefmask &= ~ IPV6_PREFER_SRC_COA ; pref_skip_coa : switch ( val & ( IPV6_PREFER_SRC_CGA | IPV6_PREFER_SRC_NONCGA ) ) { case IPV6_PREFER_SRC_CGA : case IPV6_PREFER_SRC_NONCGA : case 0 : break ; default : goto e_inval ; } np -> srcprefs = ( np -> srcprefs & prefmask ) | pref ; retv = 0 ; break ; } case IPV6_MINHOPCOUNT : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < 0 || val > 255 ) goto e_inval ; np -> min_hopcount = val ; retv = 0 ; break ; case IPV6_DONTFRAG : np -> dontfrag = valbool ; retv = 0 ; break ; case IPV6_AUTOFLOWLABEL : np -> autoflowlabel = valbool ; retv = 0 ; break ; } release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return retv ; e_inval : release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return - EINVAL ; }","opt = xchg ( ( __force struct ipv6_txoptions * * ) & np -> opt , NULL ) ;if ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}pktopt = xchg ( & np -> pktoptions , NULL ) ;",2221
83,"buggy line: opt = ipv6_renew_options ( sk , np -> opt , optname ,  ( struct ipv6_opt_hdr __user * ) optval , optlen ) ;if ( IS_ERR ( opt ) ) {retv = PTR_ERR ( opt ) ;cwe id:CWE-264context: static int do_ipv6_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct net * net = sock_net ( sk ) ; int val , valbool ; int retv = - ENOPROTOOPT ; bool needs_rtnl = setsockopt_needs_rtnl ( optname ) ; if ( ! optval ) val = 0 ; else { if ( optlen >= sizeof ( int ) ) { if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; } else val = 0 ; } valbool = ( val != 0 ) ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_setsockopt ( sk , optname , optval , optlen ) ; if ( needs_rtnl ) rtnl_lock ( ) ; lock_sock ( sk ) ; switch ( optname ) { case IPV6_ADDRFORM : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val == PF_INET ) { struct ipv6_txoptions * opt ; struct sk_buff * pktopt ; if ( sk -> sk_type == SOCK_RAW ) break ; if ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_UDPLITE ) { struct udp_sock * up = udp_sk ( sk ) ; if ( up -> pending == AF_INET6 ) { retv = - EBUSY ; break ; } } else if ( sk -> sk_protocol != IPPROTO_TCP ) break ; if ( sk -> sk_state != TCP_ESTABLISHED ) { retv = - ENOTCONN ; break ; } if ( ipv6_only_sock ( sk ) || ! ipv6_addr_v4mapped ( & sk -> sk_v6_daddr ) ) { retv = - EADDRNOTAVAIL ; break ; } fl6_free_socklist ( sk ) ; ipv6_sock_mc_close ( sk ) ; sk_refcnt_debug_dec ( sk ) ; if ( sk -> sk_protocol == IPPROTO_TCP ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , & tcp_prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = & tcp_prot ; icsk -> icsk_af_ops = & ipv4_specific ; sk -> sk_socket -> ops = & inet_stream_ops ; sk -> sk_family = PF_INET ; tcp_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } else { struct proto * prot = & udp_prot ; if ( sk -> sk_protocol == IPPROTO_UDPLITE ) prot = & udplite_prot ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = prot ; sk -> sk_socket -> ops = & inet_dgram_ops ; sk -> sk_family = PF_INET ; }  opt = xchg ( & np -> opt , NULL ) ;  if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  pktopt = xchg ( & np -> pktoptions , NULL ) ; kfree_skb ( pktopt ) ; sk -> sk_destruct = inet_sock_destruct ; sk_refcnt_debug_inc ( sk ) ; module_put ( THIS_MODULE ) ; retv = 0 ; break ; } goto e_inval ; case IPV6_V6ONLY : if ( optlen < sizeof ( int ) || inet_sk ( sk ) -> inet_num ) goto e_inval ; sk -> sk_ipv6only = valbool ; retv = 0 ; break ; case IPV6_RECVPKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxinfo = valbool ; retv = 0 ; break ; case IPV6_2292PKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxoinfo = valbool ; retv = 0 ; break ; case IPV6_RECVHOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxhlim = valbool ; retv = 0 ; break ; case IPV6_2292HOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxohlim = valbool ; retv = 0 ; break ; case IPV6_RECVRTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . srcrt = valbool ; retv = 0 ; break ; case IPV6_2292RTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . osrcrt = valbool ; retv = 0 ; break ; case IPV6_RECVHOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . hopopts = valbool ; retv = 0 ; break ; case IPV6_2292HOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . ohopopts = valbool ; retv = 0 ; break ; case IPV6_RECVDSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . dstopts = valbool ; retv = 0 ; break ; case IPV6_2292DSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . odstopts = valbool ; retv = 0 ; break ; case IPV6_TCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < - 1 || val > 0xff ) goto e_inval ; if ( val == - 1 ) val = 0 ; np -> tclass = val ; retv = 0 ; break ; case IPV6_RECVTCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxtclass = valbool ; retv = 0 ; break ; case IPV6_FLOWINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxflow = valbool ; retv = 0 ; break ; case IPV6_RECVPATHMTU : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxpmtu = valbool ; retv = 0 ; break ; case IPV6_TRANSPARENT : if ( valbool && ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) { retv = - EPERM ; break ; } if ( optlen < sizeof ( int ) ) goto e_inval ; inet_sk ( sk ) -> transparent = valbool ; retv = 0 ; break ; case IPV6_RECVORIGDSTADDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxorigdstaddr = valbool ; retv = 0 ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; if ( optlen == 0 ) optval = NULL ; else if ( ! optval ) goto e_inval ; else if ( optlen < sizeof ( struct ipv6_opt_hdr ) || optlen & 0x7 || optlen > 8 * 255 ) goto e_inval ; retv = - EPERM ; if ( optname != IPV6_RTHDR && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) break ;  opt = ipv6_renew_options ( sk , np -> opt , optname ,  ( struct ipv6_opt_hdr __user * ) optval , optlen ) ; if ( IS_ERR ( opt ) ) { retv = PTR_ERR ( opt ) ; break ; } retv = - EINVAL ; if ( optname == IPV6_RTHDR && opt && opt -> srcrt ) { struct ipv6_rt_hdr * rthdr = opt -> srcrt ; switch ( rthdr -> type ) { # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) case IPV6_SRCRT_TYPE_2 : if ( rthdr -> hdrlen != 2 || rthdr -> segments_left != 1 ) goto sticky_done ; break ; # endif default : goto sticky_done ; } } retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; sticky_done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_PKTINFO : { struct in6_pktinfo pkt ; if ( optlen == 0 ) goto e_inval ; else if ( optlen < sizeof ( struct in6_pktinfo ) || ! optval ) goto e_inval ; if ( copy_from_user ( & pkt , optval , sizeof ( struct in6_pktinfo ) ) ) { retv = - EFAULT ; break ; } if ( sk -> sk_bound_dev_if && pkt . ipi6_ifindex != sk -> sk_bound_dev_if ) goto e_inval ; np -> sticky_pktinfo . ipi6_ifindex = pkt . ipi6_ifindex ; np -> sticky_pktinfo . ipi6_addr = pkt . ipi6_addr ; retv = 0 ; break ; } case IPV6_2292PKTOPTIONS : { struct ipv6_txoptions * opt = NULL ; struct msghdr msg ; struct flowi6 fl6 ; int junk ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; if ( optlen == 0 ) goto update ; retv = - EINVAL ; if ( optlen > 64 * 1024 ) break ; opt = sock_kmalloc ( sk , sizeof ( * opt ) + optlen , GFP_KERNEL ) ; retv = - ENOBUFS ; if ( ! opt ) break ; memset ( opt , 0 , sizeof ( * opt ) ) ;  opt -> tot_len = sizeof ( * opt ) + optlen ;  retv = - EFAULT ; if ( copy_from_user ( opt + 1 , optval , optlen ) ) goto done ; msg . msg_controllen = optlen ; msg . msg_control = ( void * ) ( opt + 1 ) ; retv = ip6_datagram_send_ctl ( net , sk , & msg , & fl6 , opt , & junk , & junk , & junk ) ; if ( retv ) goto done ; update : retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_UNICAST_HOPS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> hop_limit = val ; retv = 0 ; break ; case IPV6_MULTICAST_HOPS : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> mcast_hops = ( val == - 1 ? IPV6_DEFAULT_MCASTHOPS : val ) ; retv = 0 ; break ; case IPV6_MULTICAST_LOOP : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val != valbool ) goto e_inval ; np -> mc_loop = valbool ; retv = 0 ; break ; case IPV6_UNICAST_IF : { struct net_device * dev = NULL ; int ifindex ; if ( optlen != sizeof ( int ) ) goto e_inval ; ifindex = ( __force int ) ntohl ( ( __force __be32 ) val ) ; if ( ifindex == 0 ) { np -> ucast_oif = 0 ; retv = 0 ; break ; } dev = dev_get_by_index ( net , ifindex ) ; retv = - EADDRNOTAVAIL ; if ( ! dev ) break ; dev_put ( dev ) ; retv = - EINVAL ; if ( sk -> sk_bound_dev_if ) break ; np -> ucast_oif = ifindex ; retv = 0 ; break ; } case IPV6_MULTICAST_IF : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val ) { struct net_device * dev ; if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != val ) goto e_inval ; dev = dev_get_by_index ( net , val ) ; if ( ! dev ) { retv = - ENODEV ; break ; } dev_put ( dev ) ; } np -> mcast_oif = val ; retv = 0 ; break ; case IPV6_ADD_MEMBERSHIP : case IPV6_DROP_MEMBERSHIP : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EPROTO ; if ( inet_sk ( sk ) -> is_icsk ) break ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_ADD_MEMBERSHIP ) retv = ipv6_sock_mc_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; else retv = ipv6_sock_mc_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; break ; } case IPV6_JOIN_ANYCAST : case IPV6_LEAVE_ANYCAST : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_JOIN_ANYCAST ) retv = ipv6_sock_ac_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; else retv = ipv6_sock_ac_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; break ; } case MCAST_JOIN_GROUP : case MCAST_LEAVE_GROUP : { struct group_req greq ; struct sockaddr_in6 * psin6 ; if ( optlen < sizeof ( struct group_req ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & greq , optval , sizeof ( struct group_req ) ) ) break ; if ( greq . gr_group . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } psin6 = ( struct sockaddr_in6 * ) & greq . gr_group ; if ( optname == MCAST_JOIN_GROUP ) retv = ipv6_sock_mc_join ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; else retv = ipv6_sock_mc_drop ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; break ; } case MCAST_JOIN_SOURCE_GROUP : case MCAST_LEAVE_SOURCE_GROUP : case MCAST_BLOCK_SOURCE : case MCAST_UNBLOCK_SOURCE : { struct group_source_req greqs ; int omode , add ; if ( optlen < sizeof ( struct group_source_req ) ) goto e_inval ; if ( copy_from_user ( & greqs , optval , sizeof ( greqs ) ) ) { retv = - EFAULT ; break ; } if ( greqs . gsr_group . ss_family != AF_INET6 || greqs . gsr_source . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } if ( optname == MCAST_BLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 1 ; } else if ( optname == MCAST_UNBLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 0 ; } else if ( optname == MCAST_JOIN_SOURCE_GROUP ) { struct sockaddr_in6 * psin6 ; psin6 = ( struct sockaddr_in6 * ) & greqs . gsr_group ; retv = ipv6_sock_mc_join ( sk , greqs . gsr_interface , & psin6 -> sin6_addr ) ; if ( retv && retv != - EADDRINUSE ) break ; omode = MCAST_INCLUDE ; add = 1 ; } else { omode = MCAST_INCLUDE ; add = 0 ; } retv = ip6_mc_source ( add , omode , sk , & greqs ) ; break ; } case MCAST_MSFILTER : { struct group_filter * gsf ; if ( optlen < GROUP_FILTER_SIZE ( 0 ) ) goto e_inval ; if ( optlen > sysctl_optmem_max ) { retv = - ENOBUFS ; break ; } gsf = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! gsf ) { retv = - ENOBUFS ; break ; } retv = - EFAULT ; if ( copy_from_user ( gsf , optval , optlen ) ) { kfree ( gsf ) ; break ; } if ( gsf -> gf_numsrc >= 0x1ffffffU || gsf -> gf_numsrc > sysctl_mld_max_msf ) { kfree ( gsf ) ; retv = - ENOBUFS ; break ; } if ( GROUP_FILTER_SIZE ( gsf -> gf_numsrc ) > optlen ) { kfree ( gsf ) ; retv = - EINVAL ; break ; } retv = ip6_mc_msfilter ( sk , gsf ) ; kfree ( gsf ) ; break ; } case IPV6_ROUTER_ALERT : if ( optlen < sizeof ( int ) ) goto e_inval ; retv = ip6_ra_control ( sk , val ) ; break ; case IPV6_MTU_DISCOVER : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT ) goto e_inval ; np -> pmtudisc = val ; retv = 0 ; break ; case IPV6_MTU : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val && val < IPV6_MIN_MTU ) goto e_inval ; np -> frag_size = val ; retv = 0 ; break ; case IPV6_RECVERR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> recverr = valbool ; if ( ! val ) skb_queue_purge ( & sk -> sk_error_queue ) ; retv = 0 ; break ; case IPV6_FLOWINFO_SEND : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> sndflow = valbool ; retv = 0 ; break ; case IPV6_FLOWLABEL_MGR : retv = ipv6_flowlabel_opt ( sk , optval , optlen ) ; break ; case IPV6_IPSEC_POLICY : case IPV6_XFRM_POLICY : retv = - EPERM ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) break ; retv = xfrm_user_policy ( sk , optname , optval , optlen ) ; break ; case IPV6_ADDR_PREFERENCES : { unsigned int pref = 0 ; unsigned int prefmask = ~ 0 ; if ( optlen < sizeof ( int ) ) goto e_inval ; retv = - EINVAL ; switch ( val & ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP | IPV6_PREFER_SRC_PUBTMP_DEFAULT ) ) { case IPV6_PREFER_SRC_PUBLIC : pref |= IPV6_PREFER_SRC_PUBLIC ; break ; case IPV6_PREFER_SRC_TMP : pref |= IPV6_PREFER_SRC_TMP ; break ; case IPV6_PREFER_SRC_PUBTMP_DEFAULT : break ; case 0 : goto pref_skip_pubtmp ; default : goto e_inval ; } prefmask &= ~ ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP ) ; pref_skip_pubtmp : switch ( val & ( IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA ) ) { case IPV6_PREFER_SRC_HOME : break ; case IPV6_PREFER_SRC_COA : pref |= IPV6_PREFER_SRC_COA ; case 0 : goto pref_skip_coa ; default : goto e_inval ; } prefmask &= ~ IPV6_PREFER_SRC_COA ; pref_skip_coa : switch ( val & ( IPV6_PREFER_SRC_CGA | IPV6_PREFER_SRC_NONCGA ) ) { case IPV6_PREFER_SRC_CGA : case IPV6_PREFER_SRC_NONCGA : case 0 : break ; default : goto e_inval ; } np -> srcprefs = ( np -> srcprefs & prefmask ) | pref ; retv = 0 ; break ; } case IPV6_MINHOPCOUNT : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < 0 || val > 255 ) goto e_inval ; np -> min_hopcount = val ; retv = 0 ; break ; case IPV6_DONTFRAG : np -> dontfrag = valbool ; retv = 0 ; break ; case IPV6_AUTOFLOWLABEL : np -> autoflowlabel = valbool ; retv = 0 ; break ; } release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return retv ; e_inval : release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return - EINVAL ; }","opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ;opt = ipv6_renew_options ( sk , opt , optname , ( struct ipv6_opt_hdr __user * ) optval , optlen ) ;if ( IS_ERR ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}",2221
84,"buggy line: sticky_done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;cwe id:CWE-264context: static int do_ipv6_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct net * net = sock_net ( sk ) ; int val , valbool ; int retv = - ENOPROTOOPT ; bool needs_rtnl = setsockopt_needs_rtnl ( optname ) ; if ( ! optval ) val = 0 ; else { if ( optlen >= sizeof ( int ) ) { if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; } else val = 0 ; } valbool = ( val != 0 ) ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_setsockopt ( sk , optname , optval , optlen ) ; if ( needs_rtnl ) rtnl_lock ( ) ; lock_sock ( sk ) ; switch ( optname ) { case IPV6_ADDRFORM : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val == PF_INET ) { struct ipv6_txoptions * opt ; struct sk_buff * pktopt ; if ( sk -> sk_type == SOCK_RAW ) break ; if ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_UDPLITE ) { struct udp_sock * up = udp_sk ( sk ) ; if ( up -> pending == AF_INET6 ) { retv = - EBUSY ; break ; } } else if ( sk -> sk_protocol != IPPROTO_TCP ) break ; if ( sk -> sk_state != TCP_ESTABLISHED ) { retv = - ENOTCONN ; break ; } if ( ipv6_only_sock ( sk ) || ! ipv6_addr_v4mapped ( & sk -> sk_v6_daddr ) ) { retv = - EADDRNOTAVAIL ; break ; } fl6_free_socklist ( sk ) ; ipv6_sock_mc_close ( sk ) ; sk_refcnt_debug_dec ( sk ) ; if ( sk -> sk_protocol == IPPROTO_TCP ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , & tcp_prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = & tcp_prot ; icsk -> icsk_af_ops = & ipv4_specific ; sk -> sk_socket -> ops = & inet_stream_ops ; sk -> sk_family = PF_INET ; tcp_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } else { struct proto * prot = & udp_prot ; if ( sk -> sk_protocol == IPPROTO_UDPLITE ) prot = & udplite_prot ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = prot ; sk -> sk_socket -> ops = & inet_dgram_ops ; sk -> sk_family = PF_INET ; }  opt = xchg ( & np -> opt , NULL ) ;  if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  pktopt = xchg ( & np -> pktoptions , NULL ) ; kfree_skb ( pktopt ) ; sk -> sk_destruct = inet_sock_destruct ; sk_refcnt_debug_inc ( sk ) ; module_put ( THIS_MODULE ) ; retv = 0 ; break ; } goto e_inval ; case IPV6_V6ONLY : if ( optlen < sizeof ( int ) || inet_sk ( sk ) -> inet_num ) goto e_inval ; sk -> sk_ipv6only = valbool ; retv = 0 ; break ; case IPV6_RECVPKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxinfo = valbool ; retv = 0 ; break ; case IPV6_2292PKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxoinfo = valbool ; retv = 0 ; break ; case IPV6_RECVHOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxhlim = valbool ; retv = 0 ; break ; case IPV6_2292HOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxohlim = valbool ; retv = 0 ; break ; case IPV6_RECVRTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . srcrt = valbool ; retv = 0 ; break ; case IPV6_2292RTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . osrcrt = valbool ; retv = 0 ; break ; case IPV6_RECVHOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . hopopts = valbool ; retv = 0 ; break ; case IPV6_2292HOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . ohopopts = valbool ; retv = 0 ; break ; case IPV6_RECVDSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . dstopts = valbool ; retv = 0 ; break ; case IPV6_2292DSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . odstopts = valbool ; retv = 0 ; break ; case IPV6_TCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < - 1 || val > 0xff ) goto e_inval ; if ( val == - 1 ) val = 0 ; np -> tclass = val ; retv = 0 ; break ; case IPV6_RECVTCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxtclass = valbool ; retv = 0 ; break ; case IPV6_FLOWINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxflow = valbool ; retv = 0 ; break ; case IPV6_RECVPATHMTU : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxpmtu = valbool ; retv = 0 ; break ; case IPV6_TRANSPARENT : if ( valbool && ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) { retv = - EPERM ; break ; } if ( optlen < sizeof ( int ) ) goto e_inval ; inet_sk ( sk ) -> transparent = valbool ; retv = 0 ; break ; case IPV6_RECVORIGDSTADDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxorigdstaddr = valbool ; retv = 0 ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; if ( optlen == 0 ) optval = NULL ; else if ( ! optval ) goto e_inval ; else if ( optlen < sizeof ( struct ipv6_opt_hdr ) || optlen & 0x7 || optlen > 8 * 255 ) goto e_inval ; retv = - EPERM ; if ( optname != IPV6_RTHDR && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) break ;  opt = ipv6_renew_options ( sk , np -> opt , optname ,  ( struct ipv6_opt_hdr __user * ) optval , optlen ) ; if ( IS_ERR ( opt ) ) { retv = PTR_ERR ( opt ) ; break ; } retv = - EINVAL ; if ( optname == IPV6_RTHDR && opt && opt -> srcrt ) { struct ipv6_rt_hdr * rthdr = opt -> srcrt ; switch ( rthdr -> type ) { # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) case IPV6_SRCRT_TYPE_2 : if ( rthdr -> hdrlen != 2 || rthdr -> segments_left != 1 ) goto sticky_done ; break ; # endif default : goto sticky_done ; } } retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; sticky_done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_PKTINFO : { struct in6_pktinfo pkt ; if ( optlen == 0 ) goto e_inval ; else if ( optlen < sizeof ( struct in6_pktinfo ) || ! optval ) goto e_inval ; if ( copy_from_user ( & pkt , optval , sizeof ( struct in6_pktinfo ) ) ) { retv = - EFAULT ; break ; } if ( sk -> sk_bound_dev_if && pkt . ipi6_ifindex != sk -> sk_bound_dev_if ) goto e_inval ; np -> sticky_pktinfo . ipi6_ifindex = pkt . ipi6_ifindex ; np -> sticky_pktinfo . ipi6_addr = pkt . ipi6_addr ; retv = 0 ; break ; } case IPV6_2292PKTOPTIONS : { struct ipv6_txoptions * opt = NULL ; struct msghdr msg ; struct flowi6 fl6 ; int junk ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; if ( optlen == 0 ) goto update ; retv = - EINVAL ; if ( optlen > 64 * 1024 ) break ; opt = sock_kmalloc ( sk , sizeof ( * opt ) + optlen , GFP_KERNEL ) ; retv = - ENOBUFS ; if ( ! opt ) break ; memset ( opt , 0 , sizeof ( * opt ) ) ;  opt -> tot_len = sizeof ( * opt ) + optlen ;  retv = - EFAULT ; if ( copy_from_user ( opt + 1 , optval , optlen ) ) goto done ; msg . msg_controllen = optlen ; msg . msg_control = ( void * ) ( opt + 1 ) ; retv = ip6_datagram_send_ctl ( net , sk , & msg , & fl6 , opt , & junk , & junk , & junk ) ; if ( retv ) goto done ; update : retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_UNICAST_HOPS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> hop_limit = val ; retv = 0 ; break ; case IPV6_MULTICAST_HOPS : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> mcast_hops = ( val == - 1 ? IPV6_DEFAULT_MCASTHOPS : val ) ; retv = 0 ; break ; case IPV6_MULTICAST_LOOP : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val != valbool ) goto e_inval ; np -> mc_loop = valbool ; retv = 0 ; break ; case IPV6_UNICAST_IF : { struct net_device * dev = NULL ; int ifindex ; if ( optlen != sizeof ( int ) ) goto e_inval ; ifindex = ( __force int ) ntohl ( ( __force __be32 ) val ) ; if ( ifindex == 0 ) { np -> ucast_oif = 0 ; retv = 0 ; break ; } dev = dev_get_by_index ( net , ifindex ) ; retv = - EADDRNOTAVAIL ; if ( ! dev ) break ; dev_put ( dev ) ; retv = - EINVAL ; if ( sk -> sk_bound_dev_if ) break ; np -> ucast_oif = ifindex ; retv = 0 ; break ; } case IPV6_MULTICAST_IF : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val ) { struct net_device * dev ; if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != val ) goto e_inval ; dev = dev_get_by_index ( net , val ) ; if ( ! dev ) { retv = - ENODEV ; break ; } dev_put ( dev ) ; } np -> mcast_oif = val ; retv = 0 ; break ; case IPV6_ADD_MEMBERSHIP : case IPV6_DROP_MEMBERSHIP : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EPROTO ; if ( inet_sk ( sk ) -> is_icsk ) break ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_ADD_MEMBERSHIP ) retv = ipv6_sock_mc_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; else retv = ipv6_sock_mc_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; break ; } case IPV6_JOIN_ANYCAST : case IPV6_LEAVE_ANYCAST : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_JOIN_ANYCAST ) retv = ipv6_sock_ac_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; else retv = ipv6_sock_ac_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; break ; } case MCAST_JOIN_GROUP : case MCAST_LEAVE_GROUP : { struct group_req greq ; struct sockaddr_in6 * psin6 ; if ( optlen < sizeof ( struct group_req ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & greq , optval , sizeof ( struct group_req ) ) ) break ; if ( greq . gr_group . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } psin6 = ( struct sockaddr_in6 * ) & greq . gr_group ; if ( optname == MCAST_JOIN_GROUP ) retv = ipv6_sock_mc_join ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; else retv = ipv6_sock_mc_drop ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; break ; } case MCAST_JOIN_SOURCE_GROUP : case MCAST_LEAVE_SOURCE_GROUP : case MCAST_BLOCK_SOURCE : case MCAST_UNBLOCK_SOURCE : { struct group_source_req greqs ; int omode , add ; if ( optlen < sizeof ( struct group_source_req ) ) goto e_inval ; if ( copy_from_user ( & greqs , optval , sizeof ( greqs ) ) ) { retv = - EFAULT ; break ; } if ( greqs . gsr_group . ss_family != AF_INET6 || greqs . gsr_source . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } if ( optname == MCAST_BLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 1 ; } else if ( optname == MCAST_UNBLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 0 ; } else if ( optname == MCAST_JOIN_SOURCE_GROUP ) { struct sockaddr_in6 * psin6 ; psin6 = ( struct sockaddr_in6 * ) & greqs . gsr_group ; retv = ipv6_sock_mc_join ( sk , greqs . gsr_interface , & psin6 -> sin6_addr ) ; if ( retv && retv != - EADDRINUSE ) break ; omode = MCAST_INCLUDE ; add = 1 ; } else { omode = MCAST_INCLUDE ; add = 0 ; } retv = ip6_mc_source ( add , omode , sk , & greqs ) ; break ; } case MCAST_MSFILTER : { struct group_filter * gsf ; if ( optlen < GROUP_FILTER_SIZE ( 0 ) ) goto e_inval ; if ( optlen > sysctl_optmem_max ) { retv = - ENOBUFS ; break ; } gsf = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! gsf ) { retv = - ENOBUFS ; break ; } retv = - EFAULT ; if ( copy_from_user ( gsf , optval , optlen ) ) { kfree ( gsf ) ; break ; } if ( gsf -> gf_numsrc >= 0x1ffffffU || gsf -> gf_numsrc > sysctl_mld_max_msf ) { kfree ( gsf ) ; retv = - ENOBUFS ; break ; } if ( GROUP_FILTER_SIZE ( gsf -> gf_numsrc ) > optlen ) { kfree ( gsf ) ; retv = - EINVAL ; break ; } retv = ip6_mc_msfilter ( sk , gsf ) ; kfree ( gsf ) ; break ; } case IPV6_ROUTER_ALERT : if ( optlen < sizeof ( int ) ) goto e_inval ; retv = ip6_ra_control ( sk , val ) ; break ; case IPV6_MTU_DISCOVER : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT ) goto e_inval ; np -> pmtudisc = val ; retv = 0 ; break ; case IPV6_MTU : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val && val < IPV6_MIN_MTU ) goto e_inval ; np -> frag_size = val ; retv = 0 ; break ; case IPV6_RECVERR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> recverr = valbool ; if ( ! val ) skb_queue_purge ( & sk -> sk_error_queue ) ; retv = 0 ; break ; case IPV6_FLOWINFO_SEND : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> sndflow = valbool ; retv = 0 ; break ; case IPV6_FLOWLABEL_MGR : retv = ipv6_flowlabel_opt ( sk , optval , optlen ) ; break ; case IPV6_IPSEC_POLICY : case IPV6_XFRM_POLICY : retv = - EPERM ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) break ; retv = xfrm_user_policy ( sk , optname , optval , optlen ) ; break ; case IPV6_ADDR_PREFERENCES : { unsigned int pref = 0 ; unsigned int prefmask = ~ 0 ; if ( optlen < sizeof ( int ) ) goto e_inval ; retv = - EINVAL ; switch ( val & ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP | IPV6_PREFER_SRC_PUBTMP_DEFAULT ) ) { case IPV6_PREFER_SRC_PUBLIC : pref |= IPV6_PREFER_SRC_PUBLIC ; break ; case IPV6_PREFER_SRC_TMP : pref |= IPV6_PREFER_SRC_TMP ; break ; case IPV6_PREFER_SRC_PUBTMP_DEFAULT : break ; case 0 : goto pref_skip_pubtmp ; default : goto e_inval ; } prefmask &= ~ ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP ) ; pref_skip_pubtmp : switch ( val & ( IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA ) ) { case IPV6_PREFER_SRC_HOME : break ; case IPV6_PREFER_SRC_COA : pref |= IPV6_PREFER_SRC_COA ; case 0 : goto pref_skip_coa ; default : goto e_inval ; } prefmask &= ~ IPV6_PREFER_SRC_COA ; pref_skip_coa : switch ( val & ( IPV6_PREFER_SRC_CGA | IPV6_PREFER_SRC_NONCGA ) ) { case IPV6_PREFER_SRC_CGA : case IPV6_PREFER_SRC_NONCGA : case 0 : break ; default : goto e_inval ; } np -> srcprefs = ( np -> srcprefs & prefmask ) | pref ; retv = 0 ; break ; } case IPV6_MINHOPCOUNT : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < 0 || val > 255 ) goto e_inval ; np -> min_hopcount = val ; retv = 0 ; break ; case IPV6_DONTFRAG : np -> dontfrag = valbool ; retv = 0 ; break ; case IPV6_AUTOFLOWLABEL : np -> autoflowlabel = valbool ; retv = 0 ; break ; } release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return retv ; e_inval : release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return - EINVAL ; }","sticky_done : if ( opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;",2221
85,"buggy line: cwe id:CWE-264context: static int do_ipv6_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct net * net = sock_net ( sk ) ; int val , valbool ; int retv = - ENOPROTOOPT ; bool needs_rtnl = setsockopt_needs_rtnl ( optname ) ; if ( ! optval ) val = 0 ; else { if ( optlen >= sizeof ( int ) ) { if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; } else val = 0 ; } valbool = ( val != 0 ) ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_setsockopt ( sk , optname , optval , optlen ) ; if ( needs_rtnl ) rtnl_lock ( ) ; lock_sock ( sk ) ; switch ( optname ) { case IPV6_ADDRFORM : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val == PF_INET ) { struct ipv6_txoptions * opt ; struct sk_buff * pktopt ; if ( sk -> sk_type == SOCK_RAW ) break ; if ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_UDPLITE ) { struct udp_sock * up = udp_sk ( sk ) ; if ( up -> pending == AF_INET6 ) { retv = - EBUSY ; break ; } } else if ( sk -> sk_protocol != IPPROTO_TCP ) break ; if ( sk -> sk_state != TCP_ESTABLISHED ) { retv = - ENOTCONN ; break ; } if ( ipv6_only_sock ( sk ) || ! ipv6_addr_v4mapped ( & sk -> sk_v6_daddr ) ) { retv = - EADDRNOTAVAIL ; break ; } fl6_free_socklist ( sk ) ; ipv6_sock_mc_close ( sk ) ; sk_refcnt_debug_dec ( sk ) ; if ( sk -> sk_protocol == IPPROTO_TCP ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , & tcp_prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = & tcp_prot ; icsk -> icsk_af_ops = & ipv4_specific ; sk -> sk_socket -> ops = & inet_stream_ops ; sk -> sk_family = PF_INET ; tcp_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } else { struct proto * prot = & udp_prot ; if ( sk -> sk_protocol == IPPROTO_UDPLITE ) prot = & udplite_prot ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = prot ; sk -> sk_socket -> ops = & inet_dgram_ops ; sk -> sk_family = PF_INET ; }  opt = xchg ( & np -> opt , NULL ) ;  if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  pktopt = xchg ( & np -> pktoptions , NULL ) ; kfree_skb ( pktopt ) ; sk -> sk_destruct = inet_sock_destruct ; sk_refcnt_debug_inc ( sk ) ; module_put ( THIS_MODULE ) ; retv = 0 ; break ; } goto e_inval ; case IPV6_V6ONLY : if ( optlen < sizeof ( int ) || inet_sk ( sk ) -> inet_num ) goto e_inval ; sk -> sk_ipv6only = valbool ; retv = 0 ; break ; case IPV6_RECVPKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxinfo = valbool ; retv = 0 ; break ; case IPV6_2292PKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxoinfo = valbool ; retv = 0 ; break ; case IPV6_RECVHOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxhlim = valbool ; retv = 0 ; break ; case IPV6_2292HOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxohlim = valbool ; retv = 0 ; break ; case IPV6_RECVRTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . srcrt = valbool ; retv = 0 ; break ; case IPV6_2292RTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . osrcrt = valbool ; retv = 0 ; break ; case IPV6_RECVHOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . hopopts = valbool ; retv = 0 ; break ; case IPV6_2292HOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . ohopopts = valbool ; retv = 0 ; break ; case IPV6_RECVDSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . dstopts = valbool ; retv = 0 ; break ; case IPV6_2292DSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . odstopts = valbool ; retv = 0 ; break ; case IPV6_TCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < - 1 || val > 0xff ) goto e_inval ; if ( val == - 1 ) val = 0 ; np -> tclass = val ; retv = 0 ; break ; case IPV6_RECVTCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxtclass = valbool ; retv = 0 ; break ; case IPV6_FLOWINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxflow = valbool ; retv = 0 ; break ; case IPV6_RECVPATHMTU : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxpmtu = valbool ; retv = 0 ; break ; case IPV6_TRANSPARENT : if ( valbool && ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) { retv = - EPERM ; break ; } if ( optlen < sizeof ( int ) ) goto e_inval ; inet_sk ( sk ) -> transparent = valbool ; retv = 0 ; break ; case IPV6_RECVORIGDSTADDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxorigdstaddr = valbool ; retv = 0 ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; if ( optlen == 0 ) optval = NULL ; else if ( ! optval ) goto e_inval ; else if ( optlen < sizeof ( struct ipv6_opt_hdr ) || optlen & 0x7 || optlen > 8 * 255 ) goto e_inval ; retv = - EPERM ; if ( optname != IPV6_RTHDR && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) break ;  opt = ipv6_renew_options ( sk , np -> opt , optname ,  ( struct ipv6_opt_hdr __user * ) optval , optlen ) ; if ( IS_ERR ( opt ) ) { retv = PTR_ERR ( opt ) ; break ; } retv = - EINVAL ; if ( optname == IPV6_RTHDR && opt && opt -> srcrt ) { struct ipv6_rt_hdr * rthdr = opt -> srcrt ; switch ( rthdr -> type ) { # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) case IPV6_SRCRT_TYPE_2 : if ( rthdr -> hdrlen != 2 || rthdr -> segments_left != 1 ) goto sticky_done ; break ; # endif default : goto sticky_done ; } } retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; sticky_done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_PKTINFO : { struct in6_pktinfo pkt ; if ( optlen == 0 ) goto e_inval ; else if ( optlen < sizeof ( struct in6_pktinfo ) || ! optval ) goto e_inval ; if ( copy_from_user ( & pkt , optval , sizeof ( struct in6_pktinfo ) ) ) { retv = - EFAULT ; break ; } if ( sk -> sk_bound_dev_if && pkt . ipi6_ifindex != sk -> sk_bound_dev_if ) goto e_inval ; np -> sticky_pktinfo . ipi6_ifindex = pkt . ipi6_ifindex ; np -> sticky_pktinfo . ipi6_addr = pkt . ipi6_addr ; retv = 0 ; break ; } case IPV6_2292PKTOPTIONS : { struct ipv6_txoptions * opt = NULL ; struct msghdr msg ; struct flowi6 fl6 ; int junk ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; if ( optlen == 0 ) goto update ; retv = - EINVAL ; if ( optlen > 64 * 1024 ) break ; opt = sock_kmalloc ( sk , sizeof ( * opt ) + optlen , GFP_KERNEL ) ; retv = - ENOBUFS ; if ( ! opt ) break ; memset ( opt , 0 , sizeof ( * opt ) ) ;  opt -> tot_len = sizeof ( * opt ) + optlen ;  retv = - EFAULT ; if ( copy_from_user ( opt + 1 , optval , optlen ) ) goto done ; msg . msg_controllen = optlen ; msg . msg_control = ( void * ) ( opt + 1 ) ; retv = ip6_datagram_send_ctl ( net , sk , & msg , & fl6 , opt , & junk , & junk , & junk ) ; if ( retv ) goto done ; update : retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_UNICAST_HOPS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> hop_limit = val ; retv = 0 ; break ; case IPV6_MULTICAST_HOPS : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> mcast_hops = ( val == - 1 ? IPV6_DEFAULT_MCASTHOPS : val ) ; retv = 0 ; break ; case IPV6_MULTICAST_LOOP : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val != valbool ) goto e_inval ; np -> mc_loop = valbool ; retv = 0 ; break ; case IPV6_UNICAST_IF : { struct net_device * dev = NULL ; int ifindex ; if ( optlen != sizeof ( int ) ) goto e_inval ; ifindex = ( __force int ) ntohl ( ( __force __be32 ) val ) ; if ( ifindex == 0 ) { np -> ucast_oif = 0 ; retv = 0 ; break ; } dev = dev_get_by_index ( net , ifindex ) ; retv = - EADDRNOTAVAIL ; if ( ! dev ) break ; dev_put ( dev ) ; retv = - EINVAL ; if ( sk -> sk_bound_dev_if ) break ; np -> ucast_oif = ifindex ; retv = 0 ; break ; } case IPV6_MULTICAST_IF : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val ) { struct net_device * dev ; if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != val ) goto e_inval ; dev = dev_get_by_index ( net , val ) ; if ( ! dev ) { retv = - ENODEV ; break ; } dev_put ( dev ) ; } np -> mcast_oif = val ; retv = 0 ; break ; case IPV6_ADD_MEMBERSHIP : case IPV6_DROP_MEMBERSHIP : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EPROTO ; if ( inet_sk ( sk ) -> is_icsk ) break ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_ADD_MEMBERSHIP ) retv = ipv6_sock_mc_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; else retv = ipv6_sock_mc_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; break ; } case IPV6_JOIN_ANYCAST : case IPV6_LEAVE_ANYCAST : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_JOIN_ANYCAST ) retv = ipv6_sock_ac_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; else retv = ipv6_sock_ac_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; break ; } case MCAST_JOIN_GROUP : case MCAST_LEAVE_GROUP : { struct group_req greq ; struct sockaddr_in6 * psin6 ; if ( optlen < sizeof ( struct group_req ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & greq , optval , sizeof ( struct group_req ) ) ) break ; if ( greq . gr_group . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } psin6 = ( struct sockaddr_in6 * ) & greq . gr_group ; if ( optname == MCAST_JOIN_GROUP ) retv = ipv6_sock_mc_join ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; else retv = ipv6_sock_mc_drop ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; break ; } case MCAST_JOIN_SOURCE_GROUP : case MCAST_LEAVE_SOURCE_GROUP : case MCAST_BLOCK_SOURCE : case MCAST_UNBLOCK_SOURCE : { struct group_source_req greqs ; int omode , add ; if ( optlen < sizeof ( struct group_source_req ) ) goto e_inval ; if ( copy_from_user ( & greqs , optval , sizeof ( greqs ) ) ) { retv = - EFAULT ; break ; } if ( greqs . gsr_group . ss_family != AF_INET6 || greqs . gsr_source . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } if ( optname == MCAST_BLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 1 ; } else if ( optname == MCAST_UNBLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 0 ; } else if ( optname == MCAST_JOIN_SOURCE_GROUP ) { struct sockaddr_in6 * psin6 ; psin6 = ( struct sockaddr_in6 * ) & greqs . gsr_group ; retv = ipv6_sock_mc_join ( sk , greqs . gsr_interface , & psin6 -> sin6_addr ) ; if ( retv && retv != - EADDRINUSE ) break ; omode = MCAST_INCLUDE ; add = 1 ; } else { omode = MCAST_INCLUDE ; add = 0 ; } retv = ip6_mc_source ( add , omode , sk , & greqs ) ; break ; } case MCAST_MSFILTER : { struct group_filter * gsf ; if ( optlen < GROUP_FILTER_SIZE ( 0 ) ) goto e_inval ; if ( optlen > sysctl_optmem_max ) { retv = - ENOBUFS ; break ; } gsf = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! gsf ) { retv = - ENOBUFS ; break ; } retv = - EFAULT ; if ( copy_from_user ( gsf , optval , optlen ) ) { kfree ( gsf ) ; break ; } if ( gsf -> gf_numsrc >= 0x1ffffffU || gsf -> gf_numsrc > sysctl_mld_max_msf ) { kfree ( gsf ) ; retv = - ENOBUFS ; break ; } if ( GROUP_FILTER_SIZE ( gsf -> gf_numsrc ) > optlen ) { kfree ( gsf ) ; retv = - EINVAL ; break ; } retv = ip6_mc_msfilter ( sk , gsf ) ; kfree ( gsf ) ; break ; } case IPV6_ROUTER_ALERT : if ( optlen < sizeof ( int ) ) goto e_inval ; retv = ip6_ra_control ( sk , val ) ; break ; case IPV6_MTU_DISCOVER : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT ) goto e_inval ; np -> pmtudisc = val ; retv = 0 ; break ; case IPV6_MTU : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val && val < IPV6_MIN_MTU ) goto e_inval ; np -> frag_size = val ; retv = 0 ; break ; case IPV6_RECVERR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> recverr = valbool ; if ( ! val ) skb_queue_purge ( & sk -> sk_error_queue ) ; retv = 0 ; break ; case IPV6_FLOWINFO_SEND : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> sndflow = valbool ; retv = 0 ; break ; case IPV6_FLOWLABEL_MGR : retv = ipv6_flowlabel_opt ( sk , optval , optlen ) ; break ; case IPV6_IPSEC_POLICY : case IPV6_XFRM_POLICY : retv = - EPERM ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) break ; retv = xfrm_user_policy ( sk , optname , optval , optlen ) ; break ; case IPV6_ADDR_PREFERENCES : { unsigned int pref = 0 ; unsigned int prefmask = ~ 0 ; if ( optlen < sizeof ( int ) ) goto e_inval ; retv = - EINVAL ; switch ( val & ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP | IPV6_PREFER_SRC_PUBTMP_DEFAULT ) ) { case IPV6_PREFER_SRC_PUBLIC : pref |= IPV6_PREFER_SRC_PUBLIC ; break ; case IPV6_PREFER_SRC_TMP : pref |= IPV6_PREFER_SRC_TMP ; break ; case IPV6_PREFER_SRC_PUBTMP_DEFAULT : break ; case 0 : goto pref_skip_pubtmp ; default : goto e_inval ; } prefmask &= ~ ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP ) ; pref_skip_pubtmp : switch ( val & ( IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA ) ) { case IPV6_PREFER_SRC_HOME : break ; case IPV6_PREFER_SRC_COA : pref |= IPV6_PREFER_SRC_COA ; case 0 : goto pref_skip_coa ; default : goto e_inval ; } prefmask &= ~ IPV6_PREFER_SRC_COA ; pref_skip_coa : switch ( val & ( IPV6_PREFER_SRC_CGA | IPV6_PREFER_SRC_NONCGA ) ) { case IPV6_PREFER_SRC_CGA : case IPV6_PREFER_SRC_NONCGA : case 0 : break ; default : goto e_inval ; } np -> srcprefs = ( np -> srcprefs & prefmask ) | pref ; retv = 0 ; break ; } case IPV6_MINHOPCOUNT : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < 0 || val > 255 ) goto e_inval ; np -> min_hopcount = val ; retv = 0 ; break ; case IPV6_DONTFRAG : np -> dontfrag = valbool ; retv = 0 ; break ; case IPV6_AUTOFLOWLABEL : np -> autoflowlabel = valbool ; retv = 0 ; break ; } release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return retv ; e_inval : release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return - EINVAL ; }","atomic_set ( & opt -> refcnt , 1 ) ;",2221
86,"buggy line: opt -> tot_len = sizeof ( * opt ) + optlen ;retv = - EFAULT ;cwe id:CWE-264context: static int do_ipv6_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct net * net = sock_net ( sk ) ; int val , valbool ; int retv = - ENOPROTOOPT ; bool needs_rtnl = setsockopt_needs_rtnl ( optname ) ; if ( ! optval ) val = 0 ; else { if ( optlen >= sizeof ( int ) ) { if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; } else val = 0 ; } valbool = ( val != 0 ) ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_setsockopt ( sk , optname , optval , optlen ) ; if ( needs_rtnl ) rtnl_lock ( ) ; lock_sock ( sk ) ; switch ( optname ) { case IPV6_ADDRFORM : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val == PF_INET ) { struct ipv6_txoptions * opt ; struct sk_buff * pktopt ; if ( sk -> sk_type == SOCK_RAW ) break ; if ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_UDPLITE ) { struct udp_sock * up = udp_sk ( sk ) ; if ( up -> pending == AF_INET6 ) { retv = - EBUSY ; break ; } } else if ( sk -> sk_protocol != IPPROTO_TCP ) break ; if ( sk -> sk_state != TCP_ESTABLISHED ) { retv = - ENOTCONN ; break ; } if ( ipv6_only_sock ( sk ) || ! ipv6_addr_v4mapped ( & sk -> sk_v6_daddr ) ) { retv = - EADDRNOTAVAIL ; break ; } fl6_free_socklist ( sk ) ; ipv6_sock_mc_close ( sk ) ; sk_refcnt_debug_dec ( sk ) ; if ( sk -> sk_protocol == IPPROTO_TCP ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , & tcp_prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = & tcp_prot ; icsk -> icsk_af_ops = & ipv4_specific ; sk -> sk_socket -> ops = & inet_stream_ops ; sk -> sk_family = PF_INET ; tcp_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } else { struct proto * prot = & udp_prot ; if ( sk -> sk_protocol == IPPROTO_UDPLITE ) prot = & udplite_prot ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = prot ; sk -> sk_socket -> ops = & inet_dgram_ops ; sk -> sk_family = PF_INET ; }  opt = xchg ( & np -> opt , NULL ) ;  if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  pktopt = xchg ( & np -> pktoptions , NULL ) ; kfree_skb ( pktopt ) ; sk -> sk_destruct = inet_sock_destruct ; sk_refcnt_debug_inc ( sk ) ; module_put ( THIS_MODULE ) ; retv = 0 ; break ; } goto e_inval ; case IPV6_V6ONLY : if ( optlen < sizeof ( int ) || inet_sk ( sk ) -> inet_num ) goto e_inval ; sk -> sk_ipv6only = valbool ; retv = 0 ; break ; case IPV6_RECVPKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxinfo = valbool ; retv = 0 ; break ; case IPV6_2292PKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxoinfo = valbool ; retv = 0 ; break ; case IPV6_RECVHOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxhlim = valbool ; retv = 0 ; break ; case IPV6_2292HOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxohlim = valbool ; retv = 0 ; break ; case IPV6_RECVRTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . srcrt = valbool ; retv = 0 ; break ; case IPV6_2292RTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . osrcrt = valbool ; retv = 0 ; break ; case IPV6_RECVHOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . hopopts = valbool ; retv = 0 ; break ; case IPV6_2292HOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . ohopopts = valbool ; retv = 0 ; break ; case IPV6_RECVDSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . dstopts = valbool ; retv = 0 ; break ; case IPV6_2292DSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . odstopts = valbool ; retv = 0 ; break ; case IPV6_TCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < - 1 || val > 0xff ) goto e_inval ; if ( val == - 1 ) val = 0 ; np -> tclass = val ; retv = 0 ; break ; case IPV6_RECVTCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxtclass = valbool ; retv = 0 ; break ; case IPV6_FLOWINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxflow = valbool ; retv = 0 ; break ; case IPV6_RECVPATHMTU : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxpmtu = valbool ; retv = 0 ; break ; case IPV6_TRANSPARENT : if ( valbool && ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) { retv = - EPERM ; break ; } if ( optlen < sizeof ( int ) ) goto e_inval ; inet_sk ( sk ) -> transparent = valbool ; retv = 0 ; break ; case IPV6_RECVORIGDSTADDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxorigdstaddr = valbool ; retv = 0 ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; if ( optlen == 0 ) optval = NULL ; else if ( ! optval ) goto e_inval ; else if ( optlen < sizeof ( struct ipv6_opt_hdr ) || optlen & 0x7 || optlen > 8 * 255 ) goto e_inval ; retv = - EPERM ; if ( optname != IPV6_RTHDR && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) break ;  opt = ipv6_renew_options ( sk , np -> opt , optname ,  ( struct ipv6_opt_hdr __user * ) optval , optlen ) ; if ( IS_ERR ( opt ) ) { retv = PTR_ERR ( opt ) ; break ; } retv = - EINVAL ; if ( optname == IPV6_RTHDR && opt && opt -> srcrt ) { struct ipv6_rt_hdr * rthdr = opt -> srcrt ; switch ( rthdr -> type ) { # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) case IPV6_SRCRT_TYPE_2 : if ( rthdr -> hdrlen != 2 || rthdr -> segments_left != 1 ) goto sticky_done ; break ; # endif default : goto sticky_done ; } } retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; sticky_done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_PKTINFO : { struct in6_pktinfo pkt ; if ( optlen == 0 ) goto e_inval ; else if ( optlen < sizeof ( struct in6_pktinfo ) || ! optval ) goto e_inval ; if ( copy_from_user ( & pkt , optval , sizeof ( struct in6_pktinfo ) ) ) { retv = - EFAULT ; break ; } if ( sk -> sk_bound_dev_if && pkt . ipi6_ifindex != sk -> sk_bound_dev_if ) goto e_inval ; np -> sticky_pktinfo . ipi6_ifindex = pkt . ipi6_ifindex ; np -> sticky_pktinfo . ipi6_addr = pkt . ipi6_addr ; retv = 0 ; break ; } case IPV6_2292PKTOPTIONS : { struct ipv6_txoptions * opt = NULL ; struct msghdr msg ; struct flowi6 fl6 ; int junk ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; if ( optlen == 0 ) goto update ; retv = - EINVAL ; if ( optlen > 64 * 1024 ) break ; opt = sock_kmalloc ( sk , sizeof ( * opt ) + optlen , GFP_KERNEL ) ; retv = - ENOBUFS ; if ( ! opt ) break ; memset ( opt , 0 , sizeof ( * opt ) ) ;  opt -> tot_len = sizeof ( * opt ) + optlen ;  retv = - EFAULT ; if ( copy_from_user ( opt + 1 , optval , optlen ) ) goto done ; msg . msg_controllen = optlen ; msg . msg_control = ( void * ) ( opt + 1 ) ; retv = ip6_datagram_send_ctl ( net , sk , & msg , & fl6 , opt , & junk , & junk , & junk ) ; if ( retv ) goto done ; update : retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_UNICAST_HOPS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> hop_limit = val ; retv = 0 ; break ; case IPV6_MULTICAST_HOPS : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> mcast_hops = ( val == - 1 ? IPV6_DEFAULT_MCASTHOPS : val ) ; retv = 0 ; break ; case IPV6_MULTICAST_LOOP : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val != valbool ) goto e_inval ; np -> mc_loop = valbool ; retv = 0 ; break ; case IPV6_UNICAST_IF : { struct net_device * dev = NULL ; int ifindex ; if ( optlen != sizeof ( int ) ) goto e_inval ; ifindex = ( __force int ) ntohl ( ( __force __be32 ) val ) ; if ( ifindex == 0 ) { np -> ucast_oif = 0 ; retv = 0 ; break ; } dev = dev_get_by_index ( net , ifindex ) ; retv = - EADDRNOTAVAIL ; if ( ! dev ) break ; dev_put ( dev ) ; retv = - EINVAL ; if ( sk -> sk_bound_dev_if ) break ; np -> ucast_oif = ifindex ; retv = 0 ; break ; } case IPV6_MULTICAST_IF : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val ) { struct net_device * dev ; if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != val ) goto e_inval ; dev = dev_get_by_index ( net , val ) ; if ( ! dev ) { retv = - ENODEV ; break ; } dev_put ( dev ) ; } np -> mcast_oif = val ; retv = 0 ; break ; case IPV6_ADD_MEMBERSHIP : case IPV6_DROP_MEMBERSHIP : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EPROTO ; if ( inet_sk ( sk ) -> is_icsk ) break ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_ADD_MEMBERSHIP ) retv = ipv6_sock_mc_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; else retv = ipv6_sock_mc_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; break ; } case IPV6_JOIN_ANYCAST : case IPV6_LEAVE_ANYCAST : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_JOIN_ANYCAST ) retv = ipv6_sock_ac_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; else retv = ipv6_sock_ac_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; break ; } case MCAST_JOIN_GROUP : case MCAST_LEAVE_GROUP : { struct group_req greq ; struct sockaddr_in6 * psin6 ; if ( optlen < sizeof ( struct group_req ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & greq , optval , sizeof ( struct group_req ) ) ) break ; if ( greq . gr_group . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } psin6 = ( struct sockaddr_in6 * ) & greq . gr_group ; if ( optname == MCAST_JOIN_GROUP ) retv = ipv6_sock_mc_join ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; else retv = ipv6_sock_mc_drop ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; break ; } case MCAST_JOIN_SOURCE_GROUP : case MCAST_LEAVE_SOURCE_GROUP : case MCAST_BLOCK_SOURCE : case MCAST_UNBLOCK_SOURCE : { struct group_source_req greqs ; int omode , add ; if ( optlen < sizeof ( struct group_source_req ) ) goto e_inval ; if ( copy_from_user ( & greqs , optval , sizeof ( greqs ) ) ) { retv = - EFAULT ; break ; } if ( greqs . gsr_group . ss_family != AF_INET6 || greqs . gsr_source . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } if ( optname == MCAST_BLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 1 ; } else if ( optname == MCAST_UNBLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 0 ; } else if ( optname == MCAST_JOIN_SOURCE_GROUP ) { struct sockaddr_in6 * psin6 ; psin6 = ( struct sockaddr_in6 * ) & greqs . gsr_group ; retv = ipv6_sock_mc_join ( sk , greqs . gsr_interface , & psin6 -> sin6_addr ) ; if ( retv && retv != - EADDRINUSE ) break ; omode = MCAST_INCLUDE ; add = 1 ; } else { omode = MCAST_INCLUDE ; add = 0 ; } retv = ip6_mc_source ( add , omode , sk , & greqs ) ; break ; } case MCAST_MSFILTER : { struct group_filter * gsf ; if ( optlen < GROUP_FILTER_SIZE ( 0 ) ) goto e_inval ; if ( optlen > sysctl_optmem_max ) { retv = - ENOBUFS ; break ; } gsf = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! gsf ) { retv = - ENOBUFS ; break ; } retv = - EFAULT ; if ( copy_from_user ( gsf , optval , optlen ) ) { kfree ( gsf ) ; break ; } if ( gsf -> gf_numsrc >= 0x1ffffffU || gsf -> gf_numsrc > sysctl_mld_max_msf ) { kfree ( gsf ) ; retv = - ENOBUFS ; break ; } if ( GROUP_FILTER_SIZE ( gsf -> gf_numsrc ) > optlen ) { kfree ( gsf ) ; retv = - EINVAL ; break ; } retv = ip6_mc_msfilter ( sk , gsf ) ; kfree ( gsf ) ; break ; } case IPV6_ROUTER_ALERT : if ( optlen < sizeof ( int ) ) goto e_inval ; retv = ip6_ra_control ( sk , val ) ; break ; case IPV6_MTU_DISCOVER : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT ) goto e_inval ; np -> pmtudisc = val ; retv = 0 ; break ; case IPV6_MTU : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val && val < IPV6_MIN_MTU ) goto e_inval ; np -> frag_size = val ; retv = 0 ; break ; case IPV6_RECVERR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> recverr = valbool ; if ( ! val ) skb_queue_purge ( & sk -> sk_error_queue ) ; retv = 0 ; break ; case IPV6_FLOWINFO_SEND : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> sndflow = valbool ; retv = 0 ; break ; case IPV6_FLOWLABEL_MGR : retv = ipv6_flowlabel_opt ( sk , optval , optlen ) ; break ; case IPV6_IPSEC_POLICY : case IPV6_XFRM_POLICY : retv = - EPERM ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) break ; retv = xfrm_user_policy ( sk , optname , optval , optlen ) ; break ; case IPV6_ADDR_PREFERENCES : { unsigned int pref = 0 ; unsigned int prefmask = ~ 0 ; if ( optlen < sizeof ( int ) ) goto e_inval ; retv = - EINVAL ; switch ( val & ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP | IPV6_PREFER_SRC_PUBTMP_DEFAULT ) ) { case IPV6_PREFER_SRC_PUBLIC : pref |= IPV6_PREFER_SRC_PUBLIC ; break ; case IPV6_PREFER_SRC_TMP : pref |= IPV6_PREFER_SRC_TMP ; break ; case IPV6_PREFER_SRC_PUBTMP_DEFAULT : break ; case 0 : goto pref_skip_pubtmp ; default : goto e_inval ; } prefmask &= ~ ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP ) ; pref_skip_pubtmp : switch ( val & ( IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA ) ) { case IPV6_PREFER_SRC_HOME : break ; case IPV6_PREFER_SRC_COA : pref |= IPV6_PREFER_SRC_COA ; case 0 : goto pref_skip_coa ; default : goto e_inval ; } prefmask &= ~ IPV6_PREFER_SRC_COA ; pref_skip_coa : switch ( val & ( IPV6_PREFER_SRC_CGA | IPV6_PREFER_SRC_NONCGA ) ) { case IPV6_PREFER_SRC_CGA : case IPV6_PREFER_SRC_NONCGA : case 0 : break ; default : goto e_inval ; } np -> srcprefs = ( np -> srcprefs & prefmask ) | pref ; retv = 0 ; break ; } case IPV6_MINHOPCOUNT : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < 0 || val > 255 ) goto e_inval ; np -> min_hopcount = val ; retv = 0 ; break ; case IPV6_DONTFRAG : np -> dontfrag = valbool ; retv = 0 ; break ; case IPV6_AUTOFLOWLABEL : np -> autoflowlabel = valbool ; retv = 0 ; break ; } release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return retv ; e_inval : release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return - EINVAL ; }",opt -> tot_len = sizeof ( * opt ) + optlen ;retv = - EFAULT ;,2221
87,"buggy line: done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;cwe id:CWE-264context: static int do_ipv6_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct net * net = sock_net ( sk ) ; int val , valbool ; int retv = - ENOPROTOOPT ; bool needs_rtnl = setsockopt_needs_rtnl ( optname ) ; if ( ! optval ) val = 0 ; else { if ( optlen >= sizeof ( int ) ) { if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; } else val = 0 ; } valbool = ( val != 0 ) ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_setsockopt ( sk , optname , optval , optlen ) ; if ( needs_rtnl ) rtnl_lock ( ) ; lock_sock ( sk ) ; switch ( optname ) { case IPV6_ADDRFORM : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val == PF_INET ) { struct ipv6_txoptions * opt ; struct sk_buff * pktopt ; if ( sk -> sk_type == SOCK_RAW ) break ; if ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_UDPLITE ) { struct udp_sock * up = udp_sk ( sk ) ; if ( up -> pending == AF_INET6 ) { retv = - EBUSY ; break ; } } else if ( sk -> sk_protocol != IPPROTO_TCP ) break ; if ( sk -> sk_state != TCP_ESTABLISHED ) { retv = - ENOTCONN ; break ; } if ( ipv6_only_sock ( sk ) || ! ipv6_addr_v4mapped ( & sk -> sk_v6_daddr ) ) { retv = - EADDRNOTAVAIL ; break ; } fl6_free_socklist ( sk ) ; ipv6_sock_mc_close ( sk ) ; sk_refcnt_debug_dec ( sk ) ; if ( sk -> sk_protocol == IPPROTO_TCP ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , & tcp_prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = & tcp_prot ; icsk -> icsk_af_ops = & ipv4_specific ; sk -> sk_socket -> ops = & inet_stream_ops ; sk -> sk_family = PF_INET ; tcp_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } else { struct proto * prot = & udp_prot ; if ( sk -> sk_protocol == IPPROTO_UDPLITE ) prot = & udplite_prot ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = prot ; sk -> sk_socket -> ops = & inet_dgram_ops ; sk -> sk_family = PF_INET ; }  opt = xchg ( & np -> opt , NULL ) ;  if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  pktopt = xchg ( & np -> pktoptions , NULL ) ; kfree_skb ( pktopt ) ; sk -> sk_destruct = inet_sock_destruct ; sk_refcnt_debug_inc ( sk ) ; module_put ( THIS_MODULE ) ; retv = 0 ; break ; } goto e_inval ; case IPV6_V6ONLY : if ( optlen < sizeof ( int ) || inet_sk ( sk ) -> inet_num ) goto e_inval ; sk -> sk_ipv6only = valbool ; retv = 0 ; break ; case IPV6_RECVPKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxinfo = valbool ; retv = 0 ; break ; case IPV6_2292PKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxoinfo = valbool ; retv = 0 ; break ; case IPV6_RECVHOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxhlim = valbool ; retv = 0 ; break ; case IPV6_2292HOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxohlim = valbool ; retv = 0 ; break ; case IPV6_RECVRTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . srcrt = valbool ; retv = 0 ; break ; case IPV6_2292RTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . osrcrt = valbool ; retv = 0 ; break ; case IPV6_RECVHOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . hopopts = valbool ; retv = 0 ; break ; case IPV6_2292HOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . ohopopts = valbool ; retv = 0 ; break ; case IPV6_RECVDSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . dstopts = valbool ; retv = 0 ; break ; case IPV6_2292DSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . odstopts = valbool ; retv = 0 ; break ; case IPV6_TCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < - 1 || val > 0xff ) goto e_inval ; if ( val == - 1 ) val = 0 ; np -> tclass = val ; retv = 0 ; break ; case IPV6_RECVTCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxtclass = valbool ; retv = 0 ; break ; case IPV6_FLOWINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxflow = valbool ; retv = 0 ; break ; case IPV6_RECVPATHMTU : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxpmtu = valbool ; retv = 0 ; break ; case IPV6_TRANSPARENT : if ( valbool && ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) { retv = - EPERM ; break ; } if ( optlen < sizeof ( int ) ) goto e_inval ; inet_sk ( sk ) -> transparent = valbool ; retv = 0 ; break ; case IPV6_RECVORIGDSTADDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxorigdstaddr = valbool ; retv = 0 ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; if ( optlen == 0 ) optval = NULL ; else if ( ! optval ) goto e_inval ; else if ( optlen < sizeof ( struct ipv6_opt_hdr ) || optlen & 0x7 || optlen > 8 * 255 ) goto e_inval ; retv = - EPERM ; if ( optname != IPV6_RTHDR && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) break ;  opt = ipv6_renew_options ( sk , np -> opt , optname ,  ( struct ipv6_opt_hdr __user * ) optval , optlen ) ; if ( IS_ERR ( opt ) ) { retv = PTR_ERR ( opt ) ; break ; } retv = - EINVAL ; if ( optname == IPV6_RTHDR && opt && opt -> srcrt ) { struct ipv6_rt_hdr * rthdr = opt -> srcrt ; switch ( rthdr -> type ) { # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) case IPV6_SRCRT_TYPE_2 : if ( rthdr -> hdrlen != 2 || rthdr -> segments_left != 1 ) goto sticky_done ; break ; # endif default : goto sticky_done ; } } retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; sticky_done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_PKTINFO : { struct in6_pktinfo pkt ; if ( optlen == 0 ) goto e_inval ; else if ( optlen < sizeof ( struct in6_pktinfo ) || ! optval ) goto e_inval ; if ( copy_from_user ( & pkt , optval , sizeof ( struct in6_pktinfo ) ) ) { retv = - EFAULT ; break ; } if ( sk -> sk_bound_dev_if && pkt . ipi6_ifindex != sk -> sk_bound_dev_if ) goto e_inval ; np -> sticky_pktinfo . ipi6_ifindex = pkt . ipi6_ifindex ; np -> sticky_pktinfo . ipi6_addr = pkt . ipi6_addr ; retv = 0 ; break ; } case IPV6_2292PKTOPTIONS : { struct ipv6_txoptions * opt = NULL ; struct msghdr msg ; struct flowi6 fl6 ; int junk ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; if ( optlen == 0 ) goto update ; retv = - EINVAL ; if ( optlen > 64 * 1024 ) break ; opt = sock_kmalloc ( sk , sizeof ( * opt ) + optlen , GFP_KERNEL ) ; retv = - ENOBUFS ; if ( ! opt ) break ; memset ( opt , 0 , sizeof ( * opt ) ) ;  opt -> tot_len = sizeof ( * opt ) + optlen ;  retv = - EFAULT ; if ( copy_from_user ( opt + 1 , optval , optlen ) ) goto done ; msg . msg_controllen = optlen ; msg . msg_control = ( void * ) ( opt + 1 ) ; retv = ip6_datagram_send_ctl ( net , sk , & msg , & fl6 , opt , & junk , & junk , & junk ) ; if ( retv ) goto done ; update : retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;  break ; } case IPV6_UNICAST_HOPS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> hop_limit = val ; retv = 0 ; break ; case IPV6_MULTICAST_HOPS : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> mcast_hops = ( val == - 1 ? IPV6_DEFAULT_MCASTHOPS : val ) ; retv = 0 ; break ; case IPV6_MULTICAST_LOOP : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val != valbool ) goto e_inval ; np -> mc_loop = valbool ; retv = 0 ; break ; case IPV6_UNICAST_IF : { struct net_device * dev = NULL ; int ifindex ; if ( optlen != sizeof ( int ) ) goto e_inval ; ifindex = ( __force int ) ntohl ( ( __force __be32 ) val ) ; if ( ifindex == 0 ) { np -> ucast_oif = 0 ; retv = 0 ; break ; } dev = dev_get_by_index ( net , ifindex ) ; retv = - EADDRNOTAVAIL ; if ( ! dev ) break ; dev_put ( dev ) ; retv = - EINVAL ; if ( sk -> sk_bound_dev_if ) break ; np -> ucast_oif = ifindex ; retv = 0 ; break ; } case IPV6_MULTICAST_IF : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val ) { struct net_device * dev ; if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != val ) goto e_inval ; dev = dev_get_by_index ( net , val ) ; if ( ! dev ) { retv = - ENODEV ; break ; } dev_put ( dev ) ; } np -> mcast_oif = val ; retv = 0 ; break ; case IPV6_ADD_MEMBERSHIP : case IPV6_DROP_MEMBERSHIP : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EPROTO ; if ( inet_sk ( sk ) -> is_icsk ) break ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_ADD_MEMBERSHIP ) retv = ipv6_sock_mc_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; else retv = ipv6_sock_mc_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; break ; } case IPV6_JOIN_ANYCAST : case IPV6_LEAVE_ANYCAST : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_JOIN_ANYCAST ) retv = ipv6_sock_ac_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; else retv = ipv6_sock_ac_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; break ; } case MCAST_JOIN_GROUP : case MCAST_LEAVE_GROUP : { struct group_req greq ; struct sockaddr_in6 * psin6 ; if ( optlen < sizeof ( struct group_req ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & greq , optval , sizeof ( struct group_req ) ) ) break ; if ( greq . gr_group . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } psin6 = ( struct sockaddr_in6 * ) & greq . gr_group ; if ( optname == MCAST_JOIN_GROUP ) retv = ipv6_sock_mc_join ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; else retv = ipv6_sock_mc_drop ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; break ; } case MCAST_JOIN_SOURCE_GROUP : case MCAST_LEAVE_SOURCE_GROUP : case MCAST_BLOCK_SOURCE : case MCAST_UNBLOCK_SOURCE : { struct group_source_req greqs ; int omode , add ; if ( optlen < sizeof ( struct group_source_req ) ) goto e_inval ; if ( copy_from_user ( & greqs , optval , sizeof ( greqs ) ) ) { retv = - EFAULT ; break ; } if ( greqs . gsr_group . ss_family != AF_INET6 || greqs . gsr_source . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } if ( optname == MCAST_BLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 1 ; } else if ( optname == MCAST_UNBLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 0 ; } else if ( optname == MCAST_JOIN_SOURCE_GROUP ) { struct sockaddr_in6 * psin6 ; psin6 = ( struct sockaddr_in6 * ) & greqs . gsr_group ; retv = ipv6_sock_mc_join ( sk , greqs . gsr_interface , & psin6 -> sin6_addr ) ; if ( retv && retv != - EADDRINUSE ) break ; omode = MCAST_INCLUDE ; add = 1 ; } else { omode = MCAST_INCLUDE ; add = 0 ; } retv = ip6_mc_source ( add , omode , sk , & greqs ) ; break ; } case MCAST_MSFILTER : { struct group_filter * gsf ; if ( optlen < GROUP_FILTER_SIZE ( 0 ) ) goto e_inval ; if ( optlen > sysctl_optmem_max ) { retv = - ENOBUFS ; break ; } gsf = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! gsf ) { retv = - ENOBUFS ; break ; } retv = - EFAULT ; if ( copy_from_user ( gsf , optval , optlen ) ) { kfree ( gsf ) ; break ; } if ( gsf -> gf_numsrc >= 0x1ffffffU || gsf -> gf_numsrc > sysctl_mld_max_msf ) { kfree ( gsf ) ; retv = - ENOBUFS ; break ; } if ( GROUP_FILTER_SIZE ( gsf -> gf_numsrc ) > optlen ) { kfree ( gsf ) ; retv = - EINVAL ; break ; } retv = ip6_mc_msfilter ( sk , gsf ) ; kfree ( gsf ) ; break ; } case IPV6_ROUTER_ALERT : if ( optlen < sizeof ( int ) ) goto e_inval ; retv = ip6_ra_control ( sk , val ) ; break ; case IPV6_MTU_DISCOVER : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT ) goto e_inval ; np -> pmtudisc = val ; retv = 0 ; break ; case IPV6_MTU : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val && val < IPV6_MIN_MTU ) goto e_inval ; np -> frag_size = val ; retv = 0 ; break ; case IPV6_RECVERR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> recverr = valbool ; if ( ! val ) skb_queue_purge ( & sk -> sk_error_queue ) ; retv = 0 ; break ; case IPV6_FLOWINFO_SEND : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> sndflow = valbool ; retv = 0 ; break ; case IPV6_FLOWLABEL_MGR : retv = ipv6_flowlabel_opt ( sk , optval , optlen ) ; break ; case IPV6_IPSEC_POLICY : case IPV6_XFRM_POLICY : retv = - EPERM ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) break ; retv = xfrm_user_policy ( sk , optname , optval , optlen ) ; break ; case IPV6_ADDR_PREFERENCES : { unsigned int pref = 0 ; unsigned int prefmask = ~ 0 ; if ( optlen < sizeof ( int ) ) goto e_inval ; retv = - EINVAL ; switch ( val & ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP | IPV6_PREFER_SRC_PUBTMP_DEFAULT ) ) { case IPV6_PREFER_SRC_PUBLIC : pref |= IPV6_PREFER_SRC_PUBLIC ; break ; case IPV6_PREFER_SRC_TMP : pref |= IPV6_PREFER_SRC_TMP ; break ; case IPV6_PREFER_SRC_PUBTMP_DEFAULT : break ; case 0 : goto pref_skip_pubtmp ; default : goto e_inval ; } prefmask &= ~ ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP ) ; pref_skip_pubtmp : switch ( val & ( IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA ) ) { case IPV6_PREFER_SRC_HOME : break ; case IPV6_PREFER_SRC_COA : pref |= IPV6_PREFER_SRC_COA ; case 0 : goto pref_skip_coa ; default : goto e_inval ; } prefmask &= ~ IPV6_PREFER_SRC_COA ; pref_skip_coa : switch ( val & ( IPV6_PREFER_SRC_CGA | IPV6_PREFER_SRC_NONCGA ) ) { case IPV6_PREFER_SRC_CGA : case IPV6_PREFER_SRC_NONCGA : case 0 : break ; default : goto e_inval ; } np -> srcprefs = ( np -> srcprefs & prefmask ) | pref ; retv = 0 ; break ; } case IPV6_MINHOPCOUNT : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < 0 || val > 255 ) goto e_inval ; np -> min_hopcount = val ; retv = 0 ; break ; case IPV6_DONTFRAG : np -> dontfrag = valbool ; retv = 0 ; break ; case IPV6_AUTOFLOWLABEL : np -> autoflowlabel = valbool ; retv = 0 ; break ; } release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return retv ; e_inval : release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return - EINVAL ; }","done : if ( opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;",2221
88,"buggy line: uint16_t auxsize ;if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ;cwe id:CWE-476context: static int nsv_read_chunk ( AVFormatContext * s , int fill_header ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st [ 2 ] = { NULL , NULL } ; NSVStream * nst ; AVPacket * pkt ; int i , err = 0 ; uint8_t auxcount ; uint32_t vsize ; uint16_t asize ;  uint16_t auxsize ;  if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ; null_chunk_retry : if ( pb -> eof_reached ) return - 1 ; for ( i = 0 ; i < NSV_MAX_RESYNC_TRIES && nsv -> state < NSV_FOUND_NSVS && ! err ; i ++ ) err = nsv_resync ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state == NSV_FOUND_NSVS ) err = nsv_parse_NSVs_header ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state != NSV_HAS_READ_NSVS && nsv -> state != NSV_FOUND_BEEF ) return - 1 ; auxcount = avio_r8 ( pb ) ; vsize = avio_rl16 ( pb ) ; asize = avio_rl16 ( pb ) ; vsize = ( vsize << 4 ) | ( auxcount >> 4 ) ; auxcount &= 0x0f ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>CHUNK<S2SV_blank>%"" PRIu8 ""<S2SV_blank>aux,<S2SV_blank>%"" PRIu32 ""<S2SV_blank>bytes<S2SV_blank>video,<S2SV_blank>%"" PRIu16 ""<S2SV_blank>bytes<S2SV_blank>audio\\n"" , auxcount , vsize , asize ) ; for ( i = 0 ; i < auxcount ; i ++ ) { uint32_t av_unused auxtag ; auxsize = avio_rl16 ( pb ) ; auxtag = avio_rl32 ( pb ) ; avio_skip ( pb , auxsize ) ; vsize -= auxsize + sizeof ( uint16_t ) + sizeof ( uint32_t ) ; } if ( pb -> eof_reached ) return - 1 ; if ( ! vsize && ! asize ) { nsv -> state = NSV_UNSYNC ; goto null_chunk_retry ; } if ( s -> nb_streams > 0 ) st [ s -> streams [ 0 ] -> id ] = s -> streams [ 0 ] ; if ( s -> nb_streams > 1 ) st [ s -> streams [ 1 ] -> id ] = s -> streams [ 1 ] ; if ( vsize && st [ NSV_ST_VIDEO ] ) { nst = st [ NSV_ST_VIDEO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ;  av_get_packet ( pb , pkt , vsize ) ;  pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ; pkt -> dts = nst -> frame_offset ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; for ( i = 0 ; i < FFMIN ( 8 , vsize ) ; i ++ ) av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>video:<S2SV_blank>[%d]<S2SV_blank>=<S2SV_blank>%02"" PRIx8 ""\\n"" , i , pkt -> data [ i ] ) ; } if ( st [ NSV_ST_VIDEO ] ) ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset ++ ; if ( asize && st [ NSV_ST_AUDIO ] ) { nst = st [ NSV_ST_AUDIO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_AUDIO ] ; if ( asize && st [ NSV_ST_AUDIO ] -> codecpar -> codec_tag == MKTAG ( 'P' , 'C' , 'M' , '<S2SV_blank>' ) ) { uint8_t bps ; uint8_t channels ; uint16_t samplerate ; bps = avio_r8 ( pb ) ; channels = avio_r8 ( pb ) ; samplerate = avio_rl16 ( pb ) ; if ( ! channels || ! samplerate ) return AVERROR_INVALIDDATA ; asize -= 4 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; if ( fill_header ) { st [ NSV_ST_AUDIO ] -> need_parsing = AVSTREAM_PARSE_NONE ; if ( bps != 16 ) { av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO<S2SV_blank>bit/sample<S2SV_blank>!=<S2SV_blank>16<S2SV_blank>(%"" PRIu8 "")!!!\\n"" , bps ) ; } bps /= channels ; if ( bps == 8 ) st [ NSV_ST_AUDIO ] -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; samplerate /= 4 ; channels = 1 ; st [ NSV_ST_AUDIO ] -> codecpar -> channels = channels ; st [ NSV_ST_AUDIO ] -> codecpar -> sample_rate = samplerate ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; } }  av_get_packet ( pb , pkt , asize ) ;  pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) { pkt -> dts = ( ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset - 1 ) ; pkt -> dts *= ( int64_t ) 1000 * nsv -> framerate . den ; pkt -> dts += ( int64_t ) nsv -> avsync * nsv -> framerate . num ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO:<S2SV_blank>sync:%"" PRId16 "",<S2SV_blank>dts:%"" PRId64 , nsv -> avsync , pkt -> dts ) ; } nst -> frame_offset ++ ; } nsv -> state = NSV_UNSYNC ; return 0 ; }",uint16_t auxsize ;int ret ;if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ;,2222
89,"buggy line: av_get_packet ( pb , pkt , vsize ) ;pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ;cwe id:CWE-476context: static int nsv_read_chunk ( AVFormatContext * s , int fill_header ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st [ 2 ] = { NULL , NULL } ; NSVStream * nst ; AVPacket * pkt ; int i , err = 0 ; uint8_t auxcount ; uint32_t vsize ; uint16_t asize ;  uint16_t auxsize ;  if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ; null_chunk_retry : if ( pb -> eof_reached ) return - 1 ; for ( i = 0 ; i < NSV_MAX_RESYNC_TRIES && nsv -> state < NSV_FOUND_NSVS && ! err ; i ++ ) err = nsv_resync ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state == NSV_FOUND_NSVS ) err = nsv_parse_NSVs_header ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state != NSV_HAS_READ_NSVS && nsv -> state != NSV_FOUND_BEEF ) return - 1 ; auxcount = avio_r8 ( pb ) ; vsize = avio_rl16 ( pb ) ; asize = avio_rl16 ( pb ) ; vsize = ( vsize << 4 ) | ( auxcount >> 4 ) ; auxcount &= 0x0f ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>CHUNK<S2SV_blank>%"" PRIu8 ""<S2SV_blank>aux,<S2SV_blank>%"" PRIu32 ""<S2SV_blank>bytes<S2SV_blank>video,<S2SV_blank>%"" PRIu16 ""<S2SV_blank>bytes<S2SV_blank>audio\\n"" , auxcount , vsize , asize ) ; for ( i = 0 ; i < auxcount ; i ++ ) { uint32_t av_unused auxtag ; auxsize = avio_rl16 ( pb ) ; auxtag = avio_rl32 ( pb ) ; avio_skip ( pb , auxsize ) ; vsize -= auxsize + sizeof ( uint16_t ) + sizeof ( uint32_t ) ; } if ( pb -> eof_reached ) return - 1 ; if ( ! vsize && ! asize ) { nsv -> state = NSV_UNSYNC ; goto null_chunk_retry ; } if ( s -> nb_streams > 0 ) st [ s -> streams [ 0 ] -> id ] = s -> streams [ 0 ] ; if ( s -> nb_streams > 1 ) st [ s -> streams [ 1 ] -> id ] = s -> streams [ 1 ] ; if ( vsize && st [ NSV_ST_VIDEO ] ) { nst = st [ NSV_ST_VIDEO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ;  av_get_packet ( pb , pkt , vsize ) ;  pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ; pkt -> dts = nst -> frame_offset ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; for ( i = 0 ; i < FFMIN ( 8 , vsize ) ; i ++ ) av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>video:<S2SV_blank>[%d]<S2SV_blank>=<S2SV_blank>%02"" PRIx8 ""\\n"" , i , pkt -> data [ i ] ) ; } if ( st [ NSV_ST_VIDEO ] ) ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset ++ ; if ( asize && st [ NSV_ST_AUDIO ] ) { nst = st [ NSV_ST_AUDIO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_AUDIO ] ; if ( asize && st [ NSV_ST_AUDIO ] -> codecpar -> codec_tag == MKTAG ( 'P' , 'C' , 'M' , '<S2SV_blank>' ) ) { uint8_t bps ; uint8_t channels ; uint16_t samplerate ; bps = avio_r8 ( pb ) ; channels = avio_r8 ( pb ) ; samplerate = avio_rl16 ( pb ) ; if ( ! channels || ! samplerate ) return AVERROR_INVALIDDATA ; asize -= 4 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; if ( fill_header ) { st [ NSV_ST_AUDIO ] -> need_parsing = AVSTREAM_PARSE_NONE ; if ( bps != 16 ) { av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO<S2SV_blank>bit/sample<S2SV_blank>!=<S2SV_blank>16<S2SV_blank>(%"" PRIu8 "")!!!\\n"" , bps ) ; } bps /= channels ; if ( bps == 8 ) st [ NSV_ST_AUDIO ] -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; samplerate /= 4 ; channels = 1 ; st [ NSV_ST_AUDIO ] -> codecpar -> channels = channels ; st [ NSV_ST_AUDIO ] -> codecpar -> sample_rate = samplerate ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; } }  av_get_packet ( pb , pkt , asize ) ;  pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) { pkt -> dts = ( ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset - 1 ) ; pkt -> dts *= ( int64_t ) 1000 * nsv -> framerate . den ; pkt -> dts += ( int64_t ) nsv -> avsync * nsv -> framerate . num ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO:<S2SV_blank>sync:%"" PRId16 "",<S2SV_blank>dts:%"" PRId64 , nsv -> avsync , pkt -> dts ) ; } nst -> frame_offset ++ ; } nsv -> state = NSV_UNSYNC ; return 0 ; }","if ( ( ret = av_get_packet ( pb , pkt , vsize ) ) < 0 ) return ret ;pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ;",2222
90,"buggy line: av_get_packet ( pb , pkt , asize ) ;pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ;cwe id:CWE-476context: static int nsv_read_chunk ( AVFormatContext * s , int fill_header ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st [ 2 ] = { NULL , NULL } ; NSVStream * nst ; AVPacket * pkt ; int i , err = 0 ; uint8_t auxcount ; uint32_t vsize ; uint16_t asize ;  uint16_t auxsize ;  if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ; null_chunk_retry : if ( pb -> eof_reached ) return - 1 ; for ( i = 0 ; i < NSV_MAX_RESYNC_TRIES && nsv -> state < NSV_FOUND_NSVS && ! err ; i ++ ) err = nsv_resync ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state == NSV_FOUND_NSVS ) err = nsv_parse_NSVs_header ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state != NSV_HAS_READ_NSVS && nsv -> state != NSV_FOUND_BEEF ) return - 1 ; auxcount = avio_r8 ( pb ) ; vsize = avio_rl16 ( pb ) ; asize = avio_rl16 ( pb ) ; vsize = ( vsize << 4 ) | ( auxcount >> 4 ) ; auxcount &= 0x0f ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>CHUNK<S2SV_blank>%"" PRIu8 ""<S2SV_blank>aux,<S2SV_blank>%"" PRIu32 ""<S2SV_blank>bytes<S2SV_blank>video,<S2SV_blank>%"" PRIu16 ""<S2SV_blank>bytes<S2SV_blank>audio\\n"" , auxcount , vsize , asize ) ; for ( i = 0 ; i < auxcount ; i ++ ) { uint32_t av_unused auxtag ; auxsize = avio_rl16 ( pb ) ; auxtag = avio_rl32 ( pb ) ; avio_skip ( pb , auxsize ) ; vsize -= auxsize + sizeof ( uint16_t ) + sizeof ( uint32_t ) ; } if ( pb -> eof_reached ) return - 1 ; if ( ! vsize && ! asize ) { nsv -> state = NSV_UNSYNC ; goto null_chunk_retry ; } if ( s -> nb_streams > 0 ) st [ s -> streams [ 0 ] -> id ] = s -> streams [ 0 ] ; if ( s -> nb_streams > 1 ) st [ s -> streams [ 1 ] -> id ] = s -> streams [ 1 ] ; if ( vsize && st [ NSV_ST_VIDEO ] ) { nst = st [ NSV_ST_VIDEO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ;  av_get_packet ( pb , pkt , vsize ) ;  pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ; pkt -> dts = nst -> frame_offset ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; for ( i = 0 ; i < FFMIN ( 8 , vsize ) ; i ++ ) av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>video:<S2SV_blank>[%d]<S2SV_blank>=<S2SV_blank>%02"" PRIx8 ""\\n"" , i , pkt -> data [ i ] ) ; } if ( st [ NSV_ST_VIDEO ] ) ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset ++ ; if ( asize && st [ NSV_ST_AUDIO ] ) { nst = st [ NSV_ST_AUDIO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_AUDIO ] ; if ( asize && st [ NSV_ST_AUDIO ] -> codecpar -> codec_tag == MKTAG ( 'P' , 'C' , 'M' , '<S2SV_blank>' ) ) { uint8_t bps ; uint8_t channels ; uint16_t samplerate ; bps = avio_r8 ( pb ) ; channels = avio_r8 ( pb ) ; samplerate = avio_rl16 ( pb ) ; if ( ! channels || ! samplerate ) return AVERROR_INVALIDDATA ; asize -= 4 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; if ( fill_header ) { st [ NSV_ST_AUDIO ] -> need_parsing = AVSTREAM_PARSE_NONE ; if ( bps != 16 ) { av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO<S2SV_blank>bit/sample<S2SV_blank>!=<S2SV_blank>16<S2SV_blank>(%"" PRIu8 "")!!!\\n"" , bps ) ; } bps /= channels ; if ( bps == 8 ) st [ NSV_ST_AUDIO ] -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; samplerate /= 4 ; channels = 1 ; st [ NSV_ST_AUDIO ] -> codecpar -> channels = channels ; st [ NSV_ST_AUDIO ] -> codecpar -> sample_rate = samplerate ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; } }  av_get_packet ( pb , pkt , asize ) ;  pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) { pkt -> dts = ( ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset - 1 ) ; pkt -> dts *= ( int64_t ) 1000 * nsv -> framerate . den ; pkt -> dts += ( int64_t ) nsv -> avsync * nsv -> framerate . num ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO:<S2SV_blank>sync:%"" PRId16 "",<S2SV_blank>dts:%"" PRId64 , nsv -> avsync , pkt -> dts ) ; } nst -> frame_offset ++ ; } nsv -> state = NSV_UNSYNC ; return 0 ; }","if ( ( ret = av_get_packet ( pb , pkt , asize ) ) < 0 ) return ret ;pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ;",2222
91,"buggy line: RBinWasmGlobalEntry * ptr = NULL ;int buflen = bin -> buf -> length ;if ( sec -> payload_data + 32 > buflen ) {return NULL ;}cwe id:CWE-125context: static RList * r_bin_wasm_get_global_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmGlobalEntry * ptr = NULL ;  int buflen = bin -> buf -> length ;  if ( sec -> payload_data + 32 > buflen ) { return NULL ; } if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; ut32 len = sec -> payload_len ; ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; while ( i < len && len < buflen && r < count ) { if ( ! ( ptr = R_NEW0 ( RBinWasmGlobalEntry ) ) ) { return ret ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , ( ut8 * ) & ptr -> content_type , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , & ptr -> mutability , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { goto beach ; } r_list_append ( ret , ptr ) ; r ++ ; } return ret ; beach : free ( ptr ) ; return ret ; }",RBinWasmGlobalEntry * ptr = NULL ;int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ;,2223
92,"buggy line: if ( first_mb_in_slice == 0 ) {if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) {field_end ( h , 1 ) ;}h0 -> current_slice = 0 ;if ( ! h0 -> first_field ) {if ( h -> cur_pic_ptr && ! h -> droppable ) {ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ;}h -> cur_pic_ptr = NULL ;}}slice_type = get_ue_golomb_31 ( & h -> gb ) ;if ( slice_type > 9 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""slice<S2SV_blank>type<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>%d\\\return AVERROR_INVALIDDATA ;}if ( slice_type > 4 ) {slice_type -= 5 ;h -> slice_type_fixed = 1 ;}else h -> slice_type_fixed = 0 ;slice_type = golomb_to_pict_type [ slice_type ] ;h -> slice_type = slice_type ;h -> slice_type_nos = slice_type & 3 ;h -> pict_type = h -> slice_type ;pps_id = get_ue_golomb ( & h -> gb ) ;if ( pps_id >= MAX_PPS_COUNT ) {av_log ( h -> avctx , AV_LOG_ERROR , ""pps_id<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\return AVERROR_INVALIDDATA ;}if ( ! h0 -> pps_buffers [ pps_id ] ) {av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>PPS<S2SV_blank>%u<S2SV_blank>referenced\\\return AVERROR_INVALIDDATA ;}h -> pps = * h0 -> pps_buffers [ pps_id ] ;if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] ) {av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>SPS<S2SV_blank>%u<S2SV_blank>referenced\\\return AVERROR_INVALIDDATA ;}if ( h -> pps . sps_id != h -> current_sps_id || h0 -> sps_buffers [ h -> pps . sps_id ] -> new ) {h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 ;h -> current_sps_id = h -> pps . sps_id ;h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ] ;if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc ) needs_reinit = 1 ;if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc ) {h -> bit_depth_luma = h -> sps . bit_depth_luma ;h -> chroma_format_idc = h -> sps . chroma_format_idc ;needs_reinit = 1 ;}if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 ) return ret ;}h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ) ;h -> avctx -> level = h -> sps . level_idc ;h -> avctx -> refs = h -> sps . ref_frame_count ;must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ) ;if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) ) must_reinit = 1 ;h -> mb_width = h -> sps . mb_width ;h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ;h -> mb_num = h -> mb_width * h -> mb_height ;h -> mb_stride = h -> mb_width + 1 ;h -> b_stride = h -> mb_width * 4 ;h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1 ;h -> width = 16 * h -> mb_width ;h -> height = 16 * h -> mb_height ;ret = init_dimensions ( h ) ;if ( ret < 0 ) return ret ;if ( h -> sps . video_signal_type_present_flag ) {h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG ;if ( h -> sps . colour_description_present_flag ) {if ( h -> avctx -> colorspace != h -> sps . colorspace ) needs_reinit = 1 ;h -> avctx -> color_primaries = h -> sps . color_primaries ;h -> avctx -> color_trc = h -> sps . color_trc ;h -> avctx -> colorspace = h -> sps . colorspace ;}}if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) ) {if ( h != h0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""changing<S2SV_blank>width/height<S2SV_blank>on<S2SV_blank>"" ""slice<S2SV_blank>%d\\\return AVERROR_INVALIDDATA ;}flush_change ( h ) ;if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ;h -> avctx -> pix_fmt = ret ;av_log ( h -> avctx , AV_LOG_INFO , ""Reinit<S2SV_blank>context<S2SV_blank>to<S2SV_blank>%dx%d,<S2SV_blank>"" ""pix_fmt:<S2SV_blank>%s\\\if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\\return ret ;}}if ( ! h -> context_initialized ) {if ( h != h0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""Cannot<S2SV_blank>(re-)initialize<S2SV_blank>context<S2SV_blank>during<S2SV_blank>parallel<S2SV_blank>decoding.\\\return AVERROR_PATCHWELCOME ;}if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ;h -> avctx -> pix_fmt = ret ;if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\\return ret ;}}if ( h == h0 && h -> dequant_coeff_pps != pps_id ) {h -> dequant_coeff_pps = pps_id ;init_dequant_tables ( h ) ;}h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ) ;h -> mb_mbaff = 0 ;h -> mb_aff_frame = 0 ;last_pic_structure = h0 -> picture_structure ;last_pic_droppable = h0 -> droppable ;h -> droppable = h -> nal_ref_idc == 0 ;if ( h -> sps . frame_mbs_only_flag ) {h -> picture_structure = PICT_FRAME ;}else {if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B ) {av_log ( h -> avctx , AV_LOG_ERROR , ""This<S2SV_blank>stream<S2SV_blank>was<S2SV_blank>generated<S2SV_blank>by<S2SV_blank>a<S2SV_blank>broken<S2SV_blank>encoder,<S2SV_blank>invalid<S2SV_blank>8x8<S2SV_blank>inference\\\return - 1 ;}field_pic_flag = get_bits1 ( & h -> gb ) ;if ( field_pic_flag ) {bottom_field_flag = get_bits1 ( & h -> gb ) ;h -> picture_structure = PICT_TOP_FIELD + bottom_field_flag ;}else {h -> picture_structure = PICT_FRAME ;h -> mb_aff_frame = h -> sps . mb_aff ;}}h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME ;if ( h0 -> current_slice != 0 ) {if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable ) {av_log ( h -> avctx , AV_LOG_ERROR , ""Changing<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>(%d<S2SV_blank>-><S2SV_blank>%d)<S2SV_blank>between<S2SV_blank>slices<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\\h -> picture_structure = last_pic_structure ;h -> droppable = last_pic_droppable ;return AVERROR_INVALIDDATA ;}else if ( ! h0 -> cur_pic_ptr ) {cwe id:CWE-000context: static int decode_slice_header ( H264Context * h , H264Context * h0 ) { unsigned int first_mb_in_slice ; unsigned int pps_id ; int ret ; unsigned int slice_type , tmp , i , j ; int last_pic_structure , last_pic_droppable ; int must_reinit ; int needs_reinit = 0 ; int field_pic_flag , bottom_field_flag ; h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab ; h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab ; first_mb_in_slice = get_ue_golomb_long ( & h -> gb ) ; if ( first_mb_in_slice == 0 ) { if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) { field_end ( h , 1 ) ; } h0 -> current_slice = 0 ; if ( ! h0 -> first_field ) { if ( h -> cur_pic_ptr && ! h -> droppable ) { ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ; } h -> cur_pic_ptr = NULL ; } } slice_type = get_ue_golomb_31 ( & h -> gb ) ; if ( slice_type > 9 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""slice<S2SV_blank>type<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>%d\\n"" , slice_type , h -> mb_x , h -> mb_y ) ; return AVERROR_INVALIDDATA ; } if ( slice_type > 4 ) { slice_type -= 5 ; h -> slice_type_fixed = 1 ; } else h -> slice_type_fixed = 0 ; slice_type = golomb_to_pict_type [ slice_type ] ; h -> slice_type = slice_type ; h -> slice_type_nos = slice_type & 3 ; h -> pict_type = h -> slice_type ; pps_id = get_ue_golomb ( & h -> gb ) ; if ( pps_id >= MAX_PPS_COUNT ) { av_log ( h -> avctx , AV_LOG_ERROR , ""pps_id<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! h0 -> pps_buffers [ pps_id ] ) { av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>PPS<S2SV_blank>%u<S2SV_blank>referenced\\n"" , pps_id ) ; return AVERROR_INVALIDDATA ; } h -> pps = * h0 -> pps_buffers [ pps_id ] ; if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] ) { av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>SPS<S2SV_blank>%u<S2SV_blank>referenced\\n"" , h -> pps . sps_id ) ; return AVERROR_INVALIDDATA ; } if ( h -> pps . sps_id != h -> current_sps_id || h0 -> sps_buffers [ h -> pps . sps_id ] -> new ) { h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 ; h -> current_sps_id = h -> pps . sps_id ; h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ] ; if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc ) needs_reinit = 1 ; if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc ) { h -> bit_depth_luma = h -> sps . bit_depth_luma ; h -> chroma_format_idc = h -> sps . chroma_format_idc ; needs_reinit = 1 ; } if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 ) return ret ; } h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ) ; h -> avctx -> level = h -> sps . level_idc ; h -> avctx -> refs = h -> sps . ref_frame_count ; must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ) ; if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) ) must_reinit = 1 ; h -> mb_width = h -> sps . mb_width ; h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ; h -> mb_num = h -> mb_width * h -> mb_height ; h -> mb_stride = h -> mb_width + 1 ; h -> b_stride = h -> mb_width * 4 ; h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1 ; h -> width = 16 * h -> mb_width ; h -> height = 16 * h -> mb_height ; ret = init_dimensions ( h ) ; if ( ret < 0 ) return ret ; if ( h -> sps . video_signal_type_present_flag ) { h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG ; if ( h -> sps . colour_description_present_flag ) { if ( h -> avctx -> colorspace != h -> sps . colorspace ) needs_reinit = 1 ; h -> avctx -> color_primaries = h -> sps . color_primaries ; h -> avctx -> color_trc = h -> sps . color_trc ; h -> avctx -> colorspace = h -> sps . colorspace ; } } if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) ) { if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""changing<S2SV_blank>width/height<S2SV_blank>on<S2SV_blank>"" ""slice<S2SV_blank>%d\\n"" , h0 -> current_slice + 1 ) ; return AVERROR_INVALIDDATA ; } flush_change ( h ) ; if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ; h -> avctx -> pix_fmt = ret ; av_log ( h -> avctx , AV_LOG_INFO , ""Reinit<S2SV_blank>context<S2SV_blank>to<S2SV_blank>%dx%d,<S2SV_blank>"" ""pix_fmt:<S2SV_blank>%s\\n"" , h -> width , h -> height , av_get_pix_fmt_name ( h -> avctx -> pix_fmt ) ) ; if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\n"" ) ; return ret ; } } if ( ! h -> context_initialized ) { if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Cannot<S2SV_blank>(re-)initialize<S2SV_blank>context<S2SV_blank>during<S2SV_blank>parallel<S2SV_blank>decoding.\\n"" ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ; h -> avctx -> pix_fmt = ret ; if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\n"" ) ; return ret ; } } if ( h == h0 && h -> dequant_coeff_pps != pps_id ) { h -> dequant_coeff_pps = pps_id ; init_dequant_tables ( h ) ; } h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ) ; h -> mb_mbaff = 0 ; h -> mb_aff_frame = 0 ; last_pic_structure = h0 -> picture_structure ; last_pic_droppable = h0 -> droppable ; h -> droppable = h -> nal_ref_idc == 0 ; if ( h -> sps . frame_mbs_only_flag ) { h -> picture_structure = PICT_FRAME ; } else { if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B ) { av_log ( h -> avctx , AV_LOG_ERROR , ""This<S2SV_blank>stream<S2SV_blank>was<S2SV_blank>generated<S2SV_blank>by<S2SV_blank>a<S2SV_blank>broken<S2SV_blank>encoder,<S2SV_blank>invalid<S2SV_blank>8x8<S2SV_blank>inference\\n"" ) ; return - 1 ; } field_pic_flag = get_bits1 ( & h -> gb ) ; if ( field_pic_flag ) { bottom_field_flag = get_bits1 ( & h -> gb ) ; h -> picture_structure = PICT_TOP_FIELD + bottom_field_flag ; } else { h -> picture_structure = PICT_FRAME ; h -> mb_aff_frame = h -> sps . mb_aff ; } } h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME ; if ( h0 -> current_slice != 0 ) { if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Changing<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>(%d<S2SV_blank>-><S2SV_blank>%d)<S2SV_blank>between<S2SV_blank>slices<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n"" , last_pic_structure , h -> picture_structure ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_INVALIDDATA ; } else if ( ! h0 -> cur_pic_ptr ) { av_log ( h -> avctx , AV_LOG_ERROR , ""unset<S2SV_blank>cur_pic_ptr<S2SV_blank>on<S2SV_blank>%d.<S2SV_blank>slice\\n"" , h0 -> current_slice + 1 ) ; return AVERROR_INVALIDDATA ; } } else { if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 ) { int unwrap_prev_frame_num = h -> prev_frame_num ; int max_frame_num = 1 << h -> sps . log2_max_frame_num ; if ( unwrap_prev_frame_num > h -> frame_num ) unwrap_prev_frame_num -= max_frame_num ; if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count ) { unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1 ; if ( unwrap_prev_frame_num < 0 ) unwrap_prev_frame_num += max_frame_num ; h -> prev_frame_num = unwrap_prev_frame_num ; } } if ( h0 -> first_field ) { assert ( h0 -> cur_pic_ptr ) ; assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ;  if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) {  ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ; } if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) {  if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {  ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; } } else { if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) {  if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {  ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; } } else { if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>combination<S2SV_blank>%d/%d\\n"" , last_pic_structure , h -> picture_structure ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_INVALIDDATA ; } else if ( last_pic_droppable != h -> droppable ) { avpriv_request_sample ( h -> avctx , ""Found<S2SV_blank>reference<S2SV_blank>and<S2SV_blank>non-reference<S2SV_blank>fields<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame,<S2SV_blank>which"" ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_PATCHWELCOME ; } } } } while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) ) { Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; av_log ( h -> avctx , AV_LOG_DEBUG , ""Frame<S2SV_blank>num<S2SV_blank>gap<S2SV_blank>%d<S2SV_blank>%d\\n"" , h -> frame_num , h -> prev_frame_num ) ; if ( ! h -> sps . gaps_in_frame_num_allowed_flag ) for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> last_pocs ) ; i ++ ) h -> last_pocs [ i ] = INT_MIN ; ret = h264_frame_start ( h ) ; if ( ret < 0 ) return ret ; h -> prev_frame_num ++ ; h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num ; h -> cur_pic_ptr -> frame_num = h -> prev_frame_num ; ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 0 ) ; ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 1 ) ; ret = ff_generate_sliding_window_mmcos ( h , 1 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ; ret = ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ; if ( h -> short_ref_count ) { if ( prev ) { av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , h -> avctx -> pix_fmt , h -> mb_width * 16 , h -> mb_height * 16 ) ; h -> short_ref [ 0 ] -> poc = prev -> poc + 2 ; } h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num ; } } if ( h0 -> first_field ) { assert ( h0 -> cur_pic_ptr ) ; assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { h0 -> cur_pic_ptr = NULL ; h0 -> first_field = FIELD_PICTURE ( h ) ; } else { if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) { ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , h0 -> picture_structure == PICT_BOTTOM_FIELD ) ; h0 -> first_field = 1 ; h0 -> cur_pic_ptr = NULL ; } else { h0 -> first_field = 0 ; } } } else { h0 -> first_field = FIELD_PICTURE ( h ) ; } if ( ! FIELD_PICTURE ( h ) || h0 -> first_field ) { if ( h264_frame_start ( h ) < 0 ) { h0 -> first_field = 0 ; return AVERROR_INVALIDDATA ; } } else { release_unused_pictures ( h , 0 ) ; } if ( FIELD_PICTURE ( h ) ) { for ( i = ( h -> picture_structure == PICT_BOTTOM_FIELD ) ; i < h -> mb_height ; i ++ ) memset ( h -> slice_table + i * h -> mb_stride , - 1 , ( h -> mb_stride - ( i + 1 == h -> mb_height ) ) * sizeof ( * h -> slice_table ) ) ; } else { memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ) ; } h0 -> last_slice_type = - 1 ; } if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 ) return ret ; for ( i = 0 ; i < h -> slice_context_count ; i ++ ) if ( h -> thread_context [ i ] ) { ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ) ; if ( ret < 0 ) return ret ; } h -> cur_pic_ptr -> frame_num = h -> frame_num ; av_assert1 ( h -> mb_num == h -> mb_width * h -> mb_height ) ; if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num ) { av_log ( h -> avctx , AV_LOG_ERROR , ""first_mb_in_slice<S2SV_blank>overflow\\n"" ) ; return AVERROR_INVALIDDATA ; } h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width ; h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ) ; if ( h -> picture_structure == PICT_BOTTOM_FIELD ) h -> resync_mb_y = h -> mb_y = h -> mb_y + 1 ; av_assert1 ( h -> mb_y < h -> mb_height ) ; if ( h -> picture_structure == PICT_FRAME ) { h -> curr_pic_num = h -> frame_num ; h -> max_pic_num = 1 << h -> sps . log2_max_frame_num ; } else { h -> curr_pic_num = 2 * h -> frame_num + 1 ; h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ) ; } if ( h -> nal_unit_type == NAL_IDR_SLICE ) get_ue_golomb ( & h -> gb ) ; if ( h -> sps . poc_type == 0 ) { h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ) ; if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) h -> delta_poc_bottom = get_se_golomb ( & h -> gb ) ; } if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag ) { h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ) ; if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ) ; } ff_init_poc ( h , h -> cur_pic_ptr -> field_poc , & h -> cur_pic_ptr -> poc ) ; if ( h -> pps . redundant_pic_cnt_present ) h -> redundant_pic_count = get_ue_golomb ( & h -> gb ) ; ret = ff_set_ref_count ( h ) ; if ( ret < 0 ) return ret ; if ( slice_type != AV_PICTURE_TYPE_I && ( h0 -> current_slice == 0 || slice_type != h0 -> last_slice_type || memcmp ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> ref_count ) ) ) ) { ff_h264_fill_default_ref_list ( h ) ; } if ( h -> slice_type_nos != AV_PICTURE_TYPE_I ) { ret = ff_h264_decode_ref_pic_list_reordering ( h ) ; if ( ret < 0 ) { h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0 ; return ret ; } } if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) ) ff_pred_weight_table ( h ) ; else if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { implicit_weight_table ( h , - 1 ) ; } else { h -> use_weight = 0 ; for ( i = 0 ; i < 2 ; i ++ ) { h -> luma_weight_flag [ i ] = 0 ; h -> chroma_weight_flag [ i ] = 0 ; } } if ( h -> nal_ref_idc ) { ret = ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return AVERROR_INVALIDDATA ; } if ( FRAME_MBAFF ( h ) ) { ff_h264_fill_mbaff_ref_list ( h ) ; if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { implicit_weight_table ( h , 0 ) ; implicit_weight_table ( h , 1 ) ; } } if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred ) ff_h264_direct_dist_scale_factor ( h ) ; ff_h264_direct_ref_list_init ( h ) ; if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac ) { tmp = get_ue_golomb_31 ( & h -> gb ) ; if ( tmp > 2 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""cabac_init_idc<S2SV_blank>overflow\\n"" ) ; return AVERROR_INVALIDDATA ; } h -> cabac_init_idc = tmp ; } h -> last_qscale_diff = 0 ; tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ) ; if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) ) { av_log ( h -> avctx , AV_LOG_ERROR , ""QP<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , tmp ) ; return AVERROR_INVALIDDATA ; } h -> qscale = tmp ; h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ) ; h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ) ; if ( h -> slice_type == AV_PICTURE_TYPE_SP ) get_bits1 ( & h -> gb ) ; if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI ) get_se_golomb ( & h -> gb ) ; h -> deblocking_filter = 1 ; h -> slice_alpha_c0_offset = 52 ; h -> slice_beta_offset = 52 ; if ( h -> pps . deblocking_filter_parameters_present ) { tmp = get_ue_golomb_31 ( & h -> gb ) ; if ( tmp > 2 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""deblocking_filter_idc<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , tmp ) ; return AVERROR_INVALIDDATA ; } h -> deblocking_filter = tmp ; if ( h -> deblocking_filter < 2 ) h -> deblocking_filter ^= 1 ; if ( h -> deblocking_filter ) { h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1 ; h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1 ; if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U ) { av_log ( h -> avctx , AV_LOG_ERROR , ""deblocking<S2SV_blank>filter<S2SV_blank>parameters<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ) ; return AVERROR_INVALIDDATA ; } } } if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) ) h -> deblocking_filter = 0 ; if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 ) { if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST ) { h -> deblocking_filter = 2 ; } else { h0 -> max_contexts = 1 ; if ( ! h0 -> single_decode_warning ) { av_log ( h -> avctx , AV_LOG_INFO , ""Cannot<S2SV_blank>parallelize<S2SV_blank>deblocking<S2SV_blank>type<S2SV_blank>1,<S2SV_blank>decoding<S2SV_blank>such<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>sequential<S2SV_blank>order\\n"" ) ; h0 -> single_decode_warning = 1 ; } if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Deblocking<S2SV_blank>switched<S2SV_blank>inside<S2SV_blank>frame.\\n"" ) ; return 1 ; } } } h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ) ; h0 -> last_slice_type = slice_type ; memcpy ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> last_ref_count ) ) ; h -> slice_num = ++ h0 -> current_slice ; if ( h -> slice_num ) h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = h -> resync_mb_y ; if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= h -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= h -> resync_mb_y && h -> slice_num >= MAX_SLICES ) { av_log ( h -> avctx , AV_LOG_WARNING , ""Possibly<S2SV_blank>too<S2SV_blank>many<S2SV_blank>slices<S2SV_blank>(%d<S2SV_blank>>=<S2SV_blank>%d),<S2SV_blank>increase<S2SV_blank>MAX_SLICES<S2SV_blank>and<S2SV_blank>recompile<S2SV_blank>if<S2SV_blank>there<S2SV_blank>are<S2SV_blank>artifacts\\n"" , h -> slice_num , MAX_SLICES ) ; } for ( j = 0 ; j < 2 ; j ++ ) { int id_list [ 16 ] ; int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; for ( i = 0 ; i < 16 ; i ++ ) { id_list [ i ] = 60 ; if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] ) { int k ; AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; for ( k = 0 ; k < h -> short_ref_count ; k ++ ) if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { id_list [ i ] = k ; break ; } for ( k = 0 ; k < h -> long_ref_count ; k ++ ) if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { id_list [ i ] = h -> short_ref_count + k ; break ; } } } ref2frm [ 0 ] = ref2frm [ 1 ] = - 1 ; for ( i = 0 ; i < 16 ; i ++ ) ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1 ; for ( i = 16 ; i < 48 ; i ++ ) ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; } if ( h -> ref_count [ 0 ] ) h -> er . last_pic = & h -> ref_list [ 0 ] [ 0 ] ; if ( h -> ref_count [ 1 ] ) h -> er . next_pic = & h -> ref_list [ 1 ] [ 0 ] ; h -> er . ref_count = h -> ref_count [ 0 ] ; if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO ) { av_log ( h -> avctx , AV_LOG_DEBUG , ""slice:%d<S2SV_blank>%s<S2SV_blank>mb:%d<S2SV_blank>%c%s%s<S2SV_blank>pps:%u<S2SV_blank>frame:%d<S2SV_blank>poc:%d/%d<S2SV_blank>ref:%d/%d<S2SV_blank>qp:%d<S2SV_blank>loop:%d:%d:%d<S2SV_blank>weight:%d%s<S2SV_blank>%s\\n"" , h -> slice_num , ( h -> picture_structure == PICT_FRAME ? ""F"" : h -> picture_structure == PICT_TOP_FIELD ? ""T"" : ""B"" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? ""<S2SV_blank>fix"" : """" , h -> nal_unit_type == NAL_IDR_SLICE ? ""<S2SV_blank>IDR"" : """" , pps_id , h -> frame_num , h -> cur_pic_ptr -> field_poc [ 0 ] , h -> cur_pic_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , h -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? ""c"" : """" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? ""SPAT"" : ""TEMP"" ) : """" ) ; } return 0 ; }",if ( h0 -> cur_pic_ptr ) {,2224
93,"buggy line: if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;cwe id:CWE-000context: static int decode_slice_header ( H264Context * h , H264Context * h0 ) { unsigned int first_mb_in_slice ; unsigned int pps_id ; int ret ; unsigned int slice_type , tmp , i , j ; int last_pic_structure , last_pic_droppable ; int must_reinit ; int needs_reinit = 0 ; int field_pic_flag , bottom_field_flag ; h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab ; h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab ; first_mb_in_slice = get_ue_golomb_long ( & h -> gb ) ; if ( first_mb_in_slice == 0 ) { if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) { field_end ( h , 1 ) ; } h0 -> current_slice = 0 ; if ( ! h0 -> first_field ) { if ( h -> cur_pic_ptr && ! h -> droppable ) { ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ; } h -> cur_pic_ptr = NULL ; } } slice_type = get_ue_golomb_31 ( & h -> gb ) ; if ( slice_type > 9 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""slice<S2SV_blank>type<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>%d\\n"" , slice_type , h -> mb_x , h -> mb_y ) ; return AVERROR_INVALIDDATA ; } if ( slice_type > 4 ) { slice_type -= 5 ; h -> slice_type_fixed = 1 ; } else h -> slice_type_fixed = 0 ; slice_type = golomb_to_pict_type [ slice_type ] ; h -> slice_type = slice_type ; h -> slice_type_nos = slice_type & 3 ; h -> pict_type = h -> slice_type ; pps_id = get_ue_golomb ( & h -> gb ) ; if ( pps_id >= MAX_PPS_COUNT ) { av_log ( h -> avctx , AV_LOG_ERROR , ""pps_id<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! h0 -> pps_buffers [ pps_id ] ) { av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>PPS<S2SV_blank>%u<S2SV_blank>referenced\\n"" , pps_id ) ; return AVERROR_INVALIDDATA ; } h -> pps = * h0 -> pps_buffers [ pps_id ] ; if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] ) { av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>SPS<S2SV_blank>%u<S2SV_blank>referenced\\n"" , h -> pps . sps_id ) ; return AVERROR_INVALIDDATA ; } if ( h -> pps . sps_id != h -> current_sps_id || h0 -> sps_buffers [ h -> pps . sps_id ] -> new ) { h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 ; h -> current_sps_id = h -> pps . sps_id ; h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ] ; if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc ) needs_reinit = 1 ; if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc ) { h -> bit_depth_luma = h -> sps . bit_depth_luma ; h -> chroma_format_idc = h -> sps . chroma_format_idc ; needs_reinit = 1 ; } if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 ) return ret ; } h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ) ; h -> avctx -> level = h -> sps . level_idc ; h -> avctx -> refs = h -> sps . ref_frame_count ; must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ) ; if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) ) must_reinit = 1 ; h -> mb_width = h -> sps . mb_width ; h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ; h -> mb_num = h -> mb_width * h -> mb_height ; h -> mb_stride = h -> mb_width + 1 ; h -> b_stride = h -> mb_width * 4 ; h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1 ; h -> width = 16 * h -> mb_width ; h -> height = 16 * h -> mb_height ; ret = init_dimensions ( h ) ; if ( ret < 0 ) return ret ; if ( h -> sps . video_signal_type_present_flag ) { h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG ; if ( h -> sps . colour_description_present_flag ) { if ( h -> avctx -> colorspace != h -> sps . colorspace ) needs_reinit = 1 ; h -> avctx -> color_primaries = h -> sps . color_primaries ; h -> avctx -> color_trc = h -> sps . color_trc ; h -> avctx -> colorspace = h -> sps . colorspace ; } } if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) ) { if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""changing<S2SV_blank>width/height<S2SV_blank>on<S2SV_blank>"" ""slice<S2SV_blank>%d\\n"" , h0 -> current_slice + 1 ) ; return AVERROR_INVALIDDATA ; } flush_change ( h ) ; if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ; h -> avctx -> pix_fmt = ret ; av_log ( h -> avctx , AV_LOG_INFO , ""Reinit<S2SV_blank>context<S2SV_blank>to<S2SV_blank>%dx%d,<S2SV_blank>"" ""pix_fmt:<S2SV_blank>%s\\n"" , h -> width , h -> height , av_get_pix_fmt_name ( h -> avctx -> pix_fmt ) ) ; if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\n"" ) ; return ret ; } } if ( ! h -> context_initialized ) { if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Cannot<S2SV_blank>(re-)initialize<S2SV_blank>context<S2SV_blank>during<S2SV_blank>parallel<S2SV_blank>decoding.\\n"" ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ; h -> avctx -> pix_fmt = ret ; if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\n"" ) ; return ret ; } } if ( h == h0 && h -> dequant_coeff_pps != pps_id ) { h -> dequant_coeff_pps = pps_id ; init_dequant_tables ( h ) ; } h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ) ; h -> mb_mbaff = 0 ; h -> mb_aff_frame = 0 ; last_pic_structure = h0 -> picture_structure ; last_pic_droppable = h0 -> droppable ; h -> droppable = h -> nal_ref_idc == 0 ; if ( h -> sps . frame_mbs_only_flag ) { h -> picture_structure = PICT_FRAME ; } else { if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B ) { av_log ( h -> avctx , AV_LOG_ERROR , ""This<S2SV_blank>stream<S2SV_blank>was<S2SV_blank>generated<S2SV_blank>by<S2SV_blank>a<S2SV_blank>broken<S2SV_blank>encoder,<S2SV_blank>invalid<S2SV_blank>8x8<S2SV_blank>inference\\n"" ) ; return - 1 ; } field_pic_flag = get_bits1 ( & h -> gb ) ; if ( field_pic_flag ) { bottom_field_flag = get_bits1 ( & h -> gb ) ; h -> picture_structure = PICT_TOP_FIELD + bottom_field_flag ; } else { h -> picture_structure = PICT_FRAME ; h -> mb_aff_frame = h -> sps . mb_aff ; } } h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME ; if ( h0 -> current_slice != 0 ) { if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Changing<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>(%d<S2SV_blank>-><S2SV_blank>%d)<S2SV_blank>between<S2SV_blank>slices<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n"" , last_pic_structure , h -> picture_structure ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_INVALIDDATA ; } else if ( ! h0 -> cur_pic_ptr ) { av_log ( h -> avctx , AV_LOG_ERROR , ""unset<S2SV_blank>cur_pic_ptr<S2SV_blank>on<S2SV_blank>%d.<S2SV_blank>slice\\n"" , h0 -> current_slice + 1 ) ; return AVERROR_INVALIDDATA ; } } else { if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 ) { int unwrap_prev_frame_num = h -> prev_frame_num ; int max_frame_num = 1 << h -> sps . log2_max_frame_num ; if ( unwrap_prev_frame_num > h -> frame_num ) unwrap_prev_frame_num -= max_frame_num ; if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count ) { unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1 ; if ( unwrap_prev_frame_num < 0 ) unwrap_prev_frame_num += max_frame_num ; h -> prev_frame_num = unwrap_prev_frame_num ; } } if ( h0 -> first_field ) { assert ( h0 -> cur_pic_ptr ) ; assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ;  if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) {  ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ; } if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) {  if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {  ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; } } else { if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) {  if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {  ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; } } else { if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>combination<S2SV_blank>%d/%d\\n"" , last_pic_structure , h -> picture_structure ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_INVALIDDATA ; } else if ( last_pic_droppable != h -> droppable ) { avpriv_request_sample ( h -> avctx , ""Found<S2SV_blank>reference<S2SV_blank>and<S2SV_blank>non-reference<S2SV_blank>fields<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame,<S2SV_blank>which"" ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_PATCHWELCOME ; } } } } while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) ) { Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; av_log ( h -> avctx , AV_LOG_DEBUG , ""Frame<S2SV_blank>num<S2SV_blank>gap<S2SV_blank>%d<S2SV_blank>%d\\n"" , h -> frame_num , h -> prev_frame_num ) ; if ( ! h -> sps . gaps_in_frame_num_allowed_flag ) for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> last_pocs ) ; i ++ ) h -> last_pocs [ i ] = INT_MIN ; ret = h264_frame_start ( h ) ; if ( ret < 0 ) return ret ; h -> prev_frame_num ++ ; h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num ; h -> cur_pic_ptr -> frame_num = h -> prev_frame_num ; ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 0 ) ; ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 1 ) ; ret = ff_generate_sliding_window_mmcos ( h , 1 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ; ret = ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ; if ( h -> short_ref_count ) { if ( prev ) { av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , h -> avctx -> pix_fmt , h -> mb_width * 16 , h -> mb_height * 16 ) ; h -> short_ref [ 0 ] -> poc = prev -> poc + 2 ; } h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num ; } } if ( h0 -> first_field ) { assert ( h0 -> cur_pic_ptr ) ; assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { h0 -> cur_pic_ptr = NULL ; h0 -> first_field = FIELD_PICTURE ( h ) ; } else { if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) { ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , h0 -> picture_structure == PICT_BOTTOM_FIELD ) ; h0 -> first_field = 1 ; h0 -> cur_pic_ptr = NULL ; } else { h0 -> first_field = 0 ; } } } else { h0 -> first_field = FIELD_PICTURE ( h ) ; } if ( ! FIELD_PICTURE ( h ) || h0 -> first_field ) { if ( h264_frame_start ( h ) < 0 ) { h0 -> first_field = 0 ; return AVERROR_INVALIDDATA ; } } else { release_unused_pictures ( h , 0 ) ; } if ( FIELD_PICTURE ( h ) ) { for ( i = ( h -> picture_structure == PICT_BOTTOM_FIELD ) ; i < h -> mb_height ; i ++ ) memset ( h -> slice_table + i * h -> mb_stride , - 1 , ( h -> mb_stride - ( i + 1 == h -> mb_height ) ) * sizeof ( * h -> slice_table ) ) ; } else { memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ) ; } h0 -> last_slice_type = - 1 ; } if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 ) return ret ; for ( i = 0 ; i < h -> slice_context_count ; i ++ ) if ( h -> thread_context [ i ] ) { ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ) ; if ( ret < 0 ) return ret ; } h -> cur_pic_ptr -> frame_num = h -> frame_num ; av_assert1 ( h -> mb_num == h -> mb_width * h -> mb_height ) ; if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num ) { av_log ( h -> avctx , AV_LOG_ERROR , ""first_mb_in_slice<S2SV_blank>overflow\\n"" ) ; return AVERROR_INVALIDDATA ; } h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width ; h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ) ; if ( h -> picture_structure == PICT_BOTTOM_FIELD ) h -> resync_mb_y = h -> mb_y = h -> mb_y + 1 ; av_assert1 ( h -> mb_y < h -> mb_height ) ; if ( h -> picture_structure == PICT_FRAME ) { h -> curr_pic_num = h -> frame_num ; h -> max_pic_num = 1 << h -> sps . log2_max_frame_num ; } else { h -> curr_pic_num = 2 * h -> frame_num + 1 ; h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ) ; } if ( h -> nal_unit_type == NAL_IDR_SLICE ) get_ue_golomb ( & h -> gb ) ; if ( h -> sps . poc_type == 0 ) { h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ) ; if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) h -> delta_poc_bottom = get_se_golomb ( & h -> gb ) ; } if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag ) { h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ) ; if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ) ; } ff_init_poc ( h , h -> cur_pic_ptr -> field_poc , & h -> cur_pic_ptr -> poc ) ; if ( h -> pps . redundant_pic_cnt_present ) h -> redundant_pic_count = get_ue_golomb ( & h -> gb ) ; ret = ff_set_ref_count ( h ) ; if ( ret < 0 ) return ret ; if ( slice_type != AV_PICTURE_TYPE_I && ( h0 -> current_slice == 0 || slice_type != h0 -> last_slice_type || memcmp ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> ref_count ) ) ) ) { ff_h264_fill_default_ref_list ( h ) ; } if ( h -> slice_type_nos != AV_PICTURE_TYPE_I ) { ret = ff_h264_decode_ref_pic_list_reordering ( h ) ; if ( ret < 0 ) { h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0 ; return ret ; } } if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) ) ff_pred_weight_table ( h ) ; else if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { implicit_weight_table ( h , - 1 ) ; } else { h -> use_weight = 0 ; for ( i = 0 ; i < 2 ; i ++ ) { h -> luma_weight_flag [ i ] = 0 ; h -> chroma_weight_flag [ i ] = 0 ; } } if ( h -> nal_ref_idc ) { ret = ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return AVERROR_INVALIDDATA ; } if ( FRAME_MBAFF ( h ) ) { ff_h264_fill_mbaff_ref_list ( h ) ; if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { implicit_weight_table ( h , 0 ) ; implicit_weight_table ( h , 1 ) ; } } if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred ) ff_h264_direct_dist_scale_factor ( h ) ; ff_h264_direct_ref_list_init ( h ) ; if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac ) { tmp = get_ue_golomb_31 ( & h -> gb ) ; if ( tmp > 2 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""cabac_init_idc<S2SV_blank>overflow\\n"" ) ; return AVERROR_INVALIDDATA ; } h -> cabac_init_idc = tmp ; } h -> last_qscale_diff = 0 ; tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ) ; if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) ) { av_log ( h -> avctx , AV_LOG_ERROR , ""QP<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , tmp ) ; return AVERROR_INVALIDDATA ; } h -> qscale = tmp ; h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ) ; h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ) ; if ( h -> slice_type == AV_PICTURE_TYPE_SP ) get_bits1 ( & h -> gb ) ; if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI ) get_se_golomb ( & h -> gb ) ; h -> deblocking_filter = 1 ; h -> slice_alpha_c0_offset = 52 ; h -> slice_beta_offset = 52 ; if ( h -> pps . deblocking_filter_parameters_present ) { tmp = get_ue_golomb_31 ( & h -> gb ) ; if ( tmp > 2 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""deblocking_filter_idc<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , tmp ) ; return AVERROR_INVALIDDATA ; } h -> deblocking_filter = tmp ; if ( h -> deblocking_filter < 2 ) h -> deblocking_filter ^= 1 ; if ( h -> deblocking_filter ) { h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1 ; h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1 ; if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U ) { av_log ( h -> avctx , AV_LOG_ERROR , ""deblocking<S2SV_blank>filter<S2SV_blank>parameters<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ) ; return AVERROR_INVALIDDATA ; } } } if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) ) h -> deblocking_filter = 0 ; if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 ) { if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST ) { h -> deblocking_filter = 2 ; } else { h0 -> max_contexts = 1 ; if ( ! h0 -> single_decode_warning ) { av_log ( h -> avctx , AV_LOG_INFO , ""Cannot<S2SV_blank>parallelize<S2SV_blank>deblocking<S2SV_blank>type<S2SV_blank>1,<S2SV_blank>decoding<S2SV_blank>such<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>sequential<S2SV_blank>order\\n"" ) ; h0 -> single_decode_warning = 1 ; } if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Deblocking<S2SV_blank>switched<S2SV_blank>inside<S2SV_blank>frame.\\n"" ) ; return 1 ; } } } h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ) ; h0 -> last_slice_type = slice_type ; memcpy ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> last_ref_count ) ) ; h -> slice_num = ++ h0 -> current_slice ; if ( h -> slice_num ) h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = h -> resync_mb_y ; if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= h -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= h -> resync_mb_y && h -> slice_num >= MAX_SLICES ) { av_log ( h -> avctx , AV_LOG_WARNING , ""Possibly<S2SV_blank>too<S2SV_blank>many<S2SV_blank>slices<S2SV_blank>(%d<S2SV_blank>>=<S2SV_blank>%d),<S2SV_blank>increase<S2SV_blank>MAX_SLICES<S2SV_blank>and<S2SV_blank>recompile<S2SV_blank>if<S2SV_blank>there<S2SV_blank>are<S2SV_blank>artifacts\\n"" , h -> slice_num , MAX_SLICES ) ; } for ( j = 0 ; j < 2 ; j ++ ) { int id_list [ 16 ] ; int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; for ( i = 0 ; i < 16 ; i ++ ) { id_list [ i ] = 60 ; if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] ) { int k ; AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; for ( k = 0 ; k < h -> short_ref_count ; k ++ ) if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { id_list [ i ] = k ; break ; } for ( k = 0 ; k < h -> long_ref_count ; k ++ ) if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { id_list [ i ] = h -> short_ref_count + k ; break ; } } } ref2frm [ 0 ] = ref2frm [ 1 ] = - 1 ; for ( i = 0 ; i < 16 ; i ++ ) ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1 ; for ( i = 16 ; i < 48 ; i ++ ) ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; } if ( h -> ref_count [ 0 ] ) h -> er . last_pic = & h -> ref_list [ 0 ] [ 0 ] ; if ( h -> ref_count [ 1 ] ) h -> er . next_pic = & h -> ref_list [ 1 ] [ 0 ] ; h -> er . ref_count = h -> ref_count [ 0 ] ; if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO ) { av_log ( h -> avctx , AV_LOG_DEBUG , ""slice:%d<S2SV_blank>%s<S2SV_blank>mb:%d<S2SV_blank>%c%s%s<S2SV_blank>pps:%u<S2SV_blank>frame:%d<S2SV_blank>poc:%d/%d<S2SV_blank>ref:%d/%d<S2SV_blank>qp:%d<S2SV_blank>loop:%d:%d:%d<S2SV_blank>weight:%d%s<S2SV_blank>%s\\n"" , h -> slice_num , ( h -> picture_structure == PICT_FRAME ? ""F"" : h -> picture_structure == PICT_TOP_FIELD ? ""T"" : ""B"" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? ""<S2SV_blank>fix"" : """" , h -> nal_unit_type == NAL_IDR_SLICE ? ""<S2SV_blank>IDR"" : """" , pps_id , h -> frame_num , h -> cur_pic_ptr -> field_poc [ 0 ] , h -> cur_pic_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , h -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? ""c"" : """" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? ""SPAT"" : ""TEMP"" ) : """" ) ; } return 0 ; }","if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;",2224
94,"buggy line: const int v = ( int ) ( .5 + 256 * vp8_gaussian ( sigma , 0 , i ) ) ;if ( v ) {cwe id:CWE-119context: static void fillrd ( struct postproc_state * state , int q , int a ) { char char_dist [ 300 ] ; double sigma ; int i ; vp8_clear_system_state ( ) ; sigma = a + .5 + .6 * ( 63 - q ) / 63.0 ; { int next , j ; next = 0 ; for ( i = - 32 ; i < 32 ; i ++ ) {  const int v = ( int ) ( .5 + 256 * vp8_gaussian ( sigma , 0 , i ) ) ;  if ( v ) { for ( j = 0 ; j < v ; j ++ ) { char_dist [ next + j ] = ( char ) i ; } next = next + j ; } } for ( ; next < 256 ; next ++ ) char_dist [ next ] = 0 ; } for ( i = 0 ; i < 3072 ; i ++ ) { state -> noise [ i ] = char_dist [ rand ( ) & 0xff ] ; } for ( i = 0 ; i < 16 ; i ++ ) { state -> blackclamp [ i ] = - char_dist [ 0 ] ; state -> whiteclamp [ i ] = - char_dist [ 0 ] ; state -> bothclamp [ i ] = - 2 * char_dist [ 0 ] ; } state -> last_q = q ; state -> last_noise = a ; }","const int v = ( int ) ( .5 + 256 * gaussian ( sigma , 0 , i ) ) ;if ( v ) {",2225
95,"buggy line: uint64 nstrips64 ;uint32 nstrips32 ;cwe id:CWE-125context: static void ChopUpSingleUncompressedStrip ( TIFF * tif ) { register TIFFDirectory * td = & tif -> tif_dir ; uint64 bytecount ; uint64 offset ; uint32 rowblock ; uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ;  uint64 nstrips64 ;  uint32 nstrips32 ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 * newoffsets ; bytecount = td -> td_stripbytecount [ 0 ] ; offset = td -> td_stripoffset [ 0 ] ; assert ( td -> td_planarconfig == PLANARCONFIG_CONTIG ) ; if ( ( td -> td_photometric == PHOTOMETRIC_YCBCR ) && ( ! isUpSampled ( tif ) ) ) rowblock = td -> td_ycbcrsubsampling [ 1 ] ; else rowblock = 1 ; rowblockbytes = TIFFVTileSize64 ( tif , rowblock ) ; if ( rowblockbytes > STRIP_SIZE_DEFAULT ) { stripbytes = rowblockbytes ; rowsperstrip = rowblock ; } else if ( rowblockbytes > 0 ) { uint32 rowblocksperstrip ; rowblocksperstrip = ( uint32 ) ( STRIP_SIZE_DEFAULT / rowblockbytes ) ; rowsperstrip = rowblocksperstrip * rowblock ; stripbytes = rowblocksperstrip * rowblockbytes ; } else return ; if ( rowsperstrip >= td -> td_rowsperstrip ) return ;  nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ;   if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) )  return ; nstrips32 = ( uint32 ) nstrips64 ;  newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\""StripByteCounts\\""<S2SV_blank>array"" ) ;  newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\""StripOffsets\\""<S2SV_blank>array"" ) ; if ( newcounts == NULL || newoffsets == NULL ) { if ( newcounts != NULL ) _TIFFfree ( newcounts ) ; if ( newoffsets != NULL ) _TIFFfree ( newoffsets ) ; return ; }  for ( strip = 0 ; strip < nstrips32 ; strip ++ ) {  if ( stripbytes > bytecount ) stripbytes = bytecount ; newcounts [ strip ] = stripbytes ;  newoffsets [ strip ] = offset ;  offset += stripbytes ; bytecount -= stripbytes ; }  td -> td_stripsperimage = td -> td_nstrips = nstrips32 ;  TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; _TIFFfree ( td -> td_stripbytecount ) ; _TIFFfree ( td -> td_stripoffset ) ; td -> td_stripbytecount = newcounts ; td -> td_stripoffset = newoffsets ; td -> td_stripbytecountsorted = 1 ; }",uint32 nstrips ;,2226
96,"buggy line: nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ;if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) )  return ;newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripByteCounts\\\\""<S2SV_blank>array"" ) ;newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripOffsets\\\\""<S2SV_blank>array"" ) ;for ( strip = 0 ;strip < nstrips32 ;if ( stripbytes > bytecount ) stripbytes = bytecount ;newcounts [ strip ] = stripbytes ;newoffsets [ strip ] = offset ;offset += stripbytes ;td -> td_stripsperimage = td -> td_nstrips = nstrips32 ;TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ;cwe id:CWE-125context: static void ChopUpSingleUncompressedStrip ( TIFF * tif ) { register TIFFDirectory * td = & tif -> tif_dir ; uint64 bytecount ; uint64 offset ; uint32 rowblock ; uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ;  uint64 nstrips64 ;  uint32 nstrips32 ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 * newoffsets ; bytecount = td -> td_stripbytecount [ 0 ] ; offset = td -> td_stripoffset [ 0 ] ; assert ( td -> td_planarconfig == PLANARCONFIG_CONTIG ) ; if ( ( td -> td_photometric == PHOTOMETRIC_YCBCR ) && ( ! isUpSampled ( tif ) ) ) rowblock = td -> td_ycbcrsubsampling [ 1 ] ; else rowblock = 1 ; rowblockbytes = TIFFVTileSize64 ( tif , rowblock ) ; if ( rowblockbytes > STRIP_SIZE_DEFAULT ) { stripbytes = rowblockbytes ; rowsperstrip = rowblock ; } else if ( rowblockbytes > 0 ) { uint32 rowblocksperstrip ; rowblocksperstrip = ( uint32 ) ( STRIP_SIZE_DEFAULT / rowblockbytes ) ; rowsperstrip = rowblocksperstrip * rowblock ; stripbytes = rowblocksperstrip * rowblockbytes ; } else return ; if ( rowsperstrip >= td -> td_rowsperstrip ) return ;  nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ;   if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) )  return ; nstrips32 = ( uint32 ) nstrips64 ;  newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\""StripByteCounts\\""<S2SV_blank>array"" ) ;  newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\""StripOffsets\\""<S2SV_blank>array"" ) ; if ( newcounts == NULL || newoffsets == NULL ) { if ( newcounts != NULL ) _TIFFfree ( newcounts ) ; if ( newoffsets != NULL ) _TIFFfree ( newoffsets ) ; return ; }  for ( strip = 0 ; strip < nstrips32 ; strip ++ ) {  if ( stripbytes > bytecount ) stripbytes = bytecount ; newcounts [ strip ] = stripbytes ;  newoffsets [ strip ] = offset ;  offset += stripbytes ; bytecount -= stripbytes ; }  td -> td_stripsperimage = td -> td_nstrips = nstrips32 ;  TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; _TIFFfree ( td -> td_stripbytecount ) ; _TIFFfree ( td -> td_stripoffset ) ; td -> td_stripbytecount = newcounts ; td -> td_stripoffset = newoffsets ; td -> td_stripbytecountsorted = 1 ; }","nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ;if ( nstrips == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) return ;newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips , sizeof ( uint64 ) , ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripByteCounts\\\\""<S2SV_blank>array"" ) ;newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips , sizeof ( uint64 ) , ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripOffsets\\\\""<S2SV_blank>array"" ) ;for ( strip = 0 ;strip < nstrips ;if ( stripbytes > bytecount ) stripbytes = bytecount ;newcounts [ strip ] = stripbytes ? offset : 0 ;offset += stripbytes ;td -> td_stripsperimage = td -> td_nstrips = nstrips ;TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ;",2226
97,"buggy line: assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ;memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ;cwe id:CWE-617context: struct lldpd_mgmt * lldpd_alloc_mgmt ( int family , void * addrptr , size_t addrsize , u_int32_t iface ) { struct lldpd_mgmt * mgmt ; log_debug ( ""alloc"" , ""allocate<S2SV_blank>a<S2SV_blank>new<S2SV_blank>management<S2SV_blank>address<S2SV_blank>(family:<S2SV_blank>%d)"" , family ) ; if ( family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST ) { errno = EAFNOSUPPORT ; return NULL ; } if ( addrsize > LLDPD_MGMT_MAXADDRSIZE ) { errno = EOVERFLOW ; return NULL ; } mgmt = calloc ( 1 , sizeof ( struct lldpd_mgmt ) ) ; if ( mgmt == NULL ) { errno = ENOMEM ; return NULL ; } mgmt -> m_family = family ;  assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ;  memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ; mgmt -> m_addrsize = addrsize ; mgmt -> m_iface = iface ; return mgmt ; }","memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ;",2227
98,"buggy line: int result ;D_imp_xxh ( dbh ) ;cwe id:CWE-416context: static int my_login ( pTHX_ SV * dbh , imp_dbh_t * imp_dbh ) { SV * sv ; HV * hv ; char * dbname ; char * host ; char * port ; char * user ; char * password ; char * mysql_socket ;  int result ;  D_imp_xxh ( dbh ) ; # define TAKE_IMP_DATA_VERSION 1 # if TAKE_IMP_DATA_VERSION if ( DBIc_has ( imp_dbh , DBIcf_IMPSET ) ) { if ( DBIc_has ( imp_dbh , DBIcf_ACTIVE ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""my_login<S2SV_blank>skip<S2SV_blank>connect\\n"" ) ; ++ DBIc_ACTIVE_KIDS ( DBIc_PARENT_COM ( imp_dbh ) ) ; return TRUE ; } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""my_login<S2SV_blank>IMPSET<S2SV_blank>but<S2SV_blank>not<S2SV_blank>ACTIVE<S2SV_blank>so<S2SV_blank>connect<S2SV_blank>not<S2SV_blank>skipped\\n"" ) ; } # endif sv = DBIc_IMP_DATA ( imp_dbh ) ; if ( ! sv || ! SvROK ( sv ) ) return FALSE ; hv = ( HV * ) SvRV ( sv ) ; if ( SvTYPE ( hv ) != SVt_PVHV ) return FALSE ; host = safe_hv_fetch ( aTHX_ hv , ""host"" , 4 ) ; port = safe_hv_fetch ( aTHX_ hv , ""port"" , 4 ) ; user = safe_hv_fetch ( aTHX_ hv , ""user"" , 4 ) ; password = safe_hv_fetch ( aTHX_ hv , ""password"" , 8 ) ; dbname = safe_hv_fetch ( aTHX_ hv , ""database"" , 8 ) ; mysql_socket = safe_hv_fetch ( aTHX_ hv , ""mysql_socket"" , 12 ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""imp_dbh->my_login<S2SV_blank>:<S2SV_blank>dbname<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>pwd<S2SV_blank>=<S2SV_blank>%s,"" ""host<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%s\\n"" , dbname ? dbname : ""NULL"" , user ? user : ""NULL"" , password ? password : ""NULL"" , host ? host : ""NULL"" , port ? port : ""NULL"" ) ; if ( ! imp_dbh -> pmysql ) {  Newz ( 908 , imp_dbh -> pmysql , 1 , MYSQL ) ;  } result = mysql_dr_connect ( dbh , imp_dbh -> pmysql , mysql_socket , host , port , user , password , dbname , imp_dbh ) ? TRUE : FALSE ;  if ( ! result )   Safefree ( imp_dbh -> pmysql ) ;  return result ; }",int result ;int fresh = 0 ;D_imp_xxh ( dbh ) ;,2228
99,"buggy line: Newz ( 908 , imp_dbh -> pmysql , 1 , MYSQL ) ;}if ( ! result )   Safefree ( imp_dbh -> pmysql ) ;return result ;cwe id:CWE-416context: static int my_login ( pTHX_ SV * dbh , imp_dbh_t * imp_dbh ) { SV * sv ; HV * hv ; char * dbname ; char * host ; char * port ; char * user ; char * password ; char * mysql_socket ;  int result ;  D_imp_xxh ( dbh ) ; # define TAKE_IMP_DATA_VERSION 1 # if TAKE_IMP_DATA_VERSION if ( DBIc_has ( imp_dbh , DBIcf_IMPSET ) ) { if ( DBIc_has ( imp_dbh , DBIcf_ACTIVE ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""my_login<S2SV_blank>skip<S2SV_blank>connect\\n"" ) ; ++ DBIc_ACTIVE_KIDS ( DBIc_PARENT_COM ( imp_dbh ) ) ; return TRUE ; } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""my_login<S2SV_blank>IMPSET<S2SV_blank>but<S2SV_blank>not<S2SV_blank>ACTIVE<S2SV_blank>so<S2SV_blank>connect<S2SV_blank>not<S2SV_blank>skipped\\n"" ) ; } # endif sv = DBIc_IMP_DATA ( imp_dbh ) ; if ( ! sv || ! SvROK ( sv ) ) return FALSE ; hv = ( HV * ) SvRV ( sv ) ; if ( SvTYPE ( hv ) != SVt_PVHV ) return FALSE ; host = safe_hv_fetch ( aTHX_ hv , ""host"" , 4 ) ; port = safe_hv_fetch ( aTHX_ hv , ""port"" , 4 ) ; user = safe_hv_fetch ( aTHX_ hv , ""user"" , 4 ) ; password = safe_hv_fetch ( aTHX_ hv , ""password"" , 8 ) ; dbname = safe_hv_fetch ( aTHX_ hv , ""database"" , 8 ) ; mysql_socket = safe_hv_fetch ( aTHX_ hv , ""mysql_socket"" , 12 ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""imp_dbh->my_login<S2SV_blank>:<S2SV_blank>dbname<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>pwd<S2SV_blank>=<S2SV_blank>%s,"" ""host<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%s\\n"" , dbname ? dbname : ""NULL"" , user ? user : ""NULL"" , password ? password : ""NULL"" , host ? host : ""NULL"" , port ? port : ""NULL"" ) ; if ( ! imp_dbh -> pmysql ) {  Newz ( 908 , imp_dbh -> pmysql , 1 , MYSQL ) ;  } result = mysql_dr_connect ( dbh , imp_dbh -> pmysql , mysql_socket , host , port , user , password , dbname , imp_dbh ) ? TRUE : FALSE ;  if ( ! result )   Safefree ( imp_dbh -> pmysql ) ;  return result ; }","fresh = 1 ;Newz ( 908 , imp_dbh -> pmysql , 1 , MYSQL ) ;}if ( fresh && ! result ) {do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ;Safefree ( imp_dbh -> pmysql ) ;imp_dbh -> pmysql = NULL ;}return result ;",2228
100,"buggy line: strcpy ( cat_enum . szPath , fileName ) ;sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ;strcpy ( cat_enum . szRad1 , fileName ) ;}strcpy ( cat_enum . szRad1 , sep + 1 ) ;sep [ 0 ] = 0 ;}sep = strchr ( cat_enum . szRad1 , \'*\' ) ;strcpy ( cat_enum . szRad2 , sep + 1 ) ;sep [ 0 ] = 0 ;sep = strchr ( cat_enum . szRad2 , \'%\' ) ;if ( ! sep ) sep = strchr ( cat_enum . szRad2 , \'#\' ) ;if ( sep ) {strcpy ( cat_enum . szOpt , sep ) ;cwe id:CWE-119context: GF_Err cat_multiple_files ( GF_ISOFile * dest , char * fileName , u32 import_flags , Double force_fps , u32 frames_per_sample , char * tmp_dir , Bool force_cat , Bool align_timelines , Bool allow_add_in_command ) { CATEnum cat_enum ; char * sep ; cat_enum . dest = dest ; cat_enum . import_flags = import_flags ; cat_enum . force_fps = force_fps ; cat_enum . frames_per_sample = frames_per_sample ; cat_enum . tmp_dir = tmp_dir ; cat_enum . force_cat = force_cat ; cat_enum . align_timelines = align_timelines ; cat_enum . allow_add_in_command = allow_add_in_command ;  strcpy ( cat_enum . szPath , fileName ) ;  sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ; if ( ! sep ) sep = strrchr ( cat_enum . szPath , '/' ) ; if ( ! sep ) { strcpy ( cat_enum . szPath , ""."" ) ;  strcpy ( cat_enum . szRad1 , fileName ) ;  } else {  strcpy ( cat_enum . szRad1 , sep + 1 ) ;  sep [ 0 ] = 0 ; }  sep = strchr ( cat_enum . szRad1 , '*' ) ;   strcpy ( cat_enum . szRad2 , sep + 1 ) ;  sep [ 0 ] = 0 ;  sep = strchr ( cat_enum . szRad2 , '%' ) ;  if ( ! sep ) sep = strchr ( cat_enum . szRad2 , '#' ) ; if ( ! sep ) sep = strchr ( cat_enum . szRad2 , ':' ) ; strcpy ( cat_enum . szOpt , """" ) ;  if ( sep ) {  strcpy ( cat_enum . szOpt , sep ) ; sep [ 0 ] = 0 ; } return gf_enum_directory ( cat_enum . szPath , 0 , cat_enumerate , & cat_enum , NULL ) ; }","if ( strlen ( fileName ) >= sizeof ( cat_enum . szPath ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\\return GF_NOT_SUPPORTED ;}strcpy ( cat_enum . szPath , fileName ) ;sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ;if ( strlen ( fileName ) >= sizeof ( cat_enum . szRad1 ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\\return GF_NOT_SUPPORTED ;}strcpy ( cat_enum . szRad1 , fileName ) ;}if ( strlen ( sep + 1 ) ;sep [ 0 ] = 0 ;}sep = strchr ( cat_enum . szRad1 , \'*\' ) ;strcpy ( cat_enum . szRad2 , sep + 1 ) >= sizeof ( cat_enum . szRad2 , \'%\' ) ;if ( ! sep ) sep = strchr ( cat_enum . szRad2 , \'#\' ) ;if ( sep ) {if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Invalid<S2SV_blank>option:<S2SV_blank>%s.\\\return GF_NOT_SUPPORTED ;}strcpy ( cat_enum . szOpt , sep ) ;}",2229
101,"buggy line: stbbr_send ( ""<presence<S2SV_blank>to=\\\'stabber@localhost\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ;assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\\\""On<S2SV_blank>my<S2SV_blank>mobile\\\\"""" ) ) ;prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ;assert_true ( prof_output_exact ( ""unencrypted"" ) ) ;stbbr_send (  ""<message<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost\\\'>""  ""<received<S2SV_blank>xmlns=\\\'urn:xmpp:carbons:2\\\'>"" ""<forwarded<S2SV_blank>xmlns=\\\'urn:xmpp:forward:0\\\'>"" ""<message<S2SV_blank>id=\\\'prof_msg_7\\\'<S2SV_blank>xmlns=\\\'jabber:client\\\'<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>lang=\\\'en\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ;cwe id:CWE-346context: void receive_carbon ( void * * state ) { prof_input ( ""/carbons<S2SV_blank>on"" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( ""<iq<S2SV_blank>id=\'*\'<S2SV_blank>type=\'set\'><enable<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'/></iq>"" ) ) ; stbbr_send ( ""<presence<S2SV_blank>to=\'stabber@localhost\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ; assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\""On<S2SV_blank>my<S2SV_blank>mobile\\"""" ) ) ; prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ; assert_true ( prof_output_exact ( ""unencrypted"" ) ) ; stbbr_send (  ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>""  ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ; assert_true ( prof_output_regex ( ""Buddy1/mobile:<S2SV_blank>.+test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient"" ) ) ; }","stbbr_send ( ""<message<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'stabber@localhost\\\'>"" ""<received<S2SV_blank>xmlns=\\\'urn:xmpp:carbons:2\\\'>"" ""<forwarded<S2SV_blank>xmlns=\\\'urn:xmpp:forward:0\\\'>"" ""<message<S2SV_blank>id=\\\'prof_msg_7\\\'<S2SV_blank>xmlns=\\\'jabber:client\\\'<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>lang=\\\'en\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ;",2230
102,"buggy line: int n ;assert ( cnt >= 0 ) ;cwe id:CWE-190context: static int mem_read ( jas_stream_obj_t * obj , char * buf , int cnt ) {  int n ;  assert ( cnt >= 0 ) ; assert ( buf ) ; JAS_DBGLOG ( 100 , ( ""mem_read(%p,<S2SV_blank>%p,<S2SV_blank>%d)\\n"" , obj , buf , cnt ) ) ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; n = m -> len_ - m -> pos_ ; cnt = JAS_MIN ( n , cnt ) ; memcpy ( buf , & m -> buf_ [ m -> pos_ ] , cnt ) ; m -> pos_ += cnt ; return cnt ; }",ssize_t n ;assert ( cnt >= 0 ) ;,2231
103,"buggy line: # define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\\cwe id:CWE-125context: static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\n"" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005  # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }   # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }  typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , ""exif:InteroperabilityIndex"" } , { 0x002 , ""exif:InteroperabilityVersion"" } , { 0x100 , ""exif:ImageWidth"" } , { 0x101 , ""exif:ImageLength"" } , { 0x102 , ""exif:BitsPerSample"" } , { 0x103 , ""exif:Compression"" } , { 0x106 , ""exif:PhotometricInterpretation"" } , { 0x10a , ""exif:FillOrder"" } , { 0x10d , ""exif:DocumentName"" } , { 0x10e , ""exif:ImageDescription"" } , { 0x10f , ""exif:Make"" } , { 0x110 , ""exif:Model"" } , { 0x111 , ""exif:StripOffsets"" } , { 0x112 , ""exif:Orientation"" } , { 0x115 , ""exif:SamplesPerPixel"" } , { 0x116 , ""exif:RowsPerStrip"" } , { 0x117 , ""exif:StripByteCounts"" } , { 0x11a , ""exif:XResolution"" } , { 0x11b , ""exif:YResolution"" } , { 0x11c , ""exif:PlanarConfiguration"" } , { 0x11d , ""exif:PageName"" } , { 0x11e , ""exif:XPosition"" } , { 0x11f , ""exif:YPosition"" } , { 0x118 , ""exif:MinSampleValue"" } , { 0x119 , ""exif:MaxSampleValue"" } , { 0x120 , ""exif:FreeOffsets"" } , { 0x121 , ""exif:FreeByteCounts"" } , { 0x122 , ""exif:GrayResponseUnit"" } , { 0x123 , ""exif:GrayResponseCurve"" } , { 0x124 , ""exif:T4Options"" } , { 0x125 , ""exif:T6Options"" } , { 0x128 , ""exif:ResolutionUnit"" } , { 0x12d , ""exif:TransferFunction"" } , { 0x131 , ""exif:Software"" } , { 0x132 , ""exif:DateTime"" } , { 0x13b , ""exif:Artist"" } , { 0x13e , ""exif:WhitePoint"" } , { 0x13f , ""exif:PrimaryChromaticities"" } , { 0x140 , ""exif:ColorMap"" } , { 0x141 , ""exif:HalfToneHints"" } , { 0x142 , ""exif:TileWidth"" } , { 0x143 , ""exif:TileLength"" } , { 0x144 , ""exif:TileOffsets"" } , { 0x145 , ""exif:TileByteCounts"" } , { 0x14a , ""exif:SubIFD"" } , { 0x14c , ""exif:InkSet"" } , { 0x14d , ""exif:InkNames"" } , { 0x14e , ""exif:NumberOfInks"" } , { 0x150 , ""exif:DotRange"" } , { 0x151 , ""exif:TargetPrinter"" } , { 0x152 , ""exif:ExtraSample"" } , { 0x153 , ""exif:SampleFormat"" } , { 0x154 , ""exif:SMinSampleValue"" } , { 0x155 , ""exif:SMaxSampleValue"" } , { 0x156 , ""exif:TransferRange"" } , { 0x157 , ""exif:ClipPath"" } , { 0x158 , ""exif:XClipPathUnits"" } , { 0x159 , ""exif:YClipPathUnits"" } , { 0x15a , ""exif:Indexed"" } , { 0x15b , ""exif:JPEGTables"" } , { 0x15f , ""exif:OPIProxy"" } , { 0x200 , ""exif:JPEGProc"" } , { 0x201 , ""exif:JPEGInterchangeFormat"" } , { 0x202 , ""exif:JPEGInterchangeFormatLength"" } , { 0x203 , ""exif:JPEGRestartInterval"" } , { 0x205 , ""exif:JPEGLosslessPredictors"" } , { 0x206 , ""exif:JPEGPointTransforms"" } , { 0x207 , ""exif:JPEGQTables"" } , { 0x208 , ""exif:JPEGDCTables"" } , { 0x209 , ""exif:JPEGACTables"" } , { 0x211 , ""exif:YCbCrCoefficients"" } , { 0x212 , ""exif:YCbCrSubSampling"" } , { 0x213 , ""exif:YCbCrPositioning"" } , { 0x214 , ""exif:ReferenceBlackWhite"" } , { 0x2bc , ""exif:ExtensibleMetadataPlatform"" } , { 0x301 , ""exif:Gamma"" } , { 0x302 , ""exif:ICCProfileDescriptor"" } , { 0x303 , ""exif:SRGBRenderingIntent"" } , { 0x320 , ""exif:ImageTitle"" } , { 0x5001 , ""exif:ResolutionXUnit"" } , { 0x5002 , ""exif:ResolutionYUnit"" } , { 0x5003 , ""exif:ResolutionXLengthUnit"" } , { 0x5004 , ""exif:ResolutionYLengthUnit"" } , { 0x5005 , ""exif:PrintFlags"" } , { 0x5006 , ""exif:PrintFlagsVersion"" } , { 0x5007 , ""exif:PrintFlagsCrop"" } , { 0x5008 , ""exif:PrintFlagsBleedWidth"" } , { 0x5009 , ""exif:PrintFlagsBleedWidthScale"" } , { 0x500A , ""exif:HalftoneLPI"" } , { 0x500B , ""exif:HalftoneLPIUnit"" } , { 0x500C , ""exif:HalftoneDegree"" } , { 0x500D , ""exif:HalftoneShape"" } , { 0x500E , ""exif:HalftoneMisc"" } , { 0x500F , ""exif:HalftoneScreen"" } , { 0x5010 , ""exif:JPEGQuality"" } , { 0x5011 , ""exif:GridSize"" } , { 0x5012 , ""exif:ThumbnailFormat"" } , { 0x5013 , ""exif:ThumbnailWidth"" } , { 0x5014 , ""exif:ThumbnailHeight"" } , { 0x5015 , ""exif:ThumbnailColorDepth"" } , { 0x5016 , ""exif:ThumbnailPlanes"" } , { 0x5017 , ""exif:ThumbnailRawBytes"" } , { 0x5018 , ""exif:ThumbnailSize"" } , { 0x5019 , ""exif:ThumbnailCompressedSize"" } , { 0x501a , ""exif:ColorTransferFunction"" } , { 0x501b , ""exif:ThumbnailData"" } , { 0x5020 , ""exif:ThumbnailImageWidth"" } , { 0x5021 , ""exif:ThumbnailImageHeight"" } , { 0x5022 , ""exif:ThumbnailBitsPerSample"" } , { 0x5023 , ""exif:ThumbnailCompression"" } , { 0x5024 , ""exif:ThumbnailPhotometricInterp"" } , { 0x5025 , ""exif:ThumbnailImageDescription"" } , { 0x5026 , ""exif:ThumbnailEquipMake"" } , { 0x5027 , ""exif:ThumbnailEquipModel"" } , { 0x5028 , ""exif:ThumbnailStripOffsets"" } , { 0x5029 , ""exif:ThumbnailOrientation"" } , { 0x502a , ""exif:ThumbnailSamplesPerPixel"" } , { 0x502b , ""exif:ThumbnailRowsPerStrip"" } , { 0x502c , ""exif:ThumbnailStripBytesCount"" } , { 0x502d , ""exif:ThumbnailResolutionX"" } , { 0x502e , ""exif:ThumbnailResolutionY"" } , { 0x502f , ""exif:ThumbnailPlanarConfig"" } , { 0x5030 , ""exif:ThumbnailResolutionUnit"" } , { 0x5031 , ""exif:ThumbnailTransferFunction"" } , { 0x5032 , ""exif:ThumbnailSoftwareUsed"" } , { 0x5033 , ""exif:ThumbnailDateTime"" } , { 0x5034 , ""exif:ThumbnailArtist"" } , { 0x5035 , ""exif:ThumbnailWhitePoint"" } , { 0x5036 , ""exif:ThumbnailPrimaryChromaticities"" } , { 0x5037 , ""exif:ThumbnailYCbCrCoefficients"" } , { 0x5038 , ""exif:ThumbnailYCbCrSubsampling"" } , { 0x5039 , ""exif:ThumbnailYCbCrPositioning"" } , { 0x503A , ""exif:ThumbnailRefBlackWhite"" } , { 0x503B , ""exif:ThumbnailCopyRight"" } , { 0x5090 , ""exif:LuminanceTable"" } , { 0x5091 , ""exif:ChrominanceTable"" } , { 0x5100 , ""exif:FrameDelay"" } , { 0x5101 , ""exif:LoopCount"" } , { 0x5110 , ""exif:PixelUnit"" } , { 0x5111 , ""exif:PixelPerUnitX"" } , { 0x5112 , ""exif:PixelPerUnitY"" } , { 0x5113 , ""exif:PaletteHistogram"" } , { 0x1000 , ""exif:RelatedImageFileFormat"" } , { 0x1001 , ""exif:RelatedImageLength"" } , { 0x1002 , ""exif:RelatedImageWidth"" } , { 0x800d , ""exif:ImageID"" } , { 0x80e3 , ""exif:Matteing"" } , { 0x80e4 , ""exif:DataType"" } , { 0x80e5 , ""exif:ImageDepth"" } , { 0x80e6 , ""exif:TileDepth"" } , { 0x828d , ""exif:CFARepeatPatternDim"" } , { 0x828e , ""exif:CFAPattern2"" } , { 0x828f , ""exif:BatteryLevel"" } , { 0x8298 , ""exif:Copyright"" } , { 0x829a , ""exif:ExposureTime"" } , { 0x829d , ""exif:FNumber"" } , { 0x83bb , ""exif:IPTC/NAA"" } , { 0x84e3 , ""exif:IT8RasterPadding"" } , { 0x84e5 , ""exif:IT8ColorTable"" } , { 0x8649 , ""exif:ImageResourceInformation"" } , { 0x8769 , ""exif:ExifOffset"" } , { 0x8773 , ""exif:InterColorProfile"" } , { 0x8822 , ""exif:ExposureProgram"" } , { 0x8824 , ""exif:SpectralSensitivity"" } , { 0x8825 , ""exif:GPSInfo"" } , { 0x8827 , ""exif:ISOSpeedRatings"" } , { 0x8828 , ""exif:OECF"" } , { 0x8829 , ""exif:Interlace"" } , { 0x882a , ""exif:TimeZoneOffset"" } , { 0x882b , ""exif:SelfTimerMode"" } , { 0x9000 , ""exif:ExifVersion"" } , { 0x9003 , ""exif:DateTimeOriginal"" } , { 0x9004 , ""exif:DateTimeDigitized"" } , { 0x9101 , ""exif:ComponentsConfiguration"" } , { 0x9102 , ""exif:CompressedBitsPerPixel"" } , { 0x9201 , ""exif:ShutterSpeedValue"" } , { 0x9202 , ""exif:ApertureValue"" } , { 0x9203 , ""exif:BrightnessValue"" } , { 0x9204 , ""exif:ExposureBiasValue"" } , { 0x9205 , ""exif:MaxApertureValue"" } , { 0x9206 , ""exif:SubjectDistance"" } , { 0x9207 , ""exif:MeteringMode"" } , { 0x9208 , ""exif:LightSource"" } , { 0x9209 , ""exif:Flash"" } , { 0x920a , ""exif:FocalLength"" } , { 0x920b , ""exif:FlashEnergy"" } , { 0x920c , ""exif:SpatialFrequencyResponse"" } , { 0x920d , ""exif:Noise"" } , { 0x9211 , ""exif:ImageNumber"" } , { 0x9212 , ""exif:SecurityClassification"" } , { 0x9213 , ""exif:ImageHistory"" } , { 0x9214 , ""exif:SubjectArea"" } , { 0x9215 , ""exif:ExposureIndex"" } , { 0x9216 , ""exif:TIFF-EPStandardID"" } , { 0x927c , ""exif:MakerNote"" } , { 0x9C9b , ""exif:WinXP-Title"" } , { 0x9C9c , ""exif:WinXP-Comments"" } , { 0x9C9d , ""exif:WinXP-Author"" } , { 0x9C9e , ""exif:WinXP-Keywords"" } , { 0x9C9f , ""exif:WinXP-Subject"" } , { 0x9286 , ""exif:UserComment"" } , { 0x9290 , ""exif:SubSecTime"" } , { 0x9291 , ""exif:SubSecTimeOriginal"" } , { 0x9292 , ""exif:SubSecTimeDigitized"" } , { 0xa000 , ""exif:FlashPixVersion"" } , { 0xa001 , ""exif:ColorSpace"" } , { 0xa002 , ""exif:ExifImageWidth"" } , { 0xa003 , ""exif:ExifImageLength"" } , { 0xa004 , ""exif:RelatedSoundFile"" } , { 0xa005 , ""exif:InteroperabilityOffset"" } , { 0xa20b , ""exif:FlashEnergy"" } , { 0xa20c , ""exif:SpatialFrequencyResponse"" } , { 0xa20d , ""exif:Noise"" } , { 0xa20e , ""exif:FocalPlaneXResolution"" } , { 0xa20f , ""exif:FocalPlaneYResolution"" } , { 0xa210 , ""exif:FocalPlaneResolutionUnit"" } , { 0xa214 , ""exif:SubjectLocation"" } , { 0xa215 , ""exif:ExposureIndex"" } , { 0xa216 , ""exif:TIFF/EPStandardID"" } , { 0xa217 , ""exif:SensingMethod"" } , { 0xa300 , ""exif:FileSource"" } , { 0xa301 , ""exif:SceneType"" } , { 0xa302 , ""exif:CFAPattern"" } , { 0xa401 , ""exif:CustomRendered"" } , { 0xa402 , ""exif:ExposureMode"" } , { 0xa403 , ""exif:WhiteBalance"" } , { 0xa404 , ""exif:DigitalZoomRatio"" } , { 0xa405 , ""exif:FocalLengthIn35mmFilm"" } , { 0xa406 , ""exif:SceneCaptureType"" } , { 0xa407 , ""exif:GainControl"" } , { 0xa408 , ""exif:Contrast"" } , { 0xa409 , ""exif:Saturation"" } , { 0xa40a , ""exif:Sharpness"" } , { 0xa40b , ""exif:DeviceSettingDescription"" } , { 0xa40c , ""exif:SubjectDistanceRange"" } , { 0xa420 , ""exif:ImageUniqueID"" } , { 0xc4a5 , ""exif:PrintImageMatching"" } , { 0xa500 , ""exif:Gamma"" } , { 0xc640 , ""exif:CR2Slice"" } , { 0x10000 , ""exif:GPSVersionID"" } , { 0x10001 , ""exif:GPSLatitudeRef"" } , { 0x10002 , ""exif:GPSLatitude"" } , { 0x10003 , ""exif:GPSLongitudeRef"" } , { 0x10004 , ""exif:GPSLongitude"" } , { 0x10005 , ""exif:GPSAltitudeRef"" } , { 0x10006 , ""exif:GPSAltitude"" } , { 0x10007 , ""exif:GPSTimeStamp"" } , { 0x10008 , ""exif:GPSSatellites"" } , { 0x10009 , ""exif:GPSStatus"" } , { 0x1000a , ""exif:GPSMeasureMode"" } , { 0x1000b , ""exif:GPSDop"" } , { 0x1000c , ""exif:GPSSpeedRef"" } , { 0x1000d , ""exif:GPSSpeed"" } , { 0x1000e , ""exif:GPSTrackRef"" } , { 0x1000f , ""exif:GPSTrack"" } , { 0x10010 , ""exif:GPSImgDirectionRef"" } , { 0x10011 , ""exif:GPSImgDirection"" } , { 0x10012 , ""exif:GPSMapDatum"" } , { 0x10013 , ""exif:GPSDestLatitudeRef"" } , { 0x10014 , ""exif:GPSDestLatitude"" } , { 0x10015 , ""exif:GPSDestLongitudeRef"" } , { 0x10016 , ""exif:GPSDestLongitude"" } , { 0x10017 , ""exif:GPSDestBearingRef"" } , { 0x10018 , ""exif:GPSDestBearing"" } , { 0x10019 , ""exif:GPSDestDistanceRef"" } , { 0x1001a , ""exif:GPSDestDistance"" } , { 0x1001b , ""exif:GPSProcessingMethod"" } , { 0x1001c , ""exif:GPSAreaInformation"" } , { 0x1001d , ""exif:GPSDateStamp"" } , { 0x1001e , ""exif:GPSDifferential"" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , ""exif"" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ;  if ( GetValueFromSplayTree ( exif_resources , q ) == q )  break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ;  components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;  number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , ""%hd"" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , ""%hu"" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , ""%f"" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , ""%f"" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = ""unknown"" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , ""%s"" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""#%04lx"" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""@%04lx"" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , ""unknown"" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }","# define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\\",2232
104,"buggy line: }# define EXIFMultipleFractions ( size , format , arg1 , arg2 ) {cwe id:CWE-125context: static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\n"" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005  # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }   # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }  typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , ""exif:InteroperabilityIndex"" } , { 0x002 , ""exif:InteroperabilityVersion"" } , { 0x100 , ""exif:ImageWidth"" } , { 0x101 , ""exif:ImageLength"" } , { 0x102 , ""exif:BitsPerSample"" } , { 0x103 , ""exif:Compression"" } , { 0x106 , ""exif:PhotometricInterpretation"" } , { 0x10a , ""exif:FillOrder"" } , { 0x10d , ""exif:DocumentName"" } , { 0x10e , ""exif:ImageDescription"" } , { 0x10f , ""exif:Make"" } , { 0x110 , ""exif:Model"" } , { 0x111 , ""exif:StripOffsets"" } , { 0x112 , ""exif:Orientation"" } , { 0x115 , ""exif:SamplesPerPixel"" } , { 0x116 , ""exif:RowsPerStrip"" } , { 0x117 , ""exif:StripByteCounts"" } , { 0x11a , ""exif:XResolution"" } , { 0x11b , ""exif:YResolution"" } , { 0x11c , ""exif:PlanarConfiguration"" } , { 0x11d , ""exif:PageName"" } , { 0x11e , ""exif:XPosition"" } , { 0x11f , ""exif:YPosition"" } , { 0x118 , ""exif:MinSampleValue"" } , { 0x119 , ""exif:MaxSampleValue"" } , { 0x120 , ""exif:FreeOffsets"" } , { 0x121 , ""exif:FreeByteCounts"" } , { 0x122 , ""exif:GrayResponseUnit"" } , { 0x123 , ""exif:GrayResponseCurve"" } , { 0x124 , ""exif:T4Options"" } , { 0x125 , ""exif:T6Options"" } , { 0x128 , ""exif:ResolutionUnit"" } , { 0x12d , ""exif:TransferFunction"" } , { 0x131 , ""exif:Software"" } , { 0x132 , ""exif:DateTime"" } , { 0x13b , ""exif:Artist"" } , { 0x13e , ""exif:WhitePoint"" } , { 0x13f , ""exif:PrimaryChromaticities"" } , { 0x140 , ""exif:ColorMap"" } , { 0x141 , ""exif:HalfToneHints"" } , { 0x142 , ""exif:TileWidth"" } , { 0x143 , ""exif:TileLength"" } , { 0x144 , ""exif:TileOffsets"" } , { 0x145 , ""exif:TileByteCounts"" } , { 0x14a , ""exif:SubIFD"" } , { 0x14c , ""exif:InkSet"" } , { 0x14d , ""exif:InkNames"" } , { 0x14e , ""exif:NumberOfInks"" } , { 0x150 , ""exif:DotRange"" } , { 0x151 , ""exif:TargetPrinter"" } , { 0x152 , ""exif:ExtraSample"" } , { 0x153 , ""exif:SampleFormat"" } , { 0x154 , ""exif:SMinSampleValue"" } , { 0x155 , ""exif:SMaxSampleValue"" } , { 0x156 , ""exif:TransferRange"" } , { 0x157 , ""exif:ClipPath"" } , { 0x158 , ""exif:XClipPathUnits"" } , { 0x159 , ""exif:YClipPathUnits"" } , { 0x15a , ""exif:Indexed"" } , { 0x15b , ""exif:JPEGTables"" } , { 0x15f , ""exif:OPIProxy"" } , { 0x200 , ""exif:JPEGProc"" } , { 0x201 , ""exif:JPEGInterchangeFormat"" } , { 0x202 , ""exif:JPEGInterchangeFormatLength"" } , { 0x203 , ""exif:JPEGRestartInterval"" } , { 0x205 , ""exif:JPEGLosslessPredictors"" } , { 0x206 , ""exif:JPEGPointTransforms"" } , { 0x207 , ""exif:JPEGQTables"" } , { 0x208 , ""exif:JPEGDCTables"" } , { 0x209 , ""exif:JPEGACTables"" } , { 0x211 , ""exif:YCbCrCoefficients"" } , { 0x212 , ""exif:YCbCrSubSampling"" } , { 0x213 , ""exif:YCbCrPositioning"" } , { 0x214 , ""exif:ReferenceBlackWhite"" } , { 0x2bc , ""exif:ExtensibleMetadataPlatform"" } , { 0x301 , ""exif:Gamma"" } , { 0x302 , ""exif:ICCProfileDescriptor"" } , { 0x303 , ""exif:SRGBRenderingIntent"" } , { 0x320 , ""exif:ImageTitle"" } , { 0x5001 , ""exif:ResolutionXUnit"" } , { 0x5002 , ""exif:ResolutionYUnit"" } , { 0x5003 , ""exif:ResolutionXLengthUnit"" } , { 0x5004 , ""exif:ResolutionYLengthUnit"" } , { 0x5005 , ""exif:PrintFlags"" } , { 0x5006 , ""exif:PrintFlagsVersion"" } , { 0x5007 , ""exif:PrintFlagsCrop"" } , { 0x5008 , ""exif:PrintFlagsBleedWidth"" } , { 0x5009 , ""exif:PrintFlagsBleedWidthScale"" } , { 0x500A , ""exif:HalftoneLPI"" } , { 0x500B , ""exif:HalftoneLPIUnit"" } , { 0x500C , ""exif:HalftoneDegree"" } , { 0x500D , ""exif:HalftoneShape"" } , { 0x500E , ""exif:HalftoneMisc"" } , { 0x500F , ""exif:HalftoneScreen"" } , { 0x5010 , ""exif:JPEGQuality"" } , { 0x5011 , ""exif:GridSize"" } , { 0x5012 , ""exif:ThumbnailFormat"" } , { 0x5013 , ""exif:ThumbnailWidth"" } , { 0x5014 , ""exif:ThumbnailHeight"" } , { 0x5015 , ""exif:ThumbnailColorDepth"" } , { 0x5016 , ""exif:ThumbnailPlanes"" } , { 0x5017 , ""exif:ThumbnailRawBytes"" } , { 0x5018 , ""exif:ThumbnailSize"" } , { 0x5019 , ""exif:ThumbnailCompressedSize"" } , { 0x501a , ""exif:ColorTransferFunction"" } , { 0x501b , ""exif:ThumbnailData"" } , { 0x5020 , ""exif:ThumbnailImageWidth"" } , { 0x5021 , ""exif:ThumbnailImageHeight"" } , { 0x5022 , ""exif:ThumbnailBitsPerSample"" } , { 0x5023 , ""exif:ThumbnailCompression"" } , { 0x5024 , ""exif:ThumbnailPhotometricInterp"" } , { 0x5025 , ""exif:ThumbnailImageDescription"" } , { 0x5026 , ""exif:ThumbnailEquipMake"" } , { 0x5027 , ""exif:ThumbnailEquipModel"" } , { 0x5028 , ""exif:ThumbnailStripOffsets"" } , { 0x5029 , ""exif:ThumbnailOrientation"" } , { 0x502a , ""exif:ThumbnailSamplesPerPixel"" } , { 0x502b , ""exif:ThumbnailRowsPerStrip"" } , { 0x502c , ""exif:ThumbnailStripBytesCount"" } , { 0x502d , ""exif:ThumbnailResolutionX"" } , { 0x502e , ""exif:ThumbnailResolutionY"" } , { 0x502f , ""exif:ThumbnailPlanarConfig"" } , { 0x5030 , ""exif:ThumbnailResolutionUnit"" } , { 0x5031 , ""exif:ThumbnailTransferFunction"" } , { 0x5032 , ""exif:ThumbnailSoftwareUsed"" } , { 0x5033 , ""exif:ThumbnailDateTime"" } , { 0x5034 , ""exif:ThumbnailArtist"" } , { 0x5035 , ""exif:ThumbnailWhitePoint"" } , { 0x5036 , ""exif:ThumbnailPrimaryChromaticities"" } , { 0x5037 , ""exif:ThumbnailYCbCrCoefficients"" } , { 0x5038 , ""exif:ThumbnailYCbCrSubsampling"" } , { 0x5039 , ""exif:ThumbnailYCbCrPositioning"" } , { 0x503A , ""exif:ThumbnailRefBlackWhite"" } , { 0x503B , ""exif:ThumbnailCopyRight"" } , { 0x5090 , ""exif:LuminanceTable"" } , { 0x5091 , ""exif:ChrominanceTable"" } , { 0x5100 , ""exif:FrameDelay"" } , { 0x5101 , ""exif:LoopCount"" } , { 0x5110 , ""exif:PixelUnit"" } , { 0x5111 , ""exif:PixelPerUnitX"" } , { 0x5112 , ""exif:PixelPerUnitY"" } , { 0x5113 , ""exif:PaletteHistogram"" } , { 0x1000 , ""exif:RelatedImageFileFormat"" } , { 0x1001 , ""exif:RelatedImageLength"" } , { 0x1002 , ""exif:RelatedImageWidth"" } , { 0x800d , ""exif:ImageID"" } , { 0x80e3 , ""exif:Matteing"" } , { 0x80e4 , ""exif:DataType"" } , { 0x80e5 , ""exif:ImageDepth"" } , { 0x80e6 , ""exif:TileDepth"" } , { 0x828d , ""exif:CFARepeatPatternDim"" } , { 0x828e , ""exif:CFAPattern2"" } , { 0x828f , ""exif:BatteryLevel"" } , { 0x8298 , ""exif:Copyright"" } , { 0x829a , ""exif:ExposureTime"" } , { 0x829d , ""exif:FNumber"" } , { 0x83bb , ""exif:IPTC/NAA"" } , { 0x84e3 , ""exif:IT8RasterPadding"" } , { 0x84e5 , ""exif:IT8ColorTable"" } , { 0x8649 , ""exif:ImageResourceInformation"" } , { 0x8769 , ""exif:ExifOffset"" } , { 0x8773 , ""exif:InterColorProfile"" } , { 0x8822 , ""exif:ExposureProgram"" } , { 0x8824 , ""exif:SpectralSensitivity"" } , { 0x8825 , ""exif:GPSInfo"" } , { 0x8827 , ""exif:ISOSpeedRatings"" } , { 0x8828 , ""exif:OECF"" } , { 0x8829 , ""exif:Interlace"" } , { 0x882a , ""exif:TimeZoneOffset"" } , { 0x882b , ""exif:SelfTimerMode"" } , { 0x9000 , ""exif:ExifVersion"" } , { 0x9003 , ""exif:DateTimeOriginal"" } , { 0x9004 , ""exif:DateTimeDigitized"" } , { 0x9101 , ""exif:ComponentsConfiguration"" } , { 0x9102 , ""exif:CompressedBitsPerPixel"" } , { 0x9201 , ""exif:ShutterSpeedValue"" } , { 0x9202 , ""exif:ApertureValue"" } , { 0x9203 , ""exif:BrightnessValue"" } , { 0x9204 , ""exif:ExposureBiasValue"" } , { 0x9205 , ""exif:MaxApertureValue"" } , { 0x9206 , ""exif:SubjectDistance"" } , { 0x9207 , ""exif:MeteringMode"" } , { 0x9208 , ""exif:LightSource"" } , { 0x9209 , ""exif:Flash"" } , { 0x920a , ""exif:FocalLength"" } , { 0x920b , ""exif:FlashEnergy"" } , { 0x920c , ""exif:SpatialFrequencyResponse"" } , { 0x920d , ""exif:Noise"" } , { 0x9211 , ""exif:ImageNumber"" } , { 0x9212 , ""exif:SecurityClassification"" } , { 0x9213 , ""exif:ImageHistory"" } , { 0x9214 , ""exif:SubjectArea"" } , { 0x9215 , ""exif:ExposureIndex"" } , { 0x9216 , ""exif:TIFF-EPStandardID"" } , { 0x927c , ""exif:MakerNote"" } , { 0x9C9b , ""exif:WinXP-Title"" } , { 0x9C9c , ""exif:WinXP-Comments"" } , { 0x9C9d , ""exif:WinXP-Author"" } , { 0x9C9e , ""exif:WinXP-Keywords"" } , { 0x9C9f , ""exif:WinXP-Subject"" } , { 0x9286 , ""exif:UserComment"" } , { 0x9290 , ""exif:SubSecTime"" } , { 0x9291 , ""exif:SubSecTimeOriginal"" } , { 0x9292 , ""exif:SubSecTimeDigitized"" } , { 0xa000 , ""exif:FlashPixVersion"" } , { 0xa001 , ""exif:ColorSpace"" } , { 0xa002 , ""exif:ExifImageWidth"" } , { 0xa003 , ""exif:ExifImageLength"" } , { 0xa004 , ""exif:RelatedSoundFile"" } , { 0xa005 , ""exif:InteroperabilityOffset"" } , { 0xa20b , ""exif:FlashEnergy"" } , { 0xa20c , ""exif:SpatialFrequencyResponse"" } , { 0xa20d , ""exif:Noise"" } , { 0xa20e , ""exif:FocalPlaneXResolution"" } , { 0xa20f , ""exif:FocalPlaneYResolution"" } , { 0xa210 , ""exif:FocalPlaneResolutionUnit"" } , { 0xa214 , ""exif:SubjectLocation"" } , { 0xa215 , ""exif:ExposureIndex"" } , { 0xa216 , ""exif:TIFF/EPStandardID"" } , { 0xa217 , ""exif:SensingMethod"" } , { 0xa300 , ""exif:FileSource"" } , { 0xa301 , ""exif:SceneType"" } , { 0xa302 , ""exif:CFAPattern"" } , { 0xa401 , ""exif:CustomRendered"" } , { 0xa402 , ""exif:ExposureMode"" } , { 0xa403 , ""exif:WhiteBalance"" } , { 0xa404 , ""exif:DigitalZoomRatio"" } , { 0xa405 , ""exif:FocalLengthIn35mmFilm"" } , { 0xa406 , ""exif:SceneCaptureType"" } , { 0xa407 , ""exif:GainControl"" } , { 0xa408 , ""exif:Contrast"" } , { 0xa409 , ""exif:Saturation"" } , { 0xa40a , ""exif:Sharpness"" } , { 0xa40b , ""exif:DeviceSettingDescription"" } , { 0xa40c , ""exif:SubjectDistanceRange"" } , { 0xa420 , ""exif:ImageUniqueID"" } , { 0xc4a5 , ""exif:PrintImageMatching"" } , { 0xa500 , ""exif:Gamma"" } , { 0xc640 , ""exif:CR2Slice"" } , { 0x10000 , ""exif:GPSVersionID"" } , { 0x10001 , ""exif:GPSLatitudeRef"" } , { 0x10002 , ""exif:GPSLatitude"" } , { 0x10003 , ""exif:GPSLongitudeRef"" } , { 0x10004 , ""exif:GPSLongitude"" } , { 0x10005 , ""exif:GPSAltitudeRef"" } , { 0x10006 , ""exif:GPSAltitude"" } , { 0x10007 , ""exif:GPSTimeStamp"" } , { 0x10008 , ""exif:GPSSatellites"" } , { 0x10009 , ""exif:GPSStatus"" } , { 0x1000a , ""exif:GPSMeasureMode"" } , { 0x1000b , ""exif:GPSDop"" } , { 0x1000c , ""exif:GPSSpeedRef"" } , { 0x1000d , ""exif:GPSSpeed"" } , { 0x1000e , ""exif:GPSTrackRef"" } , { 0x1000f , ""exif:GPSTrack"" } , { 0x10010 , ""exif:GPSImgDirectionRef"" } , { 0x10011 , ""exif:GPSImgDirection"" } , { 0x10012 , ""exif:GPSMapDatum"" } , { 0x10013 , ""exif:GPSDestLatitudeRef"" } , { 0x10014 , ""exif:GPSDestLatitude"" } , { 0x10015 , ""exif:GPSDestLongitudeRef"" } , { 0x10016 , ""exif:GPSDestLongitude"" } , { 0x10017 , ""exif:GPSDestBearingRef"" } , { 0x10018 , ""exif:GPSDestBearing"" } , { 0x10019 , ""exif:GPSDestDistanceRef"" } , { 0x1001a , ""exif:GPSDestDistance"" } , { 0x1001b , ""exif:GPSProcessingMethod"" } , { 0x1001c , ""exif:GPSAreaInformation"" } , { 0x1001d , ""exif:GPSDateStamp"" } , { 0x1001e , ""exif:GPSDifferential"" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , ""exif"" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ;  if ( GetValueFromSplayTree ( exif_resources , q ) == q )  break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ;  components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;  number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , ""%hd"" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , ""%hu"" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , ""%f"" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , ""%f"" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = ""unknown"" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , ""%s"" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""#%04lx"" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""@%04lx"" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , ""unknown"" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }","\\\\\# define EXIFMultipleFractions ( size , format , arg1 , arg2 ) \\\\\",2232
105,"buggy line: }typedef struct _DirectoryInfo {cwe id:CWE-125context: static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\n"" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005  # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }   # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }  typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , ""exif:InteroperabilityIndex"" } , { 0x002 , ""exif:InteroperabilityVersion"" } , { 0x100 , ""exif:ImageWidth"" } , { 0x101 , ""exif:ImageLength"" } , { 0x102 , ""exif:BitsPerSample"" } , { 0x103 , ""exif:Compression"" } , { 0x106 , ""exif:PhotometricInterpretation"" } , { 0x10a , ""exif:FillOrder"" } , { 0x10d , ""exif:DocumentName"" } , { 0x10e , ""exif:ImageDescription"" } , { 0x10f , ""exif:Make"" } , { 0x110 , ""exif:Model"" } , { 0x111 , ""exif:StripOffsets"" } , { 0x112 , ""exif:Orientation"" } , { 0x115 , ""exif:SamplesPerPixel"" } , { 0x116 , ""exif:RowsPerStrip"" } , { 0x117 , ""exif:StripByteCounts"" } , { 0x11a , ""exif:XResolution"" } , { 0x11b , ""exif:YResolution"" } , { 0x11c , ""exif:PlanarConfiguration"" } , { 0x11d , ""exif:PageName"" } , { 0x11e , ""exif:XPosition"" } , { 0x11f , ""exif:YPosition"" } , { 0x118 , ""exif:MinSampleValue"" } , { 0x119 , ""exif:MaxSampleValue"" } , { 0x120 , ""exif:FreeOffsets"" } , { 0x121 , ""exif:FreeByteCounts"" } , { 0x122 , ""exif:GrayResponseUnit"" } , { 0x123 , ""exif:GrayResponseCurve"" } , { 0x124 , ""exif:T4Options"" } , { 0x125 , ""exif:T6Options"" } , { 0x128 , ""exif:ResolutionUnit"" } , { 0x12d , ""exif:TransferFunction"" } , { 0x131 , ""exif:Software"" } , { 0x132 , ""exif:DateTime"" } , { 0x13b , ""exif:Artist"" } , { 0x13e , ""exif:WhitePoint"" } , { 0x13f , ""exif:PrimaryChromaticities"" } , { 0x140 , ""exif:ColorMap"" } , { 0x141 , ""exif:HalfToneHints"" } , { 0x142 , ""exif:TileWidth"" } , { 0x143 , ""exif:TileLength"" } , { 0x144 , ""exif:TileOffsets"" } , { 0x145 , ""exif:TileByteCounts"" } , { 0x14a , ""exif:SubIFD"" } , { 0x14c , ""exif:InkSet"" } , { 0x14d , ""exif:InkNames"" } , { 0x14e , ""exif:NumberOfInks"" } , { 0x150 , ""exif:DotRange"" } , { 0x151 , ""exif:TargetPrinter"" } , { 0x152 , ""exif:ExtraSample"" } , { 0x153 , ""exif:SampleFormat"" } , { 0x154 , ""exif:SMinSampleValue"" } , { 0x155 , ""exif:SMaxSampleValue"" } , { 0x156 , ""exif:TransferRange"" } , { 0x157 , ""exif:ClipPath"" } , { 0x158 , ""exif:XClipPathUnits"" } , { 0x159 , ""exif:YClipPathUnits"" } , { 0x15a , ""exif:Indexed"" } , { 0x15b , ""exif:JPEGTables"" } , { 0x15f , ""exif:OPIProxy"" } , { 0x200 , ""exif:JPEGProc"" } , { 0x201 , ""exif:JPEGInterchangeFormat"" } , { 0x202 , ""exif:JPEGInterchangeFormatLength"" } , { 0x203 , ""exif:JPEGRestartInterval"" } , { 0x205 , ""exif:JPEGLosslessPredictors"" } , { 0x206 , ""exif:JPEGPointTransforms"" } , { 0x207 , ""exif:JPEGQTables"" } , { 0x208 , ""exif:JPEGDCTables"" } , { 0x209 , ""exif:JPEGACTables"" } , { 0x211 , ""exif:YCbCrCoefficients"" } , { 0x212 , ""exif:YCbCrSubSampling"" } , { 0x213 , ""exif:YCbCrPositioning"" } , { 0x214 , ""exif:ReferenceBlackWhite"" } , { 0x2bc , ""exif:ExtensibleMetadataPlatform"" } , { 0x301 , ""exif:Gamma"" } , { 0x302 , ""exif:ICCProfileDescriptor"" } , { 0x303 , ""exif:SRGBRenderingIntent"" } , { 0x320 , ""exif:ImageTitle"" } , { 0x5001 , ""exif:ResolutionXUnit"" } , { 0x5002 , ""exif:ResolutionYUnit"" } , { 0x5003 , ""exif:ResolutionXLengthUnit"" } , { 0x5004 , ""exif:ResolutionYLengthUnit"" } , { 0x5005 , ""exif:PrintFlags"" } , { 0x5006 , ""exif:PrintFlagsVersion"" } , { 0x5007 , ""exif:PrintFlagsCrop"" } , { 0x5008 , ""exif:PrintFlagsBleedWidth"" } , { 0x5009 , ""exif:PrintFlagsBleedWidthScale"" } , { 0x500A , ""exif:HalftoneLPI"" } , { 0x500B , ""exif:HalftoneLPIUnit"" } , { 0x500C , ""exif:HalftoneDegree"" } , { 0x500D , ""exif:HalftoneShape"" } , { 0x500E , ""exif:HalftoneMisc"" } , { 0x500F , ""exif:HalftoneScreen"" } , { 0x5010 , ""exif:JPEGQuality"" } , { 0x5011 , ""exif:GridSize"" } , { 0x5012 , ""exif:ThumbnailFormat"" } , { 0x5013 , ""exif:ThumbnailWidth"" } , { 0x5014 , ""exif:ThumbnailHeight"" } , { 0x5015 , ""exif:ThumbnailColorDepth"" } , { 0x5016 , ""exif:ThumbnailPlanes"" } , { 0x5017 , ""exif:ThumbnailRawBytes"" } , { 0x5018 , ""exif:ThumbnailSize"" } , { 0x5019 , ""exif:ThumbnailCompressedSize"" } , { 0x501a , ""exif:ColorTransferFunction"" } , { 0x501b , ""exif:ThumbnailData"" } , { 0x5020 , ""exif:ThumbnailImageWidth"" } , { 0x5021 , ""exif:ThumbnailImageHeight"" } , { 0x5022 , ""exif:ThumbnailBitsPerSample"" } , { 0x5023 , ""exif:ThumbnailCompression"" } , { 0x5024 , ""exif:ThumbnailPhotometricInterp"" } , { 0x5025 , ""exif:ThumbnailImageDescription"" } , { 0x5026 , ""exif:ThumbnailEquipMake"" } , { 0x5027 , ""exif:ThumbnailEquipModel"" } , { 0x5028 , ""exif:ThumbnailStripOffsets"" } , { 0x5029 , ""exif:ThumbnailOrientation"" } , { 0x502a , ""exif:ThumbnailSamplesPerPixel"" } , { 0x502b , ""exif:ThumbnailRowsPerStrip"" } , { 0x502c , ""exif:ThumbnailStripBytesCount"" } , { 0x502d , ""exif:ThumbnailResolutionX"" } , { 0x502e , ""exif:ThumbnailResolutionY"" } , { 0x502f , ""exif:ThumbnailPlanarConfig"" } , { 0x5030 , ""exif:ThumbnailResolutionUnit"" } , { 0x5031 , ""exif:ThumbnailTransferFunction"" } , { 0x5032 , ""exif:ThumbnailSoftwareUsed"" } , { 0x5033 , ""exif:ThumbnailDateTime"" } , { 0x5034 , ""exif:ThumbnailArtist"" } , { 0x5035 , ""exif:ThumbnailWhitePoint"" } , { 0x5036 , ""exif:ThumbnailPrimaryChromaticities"" } , { 0x5037 , ""exif:ThumbnailYCbCrCoefficients"" } , { 0x5038 , ""exif:ThumbnailYCbCrSubsampling"" } , { 0x5039 , ""exif:ThumbnailYCbCrPositioning"" } , { 0x503A , ""exif:ThumbnailRefBlackWhite"" } , { 0x503B , ""exif:ThumbnailCopyRight"" } , { 0x5090 , ""exif:LuminanceTable"" } , { 0x5091 , ""exif:ChrominanceTable"" } , { 0x5100 , ""exif:FrameDelay"" } , { 0x5101 , ""exif:LoopCount"" } , { 0x5110 , ""exif:PixelUnit"" } , { 0x5111 , ""exif:PixelPerUnitX"" } , { 0x5112 , ""exif:PixelPerUnitY"" } , { 0x5113 , ""exif:PaletteHistogram"" } , { 0x1000 , ""exif:RelatedImageFileFormat"" } , { 0x1001 , ""exif:RelatedImageLength"" } , { 0x1002 , ""exif:RelatedImageWidth"" } , { 0x800d , ""exif:ImageID"" } , { 0x80e3 , ""exif:Matteing"" } , { 0x80e4 , ""exif:DataType"" } , { 0x80e5 , ""exif:ImageDepth"" } , { 0x80e6 , ""exif:TileDepth"" } , { 0x828d , ""exif:CFARepeatPatternDim"" } , { 0x828e , ""exif:CFAPattern2"" } , { 0x828f , ""exif:BatteryLevel"" } , { 0x8298 , ""exif:Copyright"" } , { 0x829a , ""exif:ExposureTime"" } , { 0x829d , ""exif:FNumber"" } , { 0x83bb , ""exif:IPTC/NAA"" } , { 0x84e3 , ""exif:IT8RasterPadding"" } , { 0x84e5 , ""exif:IT8ColorTable"" } , { 0x8649 , ""exif:ImageResourceInformation"" } , { 0x8769 , ""exif:ExifOffset"" } , { 0x8773 , ""exif:InterColorProfile"" } , { 0x8822 , ""exif:ExposureProgram"" } , { 0x8824 , ""exif:SpectralSensitivity"" } , { 0x8825 , ""exif:GPSInfo"" } , { 0x8827 , ""exif:ISOSpeedRatings"" } , { 0x8828 , ""exif:OECF"" } , { 0x8829 , ""exif:Interlace"" } , { 0x882a , ""exif:TimeZoneOffset"" } , { 0x882b , ""exif:SelfTimerMode"" } , { 0x9000 , ""exif:ExifVersion"" } , { 0x9003 , ""exif:DateTimeOriginal"" } , { 0x9004 , ""exif:DateTimeDigitized"" } , { 0x9101 , ""exif:ComponentsConfiguration"" } , { 0x9102 , ""exif:CompressedBitsPerPixel"" } , { 0x9201 , ""exif:ShutterSpeedValue"" } , { 0x9202 , ""exif:ApertureValue"" } , { 0x9203 , ""exif:BrightnessValue"" } , { 0x9204 , ""exif:ExposureBiasValue"" } , { 0x9205 , ""exif:MaxApertureValue"" } , { 0x9206 , ""exif:SubjectDistance"" } , { 0x9207 , ""exif:MeteringMode"" } , { 0x9208 , ""exif:LightSource"" } , { 0x9209 , ""exif:Flash"" } , { 0x920a , ""exif:FocalLength"" } , { 0x920b , ""exif:FlashEnergy"" } , { 0x920c , ""exif:SpatialFrequencyResponse"" } , { 0x920d , ""exif:Noise"" } , { 0x9211 , ""exif:ImageNumber"" } , { 0x9212 , ""exif:SecurityClassification"" } , { 0x9213 , ""exif:ImageHistory"" } , { 0x9214 , ""exif:SubjectArea"" } , { 0x9215 , ""exif:ExposureIndex"" } , { 0x9216 , ""exif:TIFF-EPStandardID"" } , { 0x927c , ""exif:MakerNote"" } , { 0x9C9b , ""exif:WinXP-Title"" } , { 0x9C9c , ""exif:WinXP-Comments"" } , { 0x9C9d , ""exif:WinXP-Author"" } , { 0x9C9e , ""exif:WinXP-Keywords"" } , { 0x9C9f , ""exif:WinXP-Subject"" } , { 0x9286 , ""exif:UserComment"" } , { 0x9290 , ""exif:SubSecTime"" } , { 0x9291 , ""exif:SubSecTimeOriginal"" } , { 0x9292 , ""exif:SubSecTimeDigitized"" } , { 0xa000 , ""exif:FlashPixVersion"" } , { 0xa001 , ""exif:ColorSpace"" } , { 0xa002 , ""exif:ExifImageWidth"" } , { 0xa003 , ""exif:ExifImageLength"" } , { 0xa004 , ""exif:RelatedSoundFile"" } , { 0xa005 , ""exif:InteroperabilityOffset"" } , { 0xa20b , ""exif:FlashEnergy"" } , { 0xa20c , ""exif:SpatialFrequencyResponse"" } , { 0xa20d , ""exif:Noise"" } , { 0xa20e , ""exif:FocalPlaneXResolution"" } , { 0xa20f , ""exif:FocalPlaneYResolution"" } , { 0xa210 , ""exif:FocalPlaneResolutionUnit"" } , { 0xa214 , ""exif:SubjectLocation"" } , { 0xa215 , ""exif:ExposureIndex"" } , { 0xa216 , ""exif:TIFF/EPStandardID"" } , { 0xa217 , ""exif:SensingMethod"" } , { 0xa300 , ""exif:FileSource"" } , { 0xa301 , ""exif:SceneType"" } , { 0xa302 , ""exif:CFAPattern"" } , { 0xa401 , ""exif:CustomRendered"" } , { 0xa402 , ""exif:ExposureMode"" } , { 0xa403 , ""exif:WhiteBalance"" } , { 0xa404 , ""exif:DigitalZoomRatio"" } , { 0xa405 , ""exif:FocalLengthIn35mmFilm"" } , { 0xa406 , ""exif:SceneCaptureType"" } , { 0xa407 , ""exif:GainControl"" } , { 0xa408 , ""exif:Contrast"" } , { 0xa409 , ""exif:Saturation"" } , { 0xa40a , ""exif:Sharpness"" } , { 0xa40b , ""exif:DeviceSettingDescription"" } , { 0xa40c , ""exif:SubjectDistanceRange"" } , { 0xa420 , ""exif:ImageUniqueID"" } , { 0xc4a5 , ""exif:PrintImageMatching"" } , { 0xa500 , ""exif:Gamma"" } , { 0xc640 , ""exif:CR2Slice"" } , { 0x10000 , ""exif:GPSVersionID"" } , { 0x10001 , ""exif:GPSLatitudeRef"" } , { 0x10002 , ""exif:GPSLatitude"" } , { 0x10003 , ""exif:GPSLongitudeRef"" } , { 0x10004 , ""exif:GPSLongitude"" } , { 0x10005 , ""exif:GPSAltitudeRef"" } , { 0x10006 , ""exif:GPSAltitude"" } , { 0x10007 , ""exif:GPSTimeStamp"" } , { 0x10008 , ""exif:GPSSatellites"" } , { 0x10009 , ""exif:GPSStatus"" } , { 0x1000a , ""exif:GPSMeasureMode"" } , { 0x1000b , ""exif:GPSDop"" } , { 0x1000c , ""exif:GPSSpeedRef"" } , { 0x1000d , ""exif:GPSSpeed"" } , { 0x1000e , ""exif:GPSTrackRef"" } , { 0x1000f , ""exif:GPSTrack"" } , { 0x10010 , ""exif:GPSImgDirectionRef"" } , { 0x10011 , ""exif:GPSImgDirection"" } , { 0x10012 , ""exif:GPSMapDatum"" } , { 0x10013 , ""exif:GPSDestLatitudeRef"" } , { 0x10014 , ""exif:GPSDestLatitude"" } , { 0x10015 , ""exif:GPSDestLongitudeRef"" } , { 0x10016 , ""exif:GPSDestLongitude"" } , { 0x10017 , ""exif:GPSDestBearingRef"" } , { 0x10018 , ""exif:GPSDestBearing"" } , { 0x10019 , ""exif:GPSDestDistanceRef"" } , { 0x1001a , ""exif:GPSDestDistance"" } , { 0x1001b , ""exif:GPSProcessingMethod"" } , { 0x1001c , ""exif:GPSAreaInformation"" } , { 0x1001d , ""exif:GPSDateStamp"" } , { 0x1001e , ""exif:GPSDifferential"" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , ""exif"" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ;  if ( GetValueFromSplayTree ( exif_resources , q ) == q )  break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ;  components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;  number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , ""%hd"" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , ""%hu"" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , ""%f"" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , ""%f"" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = ""unknown"" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , ""%s"" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""#%04lx"" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""@%04lx"" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , ""unknown"" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }",\\\\\typedef struct _DirectoryInfo {,2232
106,"buggy line: cwe id:CWE-125context: static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\n"" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005  # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }   # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }  typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , ""exif:InteroperabilityIndex"" } , { 0x002 , ""exif:InteroperabilityVersion"" } , { 0x100 , ""exif:ImageWidth"" } , { 0x101 , ""exif:ImageLength"" } , { 0x102 , ""exif:BitsPerSample"" } , { 0x103 , ""exif:Compression"" } , { 0x106 , ""exif:PhotometricInterpretation"" } , { 0x10a , ""exif:FillOrder"" } , { 0x10d , ""exif:DocumentName"" } , { 0x10e , ""exif:ImageDescription"" } , { 0x10f , ""exif:Make"" } , { 0x110 , ""exif:Model"" } , { 0x111 , ""exif:StripOffsets"" } , { 0x112 , ""exif:Orientation"" } , { 0x115 , ""exif:SamplesPerPixel"" } , { 0x116 , ""exif:RowsPerStrip"" } , { 0x117 , ""exif:StripByteCounts"" } , { 0x11a , ""exif:XResolution"" } , { 0x11b , ""exif:YResolution"" } , { 0x11c , ""exif:PlanarConfiguration"" } , { 0x11d , ""exif:PageName"" } , { 0x11e , ""exif:XPosition"" } , { 0x11f , ""exif:YPosition"" } , { 0x118 , ""exif:MinSampleValue"" } , { 0x119 , ""exif:MaxSampleValue"" } , { 0x120 , ""exif:FreeOffsets"" } , { 0x121 , ""exif:FreeByteCounts"" } , { 0x122 , ""exif:GrayResponseUnit"" } , { 0x123 , ""exif:GrayResponseCurve"" } , { 0x124 , ""exif:T4Options"" } , { 0x125 , ""exif:T6Options"" } , { 0x128 , ""exif:ResolutionUnit"" } , { 0x12d , ""exif:TransferFunction"" } , { 0x131 , ""exif:Software"" } , { 0x132 , ""exif:DateTime"" } , { 0x13b , ""exif:Artist"" } , { 0x13e , ""exif:WhitePoint"" } , { 0x13f , ""exif:PrimaryChromaticities"" } , { 0x140 , ""exif:ColorMap"" } , { 0x141 , ""exif:HalfToneHints"" } , { 0x142 , ""exif:TileWidth"" } , { 0x143 , ""exif:TileLength"" } , { 0x144 , ""exif:TileOffsets"" } , { 0x145 , ""exif:TileByteCounts"" } , { 0x14a , ""exif:SubIFD"" } , { 0x14c , ""exif:InkSet"" } , { 0x14d , ""exif:InkNames"" } , { 0x14e , ""exif:NumberOfInks"" } , { 0x150 , ""exif:DotRange"" } , { 0x151 , ""exif:TargetPrinter"" } , { 0x152 , ""exif:ExtraSample"" } , { 0x153 , ""exif:SampleFormat"" } , { 0x154 , ""exif:SMinSampleValue"" } , { 0x155 , ""exif:SMaxSampleValue"" } , { 0x156 , ""exif:TransferRange"" } , { 0x157 , ""exif:ClipPath"" } , { 0x158 , ""exif:XClipPathUnits"" } , { 0x159 , ""exif:YClipPathUnits"" } , { 0x15a , ""exif:Indexed"" } , { 0x15b , ""exif:JPEGTables"" } , { 0x15f , ""exif:OPIProxy"" } , { 0x200 , ""exif:JPEGProc"" } , { 0x201 , ""exif:JPEGInterchangeFormat"" } , { 0x202 , ""exif:JPEGInterchangeFormatLength"" } , { 0x203 , ""exif:JPEGRestartInterval"" } , { 0x205 , ""exif:JPEGLosslessPredictors"" } , { 0x206 , ""exif:JPEGPointTransforms"" } , { 0x207 , ""exif:JPEGQTables"" } , { 0x208 , ""exif:JPEGDCTables"" } , { 0x209 , ""exif:JPEGACTables"" } , { 0x211 , ""exif:YCbCrCoefficients"" } , { 0x212 , ""exif:YCbCrSubSampling"" } , { 0x213 , ""exif:YCbCrPositioning"" } , { 0x214 , ""exif:ReferenceBlackWhite"" } , { 0x2bc , ""exif:ExtensibleMetadataPlatform"" } , { 0x301 , ""exif:Gamma"" } , { 0x302 , ""exif:ICCProfileDescriptor"" } , { 0x303 , ""exif:SRGBRenderingIntent"" } , { 0x320 , ""exif:ImageTitle"" } , { 0x5001 , ""exif:ResolutionXUnit"" } , { 0x5002 , ""exif:ResolutionYUnit"" } , { 0x5003 , ""exif:ResolutionXLengthUnit"" } , { 0x5004 , ""exif:ResolutionYLengthUnit"" } , { 0x5005 , ""exif:PrintFlags"" } , { 0x5006 , ""exif:PrintFlagsVersion"" } , { 0x5007 , ""exif:PrintFlagsCrop"" } , { 0x5008 , ""exif:PrintFlagsBleedWidth"" } , { 0x5009 , ""exif:PrintFlagsBleedWidthScale"" } , { 0x500A , ""exif:HalftoneLPI"" } , { 0x500B , ""exif:HalftoneLPIUnit"" } , { 0x500C , ""exif:HalftoneDegree"" } , { 0x500D , ""exif:HalftoneShape"" } , { 0x500E , ""exif:HalftoneMisc"" } , { 0x500F , ""exif:HalftoneScreen"" } , { 0x5010 , ""exif:JPEGQuality"" } , { 0x5011 , ""exif:GridSize"" } , { 0x5012 , ""exif:ThumbnailFormat"" } , { 0x5013 , ""exif:ThumbnailWidth"" } , { 0x5014 , ""exif:ThumbnailHeight"" } , { 0x5015 , ""exif:ThumbnailColorDepth"" } , { 0x5016 , ""exif:ThumbnailPlanes"" } , { 0x5017 , ""exif:ThumbnailRawBytes"" } , { 0x5018 , ""exif:ThumbnailSize"" } , { 0x5019 , ""exif:ThumbnailCompressedSize"" } , { 0x501a , ""exif:ColorTransferFunction"" } , { 0x501b , ""exif:ThumbnailData"" } , { 0x5020 , ""exif:ThumbnailImageWidth"" } , { 0x5021 , ""exif:ThumbnailImageHeight"" } , { 0x5022 , ""exif:ThumbnailBitsPerSample"" } , { 0x5023 , ""exif:ThumbnailCompression"" } , { 0x5024 , ""exif:ThumbnailPhotometricInterp"" } , { 0x5025 , ""exif:ThumbnailImageDescription"" } , { 0x5026 , ""exif:ThumbnailEquipMake"" } , { 0x5027 , ""exif:ThumbnailEquipModel"" } , { 0x5028 , ""exif:ThumbnailStripOffsets"" } , { 0x5029 , ""exif:ThumbnailOrientation"" } , { 0x502a , ""exif:ThumbnailSamplesPerPixel"" } , { 0x502b , ""exif:ThumbnailRowsPerStrip"" } , { 0x502c , ""exif:ThumbnailStripBytesCount"" } , { 0x502d , ""exif:ThumbnailResolutionX"" } , { 0x502e , ""exif:ThumbnailResolutionY"" } , { 0x502f , ""exif:ThumbnailPlanarConfig"" } , { 0x5030 , ""exif:ThumbnailResolutionUnit"" } , { 0x5031 , ""exif:ThumbnailTransferFunction"" } , { 0x5032 , ""exif:ThumbnailSoftwareUsed"" } , { 0x5033 , ""exif:ThumbnailDateTime"" } , { 0x5034 , ""exif:ThumbnailArtist"" } , { 0x5035 , ""exif:ThumbnailWhitePoint"" } , { 0x5036 , ""exif:ThumbnailPrimaryChromaticities"" } , { 0x5037 , ""exif:ThumbnailYCbCrCoefficients"" } , { 0x5038 , ""exif:ThumbnailYCbCrSubsampling"" } , { 0x5039 , ""exif:ThumbnailYCbCrPositioning"" } , { 0x503A , ""exif:ThumbnailRefBlackWhite"" } , { 0x503B , ""exif:ThumbnailCopyRight"" } , { 0x5090 , ""exif:LuminanceTable"" } , { 0x5091 , ""exif:ChrominanceTable"" } , { 0x5100 , ""exif:FrameDelay"" } , { 0x5101 , ""exif:LoopCount"" } , { 0x5110 , ""exif:PixelUnit"" } , { 0x5111 , ""exif:PixelPerUnitX"" } , { 0x5112 , ""exif:PixelPerUnitY"" } , { 0x5113 , ""exif:PaletteHistogram"" } , { 0x1000 , ""exif:RelatedImageFileFormat"" } , { 0x1001 , ""exif:RelatedImageLength"" } , { 0x1002 , ""exif:RelatedImageWidth"" } , { 0x800d , ""exif:ImageID"" } , { 0x80e3 , ""exif:Matteing"" } , { 0x80e4 , ""exif:DataType"" } , { 0x80e5 , ""exif:ImageDepth"" } , { 0x80e6 , ""exif:TileDepth"" } , { 0x828d , ""exif:CFARepeatPatternDim"" } , { 0x828e , ""exif:CFAPattern2"" } , { 0x828f , ""exif:BatteryLevel"" } , { 0x8298 , ""exif:Copyright"" } , { 0x829a , ""exif:ExposureTime"" } , { 0x829d , ""exif:FNumber"" } , { 0x83bb , ""exif:IPTC/NAA"" } , { 0x84e3 , ""exif:IT8RasterPadding"" } , { 0x84e5 , ""exif:IT8ColorTable"" } , { 0x8649 , ""exif:ImageResourceInformation"" } , { 0x8769 , ""exif:ExifOffset"" } , { 0x8773 , ""exif:InterColorProfile"" } , { 0x8822 , ""exif:ExposureProgram"" } , { 0x8824 , ""exif:SpectralSensitivity"" } , { 0x8825 , ""exif:GPSInfo"" } , { 0x8827 , ""exif:ISOSpeedRatings"" } , { 0x8828 , ""exif:OECF"" } , { 0x8829 , ""exif:Interlace"" } , { 0x882a , ""exif:TimeZoneOffset"" } , { 0x882b , ""exif:SelfTimerMode"" } , { 0x9000 , ""exif:ExifVersion"" } , { 0x9003 , ""exif:DateTimeOriginal"" } , { 0x9004 , ""exif:DateTimeDigitized"" } , { 0x9101 , ""exif:ComponentsConfiguration"" } , { 0x9102 , ""exif:CompressedBitsPerPixel"" } , { 0x9201 , ""exif:ShutterSpeedValue"" } , { 0x9202 , ""exif:ApertureValue"" } , { 0x9203 , ""exif:BrightnessValue"" } , { 0x9204 , ""exif:ExposureBiasValue"" } , { 0x9205 , ""exif:MaxApertureValue"" } , { 0x9206 , ""exif:SubjectDistance"" } , { 0x9207 , ""exif:MeteringMode"" } , { 0x9208 , ""exif:LightSource"" } , { 0x9209 , ""exif:Flash"" } , { 0x920a , ""exif:FocalLength"" } , { 0x920b , ""exif:FlashEnergy"" } , { 0x920c , ""exif:SpatialFrequencyResponse"" } , { 0x920d , ""exif:Noise"" } , { 0x9211 , ""exif:ImageNumber"" } , { 0x9212 , ""exif:SecurityClassification"" } , { 0x9213 , ""exif:ImageHistory"" } , { 0x9214 , ""exif:SubjectArea"" } , { 0x9215 , ""exif:ExposureIndex"" } , { 0x9216 , ""exif:TIFF-EPStandardID"" } , { 0x927c , ""exif:MakerNote"" } , { 0x9C9b , ""exif:WinXP-Title"" } , { 0x9C9c , ""exif:WinXP-Comments"" } , { 0x9C9d , ""exif:WinXP-Author"" } , { 0x9C9e , ""exif:WinXP-Keywords"" } , { 0x9C9f , ""exif:WinXP-Subject"" } , { 0x9286 , ""exif:UserComment"" } , { 0x9290 , ""exif:SubSecTime"" } , { 0x9291 , ""exif:SubSecTimeOriginal"" } , { 0x9292 , ""exif:SubSecTimeDigitized"" } , { 0xa000 , ""exif:FlashPixVersion"" } , { 0xa001 , ""exif:ColorSpace"" } , { 0xa002 , ""exif:ExifImageWidth"" } , { 0xa003 , ""exif:ExifImageLength"" } , { 0xa004 , ""exif:RelatedSoundFile"" } , { 0xa005 , ""exif:InteroperabilityOffset"" } , { 0xa20b , ""exif:FlashEnergy"" } , { 0xa20c , ""exif:SpatialFrequencyResponse"" } , { 0xa20d , ""exif:Noise"" } , { 0xa20e , ""exif:FocalPlaneXResolution"" } , { 0xa20f , ""exif:FocalPlaneYResolution"" } , { 0xa210 , ""exif:FocalPlaneResolutionUnit"" } , { 0xa214 , ""exif:SubjectLocation"" } , { 0xa215 , ""exif:ExposureIndex"" } , { 0xa216 , ""exif:TIFF/EPStandardID"" } , { 0xa217 , ""exif:SensingMethod"" } , { 0xa300 , ""exif:FileSource"" } , { 0xa301 , ""exif:SceneType"" } , { 0xa302 , ""exif:CFAPattern"" } , { 0xa401 , ""exif:CustomRendered"" } , { 0xa402 , ""exif:ExposureMode"" } , { 0xa403 , ""exif:WhiteBalance"" } , { 0xa404 , ""exif:DigitalZoomRatio"" } , { 0xa405 , ""exif:FocalLengthIn35mmFilm"" } , { 0xa406 , ""exif:SceneCaptureType"" } , { 0xa407 , ""exif:GainControl"" } , { 0xa408 , ""exif:Contrast"" } , { 0xa409 , ""exif:Saturation"" } , { 0xa40a , ""exif:Sharpness"" } , { 0xa40b , ""exif:DeviceSettingDescription"" } , { 0xa40c , ""exif:SubjectDistanceRange"" } , { 0xa420 , ""exif:ImageUniqueID"" } , { 0xc4a5 , ""exif:PrintImageMatching"" } , { 0xa500 , ""exif:Gamma"" } , { 0xc640 , ""exif:CR2Slice"" } , { 0x10000 , ""exif:GPSVersionID"" } , { 0x10001 , ""exif:GPSLatitudeRef"" } , { 0x10002 , ""exif:GPSLatitude"" } , { 0x10003 , ""exif:GPSLongitudeRef"" } , { 0x10004 , ""exif:GPSLongitude"" } , { 0x10005 , ""exif:GPSAltitudeRef"" } , { 0x10006 , ""exif:GPSAltitude"" } , { 0x10007 , ""exif:GPSTimeStamp"" } , { 0x10008 , ""exif:GPSSatellites"" } , { 0x10009 , ""exif:GPSStatus"" } , { 0x1000a , ""exif:GPSMeasureMode"" } , { 0x1000b , ""exif:GPSDop"" } , { 0x1000c , ""exif:GPSSpeedRef"" } , { 0x1000d , ""exif:GPSSpeed"" } , { 0x1000e , ""exif:GPSTrackRef"" } , { 0x1000f , ""exif:GPSTrack"" } , { 0x10010 , ""exif:GPSImgDirectionRef"" } , { 0x10011 , ""exif:GPSImgDirection"" } , { 0x10012 , ""exif:GPSMapDatum"" } , { 0x10013 , ""exif:GPSDestLatitudeRef"" } , { 0x10014 , ""exif:GPSDestLatitude"" } , { 0x10015 , ""exif:GPSDestLongitudeRef"" } , { 0x10016 , ""exif:GPSDestLongitude"" } , { 0x10017 , ""exif:GPSDestBearingRef"" } , { 0x10018 , ""exif:GPSDestBearing"" } , { 0x10019 , ""exif:GPSDestDistanceRef"" } , { 0x1001a , ""exif:GPSDestDistance"" } , { 0x1001b , ""exif:GPSProcessingMethod"" } , { 0x1001c , ""exif:GPSAreaInformation"" } , { 0x1001d , ""exif:GPSDateStamp"" } , { 0x1001e , ""exif:GPSDifferential"" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , ""exif"" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ;  if ( GetValueFromSplayTree ( exif_resources , q ) == q )  break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ;  components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;  number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , ""%hd"" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , ""%hu"" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , ""%f"" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , ""%f"" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = ""unknown"" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , ""%s"" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""#%04lx"" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""@%04lx"" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , ""unknown"" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }",if ( q > ( exif + length - 12 ) ) break ;,2232
107,"buggy line: cwe id:CWE-125context: static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\n"" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005  # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }   # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }  typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , ""exif:InteroperabilityIndex"" } , { 0x002 , ""exif:InteroperabilityVersion"" } , { 0x100 , ""exif:ImageWidth"" } , { 0x101 , ""exif:ImageLength"" } , { 0x102 , ""exif:BitsPerSample"" } , { 0x103 , ""exif:Compression"" } , { 0x106 , ""exif:PhotometricInterpretation"" } , { 0x10a , ""exif:FillOrder"" } , { 0x10d , ""exif:DocumentName"" } , { 0x10e , ""exif:ImageDescription"" } , { 0x10f , ""exif:Make"" } , { 0x110 , ""exif:Model"" } , { 0x111 , ""exif:StripOffsets"" } , { 0x112 , ""exif:Orientation"" } , { 0x115 , ""exif:SamplesPerPixel"" } , { 0x116 , ""exif:RowsPerStrip"" } , { 0x117 , ""exif:StripByteCounts"" } , { 0x11a , ""exif:XResolution"" } , { 0x11b , ""exif:YResolution"" } , { 0x11c , ""exif:PlanarConfiguration"" } , { 0x11d , ""exif:PageName"" } , { 0x11e , ""exif:XPosition"" } , { 0x11f , ""exif:YPosition"" } , { 0x118 , ""exif:MinSampleValue"" } , { 0x119 , ""exif:MaxSampleValue"" } , { 0x120 , ""exif:FreeOffsets"" } , { 0x121 , ""exif:FreeByteCounts"" } , { 0x122 , ""exif:GrayResponseUnit"" } , { 0x123 , ""exif:GrayResponseCurve"" } , { 0x124 , ""exif:T4Options"" } , { 0x125 , ""exif:T6Options"" } , { 0x128 , ""exif:ResolutionUnit"" } , { 0x12d , ""exif:TransferFunction"" } , { 0x131 , ""exif:Software"" } , { 0x132 , ""exif:DateTime"" } , { 0x13b , ""exif:Artist"" } , { 0x13e , ""exif:WhitePoint"" } , { 0x13f , ""exif:PrimaryChromaticities"" } , { 0x140 , ""exif:ColorMap"" } , { 0x141 , ""exif:HalfToneHints"" } , { 0x142 , ""exif:TileWidth"" } , { 0x143 , ""exif:TileLength"" } , { 0x144 , ""exif:TileOffsets"" } , { 0x145 , ""exif:TileByteCounts"" } , { 0x14a , ""exif:SubIFD"" } , { 0x14c , ""exif:InkSet"" } , { 0x14d , ""exif:InkNames"" } , { 0x14e , ""exif:NumberOfInks"" } , { 0x150 , ""exif:DotRange"" } , { 0x151 , ""exif:TargetPrinter"" } , { 0x152 , ""exif:ExtraSample"" } , { 0x153 , ""exif:SampleFormat"" } , { 0x154 , ""exif:SMinSampleValue"" } , { 0x155 , ""exif:SMaxSampleValue"" } , { 0x156 , ""exif:TransferRange"" } , { 0x157 , ""exif:ClipPath"" } , { 0x158 , ""exif:XClipPathUnits"" } , { 0x159 , ""exif:YClipPathUnits"" } , { 0x15a , ""exif:Indexed"" } , { 0x15b , ""exif:JPEGTables"" } , { 0x15f , ""exif:OPIProxy"" } , { 0x200 , ""exif:JPEGProc"" } , { 0x201 , ""exif:JPEGInterchangeFormat"" } , { 0x202 , ""exif:JPEGInterchangeFormatLength"" } , { 0x203 , ""exif:JPEGRestartInterval"" } , { 0x205 , ""exif:JPEGLosslessPredictors"" } , { 0x206 , ""exif:JPEGPointTransforms"" } , { 0x207 , ""exif:JPEGQTables"" } , { 0x208 , ""exif:JPEGDCTables"" } , { 0x209 , ""exif:JPEGACTables"" } , { 0x211 , ""exif:YCbCrCoefficients"" } , { 0x212 , ""exif:YCbCrSubSampling"" } , { 0x213 , ""exif:YCbCrPositioning"" } , { 0x214 , ""exif:ReferenceBlackWhite"" } , { 0x2bc , ""exif:ExtensibleMetadataPlatform"" } , { 0x301 , ""exif:Gamma"" } , { 0x302 , ""exif:ICCProfileDescriptor"" } , { 0x303 , ""exif:SRGBRenderingIntent"" } , { 0x320 , ""exif:ImageTitle"" } , { 0x5001 , ""exif:ResolutionXUnit"" } , { 0x5002 , ""exif:ResolutionYUnit"" } , { 0x5003 , ""exif:ResolutionXLengthUnit"" } , { 0x5004 , ""exif:ResolutionYLengthUnit"" } , { 0x5005 , ""exif:PrintFlags"" } , { 0x5006 , ""exif:PrintFlagsVersion"" } , { 0x5007 , ""exif:PrintFlagsCrop"" } , { 0x5008 , ""exif:PrintFlagsBleedWidth"" } , { 0x5009 , ""exif:PrintFlagsBleedWidthScale"" } , { 0x500A , ""exif:HalftoneLPI"" } , { 0x500B , ""exif:HalftoneLPIUnit"" } , { 0x500C , ""exif:HalftoneDegree"" } , { 0x500D , ""exif:HalftoneShape"" } , { 0x500E , ""exif:HalftoneMisc"" } , { 0x500F , ""exif:HalftoneScreen"" } , { 0x5010 , ""exif:JPEGQuality"" } , { 0x5011 , ""exif:GridSize"" } , { 0x5012 , ""exif:ThumbnailFormat"" } , { 0x5013 , ""exif:ThumbnailWidth"" } , { 0x5014 , ""exif:ThumbnailHeight"" } , { 0x5015 , ""exif:ThumbnailColorDepth"" } , { 0x5016 , ""exif:ThumbnailPlanes"" } , { 0x5017 , ""exif:ThumbnailRawBytes"" } , { 0x5018 , ""exif:ThumbnailSize"" } , { 0x5019 , ""exif:ThumbnailCompressedSize"" } , { 0x501a , ""exif:ColorTransferFunction"" } , { 0x501b , ""exif:ThumbnailData"" } , { 0x5020 , ""exif:ThumbnailImageWidth"" } , { 0x5021 , ""exif:ThumbnailImageHeight"" } , { 0x5022 , ""exif:ThumbnailBitsPerSample"" } , { 0x5023 , ""exif:ThumbnailCompression"" } , { 0x5024 , ""exif:ThumbnailPhotometricInterp"" } , { 0x5025 , ""exif:ThumbnailImageDescription"" } , { 0x5026 , ""exif:ThumbnailEquipMake"" } , { 0x5027 , ""exif:ThumbnailEquipModel"" } , { 0x5028 , ""exif:ThumbnailStripOffsets"" } , { 0x5029 , ""exif:ThumbnailOrientation"" } , { 0x502a , ""exif:ThumbnailSamplesPerPixel"" } , { 0x502b , ""exif:ThumbnailRowsPerStrip"" } , { 0x502c , ""exif:ThumbnailStripBytesCount"" } , { 0x502d , ""exif:ThumbnailResolutionX"" } , { 0x502e , ""exif:ThumbnailResolutionY"" } , { 0x502f , ""exif:ThumbnailPlanarConfig"" } , { 0x5030 , ""exif:ThumbnailResolutionUnit"" } , { 0x5031 , ""exif:ThumbnailTransferFunction"" } , { 0x5032 , ""exif:ThumbnailSoftwareUsed"" } , { 0x5033 , ""exif:ThumbnailDateTime"" } , { 0x5034 , ""exif:ThumbnailArtist"" } , { 0x5035 , ""exif:ThumbnailWhitePoint"" } , { 0x5036 , ""exif:ThumbnailPrimaryChromaticities"" } , { 0x5037 , ""exif:ThumbnailYCbCrCoefficients"" } , { 0x5038 , ""exif:ThumbnailYCbCrSubsampling"" } , { 0x5039 , ""exif:ThumbnailYCbCrPositioning"" } , { 0x503A , ""exif:ThumbnailRefBlackWhite"" } , { 0x503B , ""exif:ThumbnailCopyRight"" } , { 0x5090 , ""exif:LuminanceTable"" } , { 0x5091 , ""exif:ChrominanceTable"" } , { 0x5100 , ""exif:FrameDelay"" } , { 0x5101 , ""exif:LoopCount"" } , { 0x5110 , ""exif:PixelUnit"" } , { 0x5111 , ""exif:PixelPerUnitX"" } , { 0x5112 , ""exif:PixelPerUnitY"" } , { 0x5113 , ""exif:PaletteHistogram"" } , { 0x1000 , ""exif:RelatedImageFileFormat"" } , { 0x1001 , ""exif:RelatedImageLength"" } , { 0x1002 , ""exif:RelatedImageWidth"" } , { 0x800d , ""exif:ImageID"" } , { 0x80e3 , ""exif:Matteing"" } , { 0x80e4 , ""exif:DataType"" } , { 0x80e5 , ""exif:ImageDepth"" } , { 0x80e6 , ""exif:TileDepth"" } , { 0x828d , ""exif:CFARepeatPatternDim"" } , { 0x828e , ""exif:CFAPattern2"" } , { 0x828f , ""exif:BatteryLevel"" } , { 0x8298 , ""exif:Copyright"" } , { 0x829a , ""exif:ExposureTime"" } , { 0x829d , ""exif:FNumber"" } , { 0x83bb , ""exif:IPTC/NAA"" } , { 0x84e3 , ""exif:IT8RasterPadding"" } , { 0x84e5 , ""exif:IT8ColorTable"" } , { 0x8649 , ""exif:ImageResourceInformation"" } , { 0x8769 , ""exif:ExifOffset"" } , { 0x8773 , ""exif:InterColorProfile"" } , { 0x8822 , ""exif:ExposureProgram"" } , { 0x8824 , ""exif:SpectralSensitivity"" } , { 0x8825 , ""exif:GPSInfo"" } , { 0x8827 , ""exif:ISOSpeedRatings"" } , { 0x8828 , ""exif:OECF"" } , { 0x8829 , ""exif:Interlace"" } , { 0x882a , ""exif:TimeZoneOffset"" } , { 0x882b , ""exif:SelfTimerMode"" } , { 0x9000 , ""exif:ExifVersion"" } , { 0x9003 , ""exif:DateTimeOriginal"" } , { 0x9004 , ""exif:DateTimeDigitized"" } , { 0x9101 , ""exif:ComponentsConfiguration"" } , { 0x9102 , ""exif:CompressedBitsPerPixel"" } , { 0x9201 , ""exif:ShutterSpeedValue"" } , { 0x9202 , ""exif:ApertureValue"" } , { 0x9203 , ""exif:BrightnessValue"" } , { 0x9204 , ""exif:ExposureBiasValue"" } , { 0x9205 , ""exif:MaxApertureValue"" } , { 0x9206 , ""exif:SubjectDistance"" } , { 0x9207 , ""exif:MeteringMode"" } , { 0x9208 , ""exif:LightSource"" } , { 0x9209 , ""exif:Flash"" } , { 0x920a , ""exif:FocalLength"" } , { 0x920b , ""exif:FlashEnergy"" } , { 0x920c , ""exif:SpatialFrequencyResponse"" } , { 0x920d , ""exif:Noise"" } , { 0x9211 , ""exif:ImageNumber"" } , { 0x9212 , ""exif:SecurityClassification"" } , { 0x9213 , ""exif:ImageHistory"" } , { 0x9214 , ""exif:SubjectArea"" } , { 0x9215 , ""exif:ExposureIndex"" } , { 0x9216 , ""exif:TIFF-EPStandardID"" } , { 0x927c , ""exif:MakerNote"" } , { 0x9C9b , ""exif:WinXP-Title"" } , { 0x9C9c , ""exif:WinXP-Comments"" } , { 0x9C9d , ""exif:WinXP-Author"" } , { 0x9C9e , ""exif:WinXP-Keywords"" } , { 0x9C9f , ""exif:WinXP-Subject"" } , { 0x9286 , ""exif:UserComment"" } , { 0x9290 , ""exif:SubSecTime"" } , { 0x9291 , ""exif:SubSecTimeOriginal"" } , { 0x9292 , ""exif:SubSecTimeDigitized"" } , { 0xa000 , ""exif:FlashPixVersion"" } , { 0xa001 , ""exif:ColorSpace"" } , { 0xa002 , ""exif:ExifImageWidth"" } , { 0xa003 , ""exif:ExifImageLength"" } , { 0xa004 , ""exif:RelatedSoundFile"" } , { 0xa005 , ""exif:InteroperabilityOffset"" } , { 0xa20b , ""exif:FlashEnergy"" } , { 0xa20c , ""exif:SpatialFrequencyResponse"" } , { 0xa20d , ""exif:Noise"" } , { 0xa20e , ""exif:FocalPlaneXResolution"" } , { 0xa20f , ""exif:FocalPlaneYResolution"" } , { 0xa210 , ""exif:FocalPlaneResolutionUnit"" } , { 0xa214 , ""exif:SubjectLocation"" } , { 0xa215 , ""exif:ExposureIndex"" } , { 0xa216 , ""exif:TIFF/EPStandardID"" } , { 0xa217 , ""exif:SensingMethod"" } , { 0xa300 , ""exif:FileSource"" } , { 0xa301 , ""exif:SceneType"" } , { 0xa302 , ""exif:CFAPattern"" } , { 0xa401 , ""exif:CustomRendered"" } , { 0xa402 , ""exif:ExposureMode"" } , { 0xa403 , ""exif:WhiteBalance"" } , { 0xa404 , ""exif:DigitalZoomRatio"" } , { 0xa405 , ""exif:FocalLengthIn35mmFilm"" } , { 0xa406 , ""exif:SceneCaptureType"" } , { 0xa407 , ""exif:GainControl"" } , { 0xa408 , ""exif:Contrast"" } , { 0xa409 , ""exif:Saturation"" } , { 0xa40a , ""exif:Sharpness"" } , { 0xa40b , ""exif:DeviceSettingDescription"" } , { 0xa40c , ""exif:SubjectDistanceRange"" } , { 0xa420 , ""exif:ImageUniqueID"" } , { 0xc4a5 , ""exif:PrintImageMatching"" } , { 0xa500 , ""exif:Gamma"" } , { 0xc640 , ""exif:CR2Slice"" } , { 0x10000 , ""exif:GPSVersionID"" } , { 0x10001 , ""exif:GPSLatitudeRef"" } , { 0x10002 , ""exif:GPSLatitude"" } , { 0x10003 , ""exif:GPSLongitudeRef"" } , { 0x10004 , ""exif:GPSLongitude"" } , { 0x10005 , ""exif:GPSAltitudeRef"" } , { 0x10006 , ""exif:GPSAltitude"" } , { 0x10007 , ""exif:GPSTimeStamp"" } , { 0x10008 , ""exif:GPSSatellites"" } , { 0x10009 , ""exif:GPSStatus"" } , { 0x1000a , ""exif:GPSMeasureMode"" } , { 0x1000b , ""exif:GPSDop"" } , { 0x1000c , ""exif:GPSSpeedRef"" } , { 0x1000d , ""exif:GPSSpeed"" } , { 0x1000e , ""exif:GPSTrackRef"" } , { 0x1000f , ""exif:GPSTrack"" } , { 0x10010 , ""exif:GPSImgDirectionRef"" } , { 0x10011 , ""exif:GPSImgDirection"" } , { 0x10012 , ""exif:GPSMapDatum"" } , { 0x10013 , ""exif:GPSDestLatitudeRef"" } , { 0x10014 , ""exif:GPSDestLatitude"" } , { 0x10015 , ""exif:GPSDestLongitudeRef"" } , { 0x10016 , ""exif:GPSDestLongitude"" } , { 0x10017 , ""exif:GPSDestBearingRef"" } , { 0x10018 , ""exif:GPSDestBearing"" } , { 0x10019 , ""exif:GPSDestDistanceRef"" } , { 0x1001a , ""exif:GPSDestDistance"" } , { 0x1001b , ""exif:GPSProcessingMethod"" } , { 0x1001c , ""exif:GPSAreaInformation"" } , { 0x1001d , ""exif:GPSDateStamp"" } , { 0x1001e , ""exif:GPSDifferential"" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , ""exif"" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ;  if ( GetValueFromSplayTree ( exif_resources , q ) == q )  break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ;  components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;  number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , ""%hd"" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , ""%hu"" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , ""%f"" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , ""%f"" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = ""unknown"" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , ""%s"" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""#%04lx"" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""@%04lx"" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , ""unknown"" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }",if ( components < 0 ) break ;,2232
108,"buggy line: if ( GetValueFromSplayTree ( exif_resources , q ) == q )  break ;components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;number_bytes = ( size_t ) components * tag_bytes [ format ] ;cwe id:CWE-125context: static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\n"" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005  # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }   # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; }  typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , ""exif:InteroperabilityIndex"" } , { 0x002 , ""exif:InteroperabilityVersion"" } , { 0x100 , ""exif:ImageWidth"" } , { 0x101 , ""exif:ImageLength"" } , { 0x102 , ""exif:BitsPerSample"" } , { 0x103 , ""exif:Compression"" } , { 0x106 , ""exif:PhotometricInterpretation"" } , { 0x10a , ""exif:FillOrder"" } , { 0x10d , ""exif:DocumentName"" } , { 0x10e , ""exif:ImageDescription"" } , { 0x10f , ""exif:Make"" } , { 0x110 , ""exif:Model"" } , { 0x111 , ""exif:StripOffsets"" } , { 0x112 , ""exif:Orientation"" } , { 0x115 , ""exif:SamplesPerPixel"" } , { 0x116 , ""exif:RowsPerStrip"" } , { 0x117 , ""exif:StripByteCounts"" } , { 0x11a , ""exif:XResolution"" } , { 0x11b , ""exif:YResolution"" } , { 0x11c , ""exif:PlanarConfiguration"" } , { 0x11d , ""exif:PageName"" } , { 0x11e , ""exif:XPosition"" } , { 0x11f , ""exif:YPosition"" } , { 0x118 , ""exif:MinSampleValue"" } , { 0x119 , ""exif:MaxSampleValue"" } , { 0x120 , ""exif:FreeOffsets"" } , { 0x121 , ""exif:FreeByteCounts"" } , { 0x122 , ""exif:GrayResponseUnit"" } , { 0x123 , ""exif:GrayResponseCurve"" } , { 0x124 , ""exif:T4Options"" } , { 0x125 , ""exif:T6Options"" } , { 0x128 , ""exif:ResolutionUnit"" } , { 0x12d , ""exif:TransferFunction"" } , { 0x131 , ""exif:Software"" } , { 0x132 , ""exif:DateTime"" } , { 0x13b , ""exif:Artist"" } , { 0x13e , ""exif:WhitePoint"" } , { 0x13f , ""exif:PrimaryChromaticities"" } , { 0x140 , ""exif:ColorMap"" } , { 0x141 , ""exif:HalfToneHints"" } , { 0x142 , ""exif:TileWidth"" } , { 0x143 , ""exif:TileLength"" } , { 0x144 , ""exif:TileOffsets"" } , { 0x145 , ""exif:TileByteCounts"" } , { 0x14a , ""exif:SubIFD"" } , { 0x14c , ""exif:InkSet"" } , { 0x14d , ""exif:InkNames"" } , { 0x14e , ""exif:NumberOfInks"" } , { 0x150 , ""exif:DotRange"" } , { 0x151 , ""exif:TargetPrinter"" } , { 0x152 , ""exif:ExtraSample"" } , { 0x153 , ""exif:SampleFormat"" } , { 0x154 , ""exif:SMinSampleValue"" } , { 0x155 , ""exif:SMaxSampleValue"" } , { 0x156 , ""exif:TransferRange"" } , { 0x157 , ""exif:ClipPath"" } , { 0x158 , ""exif:XClipPathUnits"" } , { 0x159 , ""exif:YClipPathUnits"" } , { 0x15a , ""exif:Indexed"" } , { 0x15b , ""exif:JPEGTables"" } , { 0x15f , ""exif:OPIProxy"" } , { 0x200 , ""exif:JPEGProc"" } , { 0x201 , ""exif:JPEGInterchangeFormat"" } , { 0x202 , ""exif:JPEGInterchangeFormatLength"" } , { 0x203 , ""exif:JPEGRestartInterval"" } , { 0x205 , ""exif:JPEGLosslessPredictors"" } , { 0x206 , ""exif:JPEGPointTransforms"" } , { 0x207 , ""exif:JPEGQTables"" } , { 0x208 , ""exif:JPEGDCTables"" } , { 0x209 , ""exif:JPEGACTables"" } , { 0x211 , ""exif:YCbCrCoefficients"" } , { 0x212 , ""exif:YCbCrSubSampling"" } , { 0x213 , ""exif:YCbCrPositioning"" } , { 0x214 , ""exif:ReferenceBlackWhite"" } , { 0x2bc , ""exif:ExtensibleMetadataPlatform"" } , { 0x301 , ""exif:Gamma"" } , { 0x302 , ""exif:ICCProfileDescriptor"" } , { 0x303 , ""exif:SRGBRenderingIntent"" } , { 0x320 , ""exif:ImageTitle"" } , { 0x5001 , ""exif:ResolutionXUnit"" } , { 0x5002 , ""exif:ResolutionYUnit"" } , { 0x5003 , ""exif:ResolutionXLengthUnit"" } , { 0x5004 , ""exif:ResolutionYLengthUnit"" } , { 0x5005 , ""exif:PrintFlags"" } , { 0x5006 , ""exif:PrintFlagsVersion"" } , { 0x5007 , ""exif:PrintFlagsCrop"" } , { 0x5008 , ""exif:PrintFlagsBleedWidth"" } , { 0x5009 , ""exif:PrintFlagsBleedWidthScale"" } , { 0x500A , ""exif:HalftoneLPI"" } , { 0x500B , ""exif:HalftoneLPIUnit"" } , { 0x500C , ""exif:HalftoneDegree"" } , { 0x500D , ""exif:HalftoneShape"" } , { 0x500E , ""exif:HalftoneMisc"" } , { 0x500F , ""exif:HalftoneScreen"" } , { 0x5010 , ""exif:JPEGQuality"" } , { 0x5011 , ""exif:GridSize"" } , { 0x5012 , ""exif:ThumbnailFormat"" } , { 0x5013 , ""exif:ThumbnailWidth"" } , { 0x5014 , ""exif:ThumbnailHeight"" } , { 0x5015 , ""exif:ThumbnailColorDepth"" } , { 0x5016 , ""exif:ThumbnailPlanes"" } , { 0x5017 , ""exif:ThumbnailRawBytes"" } , { 0x5018 , ""exif:ThumbnailSize"" } , { 0x5019 , ""exif:ThumbnailCompressedSize"" } , { 0x501a , ""exif:ColorTransferFunction"" } , { 0x501b , ""exif:ThumbnailData"" } , { 0x5020 , ""exif:ThumbnailImageWidth"" } , { 0x5021 , ""exif:ThumbnailImageHeight"" } , { 0x5022 , ""exif:ThumbnailBitsPerSample"" } , { 0x5023 , ""exif:ThumbnailCompression"" } , { 0x5024 , ""exif:ThumbnailPhotometricInterp"" } , { 0x5025 , ""exif:ThumbnailImageDescription"" } , { 0x5026 , ""exif:ThumbnailEquipMake"" } , { 0x5027 , ""exif:ThumbnailEquipModel"" } , { 0x5028 , ""exif:ThumbnailStripOffsets"" } , { 0x5029 , ""exif:ThumbnailOrientation"" } , { 0x502a , ""exif:ThumbnailSamplesPerPixel"" } , { 0x502b , ""exif:ThumbnailRowsPerStrip"" } , { 0x502c , ""exif:ThumbnailStripBytesCount"" } , { 0x502d , ""exif:ThumbnailResolutionX"" } , { 0x502e , ""exif:ThumbnailResolutionY"" } , { 0x502f , ""exif:ThumbnailPlanarConfig"" } , { 0x5030 , ""exif:ThumbnailResolutionUnit"" } , { 0x5031 , ""exif:ThumbnailTransferFunction"" } , { 0x5032 , ""exif:ThumbnailSoftwareUsed"" } , { 0x5033 , ""exif:ThumbnailDateTime"" } , { 0x5034 , ""exif:ThumbnailArtist"" } , { 0x5035 , ""exif:ThumbnailWhitePoint"" } , { 0x5036 , ""exif:ThumbnailPrimaryChromaticities"" } , { 0x5037 , ""exif:ThumbnailYCbCrCoefficients"" } , { 0x5038 , ""exif:ThumbnailYCbCrSubsampling"" } , { 0x5039 , ""exif:ThumbnailYCbCrPositioning"" } , { 0x503A , ""exif:ThumbnailRefBlackWhite"" } , { 0x503B , ""exif:ThumbnailCopyRight"" } , { 0x5090 , ""exif:LuminanceTable"" } , { 0x5091 , ""exif:ChrominanceTable"" } , { 0x5100 , ""exif:FrameDelay"" } , { 0x5101 , ""exif:LoopCount"" } , { 0x5110 , ""exif:PixelUnit"" } , { 0x5111 , ""exif:PixelPerUnitX"" } , { 0x5112 , ""exif:PixelPerUnitY"" } , { 0x5113 , ""exif:PaletteHistogram"" } , { 0x1000 , ""exif:RelatedImageFileFormat"" } , { 0x1001 , ""exif:RelatedImageLength"" } , { 0x1002 , ""exif:RelatedImageWidth"" } , { 0x800d , ""exif:ImageID"" } , { 0x80e3 , ""exif:Matteing"" } , { 0x80e4 , ""exif:DataType"" } , { 0x80e5 , ""exif:ImageDepth"" } , { 0x80e6 , ""exif:TileDepth"" } , { 0x828d , ""exif:CFARepeatPatternDim"" } , { 0x828e , ""exif:CFAPattern2"" } , { 0x828f , ""exif:BatteryLevel"" } , { 0x8298 , ""exif:Copyright"" } , { 0x829a , ""exif:ExposureTime"" } , { 0x829d , ""exif:FNumber"" } , { 0x83bb , ""exif:IPTC/NAA"" } , { 0x84e3 , ""exif:IT8RasterPadding"" } , { 0x84e5 , ""exif:IT8ColorTable"" } , { 0x8649 , ""exif:ImageResourceInformation"" } , { 0x8769 , ""exif:ExifOffset"" } , { 0x8773 , ""exif:InterColorProfile"" } , { 0x8822 , ""exif:ExposureProgram"" } , { 0x8824 , ""exif:SpectralSensitivity"" } , { 0x8825 , ""exif:GPSInfo"" } , { 0x8827 , ""exif:ISOSpeedRatings"" } , { 0x8828 , ""exif:OECF"" } , { 0x8829 , ""exif:Interlace"" } , { 0x882a , ""exif:TimeZoneOffset"" } , { 0x882b , ""exif:SelfTimerMode"" } , { 0x9000 , ""exif:ExifVersion"" } , { 0x9003 , ""exif:DateTimeOriginal"" } , { 0x9004 , ""exif:DateTimeDigitized"" } , { 0x9101 , ""exif:ComponentsConfiguration"" } , { 0x9102 , ""exif:CompressedBitsPerPixel"" } , { 0x9201 , ""exif:ShutterSpeedValue"" } , { 0x9202 , ""exif:ApertureValue"" } , { 0x9203 , ""exif:BrightnessValue"" } , { 0x9204 , ""exif:ExposureBiasValue"" } , { 0x9205 , ""exif:MaxApertureValue"" } , { 0x9206 , ""exif:SubjectDistance"" } , { 0x9207 , ""exif:MeteringMode"" } , { 0x9208 , ""exif:LightSource"" } , { 0x9209 , ""exif:Flash"" } , { 0x920a , ""exif:FocalLength"" } , { 0x920b , ""exif:FlashEnergy"" } , { 0x920c , ""exif:SpatialFrequencyResponse"" } , { 0x920d , ""exif:Noise"" } , { 0x9211 , ""exif:ImageNumber"" } , { 0x9212 , ""exif:SecurityClassification"" } , { 0x9213 , ""exif:ImageHistory"" } , { 0x9214 , ""exif:SubjectArea"" } , { 0x9215 , ""exif:ExposureIndex"" } , { 0x9216 , ""exif:TIFF-EPStandardID"" } , { 0x927c , ""exif:MakerNote"" } , { 0x9C9b , ""exif:WinXP-Title"" } , { 0x9C9c , ""exif:WinXP-Comments"" } , { 0x9C9d , ""exif:WinXP-Author"" } , { 0x9C9e , ""exif:WinXP-Keywords"" } , { 0x9C9f , ""exif:WinXP-Subject"" } , { 0x9286 , ""exif:UserComment"" } , { 0x9290 , ""exif:SubSecTime"" } , { 0x9291 , ""exif:SubSecTimeOriginal"" } , { 0x9292 , ""exif:SubSecTimeDigitized"" } , { 0xa000 , ""exif:FlashPixVersion"" } , { 0xa001 , ""exif:ColorSpace"" } , { 0xa002 , ""exif:ExifImageWidth"" } , { 0xa003 , ""exif:ExifImageLength"" } , { 0xa004 , ""exif:RelatedSoundFile"" } , { 0xa005 , ""exif:InteroperabilityOffset"" } , { 0xa20b , ""exif:FlashEnergy"" } , { 0xa20c , ""exif:SpatialFrequencyResponse"" } , { 0xa20d , ""exif:Noise"" } , { 0xa20e , ""exif:FocalPlaneXResolution"" } , { 0xa20f , ""exif:FocalPlaneYResolution"" } , { 0xa210 , ""exif:FocalPlaneResolutionUnit"" } , { 0xa214 , ""exif:SubjectLocation"" } , { 0xa215 , ""exif:ExposureIndex"" } , { 0xa216 , ""exif:TIFF/EPStandardID"" } , { 0xa217 , ""exif:SensingMethod"" } , { 0xa300 , ""exif:FileSource"" } , { 0xa301 , ""exif:SceneType"" } , { 0xa302 , ""exif:CFAPattern"" } , { 0xa401 , ""exif:CustomRendered"" } , { 0xa402 , ""exif:ExposureMode"" } , { 0xa403 , ""exif:WhiteBalance"" } , { 0xa404 , ""exif:DigitalZoomRatio"" } , { 0xa405 , ""exif:FocalLengthIn35mmFilm"" } , { 0xa406 , ""exif:SceneCaptureType"" } , { 0xa407 , ""exif:GainControl"" } , { 0xa408 , ""exif:Contrast"" } , { 0xa409 , ""exif:Saturation"" } , { 0xa40a , ""exif:Sharpness"" } , { 0xa40b , ""exif:DeviceSettingDescription"" } , { 0xa40c , ""exif:SubjectDistanceRange"" } , { 0xa420 , ""exif:ImageUniqueID"" } , { 0xc4a5 , ""exif:PrintImageMatching"" } , { 0xa500 , ""exif:Gamma"" } , { 0xc640 , ""exif:CR2Slice"" } , { 0x10000 , ""exif:GPSVersionID"" } , { 0x10001 , ""exif:GPSLatitudeRef"" } , { 0x10002 , ""exif:GPSLatitude"" } , { 0x10003 , ""exif:GPSLongitudeRef"" } , { 0x10004 , ""exif:GPSLongitude"" } , { 0x10005 , ""exif:GPSAltitudeRef"" } , { 0x10006 , ""exif:GPSAltitude"" } , { 0x10007 , ""exif:GPSTimeStamp"" } , { 0x10008 , ""exif:GPSSatellites"" } , { 0x10009 , ""exif:GPSStatus"" } , { 0x1000a , ""exif:GPSMeasureMode"" } , { 0x1000b , ""exif:GPSDop"" } , { 0x1000c , ""exif:GPSSpeedRef"" } , { 0x1000d , ""exif:GPSSpeed"" } , { 0x1000e , ""exif:GPSTrackRef"" } , { 0x1000f , ""exif:GPSTrack"" } , { 0x10010 , ""exif:GPSImgDirectionRef"" } , { 0x10011 , ""exif:GPSImgDirection"" } , { 0x10012 , ""exif:GPSMapDatum"" } , { 0x10013 , ""exif:GPSDestLatitudeRef"" } , { 0x10014 , ""exif:GPSDestLatitude"" } , { 0x10015 , ""exif:GPSDestLongitudeRef"" } , { 0x10016 , ""exif:GPSDestLongitude"" } , { 0x10017 , ""exif:GPSDestBearingRef"" } , { 0x10018 , ""exif:GPSDestBearing"" } , { 0x10019 , ""exif:GPSDestDistanceRef"" } , { 0x1001a , ""exif:GPSDestDistance"" } , { 0x1001b , ""exif:GPSProcessingMethod"" } , { 0x1001c , ""exif:GPSAreaInformation"" } , { 0x1001d , ""exif:GPSDateStamp"" } , { 0x1001e , ""exif:GPSDifferential"" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , ""exif"" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ;  if ( GetValueFromSplayTree ( exif_resources , q ) == q )  break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ;  components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;  number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , ""%hd"" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , ""%hu"" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , ""%f"" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , ""%f"" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = ""unknown"" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , ""%s"" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""#%04lx"" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""@%04lx"" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , ""unknown"" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }","if ( GetValueFromSplayTree ( exif_resources , q ) == q ) break ;components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;number_bytes = ( size_t ) components * tag_bytes [ format ] ;",2232
109,"buggy line: if ( fuji_width )  {cwe id:CWE-119context: void CLASS identify ( ) { static const short pana [ ] [ 6 ] = { { 3130 , 1743 , 4 , 0 , - 6 , 0 } , { 3130 , 2055 , 4 , 0 , - 6 , 0 } , { 3130 , 2319 , 4 , 0 , - 6 , 0 } , { 3170 , 2103 , 18 , 0 , - 42 , 20 } , { 3170 , 2367 , 18 , 13 , - 42 , - 21 } , { 3177 , 2367 , 0 , 0 , - 1 , 0 } , { 3304 , 2458 , 0 , 0 , - 1 , 0 } , { 3330 , 2463 , 9 , 0 , - 5 , 0 } , { 3330 , 2479 , 9 , 0 , - 17 , 4 } , { 3370 , 1899 , 15 , 0 , - 44 , 20 } , { 3370 , 2235 , 15 , 0 , - 44 , 20 } , { 3370 , 2511 , 15 , 10 , - 44 , - 21 } , { 3690 , 2751 , 3 , 0 , - 8 , - 3 } , { 3710 , 2751 , 0 , 0 , - 3 , 0 } , { 3724 , 2450 , 0 , 0 , 0 , - 2 } , { 3770 , 2487 , 17 , 0 , - 44 , 19 } , { 3770 , 2799 , 17 , 15 , - 44 , - 19 } , { 3880 , 2170 , 6 , 0 , - 6 , 0 } , { 4060 , 3018 , 0 , 0 , 0 , - 2 } , { 4290 , 2391 , 3 , 0 , - 8 , - 1 } , { 4330 , 2439 , 17 , 15 , - 44 , - 19 } , { 4508 , 2962 , 0 , 0 , - 3 , - 4 } , { 4508 , 3330 , 0 , 0 , - 3 , - 6 } , } ; static const ushort canon [ ] [ 11 ] = { { 1944 , 1416 , 0 , 0 , 48 , 0 } , { 2144 , 1560 , 4 , 8 , 52 , 2 , 0 , 0 , 0 , 25 } , { 2224 , 1456 , 48 , 6 , 0 , 2 } , { 2376 , 1728 , 12 , 6 , 52 , 2 } , { 2672 , 1968 , 12 , 6 , 44 , 2 } , { 3152 , 2068 , 64 , 12 , 0 , 0 , 16 } , { 3160 , 2344 , 44 , 12 , 4 , 4 } , { 3344 , 2484 , 4 , 6 , 52 , 6 } , { 3516 , 2328 , 42 , 14 , 0 , 0 } , { 3596 , 2360 , 74 , 12 , 0 , 0 } , { 3744 , 2784 , 52 , 12 , 8 , 12 } , { 3944 , 2622 , 30 , 18 , 6 , 2 } , { 3948 , 2622 , 42 , 18 , 0 , 2 } , { 3984 , 2622 , 76 , 20 , 0 , 2 , 14 } , { 4104 , 3048 , 48 , 12 , 24 , 12 } , { 4116 , 2178 , 4 , 2 , 0 , 0 } , { 4152 , 2772 , 192 , 12 , 0 , 0 } , { 4160 , 3124 , 104 , 11 , 8 , 65 } , { 4176 , 3062 , 96 , 17 , 8 , 0 , 0 , 16 , 0 , 7 , 0x49 } , { 4192 , 3062 , 96 , 17 , 24 , 0 , 0 , 16 , 0 , 0 , 0x49 } , { 4312 , 2876 , 22 , 18 , 0 , 2 } , { 4352 , 2874 , 62 , 18 , 0 , 0 } , { 4476 , 2954 , 90 , 34 , 0 , 0 } , { 4480 , 3348 , 12 , 10 , 36 , 12 , 0 , 0 , 0 , 18 , 0x49 } , { 4480 , 3366 , 80 , 50 , 0 , 0 } , { 4496 , 3366 , 80 , 50 , 12 , 0 } , { 4768 , 3516 , 96 , 16 , 0 , 0 , 0 , 16 } , { 4832 , 3204 , 62 , 26 , 0 , 0 } , { 4832 , 3228 , 62 , 51 , 0 , 0 } , { 5108 , 3349 , 98 , 13 , 0 , 0 } , { 5120 , 3318 , 142 , 45 , 62 , 0 } , { 5280 , 3528 , 72 , 52 , 0 , 0 } , { 5344 , 3516 , 142 , 51 , 0 , 0 } , { 5344 , 3584 , 126 , 100 , 0 , 2 } , { 5360 , 3516 , 158 , 51 , 0 , 0 } , { 5568 , 3708 , 72 , 38 , 0 , 0 } , { 5632 , 3710 , 96 , 17 , 0 , 0 , 0 , 16 , 0 , 0 , 0x49 } , { 5712 , 3774 , 62 , 20 , 10 , 2 } , { 5792 , 3804 , 158 , 51 , 0 , 0 } , { 5920 , 3950 , 122 , 80 , 2 , 0 } , { 6096 , 4056 , 72 , 34 , 0 , 0 } , { 6288 , 4056 , 266 , 36 , 0 , 0 } , { 6384 , 4224 , 120 , 44 , 0 , 0 } , { 6880 , 4544 , 136 , 42 , 0 , 0 } , { 8896 , 5920 , 160 , 64 , 0 , 0 } , } ; static const struct { ushort id ; char t_model [ 20 ] ; } unique [ ] = { { 0x001 , ""EOS-1D"" } , { 0x167 , ""EOS-1DS"" } , { 0x168 , ""EOS<S2SV_blank>10D"" } , { 0x169 , ""EOS-1D<S2SV_blank>Mark<S2SV_blank>III"" } , { 0x170 , ""EOS<S2SV_blank>300D"" } , { 0x174 , ""EOS-1D<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x175 , ""EOS<S2SV_blank>20D"" } , { 0x176 , ""EOS<S2SV_blank>450D"" } , { 0x188 , ""EOS-1Ds<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x189 , ""EOS<S2SV_blank>350D"" } , { 0x190 , ""EOS<S2SV_blank>40D"" } , { 0x213 , ""EOS<S2SV_blank>5D"" } , { 0x215 , ""EOS-1Ds<S2SV_blank>Mark<S2SV_blank>III"" } , { 0x218 , ""EOS<S2SV_blank>5D<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x232 , ""EOS-1D<S2SV_blank>Mark<S2SV_blank>II<S2SV_blank>N"" } , { 0x234 , ""EOS<S2SV_blank>30D"" } , { 0x236 , ""EOS<S2SV_blank>400D"" } , { 0x250 , ""EOS<S2SV_blank>7D"" } , { 0x252 , ""EOS<S2SV_blank>500D"" } , { 0x254 , ""EOS<S2SV_blank>1000D"" } , { 0x261 , ""EOS<S2SV_blank>50D"" } , { 0x269 , ""EOS-1D<S2SV_blank>X"" } , { 0x270 , ""EOS<S2SV_blank>550D"" } , { 0x281 , ""EOS-1D<S2SV_blank>Mark<S2SV_blank>IV"" } , { 0x285 , ""EOS<S2SV_blank>5D<S2SV_blank>Mark<S2SV_blank>III"" } , { 0x286 , ""EOS<S2SV_blank>600D"" } , { 0x287 , ""EOS<S2SV_blank>60D"" } , { 0x288 , ""EOS<S2SV_blank>1100D"" } , { 0x289 , ""EOS<S2SV_blank>7D<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x301 , ""EOS<S2SV_blank>650D"" } , { 0x302 , ""EOS<S2SV_blank>6D"" } , { 0x324 , ""EOS-1D<S2SV_blank>C"" } , { 0x325 , ""EOS<S2SV_blank>70D"" } , { 0x326 , ""EOS<S2SV_blank>700D"" } , { 0x327 , ""EOS<S2SV_blank>1200D"" } , { 0x328 , ""EOS-1D<S2SV_blank>X<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x331 , ""EOS<S2SV_blank>M"" } , { 0x335 , ""EOS<S2SV_blank>M2"" } , { 0x374 , ""EOS<S2SV_blank>M3"" } , { 0x384 , ""EOS<S2SV_blank>M10"" } , { 0x394 , ""EOS<S2SV_blank>M5"" } , { 0x398 , ""EOS<S2SV_blank>M100"" } , { 0x346 , ""EOS<S2SV_blank>100D"" } , { 0x347 , ""EOS<S2SV_blank>760D"" } , { 0x349 , ""EOS<S2SV_blank>5D<S2SV_blank>Mark<S2SV_blank>IV"" } , { 0x350 , ""EOS<S2SV_blank>80D"" } , { 0x382 , ""EOS<S2SV_blank>5DS"" } , { 0x393 , ""EOS<S2SV_blank>750D"" } , { 0x401 , ""EOS<S2SV_blank>5DS<S2SV_blank>R"" } , { 0x404 , ""EOS<S2SV_blank>1300D"" } , { 0x405 , ""EOS<S2SV_blank>800D"" } , { 0x406 , ""EOS<S2SV_blank>6D<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x407 , ""EOS<S2SV_blank>M6"" } , { 0x408 , ""EOS<S2SV_blank>77D"" } , { 0x417 , ""EOS<S2SV_blank>200D"" } , } , sonique [ ] = { { 0x002 , ""DSC-R1"" } , { 0x100 , ""DSLR-A100"" } , { 0x101 , ""DSLR-A900"" } , { 0x102 , ""DSLR-A700"" } , { 0x103 , ""DSLR-A200"" } , { 0x104 , ""DSLR-A350"" } , { 0x105 , ""DSLR-A300"" } , { 0x106 , ""DSLR-A900"" } , { 0x107 , ""DSLR-A380"" } , { 0x108 , ""DSLR-A330"" } , { 0x109 , ""DSLR-A230"" } , { 0x10a , ""DSLR-A290"" } , { 0x10d , ""DSLR-A850"" } , { 0x10e , ""DSLR-A850"" } , { 0x111 , ""DSLR-A550"" } , { 0x112 , ""DSLR-A500"" } , { 0x113 , ""DSLR-A450"" } , { 0x116 , ""NEX-5"" } , { 0x117 , ""NEX-3"" } , { 0x118 , ""SLT-A33"" } , { 0x119 , ""SLT-A55V"" } , { 0x11a , ""DSLR-A560"" } , { 0x11b , ""DSLR-A580"" } , { 0x11c , ""NEX-C3"" } , { 0x11d , ""SLT-A35"" } , { 0x11e , ""SLT-A65V"" } , { 0x11f , ""SLT-A77V"" } , { 0x120 , ""NEX-5N"" } , { 0x121 , ""NEX-7"" } , { 0x122 , ""NEX-VG20E"" } , { 0x123 , ""SLT-A37"" } , { 0x124 , ""SLT-A57"" } , { 0x125 , ""NEX-F3"" } , { 0x126 , ""SLT-A99V"" } , { 0x127 , ""NEX-6"" } , { 0x128 , ""NEX-5R"" } , { 0x129 , ""DSC-RX100"" } , { 0x12a , ""DSC-RX1"" } , { 0x12b , ""NEX-VG900"" } , { 0x12c , ""NEX-VG30E"" } , { 0x12e , ""ILCE-3000"" } , { 0x12f , ""SLT-A58"" } , { 0x131 , ""NEX-3N"" } , { 0x132 , ""ILCE-7"" } , { 0x133 , ""NEX-5T"" } , { 0x134 , ""DSC-RX100M2"" } , { 0x135 , ""DSC-RX10"" } , { 0x136 , ""DSC-RX1R"" } , { 0x137 , ""ILCE-7R"" } , { 0x138 , ""ILCE-6000"" } , { 0x139 , ""ILCE-5000"" } , { 0x13d , ""DSC-RX100M3"" } , { 0x13e , ""ILCE-7S"" } , { 0x13f , ""ILCA-77M2"" } , { 0x153 , ""ILCE-5100"" } , { 0x154 , ""ILCE-7M2"" } , { 0x155 , ""DSC-RX100M4"" } , { 0x156 , ""DSC-RX10M2"" } , { 0x158 , ""DSC-RX1RM2"" } , { 0x15a , ""ILCE-QX1"" } , { 0x15b , ""ILCE-7RM2"" } , { 0x15e , ""ILCE-7SM2"" } , { 0x161 , ""ILCA-68"" } , { 0x162 , ""ILCA-99M2"" } , { 0x163 , ""DSC-RX10M3"" } , { 0x164 , ""DSC-RX100M5"" } , { 0x165 , ""ILCE-6300"" } , { 0x166 , ""ILCE-9"" } , { 0x168 , ""ILCE-6500"" } , { 0x16a , ""ILCE-7RM3"" } , { 0x16c , ""DSC-RX0"" } , { 0x16d , ""DSC-RX10M4"" } , } ; # ifdef LIBRAW_LIBRARY_BUILD static const libraw_custom_camera_t const_table [ ] # else static const struct { unsigned fsize ; ushort rw , rh ; uchar lm , tm , rm , bm , lf , cf , max , flags ; char t_make [ 10 ] , t_model [ 20 ] ; ushort offset ; } table [ ] # endif = { { 786432 , 1024 , 768 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""AVT"" , ""F-080C"" } , { 1447680 , 1392 , 1040 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""AVT"" , ""F-145C"" } , { 1920000 , 1600 , 1200 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""AVT"" , ""F-201C"" } , { 5067304 , 2588 , 1958 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""AVT"" , ""F-510C"" } , { 5067316 , 2588 , 1958 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""AVT"" , ""F-510C"" , 12 } , { 10134608 , 2588 , 1958 , 0 , 0 , 0 , 0 , 9 , 0x94 , 0 , 0 , ""AVT"" , ""F-510C"" } , { 10134620 , 2588 , 1958 , 0 , 0 , 0 , 0 , 9 , 0x94 , 0 , 0 , ""AVT"" , ""F-510C"" , 12 } , { 16157136 , 3272 , 2469 , 0 , 0 , 0 , 0 , 9 , 0x94 , 0 , 0 , ""AVT"" , ""F-810C"" } , { 15980544 , 3264 , 2448 , 0 , 0 , 0 , 0 , 8 , 0x61 , 0 , 1 , ""AgfaPhoto"" , ""DC-833m"" } , { 9631728 , 2532 , 1902 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""Alcatel"" , ""5035D"" } , { 31850496 , 4608 , 3456 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""GITUP"" , ""GIT2<S2SV_blank>4:3"" } , { 23887872 , 4608 , 2592 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""GITUP"" , ""GIT2<S2SV_blank>16:9"" } , { 32257024 , 4624 , 3488 , 8 , 2 , 16 , 2 , 0 , 0x94 , 0 , 0 , ""GITUP"" , ""GIT2P<S2SV_blank>4:3"" } , { 1540857 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""Samsung"" , ""S3"" } , { 2658304 , 1212 , 1096 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""LG"" , ""G3FrontMipi"" } , { 2842624 , 1296 , 1096 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""LG"" , ""G3FrontQCOM"" } , { 2969600 , 1976 , 1200 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""Xiaomi"" , ""MI3wMipi"" } , { 3170304 , 1976 , 1200 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""Xiaomi"" , ""MI3wQCOM"" } , { 3763584 , 1584 , 1184 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""I_Mobile"" , ""I_StyleQ6"" } , { 5107712 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""OmniVisi"" , ""UltraPixel1"" } , { 5382640 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""OmniVisi"" , ""UltraPixel2"" } , { 5664912 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""OmniVisi"" , ""4688"" } , { 5664912 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""OmniVisi"" , ""4688"" } , { 5364240 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""OmniVisi"" , ""4688"" } , { 6299648 , 2592 , 1944 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""OmniVisi"" , ""OV5648"" } , { 6721536 , 2592 , 1944 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 0 , ""OmniVisi"" , ""OV56482"" } , { 6746112 , 2592 , 1944 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 0 , ""HTC"" , ""OneSV"" } , { 9631728 , 2532 , 1902 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""Sony"" , ""5mp"" } , { 9830400 , 2560 , 1920 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""NGM"" , ""ForwardArt"" } , { 10186752 , 3264 , 2448 , 0 , 0 , 0 , 0 , 1 , 0x94 , 0 , 0 , ""Sony"" , ""IMX219-mipi<S2SV_blank>8mp"" } , { 10223360 , 2608 , 1944 , 0 , 0 , 0 , 0 , 96 , 0x16 , 0 , 0 , ""Sony"" , ""IMX"" } , { 10782464 , 3282 , 2448 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 0 , ""HTC"" , ""MyTouch4GSlide"" } , { 10788864 , 3282 , 2448 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 0 , ""Xperia"" , ""L"" } , { 15967488 , 3264 , 2446 , 0 , 0 , 0 , 0 , 96 , 0x16 , 0 , 0 , ""OmniVison"" , ""OV8850"" } , { 16224256 , 4208 , 3082 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""LG"" , ""G3MipiL"" } , { 16424960 , 4208 , 3120 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""IMX135"" , ""MipiL"" } , { 17326080 , 4164 , 3120 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""LG"" , ""G3LQCom"" } , { 17522688 , 4212 , 3120 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 0 , ""Sony"" , ""IMX135-QCOM"" } , { 19906560 , 4608 , 3456 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""Gione"" , ""E7mipi"" } , { 19976192 , 5312 , 2988 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""LG"" , ""G4"" } , { 20389888 , 4632 , 3480 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""Xiaomi"" , ""RedmiNote3Pro"" } , { 20500480 , 4656 , 3496 , 0 , 0 , 0 , 0 , 1 , 0x94 , 0 , 0 , ""Sony"" , ""IMX298-mipi<S2SV_blank>16mp"" } , { 21233664 , 4608 , 3456 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""Gione"" , ""E7qcom"" } , { 26023936 , 4192 , 3104 , 0 , 0 , 0 , 0 , 96 , 0x94 , 0 , 0 , ""THL"" , ""5000"" } , { 26257920 , 4208 , 3120 , 0 , 0 , 0 , 0 , 96 , 0x94 , 0 , 0 , ""Sony"" , ""IMX214"" } , { 26357760 , 4224 , 3120 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""OV"" , ""13860"" } , { 41312256 , 5248 , 3936 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""Meizu"" , ""MX4"" } , { 42923008 , 5344 , 4016 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""Sony"" , ""IMX230"" } , { 20137344 , 3664 , 2748 , 0 , 0 , 0 , 0 , 0x40 , 0x49 , 0 , 0 , ""Aptina"" , ""MT9J003"" , 0xffff } , { 2868726 , 1384 , 1036 , 0 , 0 , 0 , 0 , 64 , 0x49 , 0 , 8 , ""Baumer"" , ""TXG14"" , 1078 } , { 5298000 , 2400 , 1766 , 12 , 12 , 44 , 2 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SD300"" } , { 6553440 , 2664 , 1968 , 4 , 4 , 44 , 4 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A460"" } , { 6573120 , 2672 , 1968 , 12 , 8 , 44 , 0 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A610"" } , { 6653280 , 2672 , 1992 , 10 , 6 , 42 , 2 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A530"" } , { 7710960 , 2888 , 2136 , 44 , 8 , 4 , 0 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>S3<S2SV_blank>IS"" } , { 9219600 , 3152 , 2340 , 36 , 12 , 4 , 0 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A620"" } , { 9243240 , 3152 , 2346 , 12 , 7 , 44 , 13 , 40 , 0x49 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A470"" } , { 10341600 , 3336 , 2480 , 6 , 5 , 32 , 3 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A720<S2SV_blank>IS"" } , { 10383120 , 3344 , 2484 , 12 , 6 , 44 , 6 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A630"" } , { 12945240 , 3736 , 2772 , 12 , 6 , 52 , 6 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A640"" } , { 15636240 , 4104 , 3048 , 48 , 12 , 24 , 12 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A650"" } , { 15467760 , 3720 , 2772 , 6 , 12 , 30 , 0 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SX110<S2SV_blank>IS"" } , { 15534576 , 3728 , 2778 , 12 , 9 , 44 , 9 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SX120<S2SV_blank>IS"" } , { 18653760 , 4080 , 3048 , 24 , 12 , 24 , 12 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SX20<S2SV_blank>IS"" } , { 18763488 , 4104 , 3048 , 10 , 22 , 82 , 22 , 8 , 0x49 , 0 , 0 , ""Canon"" , ""PowerShot<S2SV_blank>D10"" } , { 19131120 , 4168 , 3060 , 92 , 16 , 4 , 1 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SX220<S2SV_blank>HS"" } , { 21936096 , 4464 , 3276 , 25 , 10 , 73 , 12 , 40 , 0x16 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SX30<S2SV_blank>IS"" } , { 24724224 , 4704 , 3504 , 8 , 16 , 56 , 8 , 40 , 0x49 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A3300<S2SV_blank>IS"" } , { 30858240 , 5248 , 3920 , 8 , 16 , 56 , 16 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""IXUS<S2SV_blank>160"" } , { 1976352 , 1632 , 1211 , 0 , 2 , 0 , 1 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""QV-2000UX"" } , { 3217760 , 2080 , 1547 , 0 , 0 , 10 , 1 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""QV-3*00EX"" } , { 6218368 , 2585 , 1924 , 0 , 0 , 9 , 0 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""QV-5700"" } , { 7816704 , 2867 , 2181 , 0 , 0 , 34 , 36 , 0 , 0x16 , 0 , 1 , ""Casio"" , ""EX-Z60"" } , { 2937856 , 1621 , 1208 , 0 , 0 , 1 , 0 , 0 , 0x94 , 7 , 13 , ""Casio"" , ""EX-S20"" } , { 4948608 , 2090 , 1578 , 0 , 0 , 32 , 34 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""EX-S100"" } , { 6054400 , 2346 , 1720 , 2 , 0 , 32 , 0 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""QV-R41"" } , { 7426656 , 2568 , 1928 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-P505"" } , { 7530816 , 2602 , 1929 , 0 , 0 , 22 , 0 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""QV-R51"" } , { 7542528 , 2602 , 1932 , 0 , 0 , 32 , 0 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""EX-Z50"" } , { 7562048 , 2602 , 1937 , 0 , 0 , 25 , 0 , 0 , 0x16 , 7 , 1 , ""Casio"" , ""EX-Z500"" } , { 7753344 , 2602 , 1986 , 0 , 0 , 32 , 26 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""EX-Z55"" } , { 9313536 , 2858 , 2172 , 0 , 0 , 14 , 30 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""EX-P600"" } , { 10834368 , 3114 , 2319 , 0 , 0 , 27 , 0 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-Z750"" } , { 10843712 , 3114 , 2321 , 0 , 0 , 25 , 0 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-Z75"" } , { 10979200 , 3114 , 2350 , 0 , 0 , 32 , 32 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""EX-P700"" } , { 12310144 , 3285 , 2498 , 0 , 0 , 6 , 30 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-Z850"" } , { 12489984 , 3328 , 2502 , 0 , 0 , 47 , 35 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-Z8"" } , { 15499264 , 3754 , 2752 , 0 , 0 , 82 , 0 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-Z1050"" } , { 18702336 , 4096 , 3044 , 0 , 0 , 24 , 0 , 80 , 0x94 , 7 , 1 , ""Casio"" , ""EX-ZR100"" } , { 7684000 , 2260 , 1700 , 0 , 0 , 0 , 0 , 13 , 0x94 , 0 , 1 , ""Casio"" , ""QV-4000"" } , { 787456 , 1024 , 769 , 0 , 1 , 0 , 0 , 0 , 0x49 , 0 , 0 , ""Creative"" , ""PC-CAM<S2SV_blank>600"" } , { 28829184 , 4384 , 3288 , 0 , 0 , 0 , 0 , 36 , 0x61 , 0 , 0 , ""DJI"" } , { 15151104 , 4608 , 3288 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""Matrix"" } , { 3840000 , 1600 , 1200 , 0 , 0 , 0 , 0 , 65 , 0x49 , 0 , 0 , ""Foculus"" , ""531C"" } , { 307200 , 640 , 480 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""Generic"" } , { 62464 , 256 , 244 , 1 , 1 , 6 , 1 , 0 , 0x8d , 0 , 0 , ""Kodak"" , ""DC20"" } , { 124928 , 512 , 244 , 1 , 1 , 10 , 1 , 0 , 0x8d , 0 , 0 , ""Kodak"" , ""DC20"" } , { 1652736 , 1536 , 1076 , 0 , 52 , 0 , 0 , 0 , 0x61 , 0 , 0 , ""Kodak"" , ""DCS200"" } , { 4159302 , 2338 , 1779 , 1 , 33 , 1 , 2 , 0 , 0x94 , 0 , 0 , ""Kodak"" , ""C330"" } , { 4162462 , 2338 , 1779 , 1 , 33 , 1 , 2 , 0 , 0x94 , 0 , 0 , ""Kodak"" , ""C330"" , 3160 } , { 2247168 , 1232 , 912 , 0 , 0 , 16 , 0 , 0 , 0x00 , 0 , 0 , ""Kodak"" , ""C330"" } , { 3370752 , 1232 , 912 , 0 , 0 , 16 , 0 , 0 , 0x00 , 0 , 0 , ""Kodak"" , ""C330"" } , { 6163328 , 2864 , 2152 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""Kodak"" , ""C603"" } , { 6166488 , 2864 , 2152 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""Kodak"" , ""C603"" , 3160 } , { 460800 , 640 , 480 , 0 , 0 , 0 , 0 , 0 , 0x00 , 0 , 0 , ""Kodak"" , ""C603"" } , { 9116448 , 2848 , 2134 , 0 , 0 , 0 , 0 , 0 , 0x00 , 0 , 0 , ""Kodak"" , ""C603"" } , { 12241200 , 4040 , 3030 , 2 , 0 , 0 , 13 , 0 , 0x49 , 0 , 0 , ""Kodak"" , ""12MP"" } , { 12272756 , 4040 , 3030 , 2 , 0 , 0 , 13 , 0 , 0x49 , 0 , 0 , ""Kodak"" , ""12MP"" , 31556 } , { 18000000 , 4000 , 3000 , 0 , 0 , 0 , 0 , 0 , 0x00 , 0 , 0 , ""Kodak"" , ""12MP"" } , { 614400 , 640 , 480 , 0 , 3 , 0 , 0 , 64 , 0x94 , 0 , 0 , ""Kodak"" , ""KAI-0340"" } , { 15360000 , 3200 , 2400 , 0 , 0 , 0 , 0 , 96 , 0x16 , 0 , 0 , ""Lenovo"" , ""A820"" } , { 3884928 , 1608 , 1207 , 0 , 0 , 0 , 0 , 96 , 0x16 , 0 , 0 , ""Micron"" , ""2010"" , 3212 } , { 1138688 , 1534 , 986 , 0 , 0 , 0 , 0 , 0 , 0x61 , 0 , 0 , ""Minolta"" , ""RD175"" , 513 } , { 1581060 , 1305 , 969 , 0 , 0 , 18 , 6 , 6 , 0x1e , 4 , 1 , ""Nikon"" , ""E900"" } , { 2465792 , 1638 , 1204 , 0 , 0 , 22 , 1 , 6 , 0x4b , 5 , 1 , ""Nikon"" , ""E950"" } , { 2940928 , 1616 , 1213 , 0 , 0 , 0 , 7 , 30 , 0x94 , 0 , 1 , ""Nikon"" , ""E2100"" } , { 4771840 , 2064 , 1541 , 0 , 0 , 0 , 1 , 6 , 0xe1 , 0 , 1 , ""Nikon"" , ""E990"" } , { 4775936 , 2064 , 1542 , 0 , 0 , 0 , 0 , 30 , 0x94 , 0 , 1 , ""Nikon"" , ""E3700"" } , { 5865472 , 2288 , 1709 , 0 , 0 , 0 , 1 , 6 , 0xb4 , 0 , 1 , ""Nikon"" , ""E4500"" } , { 5869568 , 2288 , 1710 , 0 , 0 , 0 , 0 , 6 , 0x16 , 0 , 1 , ""Nikon"" , ""E4300"" } , { 7438336 , 2576 , 1925 , 0 , 0 , 0 , 1 , 6 , 0xb4 , 0 , 1 , ""Nikon"" , ""E5000"" } , { 8998912 , 2832 , 2118 , 0 , 0 , 0 , 0 , 30 , 0x94 , 7 , 1 , ""Nikon"" , ""COOLPIX<S2SV_blank>S6"" } , { 5939200 , 2304 , 1718 , 0 , 0 , 0 , 0 , 30 , 0x16 , 0 , 0 , ""Olympus"" , ""C770UZ"" } , { 3178560 , 2064 , 1540 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 1 , ""Pentax"" , ""Optio<S2SV_blank>S"" } , { 4841984 , 2090 , 1544 , 0 , 0 , 22 , 0 , 0 , 0x94 , 7 , 1 , ""Pentax"" , ""Optio<S2SV_blank>S"" } , { 6114240 , 2346 , 1737 , 0 , 0 , 22 , 0 , 0 , 0x94 , 7 , 1 , ""Pentax"" , ""Optio<S2SV_blank>S4"" } , { 10702848 , 3072 , 2322 , 0 , 0 , 0 , 21 , 30 , 0x94 , 0 , 1 , ""Pentax"" , ""Optio<S2SV_blank>750Z"" } , { 4147200 , 1920 , 1080 , 0 , 0 , 0 , 0 , 0 , 0x49 , 0 , 0 , ""Photron"" , ""BC2-HD"" } , { 4151666 , 1920 , 1080 , 0 , 0 , 0 , 0 , 0 , 0x49 , 0 , 0 , ""Photron"" , ""BC2-HD"" , 8 } , { 13248000 , 2208 , 3000 , 0 , 0 , 0 , 0 , 13 , 0x61 , 0 , 0 , ""Pixelink"" , ""A782"" } , { 6291456 , 2048 , 1536 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""RoverShot"" , ""3320AF"" } , { 311696 , 644 , 484 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 8 , ""ST<S2SV_blank>Micro"" , ""STV680<S2SV_blank>VGA"" } , { 16098048 , 3288 , 2448 , 0 , 0 , 24 , 0 , 9 , 0x94 , 0 , 1 , ""Samsung"" , ""S85"" } , { 16215552 , 3312 , 2448 , 0 , 0 , 48 , 0 , 9 , 0x94 , 0 , 1 , ""Samsung"" , ""S85"" } , { 20487168 , 3648 , 2808 , 0 , 0 , 0 , 0 , 13 , 0x94 , 5 , 1 , ""Samsung"" , ""WB550"" } , { 24000000 , 4000 , 3000 , 0 , 0 , 0 , 0 , 13 , 0x94 , 5 , 1 , ""Samsung"" , ""WB550"" } , { 12582980 , 3072 , 2048 , 0 , 0 , 0 , 0 , 33 , 0x61 , 0 , 0 , ""Sinar"" , """" , 68 } , { 33292868 , 4080 , 4080 , 0 , 0 , 0 , 0 , 33 , 0x61 , 0 , 0 , ""Sinar"" , """" , 68 } , { 44390468 , 4080 , 5440 , 0 , 0 , 0 , 0 , 33 , 0x61 , 0 , 0 , ""Sinar"" , """" , 68 } , { 1409024 , 1376 , 1024 , 0 , 0 , 1 , 0 , 0 , 0x49 , 0 , 0 , ""Sony"" , ""XCD-SX910CR"" } , { 2818048 , 1376 , 1024 , 0 , 0 , 1 , 0 , 97 , 0x49 , 0 , 0 , ""Sony"" , ""XCD-SX910CR"" } , } ; # ifdef LIBRAW_LIBRARY_BUILD libraw_custom_camera_t table [ 64 + sizeof ( const_table ) / sizeof ( const_table [ 0 ] ) ] ; # endif static const char * corp [ ] = { ""AgfaPhoto"" , ""Canon"" , ""Casio"" , ""Epson"" , ""Fujifilm"" , ""Mamiya"" , ""Minolta"" , ""Motorola"" , ""Kodak"" , ""Konica"" , ""Leica"" , ""Nikon"" , ""Nokia"" , ""Olympus"" , ""Pentax"" , ""Phase<S2SV_blank>One"" , ""Ricoh"" , ""Samsung"" , ""Sigma"" , ""Sinar"" , ""Sony"" } ; # ifdef LIBRAW_LIBRARY_BUILD char head [ 64 ] , * cp ; # else char head [ 32 ] , * cp ; # endif int hlen , flen , fsize , zero_fsize = 1 , i , c ; struct jhead jh ; # ifdef LIBRAW_LIBRARY_BUILD unsigned camera_count = parse_custom_cameras ( 64 , table , imgdata . params . custom_camera_strings ) ; for ( int q = 0 ; q < sizeof ( const_table ) / sizeof ( const_table [ 0 ] ) ; q ++ ) memmove ( & table [ q + camera_count ] , & const_table [ q ] , sizeof ( const_table [ 0 ] ) ) ; camera_count += sizeof ( const_table ) / sizeof ( const_table [ 0 ] ) ; # endif tiff_flip = flip = filters = UINT_MAX ; raw_height = raw_width = fuji_width = fuji_layout = cr2_slice [ 0 ] = 0 ; maximum = height = width = top_margin = left_margin = 0 ; cdesc [ 0 ] = desc [ 0 ] = artist [ 0 ] = make [ 0 ] = model [ 0 ] = model2 [ 0 ] = 0 ; iso_speed = shutter = aperture = focal_len = unique_id = 0 ; tiff_nifds = 0 ; memset ( tiff_ifd , 0 , sizeof tiff_ifd ) ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . other . CameraTemperature = imgdata . other . SensorTemperature = imgdata . other . SensorTemperature2 = imgdata . other . LensTemperature = imgdata . other . AmbientTemperature = imgdata . other . BatteryTemperature = imgdata . other . exifAmbientTemperature = - 1000.0f ; for ( i = 0 ; i < LIBRAW_IFD_MAXCOUNT ; i ++ ) { tiff_ifd [ i ] . dng_color [ 0 ] . illuminant = tiff_ifd [ i ] . dng_color [ 1 ] . illuminant = 0xffff ; for ( int c = 0 ; c < 4 ; c ++ ) tiff_ifd [ i ] . dng_levels . analogbalance [ c ] = 1.0f ; } # endif memset ( gpsdata , 0 , sizeof gpsdata ) ; memset ( cblack , 0 , sizeof cblack ) ; memset ( white , 0 , sizeof white ) ; memset ( mask , 0 , sizeof mask ) ; thumb_offset = thumb_length = thumb_width = thumb_height = 0 ; load_raw = thumb_load_raw = 0 ; write_thumb = & CLASS jpeg_thumb ; data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0 ; kodak_cbpp = zero_after_ff = dng_version = load_flags = 0 ; timestamp = shot_order = tiff_samples = black = is_foveon = 0 ; mix_green = profile_length = data_error = zero_is_bad = 0 ; pixel_aspect = is_raw = raw_color = 1 ; tile_width = tile_length = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { cam_mul [ i ] = i == 1 ; pre_mul [ i ] = i < 3 ; FORC3 cmatrix [ c ] [ i ] = 0 ; FORC3 rgb_cam [ c ] [ i ] = c == i ; } colors = 3 ; for ( i = 0 ; i < 0x10000 ; i ++ ) curve [ i ] = i ; order = get2 ( ) ; hlen = get4 ( ) ; fseek ( ifp , 0 , SEEK_SET ) ; # ifdef LIBRAW_LIBRARY_BUILD fread ( head , 1 , 64 , ifp ) ; libraw_internal_data . unpacker_data . lenRAFData = libraw_internal_data . unpacker_data . posRAFData = 0 ; # else fread ( head , 1 , 32 , ifp ) ; # endif fseek ( ifp , 0 , SEEK_END ) ; flen = fsize = ftell ( ifp ) ; if ( ( cp = ( char * ) memmem ( head , 32 , ( char * ) ""MMMM"" , 4 ) ) || ( cp = ( char * ) memmem ( head , 32 , ( char * ) ""IIII"" , 4 ) ) ) { parse_phase_one ( cp - head ) ; if ( cp - head && parse_tiff ( 0 ) ) apply_tiff ( ) ; } else if ( order == 0x4949 || order == 0x4d4d ) { if ( ! memcmp ( head + 6 , ""HEAPCCDR"" , 8 ) ) { data_offset = hlen ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ; # endif parse_ciff ( hlen , flen - hlen , 0 ) ; load_raw = & CLASS canon_load_raw ; } else if ( parse_tiff ( 0 ) ) apply_tiff ( ) ; } else if ( ! memcmp ( head , ""\\xff\\xd8\\xff\\xe1"" , 4 ) && ! memcmp ( head + 6 , ""Exif"" , 4 ) ) { fseek ( ifp , 4 , SEEK_SET ) ; data_offset = 4 + get2 ( ) ; fseek ( ifp , data_offset , SEEK_SET ) ; if ( fgetc ( ifp ) != 0xff ) parse_tiff ( 12 ) ; thumb_offset = 0 ; } else if ( ! memcmp ( head + 25 , ""ARECOYK"" , 7 ) ) { strcpy ( make , ""Contax"" ) ; strcpy ( model , ""N<S2SV_blank>Digital"" ) ; fseek ( ifp , 33 , SEEK_SET ) ; get_timestamp ( 1 ) ; fseek ( ifp , 52 , SEEK_SET ) ; switch ( get4 ( ) ) { case 7 : iso_speed = 25 ; break ; case 8 : iso_speed = 32 ; break ; case 9 : iso_speed = 40 ; break ; case 10 : iso_speed = 50 ; break ; case 11 : iso_speed = 64 ; break ; case 12 : iso_speed = 80 ; break ; case 13 : iso_speed = 100 ; break ; case 14 : iso_speed = 125 ; break ; case 15 : iso_speed = 160 ; break ; case 16 : iso_speed = 200 ; break ; case 17 : iso_speed = 250 ; break ; case 18 : iso_speed = 320 ; break ; case 19 : iso_speed = 400 ; break ; } shutter = powf64 ( 2.0f , ( ( ( float ) get4 ( ) ) / 8.0f ) ) / 16000.0f ; FORC4 cam_mul [ c ^ ( c >> 1 ) ] = get4 ( ) ; fseek ( ifp , 88 , SEEK_SET ) ; aperture = powf64 ( 2.0f , ( ( float ) get4 ( ) ) / 16.0f ) ; fseek ( ifp , 112 , SEEK_SET ) ; focal_len = get4 ( ) ; # ifdef LIBRAW_LIBRARY_BUILD fseek ( ifp , 104 , SEEK_SET ) ; imgdata . lens . makernotes . MaxAp4CurFocal = powf64 ( 2.0f , ( ( float ) get4 ( ) ) / 16.0f ) ; fseek ( ifp , 124 , SEEK_SET ) ; stmread ( imgdata . lens . makernotes . Lens , 32 , ifp ) ; imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_Contax_N ; if ( imgdata . lens . makernotes . Lens [ 0 ] ) imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_Contax_N ; # endif } else if ( ! strcmp ( head , ""PXN"" ) ) { strcpy ( make , ""Logitech"" ) ; strcpy ( model , ""Fotoman<S2SV_blank>Pixtura"" ) ; } else if ( ! strcmp ( head , ""qktk"" ) ) { strcpy ( make , ""Apple"" ) ; strcpy ( model , ""QuickTake<S2SV_blank>100"" ) ; load_raw = & CLASS quicktake_100_load_raw ; } else if ( ! strcmp ( head , ""qktn"" ) ) { strcpy ( make , ""Apple"" ) ; strcpy ( model , ""QuickTake<S2SV_blank>150"" ) ; load_raw = & CLASS kodak_radc_load_raw ; } else if ( ! memcmp ( head , ""FUJIFILM"" , 8 ) ) { # ifdef LIBRAW_LIBRARY_BUILD strcpy ( model , head + 0x1c ) ; memcpy ( model2 , head + 0x3c , 4 ) ; model2 [ 4 ] = 0 ; # endif fseek ( ifp , 84 , SEEK_SET ) ; thumb_offset = get4 ( ) ; thumb_length = get4 ( ) ; fseek ( ifp , 92 , SEEK_SET ) ; parse_fuji ( get4 ( ) ) ; if ( thumb_offset > 120 ) { fseek ( ifp , 120 , SEEK_SET ) ; is_raw += ( i = get4 ( ) ) ? 1 : 0 ; if ( is_raw == 2 && shot_select ) parse_fuji ( i ) ; } load_raw = & CLASS unpacked_load_raw ; fseek ( ifp , 100 + 28 * ( shot_select > 0 ) , SEEK_SET ) ; parse_tiff ( data_offset = get4 ( ) ) ; parse_tiff ( thumb_offset + 12 ) ; apply_tiff ( ) ; } else if ( ! memcmp ( head , ""RIFF"" , 4 ) ) { fseek ( ifp , 0 , SEEK_SET ) ; parse_riff ( ) ; } else if ( ! memcmp ( head + 4 , ""ftypqt<S2SV_blank><S2SV_blank><S2SV_blank>"" , 9 ) ) { fseek ( ifp , 0 , SEEK_SET ) ; parse_qt ( fsize ) ; is_raw = 0 ; } else if ( ! memcmp ( head , ""\\0\\001\\0\\001\\0@"" , 6 ) ) { fseek ( ifp , 6 , SEEK_SET ) ; fread ( make , 1 , 8 , ifp ) ; fread ( model , 1 , 8 , ifp ) ; fread ( model2 , 1 , 16 , ifp ) ; data_offset = get2 ( ) ; get2 ( ) ; raw_width = get2 ( ) ; raw_height = get2 ( ) ; load_raw = & CLASS nokia_load_raw ; filters = 0x61616161 ; } else if ( ! memcmp ( head , ""NOKIARAW"" , 8 ) ) { strcpy ( make , ""NOKIA"" ) ; order = 0x4949 ; fseek ( ifp , 300 , SEEK_SET ) ; data_offset = get4 ( ) ; i = get4 ( ) ; width = get2 ( ) ; height = get2 ( ) ; # ifdef LIBRAW_LIBRARY_BUILD if ( width < 1 || width > 16000 || height < 1 || height > 16000 || i < ( width * height ) || i > ( 2 * width * height ) ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; # endif switch ( tiff_bps = i * 8 / ( width * height ) ) { case 8 : load_raw = & CLASS eight_bit_load_raw ; break ; case 10 : load_raw = & CLASS nokia_load_raw ; } raw_height = height + ( top_margin = i / ( width * tiff_bps / 8 ) - height ) ; mask [ 0 ] [ 3 ] = 1 ; filters = 0x61616161 ; } else if ( ! memcmp ( head , ""ARRI"" , 4 ) ) { order = 0x4949 ; fseek ( ifp , 20 , SEEK_SET ) ; width = get4 ( ) ; height = get4 ( ) ; strcpy ( make , ""ARRI"" ) ; fseek ( ifp , 668 , SEEK_SET ) ; fread ( model , 1 , 64 , ifp ) ; data_offset = 4096 ; load_raw = & CLASS packed_load_raw ; load_flags = 88 ; filters = 0x61616161 ; } else if ( ! memcmp ( head , ""XPDS"" , 4 ) ) { order = 0x4949 ; fseek ( ifp , 0x800 , SEEK_SET ) ; fread ( make , 1 , 41 , ifp ) ; raw_height = get2 ( ) ; raw_width = get2 ( ) ; fseek ( ifp , 56 , SEEK_CUR ) ; fread ( model , 1 , 30 , ifp ) ; data_offset = 0x10000 ; load_raw = & CLASS canon_rmf_load_raw ; gamma_curve ( 0 , 12.25 , 1 , 1023 ) ; } else if ( ! memcmp ( head + 4 , ""RED1"" , 4 ) ) { strcpy ( make , ""Red"" ) ; strcpy ( model , ""One"" ) ; parse_redcine ( ) ; load_raw = & CLASS redcine_load_raw ; gamma_curve ( 1 / 2.4 , 12.92 , 1 , 4095 ) ; filters = 0x49494949 ; } else if ( ! memcmp ( head , ""DSC-Image"" , 9 ) ) parse_rollei ( ) ; else if ( ! memcmp ( head , ""PWAD"" , 4 ) ) parse_sinar_ia ( ) ; else if ( ! memcmp ( head , ""\\0MRM"" , 4 ) ) parse_minolta ( 0 ) ; else if ( ! memcmp ( head , ""FOVb"" , 4 ) ) { # ifdef LIBRAW_LIBRARY_BUILD parse_x3f ( ) ; # endif } else if ( ! memcmp ( head , ""CI"" , 2 ) ) parse_cine ( ) ; if ( make [ 0 ] == 0 ) # ifdef LIBRAW_LIBRARY_BUILD for ( zero_fsize = i = 0 ; i < camera_count ; i ++ ) # else for ( zero_fsize = i = 0 ; i < sizeof table / sizeof * table ; i ++ ) # endif if ( fsize == table [ i ] . fsize ) { strcpy ( make , table [ i ] . t_make ) ; # ifdef LIBRAW_LIBRARY_BUILD if ( ! strncmp ( make , ""Canon"" , 5 ) ) { imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ; } # endif strcpy ( model , table [ i ] . t_model ) ; flip = table [ i ] . flags >> 2 ; zero_is_bad = table [ i ] . flags & 2 ; if ( table [ i ] . flags & 1 ) parse_external_jpeg ( ) ; data_offset = table [ i ] . offset == 0xffff ? 0 : table [ i ] . offset ; raw_width = table [ i ] . rw ; raw_height = table [ i ] . rh ; left_margin = table [ i ] . lm ; top_margin = table [ i ] . tm ; width = raw_width - left_margin - table [ i ] . rm ; height = raw_height - top_margin - table [ i ] . bm ; filters = 0x1010101 * table [ i ] . cf ; colors = 4 - ! ( ( filters & filters >> 1 ) & 0x5555 ) ; load_flags = table [ i ] . lf ; switch ( tiff_bps = ( fsize - data_offset ) * 8 / ( raw_width * raw_height ) ) { case 6 : load_raw = & CLASS minolta_rd175_load_raw ; break ; case 8 : load_raw = & CLASS eight_bit_load_raw ; break ; case 10 : if ( ( fsize - data_offset ) / raw_height * 3 >= raw_width * 4 ) { load_raw = & CLASS android_loose_load_raw ; break ; } else if ( load_flags & 1 ) { load_raw = & CLASS android_tight_load_raw ; break ; } case 12 : load_flags |= 128 ; load_raw = & CLASS packed_load_raw ; break ; case 16 : order = 0x4949 | 0x404 * ( load_flags & 1 ) ; tiff_bps -= load_flags >> 4 ; tiff_bps -= load_flags = load_flags >> 1 & 7 ; load_raw = table [ i ] . offset == 0xffff ? & CLASS unpacked_load_raw_reversed : & CLASS unpacked_load_raw ; } maximum = ( 1 << tiff_bps ) - ( 1 << table [ i ] . max ) ; break ; } if ( zero_fsize ) fsize = 0 ; if ( make [ 0 ] == 0 ) parse_smal ( 0 , flen ) ; if ( make [ 0 ] == 0 ) { parse_jpeg ( 0 ) ; fseek ( ifp , 0 , SEEK_END ) ; int sz = ftell ( ifp ) ; # ifdef LIBRAW_LIBRARY_BUILD if ( ! strncmp ( model , ""RP_imx219"" , 9 ) && sz >= 0x9cb600 && ! fseek ( ifp , - 0x9cb600 , SEEK_END ) && fread ( head , 1 , 0x20 , ifp ) && ! strncmp ( head , ""BRCM"" , 4 ) ) { strcpy ( make , ""Broadcom"" ) ; strcpy ( model , ""RPi<S2SV_blank>IMX219"" ) ; if ( raw_height > raw_width ) flip = 5 ; data_offset = ftell ( ifp ) + 0x8000 - 0x20 ; parse_broadcom ( ) ; black = 66 ; maximum = 0x3ff ; load_raw = & CLASS broadcom_load_raw ; thumb_offset = 0 ; thumb_length = sz - 0x9cb600 - 1 ; } else if ( ! ( strncmp ( model , ""ov5647"" , 6 ) && strncmp ( model , ""RP_OV5647"" , 9 ) ) && sz >= 0x61b800 && ! fseek ( ifp , - 0x61b800 , SEEK_END ) && fread ( head , 1 , 0x20 , ifp ) && ! strncmp ( head , ""BRCM"" , 4 ) ) { strcpy ( make , ""Broadcom"" ) ; if ( ! strncmp ( model , ""ov5647"" , 6 ) ) strcpy ( model , ""RPi<S2SV_blank>OV5647<S2SV_blank>v.1"" ) ; else strcpy ( model , ""RPi<S2SV_blank>OV5647<S2SV_blank>v.2"" ) ; if ( raw_height > raw_width ) flip = 5 ; data_offset = ftell ( ifp ) + 0x8000 - 0x20 ; parse_broadcom ( ) ; black = 16 ; maximum = 0x3ff ; load_raw = & CLASS broadcom_load_raw ; thumb_offset = 0 ; thumb_length = sz - 0x61b800 - 1 ; # else if ( ! ( strncmp ( model , ""ov"" , 2 ) && strncmp ( model , ""RP_OV"" , 5 ) ) && sz >= 6404096 && ! fseek ( ifp , - 6404096 , SEEK_END ) && fread ( head , 1 , 32 , ifp ) && ! strcmp ( head , ""BRCMn"" ) ) { strcpy ( make , ""OmniVision"" ) ; data_offset = ftell ( ifp ) + 0x8000 - 32 ; width = raw_width ; raw_width = 2611 ; load_raw = & CLASS nokia_load_raw ; filters = 0x16161616 ; # endif } else is_raw = 0 ; } # ifdef LIBRAW_LIBRARY_BUILD desc [ 511 ] = artist [ 63 ] = make [ 63 ] = model [ 63 ] = model2 [ 63 ] = 0 ; # endif for ( i = 0 ; i < sizeof corp / sizeof * corp ; i ++ ) if ( strcasestr ( make , corp [ i ] ) ) strcpy ( make , corp [ i ] ) ; if ( ( ! strncmp ( make , ""Kodak"" , 5 ) || ! strncmp ( make , ""Leica"" , 5 ) ) && ( ( cp = strcasestr ( model , ""<S2SV_blank>DIGITAL<S2SV_blank>CAMERA"" ) ) || ( cp = strstr ( model , ""FILE<S2SV_blank>VERSION"" ) ) ) ) * cp = 0 ; if ( ! strncasecmp ( model , ""PENTAX"" , 6 ) ) strcpy ( make , ""Pentax"" ) ; # ifdef LIBRAW_LIBRARY_BUILD remove_trailing_spaces ( make , sizeof ( make ) ) ; remove_trailing_spaces ( model , sizeof ( model ) ) ; # else cp = make + strlen ( make ) ; while ( * -- cp == '<S2SV_blank>' ) * cp = 0 ; cp = model + strlen ( model ) ; while ( * -- cp == '<S2SV_blank>' ) * cp = 0 ; # endif i = strbuflen ( make ) ; if ( ! strncasecmp ( model , make , i ) && model [ i ++ ] == '<S2SV_blank>' ) memmove ( model , model + i , 64 - i ) ; if ( ! strncmp ( model , ""FinePix<S2SV_blank>"" , 8 ) ) strcpy ( model , model + 8 ) ; if ( ! strncmp ( model , ""Digital<S2SV_blank>Camera<S2SV_blank>"" , 15 ) ) strcpy ( model , model + 15 ) ; desc [ 511 ] = artist [ 63 ] = make [ 63 ] = model [ 63 ] = model2 [ 63 ] = 0 ; if ( ! is_raw ) goto notraw ; if ( ! height ) height = raw_height ; if ( ! width ) width = raw_width ; if ( height == 2624 && width == 3936 ) { height = 2616 ; width = 3896 ; } if ( height == 3136 && width == 4864 ) { height = 3124 ; width = 4688 ; filters = 0x16161616 ; } if ( width == 4352 && ( ! strcmp ( model , ""K-r"" ) || ! strcmp ( model , ""K-x"" ) ) ) { width = 4309 ; filters = 0x16161616 ; } if ( width >= 4960 && ! strncmp ( model , ""K-5"" , 3 ) ) { left_margin = 10 ; width = 4950 ; filters = 0x16161616 ; } if ( width == 6080 && ! strcmp ( model , ""K-70"" ) ) { height = 4016 ; top_margin = 32 ; width = 6020 ; left_margin = 60 ; } if ( width == 4736 && ! strcmp ( model , ""K-7"" ) ) { height = 3122 ; width = 4684 ; filters = 0x16161616 ; top_margin = 2 ; } if ( width == 6080 && ! strcmp ( model , ""K-3<S2SV_blank>II"" ) ) { left_margin = 4 ; width = 6040 ; } if ( width == 6112 && ! strcmp ( model , ""KP"" ) ) { left_margin = 54 ; top_margin = 28 ; width = 6028 ; height = raw_height - top_margin ; } if ( width == 6080 && ! strcmp ( model , ""K-3"" ) ) { left_margin = 4 ; width = 6040 ; } if ( width == 7424 && ! strcmp ( model , ""645D"" ) ) { height = 5502 ; width = 7328 ; filters = 0x61616161 ; top_margin = 29 ; left_margin = 48 ; } if ( height == 3014 && width == 4096 ) width = 4014 ; if ( dng_version ) { if ( filters == UINT_MAX ) filters = 0 ; if ( filters ) is_raw *= tiff_samples ; else colors = tiff_samples ; switch ( tiff_compress ) { case 0 : case 1 : load_raw = & CLASS packed_dng_load_raw ; break ; case 7 : load_raw = & CLASS lossless_dng_load_raw ; break ; # ifdef LIBRAW_LIBRARY_BUILD case 8 : load_raw = & CLASS deflate_dng_load_raw ; break ; # endif case 34892 : load_raw = & CLASS lossy_dng_load_raw ; break ; default : load_raw = 0 ; } if ( ! strncmp ( make , ""Canon"" , 5 ) && unique_id ) { for ( i = 0 ; i < sizeof unique / sizeof * unique ; i ++ ) if ( unique_id == 0x80000000 + unique [ i ] . id ) { strcpy ( model , unique [ i ] . t_model ) ; break ; } } if ( ! strncasecmp ( make , ""Sony"" , 4 ) && unique_id ) { for ( i = 0 ; i < sizeof sonique / sizeof * sonique ; i ++ ) if ( unique_id == sonique [ i ] . id ) { strcpy ( model , sonique [ i ] . t_model ) ; break ; } } goto dng_skip ; } if ( ! strncmp ( make , ""Canon"" , 5 ) && ! fsize && tiff_bps != 15 ) { if ( ! load_raw ) load_raw = & CLASS lossless_jpeg_load_raw ; for ( i = 0 ; i < sizeof canon / sizeof * canon ; i ++ ) if ( raw_width == canon [ i ] [ 0 ] && raw_height == canon [ i ] [ 1 ] ) { width = raw_width - ( left_margin = canon [ i ] [ 2 ] ) ; height = raw_height - ( top_margin = canon [ i ] [ 3 ] ) ; width -= canon [ i ] [ 4 ] ; height -= canon [ i ] [ 5 ] ; mask [ 0 ] [ 1 ] = canon [ i ] [ 6 ] ; mask [ 0 ] [ 3 ] = - canon [ i ] [ 7 ] ; mask [ 1 ] [ 1 ] = canon [ i ] [ 8 ] ; mask [ 1 ] [ 3 ] = - canon [ i ] [ 9 ] ; if ( canon [ i ] [ 10 ] ) filters = canon [ i ] [ 10 ] * 0x01010101 ; } if ( ( unique_id | 0x20000 ) == 0x2720000 ) { left_margin = 8 ; top_margin = 16 ; } } if ( ! strncmp ( make , ""Canon"" , 5 ) && unique_id ) { for ( i = 0 ; i < sizeof unique / sizeof * unique ; i ++ ) if ( unique_id == 0x80000000 + unique [ i ] . id ) { adobe_coeff ( ""Canon"" , unique [ i ] . t_model ) ; strcpy ( model , unique [ i ] . t_model ) ; } } if ( ! strncasecmp ( make , ""Sony"" , 4 ) && unique_id ) { for ( i = 0 ; i < sizeof sonique / sizeof * sonique ; i ++ ) if ( unique_id == sonique [ i ] . id ) { adobe_coeff ( ""Sony"" , sonique [ i ] . t_model ) ; strcpy ( model , sonique [ i ] . t_model ) ; } } if ( ! strncmp ( make , ""Nikon"" , 5 ) ) { if ( ! load_raw ) load_raw = & CLASS packed_load_raw ; if ( model [ 0 ] == 'E' ) load_flags |= ! data_offset << 2 | 2 ; } if ( ! strcmp ( model , ""KAI-0340"" ) && find_green ( 16 , 16 , 3840 , 5120 ) < 25 ) { height = 480 ; top_margin = filters = 0 ; strcpy ( model , ""C603"" ) ; } # ifndef LIBRAW_LIBRARY_BUILD if ( ! strcmp ( make , ""Sony"" ) && raw_width > 3888 && ! black && ! cblack [ 0 ] ) black = 128 << ( tiff_bps - 12 ) ; # else if ( ! strcmp ( make , ""Sony"" ) && raw_width > 3888 && ! black && ! cblack [ 0 ] ) black = ( load_raw == & LibRaw : : sony_arw2_load_raw ) ? 512 : ( 128 << ( tiff_bps - 12 ) ) ; # endif if ( is_foveon ) { if ( height * 2 < width ) pixel_aspect = 0.5 ; if ( height > width ) pixel_aspect = 2 ; filters = 0 ; } else if ( ! strncmp ( make , ""Pentax"" , 6 ) && ! strncmp ( model , ""K-1"" , 3 ) ) { top_margin = 18 ; height = raw_height - top_margin ; if ( raw_width == 7392 ) { left_margin = 6 ; width = 7376 ; } } else if ( ! strncmp ( make , ""Canon"" , 5 ) && tiff_bps == 15 ) { switch ( width ) { case 3344 : width -= 66 ; case 3872 : width -= 6 ; } if ( height > width ) { SWAP ( height , width ) ; SWAP ( raw_height , raw_width ) ; } if ( width == 7200 && height == 3888 ) { raw_width = width = 6480 ; raw_height = height = 4320 ; } filters = 0 ; tiff_samples = colors = 3 ; load_raw = & CLASS canon_sraw_load_raw ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>600"" ) ) { height = 613 ; width = 854 ; raw_width = 896 ; colors = 4 ; filters = 0xe1e4e1e4 ; load_raw = & CLASS canon_600_load_raw ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>A5"" ) || ! strcmp ( model , ""PowerShot<S2SV_blank>A5<S2SV_blank>Zoom"" ) ) { height = 773 ; width = 960 ; raw_width = 992 ; pixel_aspect = 256 / 235.0 ; filters = 0x1e4e1e4e ; goto canon_a5 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>A50"" ) ) { height = 968 ; width = 1290 ; raw_width = 1320 ; filters = 0x1b4e4b1e ; goto canon_a5 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>Pro70"" ) ) { height = 1024 ; width = 1552 ; filters = 0x1e4b4e1b ; canon_a5 : colors = 4 ; tiff_bps = 10 ; load_raw = & CLASS packed_load_raw ; load_flags = 40 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>Pro90<S2SV_blank>IS"" ) || ! strcmp ( model , ""PowerShot<S2SV_blank>G1"" ) ) { colors = 4 ; filters = 0xb4b4b4b4 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>A610"" ) ) { if ( canon_s2is ( ) ) strcpy ( model + 10 , ""S2<S2SV_blank>IS"" ) ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>SX220<S2SV_blank>HS"" ) ) { mask [ 1 ] [ 3 ] = - 4 ; top_margin = 16 ; left_margin = 92 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>S120"" ) ) { raw_width = 4192 ; raw_height = 3062 ; width = 4022 ; height = 3016 ; mask [ 0 ] [ 0 ] = top_margin = 31 ; mask [ 0 ] [ 2 ] = top_margin + height ; left_margin = 120 ; mask [ 0 ] [ 1 ] = 23 ; mask [ 0 ] [ 3 ] = 72 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>G16"" ) ) { mask [ 0 ] [ 0 ] = 0 ; mask [ 0 ] [ 2 ] = 80 ; mask [ 0 ] [ 1 ] = 0 ; mask [ 0 ] [ 3 ] = 16 ; top_margin = 29 ; left_margin = 120 ; width = raw_width - left_margin - 48 ; height = raw_height - top_margin - 14 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>SX50<S2SV_blank>HS"" ) ) { top_margin = 17 ; } else if ( ! strcmp ( model , ""EOS<S2SV_blank>D2000C"" ) ) { filters = 0x61616161 ; if ( ! black ) black = curve [ 200 ] ; } else if ( ! strcmp ( model , ""D1"" ) ) { cam_mul [ 0 ] *= 256 / 527.0 ; cam_mul [ 2 ] *= 256 / 317.0 ; } else if ( ! strcmp ( model , ""D1X"" ) ) { width -= 4 ; pixel_aspect = 0.5 ; } else if ( ! strcmp ( model , ""D40X"" ) || ! strcmp ( model , ""D60"" ) || ! strcmp ( model , ""D80"" ) || ! strcmp ( model , ""D3000"" ) ) { height -= 3 ; width -= 4 ; } else if ( ! strcmp ( model , ""D3"" ) || ! strcmp ( model , ""D3S"" ) || ! strcmp ( model , ""D700"" ) ) { width -= 4 ; left_margin = 2 ; } else if ( ! strcmp ( model , ""D3100"" ) ) { width -= 28 ; left_margin = 6 ; } else if ( ! strcmp ( model , ""D5000"" ) || ! strcmp ( model , ""D90"" ) ) { width -= 42 ; } else if ( ! strcmp ( model , ""D5100"" ) || ! strcmp ( model , ""D7000"" ) || ! strcmp ( model , ""COOLPIX<S2SV_blank>A"" ) ) { width -= 44 ; } else if ( ! strcmp ( model , ""D3200"" ) || ! strncmp ( model , ""D6"" , 2 ) || ! strncmp ( model , ""D800"" , 4 ) ) { width -= 46 ; } else if ( ! strcmp ( model , ""D4"" ) || ! strcmp ( model , ""Df"" ) ) { width -= 52 ; left_margin = 2 ; } else if ( ! strcmp ( model , ""D500"" ) ) { } else if ( ! strncmp ( model , ""D40"" , 3 ) || ! strncmp ( model , ""D50"" , 3 ) || ! strncmp ( model , ""D70"" , 3 ) ) { width -- ; } else if ( ! strcmp ( model , ""D100"" ) ) { if ( load_flags ) raw_width = ( width += 3 ) + 3 ; } else if ( ! strcmp ( model , ""D200"" ) ) { left_margin = 1 ; width -= 4 ; filters = 0x94949494 ; } else if ( ! strncmp ( model , ""D2H"" , 3 ) ) { left_margin = 6 ; width -= 14 ; } else if ( ! strncmp ( model , ""D2X"" , 3 ) ) { if ( width == 3264 ) width -= 32 ; else width -= 8 ; } else if ( ! strncmp ( model , ""D300"" , 4 ) ) { width -= 32 ; } else if ( ! strncmp ( make , ""Nikon"" , 5 ) && raw_width == 4032 ) { if ( ! strcmp ( model , ""COOLPIX<S2SV_blank>P7700"" ) ) { adobe_coeff ( ""Nikon"" , ""COOLPIX<S2SV_blank>P7700"" ) ; maximum = 65504 ; load_flags = 0 ; } else if ( ! strcmp ( model , ""COOLPIX<S2SV_blank>P7800"" ) ) { adobe_coeff ( ""Nikon"" , ""COOLPIX<S2SV_blank>P7800"" ) ; maximum = 65504 ; load_flags = 0 ; } else if ( ! strcmp ( model , ""COOLPIX<S2SV_blank>P340"" ) ) load_flags = 0 ; } else if ( ! strncmp ( model , ""COOLPIX<S2SV_blank>P"" , 9 ) && raw_width != 4032 ) { load_flags = 24 ; filters = 0x94949494 ; if ( model [ 9 ] == '7' && ( iso_speed >= 400 || iso_speed == 0 ) && ! strstr ( software , ""V1.2"" ) ) black = 255 ; } else if ( ! strncmp ( model , ""COOLPIX<S2SV_blank>B700"" , 12 ) ) { load_flags = 24 ; black = 200 ; } else if ( ! strncmp ( model , ""1<S2SV_blank>"" , 2 ) ) { height -= 2 ; } else if ( fsize == 1581060 ) { simple_coeff ( 3 ) ; pre_mul [ 0 ] = 1.2085 ; pre_mul [ 1 ] = 1.0943 ; pre_mul [ 3 ] = 1.1103 ; } else if ( fsize == 3178560 ) { cam_mul [ 0 ] *= 4 ; cam_mul [ 2 ] *= 4 ; } else if ( fsize == 4771840 ) { if ( ! timestamp && nikon_e995 ( ) ) strcpy ( model , ""E995"" ) ; if ( strcmp ( model , ""E995"" ) ) { filters = 0xb4b4b4b4 ; simple_coeff ( 3 ) ; pre_mul [ 0 ] = 1.196 ; pre_mul [ 1 ] = 1.246 ; pre_mul [ 2 ] = 1.018 ; } } else if ( fsize == 2940928 ) { if ( ! timestamp && ! nikon_e2100 ( ) ) strcpy ( model , ""E2500"" ) ; if ( ! strcmp ( model , ""E2500"" ) ) { height -= 2 ; load_flags = 6 ; colors = 4 ; filters = 0x4b4b4b4b ; } } else if ( fsize == 4775936 ) { if ( ! timestamp ) nikon_3700 ( ) ; if ( model [ 0 ] == 'E' && atoi ( model + 1 ) < 3700 ) filters = 0x49494949 ; if ( ! strcmp ( model , ""Optio<S2SV_blank>33WR"" ) ) { flip = 1 ; filters = 0x16161616 ; } if ( make [ 0 ] == 'O' ) { i = find_green ( 12 , 32 , 1188864 , 3576832 ) ; c = find_green ( 12 , 32 , 2383920 , 2387016 ) ; if ( abs ( i ) < abs ( c ) ) { SWAP ( i , c ) ; load_flags = 24 ; } if ( i < 0 ) filters = 0x61616161 ; } } else if ( fsize == 5869568 ) { if ( ! timestamp && minolta_z2 ( ) ) { strcpy ( make , ""Minolta"" ) ; strcpy ( model , ""DiMAGE<S2SV_blank>Z2"" ) ; } load_flags = 6 + 24 * ( make [ 0 ] == 'M' ) ; } else if ( fsize == 6291456 ) { fseek ( ifp , 0x300000 , SEEK_SET ) ; if ( ( order = guess_byte_order ( 0x10000 ) ) == 0x4d4d ) { height -= ( top_margin = 16 ) ; width -= ( left_margin = 28 ) ; maximum = 0xf5c0 ; strcpy ( make , ""ISG"" ) ; model [ 0 ] = 0 ; } } else if ( ! strncmp ( make , ""Fujifilm"" , 8 ) ) { if ( ! strcmp ( model , ""X-A3"" ) || ! strcmp ( model , ""X-A10"" ) ) { left_margin = 0 ; top_margin = 0 ; width = raw_width ; height = raw_height ; } if ( ! strcmp ( model + 7 , ""S2Pro"" ) ) { strcpy ( model , ""S2Pro"" ) ; height = 2144 ; width = 2880 ; flip = 6 ; } else if ( load_raw != & CLASS packed_load_raw && strncmp ( model , ""X-"" , 2 ) ) maximum = ( is_raw == 2 && shot_select ) ? 0x2f00 : 0x3e00 ; top_margin = ( raw_height - height ) >> 2 << 1 ; left_margin = ( raw_width - width ) >> 2 << 1 ; if ( width == 2848 || width == 3664 ) filters = 0x16161616 ; if ( width == 4032 || width == 4952 ) left_margin = 0 ; if ( width == 3328 && ( width -= 66 ) ) left_margin = 34 ; if ( width == 4936 ) left_margin = 4 ; if ( width == 6032 ) left_margin = 0 ; if ( ! strcmp ( model , ""HS50EXR"" ) || ! strcmp ( model , ""F900EXR"" ) ) { width += 2 ; left_margin = 0 ; filters = 0x16161616 ; } if ( ! strcmp ( model , ""GFX<S2SV_blank>50S"" ) ) { left_margin = 0 ; top_margin = 0 ; } if ( ! strcmp ( model , ""S5500"" ) ) { height -= ( top_margin = 6 ) ; } if ( fuji_layout ) raw_width *= is_raw ; if ( filters == 9 ) FORC ( 36 ) ( ( char * ) xtrans ) [ c ] = xtrans_abs [ ( c / 6 + top_margin ) % 6 ] [ ( c + left_margin ) % 6 ] ; } else if ( ! strcmp ( model , ""KD-400Z"" ) ) { height = 1712 ; width = 2312 ; raw_width = 2336 ; goto konica_400z ; } else if ( ! strcmp ( model , ""KD-510Z"" ) ) { goto konica_510z ; } else if ( ! strncasecmp ( make , ""Minolta"" , 7 ) ) { if ( ! load_raw && ( maximum = 0xfff ) ) load_raw = & CLASS unpacked_load_raw ; if ( ! strncmp ( model , ""DiMAGE<S2SV_blank>A"" , 8 ) ) { if ( ! strcmp ( model , ""DiMAGE<S2SV_blank>A200"" ) ) filters = 0x49494949 ; tiff_bps = 12 ; load_raw = & CLASS packed_load_raw ; } else if ( ! strncmp ( model , ""ALPHA"" , 5 ) || ! strncmp ( model , ""DYNAX"" , 5 ) || ! strncmp ( model , ""MAXXUM"" , 6 ) ) { sprintf ( model + 20 , ""DYNAX<S2SV_blank>%-10s"" , model + 6 + ( model [ 0 ] == 'M' ) ) ; adobe_coeff ( make , model + 20 ) ; load_raw = & CLASS packed_load_raw ; } else if ( ! strncmp ( model , ""DiMAGE<S2SV_blank>G"" , 8 ) ) { if ( model [ 8 ] == '4' ) { height = 1716 ; width = 2304 ; } else if ( model [ 8 ] == '5' ) { konica_510z : height = 1956 ; width = 2607 ; raw_width = 2624 ; } else if ( model [ 8 ] == '6' ) { height = 2136 ; width = 2848 ; } data_offset += 14 ; filters = 0x61616161 ; konica_400z : load_raw = & CLASS unpacked_load_raw ; maximum = 0x3df ; order = 0x4d4d ; } } else if ( ! strcmp ( model , ""*ist<S2SV_blank>D"" ) ) { load_raw = & CLASS unpacked_load_raw ; data_error = - 1 ; } else if ( ! strcmp ( model , ""*ist<S2SV_blank>DS"" ) ) { height -= 2 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && raw_width == 4704 ) { height -= top_margin = 8 ; width -= 2 * ( left_margin = 8 ) ; load_flags = 32 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && ! strcmp ( model , ""NX3000"" ) ) { top_margin = 38 ; left_margin = 92 ; width = 5456 ; height = 3634 ; filters = 0x61616161 ; colors = 3 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && raw_height == 3714 ) { height -= top_margin = 18 ; left_margin = raw_width - ( width = 5536 ) ; if ( raw_width != 5600 ) left_margin = top_margin = 0 ; filters = 0x61616161 ; colors = 3 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && raw_width == 5632 ) { order = 0x4949 ; height = 3694 ; top_margin = 2 ; width = 5574 - ( left_margin = 32 + tiff_bps ) ; if ( tiff_bps == 12 ) load_flags = 80 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && raw_width == 5664 ) { height -= top_margin = 17 ; left_margin = 96 ; width = 5544 ; filters = 0x49494949 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && raw_width == 6496 ) { filters = 0x61616161 ; # ifdef LIBRAW_LIBRARY_BUILD if ( ! black && ! cblack [ 0 ] && ! cblack [ 1 ] && ! cblack [ 2 ] && ! cblack [ 3 ] ) # endif black = 1 << ( tiff_bps - 7 ) ; } else if ( ! strcmp ( model , ""EX1"" ) ) { order = 0x4949 ; height -= 20 ; top_margin = 2 ; if ( ( width -= 6 ) > 3682 ) { height -= 10 ; width -= 46 ; top_margin = 8 ; } } else if ( ! strcmp ( model , ""WB2000"" ) ) { order = 0x4949 ; height -= 3 ; top_margin = 2 ; if ( ( width -= 10 ) > 3718 ) { height -= 28 ; width -= 56 ; top_margin = 8 ; } } else if ( strstr ( model , ""WB550"" ) ) { strcpy ( model , ""WB550"" ) ; } else if ( ! strcmp ( model , ""EX2F"" ) ) { height = 3030 ; width = 4040 ; top_margin = 15 ; left_margin = 24 ; order = 0x4949 ; filters = 0x49494949 ; load_raw = & CLASS unpacked_load_raw ; } else if ( ! strcmp ( model , ""STV680<S2SV_blank>VGA"" ) ) { black = 16 ; } else if ( ! strcmp ( model , ""N95"" ) ) { height = raw_height - ( top_margin = 2 ) ; } else if ( ! strcmp ( model , ""640x480"" ) ) { gamma_curve ( 0.45 , 4.5 , 1 , 255 ) ; } else if ( ! strncmp ( make , ""Hasselblad"" , 10 ) ) { if ( load_raw == & CLASS lossless_jpeg_load_raw ) load_raw = & CLASS hasselblad_load_raw ; if ( raw_width == 7262 ) { height = 5444 ; width = 7248 ; top_margin = 4 ; left_margin = 7 ; filters = 0x61616161 ; if ( ! strncasecmp ( model , ""H3D"" , 3 ) ) { adobe_coeff ( ""Hasselblad"" , ""H3DII-39"" ) ; strcpy ( model , ""H3DII-39"" ) ; } } else if ( raw_width == 12000 ) { left_margin = 64 ; width = 11608 ; top_margin = 108 ; height = raw_height - top_margin ; adobe_coeff ( ""Hasselblad"" , ""H6D-100c"" ) ; } else if ( raw_width == 7410 || raw_width == 8282 ) { height -= 84 ; width -= 82 ; top_margin = 4 ; left_margin = 41 ; filters = 0x61616161 ; adobe_coeff ( ""Hasselblad"" , ""H4D-40"" ) ; strcpy ( model , ""H4D-40"" ) ; } else if ( raw_width == 8384 ) { top_margin = 96 ; height -= 96 ; left_margin = 48 ; width -= 106 ; adobe_coeff ( ""Hasselblad"" , ""X1D"" ) ; maximum = 0xffff ; tiff_bps = 16 ; } else if ( raw_width == 9044 ) { if ( black > 500 ) { top_margin = 12 ; left_margin = 44 ; width = 8956 ; height = 6708 ; memset ( cblack , 0 , sizeof ( cblack ) ) ; adobe_coeff ( ""Hasselblad"" , ""H4D-60"" ) ; strcpy ( model , ""H4D-60"" ) ; black = 512 ; } else { height = 6716 ; width = 8964 ; top_margin = 8 ; left_margin = 40 ; black += load_flags = 256 ; maximum = 0x8101 ; strcpy ( model , ""H3DII-60"" ) ; } } else if ( raw_width == 4090 ) { strcpy ( model , ""V96C"" ) ; height -= ( top_margin = 6 ) ; width -= ( left_margin = 3 ) + 7 ; filters = 0x61616161 ; } else if ( raw_width == 8282 && raw_height == 6240 ) { if ( ! strncasecmp ( model , ""H5D"" , 3 ) ) { left_margin = 54 ; top_margin = 16 ; width = 8176 ; height = 6132 ; black = 256 ; strcpy ( model , ""H5D-50"" ) ; } else if ( ! strncasecmp ( model , ""H3D"" , 3 ) ) { black = 0 ; left_margin = 54 ; top_margin = 16 ; width = 8176 ; height = 6132 ; memset ( cblack , 0 , sizeof ( cblack ) ) ; adobe_coeff ( ""Hasselblad"" , ""H3D-50"" ) ; strcpy ( model , ""H3D-50"" ) ; } } else if ( raw_width == 8374 && raw_height == 6304 ) { left_margin = 52 ; top_margin = 100 ; width = 8272 ; height = 6200 ; black = 256 ; strcpy ( model , ""H5D-50c"" ) ; } if ( tiff_samples > 1 ) { is_raw = tiff_samples + 1 ; if ( ! shot_select && ! half_size ) filters = 0 ; } } else if ( ! strncmp ( make , ""Sinar"" , 5 ) ) { if ( ! load_raw ) load_raw = & CLASS unpacked_load_raw ; if ( is_raw > 1 && ! shot_select && ! half_size ) filters = 0 ; maximum = 0x3fff ; } else if ( ! strncmp ( make , ""Leaf"" , 4 ) ) { maximum = 0x3fff ; fseek ( ifp , data_offset , SEEK_SET ) ; if ( ljpeg_start ( & jh , 1 ) && jh . bits == 15 ) maximum = 0x1fff ; if ( tiff_samples > 1 ) filters = 0 ; if ( tiff_samples > 1 || tile_length < raw_height ) { load_raw = & CLASS leaf_hdr_load_raw ; raw_width = tile_width ; } if ( ( width | height ) == 2048 ) { if ( tiff_samples == 1 ) { filters = 1 ; strcpy ( cdesc , ""RBTG"" ) ; strcpy ( model , ""CatchLight"" ) ; top_margin = 8 ; left_margin = 18 ; height = 2032 ; width = 2016 ; } else { strcpy ( model , ""DCB2"" ) ; top_margin = 10 ; left_margin = 16 ; height = 2028 ; width = 2022 ; } } else if ( width + height == 3144 + 2060 ) { if ( ! model [ 0 ] ) strcpy ( model , ""Cantare"" ) ; if ( width > height ) { top_margin = 6 ; left_margin = 32 ; height = 2048 ; width = 3072 ; filters = 0x61616161 ; } else { left_margin = 6 ; top_margin = 32 ; width = 2048 ; height = 3072 ; filters = 0x16161616 ; } if ( ! cam_mul [ 0 ] || model [ 0 ] == 'V' ) filters = 0 ; else is_raw = tiff_samples ; } else if ( width == 2116 ) { strcpy ( model , ""Valeo<S2SV_blank>6"" ) ; height -= 2 * ( top_margin = 30 ) ; width -= 2 * ( left_margin = 55 ) ; filters = 0x49494949 ; } else if ( width == 3171 ) { strcpy ( model , ""Valeo<S2SV_blank>6"" ) ; height -= 2 * ( top_margin = 24 ) ; width -= 2 * ( left_margin = 24 ) ; filters = 0x16161616 ; } } else if ( ! strncmp ( make , ""Leica"" , 5 ) || ! strncmp ( make , ""Panasonic"" , 9 ) || ! strncasecmp ( make , ""YUNEEC"" , 6 ) ) { if ( raw_width > 0 && ( ( flen - data_offset ) / ( raw_width * 8 / 7 ) == raw_height ) ) load_raw = & CLASS panasonic_load_raw ; if ( ! load_raw ) { load_raw = & CLASS unpacked_load_raw ; load_flags = 4 ; } zero_is_bad = 1 ; # ifdef LIBRAW_LIBRARY_BUILD float fratio = float ( data_size ) / ( float ( raw_height ) * float ( raw_width ) ) ; if ( ! ( raw_width % 10 ) && ! ( data_size % 16384 ) && fratio >= 1.6f && fratio <= 1.6001f ) { load_raw = & CLASS panasonic_16x10_load_raw ; zero_is_bad = 0 ; } # endif if ( ( height += 12 ) > raw_height ) height = raw_height ; for ( i = 0 ; i < sizeof pana / sizeof * pana ; i ++ ) if ( raw_width == pana [ i ] [ 0 ] && raw_height == pana [ i ] [ 1 ] ) { left_margin = pana [ i ] [ 2 ] ; top_margin = pana [ i ] [ 3 ] ; width += pana [ i ] [ 4 ] ; height += pana [ i ] [ 5 ] ; } filters = 0x01010101 * ( uchar ) ""\\x94\\x61\\x49\\x16"" [ ( ( filters - 1 ) ^ ( left_margin & 1 ) ^ ( top_margin << 1 ) ) & 3 ] ; } else if ( ! strcmp ( model , ""C770UZ"" ) ) { height = 1718 ; width = 2304 ; filters = 0x16161616 ; load_raw = & CLASS packed_load_raw ; load_flags = 30 ; } else if ( ! strncmp ( make , ""Olympus"" , 7 ) ) { height += height & 1 ; if ( exif_cfa ) filters = exif_cfa ; if ( width == 4100 ) width -= 4 ; if ( width == 4080 ) width -= 24 ; if ( width == 9280 ) { width -= 6 ; height -= 6 ; } if ( load_raw == & CLASS unpacked_load_raw ) load_flags = 4 ; tiff_bps = 12 ; if ( ! strcmp ( model , ""E-300"" ) || ! strcmp ( model , ""E-500"" ) ) { width -= 20 ; if ( load_raw == & CLASS unpacked_load_raw ) { maximum = 0xfc3 ; memset ( cblack , 0 , sizeof cblack ) ; } } else if ( ! strcmp ( model , ""STYLUS1"" ) ) { width -= 14 ; maximum = 0xfff ; } else if ( ! strcmp ( model , ""E-330"" ) ) { width -= 30 ; if ( load_raw == & CLASS unpacked_load_raw ) maximum = 0xf79 ; } else if ( ! strcmp ( model , ""SP550UZ"" ) ) { thumb_length = flen - ( thumb_offset = 0xa39800 ) ; thumb_height = 480 ; thumb_width = 640 ; } else if ( ! strcmp ( model , ""TG-4"" ) ) { width -= 16 ; } else if ( ! strcmp ( model , ""TG-5"" ) ) { width -= 26 ; } } else if ( ! strcmp ( model , ""N<S2SV_blank>Digital"" ) ) { height = 2047 ; width = 3072 ; filters = 0x61616161 ; data_offset = 0x1a00 ; load_raw = & CLASS packed_load_raw ; } else if ( ! strcmp ( model , ""DSC-F828"" ) ) { width = 3288 ; left_margin = 5 ; mask [ 1 ] [ 3 ] = - 17 ; data_offset = 862144 ; load_raw = & CLASS sony_load_raw ; filters = 0x9c9c9c9c ; colors = 4 ; strcpy ( cdesc , ""RGBE"" ) ; } else if ( ! strcmp ( model , ""DSC-V3"" ) ) { width = 3109 ; left_margin = 59 ; mask [ 0 ] [ 1 ] = 9 ; data_offset = 787392 ; load_raw = & CLASS sony_load_raw ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 3984 ) { width = 3925 ; order = 0x4d4d ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 4288 ) { width -= 32 ; } else if ( ! strcmp ( make , ""Sony"" ) && raw_width == 4600 ) { if ( ! strcmp ( model , ""DSLR-A350"" ) ) height -= 4 ; black = 0 ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 4928 ) { if ( height < 3280 ) width -= 8 ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 5504 ) { width -= height > 3664 ? 8 : 32 ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 6048 ) { width -= 24 ; if ( strstr ( model , ""RX1"" ) || strstr ( model , ""A99"" ) ) width -= 6 ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 7392 ) { width -= 30 ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 8000 ) { width -= 32 ; } else if ( ! strcmp ( model , ""DSLR-A100"" ) ) { if ( width == 3880 ) { height -- ; width = ++ raw_width ; } else { height -= 4 ; width -= 4 ; order = 0x4d4d ; load_flags = 2 ; } filters = 0x61616161 ; } else if ( ! strcmp ( model , ""PIXL"" ) ) { height -= top_margin = 4 ; width -= left_margin = 32 ; gamma_curve ( 0 , 7 , 1 , 255 ) ; } else if ( ! strcmp ( model , ""C603"" ) || ! strcmp ( model , ""C330"" ) || ! strcmp ( model , ""12MP"" ) ) { order = 0x4949 ; if ( filters && data_offset ) { fseek ( ifp , data_offset < 4096 ? 168 : 5252 , SEEK_SET ) ; read_shorts ( curve , 256 ) ; } else gamma_curve ( 0 , 3.875 , 1 , 255 ) ; load_raw = filters ? & CLASS eight_bit_load_raw : strcmp ( model , ""C330"" ) ? & CLASS kodak_c603_load_raw : & CLASS kodak_c330_load_raw ; load_flags = tiff_bps > 16 ; tiff_bps = 8 ; } else if ( ! strncasecmp ( model , ""EasyShare"" , 9 ) ) { data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000 ; load_raw = & CLASS packed_load_raw ; } else if ( ! strncasecmp ( make , ""Kodak"" , 5 ) ) { if ( filters == UINT_MAX ) filters = 0x61616161 ; if ( ! strncmp ( model , ""NC2000"" , 6 ) || ! strncmp ( model , ""EOSDCS"" , 6 ) || ! strncmp ( model , ""DCS4"" , 4 ) ) { width -= 4 ; left_margin = 2 ; if ( model [ 6 ] == '<S2SV_blank>' ) model [ 6 ] = 0 ; if ( ! strcmp ( model , ""DCS460A"" ) ) goto bw ; } else if ( ! strcmp ( model , ""DCS660M"" ) ) { black = 214 ; goto bw ; } else if ( ! strcmp ( model , ""DCS760M"" ) ) { bw : colors = 1 ; filters = 0 ; } if ( ! strcmp ( model + 4 , ""20X"" ) ) strcpy ( cdesc , ""MYCY"" ) ; if ( strstr ( model , ""DC25"" ) ) { strcpy ( model , ""DC25"" ) ; data_offset = 15424 ; } if ( ! strncmp ( model , ""DC2"" , 3 ) ) { raw_height = 2 + ( height = 242 ) ; if ( ! strncmp ( model , ""DC290"" , 5 ) ) iso_speed = 100 ; if ( ! strncmp ( model , ""DC280"" , 5 ) ) iso_speed = 70 ; if ( flen < 100000 ) { raw_width = 256 ; width = 249 ; pixel_aspect = ( 4.0 * height ) / ( 3.0 * width ) ; } else { raw_width = 512 ; width = 501 ; pixel_aspect = ( 493.0 * height ) / ( 373.0 * width ) ; } top_margin = left_margin = 1 ; colors = 4 ; filters = 0x8d8d8d8d ; simple_coeff ( 1 ) ; pre_mul [ 1 ] = 1.179 ; pre_mul [ 2 ] = 1.209 ; pre_mul [ 3 ] = 1.036 ; load_raw = & CLASS eight_bit_load_raw ; } else if ( ! strcmp ( model , ""40"" ) ) { strcpy ( model , ""DC40"" ) ; height = 512 ; width = 768 ; data_offset = 1152 ; load_raw = & CLASS kodak_radc_load_raw ; tiff_bps = 12 ; } else if ( strstr ( model , ""DC50"" ) ) { strcpy ( model , ""DC50"" ) ; height = 512 ; width = 768 ; iso_speed = 84 ; data_offset = 19712 ; load_raw = & CLASS kodak_radc_load_raw ; } else if ( strstr ( model , ""DC120"" ) ) { strcpy ( model , ""DC120"" ) ; raw_height = height = 976 ; raw_width = width = 848 ; iso_speed = 160 ; pixel_aspect = height / 0.75 / width ; load_raw = tiff_compress == 7 ? & CLASS kodak_jpeg_load_raw : & CLASS kodak_dc120_load_raw ; } else if ( ! strcmp ( model , ""DCS200"" ) ) { thumb_height = 128 ; thumb_width = 192 ; thumb_offset = 6144 ; thumb_misc = 360 ; iso_speed = 140 ; write_thumb = & CLASS layer_thumb ; black = 17 ; } } else if ( ! strcmp ( model , ""Fotoman<S2SV_blank>Pixtura"" ) ) { height = 512 ; width = 768 ; data_offset = 3632 ; load_raw = & CLASS kodak_radc_load_raw ; filters = 0x61616161 ; simple_coeff ( 2 ) ; } else if ( ! strncmp ( model , ""QuickTake"" , 9 ) ) { if ( head [ 5 ] ) strcpy ( model + 10 , ""200"" ) ; fseek ( ifp , 544 , SEEK_SET ) ; height = get2 ( ) ; width = get2 ( ) ; data_offset = ( get4 ( ) , get2 ( ) ) == 30 ? 738 : 736 ; if ( height > width ) { SWAP ( height , width ) ; fseek ( ifp , data_offset - 6 , SEEK_SET ) ; flip = ~ get2 ( ) & 3 ? 5 : 6 ; } filters = 0x61616161 ; } else if ( ! strncmp ( make , ""Rollei"" , 6 ) && ! load_raw ) { switch ( raw_width ) { case 1316 : height = 1030 ; width = 1300 ; top_margin = 1 ; left_margin = 6 ; break ; case 2568 : height = 1960 ; width = 2560 ; top_margin = 2 ; left_margin = 8 ; } filters = 0x16161616 ; load_raw = & CLASS rollei_load_raw ; } else if ( ! strcmp ( model , ""GRAS-50S5C"" ) ) { height = 2048 ; width = 2440 ; load_raw = & CLASS unpacked_load_raw ; data_offset = 0 ; filters = 0x49494949 ; order = 0x4949 ; maximum = 0xfffC ; } else if ( ! strcmp ( model , ""BB-500CL"" ) ) { height = 2058 ; width = 2448 ; load_raw = & CLASS unpacked_load_raw ; data_offset = 0 ; filters = 0x94949494 ; order = 0x4949 ; maximum = 0x3fff ; } else if ( ! strcmp ( model , ""BB-500GE"" ) ) { height = 2058 ; width = 2456 ; load_raw = & CLASS unpacked_load_raw ; data_offset = 0 ; filters = 0x94949494 ; order = 0x4949 ; maximum = 0x3fff ; } else if ( ! strcmp ( model , ""SVS625CL"" ) ) { height = 2050 ; width = 2448 ; load_raw = & CLASS unpacked_load_raw ; data_offset = 0 ; filters = 0x94949494 ; order = 0x4949 ; maximum = 0x0fff ; } if ( ! load_raw || height < 22 || width < 22 || # ifdef LIBRAW_LIBRARY_BUILD ( tiff_bps > 16 && load_raw != & LibRaw : : deflate_dng_load_raw ) # else tiff_bps > 16 # endif || tiff_samples > 4 || colors > 4 || colors < 1 ) { is_raw = 0 ; # ifdef LIBRAW_LIBRARY_BUILD RUN_CALLBACK ( LIBRAW_PROGRESS_IDENTIFY , 1 , 2 ) ; # endif return ; } if ( ! model [ 0 ] ) sprintf ( model , ""%dx%d"" , width , height ) ; if ( filters == UINT_MAX ) filters = 0x94949494 ; if ( thumb_offset && ! thumb_height ) { fseek ( ifp , thumb_offset , SEEK_SET ) ; if ( ljpeg_start ( & jh , 1 ) ) { thumb_width = jh . wide ; thumb_height = jh . high ; } } dng_skip : # ifdef LIBRAW_LIBRARY_BUILD if ( dng_version ) { int iifd = 0 ; for ( ; iifd < tiff_nifds ; iifd ++ ) if ( tiff_ifd [ iifd ] . offset == data_offset ) break ; int pifd = - 1 ; for ( int ii = 0 ; ii < tiff_nifds ; ii ++ ) if ( tiff_ifd [ ii ] . offset == thumb_offset ) { pifd = ii ; break ; } # define CFAROUND ( value , filters ) filters ? ( filters >= 1000 ? ( ( value + 1 ) / 2 ) * 2 : ( ( value + 5 ) / 6 ) * 6 ) : value # define IFDCOLORINDEX ( ifd , subset , bit ) ( tiff_ifd [ ifd ] . dng_color [ subset ] . parsedfields & bit ) ? ifd : ( ( tiff_ifd [ 0 ] . dng_color [ subset ] . parsedfields & bit ) ? 0 : - 1 ) # define IFDLEVELINDEX ( ifd , bit ) ( tiff_ifd [ ifd ] . dng_levels . parsedfields & bit ) ? ifd : ( ( tiff_ifd [ 0 ] . dng_levels . parsedfields & bit ) ? 0 : - 1 ) # define COPYARR ( to , from ) memmove ( & to , & from , sizeof ( from ) ) if ( iifd < tiff_nifds ) { int sidx ; if ( imgdata . params . raw_processing_options & LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP ) { sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_CROPORIGIN ) ; int sidx2 = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_CROPSIZE ) ; if ( sidx >= 0 && sidx == sidx2 ) { int lm = tiff_ifd [ sidx ] . dng_levels . default_crop [ 0 ] ; int lmm = CFAROUND ( lm , filters ) ; int tm = tiff_ifd [ sidx ] . dng_levels . default_crop [ 1 ] ; int tmm = CFAROUND ( tm , filters ) ; int ww = tiff_ifd [ sidx ] . dng_levels . default_crop [ 2 ] ; int hh = tiff_ifd [ sidx ] . dng_levels . default_crop [ 3 ] ; if ( lmm > lm ) ww -= ( lmm - lm ) ; if ( tmm > tm ) hh -= ( tmm - tm ) ; if ( left_margin + lm + ww <= raw_width && top_margin + tm + hh <= raw_height ) { left_margin += lmm ; top_margin += tmm ; width = ww ; height = hh ; } } } if ( ! ( imgdata . color . dng_color [ 0 ] . parsedfields & LIBRAW_DNGFM_FORWARDMATRIX ) ) { sidx = IFDCOLORINDEX ( iifd , 0 , LIBRAW_DNGFM_FORWARDMATRIX ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ 0 ] . forwardmatrix , tiff_ifd [ sidx ] . dng_color [ 0 ] . forwardmatrix ) ; } if ( ! ( imgdata . color . dng_color [ 1 ] . parsedfields & LIBRAW_DNGFM_FORWARDMATRIX ) ) { sidx = IFDCOLORINDEX ( iifd , 1 , LIBRAW_DNGFM_FORWARDMATRIX ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ 1 ] . forwardmatrix , tiff_ifd [ sidx ] . dng_color [ 1 ] . forwardmatrix ) ; } for ( int ss = 0 ; ss < 2 ; ss ++ ) { sidx = IFDCOLORINDEX ( iifd , ss , LIBRAW_DNGFM_COLORMATRIX ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ ss ] . colormatrix , tiff_ifd [ sidx ] . dng_color [ ss ] . colormatrix ) ; sidx = IFDCOLORINDEX ( iifd , ss , LIBRAW_DNGFM_CALIBRATION ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ ss ] . calibration , tiff_ifd [ sidx ] . dng_color [ ss ] . calibration ) ; sidx = IFDCOLORINDEX ( iifd , ss , LIBRAW_DNGFM_ILLUMINANT ) ; if ( sidx >= 0 ) imgdata . color . dng_color [ ss ] . illuminant = tiff_ifd [ sidx ] . dng_color [ ss ] . illuminant ; } sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_ANALOGBALANCE ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_levels . analogbalance , tiff_ifd [ sidx ] . dng_levels . analogbalance ) ; sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_WHITE ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_levels . dng_whitelevel , tiff_ifd [ sidx ] . dng_levels . dng_whitelevel ) ; sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_BLACK ) ; if ( sidx >= 0 ) { imgdata . color . dng_levels . dng_black = tiff_ifd [ sidx ] . dng_levels . dng_black ; COPYARR ( imgdata . color . dng_levels . dng_cblack , tiff_ifd [ sidx ] . dng_levels . dng_cblack ) ; } if ( pifd >= 0 ) { sidx = IFDLEVELINDEX ( pifd , LIBRAW_DNGFM_PREVIEWCS ) ; if ( sidx >= 0 ) imgdata . color . dng_levels . preview_colorspace = tiff_ifd [ sidx ] . dng_levels . preview_colorspace ; } sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_OPCODE2 ) ; if ( sidx >= 0 ) meta_offset = tiff_ifd [ sidx ] . opcode2_offset ; sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_LINTABLE ) ; INT64 linoff = - 1 ; int linlen = 0 ; if ( sidx >= 0 ) { linoff = tiff_ifd [ sidx ] . lineartable_offset ; linlen = tiff_ifd [ sidx ] . lineartable_len ; } if ( linoff >= 0 && linlen > 0 ) { INT64 pos = ftell ( ifp ) ; fseek ( ifp , linoff , SEEK_SET ) ; linear_table ( linlen ) ; fseek ( ifp , pos , SEEK_SET ) ; } } maximum = imgdata . color . dng_levels . dng_whitelevel [ 0 ] ; black = imgdata . color . dng_levels . dng_black ; int ll = LIM ( 0 , ( sizeof ( cblack ) / sizeof ( cblack [ 0 ] ) ) , ( sizeof ( imgdata . color . dng_levels . dng_cblack ) / sizeof ( imgdata . color . dng_levels . dng_cblack [ 0 ] ) ) ) ; for ( int i = 0 ; i < ll ; i ++ ) cblack [ i ] = imgdata . color . dng_levels . dng_cblack [ i ] ; } # endif if ( ! load_raw || height < 22 || width < 22 || # ifdef LIBRAW_LIBRARY_BUILD ( tiff_bps > 16 && load_raw != & LibRaw : : deflate_dng_load_raw ) # else tiff_bps > 16 # endif || tiff_samples > 4 || colors > 4 || colors < 1 ) { is_raw = 0 ; # ifdef LIBRAW_LIBRARY_BUILD RUN_CALLBACK ( LIBRAW_PROGRESS_IDENTIFY , 1 , 2 ) ; # endif return ; } if ( ( use_camera_matrix & ( ( use_camera_wb || dng_version ) | 0x2 ) ) && cmatrix [ 0 ] [ 0 ] > 0.125 ) { memcpy ( rgb_cam , cmatrix , sizeof cmatrix ) ; raw_color = 0 ; } if ( raw_color ) adobe_coeff ( make , model ) ; # ifdef LIBRAW_LIBRARY_BUILD else if ( imgdata . color . cam_xyz [ 0 ] [ 0 ] < 0.01 ) adobe_coeff ( make , model , 1 ) ; # endif if ( load_raw == & CLASS kodak_radc_load_raw ) if ( raw_color ) adobe_coeff ( ""Apple"" , ""Quicktake"" ) ;  if ( fuji_width )  { fuji_width = width >> ! fuji_layout ; filters = fuji_width & 1 ? 0x94949494 : 0x49494949 ; width = ( height >> fuji_layout ) + fuji_width ; height = width - 1 ; pixel_aspect = 1 ; } else { if ( raw_height < height ) raw_height = height ; if ( raw_width < width ) raw_width = width ; } if ( ! tiff_bps ) tiff_bps = 12 ; if ( ! maximum ) { maximum = ( 1 << tiff_bps ) - 1 ; if ( maximum < 0x10000 && curve [ maximum ] > 0 && load_raw == & CLASS sony_arw2_load_raw ) maximum = curve [ maximum ] ; } if ( ! load_raw || height < 22 || width < 22 || # ifdef LIBRAW_LIBRARY_BUILD ( tiff_bps > 16 && load_raw != & LibRaw : : deflate_dng_load_raw ) # else tiff_bps > 16 # endif || tiff_samples > 6 || colors > 4 ) is_raw = 0 ; if ( raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_height > 64000 ) is_raw = 0 ; # ifdef NO_JASPER if ( load_raw == & CLASS redcine_load_raw ) { # ifdef DCRAW_VERBOSE fprintf ( stderr , _ ( ""%s:<S2SV_blank>You<S2SV_blank>must<S2SV_blank>link<S2SV_blank>dcraw<S2SV_blank>with<S2SV_blank>%s!!\\n"" ) , ifname , ""libjasper"" ) ; # endif is_raw = 0 ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . process_warnings |= LIBRAW_WARN_NO_JASPER ; # endif } # endif # ifdef NO_JPEG if ( load_raw == & CLASS kodak_jpeg_load_raw || load_raw == & CLASS lossy_dng_load_raw ) { # ifdef DCRAW_VERBOSE fprintf ( stderr , _ ( ""%s:<S2SV_blank>You<S2SV_blank>must<S2SV_blank>link<S2SV_blank>dcraw<S2SV_blank>with<S2SV_blank>%s!!\\n"" ) , ifname , ""libjpeg"" ) ; # endif is_raw = 0 ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . process_warnings |= LIBRAW_WARN_NO_JPEGLIB ; # endif } # endif if ( ! cdesc [ 0 ] ) strcpy ( cdesc , colors == 3 ? ""RGBG"" : ""GMCY"" ) ; if ( ! raw_height ) raw_height = height ; if ( ! raw_width ) raw_width = width ; if ( filters > 999 && colors == 3 ) filters |= ( ( filters >> 2 & 0x22222222 ) | ( filters << 2 & 0x88888888 ) ) & filters << 1 ; notraw : if ( flip == UINT_MAX ) flip = tiff_flip ; if ( flip == UINT_MAX ) flip = 0 ; if ( flip > 89 || flip < - 89 ) { switch ( ( flip + 3600 ) % 360 ) { case 270 : flip = 5 ; break ; case 180 : flip = 3 ; break ; case 90 : flip = 6 ; break ; } } # ifdef LIBRAW_LIBRARY_BUILD RUN_CALLBACK ( LIBRAW_PROGRESS_IDENTIFY , 1 , 2 ) ; # endif }",# ifdef LIBRAW_LIBRARY_BUILD if ( fuji_width && ! dng_version && ! ( imgdata . process_warnings & LIBRAW_WARN_PARSEFUJI_PROCESSED ) ) fuji_width = 0 ;# endif if ( fuji_width ) {,2233
110,"buggy line: if ( daddr == 0 || rs -> rs_bound_addr == 0 ) {ret = - ENOTCONN ;goto out ;}if ( payload_len > rds_sk_sndbuf ( rs ) ) {cwe id:CWE-362context: int rds_sendmsg ( struct socket * sock , struct msghdr * msg , size_t payload_len ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; __be32 daddr ; __be16 dport ; struct rds_message * rm = NULL ; struct rds_connection * conn ; int ret = 0 ; int queued = 0 , allocated_mr = 0 ; int nonblock = msg -> msg_flags & MSG_DONTWAIT ; long timeo = sock_sndtimeo ( sk , nonblock ) ; if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( msg -> msg_namelen ) { if ( msg -> msg_namelen < sizeof ( * usin ) || usin -> sin_family != AF_INET ) { ret = - EINVAL ; goto out ; } daddr = usin -> sin_addr . s_addr ; dport = usin -> sin_port ; } else { lock_sock ( sk ) ; daddr = rs -> rs_conn_addr ; dport = rs -> rs_conn_port ; release_sock ( sk ) ; }  if ( daddr == 0 || rs -> rs_bound_addr == 0 ) {   ret = - ENOTCONN ;  goto out ;  }  if ( payload_len > rds_sk_sndbuf ( rs ) ) { ret = - EMSGSIZE ; goto out ; } ret = rds_rm_size ( msg , payload_len ) ; if ( ret < 0 ) goto out ; rm = rds_message_alloc ( ret , GFP_KERNEL ) ; if ( ! rm ) { ret = - ENOMEM ; goto out ; } if ( payload_len ) { rm -> data . op_sg = rds_message_alloc_sgs ( rm , ceil ( payload_len , PAGE_SIZE ) ) ; if ( ! rm -> data . op_sg ) { ret = - ENOMEM ; goto out ; } ret = rds_message_copy_from_user ( rm , & msg -> msg_iter ) ; if ( ret ) goto out ; } rm -> data . op_active = 1 ; rm -> m_daddr = daddr ; if ( rs -> rs_conn && rs -> rs_conn -> c_faddr == daddr ) conn = rs -> rs_conn ; else { conn = rds_conn_create_outgoing ( sock_net ( sock -> sk ) , rs -> rs_bound_addr , daddr , rs -> rs_transport , sock -> sk -> sk_allocation ) ; if ( IS_ERR ( conn ) ) { ret = PTR_ERR ( conn ) ; goto out ; } rs -> rs_conn = conn ; } ret = rds_cmsg_send ( rs , rm , msg , & allocated_mr ) ; if ( ret ) goto out ; if ( rm -> rdma . op_active && ! conn -> c_trans -> xmit_rdma ) { printk_ratelimited ( KERN_NOTICE ""rdma_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_rdma<S2SV_blank>%p\\n"" , & rm -> rdma , conn -> c_trans -> xmit_rdma ) ; ret = - EOPNOTSUPP ; goto out ; } if ( rm -> atomic . op_active && ! conn -> c_trans -> xmit_atomic ) { printk_ratelimited ( KERN_NOTICE ""atomic_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_atomic<S2SV_blank>%p\\n"" , & rm -> atomic , conn -> c_trans -> xmit_atomic ) ; ret = - EOPNOTSUPP ; goto out ; } rds_conn_connect_if_down ( conn ) ; ret = rds_cong_wait ( conn -> c_fcong , dport , nonblock , rs ) ; if ( ret ) { rs -> rs_seen_congestion = 1 ; goto out ; } while ( ! rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) ) { rds_stats_inc ( s_send_queue_full ) ; if ( nonblock ) { ret = - EAGAIN ; goto out ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) , timeo ) ; rdsdebug ( ""sendmsg<S2SV_blank>woke<S2SV_blank>queued<S2SV_blank>%d<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , queued , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; goto out ; } rds_stats_inc ( s_send_queued ) ; ret = rds_send_xmit ( conn ) ; if ( ret == - ENOMEM || ret == - EAGAIN ) queue_delayed_work ( rds_wq , & conn -> c_send_w , 1 ) ; rds_message_put ( rm ) ; return payload_len ; out : if ( allocated_mr ) rds_rdma_unuse ( rs , rds_rdma_cookie_key ( rm -> m_rdma_cookie ) , 1 ) ; if ( rm ) rds_message_put ( rm ) ; return ret ; }",lock_sock ( sk ) ;if ( daddr == 0 || rs -> rs_bound_addr == 0 ) {release_sock ( sk ) ;ret = - ENOTCONN ;goto out ;}release_sock ( sk ) ;if ( payload_len > rds_sk_sndbuf ( rs ) ) {,2234
111,"buggy line: fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ;fptr -> frag_off = htons ( offset ) ;cwe id:CWE-125context: static struct sk_buff * ipv6_gso_segment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; struct ipv6hdr * ipv6h ; const struct net_offload * ops ; int proto ; struct frag_hdr * fptr ; unsigned int unfrag_ip6hlen ; unsigned int payload_len ; u8 * prevhdr ; int offset = 0 ; bool encap , udpfrag ; int nhoff ; bool gso_partial ; skb_reset_network_header ( skb ) ; nhoff = skb_network_header ( skb ) - skb_mac_header ( skb ) ; if ( unlikely ( ! pskb_may_pull ( skb , sizeof ( * ipv6h ) ) ) ) goto out ; encap = SKB_GSO_CB ( skb ) -> encap_level > 0 ; if ( encap ) features &= skb -> dev -> hw_enc_features ; SKB_GSO_CB ( skb ) -> encap_level += sizeof ( * ipv6h ) ; ipv6h = ipv6_hdr ( skb ) ; __skb_pull ( skb , sizeof ( * ipv6h ) ) ; segs = ERR_PTR ( - EPROTONOSUPPORT ) ; proto = ipv6_gso_pull_exthdrs ( skb , ipv6h -> nexthdr ) ; if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6 ) ) udpfrag = proto == IPPROTO_UDP && encap ; else udpfrag = proto == IPPROTO_UDP && ! skb -> encapsulation ; ops = rcu_dereference ( inet6_offloads [ proto ] ) ; if ( likely ( ops && ops -> callbacks . gso_segment ) ) { skb_reset_transport_header ( skb ) ; segs = ops -> callbacks . gso_segment ( skb , features ) ; } if ( IS_ERR_OR_NULL ( segs ) ) goto out ; gso_partial = ! ! ( skb_shinfo ( segs ) -> gso_type & SKB_GSO_PARTIAL ) ; for ( skb = segs ; skb ; skb = skb -> next ) { ipv6h = ( struct ipv6hdr * ) ( skb_mac_header ( skb ) + nhoff ) ; if ( gso_partial ) payload_len = skb_shinfo ( skb ) -> gso_size + SKB_GSO_CB ( skb ) -> data_offset + skb -> head - ( unsigned char * ) ( ipv6h + 1 ) ; else payload_len = skb -> len - nhoff - sizeof ( * ipv6h ) ; ipv6h -> payload_len = htons ( payload_len ) ; skb -> network_header = ( u8 * ) ipv6h - skb -> head ; if ( udpfrag ) { unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;  fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ;  fptr -> frag_off = htons ( offset ) ; if ( skb -> next ) fptr -> frag_off |= htons ( IP6_MF ) ; offset += ( ntohs ( ipv6h -> payload_len ) - sizeof ( struct frag_hdr ) ) ; } if ( encap ) skb_reset_inner_headers ( skb ) ; } out : return segs ; }",if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ;fptr -> frag_off = htons ( offset ) ;,2235
112,"buggy line: # endif  if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) {cwe id:CWE-119context: static void decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ;  # endif  if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ;  vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;  vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ;  vpx_memset ( xd -> eobs , 0 , 25 ) ;  } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff )  vpx_memset ( xd -> eobs , 0 , 25 ) ;  intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; int left_stride = dst_stride ; unsigned char top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;  vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ;  vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ;  vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }",# else ( void ) mb_idx ;# endif if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) {,2236
113,"buggy line: vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;vp8_conceal_corrupt_mb ( xd ) ;vpx_memset ( xd -> eobs , 0 , 25 ) ;}cwe id:CWE-119context: static void decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ;  # endif  if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ;  vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;  vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ;  vpx_memset ( xd -> eobs , 0 , 25 ) ;  } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff )  vpx_memset ( xd -> eobs , 0 , 25 ) ;  intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; int left_stride = dst_stride ; unsigned char top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;  vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ;  vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ;  vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }","memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;vp8_conceal_corrupt_mb ( xd ) ;memset ( xd -> eobs , 0 , 25 ) ;}",2236
114,"buggy line: if ( xd -> mode_info_context -> mbmi . mb_skip_coeff )  vpx_memset ( xd -> eobs , 0 , 25 ) ;intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ;cwe id:CWE-119context: static void decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ;  # endif  if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ;  vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;  vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ;  vpx_memset ( xd -> eobs , 0 , 25 ) ;  } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff )  vpx_memset ( xd -> eobs , 0 , 25 ) ;  intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; int left_stride = dst_stride ; unsigned char top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;  vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ;  vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ;  vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }","if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) memset ( xd -> eobs , 0 , 25 ) ;intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ;",2236
115,"buggy line: else {vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}cwe id:CWE-119context: static void decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ;  # endif  if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ;  vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;  vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ;  vpx_memset ( xd -> eobs , 0 , 25 ) ;  } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff )  vpx_memset ( xd -> eobs , 0 , 25 ) ;  intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; int left_stride = dst_stride ; unsigned char top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;  vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ;  vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ;  vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }","memset ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;",2236
116,"buggy line: vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}cwe id:CWE-119context: static void decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ;  # endif  if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ;  vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;  vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ;  vpx_memset ( xd -> eobs , 0 , 25 ) ;  } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff )  vpx_memset ( xd -> eobs , 0 , 25 ) ;  intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; int left_stride = dst_stride ; unsigned char top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;  vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ;  vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ;  vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;  } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }","memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}",2236
117,"buggy line: static void show_object ( struct object * object , struct strbuf * path ,   const char * last , void * data )  {if ( bitmap_pos < 0 ) {char * name = path_name ( path , last ) ;bitmap_pos = ext_index_add_object ( object , name ) ;free ( name ) ;}cwe id:CWE-119context:  static void show_object ( struct object * object , struct strbuf * path ,   const char * last , void * data )  { struct bitmap * base = data ; int bitmap_pos ; bitmap_pos = bitmap_position ( object -> oid . hash ) ;  if ( bitmap_pos < 0 ) {  char * name = path_name ( path , last ) ; bitmap_pos = ext_index_add_object ( object , name ) ;  free ( name ) ;  } bitmap_set ( base , bitmap_pos ) ; }","static void show_object ( struct object * object , const char * last , void * data ) {if ( bitmap_pos < 0 ) bitmap_pos = ext_index_add_object ( object , name ) ;free ( name ) ;}",2237
118,"buggy line: s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {cwe id:CWE-269context: qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""256"" , CVAR_ARCHIVE ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_ARCHIVE ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""1.3"" , CVAR_ARCHIVE ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_ARCHIVE ) ; s_alTalkAnims = Cvar_Get ( ""s_alTalkAnims"" , ""160"" , CVAR_ARCHIVE ) ;  s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;  s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;  s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;  if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> FadeStreamingSound = S_AL_FadeStreamingSound ; si -> FadeAllSounds = S_AL_FadeAllSounds ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> StopEntStreamingSound = S_AL_StopEntStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",2238
119,"buggy line: if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) {absolute_filename = g_strdup ( filename ) ;cwe id:CWE-000context: gchar * _rsvg_io_get_file_path ( const gchar * filename , const gchar * base_uri ) { gchar * absolute_filename ;  if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) {  absolute_filename = g_strdup ( filename ) ; } else { gchar * tmpcdir ; gchar * base_filename ; if ( base_uri ) { base_filename = g_filename_from_uri ( base_uri , NULL , NULL ) ; if ( base_filename != NULL ) { tmpcdir = g_path_get_dirname ( base_filename ) ; g_free ( base_filename ) ; } else return NULL ; } else tmpcdir = g_get_current_dir ( ) ; absolute_filename = g_build_filename ( tmpcdir , filename , NULL ) ; g_free ( tmpcdir ) ; } return absolute_filename ; }",if ( g_path_is_absolute ( filename ) ) {absolute_filename = g_strdup ( filename ) ;,2239
120,"buggy line: if ( qop_req != 0 ) {if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;cwe id:CWE-000context: OM_uint32 kg_seal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , int * conf_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; krb5_error_code code ; krb5_context context ; if ( qop_req != 0 ) { * minor_status = ( OM_uint32 ) G_UNKNOWN_QOP ; return GSS_S_FAILURE ; } ctx = ( krb5_gss_ctx_id_rec * ) context_handle ;  if ( ! ctx -> established ) {  * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( conf_req_flag && kg_integ_only_iov ( iov , iov_count ) ) { conf_req_flag = FALSE ; } context = ctx -> k5_context ; switch ( ctx -> proto ) { case 0 : code = make_seal_token_v1_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; case 1 : code = gss_krb5int_make_seal_token_v3_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; default : code = G_UNKNOWN_QOP ; break ; } if ( code != 0 ) { * minor_status = code ; save_error_info ( * minor_status , context ) ; return GSS_S_FAILURE ; } * minor_status = 0 ; return GSS_S_COMPLETE ; }",if ( ctx -> terminated || qop_req != 0 ) {if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,2240
121,"buggy line: slave -> master = master ;slave -> timer = master -> timer ;spin_unlock_irq ( & slave_active_lock ) ;}cwe id:CWE-20context: static void snd_timer_check_master ( struct snd_timer_instance * master ) { struct snd_timer_instance * slave , * tmp ; list_for_each_entry_safe ( slave , tmp , & snd_timer_slave_list , open_list ) { if ( slave -> slave_class == master -> slave_class && slave -> slave_id == master -> slave_id ) { list_move_tail ( & slave -> open_list , & master -> slave_list_head ) ; spin_lock_irq ( & slave_active_lock ) ;  slave -> master = master ;  slave -> timer = master -> timer ; if ( slave -> flags & SNDRV_TIMER_IFLG_RUNNING ) list_add_tail ( & slave -> active_list , & master -> slave_active_head ) ;  spin_unlock_irq ( & slave_active_lock ) ;  } } }",spin_lock ( & master -> timer -> lock ) ;slave -> master = master ;slave -> timer = master -> timer ;spin_unlock ( & master -> timer -> lock ) ;spin_unlock_irq ( & slave_active_lock ) ;},2241
122,"buggy line: static char * print_number ( cJSON * item )  {char * str ;double f , f2 ;int64_t i ;str = ( char * ) cJSON_malloc ( 64 ) ;if ( str ) {f = item -> valuefloat ;i = f ;if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint <= LLONG_MAX )  sprintf ( str , ""%lld"" , ( long long ) item -> valueint ) ;else sprintf ( str , ""%g"" , item -> valuefloat ) ;cwe id:CWE-119context:  static char * print_number ( cJSON * item )  { char * str ; double f , f2 ; int64_t i ; str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) {  f = item -> valuefloat ;  i = f ; f2 = i ;  if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint <= LLONG_MAX )  sprintf ( str , ""%lld"" , ( long long ) item -> valueint ) ; else sprintf ( str , ""%g"" , item -> valuefloat ) ; } return str ; }","static char * print_number ( cJSON * item , printbuffer * p ) {char * str = 0 ;double d = item -> valuefloat ;i = f ;if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint ) - d ) <= DBL_EPSILON && d <= LLONG_MAX && d >= LLONG_MIN ) {if ( p ) str = ensure ( p , 64 ) ;else str = ( char * ) cJSON_malloc ( 64 ) ;if ( str ) sprintf ( str , ""%lld"" , ( long long ) item -> valueint ) ;}else {if ( p ) str = ensure ( p , 64 ) ;else str = ( char * ) cJSON_malloc ( 64 ) ;if ( str ) {if ( fpclassify ( d ) != FP_ZERO && ! isnormal ( d ) ) sprintf ( str , ""null"" ) ;else if ( fabs ( floor ( d ) - d ) <= DBL_EPSILON && fabs ( d ) < 1.0e60 ) sprintf ( str , ""%.0f"" , d ) ;else if ( fabs ( d ) < 1.0e-6 || fabs ( d ) > 1.0e9 ) sprintf ( str , ""%e"" , d ) ;else sprintf ( str , ""%f"" , d ) ;}",2242
123,"buggy line: static uint32_t scsi_init_iovec ( SCSIDiskReq * r )  {r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;cwe id:CWE-119context: static uint32_t scsi_init_iovec ( SCSIDiskReq * r )  {   r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ;  qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; return r -> qiov . size / 512 ; }","static uint32_t scsi_init_iovec ( SCSIDiskReq * r ) {SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ;if ( ! r -> iov . iov_base ) {r -> buflen = SCSI_DMA_BUF_SIZE ;r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ;}r -> iov . iov_len = MIN ( r -> sector_count * 512 , r -> buflen ) ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;",2243
124,"buggy line: return headcount ;err : vhost_discard_vq_desc ( vq , headcount ) ;cwe id:CWE-787context: static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , ARRAY_SIZE ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , ""unexpected<S2SV_blank>descriptor<S2SV_blank>format<S2SV_blank>for<S2SV_blank>RX:<S2SV_blank>"" ""out<S2SV_blank>%d,<S2SV_blank>in<S2SV_blank>%d\\n"" , out , in ) ; r = - EINVAL ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ;  return headcount ;  err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }","if ( unlikely ( datalen > 0 ) ) {r = UIO_MAXIOV + 1 ;goto err ;}return headcount ;err : vhost_discard_vq_desc ( vq , headcount ) ;",2244
125,"buggy line: ps_cur_slice -> u1_field_pic_flag = 0 ;i4_frame_gaps = 0 ;cwe id:CWE-119context: WORD32 ih264d_decode_gaps_in_frame_num ( dec_struct_t * ps_dec , UWORD16 u2_frame_num ) { UWORD32 u4_next_frm_num , u4_start_frm_num ; UWORD32 u4_max_frm_num ; pocstruct_t s_tmp_poc ; WORD32 i4_poc ; dec_slice_params_t * ps_cur_slice ; dec_pic_params_t * ps_pic_params ; WORD8 i1_gap_idx ; WORD32 * i4_gaps_start_frm_num ; dpb_manager_t * ps_dpb_mgr ; WORD32 i4_frame_gaps ; WORD8 * pi1_gaps_per_seq ; WORD32 ret ; ps_cur_slice = ps_dec -> ps_cur_slice ; if ( ps_cur_slice -> u1_field_pic_flag ) { if ( ps_dec -> u2_prev_ref_frame_num == u2_frame_num ) return 0 ; } u4_next_frm_num = ps_dec -> u2_prev_ref_frame_num + 1 ; u4_max_frm_num = ps_dec -> ps_cur_sps -> u2_u4_max_pic_num_minus1 + 1 ; if ( u4_next_frm_num >= u4_max_frm_num ) { u4_next_frm_num -= u4_max_frm_num ; } if ( u4_next_frm_num == u2_frame_num ) { return ( 0 ) ; } if ( ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) && ( u4_next_frm_num >= u2_frame_num ) ) { return ( 0 ) ; } u4_start_frm_num = u4_next_frm_num ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_pic_params = ps_dec -> ps_cur_pps ;  ps_cur_slice -> u1_field_pic_flag = 0 ;  i4_frame_gaps = 0 ; ps_dpb_mgr = ps_dec -> ps_dpb_mgr ; i4_gaps_start_frm_num = ps_dpb_mgr -> ai4_gaps_start_frm_num ; for ( i1_gap_idx = 0 ; i1_gap_idx < MAX_FRAMES ; i1_gap_idx ++ ) { if ( INVALID_FRAME_NUM == i4_gaps_start_frm_num [ i1_gap_idx ] ) break ; } if ( MAX_FRAMES == i1_gap_idx ) { UWORD32 i4_error_code ; i4_error_code = ERROR_DBP_MANAGER_T ; return i4_error_code ; } i4_poc = 0 ; i4_gaps_start_frm_num [ i1_gap_idx ] = u4_start_frm_num ; ps_dpb_mgr -> ai4_gaps_end_frm_num [ i1_gap_idx ] = u2_frame_num - 1 ; pi1_gaps_per_seq = ps_dpb_mgr -> ai1_gaps_per_seq ; pi1_gaps_per_seq [ i1_gap_idx ] = 0 ; while ( u4_next_frm_num != u2_frame_num ) { ih264d_delete_nonref_nondisplay_pics ( ps_dpb_mgr ) ; if ( ps_pic_params -> ps_sps -> u1_pic_order_cnt_type ) { ret = ih264d_decode_pic_order_cnt ( 0 , u4_next_frm_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pic_params , 1 , 0 , 0 , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } ps_cur_slice -> u1_mmco_equalto5 = 0 ; ps_cur_slice -> u2_frame_num = u4_next_frm_num ; } if ( ps_dpb_mgr -> i1_poc_buf_id_entries >= ps_dec -> u1_max_dec_frame_buffering ) { ret = ih264d_assign_display_seq ( ps_dec ) ; if ( ret != OK ) return ret ; } ret = ih264d_insert_pic_in_display_list ( ps_dec -> ps_dpb_mgr , ( WORD8 ) DO_NOT_DISP , ( WORD32 ) ( ps_dec -> i4_prev_max_display_seq + i4_poc ) , u4_next_frm_num ) ; if ( ret != OK ) return ret ; pi1_gaps_per_seq [ i1_gap_idx ] ++ ; ret = ih264d_do_mmco_for_gaps ( ps_dpb_mgr , ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ; if ( ret != OK ) return ret ; ih264d_delete_nonref_nondisplay_pics ( ps_dpb_mgr ) ; u4_next_frm_num ++ ; if ( u4_next_frm_num >= u4_max_frm_num ) { u4_next_frm_num -= u4_max_frm_num ; } i4_frame_gaps ++ ; } return OK ; }",i4_frame_gaps = 0 ;,2245
126,"buggy line: memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ;if ( p -> fname ) {if ( priv -> ctrl . fname == NULL )  rc = - ENOMEM ;}cwe id:CWE-416context: static int xc2028_set_config ( struct dvb_frontend * fe , void * priv_cfg ) { struct xc2028_data * priv = fe -> tuner_priv ; struct xc2028_ctrl * p = priv_cfg ; int rc = 0 ; tuner_dbg ( ""%s<S2SV_blank>called\\n"" , __func__ ) ; mutex_lock ( & priv -> lock ) ; kfree ( priv -> ctrl . fname ) ;  memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ;  if ( p -> fname ) { priv -> ctrl . fname = kstrdup ( p -> fname , GFP_KERNEL ) ; if ( priv -> ctrl . fname == NULL )  rc = - ENOMEM ;  } if ( ! firmware_name [ 0 ] && p -> fname && priv -> fname && strcmp ( p -> fname , priv -> fname ) ) free_firmware ( priv ) ; if ( priv -> ctrl . max_len < 9 ) priv -> ctrl . max_len = 13 ; if ( priv -> state == XC2028_NO_FIRMWARE ) { if ( ! firmware_name [ 0 ] ) priv -> fname = priv -> ctrl . fname ; else priv -> fname = firmware_name ; rc = request_firmware_nowait ( THIS_MODULE , 1 , priv -> fname , priv -> i2c_props . adap -> dev . parent , GFP_KERNEL , fe , load_firmware_cb ) ; if ( rc < 0 ) { tuner_err ( ""Failed<S2SV_blank>to<S2SV_blank>request<S2SV_blank>firmware<S2SV_blank>%s\\n"" , priv -> fname ) ; priv -> state = XC2028_NODEV ; } else priv -> state = XC2028_WAITING_FIRMWARE ; } mutex_unlock ( & priv -> lock ) ; return rc ; }","priv -> ctrl . fname = NULL ;memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ;if ( p -> fname ) {if ( priv -> ctrl . fname == NULL ) return - ENOMEM ;}",2246
127,"buggy line: if ( ( ctxt -> options & XML_PARSE_OLD10 ) == 0 ) {if ( ( c == \'<S2SV_blank>\' ) || ( c == \'>\' ) || ( c == \'/\' ) || ( ! ( ( ( c >= \'a\' ) && ( c <= \'z\' ) ) || ( ( c >= \'A\' ) && ( c <= \'Z\' ) ) || ( c == \'_\' ) || ( c == \':\' ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) ) {return ( NULL ) ;len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;while ( ( c != \'<S2SV_blank>\' ) && ( c != \'>\' ) && ( c != \'/\' ) && ( ( ( c >= \'a\' ) && ( c <= \'z\' ) ) || ( ( c >= \'A\' ) && ( c <= \'Z\' ) ) || ( ( c >= \'0\' ) && ( c <= \'9\' ) ) || ( c == \'_\' ) || ( c == \':\' ) || ( c == \'-\' ) || ( c == \'.\' ) || ( c == 0xB7 ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x300 ) && ( c <= 0x36F ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x203F ) && ( c <= 0x2040 ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) {if ( count ++ > XML_PARSER_CHUNK_SIZE ) {count = 0 ;GROW ;if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ;}len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;}else {if ( ( c == \'<S2SV_blank>\' ) || ( c == \'>\' ) || ( c == \'/\' ) || ( ! IS_LETTER ( c ) && ( c != \'_\' ) && ( c != \':\' ) ) ) {len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;while ( ( c != \'<S2SV_blank>\' ) && ( c != \'>\' ) && ( c != \'/\' ) && ( ( IS_LETTER ( c ) ) || ( IS_DIGIT ( c ) ) || ( c == \'.\' ) || ( c == \'-\' ) || ( c == \'_\' ) || ( c == \':\' ) || ( IS_COMBINING ( c ) ) || ( IS_EXTENDER ( c ) ) ) ) {if ( count ++ > XML_PARSER_CHUNK_SIZE ) {count = 0 ;GROW ;if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ;}len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;if ( c == 0 ) {count = 0 ;GROW ;if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ;c = CUR_CHAR ( l ) ;}}}if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) {xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ;return ( NULL ) ;cwe id:CWE-119context: static const xmlChar * xmlParseNameComplex ( xmlParserCtxtPtr ctxt ) { int len = 0 , l ; int c ; int count = 0 ; # ifdef DEBUG nbParseNameComplex ++ ; # endif GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; c = CUR_CHAR ( l ) ; if ( ( ctxt -> options & XML_PARSE_OLD10 ) == 0 ) { if ( ( c == '<S2SV_blank>' ) || ( c == '>' ) || ( c == '/' ) || ( ! ( ( ( c >= 'a' ) && ( c <= 'z' ) ) || ( ( c >= 'A' ) && ( c <= 'Z' ) ) || ( c == '_' ) || ( c == ':' ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) ) { return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; while ( ( c != '<S2SV_blank>' ) && ( c != '>' ) && ( c != '/' ) && ( ( ( c >= 'a' ) && ( c <= 'z' ) ) || ( ( c >= 'A' ) && ( c <= 'Z' ) ) || ( ( c >= '0' ) && ( c <= '9' ) ) || ( c == '_' ) || ( c == ':' ) || ( c == '-' ) || ( c == '.' ) || ( c == 0xB7 ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x300 ) && ( c <= 0x36F ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x203F ) && ( c <= 0x2040 ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) { if ( count ++ > XML_PARSER_CHUNK_SIZE ) { count = 0 ; GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; } } else { if ( ( c == '<S2SV_blank>' ) || ( c == '>' ) || ( c == '/' ) || ( ! IS_LETTER ( c ) && ( c != '_' ) && ( c != ':' ) ) ) { return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; while ( ( c != '<S2SV_blank>' ) && ( c != '>' ) && ( c != '/' ) && ( ( IS_LETTER ( c ) ) || ( IS_DIGIT ( c ) ) || ( c == '.' ) || ( c == '-' ) || ( c == '_' ) || ( c == ':' ) || ( IS_COMBINING ( c ) ) || ( IS_EXTENDER ( c ) ) ) ) { if ( count ++ > XML_PARSER_CHUNK_SIZE ) { count = 0 ; GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ;  if ( c == 0 ) {  count = 0 ; GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; c = CUR_CHAR ( l ) ; } } } if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) {  xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ;  return ( NULL ) ; } if ( ( * ctxt -> input -> cur == '\\n' ) && ( ctxt -> input -> cur [ - 1 ] == '\\r' ) ) return ( xmlDictLookup ( ctxt -> dict , ctxt -> input -> cur - ( len + 1 ) , len ) ) ; return ( xmlDictLookup ( ctxt -> dict , ctxt -> input -> cur - len , len ) ) ; }","if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) {xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ;if ( ctxt -> input -> cur - ctxt -> input -> base < len ) {xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , ""unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"" ) ;return ( NULL ) ;",2247
128,buggy line: if ( image -> depth == 1 )  return ( ( image -> columns + 7 ) / 8 ) ;else return ( image -> columns * GetPSDPacketSize ( image ) ) ;cwe id:CWE-125context: static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 )  return ( ( image -> columns + 7 ) / 8 ) ;  else return ( image -> columns * GetPSDPacketSize ( image ) ) ; },if ( image -> depth == 1 ) return ( ( ( image -> columns + 7 ) / 8 ) * GetPSDPacketSize ( image ) ) ;else return ( image -> columns * GetPSDPacketSize ( image ) ) ;,2248
129,"buggy line: p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_AUDIO_FORMAT ) ;sprintf ( nhml , ""bitsPerSample=\\\\""%d\\\\""<S2SV_blank>"" , gf_audio_fmt_bit_depth ( p -> value . uint ) ) ;cwe id:CWE-476context: static void nhmldump_send_header ( GF_NHMLDumpCtx * ctx ) { GF_FilterPacket * dst_pck ; char nhml [ 1024 ] ; u32 size ; u8 * output ; const GF_PropertyValue * p ; ctx -> szRootName = ""NHNTStream"" ; if ( ctx -> dims ) { ctx -> szRootName = ""DIMSStream"" ; } if ( ! ctx -> filep ) { sprintf ( nhml , ""<?xml<S2SV_blank>version=\\""1.0\\""<S2SV_blank>encoding=\\""UTF-8\\""<S2SV_blank>?>\\n"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } sprintf ( nhml , ""<%s<S2SV_blank>version=\\""1.0\\""<S2SV_blank>"" , ctx -> szRootName ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; NHML_PRINT_UINT ( GF_PROP_PID_ID , NULL , ""trackID"" ) NHML_PRINT_UINT ( GF_PROP_PID_TIMESCALE , NULL , ""timeScale"" ) p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_IN_IOD ) ; if ( p && p -> value . boolean ) { sprintf ( nhml , ""inRootOD=\\""yes\\""<S2SV_blank>"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } if ( ctx -> oti && ( ctx -> oti < GF_CODECID_LAST_MPEG4_MAPPING ) ) { sprintf ( nhml , ""streamType=\\""%d\\""<S2SV_blank>objectTypeIndication=\\""%d\\""<S2SV_blank>"" , ctx -> streamtype , ctx -> oti ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } else { p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_SUBTYPE ) ; if ( p ) { sprintf ( nhml , ""%s=\\""%s\\""<S2SV_blank>"" , ""mediaType"" , gf_4cc_to_str ( p -> value . uint ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; NHML_PRINT_4CC ( GF_PROP_PID_ISOM_SUBTYPE , ""mediaSubType"" , ""mediaSubType"" ) } else { NHML_PRINT_4CC ( GF_PROP_PID_CODECID , NULL , ""codecID"" ) } } if ( ctx -> w && ctx -> h ) { switch ( ctx -> streamtype ) { case GF_STREAM_VISUAL : case GF_STREAM_SCENE : sprintf ( nhml , ""width=\\""%d\\""<S2SV_blank>height=\\""%d\\""<S2SV_blank>"" , ctx -> w , ctx -> h ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; break ; default : break ; } } else if ( ctx -> sr && ctx -> chan ) { sprintf ( nhml , ""sampleRate=\\""%d\\""<S2SV_blank>numChannels=\\""%d\\""<S2SV_blank>"" , ctx -> sr , ctx -> chan ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; sprintf ( nhml , ""sampleRate=\\""%d\\""<S2SV_blank>numChannels=\\""%d\\""<S2SV_blank>"" , ctx -> sr , ctx -> chan ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ;  p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_AUDIO_FORMAT ) ;  sprintf ( nhml , ""bitsPerSample=\\""%d\\""<S2SV_blank>"" , gf_audio_fmt_bit_depth ( p -> value . uint ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } NHML_PRINT_4CC ( 0 , ""codec_vendor"" , ""codecVendor"" ) NHML_PRINT_UINT ( 0 , ""codec_version"" , ""codecVersion"" ) NHML_PRINT_UINT ( 0 , ""codec_revision"" , ""codecRevision"" ) NHML_PRINT_STRING ( 0 , ""compressor_name"" , ""compressorName"" ) NHML_PRINT_UINT ( 0 , ""temporal_quality"" , ""temporalQuality"" ) NHML_PRINT_UINT ( 0 , ""spatial_quality"" , ""spatialQuality"" ) NHML_PRINT_UINT ( 0 , ""hres"" , ""horizontalResolution"" ) NHML_PRINT_UINT ( 0 , ""vres"" , ""verticalResolution"" ) NHML_PRINT_UINT ( GF_PROP_PID_BIT_DEPTH_Y , NULL , ""bitDepth"" ) NHML_PRINT_STRING ( 0 , ""meta:xmlns"" , ""xml_namespace"" ) NHML_PRINT_STRING ( 0 , ""meta:schemaloc"" , ""xml_schema_location"" ) NHML_PRINT_STRING ( 0 , ""meta:mime"" , ""mime_type"" ) NHML_PRINT_STRING ( 0 , ""meta:config"" , ""config"" ) NHML_PRINT_STRING ( 0 , ""meta:aux_mimes"" , ""aux_mime_type"" ) if ( ctx -> codecid == GF_CODECID_DIMS ) { if ( gf_filter_pid_get_property_str ( ctx -> ipid , ""meta:xmlns"" ) == NULL ) { sprintf ( nhml , ""xmlns=\\""http://www.3gpp.org/richmedia\\""<S2SV_blank>"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } NHML_PRINT_UINT ( 0 , ""dims:profile"" , ""profile"" ) NHML_PRINT_UINT ( 0 , ""dims:level"" , ""level"" ) NHML_PRINT_UINT ( 0 , ""dims:pathComponents"" , ""pathComponents"" ) p = gf_filter_pid_get_property_str ( ctx -> ipid , ""dims:fullRequestHost"" ) ; if ( p ) { sprintf ( nhml , ""useFullRequestHost=\\""%s\\""<S2SV_blank>"" , p -> value . boolean ? ""yes"" : ""no"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } p = gf_filter_pid_get_property_str ( ctx -> ipid , ""dims:streamType"" ) ; if ( p ) { sprintf ( nhml , ""stream_type=\\""%s\\""<S2SV_blank>"" , p -> value . boolean ? ""primary"" : ""secondary"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } p = gf_filter_pid_get_property_str ( ctx -> ipid , ""dims:redundant"" ) ; if ( p ) { sprintf ( nhml , ""contains_redundant=\\""%s\\""<S2SV_blank>"" , ( p -> value . uint == 1 ) ? ""main"" : ( ( p -> value . uint == 1 ) ? ""redundant"" : ""main+redundant"" ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } NHML_PRINT_UINT ( 0 , ""dims:scriptTypes"" , ""scriptTypes"" ) } if ( ctx -> opid_info ) { sprintf ( nhml , ""specificInfoFile=\\""%s\\""<S2SV_blank>"" , gf_file_basename ( ctx -> info_file ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; dst_pck = gf_filter_pck_new_shared ( ctx -> opid_info , ctx -> dcfg , ctx -> dcfg_size , NULL ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; gf_filter_pck_set_readonly ( dst_pck ) ; gf_filter_pck_send ( dst_pck ) ; } NHML_PRINT_STRING ( 0 , ""meta:encoding"" , ""encoding"" ) NHML_PRINT_STRING ( 0 , ""meta:contentEncoding"" , ""content_encoding"" ) ctx -> uncompress = GF_FALSE ; if ( p ) { if ( ! strcmp ( p -> value . string , ""deflate"" ) ) ctx -> uncompress = GF_TRUE ; else { GF_LOG ( GF_LOG_ERROR , GF_LOG_AUTHOR , ( ""[NHMLMx]<S2SV_blank>content_encoding<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>supported\\n"" , p -> value . string ) ) ; } } if ( ctx -> opid_mdia ) { sprintf ( nhml , ""baseMediaFile=\\""%s\\""<S2SV_blank>"" , gf_file_basename ( ctx -> media_file ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } sprintf ( nhml , "">\\n"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; gf_bs_get_content_no_truncate ( ctx -> bs_w , & ctx -> nhml_buffer , & size , & ctx -> nhml_buffer_size ) ; if ( ctx -> filep ) { gf_fwrite ( ctx -> nhml_buffer , size , ctx -> filep ) ; return ; } dst_pck = gf_filter_pck_new_alloc ( ctx -> opid_nhml , size , & output ) ; memcpy ( output , ctx -> nhml_buffer , size ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_FALSE ) ; gf_filter_pck_send ( dst_pck ) ; }","p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_AUDIO_FORMAT ) ;if ( p ) sprintf ( nhml , ""bitsPerSample=\\\\""%d\\\\""<S2SV_blank>"" , gf_audio_fmt_bit_depth ( p -> value . uint ) ) ;",2249
130,"buggy line: bit_set_position ( dat , restartpos ) ;if ( i >= 0 && i < ( int ) dwg -> num_classes ) {cwe id:CWE-835context: int dwg_decode_add_object ( Dwg_Data * restrict dwg , Bit_Chain * dat , Bit_Chain * hdl_dat , long unsigned int address ) { long unsigned int objpos , restartpos ; Bit_Chain abs_dat = { NULL } ; unsigned char previous_bit ; Dwg_Object * restrict obj ; BITCODE_BL num = dwg -> num_objects ; int error = 0 ; int realloced = 0 ; abs_dat = * dat ; dat -> byte = address ; dat -> bit = 0 ; realloced = dwg_add_object ( dwg ) ; if ( realloced > 0 ) { * dat = abs_dat ; return realloced ; } obj = & dwg -> object [ num ] ; LOG_INFO ( ""==========================================\\n"" ""Object<S2SV_blank>number:<S2SV_blank>%lu/%lX"" , ( unsigned long ) num , ( unsigned long ) num ) obj -> size = bit_read_MS ( dat ) ; LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS]"" , obj -> size ) SINCE ( R_2010 ) { obj -> handlestream_size = bit_read_UMC ( dat ) ; LOG_INFO ( "",<S2SV_blank>Hdlsize:<S2SV_blank>"" FORMAT_UMC ""<S2SV_blank>[UMC]<S2SV_blank>"" , obj -> handlestream_size ) ; obj -> bitsize = obj -> size * 8 - obj -> handlestream_size ; } objpos = bit_position ( dat ) ; obj -> address = dat -> byte ; bit_reset_chain ( dat ) ; if ( obj -> size > dat -> size ) { LOG_ERROR ( ""\\nInvalid<S2SV_blank>object<S2SV_blank>size.<S2SV_blank>Would<S2SV_blank>overflow"" ) ; * dat = abs_dat ; return DWG_ERR_VALUEOUTOFBOUNDS ; } dat -> size = obj -> size ; SINCE ( R_2010 ) { obj -> type = bit_read_BOT ( dat ) ; } else { obj -> type = bit_read_BS ( dat ) ; } LOG_INFO ( "",<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[%s]\\n"" , obj -> type , dat -> version >= R_2010 ? ""BOT"" : ""BS"" ) ; restartpos = bit_position ( dat ) ; switch ( obj -> type ) { case DWG_TYPE_TEXT : error = dwg_decode_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : error = dwg_decode_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : error = dwg_decode_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : error = dwg_decode_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : error = dwg_decode_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : error = dwg_decode_SEQEND ( dat , obj ) ; if ( dat -> version >= R_13 && obj -> tio . entity -> ownerhandle ) { Dwg_Object * restrict owner = dwg_resolve_handle ( dwg , obj -> tio . entity -> ownerhandle -> absolute_ref ) ; if ( ! owner ) { LOG_WARN ( ""no<S2SV_blank>SEQEND.ownerhandle"" ) } else if ( owner -> fixedtype == DWG_TYPE_INSERT || owner -> fixedtype == DWG_TYPE_MINSERT ) { hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_INSERT ( owner ) ; } else if ( owner -> fixedtype == DWG_TYPE_POLYLINE_2D || owner -> fixedtype == DWG_TYPE_POLYLINE_3D || owner -> fixedtype == DWG_TYPE_POLYLINE_PFACE || owner -> fixedtype == DWG_TYPE_POLYLINE_MESH ) { Dwg_Entity_POLYLINE_2D * restrict _obj = owner -> tio . entity -> tio . POLYLINE_2D ; if ( ! _obj -> seqend ) hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_POLYLINE ( owner ) ; } } break ; case DWG_TYPE_INSERT : error = dwg_decode_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : error = dwg_decode_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : error = dwg_decode_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : error = dwg_decode_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : error = dwg_decode_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : error = dwg_decode_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : error = dwg_decode_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : error = dwg_decode_POLYLINE_2D ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_POLYLINE_3D : error = dwg_decode_POLYLINE_3D ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_ARC : error = dwg_decode_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : error = dwg_decode_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : error = dwg_decode_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : error = dwg_decode_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : error = dwg_decode_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : error = dwg_decode_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : error = dwg_decode_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : error = dwg_decode_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : error = dwg_decode_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : error = dwg_decode_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : error = dwg_decode_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : error = dwg_decode__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : error = dwg_decode_POLYLINE_PFACE ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : error = dwg_decode_POLYLINE_MESH ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_SOLID : error = dwg_decode_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : error = dwg_decode_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : error = dwg_decode_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : error = dwg_decode_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : error = dwg_decode_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : error = dwg_decode_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : error = dwg_decode_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : error = dwg_decode__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : error = dwg_decode_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : error = dwg_decode_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : error = dwg_decode_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : error = dwg_decode_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : error = dwg_decode_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : error = dwg_decode_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : error = dwg_decode_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : error = dwg_decode_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : error = dwg_decode_BLOCK_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . BLOCK_CONTROL ) { obj -> tio . object -> tio . BLOCK_CONTROL -> objid = num ; if ( ! dwg -> block_control . parent ) dwg -> block_control = * obj -> tio . object -> tio . BLOCK_CONTROL ; else LOG_WARN ( ""Second<S2SV_blank>BLOCK_CONTROL<S2SV_blank>object<S2SV_blank>ignored"" ) ; } break ; case DWG_TYPE_BLOCK_HEADER : error = dwg_decode_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : error = dwg_decode_LAYER_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . LAYER_CONTROL ) { obj -> tio . object -> tio . LAYER_CONTROL -> objid = num ; dwg -> layer_control = * obj -> tio . object -> tio . LAYER_CONTROL ; } break ; case DWG_TYPE_LAYER : error = dwg_decode_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : error = dwg_decode_STYLE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . STYLE_CONTROL ) { obj -> tio . object -> tio . STYLE_CONTROL -> objid = num ; dwg -> style_control = * obj -> tio . object -> tio . STYLE_CONTROL ; } break ; case DWG_TYPE_STYLE : error = dwg_decode_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : error = dwg_decode_LTYPE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . LTYPE_CONTROL ) { obj -> tio . object -> tio . LTYPE_CONTROL -> objid = num ; dwg -> ltype_control = * obj -> tio . object -> tio . LTYPE_CONTROL ; } break ; case DWG_TYPE_LTYPE : error = dwg_decode_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : error = dwg_decode_VIEW_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VIEW_CONTROL ) { obj -> tio . object -> tio . VIEW_CONTROL -> objid = num ; dwg -> view_control = * obj -> tio . object -> tio . VIEW_CONTROL ; } break ; case DWG_TYPE_VIEW : error = dwg_decode_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : error = dwg_decode_UCS_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . UCS_CONTROL ) { obj -> tio . object -> tio . UCS_CONTROL -> objid = num ; dwg -> ucs_control = * obj -> tio . object -> tio . UCS_CONTROL ; } break ; case DWG_TYPE_UCS : error = dwg_decode_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : error = dwg_decode_VPORT_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VPORT_CONTROL ) { obj -> tio . object -> tio . VPORT_CONTROL -> objid = num ; dwg -> vport_control = * obj -> tio . object -> tio . VPORT_CONTROL ; } break ; case DWG_TYPE_VPORT : error = dwg_decode_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : error = dwg_decode_APPID_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . APPID_CONTROL ) { obj -> tio . object -> tio . APPID_CONTROL -> objid = num ; dwg -> appid_control = * obj -> tio . object -> tio . APPID_CONTROL ; } break ; case DWG_TYPE_APPID : error = dwg_decode_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : error = dwg_decode_DIMSTYLE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . DIMSTYLE_CONTROL ) { obj -> tio . object -> tio . DIMSTYLE_CONTROL -> objid = num ; dwg -> dimstyle_control = * obj -> tio . object -> tio . DIMSTYLE_CONTROL ; } break ; case DWG_TYPE_DIMSTYLE : error = dwg_decode_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : error = dwg_decode_VPORT_ENTITY_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VPORT_ENTITY_CONTROL ) { obj -> tio . object -> tio . VPORT_ENTITY_CONTROL -> objid = num ; dwg -> vport_entity_control = * obj -> tio . object -> tio . VPORT_ENTITY_CONTROL ; } break ; case DWG_TYPE_VPORT_ENTITY_HEADER : error = dwg_decode_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : error = dwg_decode_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : error = dwg_decode_MLINESTYLE ( dat , obj ) ; break ; case DWG_TYPE_OLE2FRAME : error = dwg_decode_OLE2FRAME ( dat , obj ) ; break ; case DWG_TYPE_DUMMY : error = dwg_decode_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : error = dwg_decode_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : error = dwg_decode_LWPOLYLINE ( dat , obj ) ; break ; case DWG_TYPE_HATCH : error = dwg_decode_HATCH ( dat , obj ) ; break ; case DWG_TYPE_XRECORD : error = dwg_decode_XRECORD ( dat , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : error = dwg_decode_PLACEHOLDER ( dat , obj ) ; break ; case DWG_TYPE_OLEFRAME : error = dwg_decode_OLEFRAME ( dat , obj ) ; break ; case DWG_TYPE_VBA_PROJECT : LOG_ERROR ( ""Unhandled<S2SV_blank>Object<S2SV_blank>VBA_PROJECT.<S2SV_blank>Has<S2SV_blank>its<S2SV_blank>own<S2SV_blank>section"" ) ; error = DWG_ERR_UNHANDLEDCLASS ; break ; case DWG_TYPE_LAYOUT : error = dwg_decode_LAYOUT ( dat , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : error = dwg_decode_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : error = dwg_decode_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == dwg -> layout_type ) error = dwg_decode_LAYOUT ( dat , obj ) ; else if ( ( error = dwg_decode_variable_type ( dwg , dat , hdl_dat , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { int is_entity = 0 ; int i = obj -> type - 500 ; Dwg_Class * klass = NULL ;  bit_set_position ( dat , restartpos ) ;  if ( i >= 0 && i < ( int ) dwg -> num_classes ) { klass = & dwg -> dwg_class [ i ] ; is_entity = dwg_class_is_entity ( klass ) ; } else { if ( i < 0 ) { LOG_ERROR ( ""Invalid<S2SV_blank>class<S2SV_blank>index<S2SV_blank>%d<S2SV_blank><0"" , i ) ; } else { LOG_ERROR ( ""Invalid<S2SV_blank>class<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>>%d"" , i , ( int ) dwg -> num_classes ) ; }  obj -> supertype = DWG_SUPERTYPE_UNKNOWN ;  obj -> type = 0 ; * dat = abs_dat ; return error | DWG_ERR_VALUEOUTOFBOUNDS ; }  if ( klass && ! is_entity )  { int err = dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; error |= err ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; if ( ! dat ) return error ;  if ( err >= DWG_ERR_CRITICAL )  * dat = abs_dat ;  }  else if ( klass ) { int err ; # if 0 && ! defined ( IS_RELEASE ) if ( strEQc ( klass -> dxfname , ""MULTILEADER"" ) ) { char * mleader = bit_read_TF ( dat , obj -> size ) ; LOG_INSANE_TF ( mleader , ( int ) obj -> size ) bit_set_position ( dat , restartpos ) ; free ( mleader ) ; } # endif err = dwg_decode_UNKNOWN_ENT ( dat , obj ) ; error |= err ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; if ( ! dat ) return error ; if ( err >= DWG_ERR_CRITICAL ) * dat = abs_dat ; } else { LOG_WARN ( ""Unknown<S2SV_blank>object,<S2SV_blank>skipping<S2SV_blank>eed/reactors/xdic"" ) ; SINCE ( R_2000 ) { obj -> bitsize = bit_read_RL ( dat ) ; LOG_TRACE ( ""bitsize:<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>[RL]<S2SV_blank>@%lu.%u\\n"" , obj -> bitsize , dat -> byte - 2 , dat -> bit ) ; if ( obj -> bitsize > obj -> size * 8 ) { LOG_ERROR ( ""Invalid<S2SV_blank>bitsize<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>=><S2SV_blank>"" FORMAT_RL , obj -> bitsize , obj -> size * 8 ) ; obj -> bitsize = obj -> size * 8 ; error |= DWG_ERR_VALUEOUTOFBOUNDS ; } } if ( ! bit_read_H ( dat , & obj -> handle ) ) { LOG_TRACE ( ""handle:<S2SV_blank>"" FORMAT_H ""<S2SV_blank>[H<S2SV_blank>5]\\n"" , ARGS_H ( obj -> handle ) ) ; } restartpos = dat -> byte ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; obj -> tio . unknown = bit_read_TF ( dat , obj -> size ) ; dat -> byte = restartpos ; } } } if ( obj -> handle . value ) { LOG_HANDLE ( ""<S2SV_blank>object_map{%lX}<S2SV_blank>=<S2SV_blank>%lu\\n"" , obj -> handle . value , ( unsigned long ) num ) ; hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; } if ( dat -> byte > 8 * dat -> size ) { LOG_ERROR ( ""Invalid<S2SV_blank>object<S2SV_blank>address<S2SV_blank>(overflow):<S2SV_blank>%lu<S2SV_blank>><S2SV_blank>%lu"" , dat -> byte , 8 * dat -> size ) ; * dat = abs_dat ; return error | DWG_ERR_INVALIDDWG ; } restartpos = bit_position ( dat ) ; * dat = abs_dat ; bit_set_position ( dat , objpos + restartpos ) ; if ( dat -> bit ) { unsigned char r = 8 - dat -> bit ; LOG_HANDLE ( ""<S2SV_blank>padding:<S2SV_blank>%X/%X<S2SV_blank>(%d<S2SV_blank>bits)\\n"" , dat -> chain [ dat -> byte ] , dat -> chain [ dat -> byte ] & ( ( 1 << r ) - 1 ) , r ) ; bit_advance_position ( dat , r ) ; } bit_set_position ( dat , ( obj -> address + obj -> size ) * 8 - 2 ) ; if ( ! bit_check_CRC ( dat , address , 0xC0C1 ) ) error |= DWG_ERR_WRONGCRC ; * dat = abs_dat ; return realloced ? - 1 : error ; }","bit_set_position ( dat , restartpos ) ;obj -> supertype = DWG_SUPERTYPE_UNKNOWN ;if ( i >= 0 && i < ( int ) dwg -> num_classes ) {",2250
131,"buggy line: obj -> supertype = DWG_SUPERTYPE_UNKNOWN ;obj -> type = 0 ;if ( klass && ! is_entity )  {int err = dwg_decode_UNKNOWN_OBJ ( dat , obj ) ;error |= err ;obj -> supertype = DWG_SUPERTYPE_UNKNOWN ;if ( err >= DWG_ERR_CRITICAL )  * dat = abs_dat ;}else if ( klass ) {cwe id:CWE-835context: int dwg_decode_add_object ( Dwg_Data * restrict dwg , Bit_Chain * dat , Bit_Chain * hdl_dat , long unsigned int address ) { long unsigned int objpos , restartpos ; Bit_Chain abs_dat = { NULL } ; unsigned char previous_bit ; Dwg_Object * restrict obj ; BITCODE_BL num = dwg -> num_objects ; int error = 0 ; int realloced = 0 ; abs_dat = * dat ; dat -> byte = address ; dat -> bit = 0 ; realloced = dwg_add_object ( dwg ) ; if ( realloced > 0 ) { * dat = abs_dat ; return realloced ; } obj = & dwg -> object [ num ] ; LOG_INFO ( ""==========================================\\n"" ""Object<S2SV_blank>number:<S2SV_blank>%lu/%lX"" , ( unsigned long ) num , ( unsigned long ) num ) obj -> size = bit_read_MS ( dat ) ; LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS]"" , obj -> size ) SINCE ( R_2010 ) { obj -> handlestream_size = bit_read_UMC ( dat ) ; LOG_INFO ( "",<S2SV_blank>Hdlsize:<S2SV_blank>"" FORMAT_UMC ""<S2SV_blank>[UMC]<S2SV_blank>"" , obj -> handlestream_size ) ; obj -> bitsize = obj -> size * 8 - obj -> handlestream_size ; } objpos = bit_position ( dat ) ; obj -> address = dat -> byte ; bit_reset_chain ( dat ) ; if ( obj -> size > dat -> size ) { LOG_ERROR ( ""\\nInvalid<S2SV_blank>object<S2SV_blank>size.<S2SV_blank>Would<S2SV_blank>overflow"" ) ; * dat = abs_dat ; return DWG_ERR_VALUEOUTOFBOUNDS ; } dat -> size = obj -> size ; SINCE ( R_2010 ) { obj -> type = bit_read_BOT ( dat ) ; } else { obj -> type = bit_read_BS ( dat ) ; } LOG_INFO ( "",<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[%s]\\n"" , obj -> type , dat -> version >= R_2010 ? ""BOT"" : ""BS"" ) ; restartpos = bit_position ( dat ) ; switch ( obj -> type ) { case DWG_TYPE_TEXT : error = dwg_decode_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : error = dwg_decode_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : error = dwg_decode_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : error = dwg_decode_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : error = dwg_decode_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : error = dwg_decode_SEQEND ( dat , obj ) ; if ( dat -> version >= R_13 && obj -> tio . entity -> ownerhandle ) { Dwg_Object * restrict owner = dwg_resolve_handle ( dwg , obj -> tio . entity -> ownerhandle -> absolute_ref ) ; if ( ! owner ) { LOG_WARN ( ""no<S2SV_blank>SEQEND.ownerhandle"" ) } else if ( owner -> fixedtype == DWG_TYPE_INSERT || owner -> fixedtype == DWG_TYPE_MINSERT ) { hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_INSERT ( owner ) ; } else if ( owner -> fixedtype == DWG_TYPE_POLYLINE_2D || owner -> fixedtype == DWG_TYPE_POLYLINE_3D || owner -> fixedtype == DWG_TYPE_POLYLINE_PFACE || owner -> fixedtype == DWG_TYPE_POLYLINE_MESH ) { Dwg_Entity_POLYLINE_2D * restrict _obj = owner -> tio . entity -> tio . POLYLINE_2D ; if ( ! _obj -> seqend ) hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_POLYLINE ( owner ) ; } } break ; case DWG_TYPE_INSERT : error = dwg_decode_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : error = dwg_decode_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : error = dwg_decode_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : error = dwg_decode_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : error = dwg_decode_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : error = dwg_decode_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : error = dwg_decode_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : error = dwg_decode_POLYLINE_2D ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_POLYLINE_3D : error = dwg_decode_POLYLINE_3D ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_ARC : error = dwg_decode_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : error = dwg_decode_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : error = dwg_decode_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : error = dwg_decode_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : error = dwg_decode_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : error = dwg_decode_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : error = dwg_decode_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : error = dwg_decode_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : error = dwg_decode_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : error = dwg_decode_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : error = dwg_decode_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : error = dwg_decode__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : error = dwg_decode_POLYLINE_PFACE ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : error = dwg_decode_POLYLINE_MESH ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_SOLID : error = dwg_decode_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : error = dwg_decode_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : error = dwg_decode_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : error = dwg_decode_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : error = dwg_decode_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : error = dwg_decode_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : error = dwg_decode_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : error = dwg_decode__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : error = dwg_decode_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : error = dwg_decode_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : error = dwg_decode_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : error = dwg_decode_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : error = dwg_decode_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : error = dwg_decode_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : error = dwg_decode_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : error = dwg_decode_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : error = dwg_decode_BLOCK_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . BLOCK_CONTROL ) { obj -> tio . object -> tio . BLOCK_CONTROL -> objid = num ; if ( ! dwg -> block_control . parent ) dwg -> block_control = * obj -> tio . object -> tio . BLOCK_CONTROL ; else LOG_WARN ( ""Second<S2SV_blank>BLOCK_CONTROL<S2SV_blank>object<S2SV_blank>ignored"" ) ; } break ; case DWG_TYPE_BLOCK_HEADER : error = dwg_decode_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : error = dwg_decode_LAYER_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . LAYER_CONTROL ) { obj -> tio . object -> tio . LAYER_CONTROL -> objid = num ; dwg -> layer_control = * obj -> tio . object -> tio . LAYER_CONTROL ; } break ; case DWG_TYPE_LAYER : error = dwg_decode_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : error = dwg_decode_STYLE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . STYLE_CONTROL ) { obj -> tio . object -> tio . STYLE_CONTROL -> objid = num ; dwg -> style_control = * obj -> tio . object -> tio . STYLE_CONTROL ; } break ; case DWG_TYPE_STYLE : error = dwg_decode_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : error = dwg_decode_LTYPE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . LTYPE_CONTROL ) { obj -> tio . object -> tio . LTYPE_CONTROL -> objid = num ; dwg -> ltype_control = * obj -> tio . object -> tio . LTYPE_CONTROL ; } break ; case DWG_TYPE_LTYPE : error = dwg_decode_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : error = dwg_decode_VIEW_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VIEW_CONTROL ) { obj -> tio . object -> tio . VIEW_CONTROL -> objid = num ; dwg -> view_control = * obj -> tio . object -> tio . VIEW_CONTROL ; } break ; case DWG_TYPE_VIEW : error = dwg_decode_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : error = dwg_decode_UCS_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . UCS_CONTROL ) { obj -> tio . object -> tio . UCS_CONTROL -> objid = num ; dwg -> ucs_control = * obj -> tio . object -> tio . UCS_CONTROL ; } break ; case DWG_TYPE_UCS : error = dwg_decode_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : error = dwg_decode_VPORT_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VPORT_CONTROL ) { obj -> tio . object -> tio . VPORT_CONTROL -> objid = num ; dwg -> vport_control = * obj -> tio . object -> tio . VPORT_CONTROL ; } break ; case DWG_TYPE_VPORT : error = dwg_decode_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : error = dwg_decode_APPID_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . APPID_CONTROL ) { obj -> tio . object -> tio . APPID_CONTROL -> objid = num ; dwg -> appid_control = * obj -> tio . object -> tio . APPID_CONTROL ; } break ; case DWG_TYPE_APPID : error = dwg_decode_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : error = dwg_decode_DIMSTYLE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . DIMSTYLE_CONTROL ) { obj -> tio . object -> tio . DIMSTYLE_CONTROL -> objid = num ; dwg -> dimstyle_control = * obj -> tio . object -> tio . DIMSTYLE_CONTROL ; } break ; case DWG_TYPE_DIMSTYLE : error = dwg_decode_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : error = dwg_decode_VPORT_ENTITY_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VPORT_ENTITY_CONTROL ) { obj -> tio . object -> tio . VPORT_ENTITY_CONTROL -> objid = num ; dwg -> vport_entity_control = * obj -> tio . object -> tio . VPORT_ENTITY_CONTROL ; } break ; case DWG_TYPE_VPORT_ENTITY_HEADER : error = dwg_decode_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : error = dwg_decode_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : error = dwg_decode_MLINESTYLE ( dat , obj ) ; break ; case DWG_TYPE_OLE2FRAME : error = dwg_decode_OLE2FRAME ( dat , obj ) ; break ; case DWG_TYPE_DUMMY : error = dwg_decode_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : error = dwg_decode_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : error = dwg_decode_LWPOLYLINE ( dat , obj ) ; break ; case DWG_TYPE_HATCH : error = dwg_decode_HATCH ( dat , obj ) ; break ; case DWG_TYPE_XRECORD : error = dwg_decode_XRECORD ( dat , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : error = dwg_decode_PLACEHOLDER ( dat , obj ) ; break ; case DWG_TYPE_OLEFRAME : error = dwg_decode_OLEFRAME ( dat , obj ) ; break ; case DWG_TYPE_VBA_PROJECT : LOG_ERROR ( ""Unhandled<S2SV_blank>Object<S2SV_blank>VBA_PROJECT.<S2SV_blank>Has<S2SV_blank>its<S2SV_blank>own<S2SV_blank>section"" ) ; error = DWG_ERR_UNHANDLEDCLASS ; break ; case DWG_TYPE_LAYOUT : error = dwg_decode_LAYOUT ( dat , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : error = dwg_decode_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : error = dwg_decode_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == dwg -> layout_type ) error = dwg_decode_LAYOUT ( dat , obj ) ; else if ( ( error = dwg_decode_variable_type ( dwg , dat , hdl_dat , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { int is_entity = 0 ; int i = obj -> type - 500 ; Dwg_Class * klass = NULL ;  bit_set_position ( dat , restartpos ) ;  if ( i >= 0 && i < ( int ) dwg -> num_classes ) { klass = & dwg -> dwg_class [ i ] ; is_entity = dwg_class_is_entity ( klass ) ; } else { if ( i < 0 ) { LOG_ERROR ( ""Invalid<S2SV_blank>class<S2SV_blank>index<S2SV_blank>%d<S2SV_blank><0"" , i ) ; } else { LOG_ERROR ( ""Invalid<S2SV_blank>class<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>>%d"" , i , ( int ) dwg -> num_classes ) ; }  obj -> supertype = DWG_SUPERTYPE_UNKNOWN ;  obj -> type = 0 ; * dat = abs_dat ; return error | DWG_ERR_VALUEOUTOFBOUNDS ; }  if ( klass && ! is_entity )  { int err = dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; error |= err ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; if ( ! dat ) return error ;  if ( err >= DWG_ERR_CRITICAL )  * dat = abs_dat ;  }  else if ( klass ) { int err ; # if 0 && ! defined ( IS_RELEASE ) if ( strEQc ( klass -> dxfname , ""MULTILEADER"" ) ) { char * mleader = bit_read_TF ( dat , obj -> size ) ; LOG_INSANE_TF ( mleader , ( int ) obj -> size ) bit_set_position ( dat , restartpos ) ; free ( mleader ) ; } # endif err = dwg_decode_UNKNOWN_ENT ( dat , obj ) ; error |= err ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; if ( ! dat ) return error ; if ( err >= DWG_ERR_CRITICAL ) * dat = abs_dat ; } else { LOG_WARN ( ""Unknown<S2SV_blank>object,<S2SV_blank>skipping<S2SV_blank>eed/reactors/xdic"" ) ; SINCE ( R_2000 ) { obj -> bitsize = bit_read_RL ( dat ) ; LOG_TRACE ( ""bitsize:<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>[RL]<S2SV_blank>@%lu.%u\\n"" , obj -> bitsize , dat -> byte - 2 , dat -> bit ) ; if ( obj -> bitsize > obj -> size * 8 ) { LOG_ERROR ( ""Invalid<S2SV_blank>bitsize<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>=><S2SV_blank>"" FORMAT_RL , obj -> bitsize , obj -> size * 8 ) ; obj -> bitsize = obj -> size * 8 ; error |= DWG_ERR_VALUEOUTOFBOUNDS ; } } if ( ! bit_read_H ( dat , & obj -> handle ) ) { LOG_TRACE ( ""handle:<S2SV_blank>"" FORMAT_H ""<S2SV_blank>[H<S2SV_blank>5]\\n"" , ARGS_H ( obj -> handle ) ) ; } restartpos = dat -> byte ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; obj -> tio . unknown = bit_read_TF ( dat , obj -> size ) ; dat -> byte = restartpos ; } } } if ( obj -> handle . value ) { LOG_HANDLE ( ""<S2SV_blank>object_map{%lX}<S2SV_blank>=<S2SV_blank>%lu\\n"" , obj -> handle . value , ( unsigned long ) num ) ; hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; } if ( dat -> byte > 8 * dat -> size ) { LOG_ERROR ( ""Invalid<S2SV_blank>object<S2SV_blank>address<S2SV_blank>(overflow):<S2SV_blank>%lu<S2SV_blank>><S2SV_blank>%lu"" , dat -> byte , 8 * dat -> size ) ; * dat = abs_dat ; return error | DWG_ERR_INVALIDDWG ; } restartpos = bit_position ( dat ) ; * dat = abs_dat ; bit_set_position ( dat , objpos + restartpos ) ; if ( dat -> bit ) { unsigned char r = 8 - dat -> bit ; LOG_HANDLE ( ""<S2SV_blank>padding:<S2SV_blank>%X/%X<S2SV_blank>(%d<S2SV_blank>bits)\\n"" , dat -> chain [ dat -> byte ] , dat -> chain [ dat -> byte ] & ( ( 1 << r ) - 1 ) , r ) ; bit_advance_position ( dat , r ) ; } bit_set_position ( dat , ( obj -> address + obj -> size ) * 8 - 2 ) ; if ( ! bit_check_CRC ( dat , address , 0xC0C1 ) ) error |= DWG_ERR_WRONGCRC ; * dat = abs_dat ; return realloced ? - 1 : error ; }","obj -> type = 0 ;if ( is_entity ) error |= dwg_decode_UNKNOWN_ENT ( dat , obj ) ;else error |= dwg_decode_UNKNOWN_OBJ ( dat , obj ) ;if ( err >= DWG_ERR_CRITICAL ) * dat = abs_dat ;}else if ( klass ) {",2250
132,"buggy line: if ( ! dat ) return error ;if ( err >= DWG_ERR_CRITICAL ) * dat = abs_dat ;cwe id:CWE-835context: int dwg_decode_add_object ( Dwg_Data * restrict dwg , Bit_Chain * dat , Bit_Chain * hdl_dat , long unsigned int address ) { long unsigned int objpos , restartpos ; Bit_Chain abs_dat = { NULL } ; unsigned char previous_bit ; Dwg_Object * restrict obj ; BITCODE_BL num = dwg -> num_objects ; int error = 0 ; int realloced = 0 ; abs_dat = * dat ; dat -> byte = address ; dat -> bit = 0 ; realloced = dwg_add_object ( dwg ) ; if ( realloced > 0 ) { * dat = abs_dat ; return realloced ; } obj = & dwg -> object [ num ] ; LOG_INFO ( ""==========================================\\n"" ""Object<S2SV_blank>number:<S2SV_blank>%lu/%lX"" , ( unsigned long ) num , ( unsigned long ) num ) obj -> size = bit_read_MS ( dat ) ; LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS]"" , obj -> size ) SINCE ( R_2010 ) { obj -> handlestream_size = bit_read_UMC ( dat ) ; LOG_INFO ( "",<S2SV_blank>Hdlsize:<S2SV_blank>"" FORMAT_UMC ""<S2SV_blank>[UMC]<S2SV_blank>"" , obj -> handlestream_size ) ; obj -> bitsize = obj -> size * 8 - obj -> handlestream_size ; } objpos = bit_position ( dat ) ; obj -> address = dat -> byte ; bit_reset_chain ( dat ) ; if ( obj -> size > dat -> size ) { LOG_ERROR ( ""\\nInvalid<S2SV_blank>object<S2SV_blank>size.<S2SV_blank>Would<S2SV_blank>overflow"" ) ; * dat = abs_dat ; return DWG_ERR_VALUEOUTOFBOUNDS ; } dat -> size = obj -> size ; SINCE ( R_2010 ) { obj -> type = bit_read_BOT ( dat ) ; } else { obj -> type = bit_read_BS ( dat ) ; } LOG_INFO ( "",<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[%s]\\n"" , obj -> type , dat -> version >= R_2010 ? ""BOT"" : ""BS"" ) ; restartpos = bit_position ( dat ) ; switch ( obj -> type ) { case DWG_TYPE_TEXT : error = dwg_decode_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : error = dwg_decode_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : error = dwg_decode_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : error = dwg_decode_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : error = dwg_decode_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : error = dwg_decode_SEQEND ( dat , obj ) ; if ( dat -> version >= R_13 && obj -> tio . entity -> ownerhandle ) { Dwg_Object * restrict owner = dwg_resolve_handle ( dwg , obj -> tio . entity -> ownerhandle -> absolute_ref ) ; if ( ! owner ) { LOG_WARN ( ""no<S2SV_blank>SEQEND.ownerhandle"" ) } else if ( owner -> fixedtype == DWG_TYPE_INSERT || owner -> fixedtype == DWG_TYPE_MINSERT ) { hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_INSERT ( owner ) ; } else if ( owner -> fixedtype == DWG_TYPE_POLYLINE_2D || owner -> fixedtype == DWG_TYPE_POLYLINE_3D || owner -> fixedtype == DWG_TYPE_POLYLINE_PFACE || owner -> fixedtype == DWG_TYPE_POLYLINE_MESH ) { Dwg_Entity_POLYLINE_2D * restrict _obj = owner -> tio . entity -> tio . POLYLINE_2D ; if ( ! _obj -> seqend ) hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_POLYLINE ( owner ) ; } } break ; case DWG_TYPE_INSERT : error = dwg_decode_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : error = dwg_decode_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : error = dwg_decode_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : error = dwg_decode_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : error = dwg_decode_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : error = dwg_decode_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : error = dwg_decode_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : error = dwg_decode_POLYLINE_2D ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_POLYLINE_3D : error = dwg_decode_POLYLINE_3D ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_ARC : error = dwg_decode_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : error = dwg_decode_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : error = dwg_decode_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : error = dwg_decode_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : error = dwg_decode_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : error = dwg_decode_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : error = dwg_decode_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : error = dwg_decode_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : error = dwg_decode_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : error = dwg_decode_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : error = dwg_decode_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : error = dwg_decode__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : error = dwg_decode_POLYLINE_PFACE ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : error = dwg_decode_POLYLINE_MESH ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_SOLID : error = dwg_decode_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : error = dwg_decode_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : error = dwg_decode_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : error = dwg_decode_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : error = dwg_decode_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : error = dwg_decode_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : error = dwg_decode_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : error = dwg_decode__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : error = dwg_decode_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : error = dwg_decode_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : error = dwg_decode_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : error = dwg_decode_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : error = dwg_decode_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : error = dwg_decode_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : error = dwg_decode_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : error = dwg_decode_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : error = dwg_decode_BLOCK_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . BLOCK_CONTROL ) { obj -> tio . object -> tio . BLOCK_CONTROL -> objid = num ; if ( ! dwg -> block_control . parent ) dwg -> block_control = * obj -> tio . object -> tio . BLOCK_CONTROL ; else LOG_WARN ( ""Second<S2SV_blank>BLOCK_CONTROL<S2SV_blank>object<S2SV_blank>ignored"" ) ; } break ; case DWG_TYPE_BLOCK_HEADER : error = dwg_decode_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : error = dwg_decode_LAYER_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . LAYER_CONTROL ) { obj -> tio . object -> tio . LAYER_CONTROL -> objid = num ; dwg -> layer_control = * obj -> tio . object -> tio . LAYER_CONTROL ; } break ; case DWG_TYPE_LAYER : error = dwg_decode_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : error = dwg_decode_STYLE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . STYLE_CONTROL ) { obj -> tio . object -> tio . STYLE_CONTROL -> objid = num ; dwg -> style_control = * obj -> tio . object -> tio . STYLE_CONTROL ; } break ; case DWG_TYPE_STYLE : error = dwg_decode_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : error = dwg_decode_LTYPE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . LTYPE_CONTROL ) { obj -> tio . object -> tio . LTYPE_CONTROL -> objid = num ; dwg -> ltype_control = * obj -> tio . object -> tio . LTYPE_CONTROL ; } break ; case DWG_TYPE_LTYPE : error = dwg_decode_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : error = dwg_decode_VIEW_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VIEW_CONTROL ) { obj -> tio . object -> tio . VIEW_CONTROL -> objid = num ; dwg -> view_control = * obj -> tio . object -> tio . VIEW_CONTROL ; } break ; case DWG_TYPE_VIEW : error = dwg_decode_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : error = dwg_decode_UCS_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . UCS_CONTROL ) { obj -> tio . object -> tio . UCS_CONTROL -> objid = num ; dwg -> ucs_control = * obj -> tio . object -> tio . UCS_CONTROL ; } break ; case DWG_TYPE_UCS : error = dwg_decode_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : error = dwg_decode_VPORT_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VPORT_CONTROL ) { obj -> tio . object -> tio . VPORT_CONTROL -> objid = num ; dwg -> vport_control = * obj -> tio . object -> tio . VPORT_CONTROL ; } break ; case DWG_TYPE_VPORT : error = dwg_decode_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : error = dwg_decode_APPID_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . APPID_CONTROL ) { obj -> tio . object -> tio . APPID_CONTROL -> objid = num ; dwg -> appid_control = * obj -> tio . object -> tio . APPID_CONTROL ; } break ; case DWG_TYPE_APPID : error = dwg_decode_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : error = dwg_decode_DIMSTYLE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . DIMSTYLE_CONTROL ) { obj -> tio . object -> tio . DIMSTYLE_CONTROL -> objid = num ; dwg -> dimstyle_control = * obj -> tio . object -> tio . DIMSTYLE_CONTROL ; } break ; case DWG_TYPE_DIMSTYLE : error = dwg_decode_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : error = dwg_decode_VPORT_ENTITY_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VPORT_ENTITY_CONTROL ) { obj -> tio . object -> tio . VPORT_ENTITY_CONTROL -> objid = num ; dwg -> vport_entity_control = * obj -> tio . object -> tio . VPORT_ENTITY_CONTROL ; } break ; case DWG_TYPE_VPORT_ENTITY_HEADER : error = dwg_decode_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : error = dwg_decode_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : error = dwg_decode_MLINESTYLE ( dat , obj ) ; break ; case DWG_TYPE_OLE2FRAME : error = dwg_decode_OLE2FRAME ( dat , obj ) ; break ; case DWG_TYPE_DUMMY : error = dwg_decode_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : error = dwg_decode_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : error = dwg_decode_LWPOLYLINE ( dat , obj ) ; break ; case DWG_TYPE_HATCH : error = dwg_decode_HATCH ( dat , obj ) ; break ; case DWG_TYPE_XRECORD : error = dwg_decode_XRECORD ( dat , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : error = dwg_decode_PLACEHOLDER ( dat , obj ) ; break ; case DWG_TYPE_OLEFRAME : error = dwg_decode_OLEFRAME ( dat , obj ) ; break ; case DWG_TYPE_VBA_PROJECT : LOG_ERROR ( ""Unhandled<S2SV_blank>Object<S2SV_blank>VBA_PROJECT.<S2SV_blank>Has<S2SV_blank>its<S2SV_blank>own<S2SV_blank>section"" ) ; error = DWG_ERR_UNHANDLEDCLASS ; break ; case DWG_TYPE_LAYOUT : error = dwg_decode_LAYOUT ( dat , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : error = dwg_decode_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : error = dwg_decode_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == dwg -> layout_type ) error = dwg_decode_LAYOUT ( dat , obj ) ; else if ( ( error = dwg_decode_variable_type ( dwg , dat , hdl_dat , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { int is_entity = 0 ; int i = obj -> type - 500 ; Dwg_Class * klass = NULL ;  bit_set_position ( dat , restartpos ) ;  if ( i >= 0 && i < ( int ) dwg -> num_classes ) { klass = & dwg -> dwg_class [ i ] ; is_entity = dwg_class_is_entity ( klass ) ; } else { if ( i < 0 ) { LOG_ERROR ( ""Invalid<S2SV_blank>class<S2SV_blank>index<S2SV_blank>%d<S2SV_blank><0"" , i ) ; } else { LOG_ERROR ( ""Invalid<S2SV_blank>class<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>>%d"" , i , ( int ) dwg -> num_classes ) ; }  obj -> supertype = DWG_SUPERTYPE_UNKNOWN ;  obj -> type = 0 ; * dat = abs_dat ; return error | DWG_ERR_VALUEOUTOFBOUNDS ; }  if ( klass && ! is_entity )  { int err = dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; error |= err ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; if ( ! dat ) return error ;  if ( err >= DWG_ERR_CRITICAL )  * dat = abs_dat ;  }  else if ( klass ) { int err ; # if 0 && ! defined ( IS_RELEASE ) if ( strEQc ( klass -> dxfname , ""MULTILEADER"" ) ) { char * mleader = bit_read_TF ( dat , obj -> size ) ; LOG_INSANE_TF ( mleader , ( int ) obj -> size ) bit_set_position ( dat , restartpos ) ; free ( mleader ) ; } # endif err = dwg_decode_UNKNOWN_ENT ( dat , obj ) ; error |= err ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; if ( ! dat ) return error ; if ( err >= DWG_ERR_CRITICAL ) * dat = abs_dat ; } else { LOG_WARN ( ""Unknown<S2SV_blank>object,<S2SV_blank>skipping<S2SV_blank>eed/reactors/xdic"" ) ; SINCE ( R_2000 ) { obj -> bitsize = bit_read_RL ( dat ) ; LOG_TRACE ( ""bitsize:<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>[RL]<S2SV_blank>@%lu.%u\\n"" , obj -> bitsize , dat -> byte - 2 , dat -> bit ) ; if ( obj -> bitsize > obj -> size * 8 ) { LOG_ERROR ( ""Invalid<S2SV_blank>bitsize<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>=><S2SV_blank>"" FORMAT_RL , obj -> bitsize , obj -> size * 8 ) ; obj -> bitsize = obj -> size * 8 ; error |= DWG_ERR_VALUEOUTOFBOUNDS ; } } if ( ! bit_read_H ( dat , & obj -> handle ) ) { LOG_TRACE ( ""handle:<S2SV_blank>"" FORMAT_H ""<S2SV_blank>[H<S2SV_blank>5]\\n"" , ARGS_H ( obj -> handle ) ) ; } restartpos = dat -> byte ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; obj -> tio . unknown = bit_read_TF ( dat , obj -> size ) ; dat -> byte = restartpos ; } } } if ( obj -> handle . value ) { LOG_HANDLE ( ""<S2SV_blank>object_map{%lX}<S2SV_blank>=<S2SV_blank>%lu\\n"" , obj -> handle . value , ( unsigned long ) num ) ; hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; } if ( dat -> byte > 8 * dat -> size ) { LOG_ERROR ( ""Invalid<S2SV_blank>object<S2SV_blank>address<S2SV_blank>(overflow):<S2SV_blank>%lu<S2SV_blank>><S2SV_blank>%lu"" , dat -> byte , 8 * dat -> size ) ; * dat = abs_dat ; return error | DWG_ERR_INVALIDDWG ; } restartpos = bit_position ( dat ) ; * dat = abs_dat ; bit_set_position ( dat , objpos + restartpos ) ; if ( dat -> bit ) { unsigned char r = 8 - dat -> bit ; LOG_HANDLE ( ""<S2SV_blank>padding:<S2SV_blank>%X/%X<S2SV_blank>(%d<S2SV_blank>bits)\\n"" , dat -> chain [ dat -> byte ] , dat -> chain [ dat -> byte ] & ( ( 1 << r ) - 1 ) , r ) ; bit_advance_position ( dat , r ) ; } bit_set_position ( dat , ( obj -> address + obj -> size ) * 8 - 2 ) ; if ( ! bit_check_CRC ( dat , address , 0xC0C1 ) ) error |= DWG_ERR_WRONGCRC ; * dat = abs_dat ; return realloced ? - 1 : error ; }",if ( error >= DWG_ERR_CRITICAL ) * dat = abs_dat ;,2250
133,"buggy line: value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ;return ( ( unsigned short ) ( value & 0xffff ) ) ;}value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) |  ( ( unsigned char * ) buffer ) [ 1 ] ) ;return ( ( unsigned short ) ( value & 0xffff ) ) ;}cwe id:CWE-125context: static inline unsigned short ReadPropertyUnsignedShort ( const EndianType endian , const unsigned char * buffer ) { unsigned short value ; if ( endian == LSBEndian ) {  value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ;   return ( ( unsigned short ) ( value & 0xffff ) ) ;  }  value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) |  ( ( unsigned char * ) buffer ) [ 1 ] ) ;  return ( ( unsigned short ) ( value & 0xffff ) ) ;  }",value = ( unsigned short ) buffer [ 1 ] << 8 ) | buffer [ 0 ] ;return ( ( unsigned short ) ( value & 0xffff ) ) ;}value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | ( ( unsigned char * ) buffer ) [ 1 ] ) ;return ( value & 0xffff ) ;},2251
134,"buggy line: libettercap_init ( ) ;ef_globals_alloc ( ) ;cwe id:CWE-125context: int main ( int argc , char * argv [ ] ) {  libettercap_init ( ) ;  ef_globals_alloc ( ) ; select_text_interface ( ) ; libettercap_ui_init ( ) ; fprintf ( stdout , ""\\n"" EC_COLOR_BOLD ""%s<S2SV_blank>%s"" EC_COLOR_END ""<S2SV_blank>copyright<S2SV_blank>%s<S2SV_blank>%s\\n\\n"" , PROGRAM , EC_VERSION , EC_COPYRIGHT , EC_AUTHORS ) ; EF_GBL -> lineno = 1 ; parse_options ( argc , argv ) ; if ( EF_GBL_OPTIONS -> source_file ) { yyin = fopen ( EF_GBL_OPTIONS -> source_file , ""r"" ) ; if ( yyin == NULL ) FATAL_ERROR ( ""Input<S2SV_blank>file<S2SV_blank>not<S2SV_blank>found<S2SV_blank>!"" ) ; } else { FATAL_ERROR ( ""No<S2SV_blank>source<S2SV_blank>file."" ) ; } setbuf ( yyin , NULL ) ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; load_tables ( ) ; load_constants ( ) ; fprintf ( stdout , ""\\n<S2SV_blank>Parsing<S2SV_blank>source<S2SV_blank>file<S2SV_blank>\\\'%s\\\'<S2SV_blank>"" , EF_GBL_OPTIONS -> source_file ) ; fflush ( stdout ) ; ef_debug ( 1 , ""\\n"" ) ; if ( yyparse ( ) == 0 ) fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; else fprintf ( stdout , ""\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n"" ) ;  if ( write_output ( ) != E_SUCCESS )  FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ; ef_globals_free ( ) ; return 0 ; }",int ret_value = 0 ;libettercap_init ( ) ;ef_globals_alloc ( ) ;,2252
135,"buggy line: if ( write_output ( ) != E_SUCCESS )  FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ;cwe id:CWE-125context: int main ( int argc , char * argv [ ] ) {  libettercap_init ( ) ;  ef_globals_alloc ( ) ; select_text_interface ( ) ; libettercap_ui_init ( ) ; fprintf ( stdout , ""\\n"" EC_COLOR_BOLD ""%s<S2SV_blank>%s"" EC_COLOR_END ""<S2SV_blank>copyright<S2SV_blank>%s<S2SV_blank>%s\\n\\n"" , PROGRAM , EC_VERSION , EC_COPYRIGHT , EC_AUTHORS ) ; EF_GBL -> lineno = 1 ; parse_options ( argc , argv ) ; if ( EF_GBL_OPTIONS -> source_file ) { yyin = fopen ( EF_GBL_OPTIONS -> source_file , ""r"" ) ; if ( yyin == NULL ) FATAL_ERROR ( ""Input<S2SV_blank>file<S2SV_blank>not<S2SV_blank>found<S2SV_blank>!"" ) ; } else { FATAL_ERROR ( ""No<S2SV_blank>source<S2SV_blank>file."" ) ; } setbuf ( yyin , NULL ) ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; load_tables ( ) ; load_constants ( ) ; fprintf ( stdout , ""\\n<S2SV_blank>Parsing<S2SV_blank>source<S2SV_blank>file<S2SV_blank>\\\'%s\\\'<S2SV_blank>"" , EF_GBL_OPTIONS -> source_file ) ; fflush ( stdout ) ; ef_debug ( 1 , ""\\n"" ) ; if ( yyparse ( ) == 0 ) fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; else fprintf ( stdout , ""\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n"" ) ;  if ( write_output ( ) != E_SUCCESS )  FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ; ef_globals_free ( ) ; return 0 ; }","ret_value = write_output ( ) != E_SUCCESS ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ;",2252
136,"buggy line: down_write ( & mm -> mmap_sem ) ;mutex_lock ( & ufile -> umap_lock ) ;list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) {cwe id:CWE-667context: void uverbs_user_mmap_disassociate ( struct ib_uverbs_file * ufile ) { struct rdma_umap_priv * priv , * next_priv ; lockdep_assert_held ( & ufile -> hw_destroy_rwsem ) ; while ( 1 ) { struct mm_struct * mm = NULL ; mutex_lock ( & ufile -> umap_lock ) ; while ( ! list_empty ( & ufile -> umaps ) ) { int ret ; priv = list_first_entry ( & ufile -> umaps , struct rdma_umap_priv , list ) ; mm = priv -> vma -> vm_mm ; ret = mmget_not_zero ( mm ) ; if ( ! ret ) { list_del_init ( & priv -> list ) ; mm = NULL ; continue ; } break ; } mutex_unlock ( & ufile -> umap_lock ) ; if ( ! mm ) return ;  down_write ( & mm -> mmap_sem ) ;  mutex_lock ( & ufile -> umap_lock ) ; list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) { struct vm_area_struct * vma = priv -> vma ; if ( vma -> vm_mm != mm ) continue ; list_del_init ( & priv -> list ) ; zap_vma_ptes ( vma , vma -> vm_start , vma -> vm_end - vma -> vm_start ) ; vma -> vm_flags &= ~ ( VM_SHARED | VM_MAYSHARE ) ; } mutex_unlock ( & ufile -> umap_lock ) ;  up_write ( & mm -> mmap_sem ) ;  mmput ( mm ) ; } }","down_write ( & mm -> mmap_sem ) ;if ( ! mmget_still_valid ( mm ) ) goto skip_mm ;mutex_lock ( & ufile -> umap_lock ) ;skip_mm : list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) {",2253
137,"buggy line: up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;cwe id:CWE-667context: void uverbs_user_mmap_disassociate ( struct ib_uverbs_file * ufile ) { struct rdma_umap_priv * priv , * next_priv ; lockdep_assert_held ( & ufile -> hw_destroy_rwsem ) ; while ( 1 ) { struct mm_struct * mm = NULL ; mutex_lock ( & ufile -> umap_lock ) ; while ( ! list_empty ( & ufile -> umaps ) ) { int ret ; priv = list_first_entry ( & ufile -> umaps , struct rdma_umap_priv , list ) ; mm = priv -> vma -> vm_mm ; ret = mmget_not_zero ( mm ) ; if ( ! ret ) { list_del_init ( & priv -> list ) ; mm = NULL ; continue ; } break ; } mutex_unlock ( & ufile -> umap_lock ) ; if ( ! mm ) return ;  down_write ( & mm -> mmap_sem ) ;  mutex_lock ( & ufile -> umap_lock ) ; list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) { struct vm_area_struct * vma = priv -> vma ; if ( vma -> vm_mm != mm ) continue ; list_del_init ( & priv -> list ) ; zap_vma_ptes ( vma , vma -> vm_start , vma -> vm_end - vma -> vm_start ) ; vma -> vm_flags &= ~ ( VM_SHARED | VM_MAYSHARE ) ; } mutex_unlock ( & ufile -> umap_lock ) ;  up_write ( & mm -> mmap_sem ) ;  mmput ( mm ) ; } }",up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,2253
138,"buggy line: kref_put ( & reservations -> refs , resv_map_release ) ;if ( reserve ) {cwe id:CWE-399context: static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma ( vma ) ; unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ;  kref_put ( & reservations -> refs , resv_map_release ) ;  if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool , reserve ) ; } } }",resv_map_put ( vma ) ;if ( reserve ) {,2254
139,"buggy line: int err ;dp -> dccps_role = DCCP_ROLE_CLIENT ;if ( inet -> opt != NULL && inet -> opt -> srr ) {if ( daddr == 0 ) return - EINVAL ;nexthop = inet -> opt -> faddr ;}cwe id:CWE-362context: int dccp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { const struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ;  int err ;  dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) return - EAFNOSUPPORT ; nexthop = daddr = usin -> sin_addr . s_addr ;  if ( inet -> opt != NULL && inet -> opt -> srr ) {  if ( daddr == 0 ) return - EINVAL ;  nexthop = inet -> opt -> faddr ;  } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , IPPROTO_DCCP , orig_sport , orig_dport , sk , true ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { ip_rt_put ( rt ) ; return - ENETUNREACH ; }  if ( inet -> opt == NULL || ! inet -> opt -> srr )  daddr = rt -> rt_dst ; if ( inet -> inet_saddr == 0 ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;  if ( inet -> opt != NULL )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet_hash_connect ( & dccp_death_row , sk ) ; if ( err != 0 ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( IS_ERR ( rt ) ) { rt = NULL ; goto failure ; } sk_setup_caps ( sk , & rt -> dst ) ; dp -> dccps_iss = secure_dccp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , inet -> inet_dport ) ; inet -> inet_id = dp -> dccps_iss ^ jiffies ; err = dccp_connect ( sk ) ; rt = NULL ; if ( err != 0 ) goto failure ; out : return err ; failure : dccp_set_state ( sk , DCCP_CLOSED ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; goto out ; }","int err ;struct ip_options_rcu * inet_opt ;dp -> dccps_role = DCCP_ROLE_CLIENT ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt != NULL && inet_opt -> opt . srr ) {if ( daddr == 0 ) return - EINVAL ;nexthop = inet_opt -> opt . faddr ;}",2255
140,"buggy line: if ( inet -> opt == NULL || ! inet -> opt -> srr )  daddr = rt -> rt_dst ;if ( inet -> inet_saddr == 0 ) inet -> inet_saddr = rt -> rt_src ;inet -> inet_rcv_saddr = inet -> inet_saddr ;inet -> inet_dport = usin -> sin_port ;inet -> inet_daddr = daddr ;inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;if ( inet -> opt != NULL )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ;cwe id:CWE-362context: int dccp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { const struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ;  int err ;  dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) return - EAFNOSUPPORT ; nexthop = daddr = usin -> sin_addr . s_addr ;  if ( inet -> opt != NULL && inet -> opt -> srr ) {  if ( daddr == 0 ) return - EINVAL ;  nexthop = inet -> opt -> faddr ;  } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , IPPROTO_DCCP , orig_sport , orig_dport , sk , true ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { ip_rt_put ( rt ) ; return - ENETUNREACH ; }  if ( inet -> opt == NULL || ! inet -> opt -> srr )  daddr = rt -> rt_dst ; if ( inet -> inet_saddr == 0 ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;  if ( inet -> opt != NULL )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet_hash_connect ( & dccp_death_row , sk ) ; if ( err != 0 ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( IS_ERR ( rt ) ) { rt = NULL ; goto failure ; } sk_setup_caps ( sk , & rt -> dst ) ; dp -> dccps_iss = secure_dccp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , inet -> inet_dport ) ; inet -> inet_id = dp -> dccps_iss ^ jiffies ; err = dccp_connect ( sk ) ; rt = NULL ; if ( err != 0 ) goto failure ; out : return err ; failure : dccp_set_state ( sk , DCCP_CLOSED ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; goto out ; }",if ( inet_opt == NULL || ! inet -> opt -> srr ) daddr = rt -> rt_dst ;if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . optlen ;,2255
141,"buggy line: ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ;ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ;cwe id:CWE-200context: IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) {  ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ;  ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; } while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }",if ( ps_dec -> u2_forw_f_code < 1 || ps_dec -> u2_forw_f_code > 7 || ps_dec -> u2_back_f_code < 1 || ps_dec -> u2_back_f_code > 7 ) {return IMPEG2D_UNKNOWN_ERROR ;}ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ;ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ;,2256
142,"buggy line: sas_discover_event ( dev -> port , DISCE_PROBE ) ;return 0 ;cwe id:CWE-000context: int sas_discover_sata ( struct domain_device * dev ) { int res ; if ( dev -> dev_type == SAS_SATA_PM ) return - ENODEV ; dev -> sata_dev . class = sas_get_ata_command_set ( dev ) ; sas_fill_in_rphy ( dev , dev -> rphy ) ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ;  sas_discover_event ( dev -> port , DISCE_PROBE ) ;  return 0 ; }",return 0 ;,2257
143,"buggy line: if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) {ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ;cwe id:CWE-20context: static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; }  if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) {  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  }  if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ;  for ( n = 0 ; n < num_images ; n ++ )  { if ( n != 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ;",2258
144,"buggy line: for ( n = 0 ;n ++ )  {cwe id:CWE-20context: static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; }  if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) {  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  }  if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ;  for ( n = 0 ; n < num_images ; n ++ )  { if ( n != 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;for ( n = 0 ;n ++ ) {",2258
145,"buggy line: sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ;sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_port = 0 ;* addr_len = sizeof ( * sin6 ) ;if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;cwe id:CWE-000context: int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ; int family = sk -> sk_family ; struct sk_buff * skb ; int copied , err ; pr_debug ( ""ping_recvmsg(sk=%p,sk->num=%u)\\n"" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) { struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ;  sin -> sin_family = AF_INET ;  sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ;  if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;  sin6 -> sin6_family = AF_INET6 ;  sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ;  * addr_len = sizeof ( * sin6 ) ;  if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ; # endif } else { BUG ( ) ; } err = copied ; done : skb_free_datagram ( sk , skb ) ; out : pr_debug ( ""ping_recvmsg<S2SV_blank>-><S2SV_blank>%d\\n"" , err ) ; return err ; }","if ( sin ) {sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;}if ( isk -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;if ( sin6 ) {sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_port = 0 ;* addr_len = sizeof ( * sin6 ) ;}if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;",2259
146,"buggy line: pvc . sap_family = AF_ATMPVC ;pvc . sap_addr . itf = vcc -> dev -> number ;cwe id:CWE-200context: int vcc_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct atm_vcc * vcc ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( __SO_LEVEL_MATCH ( optname , level ) && len != __SO_SIZE ( optname ) ) return - EINVAL ; vcc = ATM_SD ( sock ) ; switch ( optname ) { case SO_ATMQOS : if ( ! test_bit ( ATM_VF_HASQOS , & vcc -> flags ) ) return - EINVAL ; return copy_to_user ( optval , & vcc -> qos , sizeof ( vcc -> qos ) ) ? - EFAULT : 0 ; case SO_SETCLP : return put_user ( vcc -> atm_options & ATM_ATMOPT_CLP ? 1 : 0 , ( unsigned long __user * ) optval ) ? - EFAULT : 0 ; case SO_ATMPVC : { struct sockaddr_atmpvc pvc ; if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) return - ENOTCONN ;  pvc . sap_family = AF_ATMPVC ;  pvc . sap_addr . itf = vcc -> dev -> number ; pvc . sap_addr . vpi = vcc -> vpi ; pvc . sap_addr . vci = vcc -> vci ; return copy_to_user ( optval , & pvc , sizeof ( pvc ) ) ? - EFAULT : 0 ; } default : if ( level == SOL_SOCKET ) return - EINVAL ; break ; } if ( ! vcc -> dev || ! vcc -> dev -> ops -> getsockopt ) return - EINVAL ; return vcc -> dev -> ops -> getsockopt ( vcc , level , optname , optval , len ) ; }","memset ( & pvc , 0 , sizeof ( pvc ) ) ;pvc . sap_family = AF_ATMPVC ;pvc . sap_addr . itf = vcc -> dev -> number ;",2260
147,"buggy line: char * bufptr ;bufptr = buf ;cwe id:CWE-190context: int jas_stream_read ( jas_stream_t * stream , void * buf , int cnt ) { int n ; int c ;  char * bufptr ;  bufptr = buf ; n = 0 ; while ( n < cnt ) { if ( ( c = jas_stream_getc ( stream ) ) == EOF ) { return n ; } * bufptr ++ = c ; ++ n ; } return n ; }","char * bufptr ;if ( cnt < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ;}bufptr = buf ;",2261
148,"buggy line: if ( ! retval ) {r = strdup ( realm ) ;if ( ! r ) {retval = ENOMEM ;}}cwe id:CWE-119context: static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) { krb5_error_code retval = 0 ; char * r = NULL ; krb5_data * data = NULL ; krb5_int32 count = 0 ; krb5_int32 size = 2 ; char * component = NULL ; data = malloc ( size * sizeof ( krb5_data ) ) ; if ( ! data ) { retval = ENOMEM ; }  if ( ! retval ) {  r = strdup ( realm ) ; if ( ! r ) { retval = ENOMEM ; } } while ( ! retval && ( component = va_arg ( ap , char * ) ) ) { if ( count == size ) { krb5_data * new_data = NULL ; size *= 2 ; new_data = realloc ( data , size * sizeof ( krb5_data ) ) ; if ( new_data ) { data = new_data ; } else { retval = ENOMEM ; } } if ( ! retval ) { data [ count ] . length = strlen ( component ) ; data [ count ] . data = strdup ( component ) ; if ( ! data [ count ] . data ) { retval = ENOMEM ; } count ++ ; } } if ( ! retval ) { princ -> type = KRB5_NT_UNKNOWN ; princ -> magic = KV5M_PRINCIPAL ; princ -> realm = make_data ( r , rlen ) ; princ -> data = data ; princ -> length = count ; r = NULL ; data = NULL ; } if ( data ) { while ( -- count >= 0 ) { free ( data [ count ] . data ) ; } free ( data ) ; } free ( r ) ; return retval ; }","if ( ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ;",2262
149,"buggy line: if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) )   task -> task_state_flags |= SAS_TASK_STATE_ABORTED ;spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ;}cwe id:CWE-416context: static void smp_task_timedout ( struct timer_list * t ) { struct sas_task_slow * slow = from_timer ( slow , t , timer ) ; struct sas_task * task = slow -> task ; unsigned long flags ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ;  if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) )   task -> task_state_flags |= SAS_TASK_STATE_ABORTED ;  spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; complete ( & task -> slow_task -> completion ) ;  } ","if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) {task -> task_state_flags |= SAS_TASK_STATE_ABORTED ;}spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ;}",2263
150,"buggy line: assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ;( void ) memcpy ( ( ( char * ) buf ) + offs ,  ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ;return len ;cwe id:CWE-119context: ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) {  assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ;  ( void ) memcpy ( ( ( char * ) buf ) + offs ,  ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ;  return len ; }","size_t ss = CDF_SHORT_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;assert ( ss == len ) ;if ( sst -> sst_len < ( size_t ) id ) {DPRINTF ( ( ""bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\\return - 1 ;}( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ;return len ;",2264
151,"buggy line: static void  l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat )  {const uint16_t * ptr = ( const uint16_t * ) dat ;ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_authentype2str , ""AuthType-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ;cwe id:CWE-125context: static void  l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat )  {  const uint16_t * ptr = ( const uint16_t * ) dat ;  ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_authentype2str , ""AuthType-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ; }","static void l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint16_t * ptr = ( const uint16_t * ) dat ;if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_authentype2str , ""AuthType-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ;",2265
152,"buggy line: oe_errno = 0 ;if ( ! sock )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( optlen )  optlen_in = * optlen ;if ( oe_syscall_getsockopt_ocall (  & ret , sock -> host_fd , level , optname , optval , optlen_in , optlen ) !=  OE_OK ) {done :  return ret ;cwe id:CWE-552context: static int _hostsock_getsockopt ( oe_fd_t * sock_ , int level , int optname , void * optval , oe_socklen_t * optlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t optlen_in = 0 ;  oe_errno = 0 ;   if ( ! sock )  OE_RAISE_ERRNO ( OE_EINVAL ) ;  if ( optlen )  optlen_in = * optlen ; if ( oe_syscall_getsockopt_ocall (  & ret , sock -> host_fd , level , optname , optval , optlen_in , optlen ) !=  OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; }  done :  return ret ; }","oe_socklen_t optlen_out = 0 ;oe_errno = 0 ;if ( ! sock || ! optval || ! optlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ;optlen_in = * optlen ;if ( oe_syscall_getsockopt_ocall ( & ret , sock -> host_fd , level , optname , optval , optlen_in , & optlen_out ) != OE_OK ) {if ( optlen_out > optlen_in ) optlen_out = optlen_in ;* optlen = optlen_out ;done : return ret ;",2266
153,"buggy line: return crypto_skcipher_setkey ( private , key , keylen ) ;}cwe id:CWE-476context: static int skcipher_setkey ( void * private , const u8 * key , unsigned int keylen ) {  return crypto_skcipher_setkey ( private , key , keylen ) ;   } ","struct skcipher_tfm * tfm = private ;int err ;err = crypto_skcipher_setkey ( tfm -> skcipher , key , keylen ) ;tfm -> has_key = ! err ;return err ;}",2267
154,"buggy line: if ( l_strnstart ( ""MSG"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>MSG"" ) ) ;else if ( l_strnstart ( ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>RPY"" ) ) ;else if ( l_strnstart ( ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ERR"" ) ) ;else if ( l_strnstart ( ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ANS"" ) ) ;else if ( l_strnstart ( ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>NUL"" ) ) ;else if ( l_strnstart ( ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>SEQ"" ) ) ;else if ( l_strnstart ( ""END"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>END"" ) ) ;cwe id:CWE-125context: void beep_print ( netdissect_options * ndo , const u_char * bp , u_int length ) {  if ( l_strnstart ( ""MSG"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>MSG"" ) ) ;  else if ( l_strnstart ( ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>RPY"" ) ) ;  else if ( l_strnstart ( ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ERR"" ) ) ;  else if ( l_strnstart ( ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ANS"" ) ) ;  else if ( l_strnstart ( ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>NUL"" ) ) ;  else if ( l_strnstart ( ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>SEQ"" ) ) ;  else if ( l_strnstart ( ""END"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>END"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>(payload<S2SV_blank>or<S2SV_blank>undecoded)"" ) ) ; }","if ( l_strnstart ( ndo , ""MSG"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>MSG"" ) ) ;else if ( l_strnstart ( ndo , ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>RPY"" ) ) ;else if ( l_strnstart ( ndo , ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ERR"" ) ) ;else if ( l_strnstart ( ndo , ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ANS"" ) ) ;else if ( l_strnstart ( ndo , ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>NUL"" ) ) ;else if ( l_strnstart ( ndo , ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>SEQ"" ) ) ;else if ( l_strnstart ( ndo , ""END"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>END"" ) ) ;",2268
155,"buggy line: case BPLIST_DATA :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_STRING :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_UNICODE : if ( size * 2 < size ) {if ( * object + size * 2 > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_SET : case BPLIST_ARRAY :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\cwe id:CWE-787context: static plist_t parse_bin_node ( struct bplist_data * bplist , const char * * object ) { uint16_t type = 0 ; uint64_t size = 0 ; if ( ! object ) return NULL ; type = ( * * object ) & BPLIST_MASK ; size = ( * * object ) & BPLIST_FILL ; ( * object ) ++ ; if ( size == BPLIST_FILL ) { switch ( type ) { case BPLIST_DATA : case BPLIST_STRING : case BPLIST_UNICODE : case BPLIST_ARRAY : case BPLIST_SET : case BPLIST_DICT : { uint16_t next_size = * * object & BPLIST_FILL ; if ( ( * * object & BPLIST_MASK ) != BPLIST_UINT ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>node<S2SV_blank>type<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x:<S2SV_blank>found<S2SV_blank>0x%02x,<S2SV_blank>expected<S2SV_blank>0x%02x\\n"" , __func__ , type , * * object & BPLIST_MASK , BPLIST_UINT ) ; return NULL ; } ( * object ) ++ ; next_size = 1 << next_size ; if ( * object + next_size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>size<S2SV_blank>node<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ , type ) ; return NULL ; } size = UINT_TO_HOST ( * object , next_size ) ; ( * object ) += next_size ; break ; } default : break ; } } switch ( type ) { case BPLIST_NULL : switch ( size ) { case BPLIST_TRUE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = TRUE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_FALSE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = FALSE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_NULL : default : return NULL ; } case BPLIST_UINT : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UINT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uint_node ( object , size ) ; case BPLIST_REAL : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_real_node ( object , size ) ; case BPLIST_DATE : if ( 3 != size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>size<S2SV_blank>for<S2SV_blank>BPLIST_DATE<S2SV_blank>node\\n"" , __func__ ) ; return NULL ; } if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_date_node ( object , size ) ; case BPLIST_DATA :  if ( * object + size > bplist -> offset_table ) {  PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_data_node ( object , size ) ; case BPLIST_STRING :  if ( * object + size > bplist -> offset_table ) {  PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_string_node ( object , size ) ; case BPLIST_UNICODE : if ( size * 2 < size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>size.\\n"" , __func__ ) ; return NULL ; }  if ( * object + size * 2 > bplist -> offset_table ) {  PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_unicode_node ( object , size ) ; case BPLIST_SET : case BPLIST_ARRAY :  if ( * object + size > bplist -> offset_table ) {  PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_array_node ( bplist , object , size ) ; case BPLIST_UID : if ( * object + size + 1 > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UID<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uid_node ( object , size ) ; case BPLIST_DICT :  if ( * object + size > bplist -> offset_table ) {  PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_dict_node ( bplist , object , size ) ; default : PLIST_BIN_ERR ( ""%s:<S2SV_blank>unexpected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x\\n"" , __func__ , type ) ; return NULL ; } return NULL ; }","case BPLIST_DATA : if ( * object + size < * object || * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_STRING : if ( * object + size < * object || * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_UNICODE : if ( size * 2 < * object || * object + size < * object || * object + size * 2 < size ) {if ( * object + size * 2 > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_SET : case BPLIST_ARRAY : if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\",2269
156,"buggy line: case BPLIST_DICT :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\cwe id:CWE-787context: static plist_t parse_bin_node ( struct bplist_data * bplist , const char * * object ) { uint16_t type = 0 ; uint64_t size = 0 ; if ( ! object ) return NULL ; type = ( * * object ) & BPLIST_MASK ; size = ( * * object ) & BPLIST_FILL ; ( * object ) ++ ; if ( size == BPLIST_FILL ) { switch ( type ) { case BPLIST_DATA : case BPLIST_STRING : case BPLIST_UNICODE : case BPLIST_ARRAY : case BPLIST_SET : case BPLIST_DICT : { uint16_t next_size = * * object & BPLIST_FILL ; if ( ( * * object & BPLIST_MASK ) != BPLIST_UINT ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>node<S2SV_blank>type<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x:<S2SV_blank>found<S2SV_blank>0x%02x,<S2SV_blank>expected<S2SV_blank>0x%02x\\n"" , __func__ , type , * * object & BPLIST_MASK , BPLIST_UINT ) ; return NULL ; } ( * object ) ++ ; next_size = 1 << next_size ; if ( * object + next_size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>size<S2SV_blank>node<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ , type ) ; return NULL ; } size = UINT_TO_HOST ( * object , next_size ) ; ( * object ) += next_size ; break ; } default : break ; } } switch ( type ) { case BPLIST_NULL : switch ( size ) { case BPLIST_TRUE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = TRUE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_FALSE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = FALSE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_NULL : default : return NULL ; } case BPLIST_UINT : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UINT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uint_node ( object , size ) ; case BPLIST_REAL : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_real_node ( object , size ) ; case BPLIST_DATE : if ( 3 != size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>size<S2SV_blank>for<S2SV_blank>BPLIST_DATE<S2SV_blank>node\\n"" , __func__ ) ; return NULL ; } if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_date_node ( object , size ) ; case BPLIST_DATA :  if ( * object + size > bplist -> offset_table ) {  PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_data_node ( object , size ) ; case BPLIST_STRING :  if ( * object + size > bplist -> offset_table ) {  PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_string_node ( object , size ) ; case BPLIST_UNICODE : if ( size * 2 < size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>size.\\n"" , __func__ ) ; return NULL ; }  if ( * object + size * 2 > bplist -> offset_table ) {  PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_unicode_node ( object , size ) ; case BPLIST_SET : case BPLIST_ARRAY :  if ( * object + size > bplist -> offset_table ) {  PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_array_node ( bplist , object , size ) ; case BPLIST_UID : if ( * object + size + 1 > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UID<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uid_node ( object , size ) ; case BPLIST_DICT :  if ( * object + size > bplist -> offset_table ) {  PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_dict_node ( bplist , object , size ) ; default : PLIST_BIN_ERR ( ""%s:<S2SV_blank>unexpected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x\\n"" , __func__ , type ) ; return NULL ; } return NULL ; }","case BPLIST_DICT : if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\",2269
157,"buggy line: if ( error ) return error ;dentry = fhp -> fh_dentry ;inode = d_inode ( dentry ) ;if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) )  return nfserr_attrnotsupp ;host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ;if ( host_error < 0 )  goto out_release ;if ( S_ISDIR ( inode -> i_mode ) ) {host_error = inode -> i_op -> set_acl ( inode , dpacl ,  ACL_TYPE_DEFAULT ) ;out_release :  posix_acl_release ( pacl ) ;cwe id:CWE-284context: __be32 nfsd4_set_nfs4_acl ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct nfs4_acl * acl ) { __be32 error ; int host_error ; struct dentry * dentry ; struct inode * inode ; struct posix_acl * pacl = NULL , * dpacl = NULL ; unsigned int flags = 0 ; error = fh_verify ( rqstp , fhp , 0 , NFSD_MAY_SATTR ) ; if ( error ) return error ; dentry = fhp -> fh_dentry ; inode = d_inode ( dentry ) ;  if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) )  return nfserr_attrnotsupp ; if ( S_ISDIR ( inode -> i_mode ) ) flags = NFS4_ACL_DIR ; host_error = nfs4_acl_nfsv4_to_posix ( acl , & pacl , & dpacl , flags ) ; if ( host_error == - EINVAL ) return nfserr_attrnotsupp ; if ( host_error < 0 ) goto out_nfserr ;  host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ;  if ( host_error < 0 )  goto out_release ;  if ( S_ISDIR ( inode -> i_mode ) ) {  host_error = inode -> i_op -> set_acl ( inode , dpacl ,  ACL_TYPE_DEFAULT ) ; }  out_release :  posix_acl_release ( pacl ) ; posix_acl_release ( dpacl ) ; out_nfserr : if ( host_error == - EOPNOTSUPP ) return nfserr_attrnotsupp ; else return nfserrno ( host_error ) ; }","fh_lock ( fhp ) ;host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl ) ;if ( host_error < 0 ) goto out_drop_lock ;if ( S_ISDIR ( inode -> i_mode ) ) {host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl ) ;out_release : posix_acl_release ( pacl ) ;",2270
158,"buggy line: sprintf ( descriptor -> msg , ""\\\cwe id:CWE-119context: SQLRETURN SQLSetDescFieldW ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>SQL_INVALID_HANDLE"" ) ; # ifdef WITH_HANDLE_REDIRECT { DMHDESC parent_desc ; parent_desc = find_parent_handle ( descriptor , SQL_HANDLE_DESC ) ; if ( parent_desc ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Info:<S2SV_blank>found<S2SV_blank>parent<S2SV_blank>handle"" ) ; if ( CHECK_SQLSETDESCFIELDW ( parent_desc -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Info:<S2SV_blank>calling<S2SV_blank>redirected<S2SV_blank>driver<S2SV_blank>function"" ) ; return SQLSETDESCFIELDW ( parent_desc -> connection , descriptor , rec_number , field_identifier , value , buffer_length ) ; } } } # endif return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) {  sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" ,  descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; }  if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 )  { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; }  if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT   && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&   value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )  { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( descriptor -> connection -> unicode_driver || CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { if ( ! CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } } else { SQLCHAR * ascii_str = NULL ; if ( ! CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_NAME : ascii_str = ( SQLCHAR * ) unicode_to_ansi_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; value = ascii_str ; buffer_length = strlen ( ( char * ) ascii_str ) ; break ; default : break ; } ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } if ( ascii_str ) { free ( ascii_str ) ; } } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }","sprintf ( descriptor -> msg , ""\\\",2271
159,"buggy line: if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 )  {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT   && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&   value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )  {cwe id:CWE-119context: SQLRETURN SQLSetDescFieldW ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>SQL_INVALID_HANDLE"" ) ; # ifdef WITH_HANDLE_REDIRECT { DMHDESC parent_desc ; parent_desc = find_parent_handle ( descriptor , SQL_HANDLE_DESC ) ; if ( parent_desc ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Info:<S2SV_blank>found<S2SV_blank>parent<S2SV_blank>handle"" ) ; if ( CHECK_SQLSETDESCFIELDW ( parent_desc -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Info:<S2SV_blank>calling<S2SV_blank>redirected<S2SV_blank>driver<S2SV_blank>function"" ) ; return SQLSETDESCFIELDW ( parent_desc -> connection , descriptor , rec_number , field_identifier , value , buffer_length ) ; } } } # endif return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) {  sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" ,  descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; }  if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 )  { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; }  if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT   && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&   value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )  { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( descriptor -> connection -> unicode_driver || CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { if ( ! CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } } else { SQLCHAR * ascii_str = NULL ; if ( ! CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_NAME : ascii_str = ( SQLCHAR * ) unicode_to_ansi_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; value = ascii_str ; buffer_length = strlen ( ( char * ) ascii_str ) ; break ; default : break ; } ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } if ( ascii_str ) { free ( ascii_str ) ; } } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }",if ( field_identifier == SQL_DESC_COUNT && ( intptr_t ) value < 0 ) {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) value != SQL_PARAM_OUTPUT_STREAM ) {,2271
160,"buggy line: enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MIWR , data ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 )   {}cwe id:CWE-20context: void enc624j600WritePhyReg ( NetInterface * interface , uint8_t address , uint16_t data ) {  enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ;   enc624j600WriteReg ( interface , ENC624J600_REG_MIWR , data ) ;   while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 )   {  } }","uint16_t status ;enc624j600WriteReg ( interface , ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT | address ) ;enc624j600WriteReg ( interface , ENC624J600_MIWR , data ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_MISTAT ) ;}while ( ( status & ENC624J600_MISTAT_BUSY ) != 0 ) ;",2272
161,"buggy line: wStream * s ;size_t length ;UINT32 flags ;NTLM_AV_PAIR * AvFlags ;UINT32 PayloadBufferOffset ;flags = 0 ;AvFlags = NULL ;if ( ntlm_read_message_header ( s , ( NTLM_MESSAGE_HEADER * ) message ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( message -> MessageType != MESSAGE_TYPE_AUTHENTICATE )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> LmChallengeResponse ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> NtChallengeResponse ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> DomainName ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> UserName ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> Workstation ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 )  {Stream_Free ( s , FALSE ) ;if ( ( context -> NegotiateKeyExchange && ! message -> EncryptedRandomSessionKey . Len ) || ( ! context -> NegotiateKeyExchange && message -> EncryptedRandomSessionKey . Len ) )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ! snt )  {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) < 0 ) {Stream_Free ( snt , FALSE ) ;return SEC_E_INVALID_TOKEN ;Stream_Free ( snt , FALSE ) ;cwe id:CWE-125context: SECURITY_STATUS ntlm_read_AuthenticateMessage ( NTLM_CONTEXT * context , PSecBuffer buffer ) {  wStream * s ;  size_t length ;  UINT32 flags ;   NTLM_AV_PAIR * AvFlags ;  UINT32 PayloadBufferOffset ; NTLM_AUTHENTICATE_MESSAGE * message ; SSPI_CREDENTIALS * credentials = context -> credentials ;  flags = 0 ;  AvFlags = NULL ; message = & context -> AUTHENTICATE_MESSAGE ; ZeroMemory ( message , sizeof ( NTLM_AUTHENTICATE_MESSAGE ) ) ; s = Stream_New ( ( BYTE * ) buffer -> pvBuffer , buffer -> cbBuffer ) ; if ( ! s ) return SEC_E_INTERNAL_ERROR ; if ( ntlm_read_message_header ( s , ( NTLM_MESSAGE_HEADER * ) message ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> MessageType != MESSAGE_TYPE_AUTHENTICATE )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> LmChallengeResponse ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> NtChallengeResponse ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> DomainName ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> UserName ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> Workstation ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ; context -> NegotiateKeyExchange = ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH ) ? TRUE : FALSE ; if ( ( context -> NegotiateKeyExchange && ! message -> EncryptedRandomSessionKey . Len ) || ( ! context -> NegotiateKeyExchange && message -> EncryptedRandomSessionKey . Len ) )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) { if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } } PayloadBufferOffset = Stream_GetPosition ( s ) ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( message -> NtChallengeResponse . Len > 0 ) { size_t cbAvFlags ; wStream * snt = Stream_New ( message -> NtChallengeResponse . Buffer , message -> NtChallengeResponse . Len ) ; if ( ! snt )  {  Stream_Free ( s , FALSE ) ;  return SEC_E_INTERNAL_ERROR ;  } if ( ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) < 0 ) { Stream_Free ( s , FALSE ) ; Stream_Free ( snt , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Free ( snt , FALSE ) ; context -> NtChallengeResponse . pvBuffer = message -> NtChallengeResponse . Buffer ; context -> NtChallengeResponse . cbBuffer = message -> NtChallengeResponse . Len ; sspi_SecBufferFree ( & ( context -> ChallengeTargetInfo ) ) ; context -> ChallengeTargetInfo . pvBuffer = ( void * ) context -> NTLMv2Response . Challenge . AvPairs ; context -> ChallengeTargetInfo . cbBuffer = message -> NtChallengeResponse . Len - ( 28 + 16 ) ; CopyMemory ( context -> ClientChallenge , context -> NTLMv2Response . Challenge . ClientChallenge , 8 ) ; AvFlags = ntlm_av_pair_get ( context -> NTLMv2Response . Challenge . AvPairs , context -> NTLMv2Response . Challenge . cbAvPairs , MsvAvFlags , & cbAvFlags ) ; if ( AvFlags ) Data_Read_UINT32 ( ntlm_av_pair_get_value_pointer ( AvFlags ) , flags ) ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( message -> EncryptedRandomSessionKey . Len > 0 ) { if ( message -> EncryptedRandomSessionKey . Len != 16 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } CopyMemory ( context -> EncryptedRandomSessionKey , message -> EncryptedRandomSessionKey . Buffer , 16 ) ; } length = Stream_GetPosition ( s ) ; if ( ! sspi_SecBufferAlloc ( & context -> AuthenticateMessage , length ) )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( context -> AuthenticateMessage . pvBuffer , Stream_Buffer ( s ) , length ) ; buffer -> cbBuffer = length ; Stream_SetPosition ( s , PayloadBufferOffset ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { context -> MessageIntegrityCheckOffset = ( UINT32 ) Stream_GetPosition ( s ) ; if ( Stream_GetRemainingLength ( s ) < 16 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Read ( s , message -> MessageIntegrityCheck , 16 ) ; } # ifdef WITH_DEBUG_NTLM WLog_DBG ( TAG , ""AUTHENTICATE_MESSAGE<S2SV_blank>(length<S2SV_blank>=<S2SV_blank>%"" PRIu32 "")"" , context -> AuthenticateMessage . cbBuffer ) ; winpr_HexDump ( TAG , WLOG_DEBUG , context -> AuthenticateMessage . pvBuffer , context -> AuthenticateMessage . cbBuffer ) ; if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) ntlm_print_version_info ( & ( message -> Version ) ) ; ntlm_print_message_fields ( & ( message -> DomainName ) , ""DomainName"" ) ; ntlm_print_message_fields ( & ( message -> UserName ) , ""UserName"" ) ; ntlm_print_message_fields ( & ( message -> Workstation ) , ""Workstation"" ) ; ntlm_print_message_fields ( & ( message -> LmChallengeResponse ) , ""LmChallengeResponse"" ) ; ntlm_print_message_fields ( & ( message -> NtChallengeResponse ) , ""NtChallengeResponse"" ) ; ntlm_print_message_fields ( & ( message -> EncryptedRandomSessionKey ) , ""EncryptedRandomSessionKey"" ) ; ntlm_print_av_pair_list ( context -> NTLMv2Response . Challenge . AvPairs , context -> NTLMv2Response . Challenge . cbAvPairs ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { WLog_DBG ( TAG , ""MessageIntegrityCheck:"" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , message -> MessageIntegrityCheck , 16 ) ; } # endif if ( message -> UserName . Len > 0 ) { credentials -> identity . User = ( UINT16 * ) malloc ( message -> UserName . Len ) ; if ( ! credentials -> identity . User )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( credentials -> identity . User , message -> UserName . Buffer , message -> UserName . Len ) ; credentials -> identity . UserLength = message -> UserName . Len / 2 ; } if ( message -> DomainName . Len > 0 ) { credentials -> identity . Domain = ( UINT16 * ) malloc ( message -> DomainName . Len ) ; if ( ! credentials -> identity . Domain )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( credentials -> identity . Domain , message -> DomainName . Buffer , message -> DomainName . Len ) ; credentials -> identity . DomainLength = message -> DomainName . Len / 2 ; } Stream_Free ( s , FALSE ) ; context -> state = NTLM_STATE_COMPLETION ; return SEC_I_COMPLETE_NEEDED ;  } ","SECURITY_STATUS status = SEC_E_INVALID_TOKEN ;wStream * s ;size_t length ;UINT32 flags = 0 ;NTLM_AV_PAIR * AvFlags = NULL ;UINT32 PayloadBufferOffset ;if ( ntlm_read_message_header ( s , ( NTLM_MESSAGE_HEADER * ) message ) < 0 ) goto fail ;if ( message -> MessageType != MESSAGE_TYPE_AUTHENTICATE ) {Stream_Free ( s , FALSE ) ;if ( ntlm_read_message_fields ( s , & ( message -> LmChallengeResponse ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields ( s , & ( message -> NtChallengeResponse ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields ( s , & ( message -> DomainName ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields ( s , & ( message -> UserName ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields ( s , & ( message -> Workstation ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 ) goto fail ;if ( Stream_GetRemainingLength ( s ) < 4 ) goto fail ;if ( ( context -> NegotiateKeyExchange && ! message -> EncryptedRandomSessionKey . Len ) || ( ! context -> NegotiateKeyExchange && message -> EncryptedRandomSessionKey . Len ) ) goto fail ;if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) goto fail ;status = SEC_E_INTERNAL_ERROR ;if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) goto fail ;int rc ;if ( ! snt ) {return SEC_E_INTERNAL_ERROR ;if ( ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) < 0 ) {Stream_Free ( s , FALSE ) ;if ( rc < 0 ) goto fail ;status = SEC_E_INTERNAL_ERROR ;",2273
162,"buggy line: if ( ntlm_read_message_fields_buffer ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( message -> EncryptedRandomSessionKey . Len != 16 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ! sspi_SecBufferAlloc ( & context -> AuthenticateMessage , length ) )  {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( Stream_GetRemainingLength ( s ) < 16 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}cwe id:CWE-125context: SECURITY_STATUS ntlm_read_AuthenticateMessage ( NTLM_CONTEXT * context , PSecBuffer buffer ) {  wStream * s ;  size_t length ;  UINT32 flags ;   NTLM_AV_PAIR * AvFlags ;  UINT32 PayloadBufferOffset ; NTLM_AUTHENTICATE_MESSAGE * message ; SSPI_CREDENTIALS * credentials = context -> credentials ;  flags = 0 ;  AvFlags = NULL ; message = & context -> AUTHENTICATE_MESSAGE ; ZeroMemory ( message , sizeof ( NTLM_AUTHENTICATE_MESSAGE ) ) ; s = Stream_New ( ( BYTE * ) buffer -> pvBuffer , buffer -> cbBuffer ) ; if ( ! s ) return SEC_E_INTERNAL_ERROR ; if ( ntlm_read_message_header ( s , ( NTLM_MESSAGE_HEADER * ) message ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> MessageType != MESSAGE_TYPE_AUTHENTICATE )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> LmChallengeResponse ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> NtChallengeResponse ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> DomainName ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> UserName ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> Workstation ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ; context -> NegotiateKeyExchange = ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH ) ? TRUE : FALSE ; if ( ( context -> NegotiateKeyExchange && ! message -> EncryptedRandomSessionKey . Len ) || ( ! context -> NegotiateKeyExchange && message -> EncryptedRandomSessionKey . Len ) )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) { if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } } PayloadBufferOffset = Stream_GetPosition ( s ) ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( message -> NtChallengeResponse . Len > 0 ) { size_t cbAvFlags ; wStream * snt = Stream_New ( message -> NtChallengeResponse . Buffer , message -> NtChallengeResponse . Len ) ; if ( ! snt )  {  Stream_Free ( s , FALSE ) ;  return SEC_E_INTERNAL_ERROR ;  } if ( ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) < 0 ) { Stream_Free ( s , FALSE ) ; Stream_Free ( snt , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Free ( snt , FALSE ) ; context -> NtChallengeResponse . pvBuffer = message -> NtChallengeResponse . Buffer ; context -> NtChallengeResponse . cbBuffer = message -> NtChallengeResponse . Len ; sspi_SecBufferFree ( & ( context -> ChallengeTargetInfo ) ) ; context -> ChallengeTargetInfo . pvBuffer = ( void * ) context -> NTLMv2Response . Challenge . AvPairs ; context -> ChallengeTargetInfo . cbBuffer = message -> NtChallengeResponse . Len - ( 28 + 16 ) ; CopyMemory ( context -> ClientChallenge , context -> NTLMv2Response . Challenge . ClientChallenge , 8 ) ; AvFlags = ntlm_av_pair_get ( context -> NTLMv2Response . Challenge . AvPairs , context -> NTLMv2Response . Challenge . cbAvPairs , MsvAvFlags , & cbAvFlags ) ; if ( AvFlags ) Data_Read_UINT32 ( ntlm_av_pair_get_value_pointer ( AvFlags ) , flags ) ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( message -> EncryptedRandomSessionKey . Len > 0 ) { if ( message -> EncryptedRandomSessionKey . Len != 16 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } CopyMemory ( context -> EncryptedRandomSessionKey , message -> EncryptedRandomSessionKey . Buffer , 16 ) ; } length = Stream_GetPosition ( s ) ; if ( ! sspi_SecBufferAlloc ( & context -> AuthenticateMessage , length ) )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( context -> AuthenticateMessage . pvBuffer , Stream_Buffer ( s ) , length ) ; buffer -> cbBuffer = length ; Stream_SetPosition ( s , PayloadBufferOffset ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { context -> MessageIntegrityCheckOffset = ( UINT32 ) Stream_GetPosition ( s ) ; if ( Stream_GetRemainingLength ( s ) < 16 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Read ( s , message -> MessageIntegrityCheck , 16 ) ; } # ifdef WITH_DEBUG_NTLM WLog_DBG ( TAG , ""AUTHENTICATE_MESSAGE<S2SV_blank>(length<S2SV_blank>=<S2SV_blank>%"" PRIu32 "")"" , context -> AuthenticateMessage . cbBuffer ) ; winpr_HexDump ( TAG , WLOG_DEBUG , context -> AuthenticateMessage . pvBuffer , context -> AuthenticateMessage . cbBuffer ) ; if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) ntlm_print_version_info ( & ( message -> Version ) ) ; ntlm_print_message_fields ( & ( message -> DomainName ) , ""DomainName"" ) ; ntlm_print_message_fields ( & ( message -> UserName ) , ""UserName"" ) ; ntlm_print_message_fields ( & ( message -> Workstation ) , ""Workstation"" ) ; ntlm_print_message_fields ( & ( message -> LmChallengeResponse ) , ""LmChallengeResponse"" ) ; ntlm_print_message_fields ( & ( message -> NtChallengeResponse ) , ""NtChallengeResponse"" ) ; ntlm_print_message_fields ( & ( message -> EncryptedRandomSessionKey ) , ""EncryptedRandomSessionKey"" ) ; ntlm_print_av_pair_list ( context -> NTLMv2Response . Challenge . AvPairs , context -> NTLMv2Response . Challenge . cbAvPairs ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { WLog_DBG ( TAG , ""MessageIntegrityCheck:"" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , message -> MessageIntegrityCheck , 16 ) ; } # endif if ( message -> UserName . Len > 0 ) { credentials -> identity . User = ( UINT16 * ) malloc ( message -> UserName . Len ) ; if ( ! credentials -> identity . User )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( credentials -> identity . User , message -> UserName . Buffer , message -> UserName . Len ) ; credentials -> identity . UserLength = message -> UserName . Len / 2 ; } if ( message -> DomainName . Len > 0 ) { credentials -> identity . Domain = ( UINT16 * ) malloc ( message -> DomainName . Len ) ; if ( ! credentials -> identity . Domain )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( credentials -> identity . Domain , message -> DomainName . Buffer , message -> DomainName . Len ) ; credentials -> identity . DomainLength = message -> DomainName . Len / 2 ; } Stream_Free ( s , FALSE ) ; context -> state = NTLM_STATE_COMPLETION ; return SEC_I_COMPLETE_NEEDED ;  } ","if ( ntlm_read_message_fields_buffer ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 ) goto fail ;if ( message -> EncryptedRandomSessionKey . Len != 16 ) goto fail ;if ( ! sspi_SecBufferAlloc ( & context -> AuthenticateMessage , length ) ) goto fail ;status = SEC_E_INVALID_TOKEN ;if ( Stream_GetRemainingLength ( s ) < 16 ) goto fail ;status = SEC_E_INTERNAL_ERROR ;",2273
163,"buggy line: if ( ! credentials -> identity . User )  {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ! credentials -> identity . Domain )  {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}}cwe id:CWE-125context: SECURITY_STATUS ntlm_read_AuthenticateMessage ( NTLM_CONTEXT * context , PSecBuffer buffer ) {  wStream * s ;  size_t length ;  UINT32 flags ;   NTLM_AV_PAIR * AvFlags ;  UINT32 PayloadBufferOffset ; NTLM_AUTHENTICATE_MESSAGE * message ; SSPI_CREDENTIALS * credentials = context -> credentials ;  flags = 0 ;  AvFlags = NULL ; message = & context -> AUTHENTICATE_MESSAGE ; ZeroMemory ( message , sizeof ( NTLM_AUTHENTICATE_MESSAGE ) ) ; s = Stream_New ( ( BYTE * ) buffer -> pvBuffer , buffer -> cbBuffer ) ; if ( ! s ) return SEC_E_INTERNAL_ERROR ; if ( ntlm_read_message_header ( s , ( NTLM_MESSAGE_HEADER * ) message ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> MessageType != MESSAGE_TYPE_AUTHENTICATE )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> LmChallengeResponse ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> NtChallengeResponse ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> DomainName ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> UserName ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> Workstation ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ; context -> NegotiateKeyExchange = ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH ) ? TRUE : FALSE ; if ( ( context -> NegotiateKeyExchange && ! message -> EncryptedRandomSessionKey . Len ) || ( ! context -> NegotiateKeyExchange && message -> EncryptedRandomSessionKey . Len ) )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) { if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } } PayloadBufferOffset = Stream_GetPosition ( s ) ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( message -> NtChallengeResponse . Len > 0 ) { size_t cbAvFlags ; wStream * snt = Stream_New ( message -> NtChallengeResponse . Buffer , message -> NtChallengeResponse . Len ) ; if ( ! snt )  {  Stream_Free ( s , FALSE ) ;  return SEC_E_INTERNAL_ERROR ;  } if ( ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) < 0 ) { Stream_Free ( s , FALSE ) ; Stream_Free ( snt , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Free ( snt , FALSE ) ; context -> NtChallengeResponse . pvBuffer = message -> NtChallengeResponse . Buffer ; context -> NtChallengeResponse . cbBuffer = message -> NtChallengeResponse . Len ; sspi_SecBufferFree ( & ( context -> ChallengeTargetInfo ) ) ; context -> ChallengeTargetInfo . pvBuffer = ( void * ) context -> NTLMv2Response . Challenge . AvPairs ; context -> ChallengeTargetInfo . cbBuffer = message -> NtChallengeResponse . Len - ( 28 + 16 ) ; CopyMemory ( context -> ClientChallenge , context -> NTLMv2Response . Challenge . ClientChallenge , 8 ) ; AvFlags = ntlm_av_pair_get ( context -> NTLMv2Response . Challenge . AvPairs , context -> NTLMv2Response . Challenge . cbAvPairs , MsvAvFlags , & cbAvFlags ) ; if ( AvFlags ) Data_Read_UINT32 ( ntlm_av_pair_get_value_pointer ( AvFlags ) , flags ) ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( message -> EncryptedRandomSessionKey . Len > 0 ) { if ( message -> EncryptedRandomSessionKey . Len != 16 )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } CopyMemory ( context -> EncryptedRandomSessionKey , message -> EncryptedRandomSessionKey . Buffer , 16 ) ; } length = Stream_GetPosition ( s ) ; if ( ! sspi_SecBufferAlloc ( & context -> AuthenticateMessage , length ) )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( context -> AuthenticateMessage . pvBuffer , Stream_Buffer ( s ) , length ) ; buffer -> cbBuffer = length ; Stream_SetPosition ( s , PayloadBufferOffset ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { context -> MessageIntegrityCheckOffset = ( UINT32 ) Stream_GetPosition ( s ) ; if ( Stream_GetRemainingLength ( s ) < 16 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Read ( s , message -> MessageIntegrityCheck , 16 ) ; } # ifdef WITH_DEBUG_NTLM WLog_DBG ( TAG , ""AUTHENTICATE_MESSAGE<S2SV_blank>(length<S2SV_blank>=<S2SV_blank>%"" PRIu32 "")"" , context -> AuthenticateMessage . cbBuffer ) ; winpr_HexDump ( TAG , WLOG_DEBUG , context -> AuthenticateMessage . pvBuffer , context -> AuthenticateMessage . cbBuffer ) ; if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) ntlm_print_version_info ( & ( message -> Version ) ) ; ntlm_print_message_fields ( & ( message -> DomainName ) , ""DomainName"" ) ; ntlm_print_message_fields ( & ( message -> UserName ) , ""UserName"" ) ; ntlm_print_message_fields ( & ( message -> Workstation ) , ""Workstation"" ) ; ntlm_print_message_fields ( & ( message -> LmChallengeResponse ) , ""LmChallengeResponse"" ) ; ntlm_print_message_fields ( & ( message -> NtChallengeResponse ) , ""NtChallengeResponse"" ) ; ntlm_print_message_fields ( & ( message -> EncryptedRandomSessionKey ) , ""EncryptedRandomSessionKey"" ) ; ntlm_print_av_pair_list ( context -> NTLMv2Response . Challenge . AvPairs , context -> NTLMv2Response . Challenge . cbAvPairs ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { WLog_DBG ( TAG , ""MessageIntegrityCheck:"" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , message -> MessageIntegrityCheck , 16 ) ; } # endif if ( message -> UserName . Len > 0 ) { credentials -> identity . User = ( UINT16 * ) malloc ( message -> UserName . Len ) ; if ( ! credentials -> identity . User )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( credentials -> identity . User , message -> UserName . Buffer , message -> UserName . Len ) ; credentials -> identity . UserLength = message -> UserName . Len / 2 ; } if ( message -> DomainName . Len > 0 ) { credentials -> identity . Domain = ( UINT16 * ) malloc ( message -> DomainName . Len ) ; if ( ! credentials -> identity . Domain )  {  Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( credentials -> identity . Domain , message -> DomainName . Buffer , message -> DomainName . Len ) ; credentials -> identity . DomainLength = message -> DomainName . Len / 2 ; } Stream_Free ( s , FALSE ) ; context -> state = NTLM_STATE_COMPLETION ; return SEC_I_COMPLETE_NEEDED ;  } ","if ( ! credentials -> identity . User ) goto fail ;if ( ! credentials -> identity . Domain ) goto fail ;fail : Stream_Free ( s , FALSE ) ;return status ;}",2273
164,"buggy line: }else if ( caught_signal ) status = caught_signal + 128 ;if ( caught_signal )  {sleep ( 2 ) ;kill ( child , SIGKILL ) ;fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\\switch ( caught_signal ) {cwe id:CWE-362context: static void create_watching_parent ( void ) { pid_t child ; sigset_t ourset ; struct sigaction oldact [ 3 ] ; int status = 0 ; int retval ; retval = pam_open_session ( pamh , 0 ) ; if ( is_pam_failure ( retval ) ) { cleanup_pam ( retval ) ; errx ( EXIT_FAILURE , _ ( ""cannot<S2SV_blank>open<S2SV_blank>session:<S2SV_blank>%s"" ) , pam_strerror ( pamh , retval ) ) ; } else _pam_session_opened = 1 ; memset ( oldact , 0 , sizeof ( oldact ) ) ; child = fork ( ) ; if ( child == ( pid_t ) - 1 ) { cleanup_pam ( PAM_ABORT ) ; err ( EXIT_FAILURE , _ ( ""cannot<S2SV_blank>create<S2SV_blank>child<S2SV_blank>process"" ) ) ; } if ( child == 0 ) return ; if ( chdir ( ""/"" ) != 0 ) warn ( _ ( ""cannot<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>%s"" ) , ""/"" ) ; sigfillset ( & ourset ) ; if ( sigprocmask ( SIG_BLOCK , & ourset , NULL ) ) { warn ( _ ( ""cannot<S2SV_blank>block<S2SV_blank>signals"" ) ) ; caught_signal = true ; } if ( ! caught_signal ) { struct sigaction action ; action . sa_handler = su_catch_sig ; sigemptyset ( & action . sa_mask ) ; action . sa_flags = 0 ; sigemptyset ( & ourset ) ; if ( ! same_session ) { if ( sigaddset ( & ourset , SIGINT ) || sigaddset ( & ourset , SIGQUIT ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } } if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } } if ( ! caught_signal ) { pid_t pid ; for ( ; ; ) { pid = waitpid ( child , & status , WUNTRACED ) ; if ( pid != ( pid_t ) - 1 && WIFSTOPPED ( status ) ) { kill ( getpid ( ) , SIGSTOP ) ; kill ( pid , SIGCONT ) ; } else break ; } if ( pid != ( pid_t ) - 1 ) { if ( WIFSIGNALED ( status ) ) { fprintf ( stderr , ""%s%s\\n"" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( ""<S2SV_blank>(core<S2SV_blank>dumped)"" ) : """" ) ; status = WTERMSIG ( status ) + 128 ; } else status = WEXITSTATUS ( status ) ;  }  else if ( caught_signal ) status = caught_signal + 128 ; else status = 1 ; } else status = 1 ;  if ( caught_signal )  { fprintf ( stderr , _ ( ""\\nSession<S2SV_blank>terminated,<S2SV_blank>killing<S2SV_blank>shell..."" ) ) ; kill ( child , SIGTERM ) ; } cleanup_pam ( PAM_SUCCESS ) ; if ( caught_signal ) {  sleep ( 2 ) ;  kill ( child , SIGKILL ) ;  fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\n"" ) ) ;  switch ( caught_signal ) { case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ; break ; case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ; break ; case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ; break ; default : caught_signal = SIGKILL ; break ; } kill ( getpid ( ) , caught_signal ) ; } exit ( status ) ; }","child = ( pid_t ) - 1 ;}else if ( caught_signal && child != ( pid_t ) - 1 ) status = caught_signal + 128 ;if ( caught_signal ) {if ( child != ( pid_t ) - 1 ) {}sleep ( 2 ) ;kill ( child , SIGKILL ) ;fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\\switch ( caught_signal ) {",2274
165,"buggy line: saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;saddr . sin_port = htons ( port ) ;cwe id:CWE-284context: int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # ifdef SO_NOSIGPIPE if ( setsockopt ( sfd , SOL_SOCKET , SO_NOSIGPIPE , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # endif memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ;  saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;  saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }",saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;saddr . sin_port = htons ( port ) ;,2275
166,"buggy line: xfs_daddr_t blkno = map [ 0 ] . bm_bn ;int numblks = 0 ;pag = xfs_perag_get ( btp -> bt_mount ,  xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ;cwe id:CWE-20context: xfs_buf_t * _xfs_buf_find ( struct xfs_buftarg * btp , struct xfs_buf_map * map , int nmaps , xfs_buf_flags_t flags , xfs_buf_t * new_bp ) { size_t numbytes ; struct xfs_perag * pag ; struct rb_node * * rbp ; struct rb_node * parent ; xfs_buf_t * bp ;  xfs_daddr_t blkno = map [ 0 ] . bm_bn ;  int numblks = 0 ; int i ; for ( i = 0 ; i < nmaps ; i ++ ) numblks += map [ i ] . bm_len ; numbytes = BBTOB ( numblks ) ; ASSERT ( ! ( numbytes < ( 1 << btp -> bt_sshift ) ) ) ; ASSERT ( ! ( BBTOB ( blkno ) & ( xfs_off_t ) btp -> bt_smask ) ) ;  pag = xfs_perag_get ( btp -> bt_mount ,  xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ; spin_lock ( & pag -> pag_buf_lock ) ; rbp = & pag -> pag_buf_tree . rb_node ; parent = NULL ; bp = NULL ; while ( * rbp ) { parent = * rbp ; bp = rb_entry ( parent , struct xfs_buf , b_rbnode ) ; if ( blkno < bp -> b_bn ) rbp = & ( * rbp ) -> rb_left ; else if ( blkno > bp -> b_bn ) rbp = & ( * rbp ) -> rb_right ; else { if ( bp -> b_length != numblks ) { ASSERT ( bp -> b_flags & XBF_STALE ) ; rbp = & ( * rbp ) -> rb_right ; continue ; } atomic_inc ( & bp -> b_hold ) ; goto found ; } } if ( new_bp ) { rb_link_node ( & new_bp -> b_rbnode , parent , rbp ) ; rb_insert_color ( & new_bp -> b_rbnode , & pag -> pag_buf_tree ) ; new_bp -> b_pag = pag ; spin_unlock ( & pag -> pag_buf_lock ) ; } else { XFS_STATS_INC ( xb_miss_locked ) ; spin_unlock ( & pag -> pag_buf_lock ) ; xfs_perag_put ( pag ) ; } return new_bp ; found : spin_unlock ( & pag -> pag_buf_lock ) ; xfs_perag_put ( pag ) ; if ( ! xfs_buf_trylock ( bp ) ) { if ( flags & XBF_TRYLOCK ) { xfs_buf_rele ( bp ) ; XFS_STATS_INC ( xb_busy_locked ) ; return NULL ; } xfs_buf_lock ( bp ) ; XFS_STATS_INC ( xb_get_locked_waited ) ; } if ( bp -> b_flags & XBF_STALE ) { ASSERT ( ( bp -> b_flags & _XBF_DELWRI_Q ) == 0 ) ; ASSERT ( bp -> b_iodone == NULL ) ; bp -> b_flags &= _XBF_KMEM | _XBF_PAGES ; bp -> b_ops = NULL ; } trace_xfs_buf_find ( bp , flags , _RET_IP_ ) ; XFS_STATS_INC ( xb_get_locked ) ; return bp ; }","xfs_daddr_t blkno = map [ 0 ] . bm_bn ;xfs_daddr_t eofs ;int numblks = 0 ;eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ;if ( blkno >= eofs ) {xfs_alert ( btp -> bt_mount , ""%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>"" , __func__ , blkno , eofs ) ;return NULL ;}pag = xfs_perag_get ( btp -> bt_mount , xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ;",2276
167,"buggy line: int ret = - 1 ;s = DSA_SIG_new ( ) ;if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ;ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;err :  DSA_SIG_free ( s ) ;return ( ret ) ;cwe id:CWE-310context: int DSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int siglen , DSA * dsa ) { DSA_SIG * s ;  int ret = - 1 ;  s = DSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ;  if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ;  ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ; err :  DSA_SIG_free ( s ) ;  return ( ret ) ; }","const unsigned char * p = sigbuf ;unsigned char * der = NULL ;int derlen = - 1 ;int ret = - 1 ;s = DSA_SIG_new ( ) ;if ( d2i_DSA_SIG ( & s , & p , siglen ) == NULL ) goto err ;derlen = i2d_DSA_SIG ( s , & der ) ;if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) goto err ;ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;err : if ( derlen > 0 ) {OPENSSL_cleanse ( der , derlen ) ;OPENSSL_free ( der ) ;}DSA_SIG_free ( s ) ;return ( ret ) ;",2277
168,"buggy line: while ( res == 0 && dev ) {struct expander_device * ex = & dev -> ex_dev ;cwe id:CWE-000context: int sas_ex_revalidate_domain ( struct domain_device * port_dev ) { int res ; struct domain_device * dev = NULL ; res = sas_find_bcast_dev ( port_dev , & dev ) ;  while ( res == 0 && dev ) {  struct expander_device * ex = & dev -> ex_dev ; int i = 0 , phy_id ; do { phy_id = - 1 ; res = sas_find_bcast_phy ( dev , & phy_id , i , true ) ; if ( phy_id == - 1 ) break ; res = sas_rediscover ( dev , phy_id ) ; i = phy_id + 1 ; } while ( i < ex -> num_phys ) ;  dev = NULL ;  res = sas_find_bcast_dev ( port_dev , & dev ) ; } return res ; }",if ( res == 0 && dev ) {struct expander_device * ex = & dev -> ex_dev ;,2278
169,"buggy line: dev = NULL ;res = sas_find_bcast_dev ( port_dev , & dev ) ;cwe id:CWE-000context: int sas_ex_revalidate_domain ( struct domain_device * port_dev ) { int res ; struct domain_device * dev = NULL ; res = sas_find_bcast_dev ( port_dev , & dev ) ;  while ( res == 0 && dev ) {  struct expander_device * ex = & dev -> ex_dev ; int i = 0 , phy_id ; do { phy_id = - 1 ; res = sas_find_bcast_phy ( dev , & phy_id , i , true ) ; if ( phy_id == - 1 ) break ; res = sas_rediscover ( dev , phy_id ) ; i = phy_id + 1 ; } while ( i < ex -> num_phys ) ;  dev = NULL ;  res = sas_find_bcast_dev ( port_dev , & dev ) ; } return res ; }","
",2278
170,"buggy line: netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ;netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ;cwe id:CWE-200context: static int atl2_probe ( struct pci_dev * pdev , const struct pci_device_id * ent ) { struct net_device * netdev ; struct atl2_adapter * adapter ; static int cards_found ; unsigned long mmio_start ; int mmio_len ; int err ; cards_found = 0 ; err = pci_enable_device ( pdev ) ; if ( err ) return err ; if ( pci_set_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) && pci_set_consistent_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) ) { printk ( KERN_ERR ""atl2:<S2SV_blank>No<S2SV_blank>usable<S2SV_blank>DMA<S2SV_blank>configuration,<S2SV_blank>aborting\\n"" ) ; goto err_dma ; } err = pci_request_regions ( pdev , atl2_driver_name ) ; if ( err ) goto err_pci_reg ; pci_set_master ( pdev ) ; err = - ENOMEM ; netdev = alloc_etherdev ( sizeof ( struct atl2_adapter ) ) ; if ( ! netdev ) goto err_alloc_etherdev ; SET_NETDEV_DEV ( netdev , & pdev -> dev ) ; pci_set_drvdata ( pdev , netdev ) ; adapter = netdev_priv ( netdev ) ; adapter -> netdev = netdev ; adapter -> pdev = pdev ; adapter -> hw . back = adapter ; mmio_start = pci_resource_start ( pdev , 0x0 ) ; mmio_len = pci_resource_len ( pdev , 0x0 ) ; adapter -> hw . mem_rang = ( u32 ) mmio_len ; adapter -> hw . hw_addr = ioremap ( mmio_start , mmio_len ) ; if ( ! adapter -> hw . hw_addr ) { err = - EIO ; goto err_ioremap ; } atl2_setup_pcicmd ( pdev ) ; netdev -> netdev_ops = & atl2_netdev_ops ; netdev -> ethtool_ops = & atl2_ethtool_ops ; netdev -> watchdog_timeo = 5 * HZ ; strncpy ( netdev -> name , pci_name ( pdev ) , sizeof ( netdev -> name ) - 1 ) ; netdev -> mem_start = mmio_start ; netdev -> mem_end = mmio_start + mmio_len ; adapter -> bd_number = cards_found ; adapter -> pci_using_64 = false ; err = atl2_sw_init ( adapter ) ; if ( err ) goto err_sw_init ; err = - EIO ;  netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ;  netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ; atl2_phy_init ( & adapter -> hw ) ; if ( atl2_reset_hw ( & adapter -> hw ) ) { err = - EIO ; goto err_reset ; } atl2_read_mac_addr ( & adapter -> hw ) ; memcpy ( netdev -> dev_addr , adapter -> hw . mac_addr , netdev -> addr_len ) ; if ( ! is_valid_ether_addr ( netdev -> dev_addr ) ) { err = - EIO ; goto err_eeprom ; } atl2_check_options ( adapter ) ; setup_timer ( & adapter -> watchdog_timer , atl2_watchdog , ( unsigned long ) adapter ) ; setup_timer ( & adapter -> phy_config_timer , atl2_phy_config , ( unsigned long ) adapter ) ; INIT_WORK ( & adapter -> reset_task , atl2_reset_task ) ; INIT_WORK ( & adapter -> link_chg_task , atl2_link_chg_task ) ; strcpy ( netdev -> name , ""eth%d"" ) ; err = register_netdev ( netdev ) ; if ( err ) goto err_register ; netif_carrier_off ( netdev ) ; netif_stop_queue ( netdev ) ; cards_found ++ ; return 0 ; err_reset : err_register : err_sw_init : err_eeprom : iounmap ( adapter -> hw . hw_addr ) ; err_ioremap : free_netdev ( netdev ) ; err_alloc_etherdev : pci_release_regions ( pdev ) ; err_pci_reg : err_dma : pci_disable_device ( pdev ) ; return err ; }",netdev -> hw_features = NETIF_F_HW_VLAN_CTAG_RX ;netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ;,2279
171,"buggy line: goto next_desc ;}cwe id:CWE-119context: int cdc_parse_cdc_header ( struct usb_cdc_parsed_header * hdr , struct usb_interface * intf , u8 * buffer , int buflen ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_header_desc * header = NULL ; struct usb_cdc_ether_desc * ether = NULL ; struct usb_cdc_mdlm_detail_desc * detail = NULL ; struct usb_cdc_mdlm_desc * desc = NULL ; unsigned int elength ; int cnt = 0 ; memset ( hdr , 0x00 , sizeof ( struct usb_cdc_parsed_header ) ) ; hdr -> phonet_magic_present = false ; while ( buflen > 0 ) { elength = buffer [ 0 ] ; if ( ! elength ) { dev_err ( & intf -> dev , ""skipping<S2SV_blank>garbage<S2SV_blank>byte\\n"" ) ; elength = 1 ;  goto next_desc ;  } if ( buffer [ 1 ] != USB_DT_CS_INTERFACE ) { dev_err ( & intf -> dev , ""skipping<S2SV_blank>garbage\\n"" ) ; goto next_desc ; } switch ( buffer [ 2 ] ) { case USB_CDC_UNION_TYPE : if ( elength < sizeof ( struct usb_cdc_union_desc ) ) goto next_desc ; if ( union_header ) { dev_err ( & intf -> dev , ""More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\n"" ) ; goto next_desc ; } union_header = ( struct usb_cdc_union_desc * ) buffer ; break ; case USB_CDC_COUNTRY_TYPE : if ( elength < sizeof ( struct usb_cdc_country_functional_desc ) ) goto next_desc ; hdr -> usb_cdc_country_functional_desc = ( struct usb_cdc_country_functional_desc * ) buffer ; break ; case USB_CDC_HEADER_TYPE : if ( elength != sizeof ( struct usb_cdc_header_desc ) ) goto next_desc ; if ( header ) return - EINVAL ; header = ( struct usb_cdc_header_desc * ) buffer ; break ; case USB_CDC_ACM_TYPE : if ( elength < sizeof ( struct usb_cdc_acm_descriptor ) ) goto next_desc ; hdr -> usb_cdc_acm_descriptor = ( struct usb_cdc_acm_descriptor * ) buffer ; break ; case USB_CDC_ETHERNET_TYPE : if ( elength != sizeof ( struct usb_cdc_ether_desc ) ) goto next_desc ; if ( ether ) return - EINVAL ; ether = ( struct usb_cdc_ether_desc * ) buffer ; break ; case USB_CDC_CALL_MANAGEMENT_TYPE : if ( elength < sizeof ( struct usb_cdc_call_mgmt_descriptor ) ) goto next_desc ; hdr -> usb_cdc_call_mgmt_descriptor = ( struct usb_cdc_call_mgmt_descriptor * ) buffer ; break ; case USB_CDC_DMM_TYPE : if ( elength < sizeof ( struct usb_cdc_dmm_desc ) ) goto next_desc ; hdr -> usb_cdc_dmm_desc = ( struct usb_cdc_dmm_desc * ) buffer ; break ; case USB_CDC_MDLM_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_desc * ) ) goto next_desc ; if ( desc ) return - EINVAL ; desc = ( struct usb_cdc_mdlm_desc * ) buffer ; break ; case USB_CDC_MDLM_DETAIL_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_detail_desc * ) ) goto next_desc ; if ( detail ) return - EINVAL ; detail = ( struct usb_cdc_mdlm_detail_desc * ) buffer ; break ; case USB_CDC_NCM_TYPE : if ( elength < sizeof ( struct usb_cdc_ncm_desc ) ) goto next_desc ; hdr -> usb_cdc_ncm_desc = ( struct usb_cdc_ncm_desc * ) buffer ; break ; case USB_CDC_MBIM_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_desc ) ) goto next_desc ; hdr -> usb_cdc_mbim_desc = ( struct usb_cdc_mbim_desc * ) buffer ; break ; case USB_CDC_MBIM_EXTENDED_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_extended_desc ) ) break ; hdr -> usb_cdc_mbim_extended_desc = ( struct usb_cdc_mbim_extended_desc * ) buffer ; break ; case CDC_PHONET_MAGIC_NUMBER : hdr -> phonet_magic_present = true ; break ; default : dev_dbg ( & intf -> dev , ""Ignoring<S2SV_blank>descriptor:<S2SV_blank>type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\n"" , buffer [ 2 ] , elength ) ; goto next_desc ; } cnt ++ ; next_desc : buflen -= elength ; buffer += elength ; } hdr -> usb_cdc_union_desc = union_header ; hdr -> usb_cdc_header_desc = header ; hdr -> usb_cdc_mdlm_detail_desc = detail ; hdr -> usb_cdc_mdlm_desc = desc ; hdr -> usb_cdc_ether_desc = ether ; return cnt ; }","goto next_desc ;}if ( ( buflen < elength ) || ( elength < 3 ) ) {dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\\break ;}",2280
172,"buggy line: f = fopen ( filepath , ""rb"" ) ;if ( f ) {cwe id:CWE-59context: static gchar * read_file ( gchar * filepath ) { FILE * f ; size_t length ; gchar * ret = NULL ;  f = fopen ( filepath , ""rb"" ) ;  if ( f ) { fseek ( f , 0 , SEEK_END ) ; length = ( size_t ) ftell ( f ) ; fseek ( f , 0 , SEEK_SET ) ; ret = MALLOC ( length + 1 ) ; if ( ret ) { if ( fread ( ret , length , 1 , f ) != 1 ) { log_message ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>of<S2SV_blank>%s"" , filepath ) ; } ret [ length ] = '\\0' ; } else log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>Dbus<S2SV_blank>file<S2SV_blank>%s"" , filepath ) ; fclose ( f ) ; } return ret ; }","f = fopen ( filepath , ""r"" ) ;if ( f ) {",2281
173,"buggy line: if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO )  && ext4_can_extents_be_merged ( inode , ex , newext ) ) {cwe id:CWE-000context: int ext4_ext_insert_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_extent * newext , int flag ) { struct ext4_extent_header * eh ; struct ext4_extent * ex , * fex ; struct ext4_extent * nearex ; struct ext4_ext_path * npath = NULL ; int depth , len , err ; ext4_lblk_t next ; unsigned uninitialized = 0 ; BUG_ON ( ext4_ext_get_actual_len ( newext ) == 0 ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; BUG_ON ( path [ depth ] . p_hdr == NULL ) ;  if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO )  && ext4_can_extents_be_merged ( inode , ex , newext ) ) { ext_debug ( ""append<S2SV_blank>[%d]%d<S2SV_blank>block<S2SV_blank>to<S2SV_blank>%d:[%d]%d<S2SV_blank>(from<S2SV_blank>%llu)\\n"" , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , le32_to_cpu ( ex -> ee_block ) , ext4_ext_is_uninitialized ( ex ) , ext4_ext_get_actual_len ( ex ) , ext_pblock ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; if ( ext4_ext_is_uninitialized ( ex ) ) uninitialized = 1 ; ex -> ee_len = cpu_to_le16 ( ext4_ext_get_actual_len ( ex ) + ext4_ext_get_actual_len ( newext ) ) ; if ( uninitialized ) ext4_ext_mark_uninitialized ( ex ) ; eh = path [ depth ] . p_hdr ; nearex = ex ; goto merge ; } repeat : depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) goto has_space ; fex = EXT_LAST_EXTENT ( eh ) ; next = ext4_ext_next_leaf_block ( inode , path ) ; if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( fex -> ee_block ) && next != EXT_MAX_BLOCK ) { ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>block<S2SV_blank>-<S2SV_blank>%d\\n"" , next ) ; BUG_ON ( npath != NULL ) ; npath = ext4_ext_find_extent ( inode , next , NULL ) ; if ( IS_ERR ( npath ) ) return PTR_ERR ( npath ) ; BUG_ON ( npath -> p_depth != path -> p_depth ) ; eh = npath [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) { ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>isnt<S2SV_blank>full(%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) ) ; path = npath ; goto repeat ; } ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>has<S2SV_blank>no<S2SV_blank>free<S2SV_blank>space(%d,%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) , le16_to_cpu ( eh -> eh_max ) ) ; } err = ext4_ext_create_new_leaf ( handle , inode , path , newext ) ; if ( err ) goto cleanup ; depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; has_space : nearex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; if ( ! nearex ) { ext_debug ( ""first<S2SV_blank>extent<S2SV_blank>in<S2SV_blank>the<S2SV_blank>leaf:<S2SV_blank>%d:%llu:[%d]%d\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) ) ; path [ depth ] . p_ext = EXT_FIRST_EXTENT ( eh ) ; } else if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( nearex -> ee_block ) ) { if ( nearex != EXT_LAST_EXTENT ( eh ) ) { len = EXT_MAX_EXTENT ( eh ) - nearex ; len = ( len - 1 ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>after:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 2 , nearex + 1 , len ) ; } path [ depth ] . p_ext = nearex + 1 ; } else { BUG_ON ( newext -> ee_block == nearex -> ee_block ) ; len = ( EXT_MAX_EXTENT ( eh ) - nearex ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>before:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 1 , nearex , len ) ; path [ depth ] . p_ext = nearex ; } le16_add_cpu ( & eh -> eh_entries , 1 ) ; nearex = path [ depth ] . p_ext ; nearex -> ee_block = newext -> ee_block ; ext4_ext_store_pblock ( nearex , ext_pblock ( newext ) ) ; nearex -> ee_len = newext -> ee_len ; merge :  if ( flag != EXT4_GET_BLOCKS_PRE_IO )  ext4_ext_try_to_merge ( inode , path , nearex ) ; err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto cleanup ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; cleanup : if ( npath ) { ext4_ext_drop_refs ( npath ) ; kfree ( npath ) ; } ext4_ext_invalidate_cache ( inode ) ; return err ; }","if ( ex && ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) && ext4_can_extents_be_merged ( inode , ex , newext ) ) {",2282
174,"buggy line: merge :  if ( flag != EXT4_GET_BLOCKS_PRE_IO )  ext4_ext_try_to_merge ( inode , path , nearex ) ;cwe id:CWE-000context: int ext4_ext_insert_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_extent * newext , int flag ) { struct ext4_extent_header * eh ; struct ext4_extent * ex , * fex ; struct ext4_extent * nearex ; struct ext4_ext_path * npath = NULL ; int depth , len , err ; ext4_lblk_t next ; unsigned uninitialized = 0 ; BUG_ON ( ext4_ext_get_actual_len ( newext ) == 0 ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; BUG_ON ( path [ depth ] . p_hdr == NULL ) ;  if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO )  && ext4_can_extents_be_merged ( inode , ex , newext ) ) { ext_debug ( ""append<S2SV_blank>[%d]%d<S2SV_blank>block<S2SV_blank>to<S2SV_blank>%d:[%d]%d<S2SV_blank>(from<S2SV_blank>%llu)\\n"" , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , le32_to_cpu ( ex -> ee_block ) , ext4_ext_is_uninitialized ( ex ) , ext4_ext_get_actual_len ( ex ) , ext_pblock ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; if ( ext4_ext_is_uninitialized ( ex ) ) uninitialized = 1 ; ex -> ee_len = cpu_to_le16 ( ext4_ext_get_actual_len ( ex ) + ext4_ext_get_actual_len ( newext ) ) ; if ( uninitialized ) ext4_ext_mark_uninitialized ( ex ) ; eh = path [ depth ] . p_hdr ; nearex = ex ; goto merge ; } repeat : depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) goto has_space ; fex = EXT_LAST_EXTENT ( eh ) ; next = ext4_ext_next_leaf_block ( inode , path ) ; if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( fex -> ee_block ) && next != EXT_MAX_BLOCK ) { ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>block<S2SV_blank>-<S2SV_blank>%d\\n"" , next ) ; BUG_ON ( npath != NULL ) ; npath = ext4_ext_find_extent ( inode , next , NULL ) ; if ( IS_ERR ( npath ) ) return PTR_ERR ( npath ) ; BUG_ON ( npath -> p_depth != path -> p_depth ) ; eh = npath [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) { ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>isnt<S2SV_blank>full(%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) ) ; path = npath ; goto repeat ; } ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>has<S2SV_blank>no<S2SV_blank>free<S2SV_blank>space(%d,%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) , le16_to_cpu ( eh -> eh_max ) ) ; } err = ext4_ext_create_new_leaf ( handle , inode , path , newext ) ; if ( err ) goto cleanup ; depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; has_space : nearex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; if ( ! nearex ) { ext_debug ( ""first<S2SV_blank>extent<S2SV_blank>in<S2SV_blank>the<S2SV_blank>leaf:<S2SV_blank>%d:%llu:[%d]%d\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) ) ; path [ depth ] . p_ext = EXT_FIRST_EXTENT ( eh ) ; } else if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( nearex -> ee_block ) ) { if ( nearex != EXT_LAST_EXTENT ( eh ) ) { len = EXT_MAX_EXTENT ( eh ) - nearex ; len = ( len - 1 ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>after:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 2 , nearex + 1 , len ) ; } path [ depth ] . p_ext = nearex + 1 ; } else { BUG_ON ( newext -> ee_block == nearex -> ee_block ) ; len = ( EXT_MAX_EXTENT ( eh ) - nearex ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>before:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 1 , nearex , len ) ; path [ depth ] . p_ext = nearex ; } le16_add_cpu ( & eh -> eh_entries , 1 ) ; nearex = path [ depth ] . p_ext ; nearex -> ee_block = newext -> ee_block ; ext4_ext_store_pblock ( nearex , ext_pblock ( newext ) ) ; nearex -> ee_len = newext -> ee_len ; merge :  if ( flag != EXT4_GET_BLOCKS_PRE_IO )  ext4_ext_try_to_merge ( inode , path , nearex ) ; err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto cleanup ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; cleanup : if ( npath ) { ext4_ext_drop_refs ( npath ) ; kfree ( npath ) ; } ext4_ext_invalidate_cache ( inode ) ; return err ; }","merge : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) ) ext4_ext_try_to_merge ( inode , path , nearex ) ;",2282
175,"buggy line: evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ;if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ;cwe id:CWE-119context: static void vhost_scsi_send_evt ( struct vhost_scsi * vs , struct vhost_scsi_tpg * tpg , struct se_lun * lun , u32 event , u32 reason ) { struct vhost_scsi_evt * evt ; evt = vhost_scsi_allocate_evt ( vs , event , reason ) ; if ( ! evt ) return ; if ( tpg && lun ) { evt -> event . lun [ 0 ] = 0x01 ;  evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ;  if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ; evt -> event . lun [ 3 ] = lun -> unpacked_lun & 0xFF ; } llist_add ( & evt -> list , & vs -> vs_event_list ) ; vhost_work_queue ( & vs -> dev , & vs -> vs_event_work ) ; }",evt -> event . lun [ 1 ] = tpg -> tport_tpgt ;if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ;,2283
176,"buggy line: struct btrfs_dir_item * di ;struct btrfs_root * root = BTRFS_I ( inode ) -> root ;if ( flags & XATTR_REPLACE ) {di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name ,  name_len , - 1 ) ;if ( IS_ERR ( di ) ) {ret = PTR_ERR ( di ) ;}ret = - ENODATA ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( ret ) goto out ;btrfs_release_path ( path ) ;if ( ! value ) goto out ;}else {di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ;if ( IS_ERR ( di ) ) {ret = PTR_ERR ( di ) ;goto out ;if ( flags & XATTR_CREATE )  goto out ;btrfs_release_path ( path ) ;di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;}else if ( ! di ) {btrfs_release_path ( path ) ;goto again ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( value ) {btrfs_release_path ( path ) ;goto again ;cwe id:CWE-362context: static int do_setxattr ( struct btrfs_trans_handle * trans , struct inode * inode , const char * name , const void * value , size_t size , int flags ) {  struct btrfs_dir_item * di ;  struct btrfs_root * root = BTRFS_I ( inode ) -> root ; struct btrfs_path * path ; size_t name_len = strlen ( name ) ; int ret = 0 ; if ( name_len + size > BTRFS_MAX_XATTR_SIZE ( root ) ) return - ENOSPC ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - ENOMEM ;  if ( flags & XATTR_REPLACE ) {   di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name ,  name_len , - 1 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ;  } else if ( ! di ) {  ret = - ENODATA ; goto out ; }  ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;  if ( ret ) goto out ;  btrfs_release_path ( path ) ;  if ( ! value ) goto out ;  } else {  di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; } if ( ! di && ! value ) goto out ; btrfs_release_path ( path ) ; } again : ret = btrfs_insert_xattr_item ( trans , root , path , btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) ret = - EEXIST ; if ( ret == - EEXIST ) {  if ( flags & XATTR_CREATE )  goto out ;  btrfs_release_path ( path ) ;  di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ;  } else if ( ! di ) {  btrfs_release_path ( path ) ; goto again ; } ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; if ( ret ) goto out ;  if ( value ) {  btrfs_release_path ( path ) ; goto again ; } } out : btrfs_free_path ( path ) ; return ret ; }","struct btrfs_dir_item * di = NULL ;struct btrfs_root * root = BTRFS_I ( inode ) -> root ;path -> skip_release_on_error = 1 ;if ( ! value ) {di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;if ( ! di && ( flags & XATTR_REPLACE ) ) ret = - ENODATA ;else if ( di ) ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;}ret = - ENODATA ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( ret ) goto out ;btrfs_release_path ( path ) ;if ( ! value ) goto out ;if ( flags & XATTR_REPLACE ) {ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ;di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ;if ( flags & XATTR_CREATE ) goto out ;btrfs_release_path ( path ) ;di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;btrfs_release_path ( path ) ;di = NULL ;}ret = btrfs_insert_xattr_item ( trans , root , path , di ) ;btrfs_extend_item ( root , path , data_size ) ;item = btrfs_item_nr ( slot ) ;ptr = btrfs_item_ptr ( leaf , slot , char ) ;ptr += btrfs_item_size ( leaf , item ) - data_size ;di = ( struct btrfs_dir_item * ) ptr ;btrfs_set_dir_data_len ( leaf , di , size ) ;data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ;write_extent_buffer ( leaf , value , data_ptr , size ) ;btrfs_mark_buffer_dirty ( leaf ) ;}else {",2284
177,"buggy line: char * old = x -> ptr ;int newlen ;newlen = x -> length * 6 / 5 ;if ( newlen == x -> length )  newlen += 2 ;cwe id:CWE-119context: void Strgrow ( Str x ) { char * old = x -> ptr ; int newlen ;  newlen = x -> length * 6 / 5 ;   if ( newlen == x -> length )  newlen += 2 ; x -> ptr = GC_MALLOC_ATOMIC ( newlen ) ; x -> area_size = newlen ; bcopy ( ( void * ) old , ( void * ) x -> ptr , x -> length ) ; GC_free ( old ) ; }",char * old = x -> area_size * 6 / 5 ;if ( newlen == x -> length ) newlen += 2 ;,2285
178,"buggy line: lock_sock ( sk ) ;if ( sk -> sk_state != SS_CONNECTED ) {cwe id:CWE-200context: static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ;  lock_sock ( sk ) ;  if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }",msg -> msg_namelen = 0 ;lock_sock ( sk ) ;if ( sk -> sk_state != SS_CONNECTED ) {,2286
179,"buggy line: if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {char hexstr [ 3 ] ;cwe id:CWE-119context: CURLcode Curl_urldecode ( struct SessionHandle * data , const char * string , size_t length , char * * ostring , size_t * olen , bool reject_ctrl ) { size_t alloc = ( length ? length : strlen ( string ) ) + 1 ; char * ns = malloc ( alloc ) ; unsigned char in ; size_t strindex = 0 ; unsigned long hex ; CURLcode res ; if ( ! ns ) return CURLE_OUT_OF_MEMORY ; while ( -- alloc > 0 ) { in = * string ;  if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {  char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; res = Curl_convert_from_network ( data , & in , 1 ) ; if ( res ) { free ( ns ) ; return res ; } string += 2 ; alloc -= 2 ; } if ( reject_ctrl && ( in < 0x20 ) ) { free ( ns ) ; return CURLE_URL_MALFORMAT ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) * olen = strindex ; if ( ostring ) * ostring = ns ; return CURLE_OK ; }",if ( ( '%' == in ) && ( alloc > 2 ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {char hexstr [ 3 ] ;,2287
180,"buggy line: res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;rcu_read_unlock ( ) ;cwe id:CWE-416context: int inet6_csk_xmit ( struct sock * sk , struct sk_buff * skb , struct flowi * fl_unused ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 fl6 ; struct dst_entry * dst ; int res ; dst = inet6_csk_route_socket ( sk , & fl6 ) ; if ( IS_ERR ( dst ) ) { sk -> sk_err_soft = - PTR_ERR ( dst ) ; sk -> sk_route_caps = 0 ; kfree_skb ( skb ) ; return PTR_ERR ( dst ) ; } rcu_read_lock ( ) ; skb_dst_set_noref ( skb , dst ) ; fl6 . daddr = sk -> sk_v6_daddr ;  res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;  rcu_read_unlock ( ) ; return res ; }","res = ip6_xmit ( sk , skb , & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ;rcu_read_unlock ( ) ;",2288
181,"buggy line: skb_dst_drop ( skb ) ;}cwe id:CWE-476context: void ipv4_pktinfo_prepare ( const struct sock * sk , struct sk_buff * skb ) { struct in_pktinfo * pktinfo = PKTINFO_SKB_CB ( skb ) ; bool prepare = ( inet_sk ( sk ) -> cmsg_flags & IP_CMSG_PKTINFO ) || ipv6_sk_rxinfo ( sk ) ; if ( prepare && skb_rtable ( skb ) ) { if ( pktinfo -> ipi_ifindex == LOOPBACK_IFINDEX ) pktinfo -> ipi_ifindex = inet_iif ( skb ) ; pktinfo -> ipi_spec_dst . s_addr = fib_compute_spec_dst ( skb ) ; } else { pktinfo -> ipi_ifindex = 0 ; pktinfo -> ipi_spec_dst . s_addr = 0 ; }  skb_dst_drop ( skb ) ;  }",if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ;else skb_dst_drop ( skb ) ;},2289
182,"buggy line: cwe id:CWE-399context: static void xsltCompileLocationPathPattern ( xsltParserContextPtr ctxt , int novar ) { SKIP_BLANKS ; if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { NEXT ; NEXT ; ctxt -> comp -> priority = 0.5 ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { NEXT ; SKIP_BLANKS ; PUSH ( XSLT_OP_ROOT , NULL , NULL , novar ) ; if ( ( CUR != 0 ) && ( CUR != '|' ) ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } } else if ( CUR == '*' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '@' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else { xmlChar * name ; name = xsltScanNCName ( ctxt ) ; if ( name == NULL ) { xsltTransformError ( NULL , NULL , NULL , ""xsltCompileLocationPathPattern<S2SV_blank>:<S2SV_blank>Name<S2SV_blank>expected\\n"" ) ; ctxt -> error = 1 ; return ; } SKIP_BLANKS ; if ( ( CUR == '(' ) && ! xmlXPathIsNodeType ( name ) ) { xsltCompileIdKeyPattern ( ctxt , name , 1 , novar , 0 ) ;  if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) {  PUSH ( XSLT_OP_ANCESTOR , NULL , NULL , novar ) ; NEXT ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } return ; } xsltCompileRelativePathPattern ( ctxt , name , novar ) ; } error : return ; }",if ( ctxt -> error ) return ;,2290
183,"buggy line: if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) {PUSH ( XSLT_OP_ANCESTOR , NULL , NULL , novar ) ;cwe id:CWE-399context: static void xsltCompileLocationPathPattern ( xsltParserContextPtr ctxt , int novar ) { SKIP_BLANKS ; if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { NEXT ; NEXT ; ctxt -> comp -> priority = 0.5 ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { NEXT ; SKIP_BLANKS ; PUSH ( XSLT_OP_ROOT , NULL , NULL , novar ) ; if ( ( CUR != 0 ) && ( CUR != '|' ) ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } } else if ( CUR == '*' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '@' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else { xmlChar * name ; name = xsltScanNCName ( ctxt ) ; if ( name == NULL ) { xsltTransformError ( NULL , NULL , NULL , ""xsltCompileLocationPathPattern<S2SV_blank>:<S2SV_blank>Name<S2SV_blank>expected\\n"" ) ; ctxt -> error = 1 ; return ; } SKIP_BLANKS ; if ( ( CUR == '(' ) && ! xmlXPathIsNodeType ( name ) ) { xsltCompileIdKeyPattern ( ctxt , name , 1 , novar , 0 ) ;  if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) {  PUSH ( XSLT_OP_ANCESTOR , NULL , NULL , novar ) ; NEXT ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } return ; } xsltCompileRelativePathPattern ( ctxt , name , novar ) ; } error : return ; }","if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) {PUSH ( XSLT_OP_ANCESTOR , NULL , NULL , novar ) ;",2290
184,"buggy line: u32 offset ;msg -> msg_namelen = 0 ;cwe id:CWE-20context: static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; int err = 0 ;  u32 offset ;  msg -> msg_namelen = 0 ; if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } offset = IUCV_SKB_CB ( skb ) -> offset ; rlen = skb -> len - offset ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , offset , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , sizeof ( IUCV_SKB_CB ( skb ) -> class ) , ( void * ) & IUCV_SKB_CB ( skb ) -> class ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { if ( copied < rlen ) { IUCV_SKB_CB ( skb ) -> offset = offset + copied ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { IUCV_SKB_CB ( rskb ) -> offset = 0 ; if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }",u32 offset ;,2291
185,"buggy line: if ( ( r = sshbuf_put_u32 ( m , state -> remote_protocol_flags ) ) != 0 || ( r = sshbuf_put_u32 ( m , ssh1cipher ) ) != 0 || ( r = sshbuf_put_string ( m , state -> ssh1_key , state -> ssh1_keylen ) ) != 0 || ( r = sshbuf_put_u32 ( m , slen ) ) != 0 || ( r = sshbuf_reserve ( m , slen , & p ) ) != 0 || ( r = cipher_get_keyiv ( state -> send_context , p , slen ) ) != 0 || ( r = sshbuf_put_u32 ( m , rlen ) ) != 0 || ( r = sshbuf_reserve ( m , rlen , & p ) ) != 0 || ( r = cipher_get_keyiv ( state -> receive_context , p , rlen ) ) != 0 ) return r ;}else {if ( ( r = kex_to_blob ( m , ssh -> kex ) ) != 0 || ( r = newkeys_to_blob ( m , ssh , MODE_OUT ) ) != 0 || ( r = newkeys_to_blob ( m , ssh , MODE_IN ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> rekey_limit ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> rekey_interval ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_send . seqnr ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_send . blocks ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_send . packets ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_send . bytes ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_read . seqnr ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_read . blocks ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_read . packets ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_read . bytes ) ) != 0 ) return r ;}slen = cipher_get_keycontext ( state -> send_context , NULL ) ;rlen = cipher_get_keycontext ( state -> receive_context , NULL ) ;if ( ( r = sshbuf_put_u32 ( m , slen ) ) != 0 || ( r = sshbuf_reserve ( m , slen , & p ) ) != 0 ) return r ;if ( cipher_get_keycontext ( state -> send_context , p ) != ( int ) slen ) return SSH_ERR_INTERNAL_ERROR ;if ( ( r = sshbuf_put_u32 ( m , rlen ) ) != 0 || ( r = sshbuf_reserve ( m , rlen , & p ) ) != 0 ) return r ;if ( cipher_get_keycontext ( state -> receive_context , p ) != ( int ) rlen ) return SSH_ERR_INTERNAL_ERROR ;if ( ( r = ssh_packet_get_compress_state ( m , ssh ) ) != 0 ||  ( r = sshbuf_put_stringb ( m , state -> input ) ) != 0 || ( r = sshbuf_put_stringb ( m , state -> output ) ) != 0 ) return r ;cwe id:CWE-119context: int ssh_packet_get_state ( struct ssh * ssh , struct sshbuf * m ) { struct session_state * state = ssh -> state ; u_char * p ; size_t slen , rlen ; int r , ssh1cipher ; if ( ! compat20 ) { ssh1cipher = cipher_ctx_get_number ( state -> receive_context ) ; slen = cipher_get_keyiv_len ( state -> send_context ) ; rlen = cipher_get_keyiv_len ( state -> receive_context ) ; if ( ( r = sshbuf_put_u32 ( m , state -> remote_protocol_flags ) ) != 0 || ( r = sshbuf_put_u32 ( m , ssh1cipher ) ) != 0 || ( r = sshbuf_put_string ( m , state -> ssh1_key , state -> ssh1_keylen ) ) != 0 || ( r = sshbuf_put_u32 ( m , slen ) ) != 0 || ( r = sshbuf_reserve ( m , slen , & p ) ) != 0 || ( r = cipher_get_keyiv ( state -> send_context , p , slen ) ) != 0 || ( r = sshbuf_put_u32 ( m , rlen ) ) != 0 || ( r = sshbuf_reserve ( m , rlen , & p ) ) != 0 || ( r = cipher_get_keyiv ( state -> receive_context , p , rlen ) ) != 0 ) return r ; } else { if ( ( r = kex_to_blob ( m , ssh -> kex ) ) != 0 || ( r = newkeys_to_blob ( m , ssh , MODE_OUT ) ) != 0 || ( r = newkeys_to_blob ( m , ssh , MODE_IN ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> rekey_limit ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> rekey_interval ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_send . seqnr ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_send . blocks ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_send . packets ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_send . bytes ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_read . seqnr ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_read . blocks ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_read . packets ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_read . bytes ) ) != 0 ) return r ; } slen = cipher_get_keycontext ( state -> send_context , NULL ) ; rlen = cipher_get_keycontext ( state -> receive_context , NULL ) ; if ( ( r = sshbuf_put_u32 ( m , slen ) ) != 0 || ( r = sshbuf_reserve ( m , slen , & p ) ) != 0 ) return r ; if ( cipher_get_keycontext ( state -> send_context , p ) != ( int ) slen ) return SSH_ERR_INTERNAL_ERROR ; if ( ( r = sshbuf_put_u32 ( m , rlen ) ) != 0 || ( r = sshbuf_reserve ( m , rlen , & p ) ) != 0 ) return r ; if ( cipher_get_keycontext ( state -> receive_context , p ) != ( int ) rlen ) return SSH_ERR_INTERNAL_ERROR ;  if ( ( r = ssh_packet_get_compress_state ( m , ssh ) ) != 0 ||  ( r = sshbuf_put_stringb ( m , state -> input ) ) != 0 || ( r = sshbuf_put_stringb ( m , state -> output ) ) != 0 ) return r ; return 0 ; }","if ( ( r = sshbuf_put_stringb ( m , state -> input ) ) != 0 || ( r = sshbuf_put_stringb ( m , state -> output ) ) != 0 ) return r ;",2292
186,"buggy line: bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ;if ( bi -> pdwidth < bi -> npwidth ) {bi -> pdwidth = bi -> npwidth ;cwe id:CWE-369context: void fmtutil_macbitmap_read_pixmap_only_fields ( deark * c , dbuf * f , struct fmtutil_macbitmap_info * bi , i64 pos ) { i64 pixmap_version ; i64 pack_size ; i64 plane_bytes ; i64 n ; de_dbg ( c , ""additional<S2SV_blank>PixMap<S2SV_blank>header<S2SV_blank>fields,<S2SV_blank>at<S2SV_blank>%d"" , ( int ) pos ) ; de_dbg_indent ( c , 1 ) ; pixmap_version = dbuf_getu16be ( f , pos + 0 ) ; de_dbg ( c , ""pixmap<S2SV_blank>version:<S2SV_blank>%d"" , ( int ) pixmap_version ) ; bi -> packing_type = dbuf_getu16be ( f , pos + 2 ) ; de_dbg ( c , ""packing<S2SV_blank>type:<S2SV_blank>%d"" , ( int ) bi -> packing_type ) ; pack_size = dbuf_getu32be ( f , pos + 4 ) ; de_dbg ( c , ""pixel<S2SV_blank>data<S2SV_blank>length:<S2SV_blank>%d"" , ( int ) pack_size ) ; bi -> hdpi = pict_read_fixed ( f , pos + 8 ) ; bi -> vdpi = pict_read_fixed ( f , pos + 12 ) ; de_dbg ( c , ""dpi:<S2SV_blank>%.2f"" DE_CHAR_TIMES ""%.2f"" , bi -> hdpi , bi -> vdpi ) ; bi -> pixeltype = dbuf_getu16be ( f , pos + 16 ) ; bi -> pixelsize = dbuf_getu16be ( f , pos + 18 ) ; bi -> cmpcount = dbuf_getu16be ( f , pos + 20 ) ; bi -> cmpsize = dbuf_getu16be ( f , pos + 22 ) ; de_dbg ( c , ""pixel<S2SV_blank>type=%d,<S2SV_blank>bits/pixel=%d,<S2SV_blank>components/pixel=%d,<S2SV_blank>bits/comp=%d"" , ( int ) bi -> pixeltype , ( int ) bi -> pixelsize , ( int ) bi -> cmpcount , ( int ) bi -> cmpsize ) ;  bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ;   if ( bi -> pdwidth < bi -> npwidth ) {  bi -> pdwidth = bi -> npwidth ; } plane_bytes = dbuf_getu32be ( f , pos + 24 ) ; de_dbg ( c , ""plane<S2SV_blank>bytes:<S2SV_blank>%d"" , ( int ) plane_bytes ) ; bi -> pmTable = ( u32 ) dbuf_getu32be ( f , pos + 28 ) ; de_dbg ( c , ""pmTable:<S2SV_blank>0x%08x"" , ( unsigned int ) bi -> pmTable ) ; n = dbuf_getu32be ( f , pos + 32 ) ; de_dbg ( c , ""pmReserved:<S2SV_blank>0x%08x"" , ( unsigned int ) n ) ; de_dbg_indent ( c , - 1 ) ; }",if ( bi -> pixelsize > 0 ) {bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ;}if ( bi -> pdwidth < bi -> npwidth ) {bi -> pdwidth = bi -> npwidth ;,2293
187,"buggy line: if ( phy -> port -> num_phys == 0 )  sas_port_delete ( phy -> port ) ;phy -> port = NULL ;cwe id:CWE-000context: static void sas_unregister_devs_sas_addr ( struct domain_device * parent , int phy_id , bool last ) { struct expander_device * ex_dev = & parent -> ex_dev ; struct ex_phy * phy = & ex_dev -> ex_phy [ phy_id ] ; struct domain_device * child , * n , * found = NULL ; if ( last ) { list_for_each_entry_safe ( child , n , & ex_dev -> children , siblings ) { if ( SAS_ADDR ( child -> sas_addr ) == SAS_ADDR ( phy -> attached_sas_addr ) ) { set_bit ( SAS_DEV_GONE , & child -> state ) ; if ( child -> dev_type == SAS_EDGE_EXPANDER_DEVICE || child -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) sas_unregister_ex_tree ( parent -> port , child ) ; else sas_unregister_dev ( parent -> port , child ) ; found = child ; break ; } } sas_disable_routing ( parent , phy -> attached_sas_addr ) ; } memset ( phy -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; if ( phy -> port ) { sas_port_delete_phy ( phy -> port , phy -> phy ) ; sas_device_set_phy ( found , phy -> port ) ; if ( phy -> port -> num_phys == 0 )  sas_port_delete ( phy -> port ) ;  phy -> port = NULL ; } }","if ( phy -> port -> num_phys == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list ) ;phy -> port = NULL ;",2294
188,"buggy line: static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd ,  const struct in6_addr * dst , const struct in6_addr * src ) {u32 hash , id ;hash = __ipv6_addr_jhash ( dst , hashrnd ) ;hash = __ipv6_addr_jhash ( src , hash ) ;hash ^= net_hash_mix ( net ) ;cwe id:CWE-200context:  static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd ,  const struct in6_addr * dst , const struct in6_addr * src ) {  u32 hash , id ;   hash = __ipv6_addr_jhash ( dst , hashrnd ) ;   hash = __ipv6_addr_jhash ( src , hash ) ;  hash ^= net_hash_mix ( net ) ; id = ip_idents_reserve ( hash , 1 ) ; if ( unlikely ( ! id ) ) id = 1 << 31 ; return id ; }","static u32 __ipv6_select_ident ( struct net * net , const struct in6_addr * dst , const struct in6_addr * src ) {const struct {struct in6_addr dst ;struct in6_addr src ;}__aligned ( SIPHASH_ALIGNMENT ) combined = {. dst = * dst , . src = * src , };u32 hash , id ;if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) ) ;hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key ) ;",2295
189,"buggy line: if ( unlikely ( ! access_ok ( ! rw , buf , kiocb -> ki_nbytes ) ) )  return - EFAULT ;iovec -> iov_len = kiocb -> ki_nbytes ;* nr_segs = 1 ;cwe id:CWE-000context: static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , struct iovec * iovec ) {  if ( unlikely ( ! access_ok ( ! rw , buf , kiocb -> ki_nbytes ) ) )  return - EFAULT ; iovec -> iov_base = buf ;  iovec -> iov_len = kiocb -> ki_nbytes ;  * nr_segs = 1 ; return 0 ; }","size_t len = kiocb -> ki_nbytes ;if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ;if ( unlikely ( ! access_ok ( ! rw , buf , len ) ) ) return - EFAULT ;iovec -> iov_len = len ;* nr_segs = 1 ;",2296
190,"buggy line: assert ( sp -> encodepfunc != NULL ) ;( * sp -> encodepfunc ) ( tif , bp , cc ) ;return ( * sp -> encoderow ) ( tif , bp , cc , s ) ;cwe id:CWE-119context: static int PredictorEncodeRow ( TIFF * tif , uint8 * bp , tmsize_t cc , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encoderow != NULL ) ;  ( * sp -> encodepfunc ) ( tif , bp , cc ) ;  return ( * sp -> encoderow ) ( tif , bp , cc , s ) ; }","if ( ! assert ( sp -> encodepfunc != NULL ) ;( * sp -> encodepfunc ) ( tif , bp , cc ) ) return 0 ;return ( * sp -> encoderow ) ( tif , bp , cc , s ) ;",2297
191,"buggy line: vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ;mod_frame_err = calculate_modified_err ( cpi , this_frame ) ;cwe id:CWE-119context: static void define_gf_group ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame ) { FIRSTPASS_STATS next_frame ; FIRSTPASS_STATS * start_pos ; int i ; double r ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double gf_group_err = 0.0 ; double gf_first_frame_err = 0.0 ; double mod_frame_err = 0.0 ; double mv_ratio_accumulator = 0.0 ; double decay_accumulator = 1.0 ; double loop_decay_rate = 1.00 ; double this_frame_mv_in_out = 0.0 ; double mv_in_out_accumulator = 0.0 ; double abs_mv_in_out_accumulator = 0.0 ; double mod_err_per_mb_accumulator = 0.0 ; int max_bits = frame_max_bits ( cpi ) ; unsigned int allow_alt_ref = cpi -> oxcf . play_alternate && cpi -> oxcf . lag_in_frames ; int alt_boost = 0 ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; cpi -> twopass . gf_group_bits = 0 ; cpi -> twopass . gf_decay_rate = 0 ; vp8_clear_system_state ( ) ; start_pos = cpi -> twopass . stats_in ;  vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ;  mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( cpi -> common . frame_type == KEY_FRAME ) gf_group_err -= gf_first_frame_err ; i = 0 ; while ( ( ( i < cpi -> twopass . static_scene_max_gf_interval ) || ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) ) && ( i < cpi -> twopass . frames_to_key ) ) { i ++ ; mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; mod_err_per_mb_accumulator += mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> common . MBs ) ; if ( EOF == input_stats ( cpi , & next_frame ) ) break ; flash_detected = detect_flash ( cpi , 0 ) ; accumulate_frame_motion_stats ( cpi , & next_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ; r = calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ; if ( ! flash_detected ) { loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; decay_accumulator = decay_accumulator * loop_decay_rate ; decay_accumulator = decay_accumulator < 0.1 ? 0.1 : decay_accumulator ; } boost_score += ( decay_accumulator * r ) ; if ( detect_transition_to_still ( cpi , i , 5 , loop_decay_rate , decay_accumulator ) ) { allow_alt_ref = 0 ; boost_score = old_boost_score ; break ; } if ( ( i >= cpi -> max_gf_interval && ( decay_accumulator < 0.995 ) ) || ( ( i > MIN_GF_INTERVAL ) && ( ( cpi -> twopass . frames_to_key - i ) >= MIN_GF_INTERVAL ) && ( ( boost_score > 20.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > 100.0 ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || ( ( boost_score - old_boost_score ) < 2.0 ) ) ) ) { boost_score = old_boost_score ; break ; }  vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ;  old_boost_score = boost_score ; } cpi -> twopass . gf_decay_rate = ( i > 0 ) ? ( int ) ( 100.0 * ( 1.0 - decay_accumulator ) ) / i : 0 ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { double max_boost ; if ( cpi -> drop_frames_allowed ) { int64_t df_buffer_level = cpi -> oxcf . drop_frames_water_mark * ( cpi -> oxcf . optimal_buffer_level / 100 ) ; if ( cpi -> buffer_level > df_buffer_level ) max_boost = ( ( double ) ( ( cpi -> buffer_level - df_buffer_level ) * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; else max_boost = 0.0 ; } else if ( cpi -> buffer_level > 0 ) { max_boost = ( ( double ) ( cpi -> buffer_level * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; } else { max_boost = 0.0 ; } if ( boost_score > max_boost ) boost_score = max_boost ; } if ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) { while ( i < cpi -> twopass . frames_to_key ) { i ++ ; if ( EOF == input_stats ( cpi , this_frame ) ) break ; if ( i < cpi -> twopass . frames_to_key ) { mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; } } } cpi -> gfu_boost = ( int ) ( boost_score * 100.0 ) >> 4 ; # if NEW_BOOST alt_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; # endif if ( allow_alt_ref && ( i >= MIN_GF_INTERVAL ) && ( i <= ( cpi -> twopass . frames_to_key - MIN_GF_INTERVAL ) ) && # if NEW_BOOST ( ( next_frame . pcnt_inter > 0.75 ) || ( next_frame . pcnt_second_ref > 0.5 ) ) && ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || ( mv_in_out_accumulator > - 2.0 ) ) && ( b_boost > 100 ) && ( f_boost > 100 ) ) # else ( next_frame . pcnt_inter > 0.75 ) && ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || ( mv_in_out_accumulator > - 2.0 ) ) && ( cpi -> gfu_boost > 100 ) && ( cpi -> twopass . gf_decay_rate <= ( ARF_DECAY_THRESH + ( cpi -> gfu_boost / 200 ) ) ) ) # endif { int Boost ; int allocation_chunks ; int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int tmp_q ; int arf_frame_bits = 0 ; int group_bits ; # if NEW_BOOST cpi -> gfu_boost = alt_boost ; # endif if ( ( cpi -> twopass . kf_group_bits > 0 ) && ( cpi -> twopass . kf_group_error_left > 0 ) ) { group_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * ( gf_group_err / ( double ) cpi -> twopass . kf_group_error_left ) ) ; } else group_bits = 0 ; # if NEW_BOOST Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; # else Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; # endif Boost += ( i * 50 ) ; if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( i * 100 ) + Boost ; while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } arf_frame_bits = ( int ) ( ( double ) Boost * ( group_bits / ( double ) allocation_chunks ) ) ; tmp_q = estimate_q ( cpi , mod_frame_err , ( int ) arf_frame_bits ) ; if ( tmp_q < cpi -> worst_quality ) { int half_gf_int ; int frames_after_arf ; int frames_bwd = cpi -> oxcf . arnr_max_frames - 1 ; int frames_fwd = cpi -> oxcf . arnr_max_frames - 1 ; cpi -> source_alt_ref_pending = 1 ; cpi -> baseline_gf_interval = i ; half_gf_int = cpi -> baseline_gf_interval >> 1 ; frames_after_arf = ( int ) ( cpi -> twopass . total_stats . count - this_frame -> frame - 1 ) ; switch ( cpi -> oxcf . arnr_type ) { case 1 : frames_fwd = 0 ; if ( frames_bwd > half_gf_int ) frames_bwd = half_gf_int ; break ; case 2 : if ( frames_fwd > half_gf_int ) frames_fwd = half_gf_int ; if ( frames_fwd > frames_after_arf ) frames_fwd = frames_after_arf ; frames_bwd = 0 ; break ; case 3 : default : frames_fwd >>= 1 ; if ( frames_fwd > frames_after_arf ) frames_fwd = frames_after_arf ; if ( frames_fwd > half_gf_int ) frames_fwd = half_gf_int ; frames_bwd = frames_fwd ; if ( frames_bwd < half_gf_int ) frames_bwd += ( cpi -> oxcf . arnr_max_frames + 1 ) & 0x1 ; break ; } cpi -> active_arnr_frames = frames_bwd + 1 + frames_fwd ; } else { cpi -> source_alt_ref_pending = 0 ; cpi -> baseline_gf_interval = i ; } } else { cpi -> source_alt_ref_pending = 0 ; cpi -> baseline_gf_interval = i ; } if ( cpi -> twopass . frames_to_key >= ( int ) ( cpi -> twopass . total_stats . count - cpi -> common . current_video_frame ) ) { cpi -> twopass . kf_group_bits = ( cpi -> twopass . bits_left > 0 ) ? cpi -> twopass . bits_left : 0 ; } if ( ( cpi -> twopass . kf_group_bits > 0 ) && ( cpi -> twopass . kf_group_error_left > 0 ) ) { cpi -> twopass . gf_group_bits = ( int64_t ) ( cpi -> twopass . kf_group_bits * ( gf_group_err / cpi -> twopass . kf_group_error_left ) ) ; } else cpi -> twopass . gf_group_bits = 0 ; cpi -> twopass . gf_group_bits = ( cpi -> twopass . gf_group_bits < 0 ) ? 0 : ( cpi -> twopass . gf_group_bits > cpi -> twopass . kf_group_bits ) ? cpi -> twopass . kf_group_bits : cpi -> twopass . gf_group_bits ; if ( cpi -> twopass . gf_group_bits > ( int64_t ) max_bits * cpi -> baseline_gf_interval ) cpi -> twopass . gf_group_bits = ( int64_t ) max_bits * cpi -> baseline_gf_interval ; reset_fpf_position ( cpi , start_pos ) ; cpi -> twopass . modified_error_used += gf_group_err ; for ( i = 0 ; i <= ( cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) ; i ++ ) { int Boost ; int allocation_chunks ; int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int gf_bits ; if ( cpi -> source_alt_ref_pending && i == 0 ) { # if NEW_BOOST Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; # else Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; # endif Boost += ( cpi -> baseline_gf_interval * 50 ) ; if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( ( cpi -> baseline_gf_interval + 1 ) * 100 ) + Boost ; } else { Boost = ( cpi -> gfu_boost * GFQ_ADJUSTMENT ) / 100 ; if ( Boost > ( cpi -> baseline_gf_interval * 150 ) ) Boost = ( cpi -> baseline_gf_interval * 150 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( cpi -> baseline_gf_interval * 100 ) + ( Boost - 100 ) ; } while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } gf_bits = ( int ) ( ( double ) Boost * ( cpi -> twopass . gf_group_bits / ( double ) allocation_chunks ) ) ; if ( mod_frame_err < gf_group_err / ( double ) cpi -> baseline_gf_interval ) { double alt_gf_grp_bits ; int alt_gf_bits ; alt_gf_grp_bits = ( double ) cpi -> twopass . kf_group_bits * ( mod_frame_err * ( double ) cpi -> baseline_gf_interval ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ; alt_gf_bits = ( int ) ( ( double ) Boost * ( alt_gf_grp_bits / ( double ) allocation_chunks ) ) ; if ( gf_bits > alt_gf_bits ) { gf_bits = alt_gf_bits ; } } else { int alt_gf_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ) ; if ( alt_gf_bits > gf_bits ) { gf_bits = alt_gf_bits ; } } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( cpi -> twopass . gf_bits > ( int ) ( cpi -> buffer_level >> 1 ) ) cpi -> twopass . gf_bits = ( int ) ( cpi -> buffer_level >> 1 ) ; } if ( gf_bits < 0 ) gf_bits = 0 ; gf_bits += cpi -> min_frame_bandwidth ; if ( i == 0 ) { cpi -> twopass . gf_bits = gf_bits ; } if ( i == 1 || ( ! cpi -> source_alt_ref_pending && ( cpi -> common . frame_type != KEY_FRAME ) ) ) { cpi -> per_frame_bandwidth = gf_bits ; } } { cpi -> twopass . kf_group_error_left -= ( int64_t ) gf_group_err ; cpi -> twopass . kf_group_bits -= cpi -> twopass . gf_group_bits ; if ( cpi -> twopass . kf_group_bits < 0 ) cpi -> twopass . kf_group_bits = 0 ; if ( ! cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) cpi -> twopass . gf_group_error_left = ( int ) ( gf_group_err - gf_first_frame_err ) ; else cpi -> twopass . gf_group_error_left = ( int ) gf_group_err ; cpi -> twopass . gf_group_bits -= cpi -> twopass . gf_bits - cpi -> min_frame_bandwidth ; if ( cpi -> twopass . gf_group_bits < 0 ) cpi -> twopass . gf_group_bits = 0 ; if ( cpi -> baseline_gf_interval >= 3 ) { # if NEW_BOOST int boost = ( cpi -> source_alt_ref_pending ) ? b_boost : cpi -> gfu_boost ; # else int boost = cpi -> gfu_boost ; # endif if ( boost >= 150 ) { int pct_extra ; pct_extra = ( boost - 100 ) / 50 ; pct_extra = ( pct_extra > 20 ) ? 20 : pct_extra ; cpi -> twopass . alt_extra_bits = ( int ) ( cpi -> twopass . gf_group_bits * pct_extra ) / 100 ; cpi -> twopass . gf_group_bits -= cpi -> twopass . alt_extra_bits ; cpi -> twopass . alt_extra_bits /= ( ( cpi -> baseline_gf_interval - 1 ) >> 1 ) ; } else cpi -> twopass . alt_extra_bits = 0 ; } else cpi -> twopass . alt_extra_bits = 0 ; } if ( cpi -> common . frame_type != KEY_FRAME ) { FIRSTPASS_STATS sectionstats ; double Ratio ; zero_stats ( & sectionstats ) ; reset_fpf_position ( cpi , start_pos ) ; for ( i = 0 ; i < cpi -> baseline_gf_interval ; i ++ ) { input_stats ( cpi , & next_frame ) ; accumulate_stats ( & sectionstats , & next_frame ) ; } avg_stats ( & sectionstats ) ; cpi -> twopass . section_intra_rating = ( unsigned int ) ( sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; Ratio = sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ; cpi -> twopass . section_max_qfactor = 1.0 - ( ( Ratio - 10.0 ) * 0.025 ) ; if ( cpi -> twopass . section_max_qfactor < 0.80 ) cpi -> twopass . section_max_qfactor = 0.80 ; reset_fpf_position ( cpi , start_pos ) ; } }","memset ( & next_frame , 0 , sizeof ( next_frame ) ) ;mod_frame_err = calculate_modified_err ( cpi , this_frame ) ;",2298
192,"buggy line: if ( ( i >= cpi -> max_gf_interval && ( decay_accumulator < 0.995 ) ) || ( ( i > MIN_GF_INTERVAL ) && ( ( cpi -> twopass . frames_to_key - i ) >= MIN_GF_INTERVAL ) && ( ( boost_score > 20.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > 100.0 ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || ( ( boost_score - old_boost_score ) < 2.0 ) ) ) ) {boost_score = old_boost_score ;break ;}vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ;old_boost_score = boost_score ;cwe id:CWE-119context: static void define_gf_group ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame ) { FIRSTPASS_STATS next_frame ; FIRSTPASS_STATS * start_pos ; int i ; double r ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double gf_group_err = 0.0 ; double gf_first_frame_err = 0.0 ; double mod_frame_err = 0.0 ; double mv_ratio_accumulator = 0.0 ; double decay_accumulator = 1.0 ; double loop_decay_rate = 1.00 ; double this_frame_mv_in_out = 0.0 ; double mv_in_out_accumulator = 0.0 ; double abs_mv_in_out_accumulator = 0.0 ; double mod_err_per_mb_accumulator = 0.0 ; int max_bits = frame_max_bits ( cpi ) ; unsigned int allow_alt_ref = cpi -> oxcf . play_alternate && cpi -> oxcf . lag_in_frames ; int alt_boost = 0 ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; cpi -> twopass . gf_group_bits = 0 ; cpi -> twopass . gf_decay_rate = 0 ; vp8_clear_system_state ( ) ; start_pos = cpi -> twopass . stats_in ;  vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ;  mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( cpi -> common . frame_type == KEY_FRAME ) gf_group_err -= gf_first_frame_err ; i = 0 ; while ( ( ( i < cpi -> twopass . static_scene_max_gf_interval ) || ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) ) && ( i < cpi -> twopass . frames_to_key ) ) { i ++ ; mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; mod_err_per_mb_accumulator += mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> common . MBs ) ; if ( EOF == input_stats ( cpi , & next_frame ) ) break ; flash_detected = detect_flash ( cpi , 0 ) ; accumulate_frame_motion_stats ( cpi , & next_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ; r = calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ; if ( ! flash_detected ) { loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; decay_accumulator = decay_accumulator * loop_decay_rate ; decay_accumulator = decay_accumulator < 0.1 ? 0.1 : decay_accumulator ; } boost_score += ( decay_accumulator * r ) ; if ( detect_transition_to_still ( cpi , i , 5 , loop_decay_rate , decay_accumulator ) ) { allow_alt_ref = 0 ; boost_score = old_boost_score ; break ; } if ( ( i >= cpi -> max_gf_interval && ( decay_accumulator < 0.995 ) ) || ( ( i > MIN_GF_INTERVAL ) && ( ( cpi -> twopass . frames_to_key - i ) >= MIN_GF_INTERVAL ) && ( ( boost_score > 20.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > 100.0 ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || ( ( boost_score - old_boost_score ) < 2.0 ) ) ) ) { boost_score = old_boost_score ; break ; }  vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ;  old_boost_score = boost_score ; } cpi -> twopass . gf_decay_rate = ( i > 0 ) ? ( int ) ( 100.0 * ( 1.0 - decay_accumulator ) ) / i : 0 ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { double max_boost ; if ( cpi -> drop_frames_allowed ) { int64_t df_buffer_level = cpi -> oxcf . drop_frames_water_mark * ( cpi -> oxcf . optimal_buffer_level / 100 ) ; if ( cpi -> buffer_level > df_buffer_level ) max_boost = ( ( double ) ( ( cpi -> buffer_level - df_buffer_level ) * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; else max_boost = 0.0 ; } else if ( cpi -> buffer_level > 0 ) { max_boost = ( ( double ) ( cpi -> buffer_level * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; } else { max_boost = 0.0 ; } if ( boost_score > max_boost ) boost_score = max_boost ; } if ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) { while ( i < cpi -> twopass . frames_to_key ) { i ++ ; if ( EOF == input_stats ( cpi , this_frame ) ) break ; if ( i < cpi -> twopass . frames_to_key ) { mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; } } } cpi -> gfu_boost = ( int ) ( boost_score * 100.0 ) >> 4 ; # if NEW_BOOST alt_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; # endif if ( allow_alt_ref && ( i >= MIN_GF_INTERVAL ) && ( i <= ( cpi -> twopass . frames_to_key - MIN_GF_INTERVAL ) ) && # if NEW_BOOST ( ( next_frame . pcnt_inter > 0.75 ) || ( next_frame . pcnt_second_ref > 0.5 ) ) && ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || ( mv_in_out_accumulator > - 2.0 ) ) && ( b_boost > 100 ) && ( f_boost > 100 ) ) # else ( next_frame . pcnt_inter > 0.75 ) && ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || ( mv_in_out_accumulator > - 2.0 ) ) && ( cpi -> gfu_boost > 100 ) && ( cpi -> twopass . gf_decay_rate <= ( ARF_DECAY_THRESH + ( cpi -> gfu_boost / 200 ) ) ) ) # endif { int Boost ; int allocation_chunks ; int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int tmp_q ; int arf_frame_bits = 0 ; int group_bits ; # if NEW_BOOST cpi -> gfu_boost = alt_boost ; # endif if ( ( cpi -> twopass . kf_group_bits > 0 ) && ( cpi -> twopass . kf_group_error_left > 0 ) ) { group_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * ( gf_group_err / ( double ) cpi -> twopass . kf_group_error_left ) ) ; } else group_bits = 0 ; # if NEW_BOOST Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; # else Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; # endif Boost += ( i * 50 ) ; if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( i * 100 ) + Boost ; while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } arf_frame_bits = ( int ) ( ( double ) Boost * ( group_bits / ( double ) allocation_chunks ) ) ; tmp_q = estimate_q ( cpi , mod_frame_err , ( int ) arf_frame_bits ) ; if ( tmp_q < cpi -> worst_quality ) { int half_gf_int ; int frames_after_arf ; int frames_bwd = cpi -> oxcf . arnr_max_frames - 1 ; int frames_fwd = cpi -> oxcf . arnr_max_frames - 1 ; cpi -> source_alt_ref_pending = 1 ; cpi -> baseline_gf_interval = i ; half_gf_int = cpi -> baseline_gf_interval >> 1 ; frames_after_arf = ( int ) ( cpi -> twopass . total_stats . count - this_frame -> frame - 1 ) ; switch ( cpi -> oxcf . arnr_type ) { case 1 : frames_fwd = 0 ; if ( frames_bwd > half_gf_int ) frames_bwd = half_gf_int ; break ; case 2 : if ( frames_fwd > half_gf_int ) frames_fwd = half_gf_int ; if ( frames_fwd > frames_after_arf ) frames_fwd = frames_after_arf ; frames_bwd = 0 ; break ; case 3 : default : frames_fwd >>= 1 ; if ( frames_fwd > frames_after_arf ) frames_fwd = frames_after_arf ; if ( frames_fwd > half_gf_int ) frames_fwd = half_gf_int ; frames_bwd = frames_fwd ; if ( frames_bwd < half_gf_int ) frames_bwd += ( cpi -> oxcf . arnr_max_frames + 1 ) & 0x1 ; break ; } cpi -> active_arnr_frames = frames_bwd + 1 + frames_fwd ; } else { cpi -> source_alt_ref_pending = 0 ; cpi -> baseline_gf_interval = i ; } } else { cpi -> source_alt_ref_pending = 0 ; cpi -> baseline_gf_interval = i ; } if ( cpi -> twopass . frames_to_key >= ( int ) ( cpi -> twopass . total_stats . count - cpi -> common . current_video_frame ) ) { cpi -> twopass . kf_group_bits = ( cpi -> twopass . bits_left > 0 ) ? cpi -> twopass . bits_left : 0 ; } if ( ( cpi -> twopass . kf_group_bits > 0 ) && ( cpi -> twopass . kf_group_error_left > 0 ) ) { cpi -> twopass . gf_group_bits = ( int64_t ) ( cpi -> twopass . kf_group_bits * ( gf_group_err / cpi -> twopass . kf_group_error_left ) ) ; } else cpi -> twopass . gf_group_bits = 0 ; cpi -> twopass . gf_group_bits = ( cpi -> twopass . gf_group_bits < 0 ) ? 0 : ( cpi -> twopass . gf_group_bits > cpi -> twopass . kf_group_bits ) ? cpi -> twopass . kf_group_bits : cpi -> twopass . gf_group_bits ; if ( cpi -> twopass . gf_group_bits > ( int64_t ) max_bits * cpi -> baseline_gf_interval ) cpi -> twopass . gf_group_bits = ( int64_t ) max_bits * cpi -> baseline_gf_interval ; reset_fpf_position ( cpi , start_pos ) ; cpi -> twopass . modified_error_used += gf_group_err ; for ( i = 0 ; i <= ( cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) ; i ++ ) { int Boost ; int allocation_chunks ; int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int gf_bits ; if ( cpi -> source_alt_ref_pending && i == 0 ) { # if NEW_BOOST Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; # else Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; # endif Boost += ( cpi -> baseline_gf_interval * 50 ) ; if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( ( cpi -> baseline_gf_interval + 1 ) * 100 ) + Boost ; } else { Boost = ( cpi -> gfu_boost * GFQ_ADJUSTMENT ) / 100 ; if ( Boost > ( cpi -> baseline_gf_interval * 150 ) ) Boost = ( cpi -> baseline_gf_interval * 150 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( cpi -> baseline_gf_interval * 100 ) + ( Boost - 100 ) ; } while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } gf_bits = ( int ) ( ( double ) Boost * ( cpi -> twopass . gf_group_bits / ( double ) allocation_chunks ) ) ; if ( mod_frame_err < gf_group_err / ( double ) cpi -> baseline_gf_interval ) { double alt_gf_grp_bits ; int alt_gf_bits ; alt_gf_grp_bits = ( double ) cpi -> twopass . kf_group_bits * ( mod_frame_err * ( double ) cpi -> baseline_gf_interval ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ; alt_gf_bits = ( int ) ( ( double ) Boost * ( alt_gf_grp_bits / ( double ) allocation_chunks ) ) ; if ( gf_bits > alt_gf_bits ) { gf_bits = alt_gf_bits ; } } else { int alt_gf_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ) ; if ( alt_gf_bits > gf_bits ) { gf_bits = alt_gf_bits ; } } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( cpi -> twopass . gf_bits > ( int ) ( cpi -> buffer_level >> 1 ) ) cpi -> twopass . gf_bits = ( int ) ( cpi -> buffer_level >> 1 ) ; } if ( gf_bits < 0 ) gf_bits = 0 ; gf_bits += cpi -> min_frame_bandwidth ; if ( i == 0 ) { cpi -> twopass . gf_bits = gf_bits ; } if ( i == 1 || ( ! cpi -> source_alt_ref_pending && ( cpi -> common . frame_type != KEY_FRAME ) ) ) { cpi -> per_frame_bandwidth = gf_bits ; } } { cpi -> twopass . kf_group_error_left -= ( int64_t ) gf_group_err ; cpi -> twopass . kf_group_bits -= cpi -> twopass . gf_group_bits ; if ( cpi -> twopass . kf_group_bits < 0 ) cpi -> twopass . kf_group_bits = 0 ; if ( ! cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) cpi -> twopass . gf_group_error_left = ( int ) ( gf_group_err - gf_first_frame_err ) ; else cpi -> twopass . gf_group_error_left = ( int ) gf_group_err ; cpi -> twopass . gf_group_bits -= cpi -> twopass . gf_bits - cpi -> min_frame_bandwidth ; if ( cpi -> twopass . gf_group_bits < 0 ) cpi -> twopass . gf_group_bits = 0 ; if ( cpi -> baseline_gf_interval >= 3 ) { # if NEW_BOOST int boost = ( cpi -> source_alt_ref_pending ) ? b_boost : cpi -> gfu_boost ; # else int boost = cpi -> gfu_boost ; # endif if ( boost >= 150 ) { int pct_extra ; pct_extra = ( boost - 100 ) / 50 ; pct_extra = ( pct_extra > 20 ) ? 20 : pct_extra ; cpi -> twopass . alt_extra_bits = ( int ) ( cpi -> twopass . gf_group_bits * pct_extra ) / 100 ; cpi -> twopass . gf_group_bits -= cpi -> twopass . alt_extra_bits ; cpi -> twopass . alt_extra_bits /= ( ( cpi -> baseline_gf_interval - 1 ) >> 1 ) ; } else cpi -> twopass . alt_extra_bits = 0 ; } else cpi -> twopass . alt_extra_bits = 0 ; } if ( cpi -> common . frame_type != KEY_FRAME ) { FIRSTPASS_STATS sectionstats ; double Ratio ; zero_stats ( & sectionstats ) ; reset_fpf_position ( cpi , start_pos ) ; for ( i = 0 ; i < cpi -> baseline_gf_interval ; i ++ ) { input_stats ( cpi , & next_frame ) ; accumulate_stats ( & sectionstats , & next_frame ) ; } avg_stats ( & sectionstats ) ; cpi -> twopass . section_intra_rating = ( unsigned int ) ( sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; Ratio = sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ; cpi -> twopass . section_max_qfactor = 1.0 - ( ( Ratio - 10.0 ) * 0.025 ) ; if ( cpi -> twopass . section_max_qfactor < 0.80 ) cpi -> twopass . section_max_qfactor = 0.80 ; reset_fpf_position ( cpi , start_pos ) ; } }","memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ;old_boost_score = boost_score ;",2298
193,"buggy line: char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ;printf ( ""Extracting<S2SV_blank>%s\\\cwe id:CWE-22context: int main ( int argc , char * argv [ ] ) { struct mschm_decompressor * chmd ; struct mschmd_header * chm ; struct mschmd_file * file , * * f ; unsigned int numf , i ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; user_umask = umask ( 0 ) ; umask ( user_umask ) ; MSPACK_SYS_SELFTEST ( i ) ; if ( i ) return 0 ; if ( ( chmd = mspack_create_chm_decompressor ( NULL ) ) ) { for ( argv ++ ; * argv ; argv ++ ) { printf ( ""%s\\n"" , * argv ) ; if ( ( chm = chmd -> open ( chmd , * argv ) ) ) { for ( numf = 0 , file = chm -> files ; file ; file = file -> next ) numf ++ ; if ( ( f = ( struct mschmd_file * * ) calloc ( numf , sizeof ( struct mschmd_file * ) ) ) ) { for ( i = 0 , file = chm -> files ; file ; file = file -> next ) f [ i ++ ] = file ; qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; for ( i = 0 ; i < numf ; i ++ ) {  char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ;  printf ( ""Extracting<S2SV_blank>%s\\n"" , outname ) ; ensure_filepath ( outname ) ; if ( chmd -> extract ( chmd , f [ i ] , outname ) ) { printf ( ""%s:<S2SV_blank>extract<S2SV_blank>error<S2SV_blank>on<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , * argv , f [ i ] -> filename , ERROR ( chmd ) ) ; } free ( outname ) ; } free ( f ) ; } chmd -> close ( chmd , chm ) ; } else { printf ( ""%s:<S2SV_blank>can\'t<S2SV_blank>open<S2SV_blank>--<S2SV_blank>%s\\n"" , * argv , ERROR ( chmd ) ) ; } } mspack_destroy_chm_decompressor ( chmd ) ; } return 0 ; }","char * outname = create_output_name ( f [ i ] -> filename , NULL , 0 , 1 , 0 ) ;printf ( ""Extracting<S2SV_blank>%s\\\",2299
194,"buggy line: uint16_t numChannels , chansSpecified , chanMask = 0 ;uint32_t sampleRate ;cwe id:CWE-369context: int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ;  uint16_t numChannels , chansSpecified , chanMask = 0 ;  uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ;  if ( numChannels < chansSpecified || numChannels < 1 ) {  error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) {  total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;  break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }","uint16_t numChannels = 0 , chansSpecified , chanMask = 0 ;uint32_t sampleRate ;",2300
195,"buggy line: if ( numChannels < chansSpecified || numChannels < 1 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;cwe id:CWE-369context: int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ;  uint16_t numChannels , chansSpecified , chanMask = 0 ;  uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ;  if ( numChannels < chansSpecified || numChannels < 1 ) {  error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) {  total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;  break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }","if ( numChannels < chansSpecified || numChannels < 1 || numChannels > 256 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;",2300
196,"buggy line: cwe id:CWE-369context: int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ;  uint16_t numChannels , chansSpecified , chanMask = 0 ;  uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ;  if ( numChannels < chansSpecified || numChannels < 1 ) {  error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) {  total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;  break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }","if ( ! config -> num_channels ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}",2300
197,"buggy line: total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;break ;cwe id:CWE-369context: int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ;  uint16_t numChannels , chansSpecified , chanMask = 0 ;  uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ;  if ( numChannels < chansSpecified || numChannels < 1 ) {  error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) {  total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;  break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }",total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;break ;,2300
198,"buggy line: cwe id:CWE-000context: static int tty_open ( struct inode * inode , struct file * filp ) { struct tty_struct * tty = NULL ; int noctty , retval ; struct tty_driver * driver ; int index ; dev_t device = inode -> i_rdev ; unsigned saved_flags = filp -> f_flags ; nonseekable_open ( inode , filp ) ; retry_open : noctty = filp -> f_flags & O_NOCTTY ; index = - 1 ; retval = 0 ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; if ( device == MKDEV ( TTYAUX_MAJOR , 0 ) ) { tty = get_current_tty ( ) ; if ( ! tty ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENXIO ; } driver = tty_driver_kref_get ( tty -> driver ) ; index = tty -> index ; filp -> f_flags |= O_NONBLOCK ; tty_kref_put ( tty ) ; goto got_driver ; } # ifdef CONFIG_VT if ( device == MKDEV ( TTY_MAJOR , 0 ) ) { extern struct tty_driver * console_driver ; driver = tty_driver_kref_get ( console_driver ) ; index = fg_console ; noctty = 1 ; goto got_driver ; } # endif if ( device == MKDEV ( TTYAUX_MAJOR , 1 ) ) { struct tty_driver * console_driver = console_device ( & index ) ; if ( console_driver ) { driver = tty_driver_kref_get ( console_driver ) ; if ( driver ) { filp -> f_flags |= O_NONBLOCK ; noctty = 1 ; goto got_driver ; } } tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } driver = get_tty_driver ( device , & index ) ; if ( ! driver ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } got_driver : if ( ! tty ) { tty = tty_driver_lookup_tty ( driver , inode , index ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ;  return PTR_ERR ( tty ) ;  } } if ( tty ) { retval = tty_reopen ( tty ) ; if ( retval ) tty = ERR_PTR ( retval ) ; } else tty = tty_init_dev ( driver , index , 0 ) ; mutex_unlock ( & tty_mutex ) ; tty_driver_kref_put ( driver ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; return PTR_ERR ( tty ) ; } retval = tty_add_file ( tty , filp ) ; if ( retval ) { tty_unlock ( ) ; tty_release ( inode , filp ) ; return retval ; } check_tty_count ( tty , ""tty_open"" ) ; if ( tty -> driver -> type == TTY_DRIVER_TYPE_PTY && tty -> driver -> subtype == PTY_TYPE_MASTER ) noctty = 1 ; # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG ""opening<S2SV_blank>%s..."" , tty -> name ) ; # endif if ( tty -> ops -> open ) retval = tty -> ops -> open ( tty , filp ) ; else retval = - ENODEV ; filp -> f_flags = saved_flags ; if ( ! retval && test_bit ( TTY_EXCLUSIVE , & tty -> flags ) && ! capable ( CAP_SYS_ADMIN ) ) retval = - EBUSY ; if ( retval ) { # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG ""error<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>opening<S2SV_blank>%s..."" , retval , tty -> name ) ; # endif tty_unlock ( ) ; tty_release ( inode , filp ) ; if ( retval != - ERESTARTSYS ) return retval ; if ( signal_pending ( current ) ) return retval ; schedule ( ) ; tty_lock ( ) ; if ( filp -> f_op == & hung_up_tty_fops ) filp -> f_op = & tty_fops ; tty_unlock ( ) ; goto retry_open ; } tty_unlock ( ) ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; spin_lock_irq ( & current -> sighand -> siglock ) ; if ( ! noctty && current -> signal -> leader && ! current -> signal -> tty && tty -> session == NULL ) __proc_set_tty ( current , tty ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return 0 ; }",tty_driver_kref_put ( driver ) ;,2301
199,"buggy line: return PTR_ERR ( tty ) ;}cwe id:CWE-000context: static int tty_open ( struct inode * inode , struct file * filp ) { struct tty_struct * tty = NULL ; int noctty , retval ; struct tty_driver * driver ; int index ; dev_t device = inode -> i_rdev ; unsigned saved_flags = filp -> f_flags ; nonseekable_open ( inode , filp ) ; retry_open : noctty = filp -> f_flags & O_NOCTTY ; index = - 1 ; retval = 0 ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; if ( device == MKDEV ( TTYAUX_MAJOR , 0 ) ) { tty = get_current_tty ( ) ; if ( ! tty ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENXIO ; } driver = tty_driver_kref_get ( tty -> driver ) ; index = tty -> index ; filp -> f_flags |= O_NONBLOCK ; tty_kref_put ( tty ) ; goto got_driver ; } # ifdef CONFIG_VT if ( device == MKDEV ( TTY_MAJOR , 0 ) ) { extern struct tty_driver * console_driver ; driver = tty_driver_kref_get ( console_driver ) ; index = fg_console ; noctty = 1 ; goto got_driver ; } # endif if ( device == MKDEV ( TTYAUX_MAJOR , 1 ) ) { struct tty_driver * console_driver = console_device ( & index ) ; if ( console_driver ) { driver = tty_driver_kref_get ( console_driver ) ; if ( driver ) { filp -> f_flags |= O_NONBLOCK ; noctty = 1 ; goto got_driver ; } } tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } driver = get_tty_driver ( device , & index ) ; if ( ! driver ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } got_driver : if ( ! tty ) { tty = tty_driver_lookup_tty ( driver , inode , index ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ;  return PTR_ERR ( tty ) ;  } } if ( tty ) { retval = tty_reopen ( tty ) ; if ( retval ) tty = ERR_PTR ( retval ) ; } else tty = tty_init_dev ( driver , index , 0 ) ; mutex_unlock ( & tty_mutex ) ; tty_driver_kref_put ( driver ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; return PTR_ERR ( tty ) ; } retval = tty_add_file ( tty , filp ) ; if ( retval ) { tty_unlock ( ) ; tty_release ( inode , filp ) ; return retval ; } check_tty_count ( tty , ""tty_open"" ) ; if ( tty -> driver -> type == TTY_DRIVER_TYPE_PTY && tty -> driver -> subtype == PTY_TYPE_MASTER ) noctty = 1 ; # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG ""opening<S2SV_blank>%s..."" , tty -> name ) ; # endif if ( tty -> ops -> open ) retval = tty -> ops -> open ( tty , filp ) ; else retval = - ENODEV ; filp -> f_flags = saved_flags ; if ( ! retval && test_bit ( TTY_EXCLUSIVE , & tty -> flags ) && ! capable ( CAP_SYS_ADMIN ) ) retval = - EBUSY ; if ( retval ) { # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG ""error<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>opening<S2SV_blank>%s..."" , retval , tty -> name ) ; # endif tty_unlock ( ) ; tty_release ( inode , filp ) ; if ( retval != - ERESTARTSYS ) return retval ; if ( signal_pending ( current ) ) return retval ; schedule ( ) ; tty_lock ( ) ; if ( filp -> f_op == & hung_up_tty_fops ) filp -> f_op = & tty_fops ; tty_unlock ( ) ; goto retry_open ; } tty_unlock ( ) ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; spin_lock_irq ( & current -> sighand -> siglock ) ; if ( ! noctty && current -> signal -> leader && ! current -> signal -> tty && tty -> session == NULL ) __proc_set_tty ( current , tty ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return 0 ; }",return PTR_ERR ( tty ) ;},2301
200,"buggy line: if ( ! sctp_verify_asconf ( asoc ,  ( sctp_paramhdr_t * ) addip_hdr -> params ,  ( void * ) asconf_ack -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;cwe id:CWE-399context: sctp_disposition_t sctp_sf_do_asconf_ack ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * asconf_ack = arg ; struct sctp_chunk * last_asconf = asoc -> addip_last_asconf ; struct sctp_chunk * abort ; struct sctp_paramhdr * err_param = NULL ; sctp_addiphdr_t * addip_hdr ; __u32 sent_serial , rcvd_serial ; if ( ! sctp_vtag_verify ( asconf_ack , asoc ) ) { sctp_add_cmd_sf ( commands , SCTP_CMD_REPORT_BAD_TAG , SCTP_NULL ( ) ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } if ( ! net -> sctp . addip_noauth && ! asconf_ack -> auth ) return sctp_sf_discard_chunk ( net , ep , asoc , type , arg , commands ) ; if ( ! sctp_chunk_length_valid ( asconf_ack , sizeof ( sctp_addip_chunk_t ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; addip_hdr = ( sctp_addiphdr_t * ) asconf_ack -> skb -> data ; rcvd_serial = ntohl ( addip_hdr -> serial ) ; if ( ! sctp_verify_asconf ( asoc ,  ( sctp_paramhdr_t * ) addip_hdr -> params ,  ( void * ) asconf_ack -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ; if ( last_asconf ) { addip_hdr = ( sctp_addiphdr_t * ) last_asconf -> subh . addip_hdr ; sent_serial = ntohl ( addip_hdr -> serial ) ; } else { sent_serial = asoc -> addip_serial - 1 ; } if ( ADDIP_SERIAL_gte ( rcvd_serial , sent_serial + 1 ) && ! ( asoc -> addip_last_asconf ) ) { abort = sctp_make_abort ( asoc , asconf_ack , sizeof ( sctp_errhdr_t ) ) ; if ( abort ) { sctp_init_cause ( abort , SCTP_ERROR_ASCONF_ACK , 0 ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( abort ) ) ; } sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_STOP , SCTP_TO ( SCTP_EVENT_TIMEOUT_T4_RTO ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_DISCARD_PACKET , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , SCTP_ERROR ( ECONNABORTED ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , SCTP_PERR ( SCTP_ERROR_ASCONF_ACK ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_ABORTEDS ) ; SCTP_DEC_STATS ( net , SCTP_MIB_CURRESTAB ) ; return SCTP_DISPOSITION_ABORT ; } if ( ( rcvd_serial == sent_serial ) && asoc -> addip_last_asconf ) { sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_STOP , SCTP_TO ( SCTP_EVENT_TIMEOUT_T4_RTO ) ) ; if ( ! sctp_process_asconf_ack ( ( struct sctp_association * ) asoc , asconf_ack ) ) { sctp_add_cmd_sf ( commands , SCTP_CMD_SEND_NEXT_ASCONF , SCTP_NULL ( ) ) ; return SCTP_DISPOSITION_CONSUME ; } abort = sctp_make_abort ( asoc , asconf_ack , sizeof ( sctp_errhdr_t ) ) ; if ( abort ) { sctp_init_cause ( abort , SCTP_ERROR_RSRC_LOW , 0 ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( abort ) ) ; } sctp_add_cmd_sf ( commands , SCTP_CMD_DISCARD_PACKET , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , SCTP_ERROR ( ECONNABORTED ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , SCTP_PERR ( SCTP_ERROR_ASCONF_ACK ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_ABORTEDS ) ; SCTP_DEC_STATS ( net , SCTP_MIB_CURRESTAB ) ; return SCTP_DISPOSITION_ABORT ; } return SCTP_DISPOSITION_DISCARD ; }","if ( ! sctp_verify_asconf ( asoc , asconf_ack , false , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;",2302
201,"buggy line: memory_length += extra_length - available_length + BLOCK_QUEUE ;cp = new_memory ( memory_length , sizeof ( char ) ) ;if ( message_show ( MSG_INFO ) ) message ( ""Reallocating<S2SV_blank>queue<S2SV_blank>at<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p"" , qp -> d_memory , cp ) ;if ( qp -> d_read > qp -> d_write ) {size_t tail_len = qp -> d_memory_end - qp -> d_read ;memcpy ( cp , qp -> d_read , tail_len ) ;memcpy ( cp + tail_len , qp -> d_memory , ( size_t ) ( qp -> d_write - qp -> d_memory ) ) ;memcpy ( cp , qp -> d_memory , memory_length ) ;qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ;cwe id:CWE-119context: void queue_push ( register Queue * qp , size_t extra_length , char const * info ) { register char * cp ; size_t memory_length ; size_t available_length ; size_t begin_length ; size_t n_begin ; size_t q_length ; if ( ! extra_length ) return ; memory_length = qp -> d_memory_end - qp -> d_memory ; q_length = qp -> d_read <= qp -> d_write ? ( size_t ) ( qp -> d_write - qp -> d_read ) : memory_length - ( qp -> d_read - qp -> d_write ) ; available_length = memory_length - q_length - 1 ; if ( message_show ( MSG_INFO ) ) message ( ""push_front<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>`%s\'"" , ( unsigned ) extra_length , info ) ; if ( extra_length > available_length ) {  memory_length += extra_length - available_length + BLOCK_QUEUE ;  cp = new_memory ( memory_length , sizeof ( char ) ) ; if ( message_show ( MSG_INFO ) ) message ( ""Reallocating<S2SV_blank>queue<S2SV_blank>at<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p"" , qp -> d_memory , cp ) ; if ( qp -> d_read > qp -> d_write ) { size_t tail_len = qp -> d_memory_end - qp -> d_read ; memcpy ( cp , qp -> d_read , tail_len ) ; memcpy ( cp + tail_len , qp -> d_memory , ( size_t ) ( qp -> d_write - qp -> d_memory ) ) ; qp -> d_write = cp + q_length ; qp -> d_read = cp ; } else {  memcpy ( cp , qp -> d_memory , memory_length ) ;  qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ; qp -> d_write = cp + ( qp -> d_write - qp -> d_memory ) ; } free ( qp -> d_memory ) ; qp -> d_memory_end = cp + memory_length ; qp -> d_memory = cp ; } begin_length = qp -> d_read - qp -> d_memory ; n_begin = extra_length <= begin_length ? extra_length : begin_length ; memcpy ( qp -> d_read -= n_begin , info + extra_length - n_begin , n_begin ) ; if ( extra_length > begin_length ) { extra_length -= begin_length ; memcpy ( qp -> d_read = qp -> d_memory_end - extra_length , info , extra_length ) ; } }","size_t original_length = memory_length ;memory_length += extra_length - available_length + BLOCK_QUEUE ;cp = new_memory ( memory_length , sizeof ( char ) ) ;if ( message_show ( MSG_INFO ) ) message ( ""Reallocating<S2SV_blank>queue<S2SV_blank>at<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p"" , qp -> d_memory , original_length ) ;memcpy ( cp , qp -> d_memory , memory_length ) ;qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ;",2303
202,"buggy line: _copy_from_pages ( buf , pages , res . acl_data_offset ,  res . acl_len ) ;}cwe id:CWE-189context: static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%zu<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%zu\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , NULL , acl_len ) ; else nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ) ; if ( buf ) { ret = - ERANGE ; if ( acl_len > buflen ) goto out_free ; _copy_from_pages ( buf , pages , res . acl_data_offset ,  res . acl_len ) ;  } ret = acl_len ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ; if ( res . acl_scratch ) __free_page ( res . acl_scratch ) ; return ret ; }","_copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ;}",2304
203,"buggy line: q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) ,   Min ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;cwe id:CWE-20context: static MagickBooleanType ReadDXT5 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; ssize_t j , y ; MagickSizeType alpha_bits ; PixelPacket * q ; register ssize_t i , x ; unsigned char a0 , a1 ; size_t alpha , bits , code , alpha_code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) {  q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) ,   Min ( 4 , dds_info -> height - y ) , exception ) ;  if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; a0 = ( unsigned char ) ReadBlobByte ( image ) ; a1 = ( unsigned char ) ReadBlobByte ( image ) ; alpha_bits = ( MagickSizeType ) ReadBlobLSBLong ( image ) ; alpha_bits = alpha_bits | ( ( MagickSizeType ) ReadBlobLSBShort ( image ) << 32 ) ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickTrue ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( bits >> ( ( 4 * j + i ) * 2 ) ) & 0x3 ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; alpha_code = ( size_t ) ( alpha_bits >> ( 3 * ( 4 * j + i ) ) ) & 0x7 ; if ( alpha_code == 0 ) alpha = a0 ; else if ( alpha_code == 1 ) alpha = a1 ; else if ( a0 > a1 ) alpha = ( ( 8 - alpha_code ) * a0 + ( alpha_code - 1 ) * a1 ) / 7 ; else if ( alpha_code == 6 ) alpha = 0 ; else if ( alpha_code == 7 ) alpha = 255 ; else alpha = ( ( ( 6 - alpha_code ) * a0 + ( alpha_code - 1 ) * a1 ) / 5 ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) alpha ) ) ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } }  SkipDXTMipmaps ( image , dds_info , 16 ) ;  return MagickTrue ; }","q = QueueAuthenticPixels ( image , x , y , MagickMin ( 4 , dds_info -> width - x ) , MagickMin ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;",2305
204,"buggy line: }SkipDXTMipmaps ( image , dds_info , 16 ) ;return MagickTrue ;cwe id:CWE-20context: static MagickBooleanType ReadDXT5 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; ssize_t j , y ; MagickSizeType alpha_bits ; PixelPacket * q ; register ssize_t i , x ; unsigned char a0 , a1 ; size_t alpha , bits , code , alpha_code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) {  q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) ,   Min ( 4 , dds_info -> height - y ) , exception ) ;  if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; a0 = ( unsigned char ) ReadBlobByte ( image ) ; a1 = ( unsigned char ) ReadBlobByte ( image ) ; alpha_bits = ( MagickSizeType ) ReadBlobLSBLong ( image ) ; alpha_bits = alpha_bits | ( ( MagickSizeType ) ReadBlobLSBShort ( image ) << 32 ) ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickTrue ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( bits >> ( ( 4 * j + i ) * 2 ) ) & 0x3 ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; alpha_code = ( size_t ) ( alpha_bits >> ( 3 * ( 4 * j + i ) ) ) & 0x7 ; if ( alpha_code == 0 ) alpha = a0 ; else if ( alpha_code == 1 ) alpha = a1 ; else if ( a0 > a1 ) alpha = ( ( 8 - alpha_code ) * a0 + ( alpha_code - 1 ) * a1 ) / 7 ; else if ( alpha_code == 6 ) alpha = 0 ; else if ( alpha_code == 7 ) alpha = 255 ; else alpha = ( ( ( 6 - alpha_code ) * a0 + ( alpha_code - 1 ) * a1 ) / 5 ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) alpha ) ) ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } }  SkipDXTMipmaps ( image , dds_info , 16 ) ;  return MagickTrue ; }","return ( }SkipDXTMipmaps ( image , dds_info , 16 , exception ) ) ;",2305
205,"buggy line: id = idr_alloc ( & ids -> ipcs_idr , new ,  ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ;cwe id:CWE-362context: int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) { kuid_t euid ; kgid_t egid ; int id ; int next_id = ids -> next_id ; if ( size > IPCMNI ) size = IPCMNI ; if ( ids -> in_use >= size ) return - ENOSPC ; idr_preload ( GFP_KERNEL ) ; spin_lock_init ( & new -> lock ) ; new -> deleted = false ; rcu_read_lock ( ) ; spin_lock ( & new -> lock ) ;  id = idr_alloc ( & ids -> ipcs_idr , new ,  ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ; idr_preload_end ( ) ; if ( id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return id ; } ids -> in_use ++ ;  current_euid_egid ( & euid , & egid ) ;  new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; if ( next_id < 0 ) { new -> seq = ids -> seq ++ ; if ( ids -> seq > IPCID_SEQ_MAX ) ids -> seq = 0 ; } else { new -> seq = ipcid_to_seqx ( next_id ) ; ids -> next_id = - 1 ; } new -> id = ipc_buildid ( id , new -> seq ) ; return id ; }","current_euid_egid ( & euid , & egid ) ;new -> cuid = new -> uid = euid ;new -> gid = new -> cgid = egid ;id = idr_alloc ( & ids -> ipcs_idr , new , ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ;",2306
206,"buggy line: current_euid_egid ( & euid , & egid ) ;new -> cuid = new -> uid = euid ;new -> gid = new -> cgid = egid ;cwe id:CWE-362context: int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) { kuid_t euid ; kgid_t egid ; int id ; int next_id = ids -> next_id ; if ( size > IPCMNI ) size = IPCMNI ; if ( ids -> in_use >= size ) return - ENOSPC ; idr_preload ( GFP_KERNEL ) ; spin_lock_init ( & new -> lock ) ; new -> deleted = false ; rcu_read_lock ( ) ; spin_lock ( & new -> lock ) ;  id = idr_alloc ( & ids -> ipcs_idr , new ,  ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ; idr_preload_end ( ) ; if ( id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return id ; } ids -> in_use ++ ;  current_euid_egid ( & euid , & egid ) ;  new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; if ( next_id < 0 ) { new -> seq = ids -> seq ++ ; if ( ids -> seq > IPCID_SEQ_MAX ) ids -> seq = 0 ; } else { new -> seq = ipcid_to_seqx ( next_id ) ; ids -> next_id = - 1 ; } new -> id = ipc_buildid ( id , new -> seq ) ; return id ; }","
",2306
207,"buggy line: __be32 * pdata = ( __be32 * ) data ;if ( * pdata == ctx -> from ) {cwe id:CWE-129context: int snmp_helper ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { struct snmp_ctx * ctx = ( struct snmp_ctx * ) context ;  __be32 * pdata = ( __be32 * ) data ;  if ( * pdata == ctx -> from ) { pr_debug ( ""%s:<S2SV_blank>%pI4<S2SV_blank>to<S2SV_blank>%pI4\\n"" , __func__ , ( void * ) & ctx -> from , ( void * ) & ctx -> to ) ; if ( * ctx -> check ) fast_csum ( ctx , ( unsigned char * ) data - ctx -> begin ) ; * pdata = ctx -> to ; } return 1 ; }",__be32 * pdata ;if ( datalen != 4 ) return - EINVAL ;pdata = ( __be32 * ) data ;if ( * pdata == ctx -> from ) {,2307
208,"buggy line: if ( unlikely ( len == 0 ) ) {cwe id:CWE-119context: static void dma_rx ( struct b43_dmaring * ring , int * slot ) { const struct b43_dma_ops * ops = ring -> ops ; struct b43_dmadesc_generic * desc ; struct b43_dmadesc_meta * meta ; struct b43_rxhdr_fw4 * rxhdr ; struct sk_buff * skb ; u16 len ; int err ; dma_addr_t dmaaddr ; desc = ops -> idx2desc ( ring , * slot , & meta ) ; sync_descbuffer_for_cpu ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; skb = meta -> skb ; rxhdr = ( struct b43_rxhdr_fw4 * ) skb -> data ; len = le16_to_cpu ( rxhdr -> frame_len ) ; if ( len == 0 ) { int i = 0 ; do { udelay ( 2 ) ; barrier ( ) ; len = le16_to_cpu ( rxhdr -> frame_len ) ; } while ( len == 0 && i ++ < 5 ) ; if ( unlikely ( len == 0 ) ) { dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } } if ( unlikely ( b43_rx_buffer_is_poisoned ( ring , skb ) ) ) { b43dbg ( ring -> dev -> wl , ""DMA<S2SV_blank>RX:<S2SV_blank>Dropping<S2SV_blank>poisoned<S2SV_blank>buffer.\\n"" ) ; dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; }  if ( unlikely ( len > ring -> rx_buffersize ) ) {  int cnt = 0 ; s32 tmp = len ; while ( 1 ) { desc = ops -> idx2desc ( ring , * slot , & meta ) ; b43_poison_rx_buffer ( ring , meta -> skb ) ; sync_descbuffer_for_device ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; * slot = next_slot ( ring , * slot ) ; cnt ++ ; tmp -= ring -> rx_buffersize ; if ( tmp <= 0 ) break ; } b43err ( ring -> dev -> wl , ""DMA<S2SV_blank>RX<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>"" ""(len:<S2SV_blank>%u,<S2SV_blank>buffer:<S2SV_blank>%u,<S2SV_blank>nr-dropped:<S2SV_blank>%d)\\n"" , len , ring -> rx_buffersize , cnt ) ; goto drop ; } dmaaddr = meta -> dmaaddr ; err = setup_rx_descbuffer ( ring , desc , meta , GFP_ATOMIC ) ; if ( unlikely ( err ) ) { b43dbg ( ring -> dev -> wl , ""DMA<S2SV_blank>RX:<S2SV_blank>setup_rx_descbuffer()<S2SV_blank>failed\\n"" ) ; goto drop_recycle_buffer ; } unmap_descbuffer ( ring , dmaaddr , ring -> rx_buffersize , 0 ) ; skb_put ( skb , len + ring -> frameoffset ) ; skb_pull ( skb , ring -> frameoffset ) ; b43_rx ( ring -> dev , skb , rxhdr ) ; drop : return ; drop_recycle_buffer : b43_poison_rx_buffer ( ring , skb ) ; sync_descbuffer_for_device ( ring , dmaaddr , ring -> rx_buffersize ) ; }",if ( unlikely ( len + ring -> frameoffset == 0 ) ) {,2308
209,"buggy line: if ( unlikely ( len > ring -> rx_buffersize ) ) {int cnt = 0 ;cwe id:CWE-119context: static void dma_rx ( struct b43_dmaring * ring , int * slot ) { const struct b43_dma_ops * ops = ring -> ops ; struct b43_dmadesc_generic * desc ; struct b43_dmadesc_meta * meta ; struct b43_rxhdr_fw4 * rxhdr ; struct sk_buff * skb ; u16 len ; int err ; dma_addr_t dmaaddr ; desc = ops -> idx2desc ( ring , * slot , & meta ) ; sync_descbuffer_for_cpu ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; skb = meta -> skb ; rxhdr = ( struct b43_rxhdr_fw4 * ) skb -> data ; len = le16_to_cpu ( rxhdr -> frame_len ) ; if ( len == 0 ) { int i = 0 ; do { udelay ( 2 ) ; barrier ( ) ; len = le16_to_cpu ( rxhdr -> frame_len ) ; } while ( len == 0 && i ++ < 5 ) ; if ( unlikely ( len == 0 ) ) { dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } } if ( unlikely ( b43_rx_buffer_is_poisoned ( ring , skb ) ) ) { b43dbg ( ring -> dev -> wl , ""DMA<S2SV_blank>RX:<S2SV_blank>Dropping<S2SV_blank>poisoned<S2SV_blank>buffer.\\n"" ) ; dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; }  if ( unlikely ( len > ring -> rx_buffersize ) ) {  int cnt = 0 ; s32 tmp = len ; while ( 1 ) { desc = ops -> idx2desc ( ring , * slot , & meta ) ; b43_poison_rx_buffer ( ring , meta -> skb ) ; sync_descbuffer_for_device ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; * slot = next_slot ( ring , * slot ) ; cnt ++ ; tmp -= ring -> rx_buffersize ; if ( tmp <= 0 ) break ; } b43err ( ring -> dev -> wl , ""DMA<S2SV_blank>RX<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>"" ""(len:<S2SV_blank>%u,<S2SV_blank>buffer:<S2SV_blank>%u,<S2SV_blank>nr-dropped:<S2SV_blank>%d)\\n"" , len , ring -> rx_buffersize , cnt ) ; goto drop ; } dmaaddr = meta -> dmaaddr ; err = setup_rx_descbuffer ( ring , desc , meta , GFP_ATOMIC ) ; if ( unlikely ( err ) ) { b43dbg ( ring -> dev -> wl , ""DMA<S2SV_blank>RX:<S2SV_blank>setup_rx_descbuffer()<S2SV_blank>failed\\n"" ) ; goto drop_recycle_buffer ; } unmap_descbuffer ( ring , dmaaddr , ring -> rx_buffersize , 0 ) ; skb_put ( skb , len + ring -> frameoffset ) ; skb_pull ( skb , ring -> frameoffset ) ; b43_rx ( ring -> dev , skb , rxhdr ) ; drop : return ; drop_recycle_buffer : b43_poison_rx_buffer ( ring , skb ) ; sync_descbuffer_for_device ( ring , dmaaddr , ring -> rx_buffersize ) ; }",if ( unlikely ( len > ring -> rx_buffersize ) ) {int cnt = 0 ;,2308
210,"buggy line: set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ;cwe id:CWE-119context: int module_load ( YR_SCAN_CONTEXT * context , YR_OBJECT * module_object , void * module_data , size_t module_data_size ) { set_integer ( 1 , module_object , ""constants.one"" ) ; set_integer ( 2 , module_object , ""constants.two"" ) ; set_string ( ""foo"" , module_object , ""constants.foo"" ) ; set_string ( """" , module_object , ""constants.empty"" ) ; set_integer ( 1 , module_object , ""struct_array[1].i"" ) ; set_integer ( 0 , module_object , ""integer_array[%i]"" , 0 ) ; set_integer ( 1 , module_object , ""integer_array[%i]"" , 1 ) ; set_integer ( 2 , module_object , ""integer_array[%i]"" , 2 ) ;  set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;  set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ; set_string ( ""baz"" , module_object , ""string_array[%i]"" , 2 ) ; set_sized_string ( ""foo\\0bar"" , 7 , module_object , ""string_array[%i]"" , 3 ) ; set_string ( ""foo"" , module_object , ""string_dict[%s]"" , ""foo"" ) ; set_string ( ""bar"" , module_object , ""string_dict[\\""bar\\""]"" ) ; set_string ( ""foo"" , module_object , ""struct_dict[%s].s"" , ""foo"" ) ; set_integer ( 1 , module_object , ""struct_dict[%s].i"" , ""foo"" ) ; return ERROR_SUCCESS ; }","set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ;set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ;",2309
211,"buggy line: WARN_ON_ONCE ( ctx -> parent_ctx ) ;mutex_lock ( & ctx -> mutex ) ;list_for_each_entry ( sibling , & event -> sibling_list , group_entry ) perf_event_for_each_child ( sibling , func ) ;mutex_unlock ( & ctx -> mutex ) ;}cwe id:CWE-264context: static void perf_event_for_each ( struct perf_event * event , void ( * func ) ( struct perf_event * ) ) { struct perf_event_context * ctx = event -> ctx ; struct perf_event * sibling ;  WARN_ON_ONCE ( ctx -> parent_ctx ) ;  mutex_lock ( & ctx -> mutex ) ; event = event -> group_leader ; perf_event_for_each_child ( event , func ) ; list_for_each_entry ( sibling , & event -> sibling_list , group_entry ) perf_event_for_each_child ( sibling , func ) ;  mutex_unlock ( & ctx -> mutex ) ;  }",lockdep_assert_held ( & ctx -> mutex ) ;},2310
212,"buggy line: struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;else  pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;cwe id:CWE-125context: void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ;  struct va_format vaf ;  char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;  else  pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;  ret : va_end ( va ) ; }","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",2311
213,"buggy line: xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ;if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;cwe id:CWE-125context: static MagickBooleanType load_tile ( Image * image , Image * tile_image , XCFDocInfo * inDocInfo , XCFLayerInfo * inLayerInfo , size_t data_length , ExceptionInfo * exception ) { ssize_t y ; register ssize_t x ; register Quantum * q ; ssize_t count ; unsigned char * graydata ; XCFPixelInfo * xcfdata , * xcfodata ;  xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ;  if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; xcfodata = xcfdata ; graydata = ( unsigned char * ) xcfdata ; count = ReadBlob ( image , data_length , ( unsigned char * ) xcfdata ) ; if ( count != ( ssize_t ) data_length ) ThrowBinaryException ( CorruptImageError , ""NotEnoughPixelData"" , image -> filename ) ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { q = GetAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( inDocInfo -> image_type == GIMP_GRAY ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelGray ( tile_image , ScaleCharToQuantum ( * graydata ) , q ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; graydata ++ ; q += GetPixelChannels ( tile_image ) ; } } else if ( inDocInfo -> image_type == GIMP_RGB ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelRed ( tile_image , ScaleCharToQuantum ( xcfdata -> red ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( xcfdata -> green ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( xcfdata -> blue ) , q ) ; SetPixelAlpha ( tile_image , xcfdata -> alpha == 255U ? TransparentAlpha : ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; xcfdata ++ ; q += GetPixelChannels ( tile_image ) ; } } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; } xcfodata = ( XCFPixelInfo * ) RelinquishMagickMemory ( xcfodata ) ; return MagickTrue ; }","xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) , sizeof ( * xcfdata ) ) ;if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;",2312
214,"buggy line: struct sshbuf * b ;struct sshkey * key = NULL ;char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;u_char * pkblob , * sig , have_sig ;size_t blen , slen ;if ( ! authctxt -> valid ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;return 0 ;}cwe id:CWE-362context: static int userauth_pubkey ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct passwd * pw = authctxt -> pw ;  struct sshbuf * b ;  struct sshkey * key = NULL ;  char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;   u_char * pkblob , * sig , have_sig ;  size_t blen , slen ; int r , pktype ; int authenticated = 0 ; struct sshauthopt * authopts = NULL ;  if ( ! authctxt -> valid ) {  debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>parse<S2SV_blank>request<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { verbose ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( ""%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>"" ""(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)"" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { logit ( ""Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>client<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>"" ""signature<S2SV_blank>scheme"" ) ; goto done ; } if ( auth2_key_already_used ( authctxt , key ) ) { logit ( ""refusing<S2SV_blank>previously-used<S2SV_blank>%s<S2SV_blank>key"" , sshkey_type ( key ) ) ; goto done ; } if ( match_pattern_list ( pkalg , options . pubkey_key_types , 0 ) != 1 ) { logit ( ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>PubkeyAcceptedKeyTypes"" , __func__ , sshkey_ssh_name ( key ) ) ; goto done ; } key_s = format_key ( key ) ; if ( sshkey_is_cert ( key ) ) ca_s = format_key ( key -> cert -> signature_key ) ; if ( have_sig ) { debug3 ( ""%s:<S2SV_blank>have<S2SV_blank>%s<S2SV_blank>signature<S2SV_blank>for<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ; if ( ssh -> compat & SSH_OLD_SESSIONID ) { if ( ( r = sshbuf_put ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; } else { if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" ,  __func__ , ssh_err ( r ) ) ;  } xasprintf ( & userstyle , ""%s%s%s"" , authctxt -> user , authctxt -> style ? "":"" : """" , authctxt -> style ? authctxt -> style : """" ) ; if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , ""publickey"" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>build<S2SV_blank>packet<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif authenticated = 0 ; if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) { authenticated = 1 ; } sshbuf_free ( b ) ;  free ( sig ) ;  auth2_record_key ( authctxt , authenticated , key ) ; } else { debug ( ""%s:<S2SV_blank>test<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>pkblob<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_end ( ssh ) ) != 0 )  fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;  if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) { if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; authctxt -> postponed = 1 ; } } done : if ( authenticated == 1 && auth_activate_options ( ssh , authopts ) != 0 ) { debug ( ""%s:<S2SV_blank>key<S2SV_blank>options<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>existing"" , __func__ ) ; authenticated = 0 ; } debug2 ( ""%s:<S2SV_blank>authenticated<S2SV_blank>%d<S2SV_blank>pkalg<S2SV_blank>%s"" , __func__ , authenticated , pkalg ) ; sshauthopt_free ( authopts ) ; sshkey_free ( key ) ; free ( userstyle ) ; free ( pkalg ) ; free ( pkblob ) ; free ( key_s ) ; free ( ca_s ) ;  return authenticated ;  }","struct sshbuf * b = NULL ;struct sshkey * key = NULL ;char * pkalg = NULL , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;u_char * pkblob = NULL , * sig = NULL , have_sig ;size_t blen , slen ;}if ( ! authctxt -> valid || authctxt -> user == NULL ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;goto done ;",2313
215,"buggy line: if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" ,  __func__ , ssh_err ( r ) ) ;}cwe id:CWE-362context: static int userauth_pubkey ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct passwd * pw = authctxt -> pw ;  struct sshbuf * b ;  struct sshkey * key = NULL ;  char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;   u_char * pkblob , * sig , have_sig ;  size_t blen , slen ; int r , pktype ; int authenticated = 0 ; struct sshauthopt * authopts = NULL ;  if ( ! authctxt -> valid ) {  debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>parse<S2SV_blank>request<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { verbose ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( ""%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>"" ""(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)"" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { logit ( ""Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>client<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>"" ""signature<S2SV_blank>scheme"" ) ; goto done ; } if ( auth2_key_already_used ( authctxt , key ) ) { logit ( ""refusing<S2SV_blank>previously-used<S2SV_blank>%s<S2SV_blank>key"" , sshkey_type ( key ) ) ; goto done ; } if ( match_pattern_list ( pkalg , options . pubkey_key_types , 0 ) != 1 ) { logit ( ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>PubkeyAcceptedKeyTypes"" , __func__ , sshkey_ssh_name ( key ) ) ; goto done ; } key_s = format_key ( key ) ; if ( sshkey_is_cert ( key ) ) ca_s = format_key ( key -> cert -> signature_key ) ; if ( have_sig ) { debug3 ( ""%s:<S2SV_blank>have<S2SV_blank>%s<S2SV_blank>signature<S2SV_blank>for<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ; if ( ssh -> compat & SSH_OLD_SESSIONID ) { if ( ( r = sshbuf_put ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; } else { if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" ,  __func__ , ssh_err ( r ) ) ;  } xasprintf ( & userstyle , ""%s%s%s"" , authctxt -> user , authctxt -> style ? "":"" : """" , authctxt -> style ? authctxt -> style : """" ) ; if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , ""publickey"" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>build<S2SV_blank>packet<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif authenticated = 0 ; if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) { authenticated = 1 ; } sshbuf_free ( b ) ;  free ( sig ) ;  auth2_record_key ( authctxt , authenticated , key ) ; } else { debug ( ""%s:<S2SV_blank>test<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>pkblob<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_end ( ssh ) ) != 0 )  fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;  if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) { if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; authctxt -> postponed = 1 ; } } done : if ( authenticated == 1 && auth_activate_options ( ssh , authopts ) != 0 ) { debug ( ""%s:<S2SV_blank>key<S2SV_blank>options<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>existing"" , __func__ ) ; authenticated = 0 ; } debug2 ( ""%s:<S2SV_blank>authenticated<S2SV_blank>%d<S2SV_blank>pkalg<S2SV_blank>%s"" , __func__ , authenticated , pkalg ) ; sshauthopt_free ( authopts ) ; sshkey_free ( key ) ; free ( userstyle ) ; free ( pkalg ) ; free ( pkblob ) ; free ( key_s ) ; free ( ca_s ) ;  return authenticated ;  }","if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;}",2313
216,"buggy line: free ( sig ) ;auth2_record_key ( authctxt , authenticated , key ) ;if ( ( r = sshpkt_get_end ( ssh ) ) != 0 )  fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) {cwe id:CWE-362context: static int userauth_pubkey ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct passwd * pw = authctxt -> pw ;  struct sshbuf * b ;  struct sshkey * key = NULL ;  char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;   u_char * pkblob , * sig , have_sig ;  size_t blen , slen ; int r , pktype ; int authenticated = 0 ; struct sshauthopt * authopts = NULL ;  if ( ! authctxt -> valid ) {  debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>parse<S2SV_blank>request<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { verbose ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( ""%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>"" ""(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)"" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { logit ( ""Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>client<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>"" ""signature<S2SV_blank>scheme"" ) ; goto done ; } if ( auth2_key_already_used ( authctxt , key ) ) { logit ( ""refusing<S2SV_blank>previously-used<S2SV_blank>%s<S2SV_blank>key"" , sshkey_type ( key ) ) ; goto done ; } if ( match_pattern_list ( pkalg , options . pubkey_key_types , 0 ) != 1 ) { logit ( ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>PubkeyAcceptedKeyTypes"" , __func__ , sshkey_ssh_name ( key ) ) ; goto done ; } key_s = format_key ( key ) ; if ( sshkey_is_cert ( key ) ) ca_s = format_key ( key -> cert -> signature_key ) ; if ( have_sig ) { debug3 ( ""%s:<S2SV_blank>have<S2SV_blank>%s<S2SV_blank>signature<S2SV_blank>for<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ; if ( ssh -> compat & SSH_OLD_SESSIONID ) { if ( ( r = sshbuf_put ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; } else { if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" ,  __func__ , ssh_err ( r ) ) ;  } xasprintf ( & userstyle , ""%s%s%s"" , authctxt -> user , authctxt -> style ? "":"" : """" , authctxt -> style ? authctxt -> style : """" ) ; if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , ""publickey"" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>build<S2SV_blank>packet<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif authenticated = 0 ; if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) { authenticated = 1 ; } sshbuf_free ( b ) ;  free ( sig ) ;  auth2_record_key ( authctxt , authenticated , key ) ; } else { debug ( ""%s:<S2SV_blank>test<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>pkblob<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_end ( ssh ) ) != 0 )  fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;  if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) { if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; authctxt -> postponed = 1 ; } } done : if ( authenticated == 1 && auth_activate_options ( ssh , authopts ) != 0 ) { debug ( ""%s:<S2SV_blank>key<S2SV_blank>options<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>existing"" , __func__ ) ; authenticated = 0 ; } debug2 ( ""%s:<S2SV_blank>authenticated<S2SV_blank>%d<S2SV_blank>pkalg<S2SV_blank>%s"" , __func__ , authenticated , pkalg ) ; sshauthopt_free ( authopts ) ; sshkey_free ( key ) ; free ( userstyle ) ; free ( pkalg ) ; free ( pkblob ) ; free ( key_s ) ; free ( ca_s ) ;  return authenticated ;  }","auth2_record_key ( authctxt , authenticated , key ) ;if ( ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;if ( ! authctxt -> valid || authctxt -> user == NULL ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;goto done ;}if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) {",2313
217,"buggy line: return authenticated ;}cwe id:CWE-362context: static int userauth_pubkey ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct passwd * pw = authctxt -> pw ;  struct sshbuf * b ;  struct sshkey * key = NULL ;  char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;   u_char * pkblob , * sig , have_sig ;  size_t blen , slen ; int r , pktype ; int authenticated = 0 ; struct sshauthopt * authopts = NULL ;  if ( ! authctxt -> valid ) {  debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>parse<S2SV_blank>request<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { verbose ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( ""%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>"" ""(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)"" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { logit ( ""Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>client<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>"" ""signature<S2SV_blank>scheme"" ) ; goto done ; } if ( auth2_key_already_used ( authctxt , key ) ) { logit ( ""refusing<S2SV_blank>previously-used<S2SV_blank>%s<S2SV_blank>key"" , sshkey_type ( key ) ) ; goto done ; } if ( match_pattern_list ( pkalg , options . pubkey_key_types , 0 ) != 1 ) { logit ( ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>PubkeyAcceptedKeyTypes"" , __func__ , sshkey_ssh_name ( key ) ) ; goto done ; } key_s = format_key ( key ) ; if ( sshkey_is_cert ( key ) ) ca_s = format_key ( key -> cert -> signature_key ) ; if ( have_sig ) { debug3 ( ""%s:<S2SV_blank>have<S2SV_blank>%s<S2SV_blank>signature<S2SV_blank>for<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ; if ( ssh -> compat & SSH_OLD_SESSIONID ) { if ( ( r = sshbuf_put ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; } else { if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" ,  __func__ , ssh_err ( r ) ) ;  } xasprintf ( & userstyle , ""%s%s%s"" , authctxt -> user , authctxt -> style ? "":"" : """" , authctxt -> style ? authctxt -> style : """" ) ; if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , ""publickey"" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>build<S2SV_blank>packet<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif authenticated = 0 ; if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) { authenticated = 1 ; } sshbuf_free ( b ) ;  free ( sig ) ;  auth2_record_key ( authctxt , authenticated , key ) ; } else { debug ( ""%s:<S2SV_blank>test<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>pkblob<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_end ( ssh ) ) != 0 )  fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;  if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) { if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; authctxt -> postponed = 1 ; } } done : if ( authenticated == 1 && auth_activate_options ( ssh , authopts ) != 0 ) { debug ( ""%s:<S2SV_blank>key<S2SV_blank>options<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>existing"" , __func__ ) ; authenticated = 0 ; } debug2 ( ""%s:<S2SV_blank>authenticated<S2SV_blank>%d<S2SV_blank>pkalg<S2SV_blank>%s"" , __func__ , authenticated , pkalg ) ; sshauthopt_free ( authopts ) ; sshkey_free ( key ) ; free ( userstyle ) ; free ( pkalg ) ; free ( pkblob ) ; free ( key_s ) ; free ( ca_s ) ;  return authenticated ;  }",free ( sig ) ;return authenticated ;},2313
218,"buggy line: NameContext sNC ;memset ( & sNC , 0 , sizeof ( sNC ) ) ;sNC . pParse = & sParse ;sqlite3SelectPrep ( & sParse , pTab -> pSelect , & sNC ) ;cwe id:CWE-674context: static void renameTableFunc ( sqlite3_context * context , int NotUsed , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; const char * zDb = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zInput = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zOld = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; const char * zNew = ( const char * ) sqlite3_value_text ( argv [ 5 ] ) ; int bTemp = sqlite3_value_int ( argv [ 6 ] ) ; UNUSED_PARAMETER ( NotUsed ) ; if ( zInput && zOld && zNew ) { Parse sParse ; int rc ; int bQuote = 1 ; RenameCtx sCtx ; Walker sWalker ; # ifndef SQLITE_OMIT_AUTHORIZATION sqlite3_xauth xAuth = db -> xAuth ; db -> xAuth = 0 ; # endif sqlite3BtreeEnterAll ( db ) ; memset ( & sCtx , 0 , sizeof ( RenameCtx ) ) ; sCtx . pTab = sqlite3FindTable ( db , zOld , zDb ) ; memset ( & sWalker , 0 , sizeof ( Walker ) ) ; sWalker . pParse = & sParse ; sWalker . xExprCallback = renameTableExprCb ; sWalker . xSelectCallback = renameTableSelectCb ; sWalker . u . pRename = & sCtx ; rc = renameParseSql ( & sParse , zDb , 1 , db , zInput , bTemp ) ; if ( rc == SQLITE_OK ) { int isLegacy = ( db -> flags & SQLITE_LegacyAlter ) ; if ( sParse . pNewTable ) { Table * pTab = sParse . pNewTable ; if ( pTab -> pSelect ) { if ( isLegacy == 0 ) {  NameContext sNC ;  memset ( & sNC , 0 , sizeof ( sNC ) ) ;  sNC . pParse = & sParse ;  sqlite3SelectPrep ( & sParse , pTab -> pSelect , & sNC ) ; if ( sParse . nErr ) rc = sParse . rc ; sqlite3WalkSelect ( & sWalker , pTab -> pSelect ) ; } } else { # ifndef SQLITE_OMIT_FOREIGN_KEY if ( isLegacy == 0 || ( db -> flags & SQLITE_ForeignKeys ) ) { FKey * pFKey ; for ( pFKey = pTab -> pFKey ; pFKey ; pFKey = pFKey -> pNextFrom ) { if ( sqlite3_stricmp ( pFKey -> zTo , zOld ) == 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) pFKey -> zTo ) ; } } } # endif if ( sqlite3_stricmp ( zOld , pTab -> zName ) == 0 ) { sCtx . pTab = pTab ; if ( isLegacy == 0 ) { sqlite3WalkExprList ( & sWalker , pTab -> pCheck ) ; } renameTokenFind ( & sParse , & sCtx , pTab -> zName ) ; } } } else if ( sParse . pNewIndex ) { renameTokenFind ( & sParse , & sCtx , sParse . pNewIndex -> zName ) ; if ( isLegacy == 0 ) { sqlite3WalkExpr ( & sWalker , sParse . pNewIndex -> pPartIdxWhere ) ; } } # ifndef SQLITE_OMIT_TRIGGER else { Trigger * pTrigger = sParse . pNewTrigger ; TriggerStep * pStep ; if ( 0 == sqlite3_stricmp ( sParse . pNewTrigger -> table , zOld ) && sCtx . pTab -> pSchema == pTrigger -> pTabSchema ) { renameTokenFind ( & sParse , & sCtx , sParse . pNewTrigger -> table ) ; } if ( isLegacy == 0 ) { rc = renameResolveTrigger ( & sParse , bTemp ? 0 : zDb ) ; if ( rc == SQLITE_OK ) { renameWalkTrigger ( & sWalker , pTrigger ) ; for ( pStep = pTrigger -> step_list ; pStep ; pStep = pStep -> pNext ) { if ( pStep -> zTarget && 0 == sqlite3_stricmp ( pStep -> zTarget , zOld ) ) { renameTokenFind ( & sParse , & sCtx , pStep -> zTarget ) ; } } } } } # endif } if ( rc == SQLITE_OK ) { rc = renameEditSql ( context , & sCtx , zInput , zNew , bQuote ) ; } if ( rc != SQLITE_OK ) { if ( sParse . zErrMsg ) { renameColumnParseError ( context , 0 , argv [ 1 ] , argv [ 2 ] , & sParse ) ; } else { sqlite3_result_error_code ( context , rc ) ; } } renameParseCleanup ( & sParse ) ; renameTokenFree ( db , sCtx . pList ) ; sqlite3BtreeLeaveAll ( db ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = xAuth ; # endif } return ; }","Select * pSelect = pTab -> pSelect ;NameContext sNC ;memset ( & sNC , 0 , sizeof ( sNC ) ) ;sNC . pParse = & sParse ;assert ( pSelect -> selFlags & SF_View ) ;pSelect -> selFlags &= ~ SF_View ;sqlite3SelectPrep ( & sParse , pTab -> pSelect , & sNC ) ;",2314
219,"buggy line: args -> rmtblkcnt2 = args -> rmtblkcnt ;args -> rmtblkno = 0 ;args -> rmtblkcnt = 0 ;}cwe id:CWE-19context: STATIC int xfs_attr_node_addname ( xfs_da_args_t * args ) { xfs_da_state_t * state ; xfs_da_state_blk_t * blk ; xfs_inode_t * dp ; xfs_mount_t * mp ; int committed , retval , error ; trace_xfs_attr_node_addname ( args ) ; dp = args -> dp ; mp = dp -> i_mount ; restart : state = xfs_da_state_alloc ( ) ; state -> args = args ; state -> mp = mp ; state -> blocksize = state -> mp -> m_sb . sb_blocksize ; state -> node_ents = state -> mp -> m_attr_node_ents ; error = xfs_da3_node_lookup_int ( state , & retval ) ; if ( error ) goto out ; blk = & state -> path . blk [ state -> path . active - 1 ] ; ASSERT ( blk -> magic == XFS_ATTR_LEAF_MAGIC ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { goto out ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) goto out ; trace_xfs_attr_node_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ;  args -> rmtblkno = 0 ;   args -> rmtblkcnt = 0 ;  } retval = xfs_attr3_leaf_add ( blk -> bp , state -> args ) ; if ( retval == ENOSPC ) { if ( state -> path . active == 1 ) { xfs_da_state_free ( state ) ; state = NULL ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; goto restart ; } xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_da3_split ( state ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } else { xfs_da3_fixhashpath ( state , & state -> path ) ; } xfs_da_state_free ( state ) ; state = NULL ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) goto out ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ;  args -> rmtblkcnt = args -> rmtblkcnt2 ;  if ( args -> rmtblkno ) { error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } args -> flags |= XFS_ATTR_INCOMPLETE ; state = xfs_da_state_alloc ( ) ; state -> args = args ; state -> mp = mp ; state -> blocksize = state -> mp -> m_sb . sb_blocksize ; state -> node_ents = state -> mp -> m_attr_node_ents ; state -> inleaf = 0 ; error = xfs_da3_node_lookup_int ( state , & retval ) ; if ( error ) goto out ; blk = & state -> path . blk [ state -> path . active - 1 ] ; ASSERT ( blk -> magic == XFS_ATTR_LEAF_MAGIC ) ; error = xfs_attr3_leaf_remove ( blk -> bp , args ) ; xfs_da3_fixhashpath ( state , & state -> path ) ; if ( retval && ( state -> path . active > 1 ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_da3_join ( state ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; if ( error ) goto out ; } retval = error = 0 ; out : if ( state ) xfs_da_state_free ( state ) ; if ( error ) return ( error ) ; return ( retval ) ; }",args -> rmtvaluelen2 = args -> rmtvaluelen ;args -> rmtblkcnt2 = args -> rmtblkcnt = 0 ;args -> rmtvaluelen ;args -> rmtblkno = 0 ;args -> rmtblkcnt = 0 ;},2315
220,"buggy line: args -> rmtblkcnt = args -> rmtblkcnt2 ;if ( args -> rmtblkno ) {cwe id:CWE-19context: STATIC int xfs_attr_node_addname ( xfs_da_args_t * args ) { xfs_da_state_t * state ; xfs_da_state_blk_t * blk ; xfs_inode_t * dp ; xfs_mount_t * mp ; int committed , retval , error ; trace_xfs_attr_node_addname ( args ) ; dp = args -> dp ; mp = dp -> i_mount ; restart : state = xfs_da_state_alloc ( ) ; state -> args = args ; state -> mp = mp ; state -> blocksize = state -> mp -> m_sb . sb_blocksize ; state -> node_ents = state -> mp -> m_attr_node_ents ; error = xfs_da3_node_lookup_int ( state , & retval ) ; if ( error ) goto out ; blk = & state -> path . blk [ state -> path . active - 1 ] ; ASSERT ( blk -> magic == XFS_ATTR_LEAF_MAGIC ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { goto out ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) goto out ; trace_xfs_attr_node_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ;  args -> rmtblkno = 0 ;   args -> rmtblkcnt = 0 ;  } retval = xfs_attr3_leaf_add ( blk -> bp , state -> args ) ; if ( retval == ENOSPC ) { if ( state -> path . active == 1 ) { xfs_da_state_free ( state ) ; state = NULL ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; goto restart ; } xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_da3_split ( state ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } else { xfs_da3_fixhashpath ( state , & state -> path ) ; } xfs_da_state_free ( state ) ; state = NULL ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) goto out ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ;  args -> rmtblkcnt = args -> rmtblkcnt2 ;  if ( args -> rmtblkno ) { error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } args -> flags |= XFS_ATTR_INCOMPLETE ; state = xfs_da_state_alloc ( ) ; state -> args = args ; state -> mp = mp ; state -> blocksize = state -> mp -> m_sb . sb_blocksize ; state -> node_ents = state -> mp -> m_attr_node_ents ; state -> inleaf = 0 ; error = xfs_da3_node_lookup_int ( state , & retval ) ; if ( error ) goto out ; blk = & state -> path . blk [ state -> path . active - 1 ] ; ASSERT ( blk -> magic == XFS_ATTR_LEAF_MAGIC ) ; error = xfs_attr3_leaf_remove ( blk -> bp , args ) ; xfs_da3_fixhashpath ( state , & state -> path ) ; if ( retval && ( state -> path . active > 1 ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_da3_join ( state ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; if ( error ) goto out ; } retval = error = 0 ; out : if ( state ) xfs_da_state_free ( state ) ; if ( error ) return ( error ) ; return ( retval ) ; }",args -> rmtblkcnt = args -> rmtblkcnt2 ;args -> rmtvaluelen = args -> rmtvaluelen2 ;if ( args -> rmtblkno ) {,2315
221,"buggy line: int i , j ;p = buff1 ;i = ctm -> length ;str = ( char * ) ctm -> data ;if ( ( i < 11 ) || ( i > 17 ) )  return 0 ;}if ( i < 13 )  return 0 ;}if ( ( * str == \'Z\' ) || ( * str == \'-\' ) || ( * str == \'+\' ) ) {* ( p ++ ) = * ( str ++ ) ;* ( p ++ ) = * ( str ++ ) ;if ( * str == \'.\' ) {while ( ( * str >= \'0\' ) && ( * str <= \'9\' ) )  str ++ ;if ( * str == \'Z\' )  offset = 0 ;else {if ( ( * str != \'+\' ) && ( * str != \'-\' ) )  return 0 ;cwe id:CWE-119context: int X509_cmp_time ( const ASN1_TIME * ctm , time_t * cmp_time ) { char * str ; ASN1_TIME atm ; long offset ; char buff1 [ 24 ] , buff2 [ 24 ] , * p ;  int i , j ;  p = buff1 ;  i = ctm -> length ;  str = ( char * ) ctm -> data ; if ( ctm -> type == V_ASN1_UTCTIME ) {  if ( ( i < 11 ) || ( i > 17 ) )  return 0 ; memcpy ( p , str , 10 ) ; p += 10 ; str += 10 ;  } else {   if ( i < 13 )  return 0 ; memcpy ( p , str , 12 ) ; p += 12 ; str += 12 ;  }  if ( ( * str == 'Z' ) || ( * str == '-' ) || ( * str == '+' ) ) { * ( p ++ ) = '0' ; * ( p ++ ) = '0' ; } else {  * ( p ++ ) = * ( str ++ ) ;  * ( p ++ ) = * ( str ++ ) ; if ( * str == '.' ) { str ++ ;  while ( ( * str >= '0' ) && ( * str <= '9' ) )  str ++ ; } } * ( p ++ ) = 'Z' ; * ( p ++ ) = '\\0' ;  if ( * str == 'Z' )  offset = 0 ;  else {   if ( ( * str != '+' ) && ( * str != '-' ) )  return 0 ; offset = ( ( str [ 1 ] - '0' ) * 10 + ( str [ 2 ] - '0' ) ) * 60 ; offset += ( str [ 3 ] - '0' ) * 10 + ( str [ 4 ] - '0' ) ; if ( * str == '-' ) offset = - offset ; } atm . type = ctm -> type ; atm . flags = 0 ; atm . length = sizeof ( buff2 ) ; atm . data = ( unsigned char * ) buff2 ; if ( X509_time_adj ( & atm , offset * 60 , cmp_time ) == NULL ) return 0 ; if ( ctm -> type == V_ASN1_UTCTIME ) { i = ( buff1 [ 0 ] - '0' ) * 10 + ( buff1 [ 1 ] - '0' ) ; if ( i < 50 ) i += 100 ; j = ( buff2 [ 0 ] - '0' ) * 10 + ( buff2 [ 1 ] - '0' ) ; if ( j < 50 ) j += 100 ; if ( i < j ) return - 1 ; if ( i > j ) return 1 ; } i = strcmp ( buff1 , buff2 ) ; if ( i == 0 ) return - 1 ; else return i ; }","int i , j , remaining ;p = buff1 ;remaining = ctm -> length ;str = ( char * ) ctm -> data ;int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ;int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ;if ( remaining < min_length || remaining > max_length ) return 0 ;remaining -= 10 ;}int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ;int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ;if ( remaining < min_length || remaining > max_length ) return 0 ;remaining -= 12 ;}if ( ( * str == \'Z\' ) || ( * str == \'-\' ) || ( * str == \'+\' ) ) {if ( remaining < 2 ) return 0 ;* ( p ++ ) = * ( str ++ ) ;* ( p ++ ) = * ( str ++ ) ;remaining -= 2 ;if ( remaining && * str == \'.\' ) {remaining -- ;for ( i = 0 ;i < 3 && remaining ;i ++ , str ++ , remaining -- ) {if ( * str < \'0\' || * str > \'9\' ) break ;}if ( ! remaining ) return 0 ;if ( * str == \'Z\' ) {if ( remaining != 1 ) return 0 ;offset = 0 ;}else {if ( ( * str != \'+\' ) && ( * str != \'-\' ) ) return 0 ;if ( remaining != 5 ) return 0 ;if ( str [ 1 ] < \'0\' || str [ 1 ] > \'9\' || str [ 2 ] < \'0\' || str [ 2 ] > \'9\' || str [ 3 ] < \'0\' || str [ 3 ] > \'9\' || str [ 4 ] < \'0\' || str [ 4 ] > \'9\' ) return 0 ;",2316
222,"buggy line: cwe id:CWE-787context: BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ;  PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data )   nsc_rle_decompress_data ( context ) ;  PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data )  PROFILER_ENTER ( context -> priv -> prof_nsc_decode )   context -> decode ( context ) ;   PROFILER_EXIT ( context -> priv -> prof_nsc_decode )  if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }",{BOOL rc ;,2317
223,"buggy line: PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data )   nsc_rle_decompress_data ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data )  PROFILER_ENTER ( context -> priv -> prof_nsc_decode )   context -> decode ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_decode )  if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ;cwe id:CWE-787context: BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ;  PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data )   nsc_rle_decompress_data ( context ) ;  PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data )  PROFILER_ENTER ( context -> priv -> prof_nsc_decode )   context -> decode ( context ) ;   PROFILER_EXIT ( context -> priv -> prof_nsc_decode )  if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }","PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) rc = nsc_rle_decompress_data ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ;}{BOOL rc ;PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) rc = context -> decode ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) if ( ! rc ) return FALSE ;}if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ;",2317
224,"buggy line: if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) )  break ;cwe id:CWE-400context: static void Sp_match ( js_State * J ) { js_Regexp * re ; const char * text ; int len ; const char * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; if ( ! ( re -> flags & JS_REGEXP_G ) ) { js_RegExp_prototype_exec ( J , re , text ) ; return ; } re -> last = 0 ; js_newarray ( J ) ; len = 0 ; a = text ; e = text + strlen ( text ) ; while ( a <= e ) {  if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) )  break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; js_pushlstring ( J , b , c - b ) ; js_setindex ( J , - 2 , len ++ ) ; a = c ; if ( c - b == 0 ) ++ a ; } if ( len == 0 ) { js_pop ( J , 1 ) ; js_pushnull ( J ) ; } }","if ( js_doregexec ( J , re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) break ;",2318
225,"buggy line: int ret ;assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;ret = hns_nic_net_xmit_hw ( ndev , skb ,  & tx_ring_data ( priv , skb -> queue_mapping ) ) ;if ( ret == NETDEV_TX_OK ) {netif_trans_update ( ndev ) ;ndev -> stats . tx_bytes += skb -> len ;ndev -> stats . tx_packets ++ ;}return ( netdev_tx_t ) ret ;cwe id:CWE-416context: static netdev_tx_t hns_nic_net_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ;  int ret ;  assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;  ret = hns_nic_net_xmit_hw ( ndev , skb ,  & tx_ring_data ( priv , skb -> queue_mapping ) ) ;  if ( ret == NETDEV_TX_OK ) {  netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; } return ( netdev_tx_t ) ret ; }","assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;return hns_nic_net_xmit_hw ( ndev , skb , & tx_ring_data ( priv , skb -> queue_mapping ) ) ;",2319
226,"buggy line: void HTML_put_string ( HTStructured * me , const char * s )  {# ifdef USE_PRETTYSRC char * translated_string = NULL ;cwe id:CWE-416context: void HTML_put_string ( HTStructured * me , const char * s )  {  # ifdef USE_PRETTYSRC char * translated_string = NULL ; # endif if ( s == NULL || ( LYMapsOnly && me -> sp [ 0 ] . tag_number != HTML_OBJECT ) ) return ; # ifdef USE_PRETTYSRC if ( psrc_convert_string ) { StrAllocCopy ( translated_string , s ) ; TRANSLATE_AND_UNESCAPE_ENTITIES ( & translated_string , TRUE , FALSE ) ; s = ( const char * ) translated_string ; } # endif switch ( me -> sp [ 0 ] . tag_number ) { case HTML_COMMENT : break ; case HTML_TITLE :  HTChunkPuts ( & me -> title , s ) ;  break ; case HTML_STYLE :  HTChunkPuts ( & me -> style_block , s ) ;  break ; case HTML_SCRIPT :  HTChunkPuts ( & me -> script , s ) ;  break ; case HTML_PRE : case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : HText_appendText ( me -> text , s ) ; break ; case HTML_OBJECT :  HTChunkPuts ( & me -> object , s ) ;  break ; case HTML_TEXTAREA :  HTChunkPuts ( & me -> textarea , s ) ;  break ; case HTML_SELECT : case HTML_OPTION :  HTChunkPuts ( & me -> option , s ) ;  break ; case HTML_MATH :  HTChunkPuts ( & me -> math , s ) ;  break ; default : if ( ! me -> sp -> style -> freeFormat ) { # ifdef USE_PRETTYSRC if ( psrc_view ) { for ( ; * s ; ++ s ) HTML_put_character ( me , * s ) ; } else # endif HText_appendText ( me -> text , s ) ; break ; } else { const char * p = s ; char c ; if ( me -> style_change ) { for ( ; * p && ( ( * p == '\\n' ) || ( * p == '\\r' ) || ( * p == '<S2SV_blank>' ) || ( * p == '\\t' ) ) ; p ++ ) ; if ( ! * p ) break ; UPDATE_STYLE ; } for ( ; * p ; p ++ ) { if ( * p == 13 && p [ 1 ] != 10 ) { c = '\\n' ; } else { c = * p ; } if ( me -> style_change ) { if ( ( c == '\\n' ) || ( c == '<S2SV_blank>' ) || ( c == '\\t' ) ) continue ; UPDATE_STYLE ; } if ( c == '\\n' ) { if ( ! FIX_JAPANESE_SPACES ) { if ( me -> in_word ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; me -> in_word = NO ; } } } else if ( c == '<S2SV_blank>' || c == '\\t' ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' ) { } else { HText_appendCharacter ( me -> text , c ) ; me -> in_word = YES ; } if ( c == '\\n' || c == '\\t' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' && HText_getLastChar ( me -> text ) == '<S2SV_blank>' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else { HText_setLastChar ( me -> text , c ) ; } } } }  # ifdef USE_PRETTYSRC  if ( psrc_convert_string ) { psrc_convert_string = FALSE ; FREE ( translated_string ) ; } # endif }","void HTML_put_string ( HTStructured * me , const char * s ) {HTChunk * target = NULL ;# ifdef USE_PRETTYSRC char * translated_string = NULL ;",2320
227,"buggy line: case HTML_TITLE :  HTChunkPuts ( & me -> title , s ) ;break ;case HTML_STYLE :  HTChunkPuts ( & me -> style_block , s ) ;break ;case HTML_SCRIPT :  HTChunkPuts ( & me -> script , s ) ;break ;case HTML_OBJECT :  HTChunkPuts ( & me -> object , s ) ;break ;case HTML_TEXTAREA :  HTChunkPuts ( & me -> textarea , s ) ;break ;case HTML_SELECT : case HTML_OPTION :  HTChunkPuts ( & me -> option , s ) ;break ;case HTML_MATH :  HTChunkPuts ( & me -> math , s ) ;break ;cwe id:CWE-416context: void HTML_put_string ( HTStructured * me , const char * s )  {  # ifdef USE_PRETTYSRC char * translated_string = NULL ; # endif if ( s == NULL || ( LYMapsOnly && me -> sp [ 0 ] . tag_number != HTML_OBJECT ) ) return ; # ifdef USE_PRETTYSRC if ( psrc_convert_string ) { StrAllocCopy ( translated_string , s ) ; TRANSLATE_AND_UNESCAPE_ENTITIES ( & translated_string , TRUE , FALSE ) ; s = ( const char * ) translated_string ; } # endif switch ( me -> sp [ 0 ] . tag_number ) { case HTML_COMMENT : break ; case HTML_TITLE :  HTChunkPuts ( & me -> title , s ) ;  break ; case HTML_STYLE :  HTChunkPuts ( & me -> style_block , s ) ;  break ; case HTML_SCRIPT :  HTChunkPuts ( & me -> script , s ) ;  break ; case HTML_PRE : case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : HText_appendText ( me -> text , s ) ; break ; case HTML_OBJECT :  HTChunkPuts ( & me -> object , s ) ;  break ; case HTML_TEXTAREA :  HTChunkPuts ( & me -> textarea , s ) ;  break ; case HTML_SELECT : case HTML_OPTION :  HTChunkPuts ( & me -> option , s ) ;  break ; case HTML_MATH :  HTChunkPuts ( & me -> math , s ) ;  break ; default : if ( ! me -> sp -> style -> freeFormat ) { # ifdef USE_PRETTYSRC if ( psrc_view ) { for ( ; * s ; ++ s ) HTML_put_character ( me , * s ) ; } else # endif HText_appendText ( me -> text , s ) ; break ; } else { const char * p = s ; char c ; if ( me -> style_change ) { for ( ; * p && ( ( * p == '\\n' ) || ( * p == '\\r' ) || ( * p == '<S2SV_blank>' ) || ( * p == '\\t' ) ) ; p ++ ) ; if ( ! * p ) break ; UPDATE_STYLE ; } for ( ; * p ; p ++ ) { if ( * p == 13 && p [ 1 ] != 10 ) { c = '\\n' ; } else { c = * p ; } if ( me -> style_change ) { if ( ( c == '\\n' ) || ( c == '<S2SV_blank>' ) || ( c == '\\t' ) ) continue ; UPDATE_STYLE ; } if ( c == '\\n' ) { if ( ! FIX_JAPANESE_SPACES ) { if ( me -> in_word ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; me -> in_word = NO ; } } } else if ( c == '<S2SV_blank>' || c == '\\t' ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' ) { } else { HText_appendCharacter ( me -> text , c ) ; me -> in_word = YES ; } if ( c == '\\n' || c == '\\t' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' && HText_getLastChar ( me -> text ) == '<S2SV_blank>' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else { HText_setLastChar ( me -> text , c ) ; } } } }  # ifdef USE_PRETTYSRC  if ( psrc_convert_string ) { psrc_convert_string = FALSE ; FREE ( translated_string ) ; } # endif }","case HTML_TITLE : target = & me -> title , s ) ;break ;case HTML_STYLE : target = & me -> style_block , s ) ;break ;case HTML_SCRIPT : target = & me -> script , s ) ;break ;case HTML_OBJECT : target = & me -> object , s ) ;break ;case HTML_TEXTAREA : target = & me -> textarea , s ) ;break ;case HTML_SELECT : case HTML_OPTION : target = & me -> option , s ) ;break ;case HTML_MATH : target = & me -> math , s ) ;break ;",2320
228,"buggy line: cwe id:CWE-416context: void HTML_put_string ( HTStructured * me , const char * s )  {  # ifdef USE_PRETTYSRC char * translated_string = NULL ; # endif if ( s == NULL || ( LYMapsOnly && me -> sp [ 0 ] . tag_number != HTML_OBJECT ) ) return ; # ifdef USE_PRETTYSRC if ( psrc_convert_string ) { StrAllocCopy ( translated_string , s ) ; TRANSLATE_AND_UNESCAPE_ENTITIES ( & translated_string , TRUE , FALSE ) ; s = ( const char * ) translated_string ; } # endif switch ( me -> sp [ 0 ] . tag_number ) { case HTML_COMMENT : break ; case HTML_TITLE :  HTChunkPuts ( & me -> title , s ) ;  break ; case HTML_STYLE :  HTChunkPuts ( & me -> style_block , s ) ;  break ; case HTML_SCRIPT :  HTChunkPuts ( & me -> script , s ) ;  break ; case HTML_PRE : case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : HText_appendText ( me -> text , s ) ; break ; case HTML_OBJECT :  HTChunkPuts ( & me -> object , s ) ;  break ; case HTML_TEXTAREA :  HTChunkPuts ( & me -> textarea , s ) ;  break ; case HTML_SELECT : case HTML_OPTION :  HTChunkPuts ( & me -> option , s ) ;  break ; case HTML_MATH :  HTChunkPuts ( & me -> math , s ) ;  break ; default : if ( ! me -> sp -> style -> freeFormat ) { # ifdef USE_PRETTYSRC if ( psrc_view ) { for ( ; * s ; ++ s ) HTML_put_character ( me , * s ) ; } else # endif HText_appendText ( me -> text , s ) ; break ; } else { const char * p = s ; char c ; if ( me -> style_change ) { for ( ; * p && ( ( * p == '\\n' ) || ( * p == '\\r' ) || ( * p == '<S2SV_blank>' ) || ( * p == '\\t' ) ) ; p ++ ) ; if ( ! * p ) break ; UPDATE_STYLE ; } for ( ; * p ; p ++ ) { if ( * p == 13 && p [ 1 ] != 10 ) { c = '\\n' ; } else { c = * p ; } if ( me -> style_change ) { if ( ( c == '\\n' ) || ( c == '<S2SV_blank>' ) || ( c == '\\t' ) ) continue ; UPDATE_STYLE ; } if ( c == '\\n' ) { if ( ! FIX_JAPANESE_SPACES ) { if ( me -> in_word ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; me -> in_word = NO ; } } } else if ( c == '<S2SV_blank>' || c == '\\t' ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' ) { } else { HText_appendCharacter ( me -> text , c ) ; me -> in_word = YES ; } if ( c == '\\n' || c == '\\t' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' && HText_getLastChar ( me -> text ) == '<S2SV_blank>' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else { HText_setLastChar ( me -> text , c ) ; } } } }  # ifdef USE_PRETTYSRC  if ( psrc_convert_string ) { psrc_convert_string = FALSE ; FREE ( translated_string ) ; } # endif }","if ( target != NULL ) {if ( target -> data == s ) {CTRACE ( ( tfp , ""BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\\\'\\\}else {HTChunkPuts ( target , s ) ;}}",2320
229,"buggy line: # ifdef USE_PRETTYSRC  if ( psrc_convert_string ) {cwe id:CWE-416context: void HTML_put_string ( HTStructured * me , const char * s )  {  # ifdef USE_PRETTYSRC char * translated_string = NULL ; # endif if ( s == NULL || ( LYMapsOnly && me -> sp [ 0 ] . tag_number != HTML_OBJECT ) ) return ; # ifdef USE_PRETTYSRC if ( psrc_convert_string ) { StrAllocCopy ( translated_string , s ) ; TRANSLATE_AND_UNESCAPE_ENTITIES ( & translated_string , TRUE , FALSE ) ; s = ( const char * ) translated_string ; } # endif switch ( me -> sp [ 0 ] . tag_number ) { case HTML_COMMENT : break ; case HTML_TITLE :  HTChunkPuts ( & me -> title , s ) ;  break ; case HTML_STYLE :  HTChunkPuts ( & me -> style_block , s ) ;  break ; case HTML_SCRIPT :  HTChunkPuts ( & me -> script , s ) ;  break ; case HTML_PRE : case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : HText_appendText ( me -> text , s ) ; break ; case HTML_OBJECT :  HTChunkPuts ( & me -> object , s ) ;  break ; case HTML_TEXTAREA :  HTChunkPuts ( & me -> textarea , s ) ;  break ; case HTML_SELECT : case HTML_OPTION :  HTChunkPuts ( & me -> option , s ) ;  break ; case HTML_MATH :  HTChunkPuts ( & me -> math , s ) ;  break ; default : if ( ! me -> sp -> style -> freeFormat ) { # ifdef USE_PRETTYSRC if ( psrc_view ) { for ( ; * s ; ++ s ) HTML_put_character ( me , * s ) ; } else # endif HText_appendText ( me -> text , s ) ; break ; } else { const char * p = s ; char c ; if ( me -> style_change ) { for ( ; * p && ( ( * p == '\\n' ) || ( * p == '\\r' ) || ( * p == '<S2SV_blank>' ) || ( * p == '\\t' ) ) ; p ++ ) ; if ( ! * p ) break ; UPDATE_STYLE ; } for ( ; * p ; p ++ ) { if ( * p == 13 && p [ 1 ] != 10 ) { c = '\\n' ; } else { c = * p ; } if ( me -> style_change ) { if ( ( c == '\\n' ) || ( c == '<S2SV_blank>' ) || ( c == '\\t' ) ) continue ; UPDATE_STYLE ; } if ( c == '\\n' ) { if ( ! FIX_JAPANESE_SPACES ) { if ( me -> in_word ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; me -> in_word = NO ; } } } else if ( c == '<S2SV_blank>' || c == '\\t' ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' ) { } else { HText_appendCharacter ( me -> text , c ) ; me -> in_word = YES ; } if ( c == '\\n' || c == '\\t' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' && HText_getLastChar ( me -> text ) == '<S2SV_blank>' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else { HText_setLastChar ( me -> text , c ) ; } } } }  # ifdef USE_PRETTYSRC  if ( psrc_convert_string ) { psrc_convert_string = FALSE ; FREE ( translated_string ) ; } # endif }",# ifdef USE_PRETTYSRC if ( psrc_convert_string ) {,2320
230,"buggy line: return error ;}cwe id:CWE-000context: int iwch_cxgb3_ofld_send ( struct t3cdev * tdev , struct sk_buff * skb ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = cxgb3_ofld_send ( tdev , skb ) ; if ( error < 0 ) kfree_skb ( skb ) ;  return error ;  }",return error < 0 ? error : 0 ;},2321
231,"buggy line: kiocb -> ki_nr_segs = kiocb -> ki_nbytes ;kiocb -> ki_cur_seg = 0 ;cwe id:CWE-000context: static ssize_t aio_setup_vectored_rw ( int type , struct kiocb * kiocb , bool compat ) { ssize_t ret ; # ifdef CONFIG_COMPAT if ( compat ) ret = compat_rw_copy_check_uvector ( type , ( struct compat_iovec __user * ) kiocb -> ki_buf , kiocb -> ki_nbytes , 1 , & kiocb -> ki_inline_vec , & kiocb -> ki_iovec , 1 ) ; else # endif ret = rw_copy_check_uvector ( type , ( struct iovec __user * ) kiocb -> ki_buf , kiocb -> ki_nbytes , 1 , & kiocb -> ki_inline_vec , & kiocb -> ki_iovec , 1 ) ; if ( ret < 0 ) goto out ;  kiocb -> ki_nr_segs = kiocb -> ki_nbytes ;  kiocb -> ki_cur_seg = 0 ; kiocb -> ki_nbytes = ret ; kiocb -> ki_left = ret ; ret = 0 ; out : return ret ; }","ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ;if ( ret < 0 ) goto out ;kiocb -> ki_nr_segs = kiocb -> ki_nbytes ;kiocb -> ki_cur_seg = 0 ;",2322
232,"buggy line: sas_discover_event ( dev -> port , DISCE_PROBE ) ;return 0 ;cwe id:CWE-000context: int sas_discover_sata ( struct domain_device * dev ) { int res ; if ( dev -> dev_type == SAS_SATA_PM ) return - ENODEV ; dev -> sata_dev . class = sas_get_ata_command_set ( dev ) ; sas_fill_in_rphy ( dev , dev -> rphy ) ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ;  sas_discover_event ( dev -> port , DISCE_PROBE ) ;  return 0 ; }",return 0 ;,2323
233,"buggy line: }cwe id:CWE-476context: void pdo_stmt_init ( TSRMLS_D ) { zend_class_entry ce ; INIT_CLASS_ENTRY ( ce , ""PDOStatement"" , pdo_dbstmt_functions ) ; pdo_dbstmt_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_dbstmt_ce -> get_iterator = pdo_stmt_iter_get ; pdo_dbstmt_ce -> create_object = pdo_dbstmt_new ; zend_class_implements ( pdo_dbstmt_ce TSRMLS_CC , 1 , zend_ce_traversable ) ; zend_declare_property_null ( pdo_dbstmt_ce , ""queryString"" , sizeof ( ""queryString"" ) - 1 , ZEND_ACC_PUBLIC TSRMLS_CC ) ; memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ; pdo_dbstmt_object_handlers . write_property = dbstmt_prop_write ; pdo_dbstmt_object_handlers . unset_property = dbstmt_prop_delete ; pdo_dbstmt_object_handlers . get_method = dbstmt_method_get ; pdo_dbstmt_object_handlers . compare_objects = dbstmt_compare ; pdo_dbstmt_object_handlers . clone_obj = dbstmt_clone_obj ; INIT_CLASS_ENTRY ( ce , ""PDORow"" , pdo_row_functions ) ; pdo_row_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_row_ce -> ce_flags |= ZEND_ACC_FINAL_CLASS ; pdo_row_ce -> create_object = pdo_row_new ; pdo_row_ce -> serialize = pdo_row_serialize ;  } ",pdo_row_ce -> unserialize = zend_class_unserialize_deny ;},2324
234,"buggy line: int error ;ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ;cwe id:CWE-19context: static int ext2_xattr_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; struct ext2_xattr_entry * entry ; char * end ; size_t rest = buffer_size ;  int error ;  ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ; down_read ( & EXT2_I ( inode ) -> xattr_sem ) ; error = 0 ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%d"" , EXT2_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; end = bh -> b_data + bh -> b_size ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { bad_block : ext2_error ( inode -> i_sb , ""ext2_xattr_list"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; goto cleanup ; } entry = FIRST_ENTRY ( bh ) ; while ( ! IS_LAST_ENTRY ( entry ) ) { struct ext2_xattr_entry * next = EXT2_XATTR_NEXT ( entry ) ; if ( ( char * ) next >= end ) goto bad_block ; entry = next ; }  if ( ext2_xattr_cache_insert ( bh ) )  ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ; for ( entry = FIRST_ENTRY ( bh ) ; ! IS_LAST_ENTRY ( entry ) ; entry = EXT2_XATTR_NEXT ( entry ) ) { const struct xattr_handler * handler = ext2_xattr_handler ( entry -> e_name_index ) ; if ( handler && ( ! handler -> list || handler -> list ( dentry ) ) ) { const char * prefix = handler -> prefix ? : handler -> name ; size_t prefix_len = strlen ( prefix ) ; size_t size = prefix_len + entry -> e_name_len + 1 ; if ( buffer ) { if ( size > rest ) { error = - ERANGE ; goto cleanup ; } memcpy ( buffer , prefix , prefix_len ) ; buffer += prefix_len ; memcpy ( buffer , entry -> e_name , entry -> e_name_len ) ; buffer += entry -> e_name_len ; * buffer ++ = 0 ; } rest -= size ; } } error = buffer_size - rest ; cleanup : brelse ( bh ) ; up_read ( & EXT2_I ( inode ) -> xattr_sem ) ; return error ; }","int error ;struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache ;ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ;",2325
235,"buggy line: if ( ext2_xattr_cache_insert ( bh ) )  ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ;cwe id:CWE-19context: static int ext2_xattr_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; struct ext2_xattr_entry * entry ; char * end ; size_t rest = buffer_size ;  int error ;  ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ; down_read ( & EXT2_I ( inode ) -> xattr_sem ) ; error = 0 ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%d"" , EXT2_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; end = bh -> b_data + bh -> b_size ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { bad_block : ext2_error ( inode -> i_sb , ""ext2_xattr_list"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; goto cleanup ; } entry = FIRST_ENTRY ( bh ) ; while ( ! IS_LAST_ENTRY ( entry ) ) { struct ext2_xattr_entry * next = EXT2_XATTR_NEXT ( entry ) ; if ( ( char * ) next >= end ) goto bad_block ; entry = next ; }  if ( ext2_xattr_cache_insert ( bh ) )  ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ; for ( entry = FIRST_ENTRY ( bh ) ; ! IS_LAST_ENTRY ( entry ) ; entry = EXT2_XATTR_NEXT ( entry ) ) { const struct xattr_handler * handler = ext2_xattr_handler ( entry -> e_name_index ) ; if ( handler && ( ! handler -> list || handler -> list ( dentry ) ) ) { const char * prefix = handler -> prefix ? : handler -> name ; size_t prefix_len = strlen ( prefix ) ; size_t size = prefix_len + entry -> e_name_len + 1 ; if ( buffer ) { if ( size > rest ) { error = - ERANGE ; goto cleanup ; } memcpy ( buffer , prefix , prefix_len ) ; buffer += prefix_len ; memcpy ( buffer , entry -> e_name , entry -> e_name_len ) ; buffer += entry -> e_name_len ; * buffer ++ = 0 ; } rest -= size ; } } error = buffer_size - rest ; cleanup : brelse ( bh ) ; up_read ( & EXT2_I ( inode ) -> xattr_sem ) ; return error ; }","if ( ext2_xattr_cache_insert ( ext2_mb_cache , bh ) ) ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ;",2325
236,"buggy line: if ( client -> type == USER_CLIENT )  snd_seq_fifo_clear ( client -> data . user . fifo ) ;cwe id:CWE-000context: static int snd_seq_ioctl_remove_events ( struct snd_seq_client * client , void __user * arg ) { struct snd_seq_remove_events info ; if ( copy_from_user ( & info , arg , sizeof ( info ) ) ) return - EFAULT ; if ( info . remove_mode & SNDRV_SEQ_REMOVE_INPUT ) {  if ( client -> type == USER_CLIENT )  snd_seq_fifo_clear ( client -> data . user . fifo ) ; } if ( info . remove_mode & SNDRV_SEQ_REMOVE_OUTPUT ) snd_seq_queue_remove_cells ( client -> number , & info ) ; return 0 ; }",if ( client -> type == USER_CLIENT && client -> data . user . fifo ) snd_seq_fifo_clear ( client -> data . user . fifo ) ;,2326
237,"buggy line: if ( IS_ERR ( index_key . type ) ) {key_ref = ERR_PTR ( - ENODEV ) ;goto error ;}key_ref = ERR_PTR ( - EINVAL ) ;if ( ! index_key . type -> match || ! index_key . type -> instantiate ||  ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ;cwe id:CWE-476context: key_ref_t key_create_or_update ( key_ref_t keyring_ref , const char * type , const char * description , const void * payload , size_t plen , key_perm_t perm , unsigned long flags ) { struct keyring_index_key index_key = { . description = description , } ; struct key_preparsed_payload prep ; struct assoc_array_edit * edit ; const struct cred * cred = current_cred ( ) ; struct key * keyring , * key = NULL ; key_ref_t key_ref ; int ret ; index_key . type = key_type_lookup ( type ) ; if ( IS_ERR ( index_key . type ) ) { key_ref = ERR_PTR ( - ENODEV ) ; goto error ; } key_ref = ERR_PTR ( - EINVAL ) ;  if ( ! index_key . type -> match || ! index_key . type -> instantiate ||  ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ; keyring = key_ref_to_ptr ( keyring_ref ) ; key_check ( keyring ) ; key_ref = ERR_PTR ( - ENOTDIR ) ; if ( keyring -> type != & key_type_keyring ) goto error_put_type ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = index_key . type -> def_datalen ; prep . trusted = flags & KEY_ALLOC_TRUSTED ; prep . expiry = TIME_T_MAX ; if ( index_key . type -> preparse ) { ret = index_key . type -> preparse ( & prep ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_free_prep ; } if ( ! index_key . description ) index_key . description = prep . description ; key_ref = ERR_PTR ( - EINVAL ) ; if ( ! index_key . description ) goto error_free_prep ; } index_key . desc_len = strlen ( index_key . description ) ; key_ref = ERR_PTR ( - EPERM ) ; if ( ! prep . trusted && test_bit ( KEY_FLAG_TRUSTED_ONLY , & keyring -> flags ) ) goto error_free_prep ; flags |= prep . trusted ? KEY_ALLOC_TRUSTED : 0 ; ret = __key_link_begin ( keyring , & index_key , & edit ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_free_prep ; } ret = key_permission ( keyring_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_link_end ; } if ( index_key . type -> update ) { key_ref = find_key_to_update ( keyring_ref , & index_key ) ; if ( key_ref ) goto found_matching_key ; } if ( perm == KEY_PERM_UNDEF ) { perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR ; perm |= KEY_USR_VIEW ; if ( index_key . type -> read ) perm |= KEY_POS_READ ; if ( index_key . type == & key_type_keyring || index_key . type -> update ) perm |= KEY_POS_WRITE ; } key = key_alloc ( index_key . type , index_key . description , cred -> fsuid , cred -> fsgid , cred , perm , flags ) ; if ( IS_ERR ( key ) ) { key_ref = ERR_CAST ( key ) ; goto error_link_end ; } ret = __key_instantiate_and_link ( key , & prep , keyring , NULL , & edit ) ; if ( ret < 0 ) { key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto error_link_end ; } key_ref = make_key_ref ( key , is_key_possessed ( keyring_ref ) ) ; error_link_end : __key_link_end ( keyring , & index_key , edit ) ; error_free_prep : if ( index_key . type -> preparse ) index_key . type -> free_preparse ( & prep ) ; error_put_type : key_type_put ( index_key . type ) ; error : return key_ref ; found_matching_key : __key_link_end ( keyring , & index_key , edit ) ; key_ref = __key_update ( key_ref , & prep ) ; goto error_free_prep ; }",if ( ! index_key . type -> match || ! index_key . type -> instantiate || ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ;,2327
238,"buggy line: file = fopen ( ""/tmp/keepalived.json"" , ""w"" ) ;if ( ! file ) {cwe id:CWE-59context: void vrrp_print_json ( void ) { FILE * file ; element e ; struct json_object * array ; if ( LIST_ISEMPTY ( vrrp_data -> vrrp ) ) return ;  file = fopen ( ""/tmp/keepalived.json"" , ""w"" ) ;  if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>/tmp/keepalived.json<S2SV_blank>(%d:<S2SV_blank>%s)"" , errno , strerror ( errno ) ) ; return ; } array = json_object_new_array ( ) ; for ( e = LIST_HEAD ( vrrp_data -> vrrp ) ; e ; ELEMENT_NEXT ( e ) ) { struct json_object * instance_json , * json_stats , * json_data , * vips , * evips , * track_ifp , * track_script ; # ifdef _HAVE_FIB_ROUTING_ struct json_object * vroutes , * vrules ; # endif element f ; vrrp_t * vrrp = ELEMENT_DATA ( e ) ; instance_json = json_object_new_object ( ) ; json_stats = json_object_new_object ( ) ; json_data = json_object_new_object ( ) ; vips = json_object_new_array ( ) ; evips = json_object_new_array ( ) ; track_ifp = json_object_new_array ( ) ; track_script = json_object_new_array ( ) ; # ifdef _HAVE_FIB_ROUTING_ vroutes = json_object_new_array ( ) ; vrules = json_object_new_array ( ) ; # endif json_object_object_add ( json_data , ""iname"" , json_object_new_string ( vrrp -> iname ) ) ; json_object_object_add ( json_data , ""dont_track_primary"" , json_object_new_int ( vrrp -> dont_track_primary ) ) ; json_object_object_add ( json_data , ""skip_check_adv_addr"" , json_object_new_int ( vrrp -> skip_check_adv_addr ) ) ; json_object_object_add ( json_data , ""strict_mode"" , json_object_new_int ( ( int ) vrrp -> strict_mode ) ) ; # ifdef _HAVE_VRRP_VMAC_ json_object_object_add ( json_data , ""vmac_ifname"" , json_object_new_string ( vrrp -> vmac_ifname ) ) ; # endif if ( ! LIST_ISEMPTY ( vrrp -> track_ifp ) ) { for ( f = LIST_HEAD ( vrrp -> track_ifp ) ; f ; ELEMENT_NEXT ( f ) ) { interface_t * ifp = ELEMENT_DATA ( f ) ; json_object_array_add ( track_ifp , json_object_new_string ( ifp -> ifname ) ) ; } } json_object_object_add ( json_data , ""track_ifp"" , track_ifp ) ; if ( ! LIST_ISEMPTY ( vrrp -> track_script ) ) { for ( f = LIST_HEAD ( vrrp -> track_script ) ; f ; ELEMENT_NEXT ( f ) ) { tracked_sc_t * tsc = ELEMENT_DATA ( f ) ; vrrp_script_t * vscript = tsc -> scr ; json_object_array_add ( track_script , json_object_new_string ( cmd_str ( & vscript -> script ) ) ) ; } } json_object_object_add ( json_data , ""track_script"" , track_script ) ; json_object_object_add ( json_data , ""ifp_ifname"" , json_object_new_string ( vrrp -> ifp -> ifname ) ) ; json_object_object_add ( json_data , ""master_priority"" , json_object_new_int ( vrrp -> master_priority ) ) ; json_object_object_add ( json_data , ""last_transition"" , json_object_new_double ( timeval_to_double ( & vrrp -> last_transition ) ) ) ; json_object_object_add ( json_data , ""garp_delay"" , json_object_new_double ( vrrp -> garp_delay / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , ""garp_refresh"" , json_object_new_int ( ( int ) vrrp -> garp_refresh . tv_sec ) ) ; json_object_object_add ( json_data , ""garp_rep"" , json_object_new_int ( ( int ) vrrp -> garp_rep ) ) ; json_object_object_add ( json_data , ""garp_refresh_rep"" , json_object_new_int ( ( int ) vrrp -> garp_refresh_rep ) ) ; json_object_object_add ( json_data , ""garp_lower_prio_delay"" , json_object_new_int ( ( int ) ( vrrp -> garp_lower_prio_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , ""garp_lower_prio_rep"" , json_object_new_int ( ( int ) vrrp -> garp_lower_prio_rep ) ) ; json_object_object_add ( json_data , ""lower_prio_no_advert"" , json_object_new_int ( ( int ) vrrp -> lower_prio_no_advert ) ) ; json_object_object_add ( json_data , ""higher_prio_send_advert"" , json_object_new_int ( ( int ) vrrp -> higher_prio_send_advert ) ) ; json_object_object_add ( json_data , ""vrid"" , json_object_new_int ( vrrp -> vrid ) ) ; json_object_object_add ( json_data , ""base_priority"" , json_object_new_int ( vrrp -> base_priority ) ) ; json_object_object_add ( json_data , ""effective_priority"" , json_object_new_int ( vrrp -> effective_priority ) ) ; json_object_object_add ( json_data , ""vipset"" , json_object_new_boolean ( vrrp -> vipset ) ) ; if ( ! LIST_ISEMPTY ( vrrp -> vip ) ) { for ( f = LIST_HEAD ( vrrp -> vip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * vip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( vip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( vips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , ""vips"" , vips ) ; if ( ! LIST_ISEMPTY ( vrrp -> evip ) ) { for ( f = LIST_HEAD ( vrrp -> evip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * evip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( evip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( evips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , ""evips"" , evips ) ; json_object_object_add ( json_data , ""promote_secondaries"" , json_object_new_boolean ( vrrp -> promote_secondaries ) ) ; # ifdef _HAVE_FIB_ROUTING_ if ( ! LIST_ISEMPTY ( vrrp -> vroutes ) ) { for ( f = LIST_HEAD ( vrrp -> vroutes ) ; f ; ELEMENT_NEXT ( f ) ) { ip_route_t * route = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( ROUTE_BUF_SIZE ) ; format_iproute ( route , buf , ROUTE_BUF_SIZE ) ; json_object_array_add ( vroutes , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , ""vroutes"" , vroutes ) ; if ( ! LIST_ISEMPTY ( vrrp -> vrules ) ) { for ( f = LIST_HEAD ( vrrp -> vrules ) ; f ; ELEMENT_NEXT ( f ) ) { ip_rule_t * rule = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( RULE_BUF_SIZE ) ; format_iprule ( rule , buf , RULE_BUF_SIZE ) ; json_object_array_add ( vrules , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , ""vrules"" , vrules ) ; # endif json_object_object_add ( json_data , ""adver_int"" , json_object_new_double ( vrrp -> adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , ""master_adver_int"" , json_object_new_double ( vrrp -> master_adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , ""accept"" , json_object_new_int ( ( int ) vrrp -> accept ) ) ; json_object_object_add ( json_data , ""nopreempt"" , json_object_new_boolean ( vrrp -> nopreempt ) ) ; json_object_object_add ( json_data , ""preempt_delay"" , json_object_new_int ( ( int ) ( vrrp -> preempt_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , ""state"" , json_object_new_int ( vrrp -> state ) ) ; json_object_object_add ( json_data , ""wantstate"" , json_object_new_int ( vrrp -> wantstate ) ) ; json_object_object_add ( json_data , ""version"" , json_object_new_int ( vrrp -> version ) ) ; if ( vrrp -> script_backup ) json_object_object_add ( json_data , ""script_backup"" , json_object_new_string ( cmd_str ( vrrp -> script_backup ) ) ) ; if ( vrrp -> script_master ) json_object_object_add ( json_data , ""script_master"" , json_object_new_string ( cmd_str ( vrrp -> script_master ) ) ) ; if ( vrrp -> script_fault ) json_object_object_add ( json_data , ""script_fault"" , json_object_new_string ( cmd_str ( vrrp -> script_fault ) ) ) ; if ( vrrp -> script_stop ) json_object_object_add ( json_data , ""script_stop"" , json_object_new_string ( cmd_str ( vrrp -> script_stop ) ) ) ; if ( vrrp -> script ) json_object_object_add ( json_data , ""script"" , json_object_new_string ( cmd_str ( vrrp -> script ) ) ) ; if ( vrrp -> script_master_rx_lower_pri ) json_object_object_add ( json_data , ""script_master_rx_lower_pri"" , json_object_new_string ( cmd_str ( vrrp -> script_master_rx_lower_pri ) ) ) ; json_object_object_add ( json_data , ""smtp_alert"" , json_object_new_boolean ( vrrp -> smtp_alert ) ) ; # ifdef _WITH_VRRP_AUTH_ if ( vrrp -> auth_type ) { json_object_object_add ( json_data , ""auth_type"" , json_object_new_int ( vrrp -> auth_type ) ) ; if ( vrrp -> auth_type != VRRP_AUTH_AH ) { char auth_data [ sizeof ( vrrp -> auth_data ) + 1 ] ; memcpy ( auth_data , vrrp -> auth_data , sizeof ( vrrp -> auth_data ) ) ; auth_data [ sizeof ( vrrp -> auth_data ) ] = '\\0' ; json_object_object_add ( json_data , ""auth_data"" , json_object_new_string ( auth_data ) ) ; } } else json_object_object_add ( json_data , ""auth_type"" , json_object_new_int ( 0 ) ) ; # endif json_object_object_add ( json_stats , ""advert_rcvd"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_rcvd ) ) ; json_object_object_add ( json_stats , ""advert_sent"" , json_object_new_int64 ( vrrp -> stats -> advert_sent ) ) ; json_object_object_add ( json_stats , ""become_master"" , json_object_new_int64 ( vrrp -> stats -> become_master ) ) ; json_object_object_add ( json_stats , ""release_master"" , json_object_new_int64 ( vrrp -> stats -> release_master ) ) ; json_object_object_add ( json_stats , ""packet_len_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> packet_len_err ) ) ; json_object_object_add ( json_stats , ""advert_interval_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_interval_err ) ) ; json_object_object_add ( json_stats , ""ip_ttl_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> ip_ttl_err ) ) ; json_object_object_add ( json_stats , ""invalid_type_rcvd"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> invalid_type_rcvd ) ) ; json_object_object_add ( json_stats , ""addr_list_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> addr_list_err ) ) ; json_object_object_add ( json_stats , ""invalid_authtype"" , json_object_new_int64 ( vrrp -> stats -> invalid_authtype ) ) ; # ifdef _WITH_VRRP_AUTH_ json_object_object_add ( json_stats , ""authtype_mismatch"" , json_object_new_int64 ( vrrp -> stats -> authtype_mismatch ) ) ; json_object_object_add ( json_stats , ""auth_failure"" , json_object_new_int64 ( vrrp -> stats -> auth_failure ) ) ; # endif json_object_object_add ( json_stats , ""pri_zero_rcvd"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_rcvd ) ) ; json_object_object_add ( json_stats , ""pri_zero_sent"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_sent ) ) ; json_object_object_add ( instance_json , ""data"" , json_data ) ; json_object_object_add ( instance_json , ""stats"" , json_stats ) ; json_object_array_add ( array , instance_json ) ; } fprintf ( file , ""%s"" , json_object_to_json_string ( array ) ) ; fclose ( file ) ; }","file = fopen_safe ( ""/tmp/keepalived.json"" , ""w"" ) ;if ( ! file ) {",2328
239,"buggy line: pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ;ver = 1 ;cwe id:CWE-787context: int pdf_load_xrefs ( FILE * fp , pdf_t * pdf ) { int i , ver , is_linear ; long pos , pos_count ; char x , * c , buf [ 256 ] ; c = NULL ; pdf -> n_xrefs = 0 ; fseek ( fp , 0 , SEEK_SET ) ; while ( get_next_eof ( fp ) >= 0 ) ++ pdf -> n_xrefs ; if ( ! pdf -> n_xrefs ) return 0 ; fseek ( fp , 0 , SEEK_SET ) ;  pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ;  ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( ( pos = get_next_eof ( fp ) ) < 0 ) break ; pdf -> xrefs [ i ] . version = ver ++ ; pos_count = 0 ; while ( SAFE_F ( fp , ( ( x = fgetc ( fp ) ) != 'f' ) ) ) fseek ( fp , pos - ( ++ pos_count ) , SEEK_SET ) ; if ( pos_count >= sizeof ( buf ) ) { ERR ( ""Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>the<S2SV_blank>startxref<S2SV_blank>token.<S2SV_blank>"" ""This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n"" ) ; return - 1 ; } memset ( buf , 0 , sizeof ( buf ) ) ; SAFE_E ( fread ( buf , 1 , pos_count , fp ) , pos_count , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>startxref.\\n"" ) ; c = buf ; while ( * c == '<S2SV_blank>' || * c == '\\n' || * c == '\\r' ) ++ c ; pdf -> xrefs [ i ] . start = atol ( c ) ; if ( pdf -> xrefs [ i ] . start == 0 ) get_xref_linear_skipped ( fp , & pdf -> xrefs [ i ] ) ; else { pos = ftell ( fp ) ; fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; pdf -> xrefs [ i ] . end = get_next_eof ( fp ) ; fseek ( fp , pos , SEEK_SET ) ; } if ( ! is_valid_xref ( fp , pdf , & pdf -> xrefs [ i ] ) ) { is_linear = pdf -> xrefs [ i ] . is_linear ; memset ( & pdf -> xrefs [ i ] , 0 , sizeof ( xref_t ) ) ; pdf -> xrefs [ i ] . is_linear = is_linear ; rewind ( fp ) ; get_next_eof ( fp ) ; continue ; } load_xref_entries ( fp , & pdf -> xrefs [ i ] ) ; } if ( pdf -> xrefs [ 0 ] . is_linear ) resolve_linearized_pdf ( pdf ) ; load_creator ( fp , pdf ) ; return pdf -> n_xrefs ; }",pdf -> xrefs = safe_calloc ( sizeof ( xref_t ) * pdf -> n_xrefs ) ;ver = 1 ;,2329
240,"buggy line: if ( err )  return err ;return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ;cwe id:CWE-401context: static int crypto_report ( struct sk_buff * in_skb , struct nlmsghdr * in_nlh , struct nlattr * * attrs ) { struct net * net = sock_net ( in_skb -> sk ) ; struct crypto_user_alg * p = nlmsg_data ( in_nlh ) ; struct crypto_alg * alg ; struct sk_buff * skb ; struct crypto_dump_info info ; int err ; if ( ! null_terminated ( p -> cru_name ) || ! null_terminated ( p -> cru_driver_name ) ) return - EINVAL ; alg = crypto_alg_match ( p , 0 ) ; if ( ! alg ) return - ENOENT ; err = - ENOMEM ; skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_KERNEL ) ; if ( ! skb ) goto drop_alg ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = in_nlh -> nlmsg_seq ; info . nlmsg_flags = 0 ; err = crypto_report_alg ( alg , & info ) ; drop_alg : crypto_mod_put ( alg ) ; if ( err )  return err ;  return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ; }","if ( err ) {kfree_skb ( skb ) ;return err ;}return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ;",2330
241,"buggy line: int delta_munlocked ;struct pagevec pvec_putback ;cwe id:CWE-20context: static void __munlock_pagevec ( struct pagevec * pvec , struct zone * zone ) { int i ; int nr = pagevec_count ( pvec ) ;  int delta_munlocked ;  struct pagevec pvec_putback ; int pgrescued = 0 ; pagevec_init ( & pvec_putback , 0 ) ; spin_lock_irq ( zone_lru_lock ( zone ) ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( TestClearPageMlocked ( page ) ) { if ( __munlock_isolate_lru_page ( page , false ) ) continue ; else __munlock_isolation_failed ( page ) ;  }  pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ; pvec -> pages [ i ] = NULL ; }  delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ;  __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ; spin_unlock_irq ( zone_lru_lock ( zone ) ) ; pagevec_release ( & pvec_putback ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( page ) { lock_page ( page ) ; if ( ! __putback_lru_fast_prepare ( page , & pvec_putback , & pgrescued ) ) { get_page ( page ) ; __munlock_isolated_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; } } } if ( pagevec_count ( & pvec_putback ) ) __putback_lru_fast ( & pvec_putback , pgrescued ) ; }",int delta_munlocked = - nr ;struct pagevec pvec_putback ;,2331
242,"buggy line: }pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ;delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ;__mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ;cwe id:CWE-20context: static void __munlock_pagevec ( struct pagevec * pvec , struct zone * zone ) { int i ; int nr = pagevec_count ( pvec ) ;  int delta_munlocked ;  struct pagevec pvec_putback ; int pgrescued = 0 ; pagevec_init ( & pvec_putback , 0 ) ; spin_lock_irq ( zone_lru_lock ( zone ) ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( TestClearPageMlocked ( page ) ) { if ( __munlock_isolate_lru_page ( page , false ) ) continue ; else __munlock_isolation_failed ( page ) ;  }  pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ; pvec -> pages [ i ] = NULL ; }  delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ;  __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ; spin_unlock_irq ( zone_lru_lock ( zone ) ) ; pagevec_release ( & pvec_putback ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( page ) { lock_page ( page ) ; if ( ! __putback_lru_fast_prepare ( page , & pvec_putback , & pgrescued ) ) { get_page ( page ) ; __munlock_isolated_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; } } } if ( pagevec_count ( & pvec_putback ) ) __putback_lru_fast ( & pvec_putback , pgrescued ) ; }","}else {delta_munlocked ++ ;}pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ;__mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ;",2331
243,"buggy line: skipsize = LOGICAL_BLOCK_SIZE * vd -> location ;skipsize = __archive_read_consume ( a , skipsize ) ;cwe id:CWE-190context: static int choose_volume ( struct archive_read * a , struct iso9660 * iso9660 ) { struct file_info * file ; int64_t skipsize ; struct vd * vd ; const void * block ; char seenJoliet ; vd = & ( iso9660 -> primary ) ; if ( ! iso9660 -> opt_support_joliet ) iso9660 -> seenJoliet = 0 ; if ( iso9660 -> seenJoliet && vd -> location > iso9660 -> joliet . location ) vd = & ( iso9660 -> joliet ) ;  skipsize = LOGICAL_BLOCK_SIZE * vd -> location ;  skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ; iso9660 -> current_position = skipsize ; block = __archive_read_ahead ( a , vd -> size , NULL ) ; if ( block == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>full<S2SV_blank>block<S2SV_blank>when<S2SV_blank>scanning<S2SV_blank>"" ""ISO9660<S2SV_blank>directory<S2SV_blank>list"" ) ; return ( ARCHIVE_FATAL ) ; } seenJoliet = iso9660 -> seenJoliet ; iso9660 -> seenJoliet = 0 ; file = parse_file_info ( a , NULL , block ) ; if ( file == NULL ) return ( ARCHIVE_FATAL ) ; iso9660 -> seenJoliet = seenJoliet ; if ( vd == & ( iso9660 -> primary ) && iso9660 -> seenRockridge && iso9660 -> seenJoliet ) iso9660 -> seenJoliet = 0 ; if ( vd == & ( iso9660 -> primary ) && ! iso9660 -> seenRockridge && iso9660 -> seenJoliet ) { vd = & ( iso9660 -> joliet ) ;  skipsize = LOGICAL_BLOCK_SIZE * vd -> location ;  skipsize -= iso9660 -> current_position ; skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ; iso9660 -> current_position += skipsize ; block = __archive_read_ahead ( a , vd -> size , NULL ) ; if ( block == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>full<S2SV_blank>block<S2SV_blank>when<S2SV_blank>scanning<S2SV_blank>"" ""ISO9660<S2SV_blank>directory<S2SV_blank>list"" ) ; return ( ARCHIVE_FATAL ) ; } iso9660 -> seenJoliet = 0 ; file = parse_file_info ( a , NULL , block ) ; if ( file == NULL ) return ( ARCHIVE_FATAL ) ; iso9660 -> seenJoliet = seenJoliet ; } if ( add_entry ( a , iso9660 , file ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ; if ( iso9660 -> seenRockridge ) { a -> archive . archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE ; a -> archive . archive_format_name = ""ISO9660<S2SV_blank>with<S2SV_blank>Rockridge<S2SV_blank>extensions"" ; } return ( ARCHIVE_OK ) ; }","skipsize = LOGICAL_BLOCK_SIZE * ( int64_t ) vd -> location ;skipsize = __archive_read_consume ( a , skipsize ) ;",2332
244,"buggy line: skipsize = LOGICAL_BLOCK_SIZE * vd -> location ;skipsize -= iso9660 -> current_position ;cwe id:CWE-190context: static int choose_volume ( struct archive_read * a , struct iso9660 * iso9660 ) { struct file_info * file ; int64_t skipsize ; struct vd * vd ; const void * block ; char seenJoliet ; vd = & ( iso9660 -> primary ) ; if ( ! iso9660 -> opt_support_joliet ) iso9660 -> seenJoliet = 0 ; if ( iso9660 -> seenJoliet && vd -> location > iso9660 -> joliet . location ) vd = & ( iso9660 -> joliet ) ;  skipsize = LOGICAL_BLOCK_SIZE * vd -> location ;  skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ; iso9660 -> current_position = skipsize ; block = __archive_read_ahead ( a , vd -> size , NULL ) ; if ( block == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>full<S2SV_blank>block<S2SV_blank>when<S2SV_blank>scanning<S2SV_blank>"" ""ISO9660<S2SV_blank>directory<S2SV_blank>list"" ) ; return ( ARCHIVE_FATAL ) ; } seenJoliet = iso9660 -> seenJoliet ; iso9660 -> seenJoliet = 0 ; file = parse_file_info ( a , NULL , block ) ; if ( file == NULL ) return ( ARCHIVE_FATAL ) ; iso9660 -> seenJoliet = seenJoliet ; if ( vd == & ( iso9660 -> primary ) && iso9660 -> seenRockridge && iso9660 -> seenJoliet ) iso9660 -> seenJoliet = 0 ; if ( vd == & ( iso9660 -> primary ) && ! iso9660 -> seenRockridge && iso9660 -> seenJoliet ) { vd = & ( iso9660 -> joliet ) ;  skipsize = LOGICAL_BLOCK_SIZE * vd -> location ;  skipsize -= iso9660 -> current_position ; skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ; iso9660 -> current_position += skipsize ; block = __archive_read_ahead ( a , vd -> size , NULL ) ; if ( block == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>full<S2SV_blank>block<S2SV_blank>when<S2SV_blank>scanning<S2SV_blank>"" ""ISO9660<S2SV_blank>directory<S2SV_blank>list"" ) ; return ( ARCHIVE_FATAL ) ; } iso9660 -> seenJoliet = 0 ; file = parse_file_info ( a , NULL , block ) ; if ( file == NULL ) return ( ARCHIVE_FATAL ) ; iso9660 -> seenJoliet = seenJoliet ; } if ( add_entry ( a , iso9660 , file ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ; if ( iso9660 -> seenRockridge ) { a -> archive . archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE ; a -> archive . archive_format_name = ""ISO9660<S2SV_blank>with<S2SV_blank>Rockridge<S2SV_blank>extensions"" ; } return ( ARCHIVE_OK ) ; }",skipsize = LOGICAL_BLOCK_SIZE * ( int64_t ) vd -> location ;skipsize -= iso9660 -> current_position ;,2332
245,"buggy line: int val = 1 ;cFYI ( 1 , ""Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u"" , smb_buf_length ) ;cwe id:CWE-362context: static int smb_send_rqst ( struct TCP_Server_Info * server , struct smb_rqst * rqst ) { int rc ; struct kvec * iov = rqst -> rq_iov ; int n_vec = rqst -> rq_nvec ; unsigned int smb_buf_length = get_rfc1002_length ( iov [ 0 ] . iov_base ) ; unsigned int i ; size_t total_len = 0 , sent ; struct socket * ssocket = server -> ssocket ;  int val = 1 ;  cFYI ( 1 , ""Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u"" , smb_buf_length ) ; dump_smb ( iov [ 0 ] . iov_base , iov [ 0 ] . iov_len ) ; kernel_setsockopt ( ssocket , SOL_TCP , TCP_CORK , ( char * ) & val , sizeof ( val ) ) ; rc = smb_send_kvec ( server , iov , n_vec , & sent ) ; if ( rc < 0 ) goto uncork ; total_len += sent ; for ( i = 0 ; i < rqst -> rq_npages ; i ++ ) { struct kvec p_iov ; cifs_rqst_page_to_kvec ( rqst , i , & p_iov ) ; rc = smb_send_kvec ( server , & p_iov , 1 , & sent ) ; kunmap ( rqst -> rq_pages [ i ] ) ; if ( rc < 0 ) break ; total_len += sent ; } uncork : val = 0 ; kernel_setsockopt ( ssocket , SOL_TCP , TCP_CORK , ( char * ) & val , sizeof ( val ) ) ; if ( ( total_len > 0 ) && ( total_len != smb_buf_length + 4 ) ) { cFYI ( 1 , ""partial<S2SV_blank>send<S2SV_blank>(wanted=%u<S2SV_blank>sent=%zu):<S2SV_blank>terminating<S2SV_blank>"" ""session"" , smb_buf_length + 4 , total_len ) ; server -> tcpStatus = CifsNeedReconnect ; } if ( rc < 0 && rc != - EINTR ) cERROR ( 1 , ""Error<S2SV_blank>%d<S2SV_blank>sending<S2SV_blank>data<S2SV_blank>on<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>server"" , rc ) ; else rc = 0 ; return rc ; }","int val = 1 ;if ( ssocket == NULL ) return - ENOTSOCK ;cFYI ( 1 , ""Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u"" , smb_buf_length ) ;",2333
246,"buggy line: const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width ,  16 ) ;cwe id:CWE-119context: void vp9_copy_and_extend_frame ( const YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst ) { const int et_y = 16 ; const int el_y = 16 ;  const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width ,  16 ) ; const int er_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_height , 6 ) - src -> y_height , 16 ) ; const int uv_width_subsampling = ( src -> uv_width != src -> y_width ) ; const int uv_height_subsampling = ( src -> uv_height != src -> y_height ) ; const int et_uv = et_y >> uv_height_subsampling ; const int el_uv = el_y >> uv_width_subsampling ; const int eb_uv = eb_y >> uv_height_subsampling ; const int er_uv = er_y >> uv_width_subsampling ;  # if CONFIG_ALPHA  const int et_a = dst -> border >> ( dst -> alpha_height != dst -> y_height ) ; const int el_a = dst -> border >> ( dst -> alpha_width != dst -> y_width ) ; const int eb_a = et_a + dst -> alpha_height - src -> alpha_height ; const int er_a = el_a + dst -> alpha_width - src -> alpha_width ; copy_and_extend_plane ( src -> alpha_buffer , src -> alpha_stride , dst -> alpha_buffer , dst -> alpha_stride , src -> alpha_width , src -> alpha_height , et_a , el_a , eb_a , er_a ) ; # endif copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride ,  src -> y_width , src -> y_height ,  et_y , el_y , eb_y , er_y ) ; copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride ,  src -> uv_width , src -> uv_height ,  et_uv , el_uv , eb_uv , er_uv ) ; copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride ,  src -> uv_width , src -> uv_height ,  et_uv , el_uv , eb_uv , er_uv ) ; }","const int er_y = MAX ( src -> y_height , 6 ) ) ) - src -> y_crop_width ;const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_crop_height ;",2334
247,"buggy line: # if CONFIG_ALPHA  const int et_a = dst -> border >> ( dst -> alpha_height != dst -> y_height ) ;const int el_a = dst -> border >> ( dst -> alpha_width != dst -> y_width ) ;const int eb_a = et_a + dst -> alpha_height - src -> alpha_height ;const int er_a = el_a + dst -> alpha_width - src -> alpha_width ;copy_and_extend_plane ( src -> alpha_buffer , src -> alpha_stride , dst -> alpha_buffer , dst -> alpha_stride , src -> alpha_width , src -> alpha_height , et_a , el_a , eb_a , er_a ) ;# endif copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride ,  src -> y_width , src -> y_height ,  et_y , el_y , eb_y , er_y ) ;copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride ,  src -> uv_width , src -> uv_height ,  et_uv , el_uv , eb_uv , er_uv ) ;copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride ,  src -> uv_width , src -> uv_height ,  et_uv , el_uv , eb_uv , er_uv ) ;cwe id:CWE-119context: void vp9_copy_and_extend_frame ( const YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst ) { const int et_y = 16 ; const int el_y = 16 ;  const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width ,  16 ) ; const int er_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_height , 6 ) - src -> y_height , 16 ) ; const int uv_width_subsampling = ( src -> uv_width != src -> y_width ) ; const int uv_height_subsampling = ( src -> uv_height != src -> y_height ) ; const int et_uv = et_y >> uv_height_subsampling ; const int el_uv = el_y >> uv_width_subsampling ; const int eb_uv = eb_y >> uv_height_subsampling ; const int er_uv = er_y >> uv_width_subsampling ;  # if CONFIG_ALPHA  const int et_a = dst -> border >> ( dst -> alpha_height != dst -> y_height ) ; const int el_a = dst -> border >> ( dst -> alpha_width != dst -> y_width ) ; const int eb_a = et_a + dst -> alpha_height - src -> alpha_height ; const int er_a = el_a + dst -> alpha_width - src -> alpha_width ; copy_and_extend_plane ( src -> alpha_buffer , src -> alpha_stride , dst -> alpha_buffer , dst -> alpha_stride , src -> alpha_width , src -> alpha_height , et_a , el_a , eb_a , er_a ) ; # endif copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride ,  src -> y_width , src -> y_height ,  et_y , el_y , eb_y , er_y ) ; copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride ,  src -> uv_width , src -> uv_height ,  et_uv , el_uv , eb_uv , er_uv ) ; copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride ,  src -> uv_width , src -> uv_height ,  et_uv , el_uv , eb_uv , er_uv ) ; }","# if CONFIG_VP9_HIGHBITDEPTH if ( src -> flags & YV12_FLAG_HIGHBITDEPTH ) {highbd_copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ;highbd_copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ;highbd_copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ;return ;}# endif copy_and_extend_plane ( src -> y_buffer , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ;copy_and_extend_plane ( src -> u_buffer , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ;copy_and_extend_plane ( src -> v_buffer , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ;",2334
248,"buggy line: void * base = dlmalloc ( bytes + sizeof ( AllocationEntry ) ) ;if ( base != NULL ) {cwe id:CWE-189context: void * leak_malloc ( size_t bytes ) {  void * base = dlmalloc ( bytes + sizeof ( AllocationEntry ) ) ;  if ( base != NULL ) { pthread_mutex_lock ( & gAllocationsMutex ) ; intptr_t backtrace [ BACKTRACE_SIZE ] ; size_t numEntries = get_backtrace ( backtrace , BACKTRACE_SIZE ) ; AllocationEntry * header = ( AllocationEntry * ) base ; header -> entry = record_backtrace ( backtrace , numEntries , bytes ) ; header -> guard = GUARD ; base = ( AllocationEntry * ) base + 1 ; pthread_mutex_unlock ( & gAllocationsMutex ) ; } return base ; }",size_t size = bytes + sizeof ( AllocationEntry ) ;if ( size < bytes ) {return NULL ;}void * base = dlmalloc ( size ) ;if ( base != NULL ) {,2335
249,"buggy line: cwe id:CWE-119context: WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; }  ps_dec -> u1_mb_idx = 0 ;  ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ;  ps_dec -> u2_total_mbs_coded ++ ;  u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; }  if ( u1_tfr_n_mb )  u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }",ps_dec -> u2_total_mbs_coded += u1_num_mbs ;,2336
250,"buggy line: ps_dec -> u1_mb_idx = 0 ;ps_dec -> u4_num_mbs_cur_nmb = 0 ;cwe id:CWE-119context: WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; }  ps_dec -> u1_mb_idx = 0 ;  ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ;  ps_dec -> u2_total_mbs_coded ++ ;  u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; }  if ( u1_tfr_n_mb )  u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }",ps_dec -> u1_mb_idx = 0 ;ps_dec -> u4_num_mbs_cur_nmb = 0 ;,2336
251,"buggy line: ps_dec -> u2_total_mbs_coded ++ ;u1_num_mbsNby2 ++ ;cwe id:CWE-119context: WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; }  ps_dec -> u1_mb_idx = 0 ;  ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ;  ps_dec -> u2_total_mbs_coded ++ ;  u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; }  if ( u1_tfr_n_mb )  u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }",u1_num_mbsNby2 ++ ;,2336
252,"buggy line: if ( u1_tfr_n_mb )  u1_num_mbs = 0 ;cwe id:CWE-119context: WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; }  ps_dec -> u1_mb_idx = 0 ;  ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ;  ps_dec -> u2_total_mbs_coded ++ ;  u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; }  if ( u1_tfr_n_mb )  u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }",ps_dec -> u2_total_mbs_coded += u1_num_mbs ;if ( u1_tfr_n_mb ) u1_num_mbs = 0 ;,2336
253,"buggy line: af = EXTRACT_16BITS ( tptr ) ;safi = tptr [ 2 ] ;ND_PRINT ( ( ndo , ""\\\switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ;default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""\\\if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\goto done ;break ;}tptr += 3 ;ND_TCHECK ( tptr [ 0 ] ) ;nhlen = tptr [ 0 ] ;tlen = nhlen ;tptr ++ ;if ( tlen ) {int nnh = 0 ;ND_PRINT ( ( ndo , ""\\\while ( tlen > 0 ) {if ( nnh ++ > 0 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ;}switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ;tlen -= sizeof ( struct in_addr ) ;tptr += sizeof ( struct in_addr ) ;}break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ;tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;}break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ;tlen -= sizeof ( struct in6_addr ) ;tptr += sizeof ( struct in6_addr ) ;}break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ;tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;}break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ;tlen -= ( sizeof ( struct in_addr ) ) ;tptr += ( sizeof ( struct in_addr ) ) ;}break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ;tptr += tlen ;tlen = 0 ;break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ;if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ;else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ;tptr += tlen ;tlen = 0 ;}break ;default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ;if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\tptr += tlen ;tlen = 0 ;goto done ;break ;}}}ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ;tptr += tlen ;ND_TCHECK ( tptr [ 0 ] ) ;snpa = tptr [ 0 ] ;tptr ++ ;if ( snpa ) {ND_PRINT ( ( ndo , ""\\\for ( ;snpa > 0 ;snpa -- ) {ND_TCHECK ( tptr [ 0 ] ) ;ND_PRINT ( ( ndo , ""\\\tptr += tptr [ 0 ] + 1 ;}}else {ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ;}while ( len - ( tptr - pptr ) > 0 ) {switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;default : ND_TCHECK2 ( * tptr , tlen ) ;ND_PRINT ( ( ndo , ""\\\if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\advance = 0 ;tptr = pptr + len ;break ;}if ( advance < 0 ) break ;tptr += advance ;}done : break ;case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ;af = EXTRACT_16BITS ( tptr ) ;safi = tptr [ 2 ] ;ND_PRINT ( ( ndo , ""\\\if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\\while ( len - ( tptr - pptr ) > 0 ) {switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ;ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ;if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\\advance = 0 ;tptr = pptr + len ;break ;}if ( advance < 0 ) break ;tptr += advance ;}break ;case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;break ;}while ( tlen > 0 ) {uint16_t extd_comm ;ND_TCHECK2 ( tptr [ 0 ] , 2 ) ;extd_comm = EXTRACT_16BITS ( tptr ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ;switch ( extd_comm ) {case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ;break ;case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ;break ;case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ;break ;case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ;break ;case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ;break ;case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ;break ;case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ;break ;case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ;break ;default : ND_TCHECK2 ( * tptr , 8 ) ;print_unknown_data ( ndo , tptr , ""\\\break ;}tlen -= 8 ;tptr += 8 ;}break ;case BGPTYPE_PMSI_TUNNEL : {uint8_t tunnel_type , flags ;tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;ND_PRINT ( ( ndo , ""\\\tptr += 5 ;tlen -= 5 ;switch ( tunnel_type ) {case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\print_unknown_data ( ndo , tptr , ""\\\break ;}case BGPTYPE_AIGP : {uint8_t type ;uint16_t length ;ND_TCHECK2 ( tptr [ 0 ] , 3 ) ;tlen = len ;while ( tlen >= 3 ) {type = * tptr ;length = EXTRACT_16BITS ( tptr + 1 ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ;switch ( type ) {case BGP_AIGP_TLV :  ND_TCHECK2 ( tptr [ 3 ] , 8 ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 ,  EXTRACT_64BITS ( tptr + 3 ) ) ) ;break ;default : if ( ndo -> ndo_vflag <= 1 ) {print_unknown_data ( ndo , tptr + 3 , ""\\\}}cwe id:CWE-125context: static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( len - ( tptr - pptr ) > 0 ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( len - ( tptr - pptr ) > 0 ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ;  ND_TCHECK2 ( tptr [ 0 ] , 3 ) ;   tlen = len ;  while ( tlen >= 3 ) { type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" ,  tok2str ( bgp_aigp_values , ""Unknown"" , type ) ,  type , length ) ) ;   ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ;  switch ( type ) { case BGP_AIGP_TLV :  ND_TCHECK2 ( tptr [ 3 ] , 8 ) ;  ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 ,  EXTRACT_64BITS ( tptr + 3 ) ) ) ;  break ; default : if ( ndo -> ndo_vflag <= 1 ) {  print_unknown_data ( ndo , tptr + 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length - 3 ) ;  } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }","type = * tptr ;length = EXTRACT_16BITS ( tptr + 1 ) ;tlen -= 3 ;ND_PRINT ( ( ndo , ""\\\if ( length < 3 ) goto trunc ;length -= 3 ;ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ;switch ( type ) {case BGP_AIGP_TLV : ND_TCHECK2 ( tptr [ 3 ] , 8 ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr + 3 ) ) ) ;print_unknown_data ( ndo , tptr + 3 , ""\\\",2337
254,"buggy line: case 2 :  # line 106 ""hex_grammar.y""  {# line 1330 ""hex_grammar.c""  break ;case 3 :  # line 115 ""hex_grammar.y""  {# line 1338 ""hex_grammar.c""  break ;case 4 :  # line 119 ""hex_grammar.y""  {# line 1351 ""hex_grammar.c""  break ;case 5 :  # line 128 ""hex_grammar.y""  {RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;( yyval . re_node ) = NULL ;cwe id:CWE-674context: int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 :  # line 106 ""hex_grammar.y""  { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; }  # line 1330 ""hex_grammar.c""  break ; case 3 :  # line 115 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1338 ""hex_grammar.c""  break ; case 4 :  # line 119 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1351 ""hex_grammar.c""  break ; case 5 :  # line 128 ""hex_grammar.y""  { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ;  RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;  ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1413 ""hex_grammar.c""  break ; case 6 :  # line 190 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1421 ""hex_grammar.c""  break ; case 7 :  # line 194 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1434 ""hex_grammar.c""  break ; case 8 :  # line 207 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1442 ""hex_grammar.c""  break ; case 9 :  # line 211 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; }  # line 1451 ""hex_grammar.c""  break ; case 10 :  # line 220 ""hex_grammar.y""  { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , ""string<S2SV_blank>too<S2SV_blank>long"" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1468 ""hex_grammar.c""  break ; case 11 :  # line 233 ""hex_grammar.y""  { lex_env -> inside_or ++ ; }  # line 1476 ""hex_grammar.c""  break ; case 12 :  # line 237 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; }  # line 1485 ""hex_grammar.c""  break ; case 13 :  # line 246 ""hex_grammar.y""  { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1512 ""hex_grammar.c""  break ; case 14 :  # line 269 ""hex_grammar.y""  { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>range"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1548 ""hex_grammar.c""  break ; case 15 :  # line 301 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1574 ""hex_grammar.c""  break ; case 16 :  # line 323 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1594 ""hex_grammar.c""  break ; case 17 :  # line 343 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1602 ""hex_grammar.c""  break ; case 18 :  # line 347 ""hex_grammar.y""  { mark_as_not_fast_regexp ( ) ;  ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;  DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1617 ""hex_grammar.c""  break ; case 19 :  # line 361 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; }  # line 1629 ""hex_grammar.c""  break ; case 20 :  # line 369 ""hex_grammar.y""  { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } }  # line 1653 ""hex_grammar.c""  break ;  # line 1657 ""hex_grammar.c""  default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }","case 2 : # line 113 ""hex_grammar.y"" {# line 1337 ""hex_grammar.c"" break ;case 3 : # line 122 ""hex_grammar.y"" {# line 1345 ""hex_grammar.c"" break ;case 4 : # line 126 ""hex_grammar.y"" {incr_ast_levels ( ) ;# line 1360 ""hex_grammar.c"" break ;case 5 : # line 137 ""hex_grammar.y"" {RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;incr_ast_levels ( ) ;( yyval . re_node ) = NULL ;",2338
255,"buggy line: # line 1413 ""hex_grammar.c""  break ;case 6 :  # line 190 ""hex_grammar.y""  {# line 1421 ""hex_grammar.c""  break ;case 7 :  # line 194 ""hex_grammar.y""  {# line 1434 ""hex_grammar.c""  break ;case 8 :  # line 207 ""hex_grammar.y""  {# line 1442 ""hex_grammar.c""  break ;case 9 :  # line 211 ""hex_grammar.y""  {# line 1451 ""hex_grammar.c""  break ;case 10 :  # line 220 ""hex_grammar.y""  {cwe id:CWE-674context: int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 :  # line 106 ""hex_grammar.y""  { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; }  # line 1330 ""hex_grammar.c""  break ; case 3 :  # line 115 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1338 ""hex_grammar.c""  break ; case 4 :  # line 119 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1351 ""hex_grammar.c""  break ; case 5 :  # line 128 ""hex_grammar.y""  { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ;  RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;  ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1413 ""hex_grammar.c""  break ; case 6 :  # line 190 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1421 ""hex_grammar.c""  break ; case 7 :  # line 194 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1434 ""hex_grammar.c""  break ; case 8 :  # line 207 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1442 ""hex_grammar.c""  break ; case 9 :  # line 211 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; }  # line 1451 ""hex_grammar.c""  break ; case 10 :  # line 220 ""hex_grammar.y""  { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , ""string<S2SV_blank>too<S2SV_blank>long"" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1468 ""hex_grammar.c""  break ; case 11 :  # line 233 ""hex_grammar.y""  { lex_env -> inside_or ++ ; }  # line 1476 ""hex_grammar.c""  break ; case 12 :  # line 237 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; }  # line 1485 ""hex_grammar.c""  break ; case 13 :  # line 246 ""hex_grammar.y""  { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1512 ""hex_grammar.c""  break ; case 14 :  # line 269 ""hex_grammar.y""  { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>range"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1548 ""hex_grammar.c""  break ; case 15 :  # line 301 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1574 ""hex_grammar.c""  break ; case 16 :  # line 323 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1594 ""hex_grammar.c""  break ; case 17 :  # line 343 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1602 ""hex_grammar.c""  break ; case 18 :  # line 347 ""hex_grammar.y""  { mark_as_not_fast_regexp ( ) ;  ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;  DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1617 ""hex_grammar.c""  break ; case 19 :  # line 361 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; }  # line 1629 ""hex_grammar.c""  break ; case 20 :  # line 369 ""hex_grammar.y""  { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } }  # line 1653 ""hex_grammar.c""  break ;  # line 1657 ""hex_grammar.c""  default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }","# line 1424 ""hex_grammar.c"" break ;case 6 : # line 201 ""hex_grammar.y"" {# line 1432 ""hex_grammar.c"" break ;case 7 : # line 205 ""hex_grammar.y"" {incr_ast_levels ( ) ;# line 1447 ""hex_grammar.c"" break ;case 8 : # line 220 ""hex_grammar.y"" {# line 1455 ""hex_grammar.c"" break ;case 9 : # line 224 ""hex_grammar.y"" {# line 1464 ""hex_grammar.c"" break ;case 10 : # line 233 ""hex_grammar.y"" {",2338
256,"buggy line: # line 1468 ""hex_grammar.c""  break ;case 11 :  # line 233 ""hex_grammar.y""  {# line 1476 ""hex_grammar.c""  break ;case 12 :  # line 237 ""hex_grammar.y""  {# line 1485 ""hex_grammar.c""  break ;case 13 :  # line 246 ""hex_grammar.y""  {cwe id:CWE-674context: int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 :  # line 106 ""hex_grammar.y""  { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; }  # line 1330 ""hex_grammar.c""  break ; case 3 :  # line 115 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1338 ""hex_grammar.c""  break ; case 4 :  # line 119 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1351 ""hex_grammar.c""  break ; case 5 :  # line 128 ""hex_grammar.y""  { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ;  RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;  ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1413 ""hex_grammar.c""  break ; case 6 :  # line 190 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1421 ""hex_grammar.c""  break ; case 7 :  # line 194 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1434 ""hex_grammar.c""  break ; case 8 :  # line 207 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1442 ""hex_grammar.c""  break ; case 9 :  # line 211 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; }  # line 1451 ""hex_grammar.c""  break ; case 10 :  # line 220 ""hex_grammar.y""  { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , ""string<S2SV_blank>too<S2SV_blank>long"" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1468 ""hex_grammar.c""  break ; case 11 :  # line 233 ""hex_grammar.y""  { lex_env -> inside_or ++ ; }  # line 1476 ""hex_grammar.c""  break ; case 12 :  # line 237 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; }  # line 1485 ""hex_grammar.c""  break ; case 13 :  # line 246 ""hex_grammar.y""  { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1512 ""hex_grammar.c""  break ; case 14 :  # line 269 ""hex_grammar.y""  { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>range"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1548 ""hex_grammar.c""  break ; case 15 :  # line 301 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1574 ""hex_grammar.c""  break ; case 16 :  # line 323 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1594 ""hex_grammar.c""  break ; case 17 :  # line 343 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1602 ""hex_grammar.c""  break ; case 18 :  # line 347 ""hex_grammar.y""  { mark_as_not_fast_regexp ( ) ;  ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;  DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1617 ""hex_grammar.c""  break ; case 19 :  # line 361 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; }  # line 1629 ""hex_grammar.c""  break ; case 20 :  # line 369 ""hex_grammar.y""  { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } }  # line 1653 ""hex_grammar.c""  break ;  # line 1657 ""hex_grammar.c""  default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }","# line 1481 ""hex_grammar.c"" break ;case 11 : # line 246 ""hex_grammar.y"" {# line 1489 ""hex_grammar.c"" break ;case 12 : # line 250 ""hex_grammar.y"" {# line 1498 ""hex_grammar.c"" break ;case 13 : # line 259 ""hex_grammar.y"" {",2338
257,"buggy line: # line 1512 ""hex_grammar.c""  break ;case 14 :  # line 269 ""hex_grammar.y""  {cwe id:CWE-674context: int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 :  # line 106 ""hex_grammar.y""  { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; }  # line 1330 ""hex_grammar.c""  break ; case 3 :  # line 115 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1338 ""hex_grammar.c""  break ; case 4 :  # line 119 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1351 ""hex_grammar.c""  break ; case 5 :  # line 128 ""hex_grammar.y""  { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ;  RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;  ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1413 ""hex_grammar.c""  break ; case 6 :  # line 190 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1421 ""hex_grammar.c""  break ; case 7 :  # line 194 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1434 ""hex_grammar.c""  break ; case 8 :  # line 207 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1442 ""hex_grammar.c""  break ; case 9 :  # line 211 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; }  # line 1451 ""hex_grammar.c""  break ; case 10 :  # line 220 ""hex_grammar.y""  { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , ""string<S2SV_blank>too<S2SV_blank>long"" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1468 ""hex_grammar.c""  break ; case 11 :  # line 233 ""hex_grammar.y""  { lex_env -> inside_or ++ ; }  # line 1476 ""hex_grammar.c""  break ; case 12 :  # line 237 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; }  # line 1485 ""hex_grammar.c""  break ; case 13 :  # line 246 ""hex_grammar.y""  { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1512 ""hex_grammar.c""  break ; case 14 :  # line 269 ""hex_grammar.y""  { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>range"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1548 ""hex_grammar.c""  break ; case 15 :  # line 301 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1574 ""hex_grammar.c""  break ; case 16 :  # line 323 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1594 ""hex_grammar.c""  break ; case 17 :  # line 343 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1602 ""hex_grammar.c""  break ; case 18 :  # line 347 ""hex_grammar.y""  { mark_as_not_fast_regexp ( ) ;  ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;  DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1617 ""hex_grammar.c""  break ; case 19 :  # line 361 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; }  # line 1629 ""hex_grammar.c""  break ; case 20 :  # line 369 ""hex_grammar.y""  { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } }  # line 1653 ""hex_grammar.c""  break ;  # line 1657 ""hex_grammar.c""  default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }","# line 1525 ""hex_grammar.c"" break ;case 14 : # line 282 ""hex_grammar.y"" {",2338
258,"buggy line: # line 1548 ""hex_grammar.c""  break ;case 15 :  # line 301 ""hex_grammar.y""  {cwe id:CWE-674context: int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 :  # line 106 ""hex_grammar.y""  { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; }  # line 1330 ""hex_grammar.c""  break ; case 3 :  # line 115 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1338 ""hex_grammar.c""  break ; case 4 :  # line 119 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1351 ""hex_grammar.c""  break ; case 5 :  # line 128 ""hex_grammar.y""  { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ;  RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;  ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1413 ""hex_grammar.c""  break ; case 6 :  # line 190 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1421 ""hex_grammar.c""  break ; case 7 :  # line 194 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1434 ""hex_grammar.c""  break ; case 8 :  # line 207 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1442 ""hex_grammar.c""  break ; case 9 :  # line 211 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; }  # line 1451 ""hex_grammar.c""  break ; case 10 :  # line 220 ""hex_grammar.y""  { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , ""string<S2SV_blank>too<S2SV_blank>long"" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1468 ""hex_grammar.c""  break ; case 11 :  # line 233 ""hex_grammar.y""  { lex_env -> inside_or ++ ; }  # line 1476 ""hex_grammar.c""  break ; case 12 :  # line 237 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; }  # line 1485 ""hex_grammar.c""  break ; case 13 :  # line 246 ""hex_grammar.y""  { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1512 ""hex_grammar.c""  break ; case 14 :  # line 269 ""hex_grammar.y""  { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>range"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1548 ""hex_grammar.c""  break ; case 15 :  # line 301 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1574 ""hex_grammar.c""  break ; case 16 :  # line 323 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1594 ""hex_grammar.c""  break ; case 17 :  # line 343 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1602 ""hex_grammar.c""  break ; case 18 :  # line 347 ""hex_grammar.y""  { mark_as_not_fast_regexp ( ) ;  ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;  DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1617 ""hex_grammar.c""  break ; case 19 :  # line 361 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; }  # line 1629 ""hex_grammar.c""  break ; case 20 :  # line 369 ""hex_grammar.y""  { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } }  # line 1653 ""hex_grammar.c""  break ;  # line 1657 ""hex_grammar.c""  default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }","# line 1561 ""hex_grammar.c"" break ;case 15 : # line 314 ""hex_grammar.y"" {",2338
259,"buggy line: # line 1574 ""hex_grammar.c""  break ;case 16 :  # line 323 ""hex_grammar.y""  {cwe id:CWE-674context: int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 :  # line 106 ""hex_grammar.y""  { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; }  # line 1330 ""hex_grammar.c""  break ; case 3 :  # line 115 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1338 ""hex_grammar.c""  break ; case 4 :  # line 119 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1351 ""hex_grammar.c""  break ; case 5 :  # line 128 ""hex_grammar.y""  { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ;  RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;  ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1413 ""hex_grammar.c""  break ; case 6 :  # line 190 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1421 ""hex_grammar.c""  break ; case 7 :  # line 194 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1434 ""hex_grammar.c""  break ; case 8 :  # line 207 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1442 ""hex_grammar.c""  break ; case 9 :  # line 211 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; }  # line 1451 ""hex_grammar.c""  break ; case 10 :  # line 220 ""hex_grammar.y""  { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , ""string<S2SV_blank>too<S2SV_blank>long"" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1468 ""hex_grammar.c""  break ; case 11 :  # line 233 ""hex_grammar.y""  { lex_env -> inside_or ++ ; }  # line 1476 ""hex_grammar.c""  break ; case 12 :  # line 237 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; }  # line 1485 ""hex_grammar.c""  break ; case 13 :  # line 246 ""hex_grammar.y""  { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1512 ""hex_grammar.c""  break ; case 14 :  # line 269 ""hex_grammar.y""  { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>range"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1548 ""hex_grammar.c""  break ; case 15 :  # line 301 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1574 ""hex_grammar.c""  break ; case 16 :  # line 323 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1594 ""hex_grammar.c""  break ; case 17 :  # line 343 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1602 ""hex_grammar.c""  break ; case 18 :  # line 347 ""hex_grammar.y""  { mark_as_not_fast_regexp ( ) ;  ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;  DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1617 ""hex_grammar.c""  break ; case 19 :  # line 361 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; }  # line 1629 ""hex_grammar.c""  break ; case 20 :  # line 369 ""hex_grammar.y""  { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } }  # line 1653 ""hex_grammar.c""  break ;  # line 1657 ""hex_grammar.c""  default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }","# line 1587 ""hex_grammar.c"" break ;case 16 : # line 336 ""hex_grammar.y"" {",2338
260,"buggy line: # line 1594 ""hex_grammar.c""  break ;case 17 :  # line 343 ""hex_grammar.y""  {# line 1602 ""hex_grammar.c""  break ;case 18 :  # line 347 ""hex_grammar.y""  {( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1617 ""hex_grammar.c""  break ;case 19 :  # line 361 ""hex_grammar.y""  {# line 1629 ""hex_grammar.c""  break ;case 20 :  # line 369 ""hex_grammar.y""  {cwe id:CWE-674context: int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 :  # line 106 ""hex_grammar.y""  { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; }  # line 1330 ""hex_grammar.c""  break ; case 3 :  # line 115 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1338 ""hex_grammar.c""  break ; case 4 :  # line 119 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1351 ""hex_grammar.c""  break ; case 5 :  # line 128 ""hex_grammar.y""  { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ;  RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;  ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1413 ""hex_grammar.c""  break ; case 6 :  # line 190 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1421 ""hex_grammar.c""  break ; case 7 :  # line 194 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1434 ""hex_grammar.c""  break ; case 8 :  # line 207 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1442 ""hex_grammar.c""  break ; case 9 :  # line 211 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; }  # line 1451 ""hex_grammar.c""  break ; case 10 :  # line 220 ""hex_grammar.y""  { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , ""string<S2SV_blank>too<S2SV_blank>long"" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1468 ""hex_grammar.c""  break ; case 11 :  # line 233 ""hex_grammar.y""  { lex_env -> inside_or ++ ; }  # line 1476 ""hex_grammar.c""  break ; case 12 :  # line 237 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; }  # line 1485 ""hex_grammar.c""  break ; case 13 :  # line 246 ""hex_grammar.y""  { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1512 ""hex_grammar.c""  break ; case 14 :  # line 269 ""hex_grammar.y""  { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>range"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1548 ""hex_grammar.c""  break ; case 15 :  # line 301 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1574 ""hex_grammar.c""  break ; case 16 :  # line 323 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1594 ""hex_grammar.c""  break ; case 17 :  # line 343 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1602 ""hex_grammar.c""  break ; case 18 :  # line 347 ""hex_grammar.y""  { mark_as_not_fast_regexp ( ) ;  ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;  DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1617 ""hex_grammar.c""  break ; case 19 :  # line 361 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; }  # line 1629 ""hex_grammar.c""  break ; case 20 :  # line 369 ""hex_grammar.y""  { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } }  # line 1653 ""hex_grammar.c""  break ;  # line 1657 ""hex_grammar.c""  default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }","# line 1607 ""hex_grammar.c"" break ;case 17 : # line 356 ""hex_grammar.y"" {# line 1615 ""hex_grammar.c"" break ;case 18 : # line 360 ""hex_grammar.y"" {incr_ast_levels ( ) ;( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1631 ""hex_grammar.c"" break ;case 19 : # line 375 ""hex_grammar.y"" {# line 1643 ""hex_grammar.c"" break ;case 20 : # line 383 ""hex_grammar.y"" {",2338
261,"buggy line: # line 1653 ""hex_grammar.c""  break ;# line 1657 ""hex_grammar.c""  default : break ;cwe id:CWE-674context: int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 :  # line 106 ""hex_grammar.y""  { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; }  # line 1330 ""hex_grammar.c""  break ; case 3 :  # line 115 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1338 ""hex_grammar.c""  break ; case 4 :  # line 119 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1351 ""hex_grammar.c""  break ; case 5 :  # line 128 ""hex_grammar.y""  { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ;  RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;  ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1413 ""hex_grammar.c""  break ; case 6 :  # line 190 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1421 ""hex_grammar.c""  break ; case 7 :  # line 194 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1434 ""hex_grammar.c""  break ; case 8 :  # line 207 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1442 ""hex_grammar.c""  break ; case 9 :  # line 211 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; }  # line 1451 ""hex_grammar.c""  break ; case 10 :  # line 220 ""hex_grammar.y""  { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , ""string<S2SV_blank>too<S2SV_blank>long"" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1468 ""hex_grammar.c""  break ; case 11 :  # line 233 ""hex_grammar.y""  { lex_env -> inside_or ++ ; }  # line 1476 ""hex_grammar.c""  break ; case 12 :  # line 237 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; }  # line 1485 ""hex_grammar.c""  break ; case 13 :  # line 246 ""hex_grammar.y""  { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1512 ""hex_grammar.c""  break ; case 14 :  # line 269 ""hex_grammar.y""  { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>range"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; }  # line 1548 ""hex_grammar.c""  break ; case 15 :  # line 301 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1574 ""hex_grammar.c""  break ; case 16 :  # line 323 ""hex_grammar.y""  { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; }  # line 1594 ""hex_grammar.c""  break ; case 17 :  # line 343 ""hex_grammar.y""  { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; }  # line 1602 ""hex_grammar.c""  break ; case 18 :  # line 347 ""hex_grammar.y""  { mark_as_not_fast_regexp ( ) ;  ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;  DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; }  # line 1617 ""hex_grammar.c""  break ; case 19 :  # line 361 ""hex_grammar.y""  { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; }  # line 1629 ""hex_grammar.c""  break ; case 20 :  # line 369 ""hex_grammar.y""  { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } }  # line 1653 ""hex_grammar.c""  break ;  # line 1657 ""hex_grammar.c""  default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }","# line 1667 ""hex_grammar.c"" break ;# line 1657 ""hex_grammar.c"" default : break ;",2338
262,"buggy line: char group [ LONG_STRING ] ;char desc [ HUGE_STRING ] = """" ;if ( sscanf ( line , ""%s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\\nntp_data = nntp_data_find ( nserv , group ) ;cwe id:CWE-119context: int nntp_add_group ( char * line , void * data ) { struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ;  char group [ LONG_STRING ] ;  char desc [ HUGE_STRING ] = """" ; char mod ; anum_t first , last ; if ( ! nserv || ! line ) return 0 ;  if ( sscanf ( line , ""%s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\n]"" , group , & last , & first , & mod , desc ) < 4 )   return 0 ;  nntp_data = nntp_data_find ( nserv , group ) ; nntp_data -> deleted = false ; nntp_data -> first_message = first ; nntp_data -> last_message = last ; nntp_data -> allowed = ( mod == 'y' ) || ( mod == 'm' ) ; mutt_str_replace ( & nntp_data -> desc , desc ) ; if ( nntp_data -> newsrc_ent || nntp_data -> last_cached ) nntp_group_unread_stat ( nntp_data ) ; else if ( nntp_data -> last_message && nntp_data -> first_message <= nntp_data -> last_message ) nntp_data -> unread = nntp_data -> last_message - nntp_data -> first_message + 1 ; else nntp_data -> unread = 0 ; return 0 ; }","char group [ LONG_STRING ] = """" ;char desc [ HUGE_STRING ] = """" ;if ( sscanf ( line , ""%1023s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\\mutt_debug ( 4 , ""Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\\return 0 ;}nntp_data = nntp_data_find ( nserv , group ) ;",2339
263,"buggy line: pStorage -> picSizeInMbs =  pStorage -> activeSps -> picWidthInMbs *  pStorage -> activeSps -> picHeightInMbs ;pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ;cwe id:CWE-119context: u32 h264bsdActivateParamSets ( storage_t * pStorage , u32 ppsId , u32 isIdr ) { u32 tmp ; u32 flag ; ASSERT ( pStorage ) ; ASSERT ( ppsId < MAX_NUM_PIC_PARAM_SETS ) ; if ( ( pStorage -> pps [ ppsId ] == NULL ) || ( pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] == NULL ) ) { return ( HANTRO_NOK ) ; } tmp = CheckPps ( pStorage -> pps [ ppsId ] , pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] ) ; if ( tmp != HANTRO_OK ) return ( tmp ) ; if ( pStorage -> activePpsId == MAX_NUM_PIC_PARAM_SETS ) { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ;  pStorage -> picSizeInMbs =  pStorage -> activeSps -> picWidthInMbs *  pStorage -> activeSps -> picHeightInMbs ;  pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; pStorage -> pendingActivation = HANTRO_TRUE ; } else if ( pStorage -> pendingActivation ) { pStorage -> pendingActivation = HANTRO_FALSE ; FREE ( pStorage -> mb ) ; FREE ( pStorage -> sliceGroupMap ) ; ALLOCATE ( pStorage -> mb , pStorage -> picSizeInMbs , mbStorage_t ) ; ALLOCATE ( pStorage -> sliceGroupMap , pStorage -> picSizeInMbs , u32 ) ; if ( pStorage -> mb == NULL || pStorage -> sliceGroupMap == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( pStorage -> mb , 0 , pStorage -> picSizeInMbs * sizeof ( mbStorage_t ) ) ; h264bsdInitMbNeighbours ( pStorage -> mb , pStorage -> activeSps -> picWidthInMbs , pStorage -> picSizeInMbs ) ; if ( pStorage -> noReordering || pStorage -> activeSps -> picOrderCntType == 2 || ( pStorage -> activeSps -> vuiParametersPresentFlag && pStorage -> activeSps -> vuiParameters -> bitstreamRestrictionFlag && ! pStorage -> activeSps -> vuiParameters -> numReorderFrames ) ) flag = HANTRO_TRUE ; else flag = HANTRO_FALSE ; tmp = h264bsdResetDpb ( pStorage -> dpb , pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs , pStorage -> activeSps -> maxDpbSize , pStorage -> activeSps -> numRefFrames , pStorage -> activeSps -> maxFrameNum , flag ) ; if ( tmp != HANTRO_OK ) return ( tmp ) ; } else if ( ppsId != pStorage -> activePpsId ) { if ( pStorage -> pps [ ppsId ] -> seqParameterSetId != pStorage -> activeSpsId ) { DEBUG ( ( ""SEQ<S2SV_blank>PARAM<S2SV_blank>SET<S2SV_blank>CHANGING...\\n"" ) ) ; if ( isIdr ) { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; pStorage -> picSizeInMbs = pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs ; pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; pStorage -> pendingActivation = HANTRO_TRUE ; } else { DEBUG ( ( ""TRYING<S2SV_blank>TO<S2SV_blank>CHANGE<S2SV_blank>SPS<S2SV_blank>IN<S2SV_blank>NON-IDR<S2SV_blank>SLICE\\n"" ) ) ; return ( HANTRO_NOK ) ; } } else { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; } } return ( HANTRO_OK ) ; }",if ( pStorage -> activeSps -> picWidthInMbs == 0 ) {pStorage -> picSizeInMbs = 0 ;}else if ( pStorage -> activeSps -> picHeightInMbs > UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) {return ( MEMORY_ALLOCATION_ERROR ) ;}else {pStorage -> picSizeInMbs = pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs ;}pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ;,2340
264,"buggy line: if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {coerce_reg_to_size ( dst_reg , 4 ) ;coerce_reg_to_size ( & src_reg , 4 ) ;}cwe id:CWE-119context: static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ;  if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {  coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH :  if ( umax_val > 63 ) {  mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH :  if ( umax_val > 63 ) {  mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; }  __reg_deduce_bounds ( dst_reg ) ;  __reg_bound_offset ( dst_reg ) ; return 0 ; }",u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;,2341
265,"buggy line: if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}break ;case BPF_AND : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = dst_reg -> var_off . value ;dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ;dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ;dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_LSH :  if ( umax_val > 63 ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;cwe id:CWE-119context: static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ;  if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {  coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH :  if ( umax_val > 63 ) {  mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH :  if ( umax_val > 63 ) {  mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; }  __reg_deduce_bounds ( dst_reg ) ;  __reg_bound_offset ( dst_reg ) ; return 0 ; }","if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {coerce_reg_to_size ( dst_reg , 4 ) ;coerce_reg_to_size ( & src_reg , 4 ) ;",2341
266,"buggy line: case BPF_RSH :  if ( umax_val > 63 ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;cwe id:CWE-119context: static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ;  if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {  coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH :  if ( umax_val > 63 ) {  mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH :  if ( umax_val > 63 ) {  mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; }  __reg_deduce_bounds ( dst_reg ) ;  __reg_bound_offset ( dst_reg ) ; return 0 ; }","case BPF_RSH : if ( umax_val > 63 ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;",2341
267,"buggy line: __reg_deduce_bounds ( dst_reg ) ;__reg_bound_offset ( dst_reg ) ;cwe id:CWE-119context: static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ;  if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {  coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH :  if ( umax_val > 63 ) {  mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH :  if ( umax_val > 63 ) {  mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; }  __reg_deduce_bounds ( dst_reg ) ;  __reg_bound_offset ( dst_reg ) ; return 0 ; }",__reg_deduce_bounds ( dst_reg ) ;__reg_bound_offset ( dst_reg ) ;,2341
268,"buggy line: tdata_t tilebuf ;uint32 imagew = TIFFScanlineSize ( in ) ;uint32 tilew = TIFFTileRowSize ( in ) ;int iskew = imagew - tilew ;uint8 * bufp = ( uint8 * ) buf ;cwe id:CWE-119context: DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ;  int iskew = imagew - tilew ;  uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; for ( col = 0 ; col < imagewidth && colb < imagew ; col += tw ) { if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>%lu<S2SV_blank>%lu"" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; }  if ( colb + tilew > imagew ) {  uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf , nrow , width , oskew + iskew , oskew ) ; } else cpStripToTile ( bufp + colb , tilebuf , nrow , tilew , iskew , 0 ) ; colb += tilew ; } bufp += imagew * nrow ; } done : _TIFFfree ( tilebuf ) ; return status ; }",int64 iskew = ( int64 ) imagew - ( int64 ) tilew ;uint8 * bufp = ( uint8 * ) buf ;,2342
269,"buggy line: if ( colb + tilew > imagew ) {uint32 width = imagew - colb ;cwe id:CWE-119context: DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ;  int iskew = imagew - tilew ;  uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; for ( col = 0 ; col < imagewidth && colb < imagew ; col += tw ) { if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>%lu<S2SV_blank>%lu"" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; }  if ( colb + tilew > imagew ) {  uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf , nrow , width , oskew + iskew , oskew ) ; } else cpStripToTile ( bufp + colb , tilebuf , nrow , tilew , iskew , 0 ) ; colb += tilew ; } bufp += imagew * nrow ; } done : _TIFFfree ( tilebuf ) ; return status ; }",if ( colb > iskew ) {uint32 width = imagew - colb ;,2342
270,"buggy line: if ( ! ( dev -> flags & IFF_UP ) )  return NET_RX_DROP ;if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) )   return NET_RX_DROP ;skb_set_dev ( skb , dev ) ;cwe id:CWE-399context: int dev_forward_skb ( struct net_device * dev , struct sk_buff * skb ) { skb_orphan ( skb ) ;  if ( ! ( dev -> flags & IFF_UP ) )  return NET_RX_DROP ;  if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) )   return NET_RX_DROP ;  skb_set_dev ( skb , dev ) ; skb -> tstamp . tv64 = 0 ; skb -> pkt_type = PACKET_HOST ; skb -> protocol = eth_type_trans ( skb , dev ) ; return netif_rx ( skb ) ; }","if ( ! ( dev -> flags & IFF_UP ) || ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) ) {kfree_skb ( skb ) ;return NET_RX_DROP ;}skb_set_dev ( skb , dev ) ;",2343
271,"buggy line: else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL )  {else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL )  {cwe id:CWE-284context: static void cs_cmd_flags ( sourceinfo_t * si , int parc , char * parv [ ] ) { chanacs_t * ca ; mowgli_node_t * n ; char * channel = parv [ 0 ] ; char * target = sstrdup ( parv [ 1 ] ) ; char * flagstr = parv [ 2 ] ; const char * str1 ; unsigned int addflags , removeflags , restrictflags ; hook_channel_acl_req_t req ; mychan_t * mc ; if ( parc < 1 ) { command_fail ( si , fault_needmoreparams , STR_INSUFFICIENT_PARAMS , ""FLAGS"" ) ; command_fail ( si , fault_needmoreparams , _ ( ""Syntax:<S2SV_blank>FLAGS<S2SV_blank><channel><S2SV_blank>[target]<S2SV_blank>[flags]"" ) ) ; return ; } mc = mychan_find ( channel ) ; if ( ! mc ) { command_fail ( si , fault_nosuch_target , _ ( ""Channel<S2SV_blank>\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered."" ) , channel ) ; return ; } if ( metadata_find ( mc , ""private:close:closer"" ) && ( target || ! has_priv ( si , PRIV_CHAN_AUSPEX ) ) ) { command_fail ( si , fault_noprivs , _ ( ""\\2%s\\2<S2SV_blank>is<S2SV_blank>closed."" ) , channel ) ; return ; } if ( ! target || ( target && target [ 0 ] == '+' && flagstr == NULL ) ) { unsigned int flags = ( target != NULL ) ? flags_to_bitmask ( target , 0 ) : 0 ; do_list ( si , mc , flags ) ; return ; }  else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL )  { do_list ( si , mc , 0 ) ; free ( target ) ; return ; }  else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL )  { free ( target ) ; if ( ! chanacs_source_has_flag ( mc , si , CA_FOUNDER ) ) { command_fail ( si , fault_noprivs , ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>perform<S2SV_blank>this<S2SV_blank>operation."" ) ; return ; } mowgli_node_t * tn ; MOWGLI_ITER_FOREACH_SAFE ( n , tn , mc -> chanacs . head ) { ca = n -> data ; if ( ca -> level & CA_FOUNDER ) continue ; object_unref ( ca ) ; } logcommand ( si , CMDLOG_DO , ""CLEAR:FLAGS:<S2SV_blank>\\2%s\\2"" , mc -> name ) ; command_success_nodata ( si , _ ( ""Cleared<S2SV_blank>flags<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , mc -> name ) ; return ; }  else if ( ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL )  { free ( target ) ; if ( parc < 3 ) { command_fail ( si , fault_needmoreparams , STR_INSUFFICIENT_PARAMS , ""FLAGS"" ) ; command_fail ( si , fault_needmoreparams , _ ( ""Syntax:<S2SV_blank>FLAGS<S2SV_blank><#channel><S2SV_blank>MODIFY<S2SV_blank>[target]<S2SV_blank><flags>"" ) ) ; return ; } flagstr = strchr ( parv [ 2 ] , '<S2SV_blank>' ) ; if ( flagstr ) * flagstr ++ = '\\0' ; target = strdup ( parv [ 2 ] ) ; } { myentity_t * mt ; if ( ! si -> smu ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>logged<S2SV_blank>in."" ) ) ; return ; } if ( ! flagstr ) { if ( ! ( mc -> flags & MC_PUBACL ) && ! chanacs_source_has_flag ( mc , si , CA_ACLVIEW ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>this<S2SV_blank>command."" ) ) ; return ; } if ( validhostmask ( target ) ) ca = chanacs_find_host_literal ( mc , target , 0 ) ; else { if ( ! ( mt = myentity_find_ext ( target ) ) ) { command_fail ( si , fault_nosuch_target , _ ( ""\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered."" ) , target ) ; return ; } free ( target ) ; target = sstrdup ( mt -> name ) ; ca = chanacs_find_literal ( mc , mt , 0 ) ; } if ( ca != NULL ) { str1 = bitmask_to_flags2 ( ca -> level , 0 ) ; command_success_string ( si , str1 , _ ( ""Flags<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2<S2SV_blank>are<S2SV_blank>\\2%s\\2."" ) , target , channel , str1 ) ; } else command_success_string ( si , """" , _ ( ""No<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , target , channel ) ; logcommand ( si , CMDLOG_GET , ""FLAGS:<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2"" , mc -> name , target ) ; return ; } restrictflags = chanacs_source_flags ( mc , si ) ; if ( restrictflags & CA_FOUNDER ) restrictflags = ca_all ; else { if ( ! ( restrictflags & CA_FLAGS ) ) { if ( restrictflags & CA_AKICK || si -> smu == NULL || irccasecmp ( target , entity ( si -> smu ) -> name ) || strcmp ( flagstr , ""-*"" ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>this<S2SV_blank>command."" ) ) ; return ; } } if ( irccasecmp ( target , entity ( si -> smu ) -> name ) ) restrictflags = allow_flags ( mc , restrictflags ) ; else restrictflags |= allow_flags ( mc , restrictflags ) ; } if ( * flagstr == '+' || * flagstr == '-' || * flagstr == '=' ) { flags_make_bitmasks ( flagstr , & addflags , & removeflags ) ; if ( addflags == 0 && removeflags == 0 ) { command_fail ( si , fault_badparams , _ ( ""No<S2SV_blank>valid<S2SV_blank>flags<S2SV_blank>given,<S2SV_blank>use<S2SV_blank>/%s%s<S2SV_blank>HELP<S2SV_blank>FLAGS<S2SV_blank>for<S2SV_blank>a<S2SV_blank>list"" ) , ircd -> uses_rcommand ? """" : ""msg<S2SV_blank>"" , chansvs . me -> disp ) ; return ; } } else { addflags = get_template_flags ( mc , flagstr ) ; if ( addflags == 0 ) { if ( * target == '+' || * target == '-' || * target == '=' ) command_fail ( si , fault_badparams , _ ( ""Usage:<S2SV_blank>FLAGS<S2SV_blank>%s<S2SV_blank>[target]<S2SV_blank>[flags]"" ) , mc -> name ) ; else command_fail ( si , fault_badparams , _ ( ""Invalid<S2SV_blank>template<S2SV_blank>name<S2SV_blank>given,<S2SV_blank>use<S2SV_blank>/%s%s<S2SV_blank>TEMPLATE<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>a<S2SV_blank>list"" ) , ircd -> uses_rcommand ? """" : ""msg<S2SV_blank>"" , chansvs . me -> disp , mc -> name ) ; return ; } removeflags = ca_all & ~ addflags ; } if ( ! validhostmask ( target ) ) { if ( ! ( mt = myentity_find_ext ( target ) ) ) { command_fail ( si , fault_nosuch_target , _ ( ""\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered."" ) , target ) ; return ; } free ( target ) ; target = sstrdup ( mt -> name ) ; ca = chanacs_open ( mc , mt , NULL , true , entity ( si -> smu ) ) ; if ( ca -> level & CA_FOUNDER && removeflags & CA_FLAGS && ! ( removeflags & CA_FOUNDER ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>a<S2SV_blank>founder\'s<S2SV_blank>+f<S2SV_blank>access."" ) ) ; return ; } if ( ca -> level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders ( mc ) == 1 ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>the<S2SV_blank>last<S2SV_blank>founder."" ) ) ; return ; } if ( ! ( ca -> level & CA_FOUNDER ) && addflags & CA_FOUNDER ) { if ( mychan_num_founders ( mc ) >= chansvs . maxfounders ) { command_fail ( si , fault_noprivs , _ ( ""Only<S2SV_blank>%d<S2SV_blank>founders<S2SV_blank>allowed<S2SV_blank>per<S2SV_blank>channel."" ) , chansvs . maxfounders ) ; chanacs_close ( ca ) ; return ; } if ( ! myentity_can_register_channel ( mt ) ) { command_fail ( si , fault_toomany , _ ( ""\\2%s\\2<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>channels<S2SV_blank>registered."" ) , mt -> name ) ; chanacs_close ( ca ) ; return ; } if ( ! myentity_allow_foundership ( mt ) ) { command_fail ( si , fault_toomany , _ ( ""\\2%s\\2<S2SV_blank>cannot<S2SV_blank>take<S2SV_blank>foundership<S2SV_blank>of<S2SV_blank>a<S2SV_blank>channel."" ) , mt -> name ) ; chanacs_close ( ca ) ; return ; } } if ( addflags & CA_FOUNDER ) addflags |= CA_FLAGS , removeflags &= ~ CA_FLAGS ; if ( isuser ( mt ) && ( MU_NEVEROP & user ( mt ) -> flags && addflags != CA_AKICK && addflags != 0 && ( ca -> level == 0 || ca -> level == CA_AKICK ) ) ) { command_fail ( si , fault_noprivs , _ ( ""\\2%s\\2<S2SV_blank>does<S2SV_blank>not<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>be<S2SV_blank>added<S2SV_blank>to<S2SV_blank>channel<S2SV_blank>access<S2SV_blank>lists<S2SV_blank>(NEVEROP<S2SV_blank>set)."" ) , mt -> name ) ; chanacs_close ( ca ) ; return ; } if ( ca -> level == 0 && chanacs_is_table_full ( ca ) ) { command_fail ( si , fault_toomany , _ ( ""Channel<S2SV_blank>%s<S2SV_blank>access<S2SV_blank>list<S2SV_blank>is<S2SV_blank>full."" ) , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . ca = ca ; req . oldlevel = ca -> level ; if ( ! chanacs_modify ( ca , & addflags , & removeflags , restrictflags ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , bitmask_to_flags2 ( addflags , removeflags ) , mt -> name , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . newlevel = ca -> level ; hook_call_channel_acl_change ( & req ) ; chanacs_close ( ca ) ; } else { if ( addflags & CA_FOUNDER ) { command_fail ( si , fault_badparams , _ ( ""You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>set<S2SV_blank>founder<S2SV_blank>status<S2SV_blank>on<S2SV_blank>a<S2SV_blank>hostmask."" ) ) ; return ; } ca = chanacs_open ( mc , NULL , target , true , entity ( si -> smu ) ) ; if ( ca -> level == 0 && chanacs_is_table_full ( ca ) ) { command_fail ( si , fault_toomany , _ ( ""Channel<S2SV_blank>%s<S2SV_blank>access<S2SV_blank>list<S2SV_blank>is<S2SV_blank>full."" ) , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . ca = ca ; req . oldlevel = ca -> level ; if ( ! chanacs_modify ( ca , & addflags , & removeflags , restrictflags ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , bitmask_to_flags2 ( addflags , removeflags ) , target , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . newlevel = ca -> level ; hook_call_channel_acl_change ( & req ) ; chanacs_close ( ca ) ; } if ( ( addflags | removeflags ) == 0 ) { command_fail ( si , fault_nochange , _ ( ""Channel<S2SV_blank>access<S2SV_blank>to<S2SV_blank>\\2%s\\2<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>unchanged."" ) , channel , target ) ; return ; } flagstr = bitmask_to_flags2 ( addflags , removeflags ) ; command_success_nodata ( si , _ ( ""Flags<S2SV_blank>\\2%s\\2<S2SV_blank>were<S2SV_blank>set<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , flagstr , target , channel ) ; logcommand ( si , CMDLOG_SET , ""FLAGS:<S2SV_blank>\\2%s\\2<S2SV_blank>\\2%s\\2<S2SV_blank>\\2%s\\2"" , mc -> name , target , flagstr ) ; verbose ( mc , ""\\2%s\\2<S2SV_blank>set<S2SV_blank>flags<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2"" , get_source_name ( si ) , flagstr , target ) ; } free ( target ) ; }","else if ( anope_flags_compat && ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL ) {else if ( anope_flags_compat && ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL ) {",2344
272,"buggy line: else if ( ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL )  {cwe id:CWE-284context: static void cs_cmd_flags ( sourceinfo_t * si , int parc , char * parv [ ] ) { chanacs_t * ca ; mowgli_node_t * n ; char * channel = parv [ 0 ] ; char * target = sstrdup ( parv [ 1 ] ) ; char * flagstr = parv [ 2 ] ; const char * str1 ; unsigned int addflags , removeflags , restrictflags ; hook_channel_acl_req_t req ; mychan_t * mc ; if ( parc < 1 ) { command_fail ( si , fault_needmoreparams , STR_INSUFFICIENT_PARAMS , ""FLAGS"" ) ; command_fail ( si , fault_needmoreparams , _ ( ""Syntax:<S2SV_blank>FLAGS<S2SV_blank><channel><S2SV_blank>[target]<S2SV_blank>[flags]"" ) ) ; return ; } mc = mychan_find ( channel ) ; if ( ! mc ) { command_fail ( si , fault_nosuch_target , _ ( ""Channel<S2SV_blank>\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered."" ) , channel ) ; return ; } if ( metadata_find ( mc , ""private:close:closer"" ) && ( target || ! has_priv ( si , PRIV_CHAN_AUSPEX ) ) ) { command_fail ( si , fault_noprivs , _ ( ""\\2%s\\2<S2SV_blank>is<S2SV_blank>closed."" ) , channel ) ; return ; } if ( ! target || ( target && target [ 0 ] == '+' && flagstr == NULL ) ) { unsigned int flags = ( target != NULL ) ? flags_to_bitmask ( target , 0 ) : 0 ; do_list ( si , mc , flags ) ; return ; }  else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL )  { do_list ( si , mc , 0 ) ; free ( target ) ; return ; }  else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL )  { free ( target ) ; if ( ! chanacs_source_has_flag ( mc , si , CA_FOUNDER ) ) { command_fail ( si , fault_noprivs , ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>perform<S2SV_blank>this<S2SV_blank>operation."" ) ; return ; } mowgli_node_t * tn ; MOWGLI_ITER_FOREACH_SAFE ( n , tn , mc -> chanacs . head ) { ca = n -> data ; if ( ca -> level & CA_FOUNDER ) continue ; object_unref ( ca ) ; } logcommand ( si , CMDLOG_DO , ""CLEAR:FLAGS:<S2SV_blank>\\2%s\\2"" , mc -> name ) ; command_success_nodata ( si , _ ( ""Cleared<S2SV_blank>flags<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , mc -> name ) ; return ; }  else if ( ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL )  { free ( target ) ; if ( parc < 3 ) { command_fail ( si , fault_needmoreparams , STR_INSUFFICIENT_PARAMS , ""FLAGS"" ) ; command_fail ( si , fault_needmoreparams , _ ( ""Syntax:<S2SV_blank>FLAGS<S2SV_blank><#channel><S2SV_blank>MODIFY<S2SV_blank>[target]<S2SV_blank><flags>"" ) ) ; return ; } flagstr = strchr ( parv [ 2 ] , '<S2SV_blank>' ) ; if ( flagstr ) * flagstr ++ = '\\0' ; target = strdup ( parv [ 2 ] ) ; } { myentity_t * mt ; if ( ! si -> smu ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>logged<S2SV_blank>in."" ) ) ; return ; } if ( ! flagstr ) { if ( ! ( mc -> flags & MC_PUBACL ) && ! chanacs_source_has_flag ( mc , si , CA_ACLVIEW ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>this<S2SV_blank>command."" ) ) ; return ; } if ( validhostmask ( target ) ) ca = chanacs_find_host_literal ( mc , target , 0 ) ; else { if ( ! ( mt = myentity_find_ext ( target ) ) ) { command_fail ( si , fault_nosuch_target , _ ( ""\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered."" ) , target ) ; return ; } free ( target ) ; target = sstrdup ( mt -> name ) ; ca = chanacs_find_literal ( mc , mt , 0 ) ; } if ( ca != NULL ) { str1 = bitmask_to_flags2 ( ca -> level , 0 ) ; command_success_string ( si , str1 , _ ( ""Flags<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2<S2SV_blank>are<S2SV_blank>\\2%s\\2."" ) , target , channel , str1 ) ; } else command_success_string ( si , """" , _ ( ""No<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , target , channel ) ; logcommand ( si , CMDLOG_GET , ""FLAGS:<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2"" , mc -> name , target ) ; return ; } restrictflags = chanacs_source_flags ( mc , si ) ; if ( restrictflags & CA_FOUNDER ) restrictflags = ca_all ; else { if ( ! ( restrictflags & CA_FLAGS ) ) { if ( restrictflags & CA_AKICK || si -> smu == NULL || irccasecmp ( target , entity ( si -> smu ) -> name ) || strcmp ( flagstr , ""-*"" ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>this<S2SV_blank>command."" ) ) ; return ; } } if ( irccasecmp ( target , entity ( si -> smu ) -> name ) ) restrictflags = allow_flags ( mc , restrictflags ) ; else restrictflags |= allow_flags ( mc , restrictflags ) ; } if ( * flagstr == '+' || * flagstr == '-' || * flagstr == '=' ) { flags_make_bitmasks ( flagstr , & addflags , & removeflags ) ; if ( addflags == 0 && removeflags == 0 ) { command_fail ( si , fault_badparams , _ ( ""No<S2SV_blank>valid<S2SV_blank>flags<S2SV_blank>given,<S2SV_blank>use<S2SV_blank>/%s%s<S2SV_blank>HELP<S2SV_blank>FLAGS<S2SV_blank>for<S2SV_blank>a<S2SV_blank>list"" ) , ircd -> uses_rcommand ? """" : ""msg<S2SV_blank>"" , chansvs . me -> disp ) ; return ; } } else { addflags = get_template_flags ( mc , flagstr ) ; if ( addflags == 0 ) { if ( * target == '+' || * target == '-' || * target == '=' ) command_fail ( si , fault_badparams , _ ( ""Usage:<S2SV_blank>FLAGS<S2SV_blank>%s<S2SV_blank>[target]<S2SV_blank>[flags]"" ) , mc -> name ) ; else command_fail ( si , fault_badparams , _ ( ""Invalid<S2SV_blank>template<S2SV_blank>name<S2SV_blank>given,<S2SV_blank>use<S2SV_blank>/%s%s<S2SV_blank>TEMPLATE<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>a<S2SV_blank>list"" ) , ircd -> uses_rcommand ? """" : ""msg<S2SV_blank>"" , chansvs . me -> disp , mc -> name ) ; return ; } removeflags = ca_all & ~ addflags ; } if ( ! validhostmask ( target ) ) { if ( ! ( mt = myentity_find_ext ( target ) ) ) { command_fail ( si , fault_nosuch_target , _ ( ""\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered."" ) , target ) ; return ; } free ( target ) ; target = sstrdup ( mt -> name ) ; ca = chanacs_open ( mc , mt , NULL , true , entity ( si -> smu ) ) ; if ( ca -> level & CA_FOUNDER && removeflags & CA_FLAGS && ! ( removeflags & CA_FOUNDER ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>a<S2SV_blank>founder\'s<S2SV_blank>+f<S2SV_blank>access."" ) ) ; return ; } if ( ca -> level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders ( mc ) == 1 ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>the<S2SV_blank>last<S2SV_blank>founder."" ) ) ; return ; } if ( ! ( ca -> level & CA_FOUNDER ) && addflags & CA_FOUNDER ) { if ( mychan_num_founders ( mc ) >= chansvs . maxfounders ) { command_fail ( si , fault_noprivs , _ ( ""Only<S2SV_blank>%d<S2SV_blank>founders<S2SV_blank>allowed<S2SV_blank>per<S2SV_blank>channel."" ) , chansvs . maxfounders ) ; chanacs_close ( ca ) ; return ; } if ( ! myentity_can_register_channel ( mt ) ) { command_fail ( si , fault_toomany , _ ( ""\\2%s\\2<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>channels<S2SV_blank>registered."" ) , mt -> name ) ; chanacs_close ( ca ) ; return ; } if ( ! myentity_allow_foundership ( mt ) ) { command_fail ( si , fault_toomany , _ ( ""\\2%s\\2<S2SV_blank>cannot<S2SV_blank>take<S2SV_blank>foundership<S2SV_blank>of<S2SV_blank>a<S2SV_blank>channel."" ) , mt -> name ) ; chanacs_close ( ca ) ; return ; } } if ( addflags & CA_FOUNDER ) addflags |= CA_FLAGS , removeflags &= ~ CA_FLAGS ; if ( isuser ( mt ) && ( MU_NEVEROP & user ( mt ) -> flags && addflags != CA_AKICK && addflags != 0 && ( ca -> level == 0 || ca -> level == CA_AKICK ) ) ) { command_fail ( si , fault_noprivs , _ ( ""\\2%s\\2<S2SV_blank>does<S2SV_blank>not<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>be<S2SV_blank>added<S2SV_blank>to<S2SV_blank>channel<S2SV_blank>access<S2SV_blank>lists<S2SV_blank>(NEVEROP<S2SV_blank>set)."" ) , mt -> name ) ; chanacs_close ( ca ) ; return ; } if ( ca -> level == 0 && chanacs_is_table_full ( ca ) ) { command_fail ( si , fault_toomany , _ ( ""Channel<S2SV_blank>%s<S2SV_blank>access<S2SV_blank>list<S2SV_blank>is<S2SV_blank>full."" ) , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . ca = ca ; req . oldlevel = ca -> level ; if ( ! chanacs_modify ( ca , & addflags , & removeflags , restrictflags ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , bitmask_to_flags2 ( addflags , removeflags ) , mt -> name , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . newlevel = ca -> level ; hook_call_channel_acl_change ( & req ) ; chanacs_close ( ca ) ; } else { if ( addflags & CA_FOUNDER ) { command_fail ( si , fault_badparams , _ ( ""You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>set<S2SV_blank>founder<S2SV_blank>status<S2SV_blank>on<S2SV_blank>a<S2SV_blank>hostmask."" ) ) ; return ; } ca = chanacs_open ( mc , NULL , target , true , entity ( si -> smu ) ) ; if ( ca -> level == 0 && chanacs_is_table_full ( ca ) ) { command_fail ( si , fault_toomany , _ ( ""Channel<S2SV_blank>%s<S2SV_blank>access<S2SV_blank>list<S2SV_blank>is<S2SV_blank>full."" ) , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . ca = ca ; req . oldlevel = ca -> level ; if ( ! chanacs_modify ( ca , & addflags , & removeflags , restrictflags ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , bitmask_to_flags2 ( addflags , removeflags ) , target , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . newlevel = ca -> level ; hook_call_channel_acl_change ( & req ) ; chanacs_close ( ca ) ; } if ( ( addflags | removeflags ) == 0 ) { command_fail ( si , fault_nochange , _ ( ""Channel<S2SV_blank>access<S2SV_blank>to<S2SV_blank>\\2%s\\2<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>unchanged."" ) , channel , target ) ; return ; } flagstr = bitmask_to_flags2 ( addflags , removeflags ) ; command_success_nodata ( si , _ ( ""Flags<S2SV_blank>\\2%s\\2<S2SV_blank>were<S2SV_blank>set<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , flagstr , target , channel ) ; logcommand ( si , CMDLOG_SET , ""FLAGS:<S2SV_blank>\\2%s\\2<S2SV_blank>\\2%s\\2<S2SV_blank>\\2%s\\2"" , mc -> name , target , flagstr ) ; verbose ( mc , ""\\2%s\\2<S2SV_blank>set<S2SV_blank>flags<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2"" , get_source_name ( si ) , flagstr , target ) ; } free ( target ) ; }","else if ( anope_flags_compat && ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL ) {",2344
273,"buggy line: user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user )  return ERR_PTR ( - ENOMEM ) ;construct_get_dest_keyring ( & dest_keyring ) ;cwe id:CWE-862context: static struct key * construct_key_and_link ( struct keyring_search_context * ctx , const char * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct key_user * user ; struct key * key ; int ret ; kenter ( """" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ;  user = key_user_lookup ( current_fsuid ( ) ) ;  if ( ! user )  return ERR_PTR ( - ENOMEM ) ;  construct_get_dest_keyring ( & dest_keyring ) ; ret = construct_alloc_key ( ctx , dest_keyring , flags , user , & key ) ; key_user_put ( user ) ; if ( ret == 0 ) { ret = construct_key ( key , callout_info , callout_len , aux , dest_keyring ) ; if ( ret < 0 ) { kdebug ( ""cons<S2SV_blank>failed"" ) ; goto construction_failed ; } } else if ( ret == - EINPROGRESS ) { ret = 0 ; } else {  goto couldnt_alloc_key ;  } key_put ( dest_keyring ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>key<S2SV_blank>%d"" , key_serial ( key ) ) ; return key ; construction_failed : key_negate_and_link ( key , key_negative_timeout , NULL , NULL ) ; key_put ( key ) ;  couldnt_alloc_key :   key_put ( dest_keyring ) ;  kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ERR_PTR ( ret ) ; }",ret = construct_get_dest_keyring ( & dest_keyring ) ;if ( ret ) goto error ;user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user ) {ret = - ENOMEM ;goto error_put_dest_keyring ;},2345
274,"buggy line: goto couldnt_alloc_key ;}couldnt_alloc_key :   key_put ( dest_keyring ) ;kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ;cwe id:CWE-862context: static struct key * construct_key_and_link ( struct keyring_search_context * ctx , const char * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct key_user * user ; struct key * key ; int ret ; kenter ( """" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ;  user = key_user_lookup ( current_fsuid ( ) ) ;  if ( ! user )  return ERR_PTR ( - ENOMEM ) ;  construct_get_dest_keyring ( & dest_keyring ) ; ret = construct_alloc_key ( ctx , dest_keyring , flags , user , & key ) ; key_user_put ( user ) ; if ( ret == 0 ) { ret = construct_key ( key , callout_info , callout_len , aux , dest_keyring ) ; if ( ret < 0 ) { kdebug ( ""cons<S2SV_blank>failed"" ) ; goto construction_failed ; } } else if ( ret == - EINPROGRESS ) { ret = 0 ; } else {  goto couldnt_alloc_key ;  } key_put ( dest_keyring ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>key<S2SV_blank>%d"" , key_serial ( key ) ) ; return key ; construction_failed : key_negate_and_link ( key , key_negative_timeout , NULL , NULL ) ; key_put ( key ) ;  couldnt_alloc_key :   key_put ( dest_keyring ) ;  kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ERR_PTR ( ret ) ; }","goto error_put_dest_keyring ;}error_put_dest_keyring : key_put ( dest_keyring ) ;error : kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ;",2345
275,"buggy line: if ( s -> chunksize >= 0 ) {if ( ! s -> chunksize ) {s -> chunksize = strtoll ( line , NULL , 16 ) ;av_log ( NULL , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\\\'\\\if ( ! s -> chunksize )  return 0 ;}int64_t target = h -> is_streamed ? 0 : s -> off ;if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ;av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 ""<S2SV_blank>error=%s.\\\av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ;av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 "".\\\return read_ret ;cwe id:CWE-119context: static int http_read_stream ( URLContext * h , uint8_t * buf , int size ) { HTTPContext * s = h -> priv_data ; int err , new_location , read_ret ; int64_t seek_ret ; if ( ! s -> hd ) return AVERROR_EOF ; if ( s -> end_chunked_post && ! s -> end_header ) { err = http_read_header ( h , & new_location ) ; if ( err < 0 ) return err ; }  if ( s -> chunksize >= 0 ) {  if ( ! s -> chunksize ) { char line [ 32 ] ; do { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) return err ; } while ( ! * line ) ;  s -> chunksize = strtoll ( line , NULL , 16 ) ;   av_log ( NULL , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\'\\n"" ,  s -> chunksize ) ; if ( ! s -> chunksize )  return 0 ;  } size = FFMIN ( size , s -> chunksize ) ; } # if CONFIG_ZLIB if ( s -> compressed ) return http_buf_read_compressed ( h , buf , size ) ; # endif read_ret = http_buf_read ( h , buf , size ) ; if ( ( read_ret < 0 && s -> reconnect && ( ! h -> is_streamed || s -> reconnect_streamed ) && s -> filesize > 0 && s -> off < s -> filesize ) || ( read_ret == 0 && s -> reconnect_at_eof && ( ! h -> is_streamed || s -> reconnect_streamed ) ) ) {  int64_t target = h -> is_streamed ? 0 : s -> off ;  if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ;  av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 ""<S2SV_blank>error=%s.\\n"" , s -> off , av_err2str ( read_ret ) ) ;  av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ; s -> reconnect_delay = 1 + 2 * s -> reconnect_delay ; seek_ret = http_seek_internal ( h , target , SEEK_SET , 1 ) ; if ( seek_ret != target ) {  av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 "".\\n"" , target ) ;  return read_ret ; } read_ret = http_buf_read ( h , buf , size ) ; } else s -> reconnect_delay = 0 ; return read_ret ; }","if ( s -> chunksize != UINT64_MAX ) {if ( ! s -> chunksize ) {s -> chunksize = strtoull ( line , NULL , 16 ) ;av_log ( h , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\\\'\\\if ( ! s -> chunksize ) return 0 ;else if ( s -> chunksize == UINT64_MAX ) {av_log ( h , AV_LOG_ERROR , ""Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%"" PRIu64 ""\\\return AVERROR ( EINVAL ) ;}}uint64_t target = h -> is_streamed ? 0 : s -> off ;if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ;av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRIu64 ""<S2SV_blank>error=%s.\\\av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ;av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRIu64 "".\\\return read_ret ;",2346
276,"buggy line: long tmp = * old ;* old = atomic_long_cmpxchg ( & sem -> count , * old , new ) ;return * old == tmp ;}cwe id:CWE-362context: static inline int ldsem_cmpxchg ( long * old , long new , struct ld_semaphore * sem ) {  long tmp = * old ;  * old = atomic_long_cmpxchg ( & sem -> count , * old , new ) ;  return * old == tmp ;  }","long tmp = atomic_long_cmpxchg ( & sem -> count , * old , new ) ;if ( tmp == * old ) {* old = new ;return 1 ;}else {* old = tmp ;return 0 ;}}",2347
277,"buggy line: static void write_sync_code ( struct vp9_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ;vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ;vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ;}cwe id:CWE-119context:  static void write_sync_code ( struct vp9_write_bit_buffer * wb ) {   vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ;   vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ;   vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ;  }","static void write_sync_code ( struct vpx_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ;vpx_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ;vpx_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ;}",2348
278,"buggy line: static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) {}cwe id:CWE-787context:  static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) { nsc_encode_argb_to_aycocg_sse2 ( context , data , scanline ) ; if ( context -> ChromaSubsamplingLevel > 0 ) { nsc_encode_subsampling_sse2 ( context ) ; }  } ","static BOOL nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , UINT32 scanline ) {return TRUE ;}",2349
279,"buggy line: switch ( sun_info . maptype )  {case RMT_EQUAL_RGB : {cwe id:CWE-119context: static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype )  {  case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {,2350
280,"buggy line: other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ;if ( ! other_branch ) return - EFAULT ;cwe id:CWE-189context: static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , ""invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n"" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } }  other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ;  if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }","other_branch = push_stack ( env , * insn_idx , false + insn -> off + 1 , * insn_idx ) ;if ( ! other_branch ) return - EFAULT ;",2351
281,"buggy line: cwe id:CWE-119context: int stats_open_file ( stats_io_t * stats , const char * fpf , int pass ) { int res ; stats -> pass = pass ; if ( pass == 0 ) { stats -> file = fopen ( fpf , ""wb"" ) ; stats -> buf . sz = 0 ; stats -> buf . buf = NULL ; res = ( stats -> file != NULL ) ; } else { # if USE_POSIX_MMAP struct stat stat_buf ; int fd ; fd = open ( fpf , O_RDONLY ) ; stats -> file = fdopen ( fd , ""rb"" ) ; fstat ( fd , & stat_buf ) ; stats -> buf . sz = stat_buf . st_size ; stats -> buf . buf = mmap ( NULL , stats -> buf . sz , PROT_READ , MAP_PRIVATE , fd , 0 ) ; res = ( stats -> buf . buf != NULL ) ; # else size_t nbytes ; stats -> file = fopen ( fpf , ""rb"" ) ;  if ( fseek ( stats -> file , 0 , SEEK_END ) )  fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>must<S2SV_blank>be<S2SV_blank>seekable!"" ) ; stats -> buf . sz = stats -> buf_alloc_sz = ftell ( stats -> file ) ; rewind ( stats -> file ) ; stats -> buf . buf = malloc ( stats -> buf_alloc_sz ) ; if ( ! stats -> buf . buf ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>first-pass<S2SV_blank>stats<S2SV_blank>buffer<S2SV_blank>(%lu<S2SV_blank>bytes)"" , ( unsigned int ) stats -> buf_alloc_sz ) ; nbytes = fread ( stats -> buf . buf , 1 , stats -> buf . sz , stats -> file ) ; res = ( nbytes == stats -> buf . sz ) ; # endif } return res ; }","if ( stats -> file == NULL ) fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist!"" ) ;",2352
282,"buggy line: if ( fseek ( stats -> file , 0 , SEEK_END ) )  fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>must<S2SV_blank>be<S2SV_blank>seekable!"" ) ;cwe id:CWE-119context: int stats_open_file ( stats_io_t * stats , const char * fpf , int pass ) { int res ; stats -> pass = pass ; if ( pass == 0 ) { stats -> file = fopen ( fpf , ""wb"" ) ; stats -> buf . sz = 0 ; stats -> buf . buf = NULL ; res = ( stats -> file != NULL ) ; } else { # if USE_POSIX_MMAP struct stat stat_buf ; int fd ; fd = open ( fpf , O_RDONLY ) ; stats -> file = fdopen ( fd , ""rb"" ) ; fstat ( fd , & stat_buf ) ; stats -> buf . sz = stat_buf . st_size ; stats -> buf . buf = mmap ( NULL , stats -> buf . sz , PROT_READ , MAP_PRIVATE , fd , 0 ) ; res = ( stats -> buf . buf != NULL ) ; # else size_t nbytes ; stats -> file = fopen ( fpf , ""rb"" ) ;  if ( fseek ( stats -> file , 0 , SEEK_END ) )  fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>must<S2SV_blank>be<S2SV_blank>seekable!"" ) ; stats -> buf . sz = stats -> buf_alloc_sz = ftell ( stats -> file ) ; rewind ( stats -> file ) ; stats -> buf . buf = malloc ( stats -> buf_alloc_sz ) ; if ( ! stats -> buf . buf ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>first-pass<S2SV_blank>stats<S2SV_blank>buffer<S2SV_blank>(%lu<S2SV_blank>bytes)"" , ( unsigned int ) stats -> buf_alloc_sz ) ; nbytes = fread ( stats -> buf . buf , 1 , stats -> buf . sz , stats -> file ) ; res = ( nbytes == stats -> buf . sz ) ; # endif } return res ; }","if ( fseek ( stats -> file , 0 , SEEK_END ) ) fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>must<S2SV_blank>be<S2SV_blank>seekable!"" ) ;",2352
283,"buggy line: if ( name && memchr ( name , '\\\\0' , namelen ) )  return 0 ;cwe id:CWE-295context: static int int_x509_param_set_hosts ( X509_VERIFY_PARAM_ID * id , int mode , const char * name , size_t namelen ) { char * copy ;  if ( name && memchr ( name , '\\0' , namelen ) )  return 0 ; if ( mode == SET_HOST && id -> hosts ) { string_stack_free ( id -> hosts ) ; id -> hosts = NULL ; } if ( name == NULL || namelen == 0 ) return 1 ; copy = strndup ( name , namelen ) ; if ( copy == NULL ) return 0 ; if ( id -> hosts == NULL && ( id -> hosts = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { free ( copy ) ; return 0 ; } if ( ! sk_OPENSSL_STRING_push ( id -> hosts , copy ) ) { free ( copy ) ; if ( sk_OPENSSL_STRING_num ( id -> hosts ) == 0 ) { sk_OPENSSL_STRING_free ( id -> hosts ) ; id -> hosts = NULL ; } return 0 ; } return 1 ; }","if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ;if ( name && memchr ( name , '\\\\0' , namelen ) ) return 0 ;",2353
284,"buggy line: static int mem_resize ( jas_stream_memobj_t * m , int bufsize )  {assert ( bufsize >= 0 ) ;JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\\if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {cwe id:CWE-190context:  static int mem_resize ( jas_stream_memobj_t * m , int bufsize )  { unsigned char * buf ;  assert ( bufsize >= 0 ) ;   JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\n"" , m , bufsize ) ) ;  if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) { JAS_DBGLOG ( 100 , ( ""mem_resize<S2SV_blank>realloc<S2SV_blank>failed\\n"" ) ) ; return - 1 ; } JAS_DBGLOG ( 100 , ( ""mem_resize<S2SV_blank>realloc<S2SV_blank>succeeded\\n"" ) ) ; m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }","static int mem_resize ( jas_stream_memobj_t * m , size_t bufsize ) {JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\\if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {if ( ! bufsize ) {jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\\}",2354
285,"buggy line: unsigned int i ;cmap -> numchans = ( box -> datalen ) / 4 ;cwe id:CWE-476context: static int jp2_cmap_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cmap_t * cmap = & box -> data . cmap ; jp2_cmapent_t * ent ;  unsigned int i ;  cmap -> numchans = ( box -> datalen ) / 4 ; if ( ! ( cmap -> ents = jas_alloc2 ( cmap -> numchans , sizeof ( jp2_cmapent_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < cmap -> numchans ; ++ i ) { ent = & cmap -> ents [ i ] ; if ( jp2_getuint16 ( in , & ent -> cmptno ) || jp2_getuint8 ( in , & ent -> map ) || jp2_getuint8 ( in , & ent -> pcol ) ) { return - 1 ; } } return 0 ; }",unsigned int i ;cmap -> ents = 0 ;cmap -> numchans = ( box -> datalen ) / 4 ;,2355
286,"buggy line: BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ;}cwe id:CWE-787context: static int next_state_val ( CClassNode * cc , OnigCodePoint * vs , OnigCodePoint v , int * vs_israw , int v_israw , enum CCVALTYPE intype , enum CCVALTYPE * type , enum CCSTATE * state , ScanEnv * env ) { int r ; switch ( * state ) { case CCS_VALUE : if ( * type == CCV_SB ) {  BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ;  } else if ( * type == CCV_CODE_POINT ) { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; if ( r < 0 ) return r ; } break ; case CCS_RANGE : if ( intype == * type ) { if ( intype == CCV_SB ) { if ( * vs > 0xff || v > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ; if ( * vs > v ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) goto ccs_range_end ; else return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; } bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) v ) ; } else { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , v ) ; if ( r < 0 ) return r ; } } else { # if 0 if ( intype == CCV_CODE_POINT && * type == CCV_SB ) { # endif if ( * vs > v ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) goto ccs_range_end ; else return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; } bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) ( v < 0xff ? v : 0xff ) ) ; r = add_code_range ( & ( cc -> mbuf ) , env , ( OnigCodePoint ) * vs , v ) ; if ( r < 0 ) return r ; # if 0 } else return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE ; # endif } ccs_range_end : * state = CCS_COMPLETE ; break ; case CCS_COMPLETE : case CCS_START : * state = CCS_VALUE ; break ; default : break ; } * vs_israw = v_israw ; * vs = v ; * type = intype ; return 0 ; }","if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ;}",2356
287,"buggy line: ut8 opcode = * ( p4 ++ ) & 0xff ;while ( keep ) {cwe id:CWE-476context: static void dex_parse_debug_item ( RBinFile * binfile , RBinDexObj * bin , RBinDexClass * c , int MI , int MA , int paddr , int ins_size , int insns_size , char * class_name , int regsz , int debug_info_off ) { struct r_bin_t * rbin = binfile -> rbin ; const ut8 * p4 = r_buf_get_at ( binfile -> buf , debug_info_off , NULL ) ; const ut8 * p4_end = p4 + binfile -> buf -> length - debug_info_off ; ut64 line_start ; ut64 parameters_size ; ut64 param_type_idx ; ut16 argReg = regsz - ins_size ; ut64 source_file_idx = c -> source_file ; RList * params , * debug_positions , * emitted_debug_locals = NULL ; bool keep = true ; if ( argReg > regsz ) { return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & line_start ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & parameters_size ) ; ut32 address = 0 ; ut32 line = line_start ; if ( ! ( debug_positions = r_list_newf ( ( RListFree ) free ) ) ) { return ; } if ( ! ( emitted_debug_locals = r_list_newf ( ( RListFree ) free ) ) ) { r_list_free ( debug_positions ) ; return ; } struct dex_debug_local_t debug_locals [ regsz ] ; memset ( debug_locals , 0 , sizeof ( struct dex_debug_local_t ) * regsz ) ; if ( ! ( MA & 0x0008 ) ) { debug_locals [ argReg ] . name = ""this"" ; debug_locals [ argReg ] . descriptor = r_str_newf ( ""%s;"" , class_name ) ; debug_locals [ argReg ] . startAddress = 0 ; debug_locals [ argReg ] . signature = NULL ; debug_locals [ argReg ] . live = true ; argReg ++ ; } if ( ! ( params = dex_method_signature2 ( bin , MI ) ) ) { r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; return ; } RListIter * iter = r_list_iterator ( params ) ; char * name ; char * type ; int reg ; r_list_foreach ( params , iter , type ) { if ( ( argReg >= regsz ) || ! type || parameters_size <= 0 ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; r_list_free ( emitted_debug_locals ) ; return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & param_type_idx ) ; param_type_idx -= 1 ; name = getstr ( bin , param_type_idx ) ; reg = argReg ; switch ( type [ 0 ] ) { case 'D' : case 'J' : argReg += 2 ; break ; default : argReg += 1 ; break ; } if ( name ) { debug_locals [ reg ] . name = name ; debug_locals [ reg ] . descriptor = type ; debug_locals [ reg ] . signature = NULL ; debug_locals [ reg ] . startAddress = address ; debug_locals [ reg ] . live = true ; } -- parameters_size ; }  ut8 opcode = * ( p4 ++ ) & 0xff ;  while ( keep ) { switch ( opcode ) { case 0x0 : keep = false ; break ; case 0x1 : { ut64 addr_diff ; p4 = r_uleb128 ( p4 , p4_end - p4 , & addr_diff ) ; address += addr_diff ; } break ; case 0x2 : { st64 line_diff = r_sleb128 ( & p4 , p4_end ) ; line += line_diff ; } break ; case 0x3 : { ut64 register_num ; ut64 name_idx ; ut64 type_idx ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & name_idx ) ; name_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & type_idx ) ; type_idx -= 1 ; if ( register_num >= regsz ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; return ; } if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . name = getstr ( bin , name_idx ) ; debug_locals [ register_num ] . descriptor = dex_type_descriptor ( bin , type_idx ) ; debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . signature = NULL ; debug_locals [ register_num ] . live = true ; } break ; case 0x4 : { ut64 register_num ; ut64 name_idx ; ut64 type_idx ; ut64 sig_idx ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & name_idx ) ; name_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & type_idx ) ; type_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & sig_idx ) ; sig_idx -= 1 ; if ( register_num >= regsz ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; return ; } if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . name = getstr ( bin , name_idx ) ; debug_locals [ register_num ] . descriptor = dex_type_descriptor ( bin , type_idx ) ; debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . signature = getstr ( bin , sig_idx ) ; debug_locals [ register_num ] . live = true ; } break ; case 0x5 : { ut64 register_num ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . live = false ; } break ; case 0x6 : { ut64 register_num ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; if ( ! debug_locals [ register_num ] . live ) { debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . live = true ; } } break ; case 0x7 : break ; case 0x8 : break ; case 0x9 : { p4 = r_uleb128 ( p4 , p4_end - p4 , & source_file_idx ) ; source_file_idx -- ; } break ; default : { int adjusted_opcode = opcode - 0x0a ; address += ( adjusted_opcode / 15 ) ; line += - 4 + ( adjusted_opcode % 15 ) ; struct dex_debug_position_t * position = malloc ( sizeof ( struct dex_debug_position_t ) ) ; if ( ! position ) { keep = false ; break ; } position -> source_file_idx = source_file_idx ; position -> address = address ; position -> line = line ; r_list_append ( debug_positions , position ) ; } break ; } opcode = * ( p4 ++ ) & 0xff ; } if ( ! binfile -> sdb_addrinfo ) { binfile -> sdb_addrinfo = sdb_new0 ( ) ; } char * fileline ; char offset [ 64 ] ; char * offset_ptr ; RListIter * iter1 ; struct dex_debug_position_t * pos ; r_list_foreach ( debug_positions , iter1 , pos ) { fileline = r_str_newf ( ""%s|%"" PFMT64d , getstr ( bin , pos -> source_file_idx ) , pos -> line ) ; offset_ptr = sdb_itoa ( pos -> address + paddr , offset , 16 ) ; sdb_set ( binfile -> sdb_addrinfo , offset_ptr , fileline , 0 ) ; sdb_set ( binfile -> sdb_addrinfo , fileline , offset_ptr , 0 ) ; } if ( ! dexdump ) { r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; r_list_free ( params ) ; return ; } RListIter * iter2 ; struct dex_debug_position_t * position ; rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>positions<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:\\n"" ) ; r_list_foreach ( debug_positions , iter2 , position ) { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04llx<S2SV_blank>line=%llu\\n"" , position -> address , position -> line ) ; } rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>locals<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:\\n"" ) ; RListIter * iter3 ; struct dex_debug_local_t * local ; r_list_foreach ( emitted_debug_locals , iter3 , local ) { if ( local -> signature ) { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n"" , local -> startAddress , local -> endAddress , local -> reg , local -> name , local -> descriptor , local -> signature ) ; } else { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s\\n"" , local -> startAddress , local -> endAddress , local -> reg , local -> name , local -> descriptor ) ; } } for ( reg = 0 ; reg < regsz ; reg ++ ) { if ( debug_locals [ reg ] . live ) { if ( debug_locals [ reg ] . signature ) { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" ""%s\\n"" , debug_locals [ reg ] . startAddress , insns_size , reg , debug_locals [ reg ] . name , debug_locals [ reg ] . descriptor , debug_locals [ reg ] . signature ) ; } else { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s"" ""\\n"" , debug_locals [ reg ] . startAddress , insns_size , reg , debug_locals [ reg ] . name , debug_locals [ reg ] . descriptor ) ; } } } r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; r_list_free ( params ) ; }",if ( p4 <= 0 ) {return ;}ut8 opcode = * ( p4 ++ ) & 0xff ;while ( keep ) {,2357
288,"buggy line: h = __archive_read_ahead ( a ,  ( size_t ) cpio -> entry_bytes_remaining , NULL ) ;cwe id:CWE-20context: static int archive_read_format_cpio_read_header ( struct archive_read * a , struct archive_entry * entry ) { struct cpio * cpio ; const void * h ; struct archive_string_conv * sconv ; size_t namelength ; size_t name_pad ; int r ; cpio = ( struct cpio * ) ( a -> format -> data ) ; sconv = cpio -> opt_sconv ; if ( sconv == NULL ) { if ( ! cpio -> init_default_conversion ) { cpio -> sconv_default = archive_string_default_conversion_for_read ( & ( a -> archive ) ) ; cpio -> init_default_conversion = 1 ; } sconv = cpio -> sconv_default ; } r = ( cpio -> read_header ( a , cpio , entry , & namelength , & name_pad ) ) ; if ( r < ARCHIVE_WARN ) return ( r ) ; h = __archive_read_ahead ( a , namelength + name_pad , NULL ) ; if ( h == NULL ) return ( ARCHIVE_FATAL ) ; if ( archive_entry_copy_pathname_l ( entry , ( const char * ) h , namelength , sconv ) != 0 ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Pathname"" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Pathname<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>current<S2SV_blank>locale."" , archive_string_conversion_charset_name ( sconv ) ) ; r = ARCHIVE_WARN ; } cpio -> entry_offset = 0 ; __archive_read_consume ( a , namelength + name_pad ) ; if ( archive_entry_filetype ( entry ) == AE_IFLNK ) {  h = __archive_read_ahead ( a ,  ( size_t ) cpio -> entry_bytes_remaining , NULL ) ; if ( h == NULL ) return ( ARCHIVE_FATAL ) ; if ( archive_entry_copy_symlink_l ( entry , ( const char * ) h , ( size_t ) cpio -> entry_bytes_remaining , sconv ) != 0 ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Linkname"" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Linkname<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>"" ""current<S2SV_blank>locale."" , archive_string_conversion_charset_name ( sconv ) ) ; r = ARCHIVE_WARN ; } __archive_read_consume ( a , cpio -> entry_bytes_remaining ) ; cpio -> entry_bytes_remaining = 0 ; } if ( namelength == 11 && strcmp ( ( const char * ) h , ""TRAILER!!!"" ) == 0 ) { archive_clear_error ( & a -> archive ) ; return ( ARCHIVE_EOF ) ; } if ( record_hardlink ( a , cpio , entry ) != ARCHIVE_OK ) { return ( ARCHIVE_FATAL ) ; } return ( r ) ; }","if ( cpio -> entry_bytes_remaining > 1024 * 1024 ) {archive_set_error ( & a -> archive , ENOMEM , ""Rejecting<S2SV_blank>malformed<S2SV_blank>cpio<S2SV_blank>archive:<S2SV_blank>symlink<S2SV_blank>contents<S2SV_blank>exceed<S2SV_blank>1<S2SV_blank>megabyte"" ) ;return ( ARCHIVE_FATAL ) ;}h = __archive_read_ahead ( a , ( size_t ) cpio -> entry_bytes_remaining , NULL ) ;",2358
289,"buggy line: . index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = user_match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }cwe id:CWE-476context: struct key * key_get_instantiation_authkey ( key_serial_t target_id ) { char description [ 16 ] ; struct keyring_search_context ctx = { . index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = user_match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * authkey ; key_ref_t authkey_ref ; sprintf ( description , ""%x"" , target_id ) ; authkey_ref = search_process_keyrings ( & ctx ) ; if ( IS_ERR ( authkey_ref ) ) { authkey = ERR_CAST ( authkey_ref ) ; if ( authkey == ERR_PTR ( - EAGAIN ) ) authkey = ERR_PTR ( - ENOKEY ) ; goto error ; } authkey = key_ref_to_ptr ( authkey_ref ) ; if ( test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { key_put ( authkey ) ; authkey = ERR_PTR ( - EKEYREVOKED ) ; } error : return authkey ; }",". index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",2359
290,"buggy line: if ( pos + 8 > len ) {return op -> size ;int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) ,  max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ;cwe id:CWE-125context: static int java_switch_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { ut8 op_byte = data [ 0 ] ; ut64 offset = addr - java_get_method_start ( ) ; ut8 pos = ( offset + 1 ) % 4 ? 1 + 4 - ( offset + 1 ) % 4 : 1 ; if ( op_byte == 0xaa ) {  if ( pos + 8 > len ) {  return op -> size ; }  int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) ,  max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ; ut32 default_loc = ( ut32 ) ( UINT ( data , pos ) ) , cur_case = 0 ; op -> switch_op = r_anal_switch_op_new ( addr , min_val , default_loc ) ; RAnalCaseOp * caseop = NULL ; pos += 12 ; if ( max_val > min_val && ( ( max_val - min_val ) < ( UT16_MAX / 4 ) ) ) { for ( cur_case = 0 ; cur_case <= max_val - min_val ; pos += 4 , cur_case ++ ) { if ( pos + 4 >= len ) { break ; } int offset = ( int ) ( ut32 ) ( R_BIN_JAVA_UINT ( data , pos ) ) ; caseop = r_anal_switch_op_add_case ( op -> switch_op , addr + pos , cur_case + min_val , addr + offset ) ; if ( caseop ) { caseop -> bb_ref_to = addr + offset ; caseop -> bb_ref_from = addr ; } } } else { eprintf ( ""Invalid<S2SV_blank>switch<S2SV_blank>boundaries<S2SV_blank>at<S2SV_blank>0x%"" PFMT64x ""\\n"" , addr ) ; } } op -> size = pos ; return op -> size ; }","if ( pos + 8 + 8 > len ) {return op -> size ;const int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) ;const int max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ;",2360
291,"buggy line: RD_BOOL  ber_parse_header ( STREAM s , int tagval , int * length )  {cwe id:CWE-119context: RD_BOOL  ber_parse_header ( STREAM s , int tagval , int * length )  { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , ""ber_parse_header(),<S2SV_blank>expected<S2SV_blank>tag<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d"" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }","RD_BOOL ber_parse_header ( STREAM s , int tagval , uint32 * length ) {",2361
292,"buggy line: if ( cid <= 0 )  continue ;dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( dctx -> remaining <= 0 ) {dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( dctx -> remaining <= 0 )   return dctx -> remaining ;}cwe id:CWE-476context: static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state << 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state << 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state >> 32 ) & 0xFFFFFFFF ;  if ( cid <= 0 )  continue ;  dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ;   if ( dctx -> remaining <= 0 ) {   dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;   if ( dctx -> remaining <= 0 )   return dctx -> remaining ;  } if ( buf_size - i + 47 >= dctx -> remaining ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; return END_NOT_FOUND ; }","int remaining ;if ( cid <= 0 ) continue ;remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( remaining <= 0 ) {dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( remaining <= 0 ) return dctx -> remaining ;}",2362
293,"buggy line: first_block_offset = round_up ( offset , sb -> s_blocksize ) ;last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;ext4_std_error ( sb , ret ) ;goto out_dio ;}ret = ext4_zero_partial_blocks ( handle , inode , offset , length ) ;if ( ret ) goto out_stop ;first_block = ( offset + sb -> s_blocksize - 1 ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ;stop_block = ( offset + length ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ;if ( first_block >= stop_block ) goto out_stop ;down_write ( & EXT4_I ( inode ) -> i_data_sem ) ;ext4_discard_preallocations ( inode ) ;ret = ext4_es_remove_extent ( inode , first_block , stop_block - first_block ) ;if ( ret ) {up_write ( & EXT4_I ( inode ) -> i_data_sem ) ;goto out_stop ;}if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ret = ext4_ext_remove_space ( inode , first_block , stop_block - 1 ) ;else ret = ext4_ind_remove_space ( handle , inode , first_block , stop_block ) ;up_write ( & EXT4_I ( inode ) -> i_data_sem ) ;if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ;if ( last_block_offset > first_block_offset )  truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ;out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ;out_mutex : mutex_unlock ( & inode -> i_mutex ) ;cwe id:CWE-362context: int ext4_punch_hole ( struct inode * inode , loff_t offset , loff_t length ) { struct super_block * sb = inode -> i_sb ; ext4_lblk_t first_block , stop_block ; struct address_space * mapping = inode -> i_mapping ; loff_t first_block_offset , last_block_offset ; handle_t * handle ; unsigned int credits ; int ret = 0 ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_punch_hole ( inode , offset , length , 0 ) ; if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + length - 1 ) ; if ( ret ) return ret ; } mutex_lock ( & inode -> i_mutex ) ; if ( offset >= inode -> i_size ) goto out_mutex ; if ( offset + length > inode -> i_size ) { length = inode -> i_size + PAGE_CACHE_SIZE - ( inode -> i_size & ( PAGE_CACHE_SIZE - 1 ) ) - offset ; } if ( offset & ( sb -> s_blocksize - 1 ) || ( offset + length ) & ( sb -> s_blocksize - 1 ) ) { ret = ext4_inode_attach_jinode ( inode ) ; if ( ret < 0 ) goto out_mutex ; }  first_block_offset = round_up ( offset , sb -> s_blocksize ) ;  last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ; if ( last_block_offset > first_block_offset ) truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ;  ext4_inode_block_unlocked_dio ( inode ) ;  inode_dio_wait ( inode ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) credits = ext4_writepage_trans_blocks ( inode ) ; else credits = ext4_blocks_for_truncate ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( sb , ret ) ; goto out_dio ; } ret = ext4_zero_partial_blocks ( handle , inode , offset , length ) ; if ( ret ) goto out_stop ; first_block = ( offset + sb -> s_blocksize - 1 ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; stop_block = ( offset + length ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( first_block >= stop_block ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; ret = ext4_es_remove_extent ( inode , first_block , stop_block - first_block ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ret = ext4_ext_remove_space ( inode , first_block , stop_block - 1 ) ; else ret = ext4_ind_remove_space ( handle , inode , first_block , stop_block ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ;  if ( last_block_offset > first_block_offset )  truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; out_stop : ext4_journal_stop ( handle ) ; out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ;  out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }","ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;first_block_offset = round_up ( offset , sb -> s_blocksize ) ;last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ;out_dio : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;ext4_inode_resume_unlocked_dio ( inode ) ;out_mutex : mutex_unlock ( & inode -> i_mutex ) ;",2363
294,"buggy line: printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL ,  VPX_CODEC_USE_POSTPROC ) ;cwe id:CWE-119context: int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; vpx_codec_err_t res ; VpxVideoReader * reader = NULL ; const VpxInterface * decoder = NULL ; const VpxVideoInfo * info = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , ""wb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing"" , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( ""Unknown<S2SV_blank>input<S2SV_blank>codec."" ) ;  printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ;   res = vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL ,  VPX_CODEC_USE_POSTPROC ) ; if ( res == VPX_CODEC_INCAPABLE ) die_codec ( & codec , ""Postproc<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>decoder."" ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; ++ frame_cnt ; if ( frame_cnt % 30 == 1 ) { vp8_postproc_cfg_t pp = { 0 , 0 , 0 } ; if ( vpx_codec_control ( & codec , VP8_SET_POSTPROC , & pp ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>off<S2SV_blank>postproc."" ) ; } else if ( frame_cnt % 30 == 16 ) { vp8_postproc_cfg_t pp = { VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE , 4 , 0 } ; if ( vpx_codec_control ( & codec , VP8_SET_POSTPROC , & pp ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>on<S2SV_blank>postproc."" ) ; } ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 15000 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame"" ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { vpx_img_write ( img , outfile ) ; } } printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec"" ) ; printf ( ""Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\n"" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }","printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_dec_init ( & codec , decoder -> codec_interface ( ) , NULL , VPX_CODEC_USE_POSTPROC ) ;",2364
295,"buggy line: if ( strlen ( str ) >= sizeof ( lowstr ) )  {if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 ||  DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {cwe id:CWE-119context: timestamp PGTYPEStimestamp_from_asc ( char * str , char * * endptr ) { timestamp result ; # ifdef HAVE_INT64_TIMESTAMP int64 noresult = 0 ; # else double noresult = 0.0 ; # endif fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ;  if ( strlen ( str ) >= sizeof ( lowstr ) )  { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; }  if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 ||  DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } break ; case DTK_EPOCH : result = SetEpochTimestamp ( ) ; break ; case DTK_LATE : TIMESTAMP_NOEND ( result ) ; break ; case DTK_EARLY : TIMESTAMP_NOBEGIN ( result ) ; break ; case DTK_INVALID : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; default : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } errno = 0 ; return result ; }","if ( strlen ( str ) > MAXDATELEN ) {if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {errno = PGTYPES_TS_BAD_TIMESTAMP ;return ( noresult ) ;}switch ( dtype ) {case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {",2365
296,"buggy line: Huff_transmit ( & huff , ch , seq ) ;Huff_addRef ( & huff , ( byte ) ch ) ;cwe id:CWE-119context: void Huff_Compress ( msg_t * mbuf , int offset ) { int i , ch , size ; byte seq [ 65536 ] ; byte * buffer ; huff_t huff ; size = mbuf -> cursize - offset ; buffer = mbuf -> data + + offset ; if ( size <= 0 ) { return ; } Com_Memset ( & huff , 0 , sizeof ( huff_t ) ) ; huff . tree = huff . lhead = huff . loc [ NYT ] = & ( huff . nodeList [ huff . blocNode ++ ] ) ; huff . tree -> symbol = NYT ; huff . tree -> weight = 0 ; huff . lhead -> next = huff . lhead -> prev = NULL ; huff . tree -> parent = huff . tree -> left = huff . tree -> right = NULL ; seq [ 0 ] = ( size >> 8 ) ; seq [ 1 ] = size & 0xff ; bloc = 16 ; for ( i = 0 ; i < size ; i ++ ) { ch = buffer [ i ] ;  Huff_transmit ( & huff , ch , seq ) ;  Huff_addRef ( & huff , ( byte ) ch ) ; } bloc += 8 ; mbuf -> cursize = ( bloc >> 3 ) + offset ; Com_Memcpy ( mbuf -> data + offset , seq , ( bloc >> 3 ) ) ; }","Huff_transmit ( & huff , ch , seq , size << 3 ) ;Huff_addRef ( & huff , ( byte ) ch ) ;",2366
297,"buggy line: cmd = kmalloc ( sizeof ( * cmd ) , GFP_ATOMIC ) ;if ( ! cmd ) return - ENOMEM ;cwe id:CWE-908context: static int kvaser_usb_leaf_simple_cmd_async ( struct kvaser_usb_net_priv * priv , u8 cmd_id ) { struct kvaser_cmd * cmd ; int err ;  cmd = kmalloc ( sizeof ( * cmd ) , GFP_ATOMIC ) ;  if ( ! cmd ) return - ENOMEM ; cmd -> len = CMD_HEADER_LEN + sizeof ( struct kvaser_cmd_simple ) ; cmd -> id = cmd_id ; cmd -> u . simple . channel = priv -> channel ; err = kvaser_usb_send_cmd_async ( priv , cmd , cmd -> len ) ; if ( err ) kfree ( cmd ) ; return err ; }","cmd = kzalloc ( sizeof ( * cmd ) , GFP_ATOMIC ) ;if ( ! cmd ) return - ENOMEM ;",2367
298,"buggy line: for ( i = 0 ;i <= SERDES_MAX ;struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ;cwe id:CWE-125context: static struct phy * serdes_simple_xlate ( struct device * dev , struct of_phandle_args * args ) { struct serdes_ctrl * ctrl = dev_get_drvdata ( dev ) ; unsigned int port , idx , i ; if ( args -> args_count != 2 ) return ERR_PTR ( - EINVAL ) ; port = args -> args [ 0 ] ; idx = args -> args [ 1 ] ;  for ( i = 0 ; i <= SERDES_MAX ; i ++ ) {  struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; if ( idx != macro -> idx ) continue ; if ( idx != SERDES6G ( 0 ) && macro -> port >= 0 ) return ERR_PTR ( - EBUSY ) ; macro -> port = port ; return ctrl -> phys [ i ] ; } return ERR_PTR ( - ENODEV ) ; }",for ( i = 0 ;i < SERDES_MAX ;struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ;,2368
299,"buggy line: assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ;return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) ,  ( ( char * ) buf ) + offs , len ) ;cwe id:CWE-119context: ssize_t cdf_read_sector ( const cdf_info_t * info , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) {  assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ;   return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) ,  ( ( char * ) buf ) + offs , len ) ; }","size_t ss = CDF_SEC_SIZE ( h ) ;size_t pos = CDF_SEC_POS ( h , id ) ;assert ( ss == len ) ;return cdf_read ( info , ( off_t ) pos , ( ( char * ) buf ) + offs , len ) ;",2369
300,"buggy line: int client_socket = accept ( listen_socket_ , NULL , NULL ) ;if ( client_socket == - 1 ) {cwe id:CWE-284context: static void * listen_fn_ ( UNUSED_ATTR void * context ) { prctl ( PR_SET_NAME , ( unsigned long ) LISTEN_THREAD_NAME_ , 0 , 0 , 0 ) ; listen_socket_ = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ) ; if ( listen_socket_ == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } int enable = 1 ; if ( setsockopt ( listen_socket_ , SOL_SOCKET , SO_REUSEADDR , & enable , sizeof ( enable ) ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>SO_REUSEADDR:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } struct sockaddr_in addr ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = htonl ( LOCALHOST_ ) ; addr . sin_port = htons ( LISTEN_PORT_ ) ; if ( bind ( listen_socket_ , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>listen<S2SV_blank>socket:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } if ( listen ( listen_socket_ , 10 ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>listen:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } for ( ; ; ) {  int client_socket = accept ( listen_socket_ , NULL , NULL ) ;  if ( client_socket == - 1 ) { if ( errno == EINVAL || errno == EBADF ) { break ; } LOG_WARN ( ""%s<S2SV_blank>error<S2SV_blank>accepting<S2SV_blank>socket:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; continue ; } pthread_mutex_lock ( & client_socket_lock_ ) ; safe_close_ ( & client_socket_ ) ; client_socket_ = client_socket ;  send ( client_socket_ , ""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea"" , 16 , 0 ) ;  pthread_mutex_unlock ( & client_socket_lock_ ) ; } cleanup : safe_close_ ( & listen_socket_ ) ; return NULL ; }","int client_socket = TEMP_FAILURE_RETRY ( accept ( listen_socket_ , NULL , NULL ) ) ;if ( client_socket == - 1 ) {",2370
301,"buggy line: send ( client_socket_ , ""btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea"" , 16 , 0 ) ;pthread_mutex_unlock ( & client_socket_lock_ ) ;cwe id:CWE-284context: static void * listen_fn_ ( UNUSED_ATTR void * context ) { prctl ( PR_SET_NAME , ( unsigned long ) LISTEN_THREAD_NAME_ , 0 , 0 , 0 ) ; listen_socket_ = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ) ; if ( listen_socket_ == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } int enable = 1 ; if ( setsockopt ( listen_socket_ , SOL_SOCKET , SO_REUSEADDR , & enable , sizeof ( enable ) ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>SO_REUSEADDR:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } struct sockaddr_in addr ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = htonl ( LOCALHOST_ ) ; addr . sin_port = htons ( LISTEN_PORT_ ) ; if ( bind ( listen_socket_ , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>listen<S2SV_blank>socket:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } if ( listen ( listen_socket_ , 10 ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>listen:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } for ( ; ; ) {  int client_socket = accept ( listen_socket_ , NULL , NULL ) ;  if ( client_socket == - 1 ) { if ( errno == EINVAL || errno == EBADF ) { break ; } LOG_WARN ( ""%s<S2SV_blank>error<S2SV_blank>accepting<S2SV_blank>socket:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; continue ; } pthread_mutex_lock ( & client_socket_lock_ ) ; safe_close_ ( & client_socket_ ) ; client_socket_ = client_socket ;  send ( client_socket_ , ""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea"" , 16 , 0 ) ;  pthread_mutex_unlock ( & client_socket_lock_ ) ; } cleanup : safe_close_ ( & listen_socket_ ) ; return NULL ; }","TEMP_FAILURE_RETRY ( send ( client_socket_ , ""btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea"" , 16 , 0 ) ) ;pthread_mutex_unlock ( & client_socket_lock_ ) ;",2370
302,"buggy line: BREAK_TO_DEBUGGER ( ) ;return NULL ;cwe id:CWE-401context: struct clock_source * dce112_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; }  BREAK_TO_DEBUGGER ( ) ;  return NULL ; }",kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,2371
303,"buggy line: struct buffer_head * page_bufs ;struct inode * inode = page -> mapping -> host ;cwe id:CWE-000context: static int ext4_writepage ( struct page * page , struct writeback_control * wbc ) { int ret = 0 ; loff_t size ; unsigned int len ;  struct buffer_head * page_bufs ;  struct inode * inode = page -> mapping -> host ; trace_ext4_writepage ( inode , page ) ; size = i_size_read ( inode ) ; if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { page_bufs = page_buffers ( page ) ; if ( walk_page_buffers ( NULL , page_bufs , 0 , len , NULL , ext4_bh_delay_or_unwritten ) ) { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } } else { ret = block_prepare_write ( page , 0 , len , noalloc_get_block_write ) ; if ( ! ret ) { page_bufs = page_buffers ( page ) ; if ( walk_page_buffers ( NULL , page_bufs , 0 , len , NULL , ext4_bh_delay_or_unwritten ) ) { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } } else { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } block_commit_write ( page , 0 , len ) ; } if ( PageChecked ( page ) && ext4_should_journal_data ( inode ) ) { ClearPageChecked ( page ) ; return __ext4_journalled_writepage ( page , len ) ; } if ( test_opt ( inode -> i_sb , NOBH ) && ext4_should_writeback_data ( inode ) ) ret = nobh_writepage ( page , noalloc_get_block_write , wbc ) ;  else  ret = block_write_full_page ( page , noalloc_get_block_write , wbc ) ; return ret ; }",struct buffer_head * page_bufs = NULL ;struct inode * inode = page -> mapping -> host ;,2372
304,"buggy line: else  ret = block_write_full_page ( page , noalloc_get_block_write , wbc ) ;cwe id:CWE-000context: static int ext4_writepage ( struct page * page , struct writeback_control * wbc ) { int ret = 0 ; loff_t size ; unsigned int len ;  struct buffer_head * page_bufs ;  struct inode * inode = page -> mapping -> host ; trace_ext4_writepage ( inode , page ) ; size = i_size_read ( inode ) ; if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { page_bufs = page_buffers ( page ) ; if ( walk_page_buffers ( NULL , page_bufs , 0 , len , NULL , ext4_bh_delay_or_unwritten ) ) { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } } else { ret = block_prepare_write ( page , 0 , len , noalloc_get_block_write ) ; if ( ! ret ) { page_bufs = page_buffers ( page ) ; if ( walk_page_buffers ( NULL , page_bufs , 0 , len , NULL , ext4_bh_delay_or_unwritten ) ) { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } } else { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } block_commit_write ( page , 0 , len ) ; } if ( PageChecked ( page ) && ext4_should_journal_data ( inode ) ) { ClearPageChecked ( page ) ; return __ext4_journalled_writepage ( page , len ) ; } if ( test_opt ( inode -> i_sb , NOBH ) && ext4_should_writeback_data ( inode ) ) ret = nobh_writepage ( page , noalloc_get_block_write , wbc ) ;  else  ret = block_write_full_page ( page , noalloc_get_block_write , wbc ) ; return ret ; }","else if ( page_bufs && buffer_uninit ( page_bufs ) ) {ext4_set_bh_endio ( page_bufs , inode ) ;ret = block_write_full_page_endio ( page , noalloc_get_block_write , wbc , ext4_end_io_buffer_write ) ;}else ret = block_write_full_page ( page , noalloc_get_block_write , wbc ) ;",2372
305,"buggy line: for ( i = 0 ;++ i )  resize_multistep ( input + in_stride * i , width , intbuf + width2 * i , width2 , tmpbuf ) ;cwe id:CWE-119context: void vp9_resize_plane ( const uint8_t * const input , int height , int width , int in_stride , uint8_t * output , int height2 , int width2 , int out_stride ) { int i ; uint8_t * intbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * width2 * height ) ; uint8_t * tmpbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * ( width < height ? height : width ) ) ; uint8_t * arrbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * ( height + height2 ) ) ;  for ( i = 0 ; i < height ; ++ i )  resize_multistep ( input + in_stride * i , width , intbuf + width2 * i , width2 , tmpbuf ) ; for ( i = 0 ; i < width2 ; ++ i ) { fill_col_to_arr ( intbuf + i , width2 , height , arrbuf ) ; resize_multistep ( arrbuf , height , arrbuf + height , height2 , tmpbuf ) ; fill_arr_to_col ( output + i , out_stride , height2 , arrbuf + height ) ; } free ( intbuf ) ; free ( tmpbuf ) ; free ( arrbuf ) ; }","assert ( width > 0 ) ;assert ( height > 0 ) ;assert ( width2 > 0 ) ;assert ( height2 > 0 ) ;for ( i = 0 ;+ i )  resize_multistep ( input + in_stride * i , width , intbuf + width2 * i , width2 , tmpbuf ) ;++ i ) resize_multistep ( input + in_stride * i , width , intbuf + width2 * i , width2 , tmpbuf ) ;",2373
306,"buggy line: case SUNKBD_RET_RESET :  schedule_work ( & sunkbd -> tq ) ;sunkbd -> reset = - 1 ;cwe id:CWE-416context: static irqreturn_t sunkbd_interrupt ( struct serio * serio , unsigned char data , unsigned int flags ) { struct sunkbd * sunkbd = serio_get_drvdata ( serio ) ; if ( sunkbd -> reset <= - 1 ) { sunkbd -> reset = data ; wake_up_interruptible ( & sunkbd -> wait ) ; goto out ; } if ( sunkbd -> layout == - 1 ) { sunkbd -> layout = data ; wake_up_interruptible ( & sunkbd -> wait ) ; goto out ; } switch ( data ) { case SUNKBD_RET_RESET :  schedule_work ( & sunkbd -> tq ) ;  sunkbd -> reset = - 1 ; break ; case SUNKBD_RET_LAYOUT : sunkbd -> layout = - 1 ; break ; case SUNKBD_RET_ALLUP : break ; default : if ( ! sunkbd -> enabled ) break ; if ( sunkbd -> keycode [ data & SUNKBD_KEY ] ) { input_report_key ( sunkbd -> dev , sunkbd -> keycode [ data & SUNKBD_KEY ] , ! ( data & SUNKBD_RELEASE ) ) ; input_sync ( sunkbd -> dev ) ; } else { printk ( KERN_WARNING ""sunkbd.c:<S2SV_blank>Unknown<S2SV_blank>key<S2SV_blank>(scancode<S2SV_blank>%#x)<S2SV_blank>%s.\\n"" , data & SUNKBD_KEY , data & SUNKBD_RELEASE ? ""released"" : ""pressed"" ) ; } } out : return IRQ_HANDLED ; }",case SUNKBD_RET_RESET : if ( sunkbd -> enabled ) schedule_work ( & sunkbd -> tq ) ;sunkbd -> reset = - 1 ;,2374
307,"buggy line: # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) {cwe id:CWE-787context: static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size , ExceptionInfo * exception ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } }  Quantum index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const Quantum * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; if ( y == 0 ) { waiting_code = ( short ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;  p += GetPixelChannels ( image ) ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ;  next_pixel = MagickFalse ;  displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }",# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) # define GIFOutputCode ( code ) \\\\\,2375
308,"buggy line: }Quantum index ;cwe id:CWE-787context: static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size , ExceptionInfo * exception ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } }  Quantum index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const Quantum * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; if ( y == 0 ) { waiting_code = ( short ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;  p += GetPixelChannels ( image ) ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ;  next_pixel = MagickFalse ;  displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }",\\\\\Quantum index ;,2375
309,"buggy line: cwe id:CWE-787context: static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size , ExceptionInfo * exception ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } }  Quantum index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const Quantum * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; if ( y == 0 ) { waiting_code = ( short ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;  p += GetPixelChannels ( image ) ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ;  next_pixel = MagickFalse ;  displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }",next_pixel = MagickFalse ;displacement = 1 ;,2375
310,"buggy line: index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;p += GetPixelChannels ( image ) ;next_pixel = MagickFalse ;displacement = 1 ;cwe id:CWE-787context: static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size , ExceptionInfo * exception ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } }  Quantum index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const Quantum * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; if ( y == 0 ) { waiting_code = ( short ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;  p += GetPixelChannels ( image ) ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ;  next_pixel = MagickFalse ;  displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }","index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;p += GetPixelChannels ( image ) ;if ( k < 0 ) continue ;",2375
311,"buggy line: else umount_tree ( mnt , 0 ) ;}cwe id:CWE-200context: void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( IS_ERR_OR_NULL ( mp ) ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } }  else umount_tree ( mnt , 0 ) ;  } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }","else umount_tree ( mnt , UMOUNT_CONNECTED ) ;}",2376
312,"buggy line: if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) )  return CURLE_OUT_OF_MEMORY ;cwe id:CWE-119context: CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) { CURLcode result ; char * plainauth ; size_t ulen ; size_t plen ; size_t plainlen ; * outlen = 0 ; * outptr = NULL ; ulen = strlen ( userp ) ; plen = strlen ( passwdp ) ;  if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) )  return CURLE_OUT_OF_MEMORY ; plainlen = 2 * ulen + plen + 2 ; plainauth = malloc ( plainlen ) ; if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ; memcpy ( plainauth , userp , ulen ) ; plainauth [ ulen ] = '\\0' ; memcpy ( plainauth + ulen + 1 , userp , ulen ) ; plainauth [ 2 * ulen + 1 ] = '\\0' ; memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ; result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ; free ( plainauth ) ; return result ; }",if ( ( ulen > SIZE_T_MAX / 4 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;,2377
313,"buggy line: char buffer [ 4096 ] ;char buffer2 [ 4096 ] ;char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;int l ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;}else {memcpy ( buf , name , name_len ) ;buf [ name_len ] = 0 ;decrypt_return_plain :  if ( buf != buffer ) {efree ( buf ) ;}cwe id:CWE-119context: char * suhosin_decrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key , char * * where TSRMLS_DC ) {  char buffer [ 4096 ] ;  char buffer2 [ 4096 ] ; int o_name_len = name_len ;  char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;  int l ;  if ( name_len > sizeof ( buffer ) - 2 ) {  buf = estrndup ( name , name_len ) ;  } else {  memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { decrypt_return_plain :  if ( buf != buffer ) {  efree ( buf ) ; } memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , value , value_len ) ; * where += value_len ; return * where ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto decrypt_return_plain ; } }  if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {  memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_decrypt_string ( buf2 , value_len , buf , name_len , key , & l , SUHOSIN_G ( cookie_checkraddr ) TSRMLS_CC ) ; if ( d == NULL ) { goto skip_cookie ; } d_url = php_url_encode ( d , l , & l ) ; efree ( d ) ; memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , d_url , l ) ; * where += l ; efree ( d_url ) ; skip_cookie :  if ( buf != buffer ) {  efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return * where ; }","char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;int l ;buf = estrndup ( name , name_len ) ;else {memcpy ( buf , name , name_len ) ;decrypt_return_plain : efree ( buf ) ;",2378
314,"buggy line: else if ( SUHOSIN_G ( cookie_cryptlist ) ) {if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) {goto decrypt_return_plain ;}}if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {memcpy ( buf2 , value , value_len ) ;buf2 [ value_len ] = 0 ;}else {}cwe id:CWE-119context: char * suhosin_decrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key , char * * where TSRMLS_DC ) {  char buffer [ 4096 ] ;  char buffer2 [ 4096 ] ; int o_name_len = name_len ;  char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;  int l ;  if ( name_len > sizeof ( buffer ) - 2 ) {  buf = estrndup ( name , name_len ) ;  } else {  memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { decrypt_return_plain :  if ( buf != buffer ) {  efree ( buf ) ; } memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , value , value_len ) ; * where += value_len ; return * where ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto decrypt_return_plain ; } }  if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {  memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_decrypt_string ( buf2 , value_len , buf , name_len , key , & l , SUHOSIN_G ( cookie_checkraddr ) TSRMLS_CC ) ; if ( d == NULL ) { goto skip_cookie ; } d_url = php_url_encode ( d , l , & l ) ; efree ( d ) ; memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , d_url , l ) ; * where += l ; efree ( d_url ) ; skip_cookie :  if ( buf != buffer ) {  efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return * where ; }","
",2378
315,"buggy line: skip_cookie :  if ( buf != buffer ) {efree ( buf ) ;}if ( buf2 != buffer2 ) {}cwe id:CWE-119context: char * suhosin_decrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key , char * * where TSRMLS_DC ) {  char buffer [ 4096 ] ;  char buffer2 [ 4096 ] ; int o_name_len = name_len ;  char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;  int l ;  if ( name_len > sizeof ( buffer ) - 2 ) {  buf = estrndup ( name , name_len ) ;  } else {  memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { decrypt_return_plain :  if ( buf != buffer ) {  efree ( buf ) ; } memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , value , value_len ) ; * where += value_len ; return * where ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto decrypt_return_plain ; } }  if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {  memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_decrypt_string ( buf2 , value_len , buf , name_len , key , & l , SUHOSIN_G ( cookie_checkraddr ) TSRMLS_CC ) ; if ( d == NULL ) { goto skip_cookie ; } d_url = php_url_encode ( d , l , & l ) ; efree ( d ) ; memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , d_url , l ) ; * where += l ; efree ( d_url ) ; skip_cookie :  if ( buf != buffer ) {  efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return * where ; }",skip_cookie : efree ( buf ) ;,2378
316,"buggy line: static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high ,  int q ) {const double error_term = err_per_mb / err_divisor ;const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low ,  pt_high ) ;cwe id:CWE-119context: static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high ,  int q ) {  const double error_term = err_per_mb / err_divisor ;  const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low ,  pt_high ) ; if ( power_term < 1.0 ) assert ( error_term >= 0.0 ) ; return fclamp ( pow ( error_term , power_term ) , 0.05 , 5.0 ) ; }","static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high , int q , vpx_bit_depth_t bit_depth ) {const double error_term = err_per_mb / err_divisor ;const double power_term = MIN ( vp9_convert_qindex_to_q ( q , bit_depth ) * 0.01 + pt_low , pt_high ) ;",2379
317,"buggy line: cwe id:CWE-369context: int tcp_disconnect ( struct sock * sk , int flags ) { struct inet_sock * inet = inet_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; int err = 0 ; int old_state = sk -> sk_state ; if ( old_state != TCP_CLOSE ) tcp_set_state ( sk , TCP_CLOSE ) ; if ( old_state == TCP_LISTEN ) { inet_csk_listen_stop ( sk ) ; } else if ( unlikely ( tp -> repair ) ) { sk -> sk_err = ECONNABORTED ; } else if ( tcp_need_reset ( old_state ) || ( tp -> snd_nxt != tp -> write_seq && ( 1 << old_state ) & ( TCPF_CLOSING | TCPF_LAST_ACK ) ) ) { tcp_send_active_reset ( sk , gfp_any ( ) ) ; sk -> sk_err = ECONNRESET ; } else if ( old_state == TCP_SYN_SENT ) sk -> sk_err = ECONNRESET ; tcp_clear_xmit_timers ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; tcp_write_queue_purge ( sk ) ; tcp_fastopen_active_disable_ofo_check ( sk ) ; skb_rbtree_purge ( & tp -> out_of_order_queue ) ; inet -> inet_dport = 0 ; if ( ! ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) ) inet_reset_saddr ( sk ) ; sk -> sk_shutdown = 0 ; sock_reset_flag ( sk , SOCK_DONE ) ; tp -> srtt_us = 0 ; tp -> write_seq += tp -> max_window + 2 ; if ( tp -> write_seq == 0 ) tp -> write_seq = 1 ; icsk -> icsk_backoff = 0 ; tp -> snd_cwnd = 2 ; icsk -> icsk_probes_out = 0 ; tp -> packets_out = 0 ; tp -> snd_ssthresh = TCP_INFINITE_SSTHRESH ; tp -> snd_cwnd_cnt = 0 ; tp -> window_clamp = 0 ; tcp_set_ca_state ( sk , TCP_CA_Open ) ; tcp_clear_retrans ( tp ) ; inet_csk_delack_init ( sk ) ;  tcp_init_send_head ( sk ) ;  memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ; __sk_dst_reset ( sk ) ; tcp_saved_syn_free ( tp ) ; tcp_free_fastopen_req ( tp ) ; inet -> defer_connect = 0 ; WARN_ON ( inet -> inet_num && ! icsk -> icsk_bind_hash ) ; sk -> sk_error_report ( sk ) ; return err ; }",icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;,2380
318,"buggy line: tcp_init_send_head ( sk ) ;memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ;cwe id:CWE-369context: int tcp_disconnect ( struct sock * sk , int flags ) { struct inet_sock * inet = inet_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; int err = 0 ; int old_state = sk -> sk_state ; if ( old_state != TCP_CLOSE ) tcp_set_state ( sk , TCP_CLOSE ) ; if ( old_state == TCP_LISTEN ) { inet_csk_listen_stop ( sk ) ; } else if ( unlikely ( tp -> repair ) ) { sk -> sk_err = ECONNABORTED ; } else if ( tcp_need_reset ( old_state ) || ( tp -> snd_nxt != tp -> write_seq && ( 1 << old_state ) & ( TCPF_CLOSING | TCPF_LAST_ACK ) ) ) { tcp_send_active_reset ( sk , gfp_any ( ) ) ; sk -> sk_err = ECONNRESET ; } else if ( old_state == TCP_SYN_SENT ) sk -> sk_err = ECONNRESET ; tcp_clear_xmit_timers ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; tcp_write_queue_purge ( sk ) ; tcp_fastopen_active_disable_ofo_check ( sk ) ; skb_rbtree_purge ( & tp -> out_of_order_queue ) ; inet -> inet_dport = 0 ; if ( ! ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) ) inet_reset_saddr ( sk ) ; sk -> sk_shutdown = 0 ; sock_reset_flag ( sk , SOCK_DONE ) ; tp -> srtt_us = 0 ; tp -> write_seq += tp -> max_window + 2 ; if ( tp -> write_seq == 0 ) tp -> write_seq = 1 ; icsk -> icsk_backoff = 0 ; tp -> snd_cwnd = 2 ; icsk -> icsk_probes_out = 0 ; tp -> packets_out = 0 ; tp -> snd_ssthresh = TCP_INFINITE_SSTHRESH ; tp -> snd_cwnd_cnt = 0 ; tp -> window_clamp = 0 ; tcp_set_ca_state ( sk , TCP_CA_Open ) ; tcp_clear_retrans ( tp ) ; inet_csk_delack_init ( sk ) ;  tcp_init_send_head ( sk ) ;  memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ; __sk_dst_reset ( sk ) ; tcp_saved_syn_free ( tp ) ; tcp_free_fastopen_req ( tp ) ; inet -> defer_connect = 0 ; WARN_ON ( inet -> inet_num && ! icsk -> icsk_bind_hash ) ; sk -> sk_error_report ( sk ) ; return err ; }","tcp_init_send_head ( sk ) ;memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ;",2380
319,"buggy line: return true ;}cwe id:CWE-20context: static bool generic_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) {  return true ;  }",return nf_generic_should_process ( nf_ct_protonum ( ct ) ) ;},2381
320,"buggy line: return ;update_idle_timeout ( conn ) ;parse_input ( conn ) ;if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {cwe id:CWE-000context: static void on_read ( h2o_socket_t * sock , int status ) { h2o_http2_conn_t * conn = sock -> data ; if ( status != 0 ) { h2o_socket_read_stop ( conn -> sock ) ; close_connection ( conn ) ; return ; } update_idle_timeout ( conn ) ;  parse_input ( conn ) ;  if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { h2o_timeout_unlink ( & conn -> _write . timeout_entry ) ; do_emit_writereq ( conn ) ; } }",if ( return ;update_idle_timeout ( conn ) != 0 ) return ;parse_input ( conn ) ;if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {,2382
321,"buggy line: MATLAB_KO :  clone_info = DestroyImageInfo ( clone_info ) ;cwe id:CWE-617context: static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; quantum_info = ( QuantumInfo * ) NULL ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) {  MATLAB_KO :  clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }",MATLAB_KO : if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ;,2383
322,"buggy line: if ( ! bgp_attr_print ( ndo , atype , p , alen ) )  goto trunc ;cwe id:CWE-674context: static void bgp_update_print ( netdissect_options * ndo , const u_char * dat , int length ) { struct bgp bgp ; const u_char * p ; int withdrawn_routes_len ; int len ; int i ; ND_TCHECK2 ( dat [ 0 ] , BGP_SIZE ) ; if ( length < BGP_SIZE ) goto trunc ; memcpy ( & bgp , dat , BGP_SIZE ) ; p = dat + BGP_SIZE ; length -= BGP_SIZE ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; withdrawn_routes_len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len ) { ND_TCHECK2 ( p [ 0 ] , withdrawn_routes_len ) ; if ( length < withdrawn_routes_len ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Withdrawn<S2SV_blank>routes:<S2SV_blank>%d<S2SV_blank>bytes"" , withdrawn_routes_len ) ) ; p += withdrawn_routes_len ; length -= withdrawn_routes_len ; } ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len == 0 && len == 0 && length == 0 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; return ; } if ( len ) { while ( len ) { int aflags , atype , alenlen , alen ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; if ( length < 2 ) goto trunc ; aflags = * p ; atype = * ( p + 1 ) ; p += 2 ; len -= 2 ; length -= 2 ; alenlen = bgp_attr_lenlen ( aflags , p ) ; ND_TCHECK2 ( p [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; if ( length < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , p ) ; p += alenlen ; len -= alenlen ; length -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( len < alen ) goto trunc ; if ( length < alen ) goto trunc ;  if ( ! bgp_attr_print ( ndo , atype , p , alen ) )  goto trunc ; p += alen ; len -= alen ; length -= alen ; } } if ( length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Updated<S2SV_blank>routes:"" ) ) ; while ( length ) { char buf [ MAXHOSTNAMELEN + 100 ] ; i = decode_prefix4 ( ndo , p , length , buf , sizeof ( buf ) ) ; if ( i == - 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; break ; } else if ( i == - 2 ) goto trunc ; else if ( i == - 3 ) goto trunc ; else { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; p += i ; length -= i ; } } } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","if ( ! bgp_attr_print ( ndo , atype , p , alen , 0 ) ) goto trunc ;",2384
323,"buggy line: ext2_xattr_put_super ( sb ) ;if ( ! ( sb -> s_flags & MS_RDONLY ) ) {cwe id:CWE-19context: static void ext2_put_super ( struct super_block * sb ) { int db_count ; int i ; struct ext2_sb_info * sbi = EXT2_SB ( sb ) ; dquot_disable ( sb , - 1 , DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED ) ;  ext2_xattr_put_super ( sb ) ;  if ( ! ( sb -> s_flags & MS_RDONLY ) ) { struct ext2_super_block * es = sbi -> s_es ; spin_lock ( & sbi -> s_lock ) ; es -> s_state = cpu_to_le16 ( sbi -> s_mount_state ) ; spin_unlock ( & sbi -> s_lock ) ; ext2_sync_super ( sb , es , 1 ) ; } db_count = sbi -> s_gdb_count ; for ( i = 0 ; i < db_count ; i ++ ) if ( sbi -> s_group_desc [ i ] ) brelse ( sbi -> s_group_desc [ i ] ) ; kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; brelse ( sbi -> s_sbh ) ; sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; }",if ( sbi -> s_mb_cache ) {ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;sbi -> s_mb_cache = NULL ;}if ( ! ( sb -> s_flags & MS_RDONLY ) ) {,2385
324,"buggy line: if ( plen > PAGE_SIZE ) goto error ;payload = NULL ;if ( _payload ) {ret = - ENOMEM ;cwe id:CWE-476context: long keyctl_update_key ( key_serial_t id , const void __user * _payload , size_t plen ) { key_ref_t key_ref ; void * payload ; long ret ; ret = - EINVAL ; if ( plen > PAGE_SIZE ) goto error ; payload = NULL ;  if ( _payload ) {  ret = - ENOMEM ; payload = kmalloc ( plen , GFP_KERNEL ) ; if ( ! payload ) goto error ; ret = - EFAULT ; if ( copy_from_user ( payload , _payload , plen ) != 0 ) goto error2 ; } key_ref = lookup_user_key ( id , 0 , KEY_NEED_WRITE ) ; if ( IS_ERR ( key_ref ) ) { ret = PTR_ERR ( key_ref ) ; goto error2 ; } ret = key_update ( key_ref , payload , plen ) ; key_ref_put ( key_ref ) ; error2 : kfree ( payload ) ; error : return ret ; }",if ( plen ) {ret = - ENOMEM ;,2386
325,"buggy line: i < MAX_MODES ;i ++ ) {cpi -> mode_check_freq [ i ] = 0 ;}cpi -> mb . mbs_tested_so_far = 0 ;sf -> RD = 1 ;sf -> search_method = NSTEP ;sf -> improved_quant = 1 ;sf -> improved_dct = 1 ;sf -> auto_filter = 1 ;sf -> recode_loop = 1 ;sf -> quarter_pixel_search = 1 ;sf -> half_pixel_search = 1 ;sf -> iterative_sub_pixel = 1 ;sf -> optimize_coefficients = 1 ;sf -> use_fastquant_for_pick = 0 ;sf -> no_skip_block4x4_search = 1 ;sf -> first_step = 0 ;sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ;sf -> improved_mv_pred = 1 ;for ( i = 0 ;i < MAX_MODES ;i ++ ) sf -> thresh_mult [ i ] = 0 ;ref_frames = 1 ;if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ref_frames ++ ;cwe id:CWE-119context: void vp8_set_speed_features ( VP8_COMP * cpi ) { SPEED_FEATURES * sf = & cpi -> sf ; int Mode = cpi -> compressor_speed ; int Speed = cpi -> Speed ; int i ; VP8_COMMON * cm = & cpi -> common ; int last_improved_quant = sf -> improved_quant ; int ref_frames ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mode_check_freq [ i ] = 0 ; } cpi -> mb . mbs_tested_so_far = 0 ;  sf -> RD = 1 ;  sf -> search_method = NSTEP ; sf -> improved_quant = 1 ; sf -> improved_dct = 1 ; sf -> auto_filter = 1 ; sf -> recode_loop = 1 ; sf -> quarter_pixel_search = 1 ; sf -> half_pixel_search = 1 ; sf -> iterative_sub_pixel = 1 ; sf -> optimize_coefficients = 1 ; sf -> use_fastquant_for_pick = 0 ; sf -> no_skip_block4x4_search = 1 ; sf -> first_step = 0 ; sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; sf -> improved_mv_pred = 1 ; for ( i = 0 ; i < MAX_MODES ; i ++ ) sf -> thresh_mult [ i ] = 0 ; ref_frames = 1 ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ref_frames ++ ; if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ref_frames ++ ; if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) ref_frames ++ ; if ( Mode == 0 ) Speed = 0 ; else if ( Mode == 2 ) Speed = RT ( Speed ) ; else { if ( Speed > 5 ) Speed = 5 ; Speed = GOOD ( Speed ) ; } sf -> thresh_mult [ THR_ZERO1 ] = sf -> thresh_mult [ THR_NEAREST1 ] = sf -> thresh_mult [ THR_NEAR1 ] = sf -> thresh_mult [ THR_DC ] = 0 ; sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO3 ] = sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST3 ] = sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR3 ] = speed_map ( Speed , thresh_mult_map_znn ) ; sf -> thresh_mult [ THR_V_PRED ] = sf -> thresh_mult [ THR_H_PRED ] = speed_map ( Speed , thresh_mult_map_vhpred ) ; sf -> thresh_mult [ THR_B_PRED ] = speed_map ( Speed , thresh_mult_map_bpred ) ; sf -> thresh_mult [ THR_TM ] = speed_map ( Speed , thresh_mult_map_tm ) ; sf -> thresh_mult [ THR_NEW1 ] = speed_map ( Speed , thresh_mult_map_new1 ) ; sf -> thresh_mult [ THR_NEW2 ] = sf -> thresh_mult [ THR_NEW3 ] = speed_map ( Speed , thresh_mult_map_new2 ) ; sf -> thresh_mult [ THR_SPLIT1 ] = speed_map ( Speed , thresh_mult_map_split1 ) ; sf -> thresh_mult [ THR_SPLIT2 ] =  sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ;  cpi -> mode_check_freq [ THR_ZERO1 ] = cpi -> mode_check_freq [ THR_NEAREST1 ] = cpi -> mode_check_freq [ THR_NEAR1 ] = cpi -> mode_check_freq [ THR_TM ] = cpi -> mode_check_freq [ THR_DC ] = 0 ; cpi -> mode_check_freq [ THR_ZERO2 ] = cpi -> mode_check_freq [ THR_ZERO3 ] = cpi -> mode_check_freq [ THR_NEAREST2 ] = cpi -> mode_check_freq [ THR_NEAREST3 ] = speed_map ( Speed , mode_check_freq_map_zn2 ) ; cpi -> mode_check_freq [ THR_NEAR2 ] = cpi -> mode_check_freq [ THR_NEAR3 ] = speed_map ( Speed , mode_check_freq_map_near2 ) ; cpi -> mode_check_freq [ THR_V_PRED ] = cpi -> mode_check_freq [ THR_H_PRED ] = cpi -> mode_check_freq [ THR_B_PRED ] = speed_map ( Speed , mode_check_freq_map_vhbpred ) ; cpi -> mode_check_freq [ THR_NEW1 ] = speed_map ( Speed , mode_check_freq_map_new1 ) ; cpi -> mode_check_freq [ THR_NEW2 ] = cpi -> mode_check_freq [ THR_NEW3 ] = speed_map ( Speed , mode_check_freq_map_new2 ) ; cpi -> mode_check_freq [ THR_SPLIT1 ] = speed_map ( Speed , mode_check_freq_map_split1 ) ; cpi -> mode_check_freq [ THR_SPLIT2 ] = cpi -> mode_check_freq [ THR_SPLIT3 ] = speed_map ( Speed , mode_check_freq_map_split2 ) ; Speed = cpi -> Speed ; switch ( Mode ) { # if ! ( CONFIG_REALTIME_ONLY ) case 0 : sf -> first_step = 0 ; sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; break ; case 1 : case 3 : if ( Speed > 0 ) { sf -> optimize_coefficients = 0 ; sf -> use_fastquant_for_pick = 1 ; sf -> no_skip_block4x4_search = 0 ; sf -> first_step = 1 ; } if ( Speed > 2 ) { sf -> improved_quant = 0 ; sf -> improved_dct = 0 ; sf -> recode_loop = 2 ; } if ( Speed > 3 ) { sf -> auto_filter = 1 ; sf -> recode_loop = 0 ; sf -> RD = 0 ; } if ( Speed > 4 ) { sf -> auto_filter = 0 ; } break ; # endif case 2 : sf -> optimize_coefficients = 0 ; sf -> recode_loop = 0 ; sf -> auto_filter = 1 ; sf -> iterative_sub_pixel = 1 ; sf -> search_method = NSTEP ; if ( Speed > 0 ) { sf -> improved_quant = 0 ; sf -> improved_dct = 0 ; sf -> use_fastquant_for_pick = 1 ; sf -> no_skip_block4x4_search = 0 ; sf -> first_step = 1 ; } if ( Speed > 2 ) sf -> auto_filter = 0 ; if ( Speed > 3 ) { sf -> RD = 0 ; sf -> auto_filter = 1 ; } if ( Speed > 4 ) { sf -> auto_filter = 0 ; sf -> search_method = HEX ; sf -> iterative_sub_pixel = 0 ; } if ( Speed > 6 ) { unsigned int sum = 0 ; unsigned int total_mbs = cm -> MBs ; int thresh ; unsigned int total_skip ; int min = 2000 ; if ( cpi -> oxcf . encode_breakout > 2000 ) min = cpi -> oxcf . encode_breakout ; min >>= 7 ; for ( i = 0 ; i < min ; i ++ ) { sum += cpi -> mb . error_bins [ i ] ; } total_skip = sum ; sum = 0 ; for ( ; i < 1024 ; i ++ ) { sum += cpi -> mb . error_bins [ i ] ; if ( 10 * sum >= ( unsigned int ) ( cpi -> Speed - 6 ) * ( total_mbs - total_skip ) ) break ; } i -- ; thresh = ( i << 7 ) ; if ( thresh < 2000 ) thresh = 2000 ; if ( ref_frames > 1 ) { sf -> thresh_mult [ THR_NEW1 ] = thresh ; sf -> thresh_mult [ THR_NEAREST1 ] = thresh >> 1 ; sf -> thresh_mult [ THR_NEAR1 ] = thresh >> 1 ; } if ( ref_frames > 2 ) { sf -> thresh_mult [ THR_NEW2 ] = thresh << 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = thresh ; sf -> thresh_mult [ THR_NEAR2 ] = thresh ; } if ( ref_frames > 3 ) { sf -> thresh_mult [ THR_NEW3 ] = thresh << 1 ; sf -> thresh_mult [ THR_NEAREST3 ] = thresh ; sf -> thresh_mult [ THR_NEAR3 ] = thresh ; } sf -> improved_mv_pred = 0 ; } if ( Speed > 8 ) sf -> quarter_pixel_search = 0 ; if ( cm -> version == 0 ) { cm -> filter_type = NORMAL_LOOPFILTER ; if ( Speed >= 14 ) cm -> filter_type = SIMPLE_LOOPFILTER ; } else { cm -> filter_type = SIMPLE_LOOPFILTER ; } if ( Speed >= 15 ) sf -> half_pixel_search = 0 ;  vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ;  } ; if ( cpi -> pass == 1 ) { sf -> improved_quant = 0 ; sf -> optimize_coefficients = 0 ; sf -> improved_dct = 0 ; } if ( cpi -> sf . search_method == NSTEP ) { vp8_init3smotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; } else if ( cpi -> sf . search_method == DIAMOND ) { vp8_init_dsmotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; } if ( cpi -> sf . improved_dct ) { cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; } else { cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; } cpi -> mb . short_walsh4x4 = vp8_short_walsh4x4 ; if ( cpi -> sf . improved_quant ) { cpi -> mb . quantize_b = vp8_regular_quantize_b ;  cpi -> mb . quantize_b_pair = vp8_regular_quantize_b_pair ;  } else {  cpi -> mb . quantize_b = vp8_fast_quantize_b ;  cpi -> mb . quantize_b_pair = vp8_fast_quantize_b_pair ; } if ( cpi -> sf . improved_quant != last_improved_quant ) vp8cx_init_quantizer ( cpi ) ; if ( cpi -> sf . iterative_sub_pixel == 1 ) { cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step_iteratively ; } else if ( cpi -> sf . quarter_pixel_search ) { cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step ; } else if ( cpi -> sf . half_pixel_search ) { cpi -> find_fractional_mv_step = vp8_find_best_half_pixel_step ; } else { cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; } if ( cpi -> sf . optimize_coefficients == 1 && cpi -> pass != 1 ) cpi -> mb . optimize = 1 ; else cpi -> mb . optimize = 0 ; if ( cpi -> common . full_pixel ) cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; # ifdef SPEEDSTATS frames_at_speed [ cpi -> Speed ] ++ ; # endif }",memset ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ref_frames ++ ;,2387
326,"buggy line: sf -> thresh_mult [ THR_SPLIT2 ] =  sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ;cpi -> mode_check_freq [ THR_ZERO1 ] = cpi -> mode_check_freq [ THR_NEAREST1 ] = cpi -> mode_check_freq [ THR_NEAR1 ] = cpi -> mode_check_freq [ THR_TM ] = cpi -> mode_check_freq [ THR_DC ] = 0 ;cwe id:CWE-119context: void vp8_set_speed_features ( VP8_COMP * cpi ) { SPEED_FEATURES * sf = & cpi -> sf ; int Mode = cpi -> compressor_speed ; int Speed = cpi -> Speed ; int i ; VP8_COMMON * cm = & cpi -> common ; int last_improved_quant = sf -> improved_quant ; int ref_frames ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mode_check_freq [ i ] = 0 ; } cpi -> mb . mbs_tested_so_far = 0 ;  sf -> RD = 1 ;  sf -> search_method = NSTEP ; sf -> improved_quant = 1 ; sf -> improved_dct = 1 ; sf -> auto_filter = 1 ; sf -> recode_loop = 1 ; sf -> quarter_pixel_search = 1 ; sf -> half_pixel_search = 1 ; sf -> iterative_sub_pixel = 1 ; sf -> optimize_coefficients = 1 ; sf -> use_fastquant_for_pick = 0 ; sf -> no_skip_block4x4_search = 1 ; sf -> first_step = 0 ; sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; sf -> improved_mv_pred = 1 ; for ( i = 0 ; i < MAX_MODES ; i ++ ) sf -> thresh_mult [ i ] = 0 ; ref_frames = 1 ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ref_frames ++ ; if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ref_frames ++ ; if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) ref_frames ++ ; if ( Mode == 0 ) Speed = 0 ; else if ( Mode == 2 ) Speed = RT ( Speed ) ; else { if ( Speed > 5 ) Speed = 5 ; Speed = GOOD ( Speed ) ; } sf -> thresh_mult [ THR_ZERO1 ] = sf -> thresh_mult [ THR_NEAREST1 ] = sf -> thresh_mult [ THR_NEAR1 ] = sf -> thresh_mult [ THR_DC ] = 0 ; sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO3 ] = sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST3 ] = sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR3 ] = speed_map ( Speed , thresh_mult_map_znn ) ; sf -> thresh_mult [ THR_V_PRED ] = sf -> thresh_mult [ THR_H_PRED ] = speed_map ( Speed , thresh_mult_map_vhpred ) ; sf -> thresh_mult [ THR_B_PRED ] = speed_map ( Speed , thresh_mult_map_bpred ) ; sf -> thresh_mult [ THR_TM ] = speed_map ( Speed , thresh_mult_map_tm ) ; sf -> thresh_mult [ THR_NEW1 ] = speed_map ( Speed , thresh_mult_map_new1 ) ; sf -> thresh_mult [ THR_NEW2 ] = sf -> thresh_mult [ THR_NEW3 ] = speed_map ( Speed , thresh_mult_map_new2 ) ; sf -> thresh_mult [ THR_SPLIT1 ] = speed_map ( Speed , thresh_mult_map_split1 ) ; sf -> thresh_mult [ THR_SPLIT2 ] =  sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ;  cpi -> mode_check_freq [ THR_ZERO1 ] = cpi -> mode_check_freq [ THR_NEAREST1 ] = cpi -> mode_check_freq [ THR_NEAR1 ] = cpi -> mode_check_freq [ THR_TM ] = cpi -> mode_check_freq [ THR_DC ] = 0 ; cpi -> mode_check_freq [ THR_ZERO2 ] = cpi -> mode_check_freq [ THR_ZERO3 ] = cpi -> mode_check_freq [ THR_NEAREST2 ] = cpi -> mode_check_freq [ THR_NEAREST3 ] = speed_map ( Speed , mode_check_freq_map_zn2 ) ; cpi -> mode_check_freq [ THR_NEAR2 ] = cpi -> mode_check_freq [ THR_NEAR3 ] = speed_map ( Speed , mode_check_freq_map_near2 ) ; cpi -> mode_check_freq [ THR_V_PRED ] = cpi -> mode_check_freq [ THR_H_PRED ] = cpi -> mode_check_freq [ THR_B_PRED ] = speed_map ( Speed , mode_check_freq_map_vhbpred ) ; cpi -> mode_check_freq [ THR_NEW1 ] = speed_map ( Speed , mode_check_freq_map_new1 ) ; cpi -> mode_check_freq [ THR_NEW2 ] = cpi -> mode_check_freq [ THR_NEW3 ] = speed_map ( Speed , mode_check_freq_map_new2 ) ; cpi -> mode_check_freq [ THR_SPLIT1 ] = speed_map ( Speed , mode_check_freq_map_split1 ) ; cpi -> mode_check_freq [ THR_SPLIT2 ] = cpi -> mode_check_freq [ THR_SPLIT3 ] = speed_map ( Speed , mode_check_freq_map_split2 ) ; Speed = cpi -> Speed ; switch ( Mode ) { # if ! ( CONFIG_REALTIME_ONLY ) case 0 : sf -> first_step = 0 ; sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; break ; case 1 : case 3 : if ( Speed > 0 ) { sf -> optimize_coefficients = 0 ; sf -> use_fastquant_for_pick = 1 ; sf -> no_skip_block4x4_search = 0 ; sf -> first_step = 1 ; } if ( Speed > 2 ) { sf -> improved_quant = 0 ; sf -> improved_dct = 0 ; sf -> recode_loop = 2 ; } if ( Speed > 3 ) { sf -> auto_filter = 1 ; sf -> recode_loop = 0 ; sf -> RD = 0 ; } if ( Speed > 4 ) { sf -> auto_filter = 0 ; } break ; # endif case 2 : sf -> optimize_coefficients = 0 ; sf -> recode_loop = 0 ; sf -> auto_filter = 1 ; sf -> iterative_sub_pixel = 1 ; sf -> search_method = NSTEP ; if ( Speed > 0 ) { sf -> improved_quant = 0 ; sf -> improved_dct = 0 ; sf -> use_fastquant_for_pick = 1 ; sf -> no_skip_block4x4_search = 0 ; sf -> first_step = 1 ; } if ( Speed > 2 ) sf -> auto_filter = 0 ; if ( Speed > 3 ) { sf -> RD = 0 ; sf -> auto_filter = 1 ; } if ( Speed > 4 ) { sf -> auto_filter = 0 ; sf -> search_method = HEX ; sf -> iterative_sub_pixel = 0 ; } if ( Speed > 6 ) { unsigned int sum = 0 ; unsigned int total_mbs = cm -> MBs ; int thresh ; unsigned int total_skip ; int min = 2000 ; if ( cpi -> oxcf . encode_breakout > 2000 ) min = cpi -> oxcf . encode_breakout ; min >>= 7 ; for ( i = 0 ; i < min ; i ++ ) { sum += cpi -> mb . error_bins [ i ] ; } total_skip = sum ; sum = 0 ; for ( ; i < 1024 ; i ++ ) { sum += cpi -> mb . error_bins [ i ] ; if ( 10 * sum >= ( unsigned int ) ( cpi -> Speed - 6 ) * ( total_mbs - total_skip ) ) break ; } i -- ; thresh = ( i << 7 ) ; if ( thresh < 2000 ) thresh = 2000 ; if ( ref_frames > 1 ) { sf -> thresh_mult [ THR_NEW1 ] = thresh ; sf -> thresh_mult [ THR_NEAREST1 ] = thresh >> 1 ; sf -> thresh_mult [ THR_NEAR1 ] = thresh >> 1 ; } if ( ref_frames > 2 ) { sf -> thresh_mult [ THR_NEW2 ] = thresh << 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = thresh ; sf -> thresh_mult [ THR_NEAR2 ] = thresh ; } if ( ref_frames > 3 ) { sf -> thresh_mult [ THR_NEW3 ] = thresh << 1 ; sf -> thresh_mult [ THR_NEAREST3 ] = thresh ; sf -> thresh_mult [ THR_NEAR3 ] = thresh ; } sf -> improved_mv_pred = 0 ; } if ( Speed > 8 ) sf -> quarter_pixel_search = 0 ; if ( cm -> version == 0 ) { cm -> filter_type = NORMAL_LOOPFILTER ; if ( Speed >= 14 ) cm -> filter_type = SIMPLE_LOOPFILTER ; } else { cm -> filter_type = SIMPLE_LOOPFILTER ; } if ( Speed >= 15 ) sf -> half_pixel_search = 0 ;  vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ;  } ; if ( cpi -> pass == 1 ) { sf -> improved_quant = 0 ; sf -> optimize_coefficients = 0 ; sf -> improved_dct = 0 ; } if ( cpi -> sf . search_method == NSTEP ) { vp8_init3smotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; } else if ( cpi -> sf . search_method == DIAMOND ) { vp8_init_dsmotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; } if ( cpi -> sf . improved_dct ) { cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; } else { cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; } cpi -> mb . short_walsh4x4 = vp8_short_walsh4x4 ; if ( cpi -> sf . improved_quant ) { cpi -> mb . quantize_b = vp8_regular_quantize_b ;  cpi -> mb . quantize_b_pair = vp8_regular_quantize_b_pair ;  } else {  cpi -> mb . quantize_b = vp8_fast_quantize_b ;  cpi -> mb . quantize_b_pair = vp8_fast_quantize_b_pair ; } if ( cpi -> sf . improved_quant != last_improved_quant ) vp8cx_init_quantizer ( cpi ) ; if ( cpi -> sf . iterative_sub_pixel == 1 ) { cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step_iteratively ; } else if ( cpi -> sf . quarter_pixel_search ) { cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step ; } else if ( cpi -> sf . half_pixel_search ) { cpi -> find_fractional_mv_step = vp8_find_best_half_pixel_step ; } else { cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; } if ( cpi -> sf . optimize_coefficients == 1 && cpi -> pass != 1 ) cpi -> mb . optimize = 1 ; else cpi -> mb . optimize = 0 ; if ( cpi -> common . full_pixel ) cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; # ifdef SPEEDSTATS frames_at_speed [ cpi -> Speed ] ++ ; # endif }","sf -> thresh_mult [ THR_SPLIT2 ] = sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ;if ( ( cpi -> Speed <= 6 ) && ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) && ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ) {if ( cpi -> closest_reference_frame == GOLDEN_FRAME ) {sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 3 ;sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 3 ;sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 3 ;}else {sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 1 ;sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 1 ;sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 1 ;}}cpi -> mode_check_freq [ THR_ZERO1 ] = cpi -> mode_check_freq [ THR_NEAREST1 ] = cpi -> mode_check_freq [ THR_NEAR1 ] = cpi -> mode_check_freq [ THR_TM ] = cpi -> mode_check_freq [ THR_DC ] = 0 ;",2387
327,"buggy line: sum += cpi -> mb . error_bins [ i ] ;}total_skip = sum ;sum = 0 ;for ( ;i < 1024 ;i ++ ) {sum += cpi -> mb . error_bins [ i ] ;if ( 10 * sum >= ( unsigned int ) ( cpi -> Speed - 6 ) * ( total_mbs - total_skip ) ) break ;}i -- ;thresh = ( i << 7 ) ;if ( thresh < 2000 ) thresh = 2000 ;if ( ref_frames > 1 ) {sf -> thresh_mult [ THR_NEW1 ] = thresh ;sf -> thresh_mult [ THR_NEAREST1 ] = thresh >> 1 ;sf -> thresh_mult [ THR_NEAR1 ] = thresh >> 1 ;}if ( ref_frames > 2 ) {sf -> thresh_mult [ THR_NEW2 ] = thresh << 1 ;sf -> thresh_mult [ THR_NEAREST2 ] = thresh ;sf -> thresh_mult [ THR_NEAR2 ] = thresh ;}if ( ref_frames > 3 ) {sf -> thresh_mult [ THR_NEW3 ] = thresh << 1 ;sf -> thresh_mult [ THR_NEAREST3 ] = thresh ;sf -> thresh_mult [ THR_NEAR3 ] = thresh ;}sf -> improved_mv_pred = 0 ;}if ( Speed > 8 ) sf -> quarter_pixel_search = 0 ;if ( cm -> version == 0 ) {cm -> filter_type = NORMAL_LOOPFILTER ;if ( Speed >= 14 ) cm -> filter_type = SIMPLE_LOOPFILTER ;}else {cm -> filter_type = SIMPLE_LOOPFILTER ;}if ( Speed >= 15 ) sf -> half_pixel_search = 0 ;vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ;};if ( cpi -> pass == 1 ) {sf -> improved_quant = 0 ;sf -> optimize_coefficients = 0 ;sf -> improved_dct = 0 ;}if ( cpi -> sf . search_method == NSTEP ) {vp8_init3smotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ;}else if ( cpi -> sf . search_method == DIAMOND ) {vp8_init_dsmotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ;}if ( cpi -> sf . improved_dct ) {cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ;cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ;}else {cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ;cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ;}cpi -> mb . short_walsh4x4 = vp8_short_walsh4x4 ;if ( cpi -> sf . improved_quant ) {cpi -> mb . quantize_b = vp8_regular_quantize_b ;cpi -> mb . quantize_b_pair = vp8_regular_quantize_b_pair ;}else {cpi -> mb . quantize_b = vp8_fast_quantize_b ;cpi -> mb . quantize_b_pair = vp8_fast_quantize_b_pair ;cwe id:CWE-119context: void vp8_set_speed_features ( VP8_COMP * cpi ) { SPEED_FEATURES * sf = & cpi -> sf ; int Mode = cpi -> compressor_speed ; int Speed = cpi -> Speed ; int i ; VP8_COMMON * cm = & cpi -> common ; int last_improved_quant = sf -> improved_quant ; int ref_frames ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mode_check_freq [ i ] = 0 ; } cpi -> mb . mbs_tested_so_far = 0 ;  sf -> RD = 1 ;  sf -> search_method = NSTEP ; sf -> improved_quant = 1 ; sf -> improved_dct = 1 ; sf -> auto_filter = 1 ; sf -> recode_loop = 1 ; sf -> quarter_pixel_search = 1 ; sf -> half_pixel_search = 1 ; sf -> iterative_sub_pixel = 1 ; sf -> optimize_coefficients = 1 ; sf -> use_fastquant_for_pick = 0 ; sf -> no_skip_block4x4_search = 1 ; sf -> first_step = 0 ; sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; sf -> improved_mv_pred = 1 ; for ( i = 0 ; i < MAX_MODES ; i ++ ) sf -> thresh_mult [ i ] = 0 ; ref_frames = 1 ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ref_frames ++ ; if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ref_frames ++ ; if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) ref_frames ++ ; if ( Mode == 0 ) Speed = 0 ; else if ( Mode == 2 ) Speed = RT ( Speed ) ; else { if ( Speed > 5 ) Speed = 5 ; Speed = GOOD ( Speed ) ; } sf -> thresh_mult [ THR_ZERO1 ] = sf -> thresh_mult [ THR_NEAREST1 ] = sf -> thresh_mult [ THR_NEAR1 ] = sf -> thresh_mult [ THR_DC ] = 0 ; sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO3 ] = sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST3 ] = sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR3 ] = speed_map ( Speed , thresh_mult_map_znn ) ; sf -> thresh_mult [ THR_V_PRED ] = sf -> thresh_mult [ THR_H_PRED ] = speed_map ( Speed , thresh_mult_map_vhpred ) ; sf -> thresh_mult [ THR_B_PRED ] = speed_map ( Speed , thresh_mult_map_bpred ) ; sf -> thresh_mult [ THR_TM ] = speed_map ( Speed , thresh_mult_map_tm ) ; sf -> thresh_mult [ THR_NEW1 ] = speed_map ( Speed , thresh_mult_map_new1 ) ; sf -> thresh_mult [ THR_NEW2 ] = sf -> thresh_mult [ THR_NEW3 ] = speed_map ( Speed , thresh_mult_map_new2 ) ; sf -> thresh_mult [ THR_SPLIT1 ] = speed_map ( Speed , thresh_mult_map_split1 ) ; sf -> thresh_mult [ THR_SPLIT2 ] =  sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ;  cpi -> mode_check_freq [ THR_ZERO1 ] = cpi -> mode_check_freq [ THR_NEAREST1 ] = cpi -> mode_check_freq [ THR_NEAR1 ] = cpi -> mode_check_freq [ THR_TM ] = cpi -> mode_check_freq [ THR_DC ] = 0 ; cpi -> mode_check_freq [ THR_ZERO2 ] = cpi -> mode_check_freq [ THR_ZERO3 ] = cpi -> mode_check_freq [ THR_NEAREST2 ] = cpi -> mode_check_freq [ THR_NEAREST3 ] = speed_map ( Speed , mode_check_freq_map_zn2 ) ; cpi -> mode_check_freq [ THR_NEAR2 ] = cpi -> mode_check_freq [ THR_NEAR3 ] = speed_map ( Speed , mode_check_freq_map_near2 ) ; cpi -> mode_check_freq [ THR_V_PRED ] = cpi -> mode_check_freq [ THR_H_PRED ] = cpi -> mode_check_freq [ THR_B_PRED ] = speed_map ( Speed , mode_check_freq_map_vhbpred ) ; cpi -> mode_check_freq [ THR_NEW1 ] = speed_map ( Speed , mode_check_freq_map_new1 ) ; cpi -> mode_check_freq [ THR_NEW2 ] = cpi -> mode_check_freq [ THR_NEW3 ] = speed_map ( Speed , mode_check_freq_map_new2 ) ; cpi -> mode_check_freq [ THR_SPLIT1 ] = speed_map ( Speed , mode_check_freq_map_split1 ) ; cpi -> mode_check_freq [ THR_SPLIT2 ] = cpi -> mode_check_freq [ THR_SPLIT3 ] = speed_map ( Speed , mode_check_freq_map_split2 ) ; Speed = cpi -> Speed ; switch ( Mode ) { # if ! ( CONFIG_REALTIME_ONLY ) case 0 : sf -> first_step = 0 ; sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; break ; case 1 : case 3 : if ( Speed > 0 ) { sf -> optimize_coefficients = 0 ; sf -> use_fastquant_for_pick = 1 ; sf -> no_skip_block4x4_search = 0 ; sf -> first_step = 1 ; } if ( Speed > 2 ) { sf -> improved_quant = 0 ; sf -> improved_dct = 0 ; sf -> recode_loop = 2 ; } if ( Speed > 3 ) { sf -> auto_filter = 1 ; sf -> recode_loop = 0 ; sf -> RD = 0 ; } if ( Speed > 4 ) { sf -> auto_filter = 0 ; } break ; # endif case 2 : sf -> optimize_coefficients = 0 ; sf -> recode_loop = 0 ; sf -> auto_filter = 1 ; sf -> iterative_sub_pixel = 1 ; sf -> search_method = NSTEP ; if ( Speed > 0 ) { sf -> improved_quant = 0 ; sf -> improved_dct = 0 ; sf -> use_fastquant_for_pick = 1 ; sf -> no_skip_block4x4_search = 0 ; sf -> first_step = 1 ; } if ( Speed > 2 ) sf -> auto_filter = 0 ; if ( Speed > 3 ) { sf -> RD = 0 ; sf -> auto_filter = 1 ; } if ( Speed > 4 ) { sf -> auto_filter = 0 ; sf -> search_method = HEX ; sf -> iterative_sub_pixel = 0 ; } if ( Speed > 6 ) { unsigned int sum = 0 ; unsigned int total_mbs = cm -> MBs ; int thresh ; unsigned int total_skip ; int min = 2000 ; if ( cpi -> oxcf . encode_breakout > 2000 ) min = cpi -> oxcf . encode_breakout ; min >>= 7 ; for ( i = 0 ; i < min ; i ++ ) { sum += cpi -> mb . error_bins [ i ] ; } total_skip = sum ; sum = 0 ; for ( ; i < 1024 ; i ++ ) { sum += cpi -> mb . error_bins [ i ] ; if ( 10 * sum >= ( unsigned int ) ( cpi -> Speed - 6 ) * ( total_mbs - total_skip ) ) break ; } i -- ; thresh = ( i << 7 ) ; if ( thresh < 2000 ) thresh = 2000 ; if ( ref_frames > 1 ) { sf -> thresh_mult [ THR_NEW1 ] = thresh ; sf -> thresh_mult [ THR_NEAREST1 ] = thresh >> 1 ; sf -> thresh_mult [ THR_NEAR1 ] = thresh >> 1 ; } if ( ref_frames > 2 ) { sf -> thresh_mult [ THR_NEW2 ] = thresh << 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = thresh ; sf -> thresh_mult [ THR_NEAR2 ] = thresh ; } if ( ref_frames > 3 ) { sf -> thresh_mult [ THR_NEW3 ] = thresh << 1 ; sf -> thresh_mult [ THR_NEAREST3 ] = thresh ; sf -> thresh_mult [ THR_NEAR3 ] = thresh ; } sf -> improved_mv_pred = 0 ; } if ( Speed > 8 ) sf -> quarter_pixel_search = 0 ; if ( cm -> version == 0 ) { cm -> filter_type = NORMAL_LOOPFILTER ; if ( Speed >= 14 ) cm -> filter_type = SIMPLE_LOOPFILTER ; } else { cm -> filter_type = SIMPLE_LOOPFILTER ; } if ( Speed >= 15 ) sf -> half_pixel_search = 0 ;  vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ;  } ; if ( cpi -> pass == 1 ) { sf -> improved_quant = 0 ; sf -> optimize_coefficients = 0 ; sf -> improved_dct = 0 ; } if ( cpi -> sf . search_method == NSTEP ) { vp8_init3smotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; } else if ( cpi -> sf . search_method == DIAMOND ) { vp8_init_dsmotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; } if ( cpi -> sf . improved_dct ) { cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; } else { cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; } cpi -> mb . short_walsh4x4 = vp8_short_walsh4x4 ; if ( cpi -> sf . improved_quant ) { cpi -> mb . quantize_b = vp8_regular_quantize_b ;  cpi -> mb . quantize_b_pair = vp8_regular_quantize_b_pair ;  } else {  cpi -> mb . quantize_b = vp8_fast_quantize_b ;  cpi -> mb . quantize_b_pair = vp8_fast_quantize_b_pair ; } if ( cpi -> sf . improved_quant != last_improved_quant ) vp8cx_init_quantizer ( cpi ) ; if ( cpi -> sf . iterative_sub_pixel == 1 ) { cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step_iteratively ; } else if ( cpi -> sf . quarter_pixel_search ) { cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step ; } else if ( cpi -> sf . half_pixel_search ) { cpi -> find_fractional_mv_step = vp8_find_best_half_pixel_step ; } else { cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; } if ( cpi -> sf . optimize_coefficients == 1 && cpi -> pass != 1 ) cpi -> mb . optimize = 1 ; else cpi -> mb . optimize = 0 ; if ( cpi -> common . full_pixel ) cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; # ifdef SPEEDSTATS frames_at_speed [ cpi -> Speed ] ++ ; # endif }",sum += cpi -> mb . quantize_b = vp8_fast_quantize_b ;cpi -> mb . quantize_b_pair = vp8_fast_quantize_b_pair ;,2387
328,"buggy line: char * bufptr ;bufptr = buf ;cwe id:CWE-190context: int jas_stream_read ( jas_stream_t * stream , void * buf , int cnt ) { int n ; int c ;  char * bufptr ;  bufptr = buf ; n = 0 ; while ( n < cnt ) { if ( ( c = jas_stream_getc ( stream ) ) == EOF ) { return n ; } * bufptr ++ = c ; ++ n ; } return n ; }","char * bufptr ;if ( cnt < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ;}bufptr = buf ;",2388
329,"buggy line: struct r_bin_dyldcache_obj_t * bin ;if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) {return NULL ;memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ;if ( ! buf ) {if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) {return r_bin_dyldcache_free ( bin ) ;cwe id:CWE-125context: struct r_bin_dyldcache_obj_t * r_bin_dyldcache_from_bytes_new ( const ut8 * buf , ut64 size ) {  struct r_bin_dyldcache_obj_t * bin ;   if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) {  return NULL ; }  memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ;  if ( ! buf ) { return r_bin_dyldcache_free ( bin ) ; } bin -> b = r_buf_new ( ) ;  if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) {  return r_bin_dyldcache_free ( bin ) ; } if ( ! r_bin_dyldcache_init ( bin ) ) { return r_bin_dyldcache_free ( bin ) ; } bin -> size = size ; return bin ; }","struct r_bin_dyldcache_obj_t * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) ;if ( ! bin ) {return NULL ;memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ;if ( ! bin -> b || ! buf ) {if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) {return r_bin_dyldcache_free ( bin ) ;",2389
330,"buggy line: else  img = ctx -> iface -> dec . get_frame ( ctx -> priv -> alg_priv , iter ) ;return img ;cwe id:CWE-119context: vpx_image_t * vpx_codec_get_frame ( vpx_codec_ctx_t * ctx , vpx_codec_iter_t * iter ) { vpx_image_t * img ; if ( ! ctx || ! iter || ! ctx -> iface || ! ctx -> priv ) img = NULL ; else  img = ctx -> iface -> dec . get_frame ( ctx -> priv -> alg_priv , iter ) ;  return img ; }","else img = ctx -> iface -> dec . get_frame ( get_alg_priv ( ctx ) , iter ) ;return img ;",2390
331,"buggy line: if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ;BeginOfThisString = Offset - SizeOfHeader - 8 ;cwe id:CWE-125context: static void * Type_MLU_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) { cmsMLU * mlu ; cmsUInt32Number Count , RecLen , NumOfWchar ; cmsUInt32Number SizeOfHeader ; cmsUInt32Number Len , Offset ; cmsUInt32Number i ; wchar_t * Block ; cmsUInt32Number BeginOfThisString , EndOfThisString , LargestPosition ; * nItems = 0 ; if ( ! _cmsReadUInt32Number ( io , & Count ) ) return NULL ; if ( ! _cmsReadUInt32Number ( io , & RecLen ) ) return NULL ; if ( RecLen != 12 ) { cmsSignalError ( self -> ContextID , cmsERROR_UNKNOWN_EXTENSION , ""multiLocalizedUnicodeType<S2SV_blank>of<S2SV_blank>len<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported."" ) ; return NULL ; } mlu = cmsMLUalloc ( self -> ContextID , Count ) ; if ( mlu == NULL ) return NULL ; mlu -> UsedEntries = Count ; SizeOfHeader = 12 * Count + sizeof ( _cmsTagBase ) ; LargestPosition = 0 ; for ( i = 0 ; i < Count ; i ++ ) { if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Language ) ) goto Error ; if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Country ) ) goto Error ; if ( ! _cmsReadUInt32Number ( io , & Len ) ) goto Error ; if ( ! _cmsReadUInt32Number ( io , & Offset ) ) goto Error ;  if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ;  BeginOfThisString = Offset - SizeOfHeader - 8 ; mlu -> Entries [ i ] . Len = ( Len * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; mlu -> Entries [ i ] . StrW = ( BeginOfThisString * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; EndOfThisString = BeginOfThisString + Len ; if ( EndOfThisString > LargestPosition ) LargestPosition = EndOfThisString ; } SizeOfTag = ( LargestPosition * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; if ( SizeOfTag == 0 ) { Block = NULL ; NumOfWchar = 0 ; } else { Block = ( wchar_t * ) _cmsMalloc ( self -> ContextID , SizeOfTag ) ; if ( Block == NULL ) goto Error ; NumOfWchar = SizeOfTag / sizeof ( wchar_t ) ; if ( ! _cmsReadWCharArray ( io , NumOfWchar , Block ) ) goto Error ; } mlu -> MemPool = Block ; mlu -> PoolSize = SizeOfTag ; mlu -> PoolUsed = SizeOfTag ; * nItems = 1 ; return ( void * ) mlu ; Error : if ( mlu ) cmsMLUfree ( mlu ) ; return NULL ; }",if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ;if ( ( Offset + Len ) > SizeOfTag + 8 ) goto Error ;BeginOfThisString = Offset - SizeOfHeader - 8 ;,2391
332,"buggy line: static u32 ip_idents_hashrnd __read_mostly ;u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ;hash = jhash_3words ( ( __force u32 ) iph -> daddr ,  ( __force u32 ) iph -> saddr ,  iph -> protocol ^ net_hash_mix ( net ) ,  ip_idents_hashrnd ) ;cwe id:CWE-200context: void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) {  static u32 ip_idents_hashrnd __read_mostly ;  u32 hash , id ;  net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ;   hash = jhash_3words ( ( __force u32 ) iph -> daddr ,  ( __force u32 ) iph -> saddr ,  iph -> protocol ^ net_hash_mix ( net ) ,  ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }","u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( net -> ipv4 . ip_id_key ) ) ;hash = siphash_3u32 ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , iph -> protocol , & net -> ipv4 . ip_id_key ) ;",2392
333,"buggy line: unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;buf [ 1 ] |= 1 << offset ;buf [ 2 ] = gpio_push_pull ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ;if ( ret < 0 ) {hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\\goto fail ;}spin_unlock_irqrestore ( & dev -> lock , flags ) ;cp2112_gpio_set ( chip , offset , value ) ;fail :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret < 0 ? ret : - EIO ;cwe id:CWE-404context: static int cp2112_gpio_direction_output ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ;  unsigned long flags ;  int ret ;  spin_lock_irqsave ( & dev -> lock , flags ) ;  ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_CONFIG_LENGTH ) { hid_err ( hdev , ""error<S2SV_blank>requesting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n"" , ret ) ; goto fail ; } buf [ 1 ] |= 1 << offset ; buf [ 2 ] = gpio_push_pull ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) { hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n"" , ret ) ; goto fail ; }  spin_unlock_irqrestore ( & dev -> lock , flags ) ;  cp2112_gpio_set ( chip , offset , value ) ; return 0 ; fail :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;  return ret < 0 ? ret : - EIO ; }","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;mutex_unlock ( & dev -> lock , flags ) ;cp2112_gpio_set ( chip , offset , value ) ;fail : spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret < 0 ? ret : - EIO ;",2393
334,"buggy line: if ( t -> stamp_path )  touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ;timer_set_state ( t , TIMER_RUNNING ) ;cwe id:CWE-264context: static void timer_enter_running ( Timer * t ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; int r ; assert ( t ) ; if ( unit_stop_pending ( UNIT ( t ) ) ) return ; r = manager_add_job ( UNIT ( t ) -> manager , JOB_START , UNIT_TRIGGER ( UNIT ( t ) ) , JOB_REPLACE , true , & error , NULL ) ; if ( r < 0 ) goto fail ; dual_timestamp_get ( & t -> last_trigger ) ; if ( t -> stamp_path )  touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ;  timer_set_state ( t , TIMER_RUNNING ) ; return ; fail : log_unit_warning ( UNIT ( t ) , ""Failed<S2SV_blank>to<S2SV_blank>queue<S2SV_blank>unit<S2SV_blank>startup<S2SV_blank>job:<S2SV_blank>%s"" , bus_error_message ( & error , r ) ) ; timer_enter_dead ( t , TIMER_FAILURE_RESOURCES ) ; }","if ( t -> stamp_path ) touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , MODE_INVALID ) ;timer_set_state ( t , TIMER_RUNNING ) ;",2394
335,"buggy line: skb_dst_force ( skb ) ;skb_queue_tail ( & sk -> sk_error_queue , skb ) ;cwe id:CWE-125context: int sock_queue_err_skb ( struct sock * sk , struct sk_buff * skb ) { if ( atomic_read ( & sk -> sk_rmem_alloc ) + skb -> truesize >= ( unsigned int ) sk -> sk_rcvbuf ) return - ENOMEM ; skb_orphan ( skb ) ; skb -> sk = sk ; skb -> destructor = sock_rmem_free ; atomic_add ( skb -> truesize , & sk -> sk_rmem_alloc ) ;  skb_dst_force ( skb ) ;  skb_queue_tail ( & sk -> sk_error_queue , skb ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_data_ready ( sk ) ; return 0 ; }","skb_set_err_queue ( skb ) ;skb_dst_force ( skb ) ;skb_queue_tail ( & sk -> sk_error_queue , skb ) ;",2395
336,"buggy line: lua_authz_provider_spec * spec ;apr_pool_userdata_get ( ( void * * ) & provider_name , AUTHZ_PROVIDER_NAME_NOTE , cmd -> temp_pool ) ;if ( require_line && * require_line ) {const char * arg ;spec -> args = apr_array_make ( cmd -> pool , 2 , sizeof ( const char * ) ) ;while ( ( arg = ap_getword_conf ( cmd -> pool , & require_line ) ) && * arg ) {APR_ARRAY_PUSH ( spec -> args , const char * ) = arg ;}* parsed_require_line = spec ;return NULL ;cwe id:CWE-264context: static const char * lua_authz_parse ( cmd_parms * cmd , const char * require_line , const void * * parsed_require_line ) { const char * provider_name ;  lua_authz_provider_spec * spec ;  apr_pool_userdata_get ( ( void * * ) & provider_name , AUTHZ_PROVIDER_NAME_NOTE , cmd -> temp_pool ) ; ap_assert ( provider_name != NULL ) ; spec = apr_hash_get ( lua_authz_providers , provider_name , APR_HASH_KEY_STRING ) ; ap_assert ( spec != NULL ) ;  if ( require_line && * require_line ) {  const char * arg ;  spec -> args = apr_array_make ( cmd -> pool , 2 , sizeof ( const char * ) ) ;  while ( ( arg = ap_getword_conf ( cmd -> pool , & require_line ) ) && * arg ) {  APR_ARRAY_PUSH ( spec -> args , const char * ) = arg ;  } }  * parsed_require_line = spec ;  return NULL ; }","lua_authz_provider_spec * spec ;lua_authz_provider_func * func = apr_pcalloc ( cmd -> pool , sizeof ( lua_authz_provider_func ) ) ;apr_pool_userdata_get ( ( void * * ) & provider_name , AUTHZ_PROVIDER_NAME_NOTE , cmd -> temp_pool ) ;func -> spec = spec ;if ( require_line && * require_line ) {const char * arg ;func -> args = apr_array_make ( cmd -> pool , 2 , sizeof ( const char * ) ) ;while ( ( arg = ap_getword_conf ( cmd -> pool , & require_line ) ) && * arg ) {APR_ARRAY_PUSH ( func -> args , const char * ) = arg ;}* parsed_require_line = func ;return NULL ;",2396
337,"buggy line: len -= cut ;}cwe id:CWE-125context: static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) { size_t width = ( 79 - strlen ( prefix ) ) ; if ( ! config -> mute ) { size_t len ; char * ptr ; char * print_buffer ; print_buffer = curlx_mvaprintf ( fmt , ap ) ; if ( ! print_buffer ) return ; len = strlen ( print_buffer ) ; ptr = print_buffer ; while ( len > 0 ) { fputs ( prefix , config -> errors ) ; if ( len > width ) { size_t cut = width - 1 ; while ( ! ISSPACE ( ptr [ cut ] ) && cut ) { cut -- ; } if ( 0 == cut ) cut = width - 1 ; ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( ""\\n"" , config -> errors ) ; ptr += cut + 1 ;  len -= cut ;  } else { fputs ( ptr , config -> errors ) ; len = 0 ; } } curl_free ( print_buffer ) ; } }",len -= cut + 1 ;},2397
338,"buggy line: authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ;if ( authpending_file_descriptor < 0 ) {cwe id:CWE-000context: int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; int openasuser ; int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name"" ) ; goto done ; } DBG ( ""Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\""%s\\"""" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( ""Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)"" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( ""Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)"" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s"" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( ""Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s"" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)"" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( ""Found<S2SV_blank>user<S2SV_blank>%s"" , user ) ; DBG ( ""Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s"" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)"" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( ""/.config"" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ; } DBG ( ""Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; cfg -> auth_file = buf ; should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; } openasuser = geteuid ( ) == 0 && cfg -> openasuser ; if ( openasuser ) { if ( seteuid ( pw_s . pw_uid ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { if ( seteuid ( 0 ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication"" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting."" ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted"" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( ""authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled"" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( ""Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications"" , cfg -> authpending_file ) ;  authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ;  if ( authpending_file_descriptor < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( ""do_authentication<S2SV_blank>returned<S2SV_blank>%d"" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( ""alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)"" , retval ) ; retval = PAM_SUCCESS ; } DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ;  return retval ;  }","authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY , 0664 ) ;if ( authpending_file_descriptor < 0 ) {if ( cfg -> is_custom_debug_file ) {fclose ( cfg -> debug_file ) ;}",2398
339,"buggy line: return retval ;}cwe id:CWE-000context: int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; int openasuser ; int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name"" ) ; goto done ; } DBG ( ""Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\""%s\\"""" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( ""Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)"" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( ""Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)"" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s"" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( ""Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s"" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)"" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( ""Found<S2SV_blank>user<S2SV_blank>%s"" , user ) ; DBG ( ""Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s"" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)"" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( ""/.config"" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ; } DBG ( ""Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; cfg -> auth_file = buf ; should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; } openasuser = geteuid ( ) == 0 && cfg -> openasuser ; if ( openasuser ) { if ( seteuid ( pw_s . pw_uid ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { if ( seteuid ( 0 ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication"" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting."" ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted"" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( ""authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled"" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( ""Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications"" , cfg -> authpending_file ) ;  authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ;  if ( authpending_file_descriptor < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( ""do_authentication<S2SV_blank>returned<S2SV_blank>%d"" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( ""alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)"" , retval ) ; retval = PAM_SUCCESS ; } DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ;  return retval ;  }",return retval ;},2398
340,"buggy line: vpx_memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ;vpx_memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) ,  SIMD_WIDTH ) ;cwe id:CWE-119context: static void update_sharpness ( loop_filter_info_n * lfi , int sharpness_lvl ) { int lvl ; for ( lvl = 0 ; lvl <= MAX_LOOP_FILTER ; lvl ++ ) { int block_inside_limit = lvl >> ( ( sharpness_lvl > 0 ) + ( sharpness_lvl > 4 ) ) ; if ( sharpness_lvl > 0 ) { if ( block_inside_limit > ( 9 - sharpness_lvl ) ) block_inside_limit = ( 9 - sharpness_lvl ) ; } if ( block_inside_limit < 1 ) block_inside_limit = 1 ;  vpx_memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ;   vpx_memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) ,  SIMD_WIDTH ) ; } }","memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ;memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) , SIMD_WIDTH ) ;",2399
341,"buggy line: recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ;}cwe id:CWE-284context: static void uipc_check_interrupt_locked ( void ) { if ( SAFE_FD_ISSET ( uipc_main . signal_fds [ 0 ] , & uipc_main . read_set ) ) { char sig_recv = 0 ;  recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ;  } }","TEMP_FAILURE_RETRY ( recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ) ;}",2400
342,"buggy line: ASSERT ( redir_index < IOAPIC_NUM_PINS ) ;redir_content = ioapic -> redirtbl [ redir_index ] . bits ;result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ;cwe id:CWE-20context: static unsigned long ioapic_read_indirect ( struct kvm_ioapic * ioapic , unsigned long addr , unsigned long length ) { unsigned long result = 0 ; switch ( ioapic -> ioregsel ) { case IOAPIC_REG_VERSION : result = ( ( ( ( IOAPIC_NUM_PINS - 1 ) & 0xff ) << 16 ) | ( IOAPIC_VERSION_ID & 0xff ) ) ; break ; case IOAPIC_REG_APIC_ID : case IOAPIC_REG_ARB_ID : result = ( ( ioapic -> id & 0xf ) << 24 ) ; break ; default : { u32 redir_index = ( ioapic -> ioregsel - 0x10 ) >> 1 ; u64 redir_content ;  ASSERT ( redir_index < IOAPIC_NUM_PINS ) ;   redir_content = ioapic -> redirtbl [ redir_index ] . bits ;  result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ; break ; } } return result ; }",if ( redir_index < IOAPIC_NUM_PINS ) ;redir_content = ioapic -> redirtbl [ redir_index ] . bits ;else redir_content = ~ 0ULL ;result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ;,2401
343,"buggy line: void  crm_send_remote_msg ( void * session , xmlNode * msg , gboolean encrypted ) {if ( encrypted ) {# ifdef HAVE_GNUTLS_GNUTLS_H cib_send_tls ( session , msg ) ;# else  CRM_ASSERT ( encrypted == FALSE ) ;# endif }cib_send_plaintext ( GPOINTER_TO_INT ( session ) , msg ) ;}}cwe id:CWE-399context:  void  crm_send_remote_msg ( void * session , xmlNode * msg , gboolean encrypted ) {  if ( encrypted ) {  # ifdef HAVE_GNUTLS_GNUTLS_H cib_send_tls ( session , msg ) ;  # else  CRM_ASSERT ( encrypted == FALSE ) ; # endif } else {  cib_send_plaintext ( GPOINTER_TO_INT ( session ) , msg ) ;  }  } ","int crm_send_remote_msg ( void * session , xmlNode * msg , gboolean encrypted ) {int rc = - 1 ;char * xml_text = NULL ;int len = 0 ;xml_text = dump_xml_unformatted ( msg ) ;if ( xml_text ) {len = strlen ( xml_text ) ;}free ( xml_text ) ;return rc ;cib_send_plaintext ( GPOINTER_TO_INT ( session ) , msg ) ;}}",2402
344,"buggy line: ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ;ps_dec -> pv_dec_out = ps_dec_op ;cwe id:CWE-20context: WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ;  ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ;  ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) { break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }","ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ;{UWORD32 u4_size ;u4_size = ps_dec_op -> u4_size ;memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ;ps_dec_op -> u4_size = u4_size ;}ps_dec -> pv_dec_out = ps_dec_op ;",2403
345,"buggy line: if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ;perf_read_regs ( regs ) ;nmi = perf_intr_is_nmi ( regs ) ;if ( nmi ) nmi_enter ( ) ;else irq_enter ( ) ;for ( i = 0 ;i < cpuhw -> n_events ;++ i ) {event = cpuhw -> event [ i ] ;if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ;val = read_pmc ( event -> hw . idx ) ;if ( ( int ) val < 0 ) {found = 1 ;record_and_restart ( event , val , regs , nmi ) ;}}if ( ! found ) {for ( i = 0 ;i < ppmu -> n_counter ;++ i ) {if ( is_limited_pmc ( i + 1 ) ) continue ;val = read_pmc ( i + 1 ) ;if ( ( int ) val < 0 )  write_pmc ( i + 1 , 0 ) ;cwe id:CWE-189context: static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ;  if ( ( int ) val < 0 )  write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }","+ i ) {+ i ) {if ( pmc_overflow ( val ) ) write_pmc ( i + 1 , 0 ) ;",2404
346,"buggy line: }else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) )   ses -> server -> ops = & smb311_operations ;}cwe id:CWE-125context: int SMB2_negotiate ( const unsigned int xid , struct cifs_ses * ses ) { struct smb_rqst rqst ; struct smb2_negotiate_req * req ; struct smb2_negotiate_rsp * rsp ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; int rc = 0 ; int resp_buftype ; struct TCP_Server_Info * server = ses -> server ; int blob_offset , blob_length ; char * security_blob ; int flags = CIFS_NEG_OP ; unsigned int total_len ; cifs_dbg ( FYI , ""Negotiate<S2SV_blank>protocol\\n"" ) ; if ( ! server ) { WARN ( 1 , ""%s:<S2SV_blank>server<S2SV_blank>is<S2SV_blank>NULL!\\n"" , __func__ ) ; return - EIO ; } rc = smb2_plain_req_init ( SMB2_NEGOTIATE , NULL , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; req -> sync_hdr . SessionId = 0 ; memset ( server -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; memset ( ses -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 2 ) ; total_len += 4 ; } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB21_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 2 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> Dialects [ 3 ] = cpu_to_le16 ( SMB311_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 4 ) ; total_len += 8 ; } else { req -> Dialects [ 0 ] = cpu_to_le16 ( ses -> server -> vals -> protocol_id ) ; req -> DialectCount = cpu_to_le16 ( 1 ) ; total_len += 2 ; } if ( ses -> sign ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_REQUIRED ) ; else if ( global_secflags & CIFSSEC_MAY_SIGN ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_ENABLED ) ; else req -> SecurityMode = 0 ; req -> Capabilities = cpu_to_le32 ( ses -> server -> vals -> req_capabilities ) ; if ( ses -> server -> vals -> protocol_id == SMB20_PROT_ID ) memset ( req -> ClientGUID , 0 , SMB2_CLIENT_GUID_SIZE ) ; else { memcpy ( req -> ClientGUID , server -> client_guid , SMB2_CLIENT_GUID_SIZE ) ; if ( ( ses -> server -> vals -> protocol_id == SMB311_PROT_ID ) || ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) ) assemble_neg_contexts ( req , & total_len ) ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; cifs_small_buf_release ( req ) ; rsp = ( struct smb2_negotiate_rsp * ) rsp_iov . iov_base ; if ( rc == - EOPNOTSUPP ) { cifs_dbg ( VFS , ""Dialect<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server.<S2SV_blank>Consider<S2SV_blank>"" ""specifying<S2SV_blank>vers=1.0<S2SV_blank>or<S2SV_blank>vers=2.0<S2SV_blank>on<S2SV_blank>mount<S2SV_blank>for<S2SV_blank>accessing"" ""<S2SV_blank>older<S2SV_blank>servers\\n"" ) ; goto neg_exit ; } else if ( rc != 0 ) goto neg_exit ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2.1<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { ses -> server -> ops = & smb21_operations ;  } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) )   ses -> server -> ops = & smb311_operations ;  } else if ( le16_to_cpu ( rsp -> DialectRevision ) != ses -> server -> vals -> protocol_id ) { cifs_dbg ( VFS , ""Illegal<S2SV_blank>0x%x<S2SV_blank>dialect<S2SV_blank>returned:<S2SV_blank>not<S2SV_blank>requested\\n"" , le16_to_cpu ( rsp -> DialectRevision ) ) ; return - EIO ; } cifs_dbg ( FYI , ""mode<S2SV_blank>0x%x\\n"" , rsp -> SecurityMode ) ; if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb2.0<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb2.1<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB30_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.0<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB302_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.02<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.1.1<S2SV_blank>dialect\\n"" ) ; else { cifs_dbg ( VFS , ""Illegal<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>by<S2SV_blank>server<S2SV_blank>0x%x\\n"" , le16_to_cpu ( rsp -> DialectRevision ) ) ; rc = - EIO ; goto neg_exit ; } server -> dialect = le16_to_cpu ( rsp -> DialectRevision ) ; memcpy ( server -> preauth_sha_hash , ses -> preauth_sha_hash , SMB2_PREAUTH_HASH_SIZE ) ; server -> negflavor = CIFS_NEGFLAVOR_EXTENDED ; server -> maxBuf = min_t ( unsigned int , le32_to_cpu ( rsp -> MaxTransactSize ) , SMB2_MAX_BUFFER_SIZE ) ; server -> max_read = le32_to_cpu ( rsp -> MaxReadSize ) ; server -> max_write = le32_to_cpu ( rsp -> MaxWriteSize ) ; server -> sec_mode = le16_to_cpu ( rsp -> SecurityMode ) ; if ( ( server -> sec_mode & SMB2_SEC_MODE_FLAGS_ALL ) != server -> sec_mode ) cifs_dbg ( FYI , ""Server<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>security<S2SV_blank>mode<S2SV_blank>0x%x\\n"" , server -> sec_mode ) ; server -> capabilities = le32_to_cpu ( rsp -> Capabilities ) ; server -> capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES ; security_blob = smb2_get_data_area_len ( & blob_offset , & blob_length , ( struct smb2_sync_hdr * ) rsp ) ; if ( blob_length == 0 ) { cifs_dbg ( FYI , ""missing<S2SV_blank>security<S2SV_blank>blob<S2SV_blank>on<S2SV_blank>negprot\\n"" ) ; server -> sec_ntlmssp = true ; } rc = cifs_enable_signing ( server , ses -> sign ) ; if ( rc ) goto neg_exit ; if ( blob_length ) { rc = decode_negTokenInit ( security_blob , blob_length , server ) ; if ( rc == 1 ) rc = 0 ; else if ( rc == 0 ) rc = - EIO ; } if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { if ( rsp -> NegotiateContextCount ) rc = smb311_decode_neg_context ( rsp , server , rsp_iov . iov_len ) ; else cifs_dbg ( VFS , ""Missing<S2SV_blank>expected<S2SV_blank>negotiate<S2SV_blank>contexts\\n"" ) ; } neg_exit : free_rsp_buf ( resp_buftype , rsp ) ; return rc ; }",ses -> server -> vals = & smb21_values ;}else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) {ses -> server -> ops = & smb311_operations ;ses -> server -> vals = & smb311_values ;}},2405
347,"buggy line: err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( err < 0 ) return err ;cwe id:CWE-285context: int hfsplus_set_posix_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int err ; char * xattr_name ; size_t size = 0 ; char * value = NULL ; hfs_dbg ( ACL_MOD , ""[%s]:<S2SV_blank>ino<S2SV_blank>%lu\\n"" , __func__ , inode -> i_ino ) ; switch ( type ) { case ACL_TYPE_ACCESS : xattr_name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) {  err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;  if ( err < 0 ) return err ; } err = 0 ; break ; case ACL_TYPE_DEFAULT : xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; if ( unlikely ( size > HFSPLUS_MAX_INLINE_DATA_SIZE ) ) return - ENOMEM ; value = ( char * ) hfsplus_alloc_attr_entry ( ) ; if ( unlikely ( ! value ) ) return - ENOMEM ; err = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( unlikely ( err < 0 ) ) goto end_set_acl ; } err = __hfsplus_setxattr ( inode , xattr_name , value , size , 0 ) ; end_set_acl : hfsplus_destroy_attr_entry ( ( hfsplus_attr_entry * ) value ) ; if ( ! err ) set_cached_acl ( inode , type , acl ) ; return err ; }","err = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( err < 0 ) return err ;",2406
348,"buggy line: if ( report -> id == REPORT_KEY_STATE ) {if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ;cwe id:CWE-119context: static int picolcd_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * raw_data , int size ) { struct picolcd_data * data = hid_get_drvdata ( hdev ) ; unsigned long flags ; int ret = 0 ; if ( ! data ) return 1 ;  if ( report -> id == REPORT_KEY_STATE ) {  if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ; } else if ( report -> id == REPORT_IR_DATA ) { ret = picolcd_raw_cir ( data , report , raw_data + 1 , size - 1 ) ; } else { spin_lock_irqsave ( & data -> lock , flags ) ; if ( data -> pending ) { memcpy ( data -> pending -> raw_data , raw_data + 1 , size - 1 ) ; data -> pending -> raw_size = size - 1 ; data -> pending -> in_report = report ; complete ( & data -> pending -> ready ) ; } spin_unlock_irqrestore ( & data -> lock , flags ) ; } picolcd_debug_raw_event ( data , hdev , report , raw_data , size ) ; return 1 ; }","if ( size > 64 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\\return 0 ;}if ( report -> id == REPORT_KEY_STATE ) {if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ;",2407
349,"buggy line: struct rt6_info * rt = ( struct rt6_info * ) dst ;if ( ! dst )  goto out ;if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) {cwe id:CWE-20context: static struct dst_entry * ip6_sk_dst_check ( struct sock * sk , struct dst_entry * dst , const struct flowi6 * fl6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ;  struct rt6_info * rt = ( struct rt6_info * ) dst ;  if ( ! dst )  goto out ;  if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) { dst_release ( dst ) ; dst = NULL ; } out : return dst ; }","struct rt6_info * rt ;if ( ! dst ) goto out ;if ( dst -> ops -> family != AF_INET6 ) {dst_release ( dst ) ;return NULL ;}rt = ( struct rt6_info * ) dst ;if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) {",2408
350,"buggy line: if ( rc != X86EMUL_CONTINUE ) goto done ;rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ;if ( rc != X86EMUL_CONTINUE ) goto done ;rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ;done :  if ( ctxt -> rip_relative )  ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ;return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ;cwe id:CWE-399context: int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes ^ 12 ; else ctxt -> ad_bytes = def_ad_bytes ^ 6 ; break ; case 0x26 : case 0x2e : case 0x36 : case 0x3e : has_seg_override = true ; ctxt -> seg_override = ( ctxt -> b >> 3 ) & 3 ; break ; case 0x64 : case 0x65 : has_seg_override = true ; ctxt -> seg_override = ctxt -> b & 7 ; break ; case 0x40 ... 0x4f : if ( mode != X86EMUL_MODE_PROT64 ) goto done_prefixes ; ctxt -> rex_prefix = ctxt -> b ; continue ; case 0xf0 : ctxt -> lock_prefix = 1 ; break ; case 0xf2 : case 0xf3 : ctxt -> rep_prefix = ctxt -> b ; break ; default : goto done_prefixes ; } ctxt -> rex_prefix = 0 ; } done_prefixes : if ( ctxt -> rex_prefix & 8 ) ctxt -> op_bytes = 8 ; opcode = opcode_table [ ctxt -> b ] ; if ( ctxt -> b == 0x0f ) { ctxt -> opcode_len = 2 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = twobyte_table [ ctxt -> b ] ; if ( ctxt -> b == 0x38 ) { ctxt -> opcode_len = 3 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = opcode_map_0f_38 [ ctxt -> b ] ; } } ctxt -> d = opcode . flags ; if ( ctxt -> d & ModRM ) ctxt -> modrm = insn_fetch ( u8 , ctxt ) ; if ( ctxt -> opcode_len == 1 && ( ctxt -> b == 0xc5 || ctxt -> b == 0xc4 ) && ( mode == X86EMUL_MODE_PROT64 || ( mode >= X86EMUL_MODE_PROT16 && ( ctxt -> modrm & 0x80 ) ) ) ) { ctxt -> d = NotImpl ; } while ( ctxt -> d & GroupMask ) { switch ( ctxt -> d & GroupMask ) { case Group : goffset = ( ctxt -> modrm >> 3 ) & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case GroupDual : goffset = ( ctxt -> modrm >> 3 ) & 7 ; if ( ( ctxt -> modrm >> 6 ) == 3 ) opcode = opcode . u . gdual -> mod3 [ goffset ] ; else opcode = opcode . u . gdual -> mod012 [ goffset ] ; break ; case RMExt : goffset = ctxt -> modrm & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case Prefix : if ( ctxt -> rep_prefix && op_prefix ) return EMULATION_FAILED ; simd_prefix = op_prefix ? 0x66 : ctxt -> rep_prefix ; switch ( simd_prefix ) { case 0x00 : opcode = opcode . u . gprefix -> pfx_no ; break ; case 0x66 : opcode = opcode . u . gprefix -> pfx_66 ; break ; case 0xf2 : opcode = opcode . u . gprefix -> pfx_f2 ; break ; case 0xf3 : opcode = opcode . u . gprefix -> pfx_f3 ; break ; } break ; case Escape : if ( ctxt -> modrm > 0xbf ) opcode = opcode . u . esc -> high [ ctxt -> modrm - 0xc0 ] ; else opcode = opcode . u . esc -> op [ ( ctxt -> modrm >> 3 ) & 7 ] ; break ; default : return EMULATION_FAILED ; } ctxt -> d &= ~ ( u64 ) GroupMask ; ctxt -> d |= opcode . flags ; } if ( ctxt -> d == 0 ) return EMULATION_FAILED ; ctxt -> execute = opcode . u . execute ; if ( unlikely ( ctxt -> ud ) && likely ( ! ( ctxt -> d & EmulateOnUD ) ) ) return EMULATION_FAILED ; if ( unlikely ( ctxt -> d & ( NotImpl | Stack | Op3264 | Sse | Mmx | Intercept | CheckPerm ) ) ) { ctxt -> check_perm = opcode . check_perm ; ctxt -> intercept = opcode . intercept ; if ( ctxt -> d & NotImpl ) return EMULATION_FAILED ; if ( mode == X86EMUL_MODE_PROT64 && ( ctxt -> d & Stack ) ) ctxt -> op_bytes = 8 ; if ( ctxt -> d & Op3264 ) { if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> op_bytes = 8 ; else ctxt -> op_bytes = 4 ; } if ( ctxt -> d & Sse ) ctxt -> op_bytes = 16 ; else if ( ctxt -> d & Mmx ) ctxt -> op_bytes = 8 ; } if ( ctxt -> d & ModRM ) { rc = decode_modrm ( ctxt , & ctxt -> memop ) ; if ( ! has_seg_override ) { has_seg_override = true ; ctxt -> seg_override = ctxt -> modrm_seg ; } } else if ( ctxt -> d & MemAbs ) rc = decode_abs ( ctxt , & ctxt -> memop ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; if ( ! has_seg_override ) ctxt -> seg_override = VCPU_SREG_DS ; ctxt -> memop . addr . mem . seg = ctxt -> seg_override ; rc = decode_operand ( ctxt , & ctxt -> src , ( ctxt -> d >> SrcShift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ;  done :  if ( ctxt -> rip_relative )  ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ;  return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ; }",if ( ctxt -> rip_relative ) ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ;done : return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ;,2409
351,"buggy line: json_t * object , * foo , * bar , * baz ;void * iter ;if ( json_object_iter ( NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>NULL"" ) ;cwe id:CWE-310context: static void test_iterators ( ) {  json_t * object , * foo , * bar , * baz ;   void * iter ;  if ( json_object_iter ( NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>NULL"" ) ; if ( json_object_iter_next ( NULL , NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>an<S2SV_blank>iterator<S2SV_blank>on<S2SV_blank>a<S2SV_blank>NULL<S2SV_blank>object"" ) ; object = json_object ( ) ; foo = json_string ( ""foo"" ) ; bar = json_string ( ""bar"" ) ; baz = json_string ( ""baz"" ) ; if ( ! object || ! foo || ! bar || ! bar ) fail ( ""unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>values"" ) ; if ( json_object_iter_next ( object , NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>a<S2SV_blank>NULL<S2SV_blank>iterator"" ) ; if ( json_object_set ( object , ""a"" , foo ) || json_object_set ( object , ""b"" , bar ) || json_object_set ( object , ""c"" , baz ) ) fail ( ""unable<S2SV_blank>to<S2SV_blank>populate<S2SV_blank>object"" ) ; iter = json_object_iter ( object ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>iterator"" ) ;  if ( strcmp ( json_object_iter_key ( iter ) , ""a"" ) )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != foo )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;   iter = json_object_iter_next ( object , iter ) ;  if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;   if ( json_object_iter_value ( iter ) != bar )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;  if ( json_object_iter_value ( iter ) != baz )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; if ( json_object_iter_next ( object , iter ) != NULL ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>the<S2SV_blank>end"" ) ; if ( json_object_iter_at ( object , ""foo"" ) ) fail ( ""json_object_iter_at()<S2SV_blank>succeeds<S2SV_blank>for<S2SV_blank>non-existent<S2SV_blank>key"" ) ; iter = json_object_iter_at ( object , ""b"" ) ; if ( ! iter ) fail ( ""json_object_iter_at()<S2SV_blank>fails<S2SV_blank>for<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>key"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != bar ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != baz ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; if ( json_object_iter_set ( object , iter , bar ) ) fail ( ""unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>value<S2SV_blank>at<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""json_object_iter_key()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; if ( json_object_iter_value ( iter ) != bar ) fail ( ""json_object_iter_value()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; if ( json_object_get ( object , ""c"" ) != bar ) fail ( ""json_object_get()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; json_decref ( object ) ; json_decref ( foo ) ; json_decref ( bar ) ; json_decref ( baz ) ; }","int i ;json_t * object , * foo , * bar , * baz ;const char * iter_keys [ 3 ] ;int have_key [ 3 ] = {0 , 0 , 0 };json_t * iter_values [ 3 ] ;void * iter ;if ( json_object_iter ( NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>NULL"" ) ;",2410
352,"buggy line: if ( strcmp ( json_object_iter_key ( iter ) , ""a"" ) )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != foo )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;iter = json_object_iter_next ( object , iter ) ;if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ;if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != bar )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != baz )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;cwe id:CWE-310context: static void test_iterators ( ) {  json_t * object , * foo , * bar , * baz ;   void * iter ;  if ( json_object_iter ( NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>NULL"" ) ; if ( json_object_iter_next ( NULL , NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>an<S2SV_blank>iterator<S2SV_blank>on<S2SV_blank>a<S2SV_blank>NULL<S2SV_blank>object"" ) ; object = json_object ( ) ; foo = json_string ( ""foo"" ) ; bar = json_string ( ""bar"" ) ; baz = json_string ( ""baz"" ) ; if ( ! object || ! foo || ! bar || ! bar ) fail ( ""unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>values"" ) ; if ( json_object_iter_next ( object , NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>a<S2SV_blank>NULL<S2SV_blank>iterator"" ) ; if ( json_object_set ( object , ""a"" , foo ) || json_object_set ( object , ""b"" , bar ) || json_object_set ( object , ""c"" , baz ) ) fail ( ""unable<S2SV_blank>to<S2SV_blank>populate<S2SV_blank>object"" ) ; iter = json_object_iter ( object ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>iterator"" ) ;  if ( strcmp ( json_object_iter_key ( iter ) , ""a"" ) )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != foo )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;   iter = json_object_iter_next ( object , iter ) ;  if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;   if ( json_object_iter_value ( iter ) != bar )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;  if ( json_object_iter_value ( iter ) != baz )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; if ( json_object_iter_next ( object , iter ) != NULL ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>the<S2SV_blank>end"" ) ; if ( json_object_iter_at ( object , ""foo"" ) ) fail ( ""json_object_iter_at()<S2SV_blank>succeeds<S2SV_blank>for<S2SV_blank>non-existent<S2SV_blank>key"" ) ; iter = json_object_iter_at ( object , ""b"" ) ; if ( ! iter ) fail ( ""json_object_iter_at()<S2SV_blank>fails<S2SV_blank>for<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>key"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != bar ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != baz ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; if ( json_object_iter_set ( object , iter , bar ) ) fail ( ""unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>value<S2SV_blank>at<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""json_object_iter_key()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; if ( json_object_iter_value ( iter ) != bar ) fail ( ""json_object_iter_value()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; if ( json_object_get ( object , ""c"" ) != bar ) fail ( ""json_object_get()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; json_decref ( object ) ; json_decref ( foo ) ; json_decref ( bar ) ; json_decref ( baz ) ; }","iter_keys [ 0 ] = json_object_iter_key ( iter ) ;iter_values [ 0 ] = json_object_iter_value ( iter ) ;iter_keys [ 1 ] = json_object_iter_key ( iter ) ;iter_values [ 1 ] = json_object_iter_value ( iter ) ;iter = json_object_iter_next ( object , iter ) ;if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ;iter_keys [ 2 ] = json_object_iter_key ( iter ) ;iter_values [ 2 ] = json_object_iter_value ( iter ) ;if ( json_object_iter_next ( object , iter ) != NULL ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>the<S2SV_blank>end"" ) ;for ( i = 0 ;i < 3 ;i ++ ) {if ( strcmp ( iter_keys [ i ] , ""a"" ) ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>a"" ) ;else have_key [ 0 ] = 1 ;}else if ( strcmp ( iter_keys [ i ] , ""b"" ) == 0 ) {if ( iter_values [ i ] != bar ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>b"" ) ;else have_key [ 1 ] = 1 ;}else if ( strcmp ( iter_keys [ i ] , ""c"" ) == 0 ) {if ( iter_values [ i ] != baz ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>c"" ) ;else have_key [ 2 ] = 1 ;}}for ( i = 0 ;i < 3 ;i ++ ) {if ( ! have_key [ i ] ) fail ( ""a<S2SV_blank>key<S2SV_blank>wasn\\\'t<S2SV_blank>iterated<S2SV_blank>over"" ) ;}if ( json_object_iter_at ( object , ""foo"" ) ) fail ( ""json_object_iter_at()<S2SV_blank>succeeds<S2SV_blank>for<S2SV_blank>non-existent<S2SV_blank>key"" ) ;iter = json_object_iter_at ( object , ""b"" ) ;if ( ! iter ) fail ( ""json_object_iter_at()<S2SV_blank>fails<S2SV_blank>for<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>key"" ) ;if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != bar ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != foo ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;if ( json_object_iter_set ( object , iter , baz ) ) fail ( ""json_object_iter_key()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ;if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ;if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != baz ) fail ( ""json_object_iter_value()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ;if ( json_object_get ( object , ""b"" ) != baz ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;",2410
353,"buggy line: memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ;SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ;cwe id:CWE-119context: static int cac_get_serial_nr_from_CUID ( sc_card_t * card , sc_serial_number_t * serial ) { cac_private_data_t * priv = CAC_DATA ( card ) ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_NORMAL ) ; if ( card -> serialnr . len ) { * serial = card -> serialnr ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ;  memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ;  SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ; }","memcpy ( serial -> value , priv -> cac_id , serial -> len ) ;SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ;",2411
354,"buggy line: for ( i = 0 ;i < 4 && out -> data [ i ] ;int hsub = s -> draw . hsub [ i ] ;cwe id:CWE-119context: static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { PadContext * s = inlink -> dst -> priv ; AVFrame * out ; int needs_copy = frame_needs_copy ( s , in ) ; if ( needs_copy ) { av_log ( inlink -> dst , AV_LOG_DEBUG , ""Direct<S2SV_blank>padding<S2SV_blank>impossible<S2SV_blank>allocating<S2SV_blank>new<S2SV_blank>frame\\n"" ) ; out = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , FFMAX ( inlink -> w , s -> w ) , FFMAX ( inlink -> h , s -> h ) ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } else { int i ; out = in ;  for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) {  int hsub = s -> draw . hsub [ i ] ; int vsub = s -> draw . vsub [ i ] ; out -> data [ i ] -= ( s -> x >> hsub ) * s -> draw . pixelstep [ i ] + ( s -> y >> vsub ) * out -> linesize [ i ] ; } } if ( s -> y ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , 0 , s -> w , s -> y ) ; } if ( s -> h > s -> y + s -> in_h ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y + s -> in_h , s -> w , s -> h - s -> y - s -> in_h ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y , s -> x , in -> height ) ; if ( needs_copy ) { ff_copy_rectangle2 ( & s -> draw , out -> data , out -> linesize , in -> data , in -> linesize , s -> x , s -> y , 0 , 0 , in -> width , in -> height ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , s -> x + s -> in_w , s -> y , s -> w - s -> x - s -> in_w , in -> height ) ; out -> width = s -> w ; out -> height = s -> h ; if ( in != out ) av_frame_free ( & in ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , out ) ; }",for ( i = 0 ;i < 4 && out -> data [ i ] && out -> linesize [ i ] ;int hsub = s -> draw . hsub [ i ] ;,2412
355,"buggy line: if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ;if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR )  return 1 ;cwe id:CWE-388context: static int handle_exception ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct kvm_run * kvm_run = vcpu -> run ; u32 intr_info , ex_no , error_code ; unsigned long cr2 , rip , dr6 ; u32 vect_info ; enum emulation_result er ; vect_info = vmx -> idt_vectoring_info ; intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ;  if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR )  return 1 ; if ( is_no_device ( intr_info ) ) { vmx_fpu_activate ( vcpu ) ; return 1 ; } if ( is_invalid_opcode ( intr_info ) ) { if ( is_guest_mode ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } er = emulate_instruction ( vcpu , EMULTYPE_TRAP_UD ) ; if ( er != EMULATE_DONE ) kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } error_code = 0 ; if ( intr_info & INTR_INFO_DELIVER_CODE_MASK ) error_code = vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) ; if ( ( vect_info & VECTORING_INFO_VALID_MASK ) && ! ( is_page_fault ( intr_info ) && ! ( error_code & PFERR_RSVD_MASK ) ) ) { vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_SIMUL_EX ; vcpu -> run -> internal . ndata = 3 ; vcpu -> run -> internal . data [ 0 ] = vect_info ; vcpu -> run -> internal . data [ 1 ] = intr_info ; vcpu -> run -> internal . data [ 2 ] = error_code ; return 0 ; } if ( is_page_fault ( intr_info ) ) { BUG_ON ( enable_ept ) ; cr2 = vmcs_readl ( EXIT_QUALIFICATION ) ; trace_kvm_page_fault ( cr2 , error_code ) ; if ( kvm_event_needs_reinjection ( vcpu ) ) kvm_mmu_unprotect_page_virt ( vcpu , cr2 ) ; return kvm_mmu_page_fault ( vcpu , cr2 , error_code , NULL , 0 ) ; } ex_no = intr_info & INTR_INFO_VECTOR_MASK ; if ( vmx -> rmode . vm86_active && rmode_exception ( vcpu , ex_no ) ) return handle_rmode_exception ( vcpu , ex_no , error_code ) ; switch ( ex_no ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case DB_VECTOR : dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ; if ( ! ( vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) ) { vcpu -> arch . dr6 &= ~ 15 ; vcpu -> arch . dr6 |= dr6 | DR6_RTM ; if ( ! ( dr6 & ~ DR6_RESERVED ) ) skip_emulated_instruction ( vcpu ) ; kvm_queue_exception ( vcpu , DB_VECTOR ) ; return 1 ; } kvm_run -> debug . arch . dr6 = dr6 | DR6_FIXED_1 ; kvm_run -> debug . arch . dr7 = vmcs_readl ( GUEST_DR7 ) ; case BP_VECTOR : vmx -> vcpu . arch . event_exit_inst_len = vmcs_read32 ( VM_EXIT_INSTRUCTION_LEN ) ; kvm_run -> exit_reason = KVM_EXIT_DEBUG ; rip = kvm_rip_read ( vcpu ) ; kvm_run -> debug . arch . pc = vmcs_readl ( GUEST_CS_BASE ) + rip ; kvm_run -> debug . arch . exception = ex_no ; break ; default : kvm_run -> exit_reason = KVM_EXIT_EXCEPTION ; kvm_run -> ex . exception = ex_no ; kvm_run -> ex . error_code = error_code ; break ; } return 0 ; }",if ( is_nmi ( intr_info ) ) return 1 ;,2413
356,"buggy line: unsigned char * data ;uint32_t * data32 ;cwe id:CWE-119context: static int hybiReadAndDecode ( ws_ctx_t * wsctx , char * dst , int len , int * sockRet , int nInBuf ) { int n ; int i ; int toReturn ; int toDecode ; int bufsize ; int nextRead ;  unsigned char * data ;  uint32_t * data32 ; memcpy ( wsctx -> writePos , wsctx -> carryBuf , wsctx -> carrylen ) ; wsctx -> writePos += wsctx -> carrylen ; bufsize = wsctx -> codeBufDecode + ARRAYSIZE ( wsctx -> codeBufDecode ) - wsctx -> writePos - 1 ; ws_dbg ( ""bufsize=%d\\n"" , bufsize ) ; if ( hybiRemaining ( wsctx ) > bufsize ) { nextRead = bufsize ; } else { nextRead = hybiRemaining ( wsctx ) ; } ws_dbg ( ""calling<S2SV_blank>read<S2SV_blank>with<S2SV_blank>buf=%p<S2SV_blank>and<S2SV_blank>len=%d<S2SV_blank>(decodebuf=%p<S2SV_blank>headerLen=%d)\\n"" , wsctx -> writePos , nextRead , wsctx -> codeBufDecode , wsctx -> header . headerLen ) ; if ( nextRead > 0 ) { if ( - 1 == ( n = wsctx -> ctxInfo . readFunc ( wsctx -> ctxInfo . ctxPtr , wsctx -> writePos , nextRead ) ) ) { int olderrno = errno ; rfbErr ( ""%s:<S2SV_blank>read;<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; errno = olderrno ; * sockRet = - 1 ; return WS_HYBI_STATE_ERR ; } else if ( n == 0 ) { * sockRet = 0 ; return WS_HYBI_STATE_ERR ; } else { ws_dbg ( ""read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>socket;<S2SV_blank>nRead=%d\\n"" , n , wsctx -> nReadPayload ) ; } } else { n = 0 ; } wsctx -> nReadPayload += n ; wsctx -> writePos += n ; if ( hybiRemaining ( wsctx ) == 0 ) { wsctx -> hybiDecodeState = WS_HYBI_STATE_FRAME_COMPLETE ; } toDecode = n + wsctx -> carrylen + nInBuf ; ws_dbg ( ""toDecode=%d<S2SV_blank>from<S2SV_blank>n=%d<S2SV_blank>carrylen=%d<S2SV_blank>headerLen=%d\\n"" , toDecode , n , wsctx -> carrylen , wsctx -> header . headerLen ) ; if ( toDecode < 0 ) { rfbErr ( ""%s:<S2SV_blank>internal<S2SV_blank>error;<S2SV_blank>negative<S2SV_blank>number<S2SV_blank>of<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>decode:<S2SV_blank>%d"" , __func__ , toDecode ) ; errno = EIO ; * sockRet = - 1 ; return WS_HYBI_STATE_ERR ; } data = ( unsigned char * ) ( wsctx -> writePos - toDecode ) ;  data32 = ( uint32_t * ) data ;  for ( i = 0 ; i < ( toDecode >> 2 ) ; i ++ ) {  data32 [ i ] ^= wsctx -> header . mask . u ;  } ws_dbg ( ""mask<S2SV_blank>decoding;<S2SV_blank>i=%d<S2SV_blank>toDecode=%d\\n"" , i , toDecode ) ; if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE ) { for ( i *= 4 ; i < toDecode ; i ++ ) { data [ i ] ^= wsctx -> header . mask . c [ i % 4 ] ; } wsctx -> carrylen = 0 ; } else { wsctx -> carrylen = toDecode - ( i * 4 ) ; if ( wsctx -> carrylen < 0 || wsctx -> carrylen > ARRAYSIZE ( wsctx -> carryBuf ) ) { rfbErr ( ""%s:<S2SV_blank>internal<S2SV_blank>error,<S2SV_blank>invalid<S2SV_blank>carry<S2SV_blank>over<S2SV_blank>size:<S2SV_blank>carrylen=%d,<S2SV_blank>toDecode=%d,<S2SV_blank>i=%d"" , __func__ , wsctx -> carrylen , toDecode , i ) ; * sockRet = - 1 ; errno = EIO ; return WS_HYBI_STATE_ERR ; } ws_dbg ( ""carrying<S2SV_blank>over<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p\\n"" , wsctx -> carrylen , wsctx -> writePos + ( i * 4 ) , wsctx -> carryBuf ) ; memcpy ( wsctx -> carryBuf , data + ( i * 4 ) , wsctx -> carrylen ) ; wsctx -> writePos -= wsctx -> carrylen ; } toReturn = toDecode - wsctx -> carrylen ; switch ( wsctx -> header . opcode ) { case WS_OPCODE_CLOSE : if ( hybiWsFrameComplete ( wsctx ) ) { * ( wsctx -> writePos ) = '\\0' ; ws_dbg ( ""got<S2SV_blank>close<S2SV_blank>cmd<S2SV_blank>%d,<S2SV_blank>reason<S2SV_blank>%d:<S2SV_blank>%s\\n"" , ( int ) ( wsctx -> writePos - hybiPayloadStart ( wsctx ) ) , WS_NTOH16 ( ( ( uint16_t * ) hybiPayloadStart ( wsctx ) ) [ 0 ] ) , & hybiPayloadStart ( wsctx ) [ 2 ] ) ; errno = ECONNRESET ; * sockRet = - 1 ; return WS_HYBI_STATE_FRAME_COMPLETE ; } else { ws_dbg ( ""got<S2SV_blank>close<S2SV_blank>cmd;<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>more<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>arrive\\n"" , hybiRemaining ( wsctx ) ) ; * sockRet = - 1 ; errno = EAGAIN ; return WS_HYBI_STATE_CLOSE_REASON_PENDING ; } break ; case WS_OPCODE_TEXT_FRAME : data [ toReturn ] = '\\0' ; ws_dbg ( ""Initiate<S2SV_blank>Base64<S2SV_blank>decoding<S2SV_blank>in<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>max<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>\'\\\\0\'<S2SV_blank>at<S2SV_blank>%p\\n"" , data , bufsize , data + toReturn ) ; if ( - 1 == ( wsctx -> readlen = rfbBase64PtoN ( ( char * ) data , data , bufsize ) ) ) { rfbErr ( ""%s:<S2SV_blank>Base64<S2SV_blank>decode<S2SV_blank>error;<S2SV_blank>%s\\n"" , __func__ , strerror ( errno ) ) ; } wsctx -> writePos = hybiPayloadStart ( wsctx ) ; break ; case WS_OPCODE_BINARY_FRAME : wsctx -> readlen = toReturn ; wsctx -> writePos = hybiPayloadStart ( wsctx ) ; ws_dbg ( ""set<S2SV_blank>readlen=%d<S2SV_blank>writePos=%p\\n"" , wsctx -> readlen , wsctx -> writePos ) ; break ; default : rfbErr ( ""%s:<S2SV_blank>unhandled<S2SV_blank>opcode<S2SV_blank>%d,<S2SV_blank>b0:<S2SV_blank>%02x,<S2SV_blank>b1:<S2SV_blank>%02x\\n"" , __func__ , ( int ) wsctx -> header . opcode , wsctx -> header . data -> b0 , wsctx -> header . data -> b1 ) ; } wsctx -> readPos = data ; return hybiReturnData ( dst , len , wsctx , sockRet ) ; }",unsigned char * data ;,2414
357,"buggy line: errno = EIO ;* sockRet = - 1 ;return WS_HYBI_STATE_ERR ;}data = ( unsigned char * ) ( wsctx -> writePos - toDecode ) ;data32 = ( uint32_t * ) data ;for ( i = 0 ;data32 [ i ] ^= wsctx -> header . mask . u ;}data [ i ] ^= wsctx -> header . mask . c [ i % 4 ] ;cwe id:CWE-119context: static int hybiReadAndDecode ( ws_ctx_t * wsctx , char * dst , int len , int * sockRet , int nInBuf ) { int n ; int i ; int toReturn ; int toDecode ; int bufsize ; int nextRead ;  unsigned char * data ;  uint32_t * data32 ; memcpy ( wsctx -> writePos , wsctx -> carryBuf , wsctx -> carrylen ) ; wsctx -> writePos += wsctx -> carrylen ; bufsize = wsctx -> codeBufDecode + ARRAYSIZE ( wsctx -> codeBufDecode ) - wsctx -> writePos - 1 ; ws_dbg ( ""bufsize=%d\\n"" , bufsize ) ; if ( hybiRemaining ( wsctx ) > bufsize ) { nextRead = bufsize ; } else { nextRead = hybiRemaining ( wsctx ) ; } ws_dbg ( ""calling<S2SV_blank>read<S2SV_blank>with<S2SV_blank>buf=%p<S2SV_blank>and<S2SV_blank>len=%d<S2SV_blank>(decodebuf=%p<S2SV_blank>headerLen=%d)\\n"" , wsctx -> writePos , nextRead , wsctx -> codeBufDecode , wsctx -> header . headerLen ) ; if ( nextRead > 0 ) { if ( - 1 == ( n = wsctx -> ctxInfo . readFunc ( wsctx -> ctxInfo . ctxPtr , wsctx -> writePos , nextRead ) ) ) { int olderrno = errno ; rfbErr ( ""%s:<S2SV_blank>read;<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; errno = olderrno ; * sockRet = - 1 ; return WS_HYBI_STATE_ERR ; } else if ( n == 0 ) { * sockRet = 0 ; return WS_HYBI_STATE_ERR ; } else { ws_dbg ( ""read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>socket;<S2SV_blank>nRead=%d\\n"" , n , wsctx -> nReadPayload ) ; } } else { n = 0 ; } wsctx -> nReadPayload += n ; wsctx -> writePos += n ; if ( hybiRemaining ( wsctx ) == 0 ) { wsctx -> hybiDecodeState = WS_HYBI_STATE_FRAME_COMPLETE ; } toDecode = n + wsctx -> carrylen + nInBuf ; ws_dbg ( ""toDecode=%d<S2SV_blank>from<S2SV_blank>n=%d<S2SV_blank>carrylen=%d<S2SV_blank>headerLen=%d\\n"" , toDecode , n , wsctx -> carrylen , wsctx -> header . headerLen ) ; if ( toDecode < 0 ) { rfbErr ( ""%s:<S2SV_blank>internal<S2SV_blank>error;<S2SV_blank>negative<S2SV_blank>number<S2SV_blank>of<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>decode:<S2SV_blank>%d"" , __func__ , toDecode ) ; errno = EIO ; * sockRet = - 1 ; return WS_HYBI_STATE_ERR ; } data = ( unsigned char * ) ( wsctx -> writePos - toDecode ) ;  data32 = ( uint32_t * ) data ;  for ( i = 0 ; i < ( toDecode >> 2 ) ; i ++ ) {  data32 [ i ] ^= wsctx -> header . mask . u ;  } ws_dbg ( ""mask<S2SV_blank>decoding;<S2SV_blank>i=%d<S2SV_blank>toDecode=%d\\n"" , i , toDecode ) ; if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE ) { for ( i *= 4 ; i < toDecode ; i ++ ) { data [ i ] ^= wsctx -> header . mask . c [ i % 4 ] ; } wsctx -> carrylen = 0 ; } else { wsctx -> carrylen = toDecode - ( i * 4 ) ; if ( wsctx -> carrylen < 0 || wsctx -> carrylen > ARRAYSIZE ( wsctx -> carryBuf ) ) { rfbErr ( ""%s:<S2SV_blank>internal<S2SV_blank>error,<S2SV_blank>invalid<S2SV_blank>carry<S2SV_blank>over<S2SV_blank>size:<S2SV_blank>carrylen=%d,<S2SV_blank>toDecode=%d,<S2SV_blank>i=%d"" , __func__ , wsctx -> carrylen , toDecode , i ) ; * sockRet = - 1 ; errno = EIO ; return WS_HYBI_STATE_ERR ; } ws_dbg ( ""carrying<S2SV_blank>over<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p\\n"" , wsctx -> carrylen , wsctx -> writePos + ( i * 4 ) , wsctx -> carryBuf ) ; memcpy ( wsctx -> carryBuf , data + ( i * 4 ) , wsctx -> carrylen ) ; wsctx -> writePos -= wsctx -> carrylen ; } toReturn = toDecode - wsctx -> carrylen ; switch ( wsctx -> header . opcode ) { case WS_OPCODE_CLOSE : if ( hybiWsFrameComplete ( wsctx ) ) { * ( wsctx -> writePos ) = '\\0' ; ws_dbg ( ""got<S2SV_blank>close<S2SV_blank>cmd<S2SV_blank>%d,<S2SV_blank>reason<S2SV_blank>%d:<S2SV_blank>%s\\n"" , ( int ) ( wsctx -> writePos - hybiPayloadStart ( wsctx ) ) , WS_NTOH16 ( ( ( uint16_t * ) hybiPayloadStart ( wsctx ) ) [ 0 ] ) , & hybiPayloadStart ( wsctx ) [ 2 ] ) ; errno = ECONNRESET ; * sockRet = - 1 ; return WS_HYBI_STATE_FRAME_COMPLETE ; } else { ws_dbg ( ""got<S2SV_blank>close<S2SV_blank>cmd;<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>more<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>arrive\\n"" , hybiRemaining ( wsctx ) ) ; * sockRet = - 1 ; errno = EAGAIN ; return WS_HYBI_STATE_CLOSE_REASON_PENDING ; } break ; case WS_OPCODE_TEXT_FRAME : data [ toReturn ] = '\\0' ; ws_dbg ( ""Initiate<S2SV_blank>Base64<S2SV_blank>decoding<S2SV_blank>in<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>max<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>\'\\\\0\'<S2SV_blank>at<S2SV_blank>%p\\n"" , data , bufsize , data + toReturn ) ; if ( - 1 == ( wsctx -> readlen = rfbBase64PtoN ( ( char * ) data , data , bufsize ) ) ) { rfbErr ( ""%s:<S2SV_blank>Base64<S2SV_blank>decode<S2SV_blank>error;<S2SV_blank>%s\\n"" , __func__ , strerror ( errno ) ) ; } wsctx -> writePos = hybiPayloadStart ( wsctx ) ; break ; case WS_OPCODE_BINARY_FRAME : wsctx -> readlen = toReturn ; wsctx -> writePos = hybiPayloadStart ( wsctx ) ; ws_dbg ( ""set<S2SV_blank>readlen=%d<S2SV_blank>writePos=%p\\n"" , wsctx -> readlen , wsctx -> writePos ) ; break ; default : rfbErr ( ""%s:<S2SV_blank>unhandled<S2SV_blank>opcode<S2SV_blank>%d,<S2SV_blank>b0:<S2SV_blank>%02x,<S2SV_blank>b1:<S2SV_blank>%02x\\n"" , __func__ , ( int ) wsctx -> header . opcode , wsctx -> header . data -> b0 , wsctx -> header . data -> b1 ) ; } wsctx -> readPos = data ; return hybiReturnData ( dst , len , wsctx , sockRet ) ; }","for ( i = 0 ;data32 [ i ] ^= wsctx -> header . mask . u ;}uint32_t tmp ;memcpy ( & tmp , data + i * sizeof ( tmp ) , sizeof ( tmp ) ) ;tmp ^= wsctx -> header . mask . c [ i % 4 ] ;",2414
358,"buggy line: return mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ;}cwe id:CWE-264context: static struct dentry * aio_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { static const struct dentry_operations ops = { . d_dname = simple_dname , } ;  return mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ;   } ","struct dentry * root = mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ;if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ;return root ;}",2415
359,"buggy line: case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ;* dptr ++ = lci2 ;* dptr ++ = frametype ;* dptr ++ = 0xAA ;memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;cwe id:CWE-20context: void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ;  * dptr ++ = 0xAA ;  memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE:<S2SV_blank>rose_write_internal<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>frametype<S2SV_blank>%02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }","case ROSE_CALL_REQUEST : * dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL ;memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;",2416
360,"buggy line: cwe id:CWE-125context: static int xid_map_enter ( netdissect_options * ndo , const struct sunrpc_msg * rp , const u_char * bp ) { const struct ip * ip = NULL ; const struct ip6_hdr * ip6 = NULL ; struct xid_map_entry * xmep ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 ) ; switch ( IP_V ( ( const struct ip * ) bp ) ) { case 4 : ip = ( const struct ip * ) bp ; break ; case 6 : ip6 = ( const struct ip6_hdr * ) bp ; break ; default : return ( 1 ) ; } xmep = & xid_map [ xid_map_next ] ; if ( ++ xid_map_next >= XIDMAPSIZE ) xid_map_next = 0 ; UNALIGNED_MEMCPY ( & xmep -> xid , & rp -> rm_xid , sizeof ( xmep -> xid ) ) ; if ( ip ) { xmep -> ipver = 4 ; UNALIGNED_MEMCPY ( & xmep -> client , & ip -> ip_src , sizeof ( ip -> ip_src ) ) ; UNALIGNED_MEMCPY ( & xmep -> server , & ip -> ip_dst , sizeof ( ip -> ip_dst ) ) ; } else if ( ip6 ) { xmep -> ipver = 6 ; UNALIGNED_MEMCPY ( & xmep -> client , & ip6 -> ip6_src , sizeof ( ip6 -> ip6_src ) ) ; UNALIGNED_MEMCPY ( & xmep -> server , & ip6 -> ip6_dst , sizeof ( ip6 -> ip6_dst ) ) ; }  xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ;  xmep -> vers = EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) ; return ( 1 ) ; }",if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ;if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 ) ) return ( 0 ) ;,2417
361,"buggy line: xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ;xmep -> vers = EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) ;cwe id:CWE-125context: static int xid_map_enter ( netdissect_options * ndo , const struct sunrpc_msg * rp , const u_char * bp ) { const struct ip * ip = NULL ; const struct ip6_hdr * ip6 = NULL ; struct xid_map_entry * xmep ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 ) ; switch ( IP_V ( ( const struct ip * ) bp ) ) { case 4 : ip = ( const struct ip * ) bp ; break ; case 6 : ip6 = ( const struct ip6_hdr * ) bp ; break ; default : return ( 1 ) ; } xmep = & xid_map [ xid_map_next ] ; if ( ++ xid_map_next >= XIDMAPSIZE ) xid_map_next = 0 ; UNALIGNED_MEMCPY ( & xmep -> xid , & rp -> rm_xid , sizeof ( xmep -> xid ) ) ; if ( ip ) { xmep -> ipver = 4 ; UNALIGNED_MEMCPY ( & xmep -> client , & ip -> ip_src , sizeof ( ip -> ip_src ) ) ; UNALIGNED_MEMCPY ( & xmep -> server , & ip -> ip_dst , sizeof ( ip -> ip_dst ) ) ; } else if ( ip6 ) { xmep -> ipver = 6 ; UNALIGNED_MEMCPY ( & xmep -> client , & ip6 -> ip6_src , sizeof ( ip6 -> ip6_src ) ) ; UNALIGNED_MEMCPY ( & xmep -> server , & ip6 -> ip6_dst , sizeof ( ip6 -> ip6_dst ) ) ; }  xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ;  xmep -> vers = EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) ; return ( 1 ) ; }",xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ;xmep -> vers = EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) ;,2417
362,"buggy line: vmcs_write32 ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ;}cwe id:CWE-000context: static int prepare_vmcs02 ( struct kvm_vcpu * vcpu , struct vmcs12 * vmcs12 , bool from_vmentry , u32 * entry_failure_code ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; u32 exec_control , vmcs12_exec_ctrl ; vmcs_write16 ( GUEST_ES_SELECTOR , vmcs12 -> guest_es_selector ) ; vmcs_write16 ( GUEST_CS_SELECTOR , vmcs12 -> guest_cs_selector ) ; vmcs_write16 ( GUEST_SS_SELECTOR , vmcs12 -> guest_ss_selector ) ; vmcs_write16 ( GUEST_DS_SELECTOR , vmcs12 -> guest_ds_selector ) ; vmcs_write16 ( GUEST_FS_SELECTOR , vmcs12 -> guest_fs_selector ) ; vmcs_write16 ( GUEST_GS_SELECTOR , vmcs12 -> guest_gs_selector ) ; vmcs_write16 ( GUEST_LDTR_SELECTOR , vmcs12 -> guest_ldtr_selector ) ; vmcs_write16 ( GUEST_TR_SELECTOR , vmcs12 -> guest_tr_selector ) ; vmcs_write32 ( GUEST_ES_LIMIT , vmcs12 -> guest_es_limit ) ; vmcs_write32 ( GUEST_CS_LIMIT , vmcs12 -> guest_cs_limit ) ; vmcs_write32 ( GUEST_SS_LIMIT , vmcs12 -> guest_ss_limit ) ; vmcs_write32 ( GUEST_DS_LIMIT , vmcs12 -> guest_ds_limit ) ; vmcs_write32 ( GUEST_FS_LIMIT , vmcs12 -> guest_fs_limit ) ; vmcs_write32 ( GUEST_GS_LIMIT , vmcs12 -> guest_gs_limit ) ; vmcs_write32 ( GUEST_LDTR_LIMIT , vmcs12 -> guest_ldtr_limit ) ; vmcs_write32 ( GUEST_TR_LIMIT , vmcs12 -> guest_tr_limit ) ; vmcs_write32 ( GUEST_GDTR_LIMIT , vmcs12 -> guest_gdtr_limit ) ; vmcs_write32 ( GUEST_IDTR_LIMIT , vmcs12 -> guest_idtr_limit ) ; vmcs_write32 ( GUEST_ES_AR_BYTES , vmcs12 -> guest_es_ar_bytes ) ; vmcs_write32 ( GUEST_CS_AR_BYTES , vmcs12 -> guest_cs_ar_bytes ) ; vmcs_write32 ( GUEST_SS_AR_BYTES , vmcs12 -> guest_ss_ar_bytes ) ; vmcs_write32 ( GUEST_DS_AR_BYTES , vmcs12 -> guest_ds_ar_bytes ) ; vmcs_write32 ( GUEST_FS_AR_BYTES , vmcs12 -> guest_fs_ar_bytes ) ; vmcs_write32 ( GUEST_GS_AR_BYTES , vmcs12 -> guest_gs_ar_bytes ) ; vmcs_write32 ( GUEST_LDTR_AR_BYTES , vmcs12 -> guest_ldtr_ar_bytes ) ; vmcs_write32 ( GUEST_TR_AR_BYTES , vmcs12 -> guest_tr_ar_bytes ) ; vmcs_writel ( GUEST_ES_BASE , vmcs12 -> guest_es_base ) ; vmcs_writel ( GUEST_CS_BASE , vmcs12 -> guest_cs_base ) ; vmcs_writel ( GUEST_SS_BASE , vmcs12 -> guest_ss_base ) ; vmcs_writel ( GUEST_DS_BASE , vmcs12 -> guest_ds_base ) ; vmcs_writel ( GUEST_FS_BASE , vmcs12 -> guest_fs_base ) ; vmcs_writel ( GUEST_GS_BASE , vmcs12 -> guest_gs_base ) ; vmcs_writel ( GUEST_LDTR_BASE , vmcs12 -> guest_ldtr_base ) ; vmcs_writel ( GUEST_TR_BASE , vmcs12 -> guest_tr_base ) ; vmcs_writel ( GUEST_GDTR_BASE , vmcs12 -> guest_gdtr_base ) ; vmcs_writel ( GUEST_IDTR_BASE , vmcs12 -> guest_idtr_base ) ; if ( from_vmentry && ( vmcs12 -> vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS ) ) { kvm_set_dr ( vcpu , 7 , vmcs12 -> guest_dr7 ) ; vmcs_write64 ( GUEST_IA32_DEBUGCTL , vmcs12 -> guest_ia32_debugctl ) ; } else { kvm_set_dr ( vcpu , 7 , vcpu -> arch . dr7 ) ; vmcs_write64 ( GUEST_IA32_DEBUGCTL , vmx -> nested . vmcs01_debugctl ) ; } if ( from_vmentry ) { vmcs_write32 ( VM_ENTRY_INTR_INFO_FIELD , vmcs12 -> vm_entry_intr_info_field ) ; vmcs_write32 ( VM_ENTRY_EXCEPTION_ERROR_CODE , vmcs12 -> vm_entry_exception_error_code ) ; vmcs_write32 ( VM_ENTRY_INSTRUCTION_LEN , vmcs12 -> vm_entry_instruction_len ) ; vmcs_write32 ( GUEST_INTERRUPTIBILITY_INFO , vmcs12 -> guest_interruptibility_info ) ; vmx -> loaded_vmcs -> nmi_known_unmasked = ! ( vmcs12 -> guest_interruptibility_info & GUEST_INTR_STATE_NMI ) ; } else { vmcs_write32 ( VM_ENTRY_INTR_INFO_FIELD , 0 ) ; } vmcs_write32 ( GUEST_SYSENTER_CS , vmcs12 -> guest_sysenter_cs ) ; vmx_set_rflags ( vcpu , vmcs12 -> guest_rflags ) ; vmcs_writel ( GUEST_PENDING_DBG_EXCEPTIONS , vmcs12 -> guest_pending_dbg_exceptions ) ; vmcs_writel ( GUEST_SYSENTER_ESP , vmcs12 -> guest_sysenter_esp ) ; vmcs_writel ( GUEST_SYSENTER_EIP , vmcs12 -> guest_sysenter_eip ) ; if ( nested_cpu_has_xsaves ( vmcs12 ) ) vmcs_write64 ( XSS_EXIT_BITMAP , vmcs12 -> xss_exit_bitmap ) ; vmcs_write64 ( VMCS_LINK_POINTER , - 1ull ) ; exec_control = vmcs12 -> pin_based_vm_exec_control ; exec_control &= ~ PIN_BASED_VMX_PREEMPTION_TIMER ; exec_control |= vmcs_config . pin_based_exec_ctrl ; if ( vmx -> hv_deadline_tsc == - 1 ) exec_control &= ~ PIN_BASED_VMX_PREEMPTION_TIMER ; if ( nested_cpu_has_posted_intr ( vmcs12 ) ) { vmx -> nested . posted_intr_nv = vmcs12 -> posted_intr_nv ; vmx -> nested . pi_pending = false ; vmcs_write16 ( POSTED_INTR_NV , POSTED_INTR_NESTED_VECTOR ) ; } else { exec_control &= ~ PIN_BASED_POSTED_INTR ; } vmcs_write32 ( PIN_BASED_VM_EXEC_CONTROL , exec_control ) ; vmx -> nested . preemption_timer_expired = false ; if ( nested_cpu_has_preemption_timer ( vmcs12 ) ) vmx_start_preemption_timer ( vcpu ) ; vmcs_write32 ( PAGE_FAULT_ERROR_CODE_MASK , enable_ept ? vmcs12 -> page_fault_error_code_mask : 0 ) ; vmcs_write32 ( PAGE_FAULT_ERROR_CODE_MATCH , enable_ept ? vmcs12 -> page_fault_error_code_match : 0 ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { exec_control = vmx -> secondary_exec_control ; exec_control &= ~ ( SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES | SECONDARY_EXEC_ENABLE_INVPCID | SECONDARY_EXEC_RDTSCP | SECONDARY_EXEC_XSAVES | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY | SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_ENABLE_VMFUNC ) ; if ( nested_cpu_has ( vmcs12 , CPU_BASED_ACTIVATE_SECONDARY_CONTROLS ) ) { vmcs12_exec_ctrl = vmcs12 -> secondary_vm_exec_control & ~ SECONDARY_EXEC_ENABLE_PML ; exec_control |= vmcs12_exec_ctrl ; } if ( exec_control & SECONDARY_EXEC_ENABLE_VMFUNC ) vmcs_write64 ( VM_FUNCTION_CONTROL , 0 ) ; if ( exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) { vmcs_write64 ( EOI_EXIT_BITMAP0 , vmcs12 -> eoi_exit_bitmap0 ) ; vmcs_write64 ( EOI_EXIT_BITMAP1 , vmcs12 -> eoi_exit_bitmap1 ) ; vmcs_write64 ( EOI_EXIT_BITMAP2 , vmcs12 -> eoi_exit_bitmap2 ) ; vmcs_write64 ( EOI_EXIT_BITMAP3 , vmcs12 -> eoi_exit_bitmap3 ) ; vmcs_write16 ( GUEST_INTR_STATUS , vmcs12 -> guest_intr_status ) ; } if ( exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) vmcs_write64 ( APIC_ACCESS_ADDR , - 1ull ) ; vmcs_write32 ( SECONDARY_VM_EXEC_CONTROL , exec_control ) ; } vmx_set_constant_host_state ( vmx ) ; vmcs_write32 ( VM_EXIT_MSR_STORE_COUNT , 0 ) ; vmcs_write32 ( VM_EXIT_MSR_LOAD_COUNT , vmx -> msr_autoload . nr ) ; vmcs_write64 ( VM_EXIT_MSR_LOAD_ADDR , __pa ( vmx -> msr_autoload . host ) ) ; vmcs_write32 ( VM_ENTRY_MSR_LOAD_COUNT , vmx -> msr_autoload . nr ) ; vmcs_write64 ( VM_ENTRY_MSR_LOAD_ADDR , __pa ( vmx -> msr_autoload . guest ) ) ; vmx -> host_rsp = 0 ; exec_control = vmx_exec_control ( vmx ) ; exec_control &= ~ CPU_BASED_VIRTUAL_INTR_PENDING ; exec_control &= ~ CPU_BASED_VIRTUAL_NMI_PENDING ; exec_control &= ~ CPU_BASED_TPR_SHADOW ; exec_control |= vmcs12 -> cpu_based_vm_exec_control ; if ( exec_control & CPU_BASED_TPR_SHADOW ) { vmcs_write64 ( VIRTUAL_APIC_PAGE_ADDR , - 1ull ) ;  vmcs_write32 ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ;  } exec_control &= ~ CPU_BASED_USE_IO_BITMAPS ; exec_control |= CPU_BASED_UNCOND_IO_EXITING ; vmcs_write32 ( CPU_BASED_VM_EXEC_CONTROL , exec_control ) ; update_exception_bitmap ( vcpu ) ; vcpu -> arch . cr0_guest_owned_bits &= ~ vmcs12 -> cr0_guest_host_mask ; vmcs_writel ( CR0_GUEST_HOST_MASK , ~ vcpu -> arch . cr0_guest_owned_bits ) ; vmcs_write32 ( VM_EXIT_CONTROLS , vmcs_config . vmexit_ctrl ) ; vm_entry_controls_init ( vmx , ( vmcs12 -> vm_entry_controls & ~ VM_ENTRY_LOAD_IA32_EFER & ~ VM_ENTRY_IA32E_MODE ) | ( vmcs_config . vmentry_ctrl & ~ VM_ENTRY_IA32E_MODE ) ) ; if ( from_vmentry && ( vmcs12 -> vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT ) ) { vmcs_write64 ( GUEST_IA32_PAT , vmcs12 -> guest_ia32_pat ) ; vcpu -> arch . pat = vmcs12 -> guest_ia32_pat ; } else if ( vmcs_config . vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT ) { vmcs_write64 ( GUEST_IA32_PAT , vmx -> vcpu . arch . pat ) ; } set_cr4_guest_host_mask ( vmx ) ; if ( from_vmentry && vmcs12 -> vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS ) vmcs_write64 ( GUEST_BNDCFGS , vmcs12 -> guest_bndcfgs ) ; if ( vmcs12 -> cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING ) vmcs_write64 ( TSC_OFFSET , vcpu -> arch . tsc_offset + vmcs12 -> tsc_offset ) ; else vmcs_write64 ( TSC_OFFSET , vcpu -> arch . tsc_offset ) ; if ( kvm_has_tsc_control ) decache_tsc_multiplier ( vmx ) ; if ( enable_vpid ) { if ( nested_cpu_has_vpid ( vmcs12 ) && vmx -> nested . vpid02 ) { vmcs_write16 ( VIRTUAL_PROCESSOR_ID , vmx -> nested . vpid02 ) ; if ( vmcs12 -> virtual_processor_id != vmx -> nested . last_vpid ) { vmx -> nested . last_vpid = vmcs12 -> virtual_processor_id ; __vmx_flush_tlb ( vcpu , to_vmx ( vcpu ) -> nested . vpid02 ) ; } } else { vmcs_write16 ( VIRTUAL_PROCESSOR_ID , vmx -> vpid ) ; vmx_flush_tlb ( vcpu ) ; } } if ( enable_pml ) { ASSERT ( vmx -> pml_pg ) ; vmcs_write64 ( PML_ADDRESS , page_to_phys ( vmx -> pml_pg ) ) ; vmcs_write16 ( GUEST_PML_INDEX , PML_ENTITY_NUM - 1 ) ; } if ( nested_cpu_has_ept ( vmcs12 ) ) { if ( nested_ept_init_mmu_context ( vcpu ) ) { * entry_failure_code = ENTRY_FAIL_DEFAULT ; return 1 ; } } else if ( nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ) { vmx_flush_tlb_ept_only ( vcpu ) ; } vmx_set_cr0 ( vcpu , vmcs12 -> guest_cr0 ) ; vmcs_writel ( CR0_READ_SHADOW , nested_read_cr0 ( vmcs12 ) ) ; vmx_set_cr4 ( vcpu , vmcs12 -> guest_cr4 ) ; vmcs_writel ( CR4_READ_SHADOW , nested_read_cr4 ( vmcs12 ) ) ; if ( from_vmentry && ( vmcs12 -> vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER ) ) vcpu -> arch . efer = vmcs12 -> guest_ia32_efer ; else if ( vmcs12 -> vm_entry_controls & VM_ENTRY_IA32E_MODE ) vcpu -> arch . efer |= ( EFER_LMA | EFER_LME ) ; else vcpu -> arch . efer &= ~ ( EFER_LMA | EFER_LME ) ; vmx_set_efer ( vcpu , vcpu -> arch . efer ) ; if ( nested_vmx_load_cr3 ( vcpu , vmcs12 -> guest_cr3 , nested_cpu_has_ept ( vmcs12 ) , entry_failure_code ) ) return 1 ; if ( ! enable_ept ) vcpu -> arch . walk_mmu -> inject_page_fault = vmx_inject_page_fault_nested ; if ( enable_ept ) { vmcs_write64 ( GUEST_PDPTR0 , vmcs12 -> guest_pdptr0 ) ; vmcs_write64 ( GUEST_PDPTR1 , vmcs12 -> guest_pdptr1 ) ; vmcs_write64 ( GUEST_PDPTR2 , vmcs12 -> guest_pdptr2 ) ; vmcs_write64 ( GUEST_PDPTR3 , vmcs12 -> guest_pdptr3 ) ; } kvm_register_write ( vcpu , VCPU_REGS_RSP , vmcs12 -> guest_rsp ) ; kvm_register_write ( vcpu , VCPU_REGS_RIP , vmcs12 -> guest_rip ) ; return 0 ; }","vmcs_write32 ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ;}else {# ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ;# endif }",2418
363,"buggy line: if ( table_base + v != ipt_next_entry ( e ) &&  ! ( e -> ip . flags & IPT_F_GOTO ) )  jumpstack [ stackidx ++ ] = e ;e = get_entry ( table_base , v ) ;continue ;cwe id:CWE-476context: unsigned int ipt_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; const struct iphdr * ip ; unsigned int verdict = NF_DROP ; const char * indev , * outdev ; const void * table_base ; struct ipt_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; stackidx = 0 ; ip = ip_hdr ( skb ) ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; acpar . fragoff = ntohs ( ip -> frag_off ) & IP_OFFSET ; acpar . thoff = ip_hdrlen ( skb ) ; acpar . hotdrop = false ; acpar . state = state ; WARN_ON ( ! ( table -> valid_hooks & ( 1 << hook ) ) ) ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct ipt_entry * * ) private -> jumpstack [ cpu ] ; if ( static_key_false ( & xt_tee_enabled ) ) jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ) ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; do { const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; struct xt_counters * counter ; WARN_ON ( ! e ) ; if ( ! ip_packet_match ( ip , indev , outdev , & e -> ip , acpar . fragoff ) ) { no_match : e = ipt_next_entry ( e ) ; continue ; } xt_ematch_foreach ( ematch , e ) { acpar . match = ematch -> u . kernel . match ; acpar . matchinfo = ematch -> data ; if ( ! acpar . match -> match ( skb , & acpar ) ) goto no_match ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , skb -> len , 1 ) ; t = ipt_get_target ( e ) ; WARN_ON ( ! t -> u . kernel . target ) ; # if IS_ENABLED ( CONFIG_NETFILTER_XT_TARGET_TRACE ) if ( unlikely ( skb -> nf_trace ) ) trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ) ; # endif if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) { e = get_entry ( table_base , private -> underflow [ hook ] ) ; } else { e = jumpstack [ -- stackidx ] ; e = ipt_next_entry ( e ) ; } continue ; } if ( table_base + v != ipt_next_entry ( e ) &&  ! ( e -> ip . flags & IPT_F_GOTO ) )  jumpstack [ stackidx ++ ] = e ;  e = get_entry ( table_base , v ) ;  continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) { ip = ip_hdr ( skb ) ; e = ipt_next_entry ( e ) ; } else { break ; } } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }","if ( table_base + v != ipt_next_entry ( e ) && ! ( e -> ip . flags & IPT_F_GOTO ) ) {if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;}jumpstack [ stackidx ++ ] = e ;}e = get_entry ( table_base , v ) ;continue ;",2419
364,"buggy line: int nNew = pSorter -> nMemory * 2 ;while ( nNew < nMin ) nNew = nNew * 2 ;cwe id:CWE-190context: SQLITE_PRIVATE int sqlite3VdbeSorterWrite ( const VdbeCursor * pCsr , Mem * pVal ) { VdbeSorter * pSorter ; int rc = SQLITE_OK ; SorterRecord * pNew ; int bFlush ; int nReq ; int nPMA ; int t ; assert ( pCsr -> eCurType == CURTYPE_SORTER ) ; pSorter = pCsr -> uc . pSorter ; getVarint32 ( ( const u8 * ) & pVal -> z [ 1 ] , t ) ; if ( t > 0 && t < 10 && t != 7 ) { pSorter -> typeMask &= SORTER_TYPE_INTEGER ; } else if ( t > 10 && ( t & 0x01 ) ) { pSorter -> typeMask &= SORTER_TYPE_TEXT ; } else { pSorter -> typeMask = 0 ; } assert ( pSorter ) ; nReq = pVal -> n + sizeof ( SorterRecord ) ; nPMA = pVal -> n + sqlite3VarintLen ( pVal -> n ) ; if ( pSorter -> mxPmaSize ) { if ( pSorter -> list . aMemory ) { bFlush = pSorter -> iMemory && ( pSorter -> iMemory + nReq ) > pSorter -> mxPmaSize ; } else { bFlush = ( ( pSorter -> list . szPMA > pSorter -> mxPmaSize ) || ( pSorter -> list . szPMA > pSorter -> mnPmaSize && sqlite3HeapNearlyFull ( ) ) ) ; } if ( bFlush ) { rc = vdbeSorterFlushPMA ( pSorter ) ; pSorter -> list . szPMA = 0 ; pSorter -> iMemory = 0 ; assert ( rc != SQLITE_OK || pSorter -> list . pList == 0 ) ; } } pSorter -> list . szPMA += nPMA ; if ( nPMA > pSorter -> mxKeysize ) { pSorter -> mxKeysize = nPMA ; } if ( pSorter -> list . aMemory ) { int nMin = pSorter -> iMemory + nReq ; if ( nMin > pSorter -> nMemory ) { u8 * aNew ; int iListOff = ( u8 * ) pSorter -> list . pList - pSorter -> list . aMemory ;  int nNew = pSorter -> nMemory * 2 ;  while ( nNew < nMin ) nNew = nNew * 2 ; if ( nNew > pSorter -> mxPmaSize ) nNew = pSorter -> mxPmaSize ; if ( nNew < nMin ) nNew = nMin ; aNew = sqlite3Realloc ( pSorter -> list . aMemory , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; pSorter -> list . pList = ( SorterRecord * ) & aNew [ iListOff ] ; pSorter -> list . aMemory = aNew ; pSorter -> nMemory = nNew ; } pNew = ( SorterRecord * ) & pSorter -> list . aMemory [ pSorter -> iMemory ] ; pSorter -> iMemory += ROUND8 ( nReq ) ; if ( pSorter -> list . pList ) { pNew -> u . iNext = ( int ) ( ( u8 * ) ( pSorter -> list . pList ) - pSorter -> list . aMemory ) ; } } else { pNew = ( SorterRecord * ) sqlite3Malloc ( nReq ) ; if ( pNew == 0 ) { return SQLITE_NOMEM_BKPT ; } pNew -> u . pNext = pSorter -> list . pList ; } memcpy ( SRVAL ( pNew ) , pVal -> z , pVal -> n ) ; pNew -> nVal = pVal -> n ; pSorter -> list . pList = pNew ; return rc ; }",sqlite3_int64 nNew = 2 * ( sqlite3_int64 ) pSorter -> nMemory ;while ( nNew < nMin ) nNew = nNew * 2 ;,2420
365,"buggy line: return ;}return ;}cwe id:CWE-125context: void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ;  return ;  } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ;  return ;  } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , tcpport_string ( ndo , sport ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } else { if ( ip -> ip_p == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ipaddr_string ( ndo , & ip -> ip_src ) , tcpport_string ( ndo , sport ) , ipaddr_string ( ndo , & ip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } ND_TCHECK ( * pgm ) ; ND_PRINT ( ( ndo , ""PGM,<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_PRINT ( ( ndo , ""<S2SV_blank>0x%02x%02x%02x%02x%02x%02x<S2SV_blank>"" , pgm -> pgm_gsid [ 0 ] , pgm -> pgm_gsid [ 1 ] , pgm -> pgm_gsid [ 2 ] , pgm -> pgm_gsid [ 3 ] , pgm -> pgm_gsid [ 4 ] , pgm -> pgm_gsid [ 5 ] ) ) ; switch ( pgm -> pgm_type ) { case PGM_SPM : { const struct pgm_spm * spm ; spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; ND_TCHECK ( * spm ) ; bp = ( const u_char * ) ( spm + 1 ) ; switch ( EXTRACT_16BITS ( & spm -> pgms_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""SPM<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>lead<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s"" , EXTRACT_32BITS ( & spm -> pgms_seq ) , EXTRACT_32BITS ( & spm -> pgms_trailseq ) , EXTRACT_32BITS ( & spm -> pgms_leadseq ) , nla_buf ) ) ; break ; } case PGM_POLL : { const struct pgm_poll * poll_msg ; poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; ND_TCHECK ( * poll_msg ) ; ND_PRINT ( ( ndo , ""POLL<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u"" , EXTRACT_32BITS ( & poll_msg -> pgmp_seq ) , EXTRACT_16BITS ( & poll_msg -> pgmp_round ) ) ) ; bp = ( const u_char * ) ( poll_msg + 1 ) ; break ; } case PGM_POLR : { const struct pgm_polr * polr ; uint32_t ivl , rnd , mask ; polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; ND_TCHECK ( * polr ) ; bp = ( const u_char * ) ( polr + 1 ) ; switch ( EXTRACT_16BITS ( & polr -> pgmp_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ivl = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; rnd = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; mask = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""POLR<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>rnd<S2SV_blank>0x%08x<S2SV_blank>"" ""mask<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & polr -> pgmp_seq ) , EXTRACT_16BITS ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; break ; } case PGM_ODATA : { const struct pgm_data * odata ; odata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * odata ) ; ND_PRINT ( ( ndo , ""ODATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & odata -> pgmd_trailseq ) , EXTRACT_32BITS ( & odata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( odata + 1 ) ; break ; } case PGM_RDATA : { const struct pgm_data * rdata ; rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * rdata ) ; ND_PRINT ( ( ndo , ""RDATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & rdata -> pgmd_trailseq ) , EXTRACT_32BITS ( & rdata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( rdata + 1 ) ; break ; } case PGM_NAK : case PGM_NULLNAK : case PGM_NCF : { const struct pgm_nak * nak ; char source_buf [ INET6_ADDRSTRLEN ] , group_buf [ INET6_ADDRSTRLEN ] ; nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; ND_TCHECK ( * nak ) ; bp = ( const u_char * ) ( nak + 1 ) ; switch ( EXTRACT_16BITS ( & nak -> pgmn_source_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } bp += ( 2 * sizeof ( uint16_t ) ) ;  switch ( EXTRACT_16BITS ( bp ) ) {  case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } switch ( pgm -> pgm_type ) { case PGM_NAK : ND_PRINT ( ( ndo , ""NAK<S2SV_blank>"" ) ) ; break ; case PGM_NULLNAK : ND_PRINT ( ( ndo , ""NNAK<S2SV_blank>"" ) ) ; break ; case PGM_NCF : ND_PRINT ( ( ndo , ""NCF<S2SV_blank>"" ) ) ; break ; default : break ; } ND_PRINT ( ( ndo , ""(%s<S2SV_blank>-><S2SV_blank>%s),<S2SV_blank>seq<S2SV_blank>%u"" , source_buf , group_buf , EXTRACT_32BITS ( & nak -> pgmn_seq ) ) ) ; break ; } case PGM_ACK : { const struct pgm_ack * ack ; ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; ND_TCHECK ( * ack ) ; ND_PRINT ( ( ndo , ""ACK<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & ack -> pgma_rx_max_seq ) ) ) ; bp = ( const u_char * ) ( ack + 1 ) ; break ; } case PGM_SPMR : ND_PRINT ( ( ndo , ""SPMR"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""UNKNOWN<S2SV_blank>type<S2SV_blank>0x%02x"" , pgm -> pgm_type ) ) ; break ; } if ( pgm -> pgm_options & PGM_OPT_BIT_PRESENT ) { if ( ! ND_TTEST2 ( * bp , PGM_MIN_OPT_LEN ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; if ( ( opt_type & PGM_OPT_MASK ) != PGM_OPT_LENGTH ) { ND_PRINT ( ( ndo , ""[First<S2SV_blank>option<S2SV_blank>bad,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>PGM_OPT_LENGTH,<S2SV_blank>is<S2SV_blank>%u]"" , opt_type & PGM_OPT_MASK ) ) ; return ; } opt_len = * bp ++ ; if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } opts_len = EXTRACT_16BITS ( bp ) ; if ( opts_len < 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>4]"" , opts_len ) ) ; return ; } bp += sizeof ( uint16_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>%d"" , opts_len ) ) ; opts_len -= 4 ; while ( opts_len ) { if ( opts_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; opt_len = * bp ++ ; if ( opt_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_MIN_OPT_LEN ) ) ; break ; } if ( opts_len < opt_len ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , opt_len - 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } switch ( opt_type & PGM_OPT_MASK ) { case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FRAGMENT_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 ; opts_len -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_JOIN_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq ) ) ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_IVL_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u"" , offset , seq ) ) ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) if ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_RNG_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset , seq ) ) ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , PGM_OPT_REDIRECT_FIXED_LEN , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) ) ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NBR_UNREACH"" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""<S2SV_blank>PATH_NLA<S2SV_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>SYN"" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>RST"" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>CRQST"" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>PGM_OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>FEEDBACK<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>OPT_%02X<S2SV_blank>[%d]<S2SV_blank>"" , opt_type , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; } if ( opt_type & PGM_OPT_END ) break ; } } ND_PRINT ( ( ndo , ""<S2SV_blank>[%u]"" , length ) ) ; if ( ndo -> ndo_packettype == PT_PGM_ZMTP1 && ( pgm -> pgm_type == PGM_ODATA || pgm -> pgm_type == PGM_RDATA ) ) zmtp1_print_datagram ( ndo , bp , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pgm]"" ) ) ; if ( ch != '\\0' ) ND_PRINT ( ( ndo , "">"" ) ) ; }",}}return ;ND_TCHECK_16BITS ( bp ) ;,2421
366,"buggy line: switch ( EXTRACT_16BITS ( bp ) ) {case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ;cwe id:CWE-125context: void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ;  return ;  } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ;  return ;  } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , tcpport_string ( ndo , sport ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } else { if ( ip -> ip_p == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ipaddr_string ( ndo , & ip -> ip_src ) , tcpport_string ( ndo , sport ) , ipaddr_string ( ndo , & ip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } ND_TCHECK ( * pgm ) ; ND_PRINT ( ( ndo , ""PGM,<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_PRINT ( ( ndo , ""<S2SV_blank>0x%02x%02x%02x%02x%02x%02x<S2SV_blank>"" , pgm -> pgm_gsid [ 0 ] , pgm -> pgm_gsid [ 1 ] , pgm -> pgm_gsid [ 2 ] , pgm -> pgm_gsid [ 3 ] , pgm -> pgm_gsid [ 4 ] , pgm -> pgm_gsid [ 5 ] ) ) ; switch ( pgm -> pgm_type ) { case PGM_SPM : { const struct pgm_spm * spm ; spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; ND_TCHECK ( * spm ) ; bp = ( const u_char * ) ( spm + 1 ) ; switch ( EXTRACT_16BITS ( & spm -> pgms_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""SPM<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>lead<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s"" , EXTRACT_32BITS ( & spm -> pgms_seq ) , EXTRACT_32BITS ( & spm -> pgms_trailseq ) , EXTRACT_32BITS ( & spm -> pgms_leadseq ) , nla_buf ) ) ; break ; } case PGM_POLL : { const struct pgm_poll * poll_msg ; poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; ND_TCHECK ( * poll_msg ) ; ND_PRINT ( ( ndo , ""POLL<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u"" , EXTRACT_32BITS ( & poll_msg -> pgmp_seq ) , EXTRACT_16BITS ( & poll_msg -> pgmp_round ) ) ) ; bp = ( const u_char * ) ( poll_msg + 1 ) ; break ; } case PGM_POLR : { const struct pgm_polr * polr ; uint32_t ivl , rnd , mask ; polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; ND_TCHECK ( * polr ) ; bp = ( const u_char * ) ( polr + 1 ) ; switch ( EXTRACT_16BITS ( & polr -> pgmp_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ivl = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; rnd = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; mask = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""POLR<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>rnd<S2SV_blank>0x%08x<S2SV_blank>"" ""mask<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & polr -> pgmp_seq ) , EXTRACT_16BITS ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; break ; } case PGM_ODATA : { const struct pgm_data * odata ; odata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * odata ) ; ND_PRINT ( ( ndo , ""ODATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & odata -> pgmd_trailseq ) , EXTRACT_32BITS ( & odata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( odata + 1 ) ; break ; } case PGM_RDATA : { const struct pgm_data * rdata ; rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * rdata ) ; ND_PRINT ( ( ndo , ""RDATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & rdata -> pgmd_trailseq ) , EXTRACT_32BITS ( & rdata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( rdata + 1 ) ; break ; } case PGM_NAK : case PGM_NULLNAK : case PGM_NCF : { const struct pgm_nak * nak ; char source_buf [ INET6_ADDRSTRLEN ] , group_buf [ INET6_ADDRSTRLEN ] ; nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; ND_TCHECK ( * nak ) ; bp = ( const u_char * ) ( nak + 1 ) ; switch ( EXTRACT_16BITS ( & nak -> pgmn_source_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } bp += ( 2 * sizeof ( uint16_t ) ) ;  switch ( EXTRACT_16BITS ( bp ) ) {  case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } switch ( pgm -> pgm_type ) { case PGM_NAK : ND_PRINT ( ( ndo , ""NAK<S2SV_blank>"" ) ) ; break ; case PGM_NULLNAK : ND_PRINT ( ( ndo , ""NNAK<S2SV_blank>"" ) ) ; break ; case PGM_NCF : ND_PRINT ( ( ndo , ""NCF<S2SV_blank>"" ) ) ; break ; default : break ; } ND_PRINT ( ( ndo , ""(%s<S2SV_blank>-><S2SV_blank>%s),<S2SV_blank>seq<S2SV_blank>%u"" , source_buf , group_buf , EXTRACT_32BITS ( & nak -> pgmn_seq ) ) ) ; break ; } case PGM_ACK : { const struct pgm_ack * ack ; ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; ND_TCHECK ( * ack ) ; ND_PRINT ( ( ndo , ""ACK<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & ack -> pgma_rx_max_seq ) ) ) ; bp = ( const u_char * ) ( ack + 1 ) ; break ; } case PGM_SPMR : ND_PRINT ( ( ndo , ""SPMR"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""UNKNOWN<S2SV_blank>type<S2SV_blank>0x%02x"" , pgm -> pgm_type ) ) ; break ; } if ( pgm -> pgm_options & PGM_OPT_BIT_PRESENT ) { if ( ! ND_TTEST2 ( * bp , PGM_MIN_OPT_LEN ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; if ( ( opt_type & PGM_OPT_MASK ) != PGM_OPT_LENGTH ) { ND_PRINT ( ( ndo , ""[First<S2SV_blank>option<S2SV_blank>bad,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>PGM_OPT_LENGTH,<S2SV_blank>is<S2SV_blank>%u]"" , opt_type & PGM_OPT_MASK ) ) ; return ; } opt_len = * bp ++ ; if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } opts_len = EXTRACT_16BITS ( bp ) ; if ( opts_len < 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>4]"" , opts_len ) ) ; return ; } bp += sizeof ( uint16_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>%d"" , opts_len ) ) ; opts_len -= 4 ; while ( opts_len ) { if ( opts_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; opt_len = * bp ++ ; if ( opt_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_MIN_OPT_LEN ) ) ; break ; } if ( opts_len < opt_len ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , opt_len - 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } switch ( opt_type & PGM_OPT_MASK ) { case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FRAGMENT_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 ; opts_len -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_JOIN_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq ) ) ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_IVL_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u"" , offset , seq ) ) ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) if ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_RNG_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset , seq ) ) ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , PGM_OPT_REDIRECT_FIXED_LEN , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) ) ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NBR_UNREACH"" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""<S2SV_blank>PATH_NLA<S2SV_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>SYN"" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>RST"" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>CRQST"" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>PGM_OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>FEEDBACK<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>OPT_%02X<S2SV_blank>[%d]<S2SV_blank>"" , opt_type , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; } if ( opt_type & PGM_OPT_END ) break ; } } ND_PRINT ( ( ndo , ""<S2SV_blank>[%u]"" , length ) ) ; if ( ndo -> ndo_packettype == PT_PGM_ZMTP1 && ( pgm -> pgm_type == PGM_ODATA || pgm -> pgm_type == PGM_RDATA ) ) zmtp1_print_datagram ( ndo , bp , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pgm]"" ) ) ; if ( ch != '\\0' ) ND_PRINT ( ( ndo , "">"" ) ) ; }","switch ( EXTRACT_16BITS ( bp ) ) {case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ;",2421
367,"buggy line: struct net * net = sock_net ( asoc -> base . sk ) ;int error = 0 ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_association_put ( asoc ) ;cwe id:CWE-362context: static void sctp_generate_timeout_event ( struct sctp_association * asoc , sctp_event_timeout_t timeout_type ) {  struct net * net = sock_net ( asoc -> base . sk ) ;  int error = 0 ;  bh_lock_sock ( asoc -> base . sk ) ;   if ( sock_owned_by_user ( asoc -> base . sk ) ) {  pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\n"" , __func__ , timeout_type ) ; if ( ! mod_timer ( & asoc -> timers [ timeout_type ] , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( timeout_type ) , asoc -> state , asoc -> ep , asoc , ( void * ) timeout_type , GFP_ATOMIC ) ; if ( error )  asoc -> base . sk -> sk_err = - error ;  out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;  sctp_association_put ( asoc ) ; }","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;int error = 0 ;bh_lock_sock ( sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_association_put ( asoc ) ;",2422
368,"buggy line: static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem )  {uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ;return TEE_SUCCESS ;}cwe id:CWE-119context: static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem )  {  uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ; mem -> mobj = mobj_reg_shm_get_by_cookie ( shm_ref ) ; if ( ! mem -> mobj ) return TEE_ERROR_BAD_PARAMETERS ; mem -> offs = READ_ONCE ( rmem -> offs ) ; mem -> size = READ_ONCE ( rmem -> size ) ;  return TEE_SUCCESS ;  }","static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem ) {size_t req_size = 0 ;uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ;if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;return TEE_SUCCESS ;}",2423
369,"buggy line: int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ;if ( ret || ! write ) return ret ;cwe id:CWE-190context: int perf_cpu_time_max_percent_handler ( struct ctl_table * table , int write , void __user * buffer , size_t * lenp , loff_t * ppos ) {  int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ;  if ( ret || ! write ) return ret ; if ( sysctl_perf_cpu_time_max_percent == 100 || sysctl_perf_cpu_time_max_percent == 0 ) { printk ( KERN_WARNING ""perf:<S2SV_blank>Dynamic<S2SV_blank>interrupt<S2SV_blank>throttling<S2SV_blank>disabled,<S2SV_blank>can<S2SV_blank>hang<S2SV_blank>your<S2SV_blank>system!\\n"" ) ; WRITE_ONCE ( perf_sample_allowed_ns , 0 ) ; } else { update_perf_cpu_limits ( ) ; } return 0 ; }","int ret = proc_dointvec_minmax ( table , write , buffer , lenp , ppos ) ;if ( ret || ! write ) return ret ;",2424
370,"buggy line: return ret <= 0 ? ret : - EIO ;}cwe id:CWE-388context: static int cp2112_gpio_direction_input ( struct gpio_chip * chip , unsigned offset ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; int ret ; mutex_lock ( & dev -> lock ) ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_CONFIG_LENGTH ) { hid_err ( hdev , ""error<S2SV_blank>requesting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n"" , ret ) ; goto exit ; } buf [ 1 ] &= ~ ( 1 << offset ) ; buf [ 2 ] = gpio_push_pull ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) { hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n"" , ret ) ; goto exit ; } ret = 0 ; exit : mutex_unlock ( & dev -> lock ) ;  return ret <= 0 ? ret : - EIO ;  }",return ret < 0 ? ret : - EIO ;},2425
371,"buggy line: int rc = 0 ;if ( ! ss_initialized ) {cwe id:CWE-20context: static int security_context_to_sid_core ( const char * scontext , u32 scontext_len , u32 * sid , u32 def_sid , gfp_t gfp_flags , int force ) { char * scontext2 , * str = NULL ; struct context context ;  int rc = 0 ;  if ( ! ss_initialized ) { int i ; for ( i = 1 ; i < SECINITSID_NUM ; i ++ ) { if ( ! strcmp ( initial_sid_to_string [ i ] , scontext ) ) { * sid = i ; return 0 ; } } * sid = SECINITSID_KERNEL ; return 0 ; } * sid = SECSID_NULL ; scontext2 = kmalloc ( scontext_len + 1 , gfp_flags ) ; if ( ! scontext2 ) return - ENOMEM ; memcpy ( scontext2 , scontext , scontext_len ) ; scontext2 [ scontext_len ] = 0 ; if ( force ) { rc = - ENOMEM ; str = kstrdup ( scontext2 , gfp_flags ) ; if ( ! str ) goto out ; } read_lock ( & policy_rwlock ) ; rc = string_to_context_struct ( & policydb , & sidtab , scontext2 , scontext_len , & context , def_sid ) ; if ( rc == - EINVAL && force ) { context . str = str ; context . len = scontext_len ; str = NULL ; } else if ( rc ) goto out_unlock ; rc = sidtab_context_to_sid ( & sidtab , & context , sid ) ; context_destroy ( & context ) ; out_unlock : read_unlock ( & policy_rwlock ) ; out : kfree ( scontext2 ) ; kfree ( str ) ; return rc ; }",int rc = 0 ;if ( ! scontext_len ) return - EINVAL ;if ( ! ss_initialized ) {,2426
372,"buggy line: char * identifier ;char * args_fmt ;cwe id:CWE-416context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ;  char * identifier ;  char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;  while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif  break ;  case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS )  {   r1 . o = function -> return_obj ;  push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; }  yr_modules_unload_all ( context ) ;  yr_free ( stack ) ; return result ; }",YR_OBJECT * * obj_ptr ;YR_ARENA * obj_arena ;char * identifier ;char * args_fmt ;,2427
373,"buggy line: if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;while ( ! stop ) {cwe id:CWE-416context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ;  char * identifier ;  char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;  while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif  break ;  case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS )  {   r1 . o = function -> return_obj ;  push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; }  yr_modules_unload_all ( context ) ;  yr_free ( stack ) ; return result ; }","if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ;FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) ;while ( ! stop ) {",2427
374,"buggy line: # endif ip += sizeof ( uint64_t ) ;cwe id:CWE-416context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ;  char * identifier ;  char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;  while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif  break ;  case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS )  {   r1 . o = function -> return_obj ;  push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; }  yr_modules_unload_all ( context ) ;  yr_free ( stack ) ; return result ; }",# endif assert ( sp == 0 ) ;ip += sizeof ( uint64_t ) ;,2427
375,"buggy line: # endif  break ;case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ;cwe id:CWE-416context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ;  char * identifier ;  char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;  while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif  break ;  case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS )  {   r1 . o = function -> return_obj ;  push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; }  yr_modules_unload_all ( context ) ;  yr_free ( stack ) ; return result ; }",# endif break ;case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ;,2427
376,"buggy line: if ( result == ERROR_SUCCESS )  {r1 . o = function -> return_obj ;push ( r1 ) ;}else {stop = TRUE ;}cwe id:CWE-416context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ;  char * identifier ;  char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;  while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif  break ;  case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS )  {   r1 . o = function -> return_obj ;  push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; }  yr_modules_unload_all ( context ) ;  yr_free ( stack ) ; return result ; }","if ( result == ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & r1 . o ) ;if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ;stop = ( result != ERROR_SUCCESS ) ;push ( r1 ) ;",2427
377,"buggy line: yr_modules_unload_all ( context ) ;yr_free ( stack ) ;cwe id:CWE-416context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ;  char * identifier ;  char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;  while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif  break ;  case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS )  {   r1 . o = function -> return_obj ;  push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; }  yr_modules_unload_all ( context ) ;  yr_free ( stack ) ; return result ; }","obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ;while ( obj_ptr != NULL ) {yr_object_destroy ( * obj_ptr ) ;obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ;}yr_arena_destroy ( obj_arena ) ;yr_modules_unload_all ( context ) ;yr_free ( stack ) ;",2427
378,"buggy line: err = - EINVAL ;ds = salg -> digestsize ;ss = salg -> statesize ;alg = & salg -> base ;cwe id:CWE-787context: static int hmac_create ( struct crypto_template * tmpl , struct rtattr * * tb ) { struct shash_instance * inst ; struct crypto_alg * alg ; struct shash_alg * salg ; int err ; int ds ; int ss ; err = crypto_check_attr_type ( tb , CRYPTO_ALG_TYPE_SHASH ) ; if ( err ) return err ; salg = shash_attr_alg ( tb [ 1 ] , 0 , 0 ) ; if ( IS_ERR ( salg ) ) return PTR_ERR ( salg ) ;  err = - EINVAL ;   ds = salg -> digestsize ;   ss = salg -> statesize ;  alg = & salg -> base ; if ( ds > alg -> cra_blocksize || ss < alg -> cra_blocksize ) goto out_put_alg ; inst = shash_alloc_instance ( ""hmac"" , alg ) ; err = PTR_ERR ( inst ) ; if ( IS_ERR ( inst ) ) goto out_put_alg ; err = crypto_init_shash_spawn ( shash_instance_ctx ( inst ) , salg , shash_crypto_instance ( inst ) ) ; if ( err ) goto out_free_inst ; inst -> alg . base . cra_priority = alg -> cra_priority ; inst -> alg . base . cra_blocksize = alg -> cra_blocksize ; inst -> alg . base . cra_alignmask = alg -> cra_alignmask ; ss = ALIGN ( ss , alg -> cra_alignmask + 1 ) ; inst -> alg . digestsize = ds ; inst -> alg . statesize = ss ; inst -> alg . base . cra_ctxsize = sizeof ( struct hmac_ctx ) + ALIGN ( ss * 2 , crypto_tfm_ctx_alignment ( ) ) ; inst -> alg . base . cra_init = hmac_init_tfm ; inst -> alg . base . cra_exit = hmac_exit_tfm ; inst -> alg . init = hmac_init ; inst -> alg . update = hmac_update ; inst -> alg . final = hmac_final ; inst -> alg . finup = hmac_finup ; inst -> alg . export = hmac_export ; inst -> alg . import = hmac_import ; inst -> alg . setkey = hmac_setkey ; err = shash_register_instance ( tmpl , inst ) ; if ( err ) { out_free_inst : shash_free_instance ( shash_crypto_instance ( inst ) ) ; } out_put_alg : crypto_mod_put ( alg ) ; return err ; }",alg = & salg -> base ;err = - EINVAL ;if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ;ds = salg -> digestsize ;ss = salg -> statesize ;,2428
379,"buggy line: perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;cwe id:CWE-399context: static int misaligned_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; }  perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;  srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } switch ( width_shift ) { case 1 : * ( __u16 * ) & buffer = ( __u16 ) regs -> regs [ srcreg ] ; break ; case 2 : * ( __u32 * ) & buffer = ( __u32 ) regs -> regs [ srcreg ] ; break ; case 3 : buffer = regs -> regs [ srcreg ] ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_store,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } } else { __u64 val = regs -> regs [ srcreg ] ; switch ( width_shift ) { case 1 : misaligned_kernel_word_store ( address , val ) ; break ; case 2 : asm ( ""stlo.l<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; asm ( ""sthi.l<S2SV_blank>%1,<S2SV_blank>3,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; break ; case 3 : asm ( ""stlo.q<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; asm ( ""sthi.q<S2SV_blank>%1,<S2SV_blank>7,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_store,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;",2429
380,"buggy line: _pam_log ( LOG_DEBUG , ""sending<S2SV_blank>server<S2SV_blank>address<S2SV_blank>to<S2SV_blank>getaddrinfo<S2SV_blank>as:<S2SV_blank>%s<S2SV_blank>"" , server_name ) ;if ( ( rv = getaddrinfo ( server_name , ( port == NULL ) ? ""49"" : port , & hints , & servers ) ) == 0 ) {for ( server = servers ;server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS ;server = server -> ai_next ) {set_tac_srv_addr ( tac_srv_no , server ) ;set_tac_srv_key ( tac_srv_no , current_secret ) ;tac_srv_no ++ ;}_pam_log ( LOG_DEBUG , ""%s:<S2SV_blank>server<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>"" , __FUNCTION__ , tac_srv_no ) ;freeaddrinfo ( servers ) ;}else {_pam_log ( LOG_ERR , ""skip<S2SV_blank>invalid<S2SV_blank>server:<S2SV_blank>%s<S2SV_blank>(getaddrinfo:<S2SV_blank>%s)"" , server_name , gai_strerror ( rv ) ) ;}}else {_pam_log ( LOG_ERR , ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>servers<S2SV_blank>(%d)<S2SV_blank>exceeded,<S2SV_blank>skipping"" , TAC_PLUS_MAXSERVERS ) ;}}else if ( ! strncmp ( * argv , ""secret="" , 7 ) ) {current_secret = * argv + 7 ;if ( tac_srv_no == 0 ) {_pam_log ( LOG_ERR , ""secret<S2SV_blank>set<S2SV_blank>but<S2SV_blank>no<S2SV_blank>servers<S2SV_blank>configured<S2SV_blank>yet"" ) ;}else {set_tac_srv_key ( tac_srv_no - 1 , current_secret ) ;}}else if ( ! strncmp ( * argv , ""timeout="" , 8 ) ) {# ifdef HAVE_STRTOL tac_timeout = strtol ( * argv + 8 , NULL , 10 ) ;# else tac_timeout = atoi ( * argv + 8 ) ;# endif if ( tac_timeout == LONG_MAX ) {_pam_log ( LOG_ERR , ""timeout<S2SV_blank>parameter<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>parsed<S2SV_blank>as<S2SV_blank>integer:<S2SV_blank>%s"" , * argv ) ;tac_timeout = 0 ;}else {tac_readtimeout_enable = 1 ;}}else {_pam_log ( LOG_WARNING , ""unrecognized<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ;}}if ( ctrl & PAM_TAC_DEBUG ) {unsigned long n ;_pam_log ( LOG_DEBUG , ""%d<S2SV_blank>servers<S2SV_blank>defined"" , tac_srv_no ) ;for ( n = 0 ;n < tac_srv_no ;n ++ ) {_pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\\\'%s\\\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) ,  tac_srv [ n ] . key ) ;cwe id:CWE-532context: int _pam_parse ( int argc , const char * * argv ) { int ctrl = 0 ; const char * current_secret = NULL ; memset ( tac_srv , 0 , sizeof ( tacplus_server_t ) * TAC_PLUS_MAXSERVERS ) ; memset ( & tac_srv_addr , 0 , sizeof ( struct addrinfo ) * TAC_PLUS_MAXSERVERS ) ; memset ( & tac_sock_addr , 0 , sizeof ( struct sockaddr ) * TAC_PLUS_MAXSERVERS ) ; memset ( & tac_sock6_addr , 0 , sizeof ( struct sockaddr_in6 ) * TAC_PLUS_MAXSERVERS ) ; tac_srv_no = 0 ; tac_service [ 0 ] = 0 ; tac_protocol [ 0 ] = 0 ; tac_prompt [ 0 ] = 0 ; tac_login [ 0 ] = 0 ; for ( ctrl = 0 ; argc -- > 0 ; ++ argv ) { if ( ! strcmp ( * argv , ""debug"" ) ) { ctrl |= PAM_TAC_DEBUG ; } else if ( ! strcmp ( * argv , ""use_first_pass"" ) ) { ctrl |= PAM_TAC_USE_FIRST_PASS ; } else if ( ! strcmp ( * argv , ""try_first_pass"" ) ) { ctrl |= PAM_TAC_TRY_FIRST_PASS ; } else if ( ! strncmp ( * argv , ""service="" , 8 ) ) { xstrcpy ( tac_service , * argv + 8 , sizeof ( tac_service ) ) ; } else if ( ! strncmp ( * argv , ""protocol="" , 9 ) ) { xstrcpy ( tac_protocol , * argv + 9 , sizeof ( tac_protocol ) ) ; } else if ( ! strncmp ( * argv , ""prompt="" , 7 ) ) { xstrcpy ( tac_prompt , * argv + 7 , sizeof ( tac_prompt ) ) ; unsigned long chr ; for ( chr = 0 ; chr < strlen ( tac_prompt ) ; chr ++ ) { if ( tac_prompt [ chr ] == '_' ) { tac_prompt [ chr ] = '<S2SV_blank>' ; } } } else if ( ! strncmp ( * argv , ""login="" , 6 ) ) { xstrcpy ( tac_login , * argv + 6 , sizeof ( tac_login ) ) ; } else if ( ! strcmp ( * argv , ""acct_all"" ) ) { ctrl |= PAM_TAC_ACCT ; } else if ( ! strncmp ( * argv , ""server="" , 7 ) ) { if ( tac_srv_no < TAC_PLUS_MAXSERVERS ) { struct addrinfo hints , * servers , * server ; int rv ; char * close_bracket , * server_name , * port , server_buf [ 256 ] ; memset ( & hints , 0 , sizeof hints ) ; memset ( & server_buf , 0 , sizeof ( server_buf ) ) ; hints . ai_family = AF_UNSPEC ; hints . ai_socktype = SOCK_STREAM ; if ( strlen ( * argv + 7 ) >= sizeof ( server_buf ) ) { _pam_log ( LOG_ERR , ""server<S2SV_blank>address<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>sorry"" ) ; continue ; } strcpy ( server_buf , * argv + 7 ) ; if ( * server_buf == '[' && ( close_bracket = strchr ( server_buf , ']' ) ) != NULL ) { server_name = server_buf + 1 ; _pam_log ( LOG_ERR , ""reading<S2SV_blank>server<S2SV_blank>address<S2SV_blank>as:<S2SV_blank>%s<S2SV_blank>"" , server_name ) ; port = strchr ( close_bracket , ':' ) ; * close_bracket = '\\0' ; } else { server_name = server_buf ; port = strchr ( server_buf , ':' ) ; } if ( port != NULL ) { * port = '\\0' ; port ++ ; } _pam_log ( LOG_DEBUG , ""sending<S2SV_blank>server<S2SV_blank>address<S2SV_blank>to<S2SV_blank>getaddrinfo<S2SV_blank>as:<S2SV_blank>%s<S2SV_blank>"" , server_name ) ; if ( ( rv = getaddrinfo ( server_name , ( port == NULL ) ? ""49"" : port , & hints , & servers ) ) == 0 ) { for ( server = servers ; server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS ; server = server -> ai_next ) { set_tac_srv_addr ( tac_srv_no , server ) ; set_tac_srv_key ( tac_srv_no , current_secret ) ; tac_srv_no ++ ; } _pam_log ( LOG_DEBUG , ""%s:<S2SV_blank>server<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>"" , __FUNCTION__ , tac_srv_no ) ; freeaddrinfo ( servers ) ; } else { _pam_log ( LOG_ERR , ""skip<S2SV_blank>invalid<S2SV_blank>server:<S2SV_blank>%s<S2SV_blank>(getaddrinfo:<S2SV_blank>%s)"" , server_name , gai_strerror ( rv ) ) ; } } else { _pam_log ( LOG_ERR , ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>servers<S2SV_blank>(%d)<S2SV_blank>exceeded,<S2SV_blank>skipping"" , TAC_PLUS_MAXSERVERS ) ; } } else if ( ! strncmp ( * argv , ""secret="" , 7 ) ) { current_secret = * argv + 7 ; if ( tac_srv_no == 0 ) { _pam_log ( LOG_ERR , ""secret<S2SV_blank>set<S2SV_blank>but<S2SV_blank>no<S2SV_blank>servers<S2SV_blank>configured<S2SV_blank>yet"" ) ; } else { set_tac_srv_key ( tac_srv_no - 1 , current_secret ) ; } } else if ( ! strncmp ( * argv , ""timeout="" , 8 ) ) { # ifdef HAVE_STRTOL tac_timeout = strtol ( * argv + 8 , NULL , 10 ) ; # else tac_timeout = atoi ( * argv + 8 ) ; # endif if ( tac_timeout == LONG_MAX ) { _pam_log ( LOG_ERR , ""timeout<S2SV_blank>parameter<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>parsed<S2SV_blank>as<S2SV_blank>integer:<S2SV_blank>%s"" , * argv ) ; tac_timeout = 0 ; } else { tac_readtimeout_enable = 1 ; } } else { _pam_log ( LOG_WARNING , ""unrecognized<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ; } } if ( ctrl & PAM_TAC_DEBUG ) { unsigned long n ; _pam_log ( LOG_DEBUG , ""%d<S2SV_blank>servers<S2SV_blank>defined"" , tac_srv_no ) ; for ( n = 0 ; n < tac_srv_no ; n ++ ) {  _pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'%s\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) ,  tac_srv [ n ] . key ) ; } _pam_log ( LOG_DEBUG , ""tac_service=\'%s\'"" , tac_service ) ; _pam_log ( LOG_DEBUG , ""tac_protocol=\'%s\'"" , tac_protocol ) ; _pam_log ( LOG_DEBUG , ""tac_prompt=\'%s\'"" , tac_prompt ) ; _pam_log ( LOG_DEBUG , ""tac_login=\'%s\'"" , tac_login ) ; } return ctrl ; }","_pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\\\'********\\\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) , tac_srv [ n ] . key ) ;",2430
381,"buggy line: vpx_memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ;}cwe id:CWE-119context: void vp8_default_bmode_probs ( vp8_prob p [ VP8_BINTRAMODES - 1 ] ) {  vpx_memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ;  }","memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ;}",2431
382,"buggy line: client -> connectTimeout = DEFAULT_CONNECT_TIMEOUT ;client -> CurrentKeyboardLedState = 0 ;cwe id:CWE-835context: rfbClient * rfbGetClient ( int bitsPerSample , int samplesPerPixel , int bytesPerPixel ) { # ifdef WIN32 WSADATA unused ; # endif rfbClient * client = ( rfbClient * ) calloc ( sizeof ( rfbClient ) , 1 ) ; if ( ! client ) { rfbClientErr ( ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>client<S2SV_blank>structure!\\n"" ) ; return NULL ; } # ifdef WIN32 if ( ( errno = WSAStartup ( MAKEWORD ( 2 , 0 ) , & unused ) ) != 0 ) { rfbClientErr ( ""Could<S2SV_blank>not<S2SV_blank>init<S2SV_blank>Windows<S2SV_blank>Sockets:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; return NULL ; } # endif initAppData ( & client -> appData ) ; client -> endianTest = 1 ; client -> programName = """" ; client -> serverHost = strdup ( """" ) ; client -> serverPort = 5900 ; client -> destHost = NULL ; client -> destPort = 5900 ;  client -> connectTimeout = DEFAULT_CONNECT_TIMEOUT ;  client -> CurrentKeyboardLedState = 0 ; client -> HandleKeyboardLedState = ( HandleKeyboardLedStateProc ) DummyPoint ; client -> updateRect . x = - 1 ; client -> frameBuffer = NULL ; client -> outputWindow = 0 ; client -> format . bitsPerPixel = bytesPerPixel * 8 ; client -> format . depth = bitsPerSample * samplesPerPixel ; client -> appData . requestedDepth = client -> format . depth ; client -> format . bigEndian = * ( char * ) & client -> endianTest ? FALSE : TRUE ; client -> format . trueColour = 1 ; if ( client -> format . bitsPerPixel == 8 ) { client -> format . redMax = 7 ; client -> format . greenMax = 7 ; client -> format . blueMax = 3 ; client -> format . redShift = 0 ; client -> format . greenShift = 3 ; client -> format . blueShift = 6 ; } else { client -> format . redMax = ( 1 << bitsPerSample ) - 1 ; client -> format . greenMax = ( 1 << bitsPerSample ) - 1 ; client -> format . blueMax = ( 1 << bitsPerSample ) - 1 ; if ( ! client -> format . bigEndian ) { client -> format . redShift = 0 ; client -> format . greenShift = bitsPerSample ; client -> format . blueShift = bitsPerSample * 2 ; } else { if ( client -> format . bitsPerPixel == 8 * 3 ) { client -> format . redShift = bitsPerSample * 2 ; client -> format . greenShift = bitsPerSample * 1 ; client -> format . blueShift = 0 ; } else { client -> format . redShift = bitsPerSample * 3 ; client -> format . greenShift = bitsPerSample * 2 ; client -> format . blueShift = bitsPerSample ; } } } client -> bufoutptr = client -> buf ; client -> buffered = 0 ; # ifdef LIBVNCSERVER_HAVE_LIBZ client -> raw_buffer_size = - 1 ; client -> decompStreamInited = FALSE ; # ifdef LIBVNCSERVER_HAVE_LIBJPEG memset ( client -> zlibStreamActive , 0 , sizeof ( rfbBool ) * 4 ) ; # endif # endif client -> HandleCursorPos = DummyPoint ; client -> SoftCursorLockArea = DummyRect ; client -> SoftCursorUnlockScreen = Dummy ; client -> GotFrameBufferUpdate = DummyRect ; client -> GotCopyRect = CopyRectangleFromRectangle ; client -> GotFillRect = FillRectangle ; client -> GotBitmap = CopyRectangle ; client -> FinishedFrameBufferUpdate = NULL ; client -> GetPassword = ReadPassword ; client -> MallocFrameBuffer = MallocFrameBuffer ; client -> Bell = Dummy ; client -> CurrentKeyboardLedState = 0 ; client -> HandleKeyboardLedState = ( HandleKeyboardLedStateProc ) DummyPoint ; client -> QoS_DSCP = 0 ; client -> authScheme = 0 ; client -> subAuthScheme = 0 ; client -> GetCredential = NULL ; client -> tlsSession = NULL ; client -> LockWriteToTLS = NULL ; client -> UnlockWriteToTLS = NULL ; client -> sock = RFB_INVALID_SOCKET ; client -> listenSock = RFB_INVALID_SOCKET ; client -> listenAddress = NULL ; client -> listen6Sock = RFB_INVALID_SOCKET ; client -> listen6Address = NULL ; client -> clientAuthSchemes = NULL ; # ifdef LIBVNCSERVER_HAVE_SASL client -> GetSASLMechanism = NULL ; client -> GetUser = NULL ; client -> saslSecret = NULL ; # endif return client ; }",client -> connectTimeout = DEFAULT_CONNECT_TIMEOUT ;client -> readTimeout = DEFAULT_READ_TIMEOUT ;client -> CurrentKeyboardLedState = 0 ;,2432
383,"buggy line: for ( plane = 0 ;inpic -> data [ plane ] && plane < 4 ;h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ;cwe id:CWE-119context: static int filter_frame ( AVFilterLink * inlink , AVFrame * inpic ) { KerndeintContext * kerndeint = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * outpic ; const uint8_t * prvp ; const uint8_t * prvpp ; const uint8_t * prvpn ; const uint8_t * prvppp ; const uint8_t * prvpnn ; const uint8_t * prvp4p ; const uint8_t * prvp4n ; const uint8_t * srcp ; const uint8_t * srcpp ; const uint8_t * srcpn ; const uint8_t * srcppp ; const uint8_t * srcpnn ; const uint8_t * srcp3p ; const uint8_t * srcp3n ; const uint8_t * srcp4p ; const uint8_t * srcp4n ; uint8_t * dstp , * dstp_saved ; const uint8_t * srcp_saved ; int src_linesize , psrc_linesize , dst_linesize , bwidth ; int x , y , plane , val , hi , lo , g , h , n = kerndeint -> frame ++ ; double valf ; const int thresh = kerndeint -> thresh ; const int order = kerndeint -> order ; const int map = kerndeint -> map ; const int sharp = kerndeint -> sharp ; const int twoway = kerndeint -> twoway ; const int is_packed_rgb = kerndeint -> is_packed_rgb ; outpic = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! outpic ) { av_frame_free ( & inpic ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( outpic , inpic ) ; outpic -> interlaced_frame = 0 ;  for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) {  h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ; bwidth = kerndeint -> tmp_bwidth [ plane ] ; srcp = srcp_saved = inpic -> data [ plane ] ; src_linesize = inpic -> linesize [ plane ] ; psrc_linesize = kerndeint -> tmp_linesize [ plane ] ; dstp = dstp_saved = outpic -> data [ plane ] ; dst_linesize = outpic -> linesize [ plane ] ; srcp = srcp_saved + ( 1 - order ) * src_linesize ; dstp = dstp_saved + ( 1 - order ) * dst_linesize ; for ( y = 0 ; y < h ; y += 2 ) { memcpy ( dstp , srcp , bwidth ) ; srcp += 2 * src_linesize ; dstp += 2 * dst_linesize ; } memcpy ( dstp_saved + order * dst_linesize , srcp_saved + ( 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( 2 + order ) * dst_linesize , srcp_saved + ( 3 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 2 + order ) * dst_linesize , srcp_saved + ( h - 1 - order ) * src_linesize , bwidth ) ; memcpy ( dstp_saved + ( h - 4 + order ) * dst_linesize , srcp_saved + ( h - 3 - order ) * src_linesize , bwidth ) ; prvp = kerndeint -> tmp_data [ plane ] + 5 * psrc_linesize - ( 1 - order ) * psrc_linesize ; prvpp = prvp - psrc_linesize ; prvppp = prvp - 2 * psrc_linesize ; prvp4p = prvp - 4 * psrc_linesize ; prvpn = prvp + psrc_linesize ; prvpnn = prvp + 2 * psrc_linesize ; prvp4n = prvp + 4 * psrc_linesize ; srcp = srcp_saved + 5 * src_linesize - ( 1 - order ) * src_linesize ; srcpp = srcp - src_linesize ; srcppp = srcp - 2 * src_linesize ; srcp3p = srcp - 3 * src_linesize ; srcp4p = srcp - 4 * src_linesize ; srcpn = srcp + src_linesize ; srcpnn = srcp + 2 * src_linesize ; srcp3n = srcp + 3 * src_linesize ; srcp4n = srcp + 4 * src_linesize ; dstp = dstp_saved + 5 * dst_linesize - ( 1 - order ) * dst_linesize ; for ( y = 5 - ( 1 - order ) ; y <= h - 5 - ( 1 - order ) ; y += 2 ) { for ( x = 0 ; x < bwidth ; x ++ ) { if ( thresh == 0 || n == 0 || ( abs ( ( int ) prvp [ x ] - ( int ) srcp [ x ] ) > thresh ) || ( abs ( ( int ) prvpp [ x ] - ( int ) srcpp [ x ] ) > thresh ) || ( abs ( ( int ) prvpn [ x ] - ( int ) srcpn [ x ] ) > thresh ) ) { if ( map ) { g = x & ~ 3 ; if ( is_packed_rgb ) { AV_WB32 ( dstp + g , 0xffffffff ) ; x = g + 3 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { AV_WB32 ( dstp + g , 0xeb80eb80 ) ; x = g + 3 ; } else { dstp [ x ] = plane == 0 ? 235 : 128 ; } } else { if ( is_packed_rgb ) { hi = 255 ; lo = 0 ; } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { hi = x & 1 ? 240 : 235 ; lo = 16 ; } else { hi = plane == 0 ? 235 : 240 ; lo = 16 ; } if ( sharp ) { if ( twoway ) { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - 0.116 * ( ( int ) srcppp [ x ] + ( int ) srcpnn [ x ] + ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) srcp4p [ x ] + ( int ) srcp4n [ x ] + ( int ) prvp4p [ x ] + ( int ) prvp4n [ x ] ) ; } else { valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 0.170 * ( ( int ) prvp [ x ] ) - 0.116 * ( ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) + 0.031 * ( ( int ) prvp4p [ x ] + ( int ) prvp4p [ x ] ) ; } dstp [ x ] = av_clip ( valf , lo , hi ) ; } else { if ( twoway ) { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) - ( int ) ( srcppp [ x ] ) - ( int ) ( srcpnn [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } else { val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) prvp [ x ] ) - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; } dstp [ x ] = av_clip ( val , lo , hi ) ; } } } else { dstp [ x ] = srcp [ x ] ; } } prvp += 2 * psrc_linesize ; prvpp += 2 * psrc_linesize ; prvppp += 2 * psrc_linesize ; prvpn += 2 * psrc_linesize ; prvpnn += 2 * psrc_linesize ; prvp4p += 2 * psrc_linesize ; prvp4n += 2 * psrc_linesize ; srcp += 2 * src_linesize ; srcpp += 2 * src_linesize ; srcppp += 2 * src_linesize ; srcp3p += 2 * src_linesize ; srcp4p += 2 * src_linesize ; srcpn += 2 * src_linesize ; srcpnn += 2 * src_linesize ; srcp3n += 2 * src_linesize ; srcp4n += 2 * src_linesize ; dstp += 2 * dst_linesize ; } srcp = inpic -> data [ plane ] ; dstp = kerndeint -> tmp_data [ plane ] ; av_image_copy_plane ( dstp , psrc_linesize , srcp , src_linesize , bwidth , h ) ; } av_frame_free ( & inpic ) ; return ff_filter_frame ( outlink , outpic ) ; }","plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ] ;h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ;",2433
384,"buggy line: map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ;if ( NULL == map ) return - ENOMEM ;cwe id:CWE-119context: static int __videobuf_mmap_mapper ( struct videobuf_queue * q , struct vm_area_struct * vma ) { struct videbuf_vmalloc_memory * mem ; struct videobuf_mapping * map ; unsigned int first ; int retval ; unsigned long offset = vma -> vm_pgoff << PAGE_SHIFT ; if ( ! ( vma -> vm_flags & VM_WRITE ) || ! ( vma -> vm_flags & VM_SHARED ) ) return - EINVAL ; for ( first = 0 ; first < VIDEO_MAX_FRAME ; first ++ ) { if ( NULL == q -> bufs [ first ] ) continue ; if ( V4L2_MEMORY_MMAP != q -> bufs [ first ] -> memory ) continue ; if ( q -> bufs [ first ] -> boff == offset ) break ; } if ( VIDEO_MAX_FRAME == first ) { dprintk ( 1 , ""mmap<S2SV_blank>app<S2SV_blank>bug:<S2SV_blank>offset<S2SV_blank>invalid<S2SV_blank>[offset=0x%lx]\\n"" , ( vma -> vm_pgoff << PAGE_SHIFT ) ) ; return - EINVAL ; }  map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ;  if ( NULL == map ) return - ENOMEM ; map -> start = vma -> vm_start ; map -> end = vma -> vm_end ; map -> q = q ; q -> bufs [ first ] -> baddr = vma -> vm_start ; vma -> vm_ops = & videobuf_vm_ops ; vma -> vm_flags |= VM_DONTEXPAND | VM_RESERVED ; vma -> vm_private_data = map ; mem = q -> bufs [ first ] -> priv ; BUG_ON ( ! mem ) ; MAGIC_CHECK ( mem -> magic , MAGIC_VMAL_MEM ) ; retval = remap_vmalloc_range ( vma , mem -> vmalloc , 0 ) ; if ( retval < 0 ) { dprintk ( 1 , ""mmap:<S2SV_blank>postponing<S2SV_blank>remap_vmalloc_range\\n"" ) ; mem -> vma = kmalloc ( sizeof ( * vma ) , GFP_KERNEL ) ; if ( ! mem -> vma ) { kfree ( map ) ; q -> bufs [ first ] -> map = NULL ; return - ENOMEM ; } memcpy ( mem -> vma , vma , sizeof ( * vma ) ) ; } dprintk ( 1 , ""mmap<S2SV_blank>%p:<S2SV_blank>q=%p<S2SV_blank>%08lx-%08lx<S2SV_blank>(%lx)<S2SV_blank>pgoff<S2SV_blank>%08lx<S2SV_blank>buf<S2SV_blank>%d\\n"" , map , q , vma -> vm_start , vma -> vm_end , ( long int ) q -> bufs [ first ] -> bsize , vma -> vm_pgoff , first ) ; videobuf_vm_open ( vma ) ; return ( 0 ) ; }","map = q -> bufs [ first ] -> map = kzalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ;if ( NULL == map ) return - ENOMEM ;",2434
385,"buggy line: sock -> sk -> sk_uid = iattr -> ia_uid ;}return err ;cwe id:CWE-362context: static int sockfs_setattr ( struct dentry * dentry , struct iattr * iattr ) { int err = simple_setattr ( dentry , iattr ) ; if ( ! err && ( iattr -> ia_valid & ATTR_UID ) ) { struct socket * sock = SOCKET_I ( d_inode ( dentry ) ) ;  sock -> sk -> sk_uid = iattr -> ia_uid ;   }  return err ; }",if ( sock -> sk ) sock -> sk -> sk_uid = iattr -> ia_uid ;else err = - ENOENT ;}return err ;,2435
386,"buggy line: struct sk_buff * skb ;if ( len > 0xFFFF ) return - EMSGSIZE ;cwe id:CWE-362context: int udp_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct udp_sock * up = udp_sk ( sk ) ; struct flowi4 * fl4 ; int ulen = len ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; int free = 0 ; int connected = 0 ; __be32 daddr , faddr , saddr ; __be16 dport ; u8 tos ; int err , is_udplite = IS_UDPLITE ( sk ) ; int corkreq = up -> corkflag || msg -> msg_flags & MSG_MORE ; int ( * getfrag ) ( void * , char * , int , int , int , struct sk_buff * ) ;  struct sk_buff * skb ;  if ( len > 0xFFFF ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; ipc . opt = NULL ; ipc . tx_flags = 0 ; getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag ; if ( up -> pending ) { lock_sock ( sk ) ; if ( likely ( up -> pending ) ) { if ( unlikely ( up -> pending != AF_INET ) ) { release_sock ( sk ) ; return - EINVAL ; } goto do_append_data ; } release_sock ( sk ) ; } ulen += sizeof ( struct udphdr ) ; if ( msg -> msg_name ) { struct sockaddr_in * usin = ( struct sockaddr_in * ) msg -> msg_name ; if ( msg -> msg_namelen < sizeof ( * usin ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) { if ( usin -> sin_family != AF_UNSPEC ) return - EAFNOSUPPORT ; } daddr = usin -> sin_addr . s_addr ; dport = usin -> sin_port ; if ( dport == 0 ) return - EINVAL ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = inet -> inet_daddr ; dport = inet -> inet_dport ; connected = 1 ; } ipc . addr = inet -> inet_saddr ; ipc . oif = sk -> sk_bound_dev_if ; err = sock_tx_timestamp ( sk , & ipc . tx_flags ) ; if ( err ) return err ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sock_net ( sk ) , msg , & ipc ) ; if ( err ) return err ; if ( ipc . opt ) free = 1 ; connected = 0 ; } if ( ! ipc . opt )  ipc . opt = inet -> opt ;  saddr = ipc . addr ; ipc . addr = faddr = daddr ;  if ( ipc . opt && ipc . opt -> srr ) {  if ( ! daddr ) return - EINVAL ;  faddr = ipc . opt -> faddr ;  connected = 0 ; } tos = RT_TOS ( inet -> tos ) ; if ( sock_flag ( sk , SOCK_LOCALROUTE ) || ( msg -> msg_flags & MSG_DONTROUTE ) ||  ( ipc . opt && ipc . opt -> is_strictroute ) ) {  tos |= RTO_ONLINK ; connected = 0 ; } if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; connected = 0 ; } if ( connected ) rt = ( struct rtable * ) sk_dst_check ( sk , 0 ) ; if ( rt == NULL ) { struct flowi4 fl4 ; struct net * net = sock_net ( sk ) ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) | FLOWI_FLAG_CAN_SLEEP , faddr , saddr , dport , inet -> inet_sport ) ; security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; if ( err == - ENETUNREACH ) IP_INC_STATS_BH ( net , IPSTATS_MIB_OUTNOROUTES ) ; goto out ; } err = - EACCES ; if ( ( rt -> rt_flags & RTCF_BROADCAST ) && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto out ; if ( connected ) sk_dst_set ( sk , dst_clone ( & rt -> dst ) ) ; } if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : saddr = rt -> rt_src ; if ( ! ipc . addr ) daddr = ipc . addr = rt -> rt_dst ; if ( ! corkreq ) { skb = ip_make_skb ( sk , getfrag , msg -> msg_iov , ulen , sizeof ( struct udphdr ) , & ipc , & rt , msg -> msg_flags ) ; err = PTR_ERR ( skb ) ; if ( skb && ! IS_ERR ( skb ) ) err = udp_send_skb ( skb , daddr , dport ) ; goto out ; } lock_sock ( sk ) ; if ( unlikely ( up -> pending ) ) { release_sock ( sk ) ; LIMIT_NETDEBUG ( KERN_DEBUG ""udp<S2SV_blank>cork<S2SV_blank>app<S2SV_blank>bug<S2SV_blank>2\\n"" ) ; err = - EINVAL ; goto out ; } fl4 = & inet -> cork . fl . u . ip4 ; fl4 -> daddr = daddr ; fl4 -> saddr = saddr ; fl4 -> fl4_dport = dport ; fl4 -> fl4_sport = inet -> inet_sport ; up -> pending = AF_INET ; do_append_data : up -> len += ulen ; err = ip_append_data ( sk , getfrag , msg -> msg_iov , ulen , sizeof ( struct udphdr ) , & ipc , & rt , corkreq ? msg -> msg_flags | MSG_MORE : msg -> msg_flags ) ; if ( err ) udp_flush_pending_frames ( sk ) ; else if ( ! corkreq ) err = udp_push_pending_frames ( sk ) ; else if ( unlikely ( skb_queue_empty ( & sk -> sk_write_queue ) ) ) up -> pending = 0 ; release_sock ( sk ) ; out : ip_rt_put ( rt ) ; if ( free ) kfree ( ipc . opt ) ; if ( ! err ) return len ; if ( err == - ENOBUFS || test_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; } return err ; do_confirm : dst_confirm ( & rt -> dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto out ; }",struct sk_buff * skb ;struct ip_options_data opt_copy ;if ( len > 0xFFFF ) return - EMSGSIZE ;,2436
387,"buggy line: if ( ipc . opt ) free = 1 ;connected = 0 ;if ( ! ipc . opt )  ipc . opt = inet -> opt ;saddr = ipc . addr ;if ( ipc . opt && ipc . opt -> srr ) {if ( ! daddr ) return - EINVAL ;faddr = ipc . opt -> faddr ;connected = 0 ;if ( sock_flag ( sk , SOCK_LOCALROUTE ) || ( msg -> msg_flags & MSG_DONTROUTE ) ||  ( ipc . opt && ipc . opt -> is_strictroute ) ) {tos |= RTO_ONLINK ;cwe id:CWE-362context: int udp_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct udp_sock * up = udp_sk ( sk ) ; struct flowi4 * fl4 ; int ulen = len ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; int free = 0 ; int connected = 0 ; __be32 daddr , faddr , saddr ; __be16 dport ; u8 tos ; int err , is_udplite = IS_UDPLITE ( sk ) ; int corkreq = up -> corkflag || msg -> msg_flags & MSG_MORE ; int ( * getfrag ) ( void * , char * , int , int , int , struct sk_buff * ) ;  struct sk_buff * skb ;  if ( len > 0xFFFF ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; ipc . opt = NULL ; ipc . tx_flags = 0 ; getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag ; if ( up -> pending ) { lock_sock ( sk ) ; if ( likely ( up -> pending ) ) { if ( unlikely ( up -> pending != AF_INET ) ) { release_sock ( sk ) ; return - EINVAL ; } goto do_append_data ; } release_sock ( sk ) ; } ulen += sizeof ( struct udphdr ) ; if ( msg -> msg_name ) { struct sockaddr_in * usin = ( struct sockaddr_in * ) msg -> msg_name ; if ( msg -> msg_namelen < sizeof ( * usin ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) { if ( usin -> sin_family != AF_UNSPEC ) return - EAFNOSUPPORT ; } daddr = usin -> sin_addr . s_addr ; dport = usin -> sin_port ; if ( dport == 0 ) return - EINVAL ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = inet -> inet_daddr ; dport = inet -> inet_dport ; connected = 1 ; } ipc . addr = inet -> inet_saddr ; ipc . oif = sk -> sk_bound_dev_if ; err = sock_tx_timestamp ( sk , & ipc . tx_flags ) ; if ( err ) return err ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sock_net ( sk ) , msg , & ipc ) ; if ( err ) return err ; if ( ipc . opt ) free = 1 ; connected = 0 ; } if ( ! ipc . opt )  ipc . opt = inet -> opt ;  saddr = ipc . addr ; ipc . addr = faddr = daddr ;  if ( ipc . opt && ipc . opt -> srr ) {  if ( ! daddr ) return - EINVAL ;  faddr = ipc . opt -> faddr ;  connected = 0 ; } tos = RT_TOS ( inet -> tos ) ; if ( sock_flag ( sk , SOCK_LOCALROUTE ) || ( msg -> msg_flags & MSG_DONTROUTE ) ||  ( ipc . opt && ipc . opt -> is_strictroute ) ) {  tos |= RTO_ONLINK ; connected = 0 ; } if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; connected = 0 ; } if ( connected ) rt = ( struct rtable * ) sk_dst_check ( sk , 0 ) ; if ( rt == NULL ) { struct flowi4 fl4 ; struct net * net = sock_net ( sk ) ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) | FLOWI_FLAG_CAN_SLEEP , faddr , saddr , dport , inet -> inet_sport ) ; security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; if ( err == - ENETUNREACH ) IP_INC_STATS_BH ( net , IPSTATS_MIB_OUTNOROUTES ) ; goto out ; } err = - EACCES ; if ( ( rt -> rt_flags & RTCF_BROADCAST ) && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto out ; if ( connected ) sk_dst_set ( sk , dst_clone ( & rt -> dst ) ) ; } if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : saddr = rt -> rt_src ; if ( ! ipc . addr ) daddr = ipc . addr = rt -> rt_dst ; if ( ! corkreq ) { skb = ip_make_skb ( sk , getfrag , msg -> msg_iov , ulen , sizeof ( struct udphdr ) , & ipc , & rt , msg -> msg_flags ) ; err = PTR_ERR ( skb ) ; if ( skb && ! IS_ERR ( skb ) ) err = udp_send_skb ( skb , daddr , dport ) ; goto out ; } lock_sock ( sk ) ; if ( unlikely ( up -> pending ) ) { release_sock ( sk ) ; LIMIT_NETDEBUG ( KERN_DEBUG ""udp<S2SV_blank>cork<S2SV_blank>app<S2SV_blank>bug<S2SV_blank>2\\n"" ) ; err = - EINVAL ; goto out ; } fl4 = & inet -> cork . fl . u . ip4 ; fl4 -> daddr = daddr ; fl4 -> saddr = saddr ; fl4 -> fl4_dport = dport ; fl4 -> fl4_sport = inet -> inet_sport ; up -> pending = AF_INET ; do_append_data : up -> len += ulen ; err = ip_append_data ( sk , getfrag , msg -> msg_iov , ulen , sizeof ( struct udphdr ) , & ipc , & rt , corkreq ? msg -> msg_flags | MSG_MORE : msg -> msg_flags ) ; if ( err ) udp_flush_pending_frames ( sk ) ; else if ( ! corkreq ) err = udp_push_pending_frames ( sk ) ; else if ( unlikely ( skb_queue_empty ( & sk -> sk_write_queue ) ) ) up -> pending = 0 ; release_sock ( sk ) ; out : ip_rt_put ( rt ) ; if ( free ) kfree ( ipc . opt ) ; if ( ! err ) return len ; if ( err == - ENOBUFS || test_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; } return err ; do_confirm : dst_confirm ( & rt -> dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto out ; }","if ( ipc . opt ) {struct ip_options_rcu * inet_opt ;rcu_read_lock ( ) ;inet_opt = rcu_dereference ( inet -> inet_opt ) ;if ( inet_opt ) {memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ;ipc . opt = & opt_copy . opt ;}rcu_read_unlock ( ) ;saddr = ipc . addr ;if ( ipc . opt && ipc . opt -> opt . srr ) {if ( ! daddr ) return - EINVAL ;faddr = ipc . opt -> opt . faddr ;connected = 0 ;if ( sock_flag ( sk , SOCK_LOCALROUTE ) || ( msg -> msg_flags & MSG_DONTROUTE ) || ( ipc . opt && ipc . opt -> opt . is_strictroute ) ) {tos |= RTO_ONLINK ;",2436
388,"buggy line: for ( vma = mm -> mmap ;vma = vma -> vm_next )  if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) {cwe id:CWE-362context: static void userfaultfd_event_wait_completion ( struct userfaultfd_ctx * ctx , struct userfaultfd_wait_queue * ewq ) { struct userfaultfd_ctx * release_new_ctx ; if ( WARN_ON_ONCE ( current -> flags & PF_EXITING ) ) goto out ; ewq -> ctx = ctx ; init_waitqueue_entry ( & ewq -> wq , current ) ; release_new_ctx = NULL ; spin_lock ( & ctx -> event_wqh . lock ) ; __add_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; for ( ; ; ) { set_current_state ( TASK_KILLABLE ) ; if ( ewq -> msg . event == 0 ) break ; if ( READ_ONCE ( ctx -> released ) || fatal_signal_pending ( current ) ) { __remove_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; if ( ewq -> msg . event == UFFD_EVENT_FORK ) { struct userfaultfd_ctx * new ; new = ( struct userfaultfd_ctx * ) ( unsigned long ) ewq -> msg . arg . reserved . reserved1 ; release_new_ctx = new ; } break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLIN ) ; schedule ( ) ; spin_lock ( & ctx -> event_wqh . lock ) ; } __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; if ( release_new_ctx ) { struct vm_area_struct * vma ; struct mm_struct * mm = release_new_ctx -> mm ; down_write ( & mm -> mmap_sem ) ;  for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next )  if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) { vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; vma -> vm_flags &= ~ ( VM_UFFD_WP | VM_UFFD_MISSING ) ; } up_write ( & mm -> mmap_sem ) ; userfaultfd_ctx_put ( release_new_ctx ) ; } out : WRITE_ONCE ( ctx -> mmap_changing , false ) ; userfaultfd_ctx_put ( ctx ) ; }",VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;for ( vma = mm -> mmap ;vma = vma -> vm_next ) if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) {,2437
389,"buggy line: ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ;cwe id:CWE-362context: static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags , unsigned int allocated , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = ext4_inode_aio ( inode ) ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical<S2SV_blank>"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%x,<S2SV_blank>allocated<S2SV_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; trace_ext4_ext_handle_uninitialized_extents ( inode , map , allocated , newblock ) ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) { ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ; if ( ret <= 0 ) goto out ; if ( io ) ext4_set_io_unwritten_flag ( inode , io ) ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) map -> m_flags |= EXT4_MAP_UNINIT ; goto out ; } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) {  ret = ext4_convert_unwritten_extents_endio ( handle , inode ,  path ) ; if ( ret >= 0 ) { ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; } else err = ret ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { map -> m_flags |= EXT4_MAP_UNWRITTEN ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , map , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; map -> m_flags |= EXT4_MAP_NEW ; if ( allocated > map -> m_len ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + map -> m_len , allocated - map -> m_len ) ; allocated = map -> m_len ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) { unsigned int reserved_clusters ; reserved_clusters = get_reserved_cluster_alloc ( inode , map -> m_lblk , map -> m_len ) ; if ( reserved_clusters ) ext4_da_update_reserve_space ( inode , reserved_clusters , 0 ) ; } map_out : map -> m_flags |= EXT4_MAP_MAPPED ; if ( ( flags & EXT4_GET_BLOCKS_KEEP_SIZE ) == 0 ) { err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; if ( err < 0 ) goto out2 ; } out1 : if ( allocated > map -> m_len ) allocated = map -> m_len ; ext4_ext_show_leaf ( inode , path ) ; map -> m_pblk = newblock ; map -> m_len = allocated ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }","ret = ext4_split_unwritten_extents ( handle , inode , map , map , path , flags ) ;",2438
390,"buggy line: ret = ext4_convert_unwritten_extents_endio ( handle , inode ,  path ) ;cwe id:CWE-362context: static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags , unsigned int allocated , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = ext4_inode_aio ( inode ) ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical<S2SV_blank>"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%x,<S2SV_blank>allocated<S2SV_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; trace_ext4_ext_handle_uninitialized_extents ( inode , map , allocated , newblock ) ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) { ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ; if ( ret <= 0 ) goto out ; if ( io ) ext4_set_io_unwritten_flag ( inode , io ) ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) map -> m_flags |= EXT4_MAP_UNINIT ; goto out ; } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) {  ret = ext4_convert_unwritten_extents_endio ( handle , inode ,  path ) ; if ( ret >= 0 ) { ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; } else err = ret ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { map -> m_flags |= EXT4_MAP_UNWRITTEN ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , map , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; map -> m_flags |= EXT4_MAP_NEW ; if ( allocated > map -> m_len ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + map -> m_len , allocated - map -> m_len ) ; allocated = map -> m_len ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) { unsigned int reserved_clusters ; reserved_clusters = get_reserved_cluster_alloc ( inode , map -> m_lblk , map -> m_len ) ; if ( reserved_clusters ) ext4_da_update_reserve_space ( inode , reserved_clusters , 0 ) ; } map_out : map -> m_flags |= EXT4_MAP_MAPPED ; if ( ( flags & EXT4_GET_BLOCKS_KEEP_SIZE ) == 0 ) { err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; if ( err < 0 ) goto out2 ; } out1 : if ( allocated > map -> m_len ) allocated = map -> m_len ; ext4_ext_show_leaf ( inode , path ) ; map -> m_pblk = newblock ; map -> m_len = allocated ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }","ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;",2438
391,"buggy line: if ( mi < 0 )  return - EINVAL ;return remap_pfn_range ( vma , vma -> vm_start ,  idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;cwe id:CWE-119context: static int uio_mmap_physical ( struct vm_area_struct * vma ) { struct uio_device * idev = vma -> vm_private_data ; int mi = uio_find_mem_index ( vma ) ;  if ( mi < 0 )  return - EINVAL ; vma -> vm_ops = & uio_physical_vm_ops ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; return remap_pfn_range ( vma , vma -> vm_start ,  idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }","struct uio_mem * mem ;if ( mi < 0 ) return - EINVAL ;mem = idev -> info -> mem + mi ;if ( vma -> vm_end - vma -> vm_start > mem -> size ) return - EINVAL ;return remap_pfn_range ( vma , vma -> vm_start , mem -> addr >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;",2439
392,"buggy line: mpz_t xdiff , ydiff , lambda ;mpz_inits ( xdiff , ydiff , lambda , NULL ) ;cwe id:CWE-347context: void pointZZ_pAdd ( PointZZ_p * rop , const PointZZ_p * op1 , const PointZZ_p * op2 , const CurveZZ_p * curve ) {  mpz_t xdiff , ydiff , lambda ;  mpz_inits ( xdiff , ydiff , lambda , NULL ) ; mpz_sub ( ydiff , op2 -> y , op1 -> y ) ; mpz_sub ( xdiff , op2 -> x , op1 -> x ) ; mpz_invert ( xdiff , xdiff , curve -> p ) ; mpz_mul ( lambda , ydiff , xdiff ) ; mpz_mod ( lambda , lambda , curve -> p ) ; mpz_mul ( rop -> x , lambda , lambda ) ; mpz_sub ( rop -> x , rop -> x , op1 -> x ) ; mpz_sub ( rop -> x , rop -> x , op2 -> x ) ; mpz_mod ( rop -> x , rop -> x , curve -> p ) ; mpz_sub ( rop -> y , op1 -> x , rop -> x ) ; mpz_mul ( rop -> y , lambda , rop -> y ) ; mpz_sub ( rop -> y , rop -> y , op1 -> y ) ; mpz_mod ( rop -> y , rop -> y , curve -> p ) ;  mpz_clears ( xdiff , ydiff , lambda , NULL ) ;  }","if ( pointZZ_pIsIdentityElement ( op1 ) && pointZZ_pIsIdentityElement ( op2 ) ) {return pointZZ_pSetToIdentityElement ( rop ) ;}else if ( pointZZ_pIsIdentityElement ( op1 ) ) {mpz_set ( rop -> x , op2 -> x ) ;mpz_set ( rop -> y , op2 -> y ) ;return ;}else if ( pointZZ_pIsIdentityElement ( op2 ) ) {mpz_set ( rop -> x , op1 -> x ) ;mpz_set ( rop -> y , op1 -> y ) ;return ;}if ( pointZZ_pEqual ( op1 , op2 ) ) {pointZZ_pDouble ( rop , op1 , curve ) ;return ;}mpz_t negy ;mpz_init ( negy ) ;mpz_sub ( negy , curve -> p , op2 -> y ) ;if ( mpz_cmp ( op1 -> x , op2 -> x ) == 0 && mpz_cmp ( op1 -> y , negy ) == 0 ) {mpz_clear ( negy ) ;return pointZZ_pSetToIdentityElement ( rop ) ;}mpz_t xdiff , ydiff , lambda ;mpz_inits ( xdiff , ydiff , lambda , NULL ) ;",2440
393,"buggy line: mpz_clears ( xdiff , ydiff , lambda , NULL ) ;}cwe id:CWE-347context: void pointZZ_pAdd ( PointZZ_p * rop , const PointZZ_p * op1 , const PointZZ_p * op2 , const CurveZZ_p * curve ) {  mpz_t xdiff , ydiff , lambda ;  mpz_inits ( xdiff , ydiff , lambda , NULL ) ; mpz_sub ( ydiff , op2 -> y , op1 -> y ) ; mpz_sub ( xdiff , op2 -> x , op1 -> x ) ; mpz_invert ( xdiff , xdiff , curve -> p ) ; mpz_mul ( lambda , ydiff , xdiff ) ; mpz_mod ( lambda , lambda , curve -> p ) ; mpz_mul ( rop -> x , lambda , lambda ) ; mpz_sub ( rop -> x , rop -> x , op1 -> x ) ; mpz_sub ( rop -> x , rop -> x , op2 -> x ) ; mpz_mod ( rop -> x , rop -> x , curve -> p ) ; mpz_sub ( rop -> y , op1 -> x , rop -> x ) ; mpz_mul ( rop -> y , lambda , rop -> y ) ; mpz_sub ( rop -> y , rop -> y , op1 -> y ) ; mpz_mod ( rop -> y , rop -> y , curve -> p ) ;  mpz_clears ( xdiff , ydiff , lambda , NULL ) ;  }","mpz_clears ( negy , xdiff , ydiff , lambda , NULL ) ;}",2440
394,"buggy line: char * ext , szName [ 1000 ] , szExt [ 20 ] ;const char * szExtList ;cwe id:CWE-119context: static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) { Bool has_audio , has_video ; s32 i ; AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ;  char * ext , szName [ 1000 ] , szExt [ 20 ] ;  const char * szExtList ; FFDemux * ffd ; if ( ! plug || ! url ) return GF_FALSE ; if ( ! strnicmp ( url , ""rtsp://"" , 7 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""rtspu://"" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""rtp://"" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""plato://"" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""udp://"" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""tcp://"" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""data:"" , 5 ) ) return GF_FALSE ; ffd = ( FFDemux * ) plug -> priv ;  strcpy ( szName , url ) ;  ext = strrchr ( szName , '#' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '?' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '.' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ;  if ( ext && strlen ( ext ) > 1 ) {  strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; # ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS if ( strstr ( ""ts<S2SV_blank>m2t<S2SV_blank>mts<S2SV_blank>dmb<S2SV_blank>trp"" , szExt ) ) return GF_FALSE ; # endif if ( ! strcmp ( szExt , ""mp4"" ) || ! strcmp ( szExt , ""mpg4"" ) || ! strcmp ( szExt , ""m4a"" ) || ! strcmp ( szExt , ""m21"" ) || ! strcmp ( szExt , ""m4v"" ) || ! strcmp ( szExt , ""m4a"" ) || ! strcmp ( szExt , ""m4s"" ) || ! strcmp ( szExt , ""3gs"" ) || ! strcmp ( szExt , ""3gp"" ) || ! strcmp ( szExt , ""3gpp"" ) || ! strcmp ( szExt , ""3gp2"" ) || ! strcmp ( szExt , ""3g2"" ) || ! strcmp ( szExt , ""mp3"" ) || ! strcmp ( szExt , ""ac3"" ) || ! strcmp ( szExt , ""amr"" ) || ! strcmp ( szExt , ""bt"" ) || ! strcmp ( szExt , ""wrl"" ) || ! strcmp ( szExt , ""x3dv"" ) || ! strcmp ( szExt , ""xmt"" ) || ! strcmp ( szExt , ""xmta"" ) || ! strcmp ( szExt , ""x3d"" ) || ! strcmp ( szExt , ""jpg"" ) || ! strcmp ( szExt , ""jpeg"" ) || ! strcmp ( szExt , ""png"" ) ) return GF_FALSE ; { u32 i ; for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) return GF_TRUE ; } } } ffd_parse_options ( ffd , url ) ; ctx = NULL ; if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { AVInputFormat * av_in = NULL ; if ( ext && ! strcmp ( szExt , ""cmp"" ) ) av_in = av_find_input_format ( ""m4v"" ) ; if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { return GF_FALSE ; } } if ( ! ctx ) goto exit ; if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; has_video = has_audio = GF_FALSE ; for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { AVCodecContext * enc = ctx -> streams [ i ] -> codec ; switch ( enc -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ! has_audio ) has_audio = GF_TRUE ; break ; case AVMEDIA_TYPE_VIDEO : if ( ! has_video ) has_video = GF_TRUE ; break ; default : break ; } } if ( ! has_audio && ! has_video ) goto exit ; ret = GF_TRUE ; # if ( ( LIBAVFORMAT_VERSION_MAJOR == 52 ) && ( LIBAVFORMAT_VERSION_MINOR <= 47 ) ) || ( LIBAVFORMAT_VERSION_MAJOR < 52 ) fmt_out = guess_stream_format ( NULL , url , NULL ) ; # else fmt_out = av_guess_format ( NULL , url , NULL ) ; # endif if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; else { ext = strrchr ( szName , '.' ) ; if ( ext ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , ""MimeTypes"" , ""application/x-ffmpeg"" ) ; if ( ! szExtList ) { gf_service_register_mime ( plug , ""application/x-ffmpeg"" , szExt , ""Other<S2SV_blank>Movies<S2SV_blank>(FFMPEG)"" ) ; } else if ( ! strstr ( szExtList , szExt ) ) { u32 len ; char * buf ; len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; sprintf ( buf , ""\\""%s<S2SV_blank>"" , szExt ) ; strcat ( buf , & szExtList [ 1 ] ) ; gf_modules_set_option ( ( GF_BaseInterface * ) plug , ""MimeTypes"" , ""application/x-ffmpeg"" , buf ) ; gf_free ( buf ) ; } } } exit : # if FF_API_CLOSE_INPUT_FILE if ( ctx ) av_close_input_file ( ctx ) ; # else if ( ctx ) avformat_close_input ( & ctx ) ; # endif return ret ; }","char * ext , szName [ 1024 ] , szExt [ 20 ] ;const char * szExtList ;",2441
395,"buggy line: strcpy ( szName , url ) ;ext = strrchr ( szName , \'#\' ) ;if ( ext && strlen ( ext ) > 1 ) {strcpy ( szExt , & ext [ 1 ] ) ;cwe id:CWE-119context: static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) { Bool has_audio , has_video ; s32 i ; AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ;  char * ext , szName [ 1000 ] , szExt [ 20 ] ;  const char * szExtList ; FFDemux * ffd ; if ( ! plug || ! url ) return GF_FALSE ; if ( ! strnicmp ( url , ""rtsp://"" , 7 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""rtspu://"" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""rtp://"" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""plato://"" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""udp://"" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""tcp://"" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""data:"" , 5 ) ) return GF_FALSE ; ffd = ( FFDemux * ) plug -> priv ;  strcpy ( szName , url ) ;  ext = strrchr ( szName , '#' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '?' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '.' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ;  if ( ext && strlen ( ext ) > 1 ) {  strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; # ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS if ( strstr ( ""ts<S2SV_blank>m2t<S2SV_blank>mts<S2SV_blank>dmb<S2SV_blank>trp"" , szExt ) ) return GF_FALSE ; # endif if ( ! strcmp ( szExt , ""mp4"" ) || ! strcmp ( szExt , ""mpg4"" ) || ! strcmp ( szExt , ""m4a"" ) || ! strcmp ( szExt , ""m21"" ) || ! strcmp ( szExt , ""m4v"" ) || ! strcmp ( szExt , ""m4a"" ) || ! strcmp ( szExt , ""m4s"" ) || ! strcmp ( szExt , ""3gs"" ) || ! strcmp ( szExt , ""3gp"" ) || ! strcmp ( szExt , ""3gpp"" ) || ! strcmp ( szExt , ""3gp2"" ) || ! strcmp ( szExt , ""3g2"" ) || ! strcmp ( szExt , ""mp3"" ) || ! strcmp ( szExt , ""ac3"" ) || ! strcmp ( szExt , ""amr"" ) || ! strcmp ( szExt , ""bt"" ) || ! strcmp ( szExt , ""wrl"" ) || ! strcmp ( szExt , ""x3dv"" ) || ! strcmp ( szExt , ""xmt"" ) || ! strcmp ( szExt , ""xmta"" ) || ! strcmp ( szExt , ""x3d"" ) || ! strcmp ( szExt , ""jpg"" ) || ! strcmp ( szExt , ""jpeg"" ) || ! strcmp ( szExt , ""png"" ) ) return GF_FALSE ; { u32 i ; for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) return GF_TRUE ; } } } ffd_parse_options ( ffd , url ) ; ctx = NULL ; if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { AVInputFormat * av_in = NULL ; if ( ext && ! strcmp ( szExt , ""cmp"" ) ) av_in = av_find_input_format ( ""m4v"" ) ; if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { return GF_FALSE ; } } if ( ! ctx ) goto exit ; if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; has_video = has_audio = GF_FALSE ; for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { AVCodecContext * enc = ctx -> streams [ i ] -> codec ; switch ( enc -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ! has_audio ) has_audio = GF_TRUE ; break ; case AVMEDIA_TYPE_VIDEO : if ( ! has_video ) has_video = GF_TRUE ; break ; default : break ; } } if ( ! has_audio && ! has_video ) goto exit ; ret = GF_TRUE ; # if ( ( LIBAVFORMAT_VERSION_MAJOR == 52 ) && ( LIBAVFORMAT_VERSION_MINOR <= 47 ) ) || ( LIBAVFORMAT_VERSION_MAJOR < 52 ) fmt_out = guess_stream_format ( NULL , url , NULL ) ; # else fmt_out = av_guess_format ( NULL , url , NULL ) ; # endif if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; else { ext = strrchr ( szName , '.' ) ; if ( ext ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , ""MimeTypes"" , ""application/x-ffmpeg"" ) ; if ( ! szExtList ) { gf_service_register_mime ( plug , ""application/x-ffmpeg"" , szExt , ""Other<S2SV_blank>Movies<S2SV_blank>(FFMPEG)"" ) ; } else if ( ! strstr ( szExtList , szExt ) ) { u32 len ; char * buf ; len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; sprintf ( buf , ""\\""%s<S2SV_blank>"" , szExt ) ; strcat ( buf , & szExtList [ 1 ] ) ; gf_modules_set_option ( ( GF_BaseInterface * ) plug , ""MimeTypes"" , ""application/x-ffmpeg"" , buf ) ; gf_free ( buf ) ; } } } exit : # if FF_API_CLOSE_INPUT_FILE if ( ctx ) av_close_input_file ( ctx ) ; # else if ( ctx ) avformat_close_input ( & ctx ) ; # endif return ret ; }","if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ;strcpy ( szName , url ) ;ext = strrchr ( szName , \'#\' ) ;if ( ext && strlen ( ext ) > 1 && strlen ( ext ) <= sizeof ( szExt ) ) {strcpy ( szExt , & ext [ 1 ] ) ;",2441
396,"buggy line: vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ;if ( ! vdev -> ctx ) return - ENOMEM ;cwe id:CWE-190context: static int vfio_msi_enable ( struct vfio_pci_device * vdev , int nvec , bool msix ) { struct pci_dev * pdev = vdev -> pdev ; unsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI ; int ret ; if ( ! is_irq_none ( vdev ) ) return - EINVAL ;  vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ;  if ( ! vdev -> ctx ) return - ENOMEM ; ret = pci_alloc_irq_vectors ( pdev , 1 , nvec , flag ) ; if ( ret < nvec ) { if ( ret > 0 ) pci_free_irq_vectors ( pdev ) ; kfree ( vdev -> ctx ) ; return ret ; } vdev -> num_ctx = nvec ; vdev -> irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX : VFIO_PCI_MSI_IRQ_INDEX ; if ( ! msix ) { vdev -> msi_qmax = fls ( nvec * 2 - 1 ) - 1 ; } return 0 ; }","vdev -> ctx = kcalloc ( nvec , sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ;if ( ! vdev -> ctx ) return - ENOMEM ;",2442
397,"buggy line: int rc = 0 ;memset ( & sllc , 0 , sizeof ( sllc ) ) ;* uaddrlen = sizeof ( sllc ) ;memset ( uaddr , 0 , * uaddrlen ) ;cwe id:CWE-200context: static int llc_ui_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddrlen , int peer ) { struct sockaddr_llc sllc ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ;  int rc = 0 ;  memset ( & sllc , 0 , sizeof ( sllc ) ) ; lock_sock ( sk ) ; if ( sock_flag ( sk , SOCK_ZAPPED ) ) goto out ;  * uaddrlen = sizeof ( sllc ) ;  memset ( uaddr , 0 , * uaddrlen ) ; if ( peer ) { rc = - ENOTCONN ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; if ( llc -> dev ) sllc . sllc_arphrd = llc -> dev -> type ; sllc . sllc_sap = llc -> daddr . lsap ; memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ) ; } else { rc = - EINVAL ; if ( ! llc -> sap ) goto out ; sllc . sllc_sap = llc -> sap -> laddr . lsap ; if ( llc -> dev ) { sllc . sllc_arphrd = llc -> dev -> type ; memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ) ; } } rc = 0 ; sllc . sllc_family = AF_LLC ; memcpy ( uaddr , & sllc , sizeof ( sllc ) ) ; out : release_sock ( sk ) ; return rc ; }","int rc = - EBADF ;memset ( & sllc , 0 , sizeof ( sllc ) ) ;* uaddrlen = sizeof ( sllc ) ;",2443
398,"buggy line: static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu )  {if ( ! to_vmx ( vcpu ) -> nested . vmxon ) {cwe id:CWE-000context: static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu )  {  if ( ! to_vmx ( vcpu ) -> nested . vmxon ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; } return 1 ; }","static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu ) {if ( vmx_get_cpl ( vcpu ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;return 0 ;}if ( ! to_vmx ( vcpu ) -> nested . vmxon ) {",2444
399,"buggy line: if ( atomic_dec_and_test ( & ucounts -> count ) ) {spin_lock_irqsave ( & ucounts_lock , flags ) ;hlist_del_init ( & ucounts -> node ) ;spin_unlock_irqrestore ( & ucounts_lock , flags ) ;}cwe id:CWE-416context: static void put_ucounts ( struct ucounts * ucounts ) { unsigned long flags ;  if ( atomic_dec_and_test ( & ucounts -> count ) ) {  spin_lock_irqsave ( & ucounts_lock , flags ) ;  hlist_del_init ( & ucounts -> node ) ;  spin_unlock_irqrestore ( & ucounts_lock , flags ) ; kfree ( ucounts ) ; }  } ","spin_lock_irqsave ( & ucounts_lock , flags ) ;ucounts -> count -= 1 ;if ( ! ucounts -> count ) hlist_del_init ( & ucounts -> node ) ;else ucounts = NULL ;spin_unlock_irqrestore ( & ucounts_lock , flags ) ;",2445
400,"buggy line: data = img -> img_data ;if ( img -> fmt & VPX_IMG_FMT_HAS_ALPHA ) {img -> planes [ VPX_PLANE_ALPHA ] =  data + x + y * img -> stride [ VPX_PLANE_ALPHA ] ;data += img -> h * img -> stride [ VPX_PLANE_ALPHA ] ;img -> planes [ VPX_PLANE_Y ] = data + x + y * img -> stride [ VPX_PLANE_Y ] ;data += img -> h * img -> stride [ VPX_PLANE_Y ] ;img -> planes [ VPX_PLANE_U ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;img -> planes [ VPX_PLANE_V ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;}img -> planes [ VPX_PLANE_V ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;img -> planes [ VPX_PLANE_U ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;}cwe id:CWE-119context: int vpx_img_set_rect ( vpx_image_t * img , unsigned int x , unsigned int y , unsigned int w , unsigned int h ) { unsigned char * data ; if ( x + w <= img -> w && y + h <= img -> h ) { img -> d_w = w ; img -> d_h = h ; if ( ! ( img -> fmt & VPX_IMG_FMT_PLANAR ) ) { img -> planes [ VPX_PLANE_PACKED ] = img -> img_data + x * img -> bps / 8 + y * img -> stride [ VPX_PLANE_PACKED ] ; } else {  data = img -> img_data ;  if ( img -> fmt & VPX_IMG_FMT_HAS_ALPHA ) { img -> planes [ VPX_PLANE_ALPHA ] =  data + x + y * img -> stride [ VPX_PLANE_ALPHA ] ;  data += img -> h * img -> stride [ VPX_PLANE_ALPHA ] ; }  img -> planes [ VPX_PLANE_Y ] = data + x + y * img -> stride [ VPX_PLANE_Y ] ;  data += img -> h * img -> stride [ VPX_PLANE_Y ] ; if ( ! ( img -> fmt & VPX_IMG_FMT_UV_FLIP ) ) {  img -> planes [ VPX_PLANE_U ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;  data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;  img -> planes [ VPX_PLANE_V ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;  } else {  img -> planes [ VPX_PLANE_V ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;  data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;  img -> planes [ VPX_PLANE_U ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;  } } return 0 ; } return - 1 ; }",const int bytes_per_sample = ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ;data = img -> img_data ;if ( img -> fmt & VPX_IMG_FMT_HAS_ALPHA ) {img -> planes [ VPX_PLANE_ALPHA ] = data + x * bytes_per_sample + y * img -> stride [ VPX_PLANE_ALPHA ] ;data += img -> h * img -> stride [ VPX_PLANE_ALPHA ] ;img -> planes [ VPX_PLANE_Y ] = data + x + y * img -> stride [ VPX_PLANE_Y ] ;data += img -> h * img -> stride [ VPX_PLANE_Y ] ;img -> planes [ VPX_PLANE_U ] = data + ( x >> img -> x_chroma_shift ) * bytes_per_sample + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;img -> planes [ VPX_PLANE_V ] = data + ( x >> img -> x_chroma_shift ) * bytes_per_sample + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;}img -> planes [ VPX_PLANE_V ] = data + ( x >> img -> x_chroma_shift ) * bytes_per_sample + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;img -> planes [ VPX_PLANE_U ] = data + ( x >> img -> x_chroma_shift ) * bytes_per_sample + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;},2446
401,"buggy line: JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\\result = realloc ( ptr , size ) ;cwe id:CWE-190context: void * jas_realloc ( void * ptr , size_t size ) { void * result ;  JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n"" , ptr , size ) ) ;  result = realloc ( ptr , size ) ; JAS_DBGLOG ( 100 , ( ""jas_realloc(%p,<S2SV_blank>%zu)<S2SV_blank>-><S2SV_blank>%p\\n"" , ptr , size , result ) ) ; return result ; }","JAS_DBGLOG ( 101 , ( ""jas_realloc(%x,<S2SV_blank>%zu)\\\result = realloc ( ptr , size ) ;",2447
402,"buggy line: passert ( GLOBALS_ARE_RESET ( ) ) ;}cwe id:CWE-20context: static void ikev2_parent_inR1outI2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inR1outI2:<S2SV_blank>calculating<S2SV_blank>g^{xy},<S2SV_blank>sending<S2SV_blank>I2"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inR1outI2_tail ( pcrc , r ) ; if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ;  passert ( GLOBALS_ARE_RESET ( ) ) ;  }",},2448
403,"buggy line: vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cm -> fc . mvc , flag ) ;cwe id:CWE-119context: void vp8_first_pass ( VP8_COMP * cpi ) { int mb_row , mb_col ; MACROBLOCK * const x = & cpi -> mb ; VP8_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; int recon_yoffset , recon_uvoffset ; YV12_BUFFER_CONFIG * lst_yv12 = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; YV12_BUFFER_CONFIG * new_yv12 = & cm -> yv12_fb [ cm -> new_fb_idx ] ; YV12_BUFFER_CONFIG * gld_yv12 = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; int recon_y_stride = lst_yv12 -> y_stride ; int recon_uv_stride = lst_yv12 -> uv_stride ; int64_t intra_error = 0 ; int64_t coded_error = 0 ; int sum_mvr = 0 , sum_mvc = 0 ; int sum_mvr_abs = 0 , sum_mvc_abs = 0 ; int sum_mvrs = 0 , sum_mvcs = 0 ; int mvcount = 0 ; int intercount = 0 ; int second_ref_count = 0 ; int intrapenalty = 256 ; int neutral_count = 0 ; int new_mv_count = 0 ; int sum_in_vectors = 0 ; uint32_t lastmv_as_int = 0 ; int_mv zero_ref_mv ; zero_ref_mv . as_int = 0 ; vp8_clear_system_state ( ) ; x -> src = * cpi -> Source ; xd -> pre = * lst_yv12 ; xd -> dst = * new_yv12 ; x -> partition_info = x -> pi ; xd -> mode_info_context = cm -> mi ; if ( ! cm -> use_bilinear_mc_filter ) { xd -> subpixel_predict = vp8_sixtap_predict4x4 ; xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; } else { xd -> subpixel_predict = vp8_bilinear_predict4x4 ; xd -> subpixel_predict8x4 = vp8_bilinear_predict8x4 ; xd -> subpixel_predict8x8 = vp8_bilinear_predict8x8 ; xd -> subpixel_predict16x16 = vp8_bilinear_predict16x16 ; } vp8_build_block_offsets ( x ) ; vp8_setup_intra_recon ( new_yv12 ) ; vp8cx_frame_init_quantizer ( cpi ) ; { int flag [ 2 ] = { 1 , 1 } ; vp8_initialize_rd_consts ( cpi , x , vp8_dc_quant ( cm -> base_qindex , cm -> y1dc_delta_q ) ) ;  vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;  vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cm -> fc . mvc , flag ) ; } for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { int_mv best_ref_mv ; best_ref_mv . as_int = 0 ; xd -> up_available = ( mb_row != 0 ) ; recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; recon_uvoffset = ( mb_row * recon_uv_stride * 8 ) ; x -> mv_row_min = - ( ( mb_row * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { int this_error ; int gf_motion_error = INT_MAX ; int use_dc_pred = ( mb_col || mb_row ) && ( ! mb_col || ! mb_row ) ; xd -> dst . y_buffer = new_yv12 -> y_buffer + recon_yoffset ; xd -> dst . u_buffer = new_yv12 -> u_buffer + recon_uvoffset ; xd -> dst . v_buffer = new_yv12 -> v_buffer + recon_uvoffset ; xd -> left_available = ( mb_col != 0 ) ; vp8_copy_mem16x16 ( x -> src . y_buffer , x -> src . y_stride , x -> thismb , 16 ) ; this_error = vp8_encode_intra ( cpi , x , use_dc_pred ) ; this_error += intrapenalty ; intra_error += ( int64_t ) this_error ; x -> mv_col_min = - ( ( mb_col * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; if ( cm -> current_video_frame > 0 ) { BLOCKD * d = & x -> e_mbd . block [ 0 ] ; MV tmp_mv = { 0 , 0 } ; int tmp_err ; int motion_error = INT_MAX ; int raw_motion_error = INT_MAX ; zz_motion_search ( cpi , x , cpi -> last_frame_unscaled_source , & raw_motion_error , lst_yv12 , & motion_error , recon_yoffset ) ; d -> bmi . mv . as_mv . row = 0 ; d -> bmi . mv . as_mv . col = 0 ; if ( raw_motion_error < cpi -> oxcf . encode_breakout ) goto skip_motion_search ; first_pass_motion_search ( cpi , x , & best_ref_mv , & d -> bmi . mv . as_mv , lst_yv12 , & motion_error , recon_yoffset ) ; if ( best_ref_mv . as_int ) { tmp_err = INT_MAX ; first_pass_motion_search ( cpi , x , & zero_ref_mv , & tmp_mv , lst_yv12 , & tmp_err , recon_yoffset ) ; if ( tmp_err < motion_error ) { motion_error = tmp_err ; d -> bmi . mv . as_mv . row = tmp_mv . row ; d -> bmi . mv . as_mv . col = tmp_mv . col ; } } if ( cm -> current_video_frame > 1 ) { first_pass_motion_search ( cpi , x , & zero_ref_mv , & tmp_mv , gld_yv12 , & gf_motion_error , recon_yoffset ) ; if ( ( gf_motion_error < motion_error ) && ( gf_motion_error < this_error ) ) { second_ref_count ++ ; } xd -> pre . y_buffer = lst_yv12 -> y_buffer + recon_yoffset ; xd -> pre . u_buffer = lst_yv12 -> u_buffer + recon_uvoffset ; xd -> pre . v_buffer = lst_yv12 -> v_buffer + recon_uvoffset ; } skip_motion_search : best_ref_mv . as_int = 0 ; if ( motion_error <= this_error ) { if ( ( ( ( this_error - intrapenalty ) * 9 ) <= ( motion_error * 10 ) ) && ( this_error < ( 2 * intrapenalty ) ) ) { neutral_count ++ ; } d -> bmi . mv . as_mv . row *= 8 ; d -> bmi . mv . as_mv . col *= 8 ; this_error = motion_error ; vp8_set_mbmode_and_mvs ( x , NEWMV , & d -> bmi . mv ) ; vp8_encode_inter16x16y ( x ) ; sum_mvr += d -> bmi . mv . as_mv . row ; sum_mvr_abs += abs ( d -> bmi . mv . as_mv . row ) ; sum_mvc += d -> bmi . mv . as_mv . col ; sum_mvc_abs += abs ( d -> bmi . mv . as_mv . col ) ; sum_mvrs += d -> bmi . mv . as_mv . row * d -> bmi . mv . as_mv . row ; sum_mvcs += d -> bmi . mv . as_mv . col * d -> bmi . mv . as_mv . col ; intercount ++ ; best_ref_mv . as_int = d -> bmi . mv . as_int ; if ( d -> bmi . mv . as_int ) { mvcount ++ ; if ( d -> bmi . mv . as_int != lastmv_as_int ) new_mv_count ++ ; lastmv_as_int = d -> bmi . mv . as_int ; if ( mb_row < cm -> mb_rows / 2 ) { if ( d -> bmi . mv . as_mv . row > 0 ) sum_in_vectors -- ; else if ( d -> bmi . mv . as_mv . row < 0 ) sum_in_vectors ++ ; } else if ( mb_row > cm -> mb_rows / 2 ) { if ( d -> bmi . mv . as_mv . row > 0 ) sum_in_vectors ++ ; else if ( d -> bmi . mv . as_mv . row < 0 ) sum_in_vectors -- ; } if ( mb_col < cm -> mb_cols / 2 ) { if ( d -> bmi . mv . as_mv . col > 0 ) sum_in_vectors -- ; else if ( d -> bmi . mv . as_mv . col < 0 ) sum_in_vectors ++ ; } else if ( mb_col > cm -> mb_cols / 2 ) { if ( d -> bmi . mv . as_mv . col > 0 ) sum_in_vectors ++ ; else if ( d -> bmi . mv . as_mv . col < 0 ) sum_in_vectors -- ; } } } } coded_error += ( int64_t ) this_error ; x -> src . y_buffer += 16 ; x -> src . u_buffer += 8 ; x -> src . v_buffer += 8 ; recon_yoffset += 16 ; recon_uvoffset += 8 ; } x -> src . y_buffer += 16 * x -> src . y_stride - 16 * cm -> mb_cols ; x -> src . u_buffer += 8 * x -> src . uv_stride - 8 * cm -> mb_cols ; x -> src . v_buffer += 8 * x -> src . uv_stride - 8 * cm -> mb_cols ; vp8_extend_mb_row ( new_yv12 , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; vp8_clear_system_state ( ) ; } vp8_clear_system_state ( ) ; { double weight = 0.0 ; FIRSTPASS_STATS fps ; fps . frame = cm -> current_video_frame ; fps . intra_error = ( double ) ( intra_error >> 8 ) ; fps . coded_error = ( double ) ( coded_error >> 8 ) ; weight = simple_weight ( cpi -> Source ) ; if ( weight < 0.1 ) weight = 0.1 ; fps . ssim_weighted_pred_err = fps . coded_error * weight ; fps . pcnt_inter = 0.0 ; fps . pcnt_motion = 0.0 ; fps . MVr = 0.0 ; fps . mvr_abs = 0.0 ; fps . MVc = 0.0 ; fps . mvc_abs = 0.0 ; fps . MVrv = 0.0 ; fps . MVcv = 0.0 ; fps . mv_in_out_count = 0.0 ; fps . new_mv_count = 0.0 ; fps . count = 1.0 ; fps . pcnt_inter = 1.0 * ( double ) intercount / cm -> MBs ; fps . pcnt_second_ref = 1.0 * ( double ) second_ref_count / cm -> MBs ; fps . pcnt_neutral = 1.0 * ( double ) neutral_count / cm -> MBs ; if ( mvcount > 0 ) { fps . MVr = ( double ) sum_mvr / ( double ) mvcount ; fps . mvr_abs = ( double ) sum_mvr_abs / ( double ) mvcount ; fps . MVc = ( double ) sum_mvc / ( double ) mvcount ; fps . mvc_abs = ( double ) sum_mvc_abs / ( double ) mvcount ; fps . MVrv = ( ( double ) sum_mvrs - ( fps . MVr * fps . MVr / ( double ) mvcount ) ) / ( double ) mvcount ; fps . MVcv = ( ( double ) sum_mvcs - ( fps . MVc * fps . MVc / ( double ) mvcount ) ) / ( double ) mvcount ; fps . mv_in_out_count = ( double ) sum_in_vectors / ( double ) ( mvcount * 2 ) ; fps . new_mv_count = new_mv_count ; fps . pcnt_motion = 1.0 * ( double ) mvcount / cpi -> common . MBs ; } fps . duration = ( double ) ( cpi -> source -> ts_end - cpi -> source -> ts_start ) ; memcpy ( & cpi -> twopass . this_frame_stats , & fps , sizeof ( FIRSTPASS_STATS ) ) ; output_stats ( cpi , cpi -> output_pkt_list , & cpi -> twopass . this_frame_stats ) ; accumulate_stats ( & cpi -> twopass . total_stats , & fps ) ; } if ( ( cm -> current_video_frame > 0 ) && ( cpi -> twopass . this_frame_stats . pcnt_inter > 0.20 ) && ( ( cpi -> twopass . this_frame_stats . intra_error / DOUBLE_DIVIDE_CHECK ( cpi -> twopass . this_frame_stats . coded_error ) ) > 2.0 ) ) { vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; } vp8_swap_yv12_buffer ( lst_yv12 , new_yv12 ) ; vp8_yv12_extend_frame_borders ( lst_yv12 ) ; if ( cm -> current_video_frame == 0 ) { vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; } if ( 0 ) { char filename [ 512 ] ; FILE * recon_file ; sprintf ( filename , ""enc%04d.yuv"" , ( int ) cm -> current_video_frame ) ; if ( cm -> current_video_frame == 0 ) recon_file = fopen ( filename , ""wb"" ) ; else recon_file = fopen ( filename , ""ab"" ) ; ( void ) fwrite ( lst_yv12 -> buffer_alloc , lst_yv12 -> frame_size , 1 , recon_file ) ; fclose ( recon_file ) ; } cm -> current_video_frame ++ ; }","memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cm -> fc . mvc , flag ) ;",2449
404,"buggy line: cwe id:CWE-125context: int modbus_reply ( modbus_t * ctx , const uint8_t * req , int req_length , modbus_mapping_t * mb_mapping ) { int offset ; int slave ; int function ; uint16_t address ; uint8_t rsp [ MAX_MESSAGE_LENGTH ] ; int rsp_length = 0 ; sft_t sft ; if ( ctx == NULL ) { errno = EINVAL ; return - 1 ; } offset = ctx -> backend -> header_length ; slave = req [ offset - 1 ] ; function = req [ offset ] ; address = ( req [ offset + 1 ] << 8 ) + req [ offset + 2 ] ; sft . slave = slave ; sft . function = function ; sft . t_id = ctx -> backend -> prepare_response_tid ( req , & req_length ) ; switch ( function ) { case MODBUS_FC_READ_COILS : case MODBUS_FC_READ_DISCRETE_INPUTS : { unsigned int is_input = ( function == MODBUS_FC_READ_DISCRETE_INPUTS ) ; int start_bits = is_input ? mb_mapping -> start_input_bits : mb_mapping -> start_bits ; int nb_bits = is_input ? mb_mapping -> nb_input_bits : mb_mapping -> nb_bits ; uint8_t * tab_bits = is_input ? mb_mapping -> tab_input_bits : mb_mapping -> tab_bits ; const char * const name = is_input ? ""read_input_bits"" : ""read_bits"" ; int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; int mapping_address = address - start_bits ; if ( nb < 1 || MODBUS_MAX_READ_BITS < nb ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , name , MODBUS_MAX_READ_BITS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n"" , mapping_address < 0 ? address : address + nb , name ) ; } else { rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = ( nb / 8 ) + ( ( nb % 8 ) ? 1 : 0 ) ; rsp_length = response_io_status ( tab_bits , mapping_address , nb , rsp , rsp_length ) ; } } break ; case MODBUS_FC_READ_HOLDING_REGISTERS : case MODBUS_FC_READ_INPUT_REGISTERS : { unsigned int is_input = ( function == MODBUS_FC_READ_INPUT_REGISTERS ) ; int start_registers = is_input ? mb_mapping -> start_input_registers : mb_mapping -> start_registers ; int nb_registers = is_input ? mb_mapping -> nb_input_registers : mb_mapping -> nb_registers ; uint16_t * tab_registers = is_input ? mb_mapping -> tab_input_registers : mb_mapping -> tab_registers ; const char * const name = is_input ? ""read_input_registers"" : ""read_registers"" ; int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; int mapping_address = address - start_registers ; if ( nb < 1 || MODBUS_MAX_READ_REGISTERS < nb ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , name , MODBUS_MAX_READ_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n"" , mapping_address < 0 ? address : address + nb , name ) ; } else { int i ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = nb << 1 ; for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { rsp [ rsp_length ++ ] = tab_registers [ i ] >> 8 ; rsp [ rsp_length ++ ] = tab_registers [ i ] & 0xFF ; } } } break ; case MODBUS_FC_WRITE_SINGLE_COIL : { int mapping_address = address - mb_mapping -> start_bits ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit\\n"" , address ) ; } else { int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; if ( data == 0xFF00 || data == 0x0 ) { mb_mapping -> tab_bits [ mapping_address ] = data ? ON : OFF ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } else { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>value<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit<S2SV_blank>request<S2SV_blank>at<S2SV_blank>address<S2SV_blank>%0X\\n"" , data , address ) ; } } } break ; case MODBUS_FC_WRITE_SINGLE_REGISTER : { int mapping_address = address - mb_mapping -> start_registers ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n"" , address ) ; } else { int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; mb_mapping -> tab_registers [ mapping_address ] = data ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } } break ; case MODBUS_FC_WRITE_MULTIPLE_COILS : { int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;  int mapping_address = address - mb_mapping -> start_bits ;   if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) {  rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , MODBUS_MAX_WRITE_BITS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bits\\n"" , mapping_address < 0 ? address : address + nb ) ; } else { modbus_set_bits_from_bytes ( mb_mapping -> tab_bits , mapping_address , nb , & req [ offset + 6 ] ) ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; rsp_length += 4 ; } } break ; case MODBUS_FC_WRITE_MULTIPLE_REGISTERS : {  int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;  int mapping_address = address - mb_mapping -> start_registers ;  if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) {  rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , MODBUS_MAX_WRITE_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_registers\\n"" , mapping_address < 0 ? address : address + nb ) ; } else { int i , j ; for ( i = mapping_address , j = 6 ; i < mapping_address + nb ; i ++ , j += 2 ) { mb_mapping -> tab_registers [ i ] = ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; } rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; rsp_length += 4 ; } } break ; case MODBUS_FC_REPORT_SLAVE_ID : { int str_len ; int byte_count_pos ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; byte_count_pos = rsp_length ++ ; rsp [ rsp_length ++ ] = _REPORT_SLAVE_ID ; rsp [ rsp_length ++ ] = 0xFF ; str_len = 3 + strlen ( LIBMODBUS_VERSION_STRING ) ; memcpy ( rsp + rsp_length , ""LMB"" LIBMODBUS_VERSION_STRING , str_len ) ; rsp_length += str_len ; rsp [ byte_count_pos ] = rsp_length - byte_count_pos - 1 ; } break ; case MODBUS_FC_READ_EXCEPTION_STATUS : if ( ctx -> debug ) { fprintf ( stderr , ""FIXME<S2SV_blank>Not<S2SV_blank>implemented\\n"" ) ; } errno = ENOPROTOOPT ; return - 1 ; break ; case MODBUS_FC_MASK_WRITE_REGISTER : { int mapping_address = address - mb_mapping -> start_registers ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n"" , address ) ; } else { uint16_t data = mb_mapping -> tab_registers [ mapping_address ] ; uint16_t and = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; uint16_t or = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; data = ( data & and ) | ( or & ( ~ and ) ) ; mb_mapping -> tab_registers [ mapping_address ] = data ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } } break ; case MODBUS_FC_WRITE_AND_READ_REGISTERS : { int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; uint16_t address_write = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; int nb_write = ( req [ offset + 7 ] << 8 ) + req [ offset + 8 ] ; int nb_write_bytes = req [ offset + 9 ] ; int mapping_address = address - mb_mapping -> start_registers ; int mapping_address_write = address_write - mb_mapping -> start_registers ; if ( nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write || nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb || nb_write_bytes != nb_write * 2 ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>(W%d,<S2SV_blank>R%d)<S2SV_blank>in<S2SV_blank>write_and_read_registers<S2SV_blank>(max<S2SV_blank>W%d,<S2SV_blank>R%d)\\n"" , nb_write , nb , MODBUS_MAX_WR_WRITE_REGISTERS , MODBUS_MAX_WR_READ_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_registers || mapping_address < 0 || ( mapping_address_write + nb_write ) > mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>read<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>or<S2SV_blank>write<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>write_and_read_registers\\n"" , mapping_address < 0 ? address : address + nb , mapping_address_write < 0 ? address_write : address_write + nb_write ) ; } else { int i , j ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = nb << 1 ; for ( i = mapping_address_write , j = 10 ; i < mapping_address_write + nb_write ; i ++ , j += 2 ) { mb_mapping -> tab_registers [ i ] = ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; } for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] >> 8 ; rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] & 0xFF ; } } } break ; default : rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_FUNCTION , rsp , TRUE , ""Unknown<S2SV_blank>Modbus<S2SV_blank>function<S2SV_blank>code:<S2SV_blank>0x%0X\\n"" , function ) ; break ; } return ( ctx -> backend -> backend_type == _MODBUS_BACKEND_TYPE_RTU && slave == MODBUS_BROADCAST_ADDRESS ) ? 0 : send_msg ( ctx , rsp , rsp_length ) ; }",int nb_bits = req [ offset + 5 ] ;,2450
405,"buggy line: int mapping_address = address - mb_mapping -> start_bits ;if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\\cwe id:CWE-125context: int modbus_reply ( modbus_t * ctx , const uint8_t * req , int req_length , modbus_mapping_t * mb_mapping ) { int offset ; int slave ; int function ; uint16_t address ; uint8_t rsp [ MAX_MESSAGE_LENGTH ] ; int rsp_length = 0 ; sft_t sft ; if ( ctx == NULL ) { errno = EINVAL ; return - 1 ; } offset = ctx -> backend -> header_length ; slave = req [ offset - 1 ] ; function = req [ offset ] ; address = ( req [ offset + 1 ] << 8 ) + req [ offset + 2 ] ; sft . slave = slave ; sft . function = function ; sft . t_id = ctx -> backend -> prepare_response_tid ( req , & req_length ) ; switch ( function ) { case MODBUS_FC_READ_COILS : case MODBUS_FC_READ_DISCRETE_INPUTS : { unsigned int is_input = ( function == MODBUS_FC_READ_DISCRETE_INPUTS ) ; int start_bits = is_input ? mb_mapping -> start_input_bits : mb_mapping -> start_bits ; int nb_bits = is_input ? mb_mapping -> nb_input_bits : mb_mapping -> nb_bits ; uint8_t * tab_bits = is_input ? mb_mapping -> tab_input_bits : mb_mapping -> tab_bits ; const char * const name = is_input ? ""read_input_bits"" : ""read_bits"" ; int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; int mapping_address = address - start_bits ; if ( nb < 1 || MODBUS_MAX_READ_BITS < nb ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , name , MODBUS_MAX_READ_BITS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n"" , mapping_address < 0 ? address : address + nb , name ) ; } else { rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = ( nb / 8 ) + ( ( nb % 8 ) ? 1 : 0 ) ; rsp_length = response_io_status ( tab_bits , mapping_address , nb , rsp , rsp_length ) ; } } break ; case MODBUS_FC_READ_HOLDING_REGISTERS : case MODBUS_FC_READ_INPUT_REGISTERS : { unsigned int is_input = ( function == MODBUS_FC_READ_INPUT_REGISTERS ) ; int start_registers = is_input ? mb_mapping -> start_input_registers : mb_mapping -> start_registers ; int nb_registers = is_input ? mb_mapping -> nb_input_registers : mb_mapping -> nb_registers ; uint16_t * tab_registers = is_input ? mb_mapping -> tab_input_registers : mb_mapping -> tab_registers ; const char * const name = is_input ? ""read_input_registers"" : ""read_registers"" ; int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; int mapping_address = address - start_registers ; if ( nb < 1 || MODBUS_MAX_READ_REGISTERS < nb ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , name , MODBUS_MAX_READ_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n"" , mapping_address < 0 ? address : address + nb , name ) ; } else { int i ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = nb << 1 ; for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { rsp [ rsp_length ++ ] = tab_registers [ i ] >> 8 ; rsp [ rsp_length ++ ] = tab_registers [ i ] & 0xFF ; } } } break ; case MODBUS_FC_WRITE_SINGLE_COIL : { int mapping_address = address - mb_mapping -> start_bits ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit\\n"" , address ) ; } else { int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; if ( data == 0xFF00 || data == 0x0 ) { mb_mapping -> tab_bits [ mapping_address ] = data ? ON : OFF ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } else { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>value<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit<S2SV_blank>request<S2SV_blank>at<S2SV_blank>address<S2SV_blank>%0X\\n"" , data , address ) ; } } } break ; case MODBUS_FC_WRITE_SINGLE_REGISTER : { int mapping_address = address - mb_mapping -> start_registers ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n"" , address ) ; } else { int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; mb_mapping -> tab_registers [ mapping_address ] = data ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } } break ; case MODBUS_FC_WRITE_MULTIPLE_COILS : { int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;  int mapping_address = address - mb_mapping -> start_bits ;   if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) {  rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , MODBUS_MAX_WRITE_BITS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bits\\n"" , mapping_address < 0 ? address : address + nb ) ; } else { modbus_set_bits_from_bytes ( mb_mapping -> tab_bits , mapping_address , nb , & req [ offset + 6 ] ) ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; rsp_length += 4 ; } } break ; case MODBUS_FC_WRITE_MULTIPLE_REGISTERS : {  int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;  int mapping_address = address - mb_mapping -> start_registers ;  if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) {  rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , MODBUS_MAX_WRITE_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_registers\\n"" , mapping_address < 0 ? address : address + nb ) ; } else { int i , j ; for ( i = mapping_address , j = 6 ; i < mapping_address + nb ; i ++ , j += 2 ) { mb_mapping -> tab_registers [ i ] = ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; } rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; rsp_length += 4 ; } } break ; case MODBUS_FC_REPORT_SLAVE_ID : { int str_len ; int byte_count_pos ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; byte_count_pos = rsp_length ++ ; rsp [ rsp_length ++ ] = _REPORT_SLAVE_ID ; rsp [ rsp_length ++ ] = 0xFF ; str_len = 3 + strlen ( LIBMODBUS_VERSION_STRING ) ; memcpy ( rsp + rsp_length , ""LMB"" LIBMODBUS_VERSION_STRING , str_len ) ; rsp_length += str_len ; rsp [ byte_count_pos ] = rsp_length - byte_count_pos - 1 ; } break ; case MODBUS_FC_READ_EXCEPTION_STATUS : if ( ctx -> debug ) { fprintf ( stderr , ""FIXME<S2SV_blank>Not<S2SV_blank>implemented\\n"" ) ; } errno = ENOPROTOOPT ; return - 1 ; break ; case MODBUS_FC_MASK_WRITE_REGISTER : { int mapping_address = address - mb_mapping -> start_registers ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n"" , address ) ; } else { uint16_t data = mb_mapping -> tab_registers [ mapping_address ] ; uint16_t and = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; uint16_t or = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; data = ( data & and ) | ( or & ( ~ and ) ) ; mb_mapping -> tab_registers [ mapping_address ] = data ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } } break ; case MODBUS_FC_WRITE_AND_READ_REGISTERS : { int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; uint16_t address_write = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; int nb_write = ( req [ offset + 7 ] << 8 ) + req [ offset + 8 ] ; int nb_write_bytes = req [ offset + 9 ] ; int mapping_address = address - mb_mapping -> start_registers ; int mapping_address_write = address_write - mb_mapping -> start_registers ; if ( nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write || nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb || nb_write_bytes != nb_write * 2 ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>(W%d,<S2SV_blank>R%d)<S2SV_blank>in<S2SV_blank>write_and_read_registers<S2SV_blank>(max<S2SV_blank>W%d,<S2SV_blank>R%d)\\n"" , nb_write , nb , MODBUS_MAX_WR_WRITE_REGISTERS , MODBUS_MAX_WR_READ_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_registers || mapping_address < 0 || ( mapping_address_write + nb_write ) > mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>read<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>or<S2SV_blank>write<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>write_and_read_registers\\n"" , mapping_address < 0 ? address : address + nb , mapping_address_write < 0 ? address_write : address_write + nb_write ) ; } else { int i , j ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = nb << 1 ; for ( i = mapping_address_write , j = 10 ; i < mapping_address_write + nb_write ; i ++ , j += 2 ) { mb_mapping -> tab_registers [ i ] = ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; } for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] >> 8 ; rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] & 0xFF ; } } } break ; default : rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_FUNCTION , rsp , TRUE , ""Unknown<S2SV_blank>Modbus<S2SV_blank>function<S2SV_blank>code:<S2SV_blank>0x%0X\\n"" , function ) ; break ; } return ( ctx -> backend -> backend_type == _MODBUS_BACKEND_TYPE_RTU && slave == MODBUS_BROADCAST_ADDRESS ) ? 0 : send_msg ( ctx , rsp , rsp_length ) ; }","int mapping_address = address - mb_mapping -> start_bits ;if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\\",2450
406,"buggy line: int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;int mapping_address = address - mb_mapping -> start_registers ;if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\\cwe id:CWE-125context: int modbus_reply ( modbus_t * ctx , const uint8_t * req , int req_length , modbus_mapping_t * mb_mapping ) { int offset ; int slave ; int function ; uint16_t address ; uint8_t rsp [ MAX_MESSAGE_LENGTH ] ; int rsp_length = 0 ; sft_t sft ; if ( ctx == NULL ) { errno = EINVAL ; return - 1 ; } offset = ctx -> backend -> header_length ; slave = req [ offset - 1 ] ; function = req [ offset ] ; address = ( req [ offset + 1 ] << 8 ) + req [ offset + 2 ] ; sft . slave = slave ; sft . function = function ; sft . t_id = ctx -> backend -> prepare_response_tid ( req , & req_length ) ; switch ( function ) { case MODBUS_FC_READ_COILS : case MODBUS_FC_READ_DISCRETE_INPUTS : { unsigned int is_input = ( function == MODBUS_FC_READ_DISCRETE_INPUTS ) ; int start_bits = is_input ? mb_mapping -> start_input_bits : mb_mapping -> start_bits ; int nb_bits = is_input ? mb_mapping -> nb_input_bits : mb_mapping -> nb_bits ; uint8_t * tab_bits = is_input ? mb_mapping -> tab_input_bits : mb_mapping -> tab_bits ; const char * const name = is_input ? ""read_input_bits"" : ""read_bits"" ; int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; int mapping_address = address - start_bits ; if ( nb < 1 || MODBUS_MAX_READ_BITS < nb ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , name , MODBUS_MAX_READ_BITS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n"" , mapping_address < 0 ? address : address + nb , name ) ; } else { rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = ( nb / 8 ) + ( ( nb % 8 ) ? 1 : 0 ) ; rsp_length = response_io_status ( tab_bits , mapping_address , nb , rsp , rsp_length ) ; } } break ; case MODBUS_FC_READ_HOLDING_REGISTERS : case MODBUS_FC_READ_INPUT_REGISTERS : { unsigned int is_input = ( function == MODBUS_FC_READ_INPUT_REGISTERS ) ; int start_registers = is_input ? mb_mapping -> start_input_registers : mb_mapping -> start_registers ; int nb_registers = is_input ? mb_mapping -> nb_input_registers : mb_mapping -> nb_registers ; uint16_t * tab_registers = is_input ? mb_mapping -> tab_input_registers : mb_mapping -> tab_registers ; const char * const name = is_input ? ""read_input_registers"" : ""read_registers"" ; int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; int mapping_address = address - start_registers ; if ( nb < 1 || MODBUS_MAX_READ_REGISTERS < nb ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , name , MODBUS_MAX_READ_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n"" , mapping_address < 0 ? address : address + nb , name ) ; } else { int i ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = nb << 1 ; for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { rsp [ rsp_length ++ ] = tab_registers [ i ] >> 8 ; rsp [ rsp_length ++ ] = tab_registers [ i ] & 0xFF ; } } } break ; case MODBUS_FC_WRITE_SINGLE_COIL : { int mapping_address = address - mb_mapping -> start_bits ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit\\n"" , address ) ; } else { int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; if ( data == 0xFF00 || data == 0x0 ) { mb_mapping -> tab_bits [ mapping_address ] = data ? ON : OFF ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } else { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>value<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit<S2SV_blank>request<S2SV_blank>at<S2SV_blank>address<S2SV_blank>%0X\\n"" , data , address ) ; } } } break ; case MODBUS_FC_WRITE_SINGLE_REGISTER : { int mapping_address = address - mb_mapping -> start_registers ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n"" , address ) ; } else { int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; mb_mapping -> tab_registers [ mapping_address ] = data ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } } break ; case MODBUS_FC_WRITE_MULTIPLE_COILS : { int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;  int mapping_address = address - mb_mapping -> start_bits ;   if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) {  rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , MODBUS_MAX_WRITE_BITS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bits\\n"" , mapping_address < 0 ? address : address + nb ) ; } else { modbus_set_bits_from_bytes ( mb_mapping -> tab_bits , mapping_address , nb , & req [ offset + 6 ] ) ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; rsp_length += 4 ; } } break ; case MODBUS_FC_WRITE_MULTIPLE_REGISTERS : {  int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;  int mapping_address = address - mb_mapping -> start_registers ;  if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) {  rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\n"" , nb , MODBUS_MAX_WRITE_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_registers\\n"" , mapping_address < 0 ? address : address + nb ) ; } else { int i , j ; for ( i = mapping_address , j = 6 ; i < mapping_address + nb ; i ++ , j += 2 ) { mb_mapping -> tab_registers [ i ] = ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; } rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; rsp_length += 4 ; } } break ; case MODBUS_FC_REPORT_SLAVE_ID : { int str_len ; int byte_count_pos ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; byte_count_pos = rsp_length ++ ; rsp [ rsp_length ++ ] = _REPORT_SLAVE_ID ; rsp [ rsp_length ++ ] = 0xFF ; str_len = 3 + strlen ( LIBMODBUS_VERSION_STRING ) ; memcpy ( rsp + rsp_length , ""LMB"" LIBMODBUS_VERSION_STRING , str_len ) ; rsp_length += str_len ; rsp [ byte_count_pos ] = rsp_length - byte_count_pos - 1 ; } break ; case MODBUS_FC_READ_EXCEPTION_STATUS : if ( ctx -> debug ) { fprintf ( stderr , ""FIXME<S2SV_blank>Not<S2SV_blank>implemented\\n"" ) ; } errno = ENOPROTOOPT ; return - 1 ; break ; case MODBUS_FC_MASK_WRITE_REGISTER : { int mapping_address = address - mb_mapping -> start_registers ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n"" , address ) ; } else { uint16_t data = mb_mapping -> tab_registers [ mapping_address ] ; uint16_t and = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; uint16_t or = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; data = ( data & and ) | ( or & ( ~ and ) ) ; mb_mapping -> tab_registers [ mapping_address ] = data ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } } break ; case MODBUS_FC_WRITE_AND_READ_REGISTERS : { int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; uint16_t address_write = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; int nb_write = ( req [ offset + 7 ] << 8 ) + req [ offset + 8 ] ; int nb_write_bytes = req [ offset + 9 ] ; int mapping_address = address - mb_mapping -> start_registers ; int mapping_address_write = address_write - mb_mapping -> start_registers ; if ( nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write || nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb || nb_write_bytes != nb_write * 2 ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>(W%d,<S2SV_blank>R%d)<S2SV_blank>in<S2SV_blank>write_and_read_registers<S2SV_blank>(max<S2SV_blank>W%d,<S2SV_blank>R%d)\\n"" , nb_write , nb , MODBUS_MAX_WR_WRITE_REGISTERS , MODBUS_MAX_WR_READ_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_registers || mapping_address < 0 || ( mapping_address_write + nb_write ) > mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , ""Illegal<S2SV_blank>data<S2SV_blank>read<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>or<S2SV_blank>write<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>write_and_read_registers\\n"" , mapping_address < 0 ? address : address + nb , mapping_address_write < 0 ? address_write : address_write + nb_write ) ; } else { int i , j ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = nb << 1 ; for ( i = mapping_address_write , j = 10 ; i < mapping_address_write + nb_write ; i ++ , j += 2 ) { mb_mapping -> tab_registers [ i ] = ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; } for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] >> 8 ; rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] & 0xFF ; } } } break ; default : rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_FUNCTION , rsp , TRUE , ""Unknown<S2SV_blank>Modbus<S2SV_blank>function<S2SV_blank>code:<S2SV_blank>0x%0X\\n"" , function ) ; break ; } return ( ctx -> backend -> backend_type == _MODBUS_BACKEND_TYPE_RTU && slave == MODBUS_BROADCAST_ADDRESS ) ? 0 : send_msg ( ctx , rsp , rsp_length ) ; }","int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;int nb_bytes = req [ offset + 5 ] ;int mapping_address = address - mb_mapping -> start_registers ;if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\\",2450
407,"buggy line: int ret = 0 , found = 0 ;char * repo_config = NULL ;cwe id:CWE-000context: int perf_config ( config_fn_t fn , void * data ) {  int ret = 0 , found = 0 ;  char * repo_config = NULL ; const char * home = NULL ; if ( config_exclusive_filename ) return perf_config_from_file ( fn , config_exclusive_filename , data ) ; if ( perf_config_system ( ) && ! access ( perf_etc_perfconfig ( ) , R_OK ) ) { ret += perf_config_from_file ( fn , perf_etc_perfconfig ( ) , data ) ; found += 1 ; } home = getenv ( ""HOME"" ) ; if ( perf_config_global ( ) && home ) { char * user_config = strdup ( mkpath ( ""%s/.perfconfig"" , home ) ) ; if ( ! access ( user_config , R_OK ) ) { ret += perf_config_from_file ( fn , user_config , data ) ; found += 1 ; } free ( user_config ) ; }  repo_config = perf_pathdup ( ""config"" ) ;  if ( ! access ( repo_config , R_OK ) ) { ret += perf_config_from_file ( fn , repo_config , data ) ; found += 1 ; } free ( repo_config ) ; if ( found == 0 ) return - 1 ; return ret ; }","int ret = 0 , found = 0 ;",2451
408,"buggy line: repo_config = perf_pathdup ( ""config"" ) ;if ( ! access ( repo_config , R_OK ) ) {ret += perf_config_from_file ( fn , repo_config , data ) ;found += 1 ;}free ( repo_config ) ;cwe id:CWE-000context: int perf_config ( config_fn_t fn , void * data ) {  int ret = 0 , found = 0 ;  char * repo_config = NULL ; const char * home = NULL ; if ( config_exclusive_filename ) return perf_config_from_file ( fn , config_exclusive_filename , data ) ; if ( perf_config_system ( ) && ! access ( perf_etc_perfconfig ( ) , R_OK ) ) { ret += perf_config_from_file ( fn , perf_etc_perfconfig ( ) , data ) ; found += 1 ; } home = getenv ( ""HOME"" ) ; if ( perf_config_global ( ) && home ) { char * user_config = strdup ( mkpath ( ""%s/.perfconfig"" , home ) ) ; if ( ! access ( user_config , R_OK ) ) { ret += perf_config_from_file ( fn , user_config , data ) ; found += 1 ; } free ( user_config ) ; }  repo_config = perf_pathdup ( ""config"" ) ;  if ( ! access ( repo_config , R_OK ) ) { ret += perf_config_from_file ( fn , repo_config , data ) ; found += 1 ; } free ( repo_config ) ; if ( found == 0 ) return - 1 ; return ret ; }","
",2451
409,"buggy line: static void  horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 4 * stride ) ) == 0 ) ;if ( wc > stride ) {cwe id:CWE-119context:  static void  horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ;  assert ( ( cc % ( 4 * stride ) ) == 0 ) ;  if ( wc > stride ) { wc -= stride ; wp += wc - 1 ; do { REPEAT4 ( stride , wp [ stride ] -= wp [ 0 ] ; wp -- ) wc -= stride ; } while ( wc > 0 ) ; }  } ","static int horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 4 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horDiff32"" , ""%s"" , ""(cc%(4*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",2452
410,"buggy line: }cwe id:CWE-119context:  static void  horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ;  assert ( ( cc % ( 4 * stride ) ) == 0 ) ;  if ( wc > stride ) { wc -= stride ; wp += wc - 1 ; do { REPEAT4 ( stride , wp [ stride ] -= wp [ 0 ] ; wp -- ) wc -= stride ; } while ( wc > 0 ) ; }  } ",return 1 ;},2452
411,"buggy line: bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;cwe id:CWE-119context: int vp8_diamond_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , int * num00 , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { int i , j , step ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * best_address ; int tot_steps ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int best_site = 0 ; int last_site = 0 ; int ref_row ; int ref_col ; int this_row_offset ; int this_col_offset ; search_site * ss ; unsigned char * check_here ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; ref_row = ref_mv -> as_mv . row ; ref_col = ref_mv -> as_mv . col ; * num00 = 0 ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; in_what = ( unsigned char * ) ( base_pre + d -> offset + ( ref_row * pre_stride ) + ref_col ) ; best_address = in_what ;  bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; ss = & x -> ss [ search_param * x -> searches_per_step ] ; tot_steps = ( x -> ss_count / x -> searches_per_step ) - search_param ; i = 1 ; for ( step = 0 ; step < tot_steps ; step ++ ) { for ( j = 0 ; j < x -> searches_per_step ; j ++ ) { this_row_offset = best_mv -> as_mv . row + ss [ i ] . mv . row ; this_col_offset = best_mv -> as_mv . col + ss [ i ] . mv . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ss [ i ] . offset + best_address ;  thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;  if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = i ; } } } i ++ ; } if ( best_site != last_site ) { best_mv -> as_mv . row += ss [ best_site ] . mv . row ; best_mv -> as_mv . col += ss [ best_site ] . mv . col ; best_address += ss [ best_site ] . offset ; last_site = best_site ; } else if ( best_address == in_what ) ( * num00 ) ++ ; } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }","bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",2453
412,"buggy line: thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {cwe id:CWE-119context: int vp8_diamond_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , int * num00 , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { int i , j , step ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * best_address ; int tot_steps ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int best_site = 0 ; int last_site = 0 ; int ref_row ; int ref_col ; int this_row_offset ; int this_col_offset ; search_site * ss ; unsigned char * check_here ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; ref_row = ref_mv -> as_mv . row ; ref_col = ref_mv -> as_mv . col ; * num00 = 0 ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; in_what = ( unsigned char * ) ( base_pre + d -> offset + ( ref_row * pre_stride ) + ref_col ) ; best_address = in_what ;  bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; ss = & x -> ss [ search_param * x -> searches_per_step ] ; tot_steps = ( x -> ss_count / x -> searches_per_step ) - search_param ; i = 1 ; for ( step = 0 ; step < tot_steps ; step ++ ) { for ( j = 0 ; j < x -> searches_per_step ; j ++ ) { this_row_offset = best_mv -> as_mv . row + ss [ i ] . mv . row ; this_col_offset = best_mv -> as_mv . col + ss [ i ] . mv . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ss [ i ] . offset + best_address ;  thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;  if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = i ; } } } i ++ ; } if ( best_site != last_site ) { best_mv -> as_mv . row += ss [ best_site ] . mv . row ; best_mv -> as_mv . col += ss [ best_site ] . mv . col ; best_address += ss [ best_site ] . offset ; last_site = best_site ; } else if ( best_address == in_what ) ( * num00 ) ++ ; } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride ) ;if ( thissad < bestsad ) {",2453
413,"buggy line: if ( A > skb -> len - sizeof ( struct nlattr ) )  return 0 ;if ( nla -> nla_len > A - skb -> len )  return 0 ;cwe id:CWE-125context: static u64 __skb_get_nlattr_nest ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; if ( skb_is_nonlinear ( skb ) ) return 0 ;  if ( A > skb -> len - sizeof ( struct nlattr ) )  return 0 ; nla = ( struct nlattr * ) & skb -> data [ A ] ;  if ( nla -> nla_len > A - skb -> len )  return 0 ; nla = nla_find_nested ( nla , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }",if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ;if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ;if ( nla -> nla_len > skb -> len - A ) return 0 ;,2454
414,"buggy line: total = le32_to_cpu ( raw_super -> segment_count ) ;fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ;cwe id:CWE-129context: int sanity_check_ckpt ( struct f2fs_sb_info * sbi ) { unsigned int total , fsmeta ; struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; unsigned int ovp_segments , reserved_segments ;  total = le32_to_cpu ( raw_super -> segment_count ) ;  fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ; fsmeta += le32_to_cpu ( raw_super -> segment_count_sit ) ; fsmeta += le32_to_cpu ( raw_super -> segment_count_nat ) ; fsmeta += le32_to_cpu ( ckpt -> rsvd_segment_count ) ; fsmeta += le32_to_cpu ( raw_super -> segment_count_ssa ) ; if ( unlikely ( fsmeta >= total ) ) return 1 ; ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; if ( unlikely ( fsmeta < F2FS_MIN_SEGMENTS || ovp_segments == 0 || reserved_segments == 0 ) ) { f2fs_msg ( sbi -> sb , KERN_ERR , ""Wrong<S2SV_blank>layout:<S2SV_blank>check<S2SV_blank>mkfs.f2fs<S2SV_blank>version"" ) ; return 1 ; }  if ( unlikely ( f2fs_cp_error ( sbi ) ) ) {  f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ; return 1 ; } return 0 ; }","unsigned int main_segs , blocks_per_seg ;int i ;total = le32_to_cpu ( raw_super -> segment_count ) ;fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ;",2455
415,"buggy line: if ( unlikely ( f2fs_cp_error ( sbi ) ) ) {f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ;cwe id:CWE-129context: int sanity_check_ckpt ( struct f2fs_sb_info * sbi ) { unsigned int total , fsmeta ; struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; unsigned int ovp_segments , reserved_segments ;  total = le32_to_cpu ( raw_super -> segment_count ) ;  fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ; fsmeta += le32_to_cpu ( raw_super -> segment_count_sit ) ; fsmeta += le32_to_cpu ( raw_super -> segment_count_nat ) ; fsmeta += le32_to_cpu ( ckpt -> rsvd_segment_count ) ; fsmeta += le32_to_cpu ( raw_super -> segment_count_ssa ) ; if ( unlikely ( fsmeta >= total ) ) return 1 ; ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; if ( unlikely ( fsmeta < F2FS_MIN_SEGMENTS || ovp_segments == 0 || reserved_segments == 0 ) ) { f2fs_msg ( sbi -> sb , KERN_ERR , ""Wrong<S2SV_blank>layout:<S2SV_blank>check<S2SV_blank>mkfs.f2fs<S2SV_blank>version"" ) ; return 1 ; }  if ( unlikely ( f2fs_cp_error ( sbi ) ) ) {  f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ; return 1 ; } return 0 ; }","main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ;blocks_per_seg = sbi -> blocks_per_seg ;for ( i = 0 ;i < NR_CURSEG_NODE_TYPE ;i ++ ) {if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ;}for ( i = 0 ;i < NR_CURSEG_DATA_TYPE ;i ++ ) {if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ;}if ( unlikely ( f2fs_cp_error ( sbi ) ) ) {f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ;",2455
416,"buggy line: REQ ( n , suite ) ;total = num_stmts ( n ) ;cwe id:CWE-125context: static asdl_seq * ast_for_suite ( struct compiling * c , const node * n ) { asdl_seq * seq ; stmt_ty s ; int i , total , num , end , pos = 0 ; node * ch ;  REQ ( n , suite ) ;  total = num_stmts ( n ) ; seq = _Py_asdl_seq_new ( total , c -> c_arena ) ; if ( ! seq ) return NULL ; if ( TYPE ( CHILD ( n , 0 ) ) == simple_stmt ) { n = CHILD ( n , 0 ) ; end = NCH ( n ) - 1 ; if ( TYPE ( CHILD ( n , end - 1 ) ) == SEMI ) end -- ; for ( i = 0 ; i < end ; i += 2 ) { ch = CHILD ( n , i ) ; s = ast_for_stmt ( c , ch ) ; if ( ! s ) return NULL ; asdl_seq_SET ( seq , pos ++ , s ) ; } } else {  for ( i = 2 ; i < ( NCH ( n ) - 1 ) ; i ++ ) {  ch = CHILD ( n , i ) ; REQ ( ch , stmt ) ; num = num_stmts ( ch ) ; if ( num == 1 ) { s = ast_for_stmt ( c , ch ) ; if ( ! s ) return NULL ; asdl_seq_SET ( seq , pos ++ , s ) ; } else { int j ; ch = CHILD ( ch , 0 ) ; REQ ( ch , simple_stmt ) ; for ( j = 0 ; j < NCH ( ch ) ; j += 2 ) { if ( NCH ( CHILD ( ch , j ) ) == 0 ) { assert ( ( j + 1 ) == NCH ( ch ) ) ; break ; } s = ast_for_stmt ( c , CHILD ( ch , j ) ) ; if ( ! s ) return NULL ; asdl_seq_SET ( seq , pos ++ , s ) ; } } } } assert ( pos == seq -> size ) ; return seq ; }","if ( TYPE ( n ) != func_body_suite ) {REQ ( n , suite ) ;}total = num_stmts ( n ) ;",2456
417,"buggy line: for ( i = 2 ;ch = CHILD ( n , i ) ;cwe id:CWE-125context: static asdl_seq * ast_for_suite ( struct compiling * c , const node * n ) { asdl_seq * seq ; stmt_ty s ; int i , total , num , end , pos = 0 ; node * ch ;  REQ ( n , suite ) ;  total = num_stmts ( n ) ; seq = _Py_asdl_seq_new ( total , c -> c_arena ) ; if ( ! seq ) return NULL ; if ( TYPE ( CHILD ( n , 0 ) ) == simple_stmt ) { n = CHILD ( n , 0 ) ; end = NCH ( n ) - 1 ; if ( TYPE ( CHILD ( n , end - 1 ) ) == SEMI ) end -- ; for ( i = 0 ; i < end ; i += 2 ) { ch = CHILD ( n , i ) ; s = ast_for_stmt ( c , ch ) ; if ( ! s ) return NULL ; asdl_seq_SET ( seq , pos ++ , s ) ; } } else {  for ( i = 2 ; i < ( NCH ( n ) - 1 ) ; i ++ ) {  ch = CHILD ( n , i ) ; REQ ( ch , stmt ) ; num = num_stmts ( ch ) ; if ( num == 1 ) { s = ast_for_stmt ( c , ch ) ; if ( ! s ) return NULL ; asdl_seq_SET ( seq , pos ++ , s ) ; } else { int j ; ch = CHILD ( ch , 0 ) ; REQ ( ch , simple_stmt ) ; for ( j = 0 ; j < NCH ( ch ) ; j += 2 ) { if ( NCH ( CHILD ( ch , j ) ) == 0 ) { assert ( ( j + 1 ) == NCH ( ch ) ) ; break ; } s = ast_for_stmt ( c , CHILD ( ch , j ) ) ; if ( ! s ) return NULL ; asdl_seq_SET ( seq , pos ++ , s ) ; } } } } assert ( pos == seq -> size ) ; return seq ; }","i = 2 ;if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) {i += 2 ;REQ ( CHILD ( n , 2 ) , NEWLINE ) ;}for ( ;ch = CHILD ( n , i ) ;",2456
418,"buggy line: int status = - 1 ;bool recompute_flag = false ;ALOGV ( ""%s<S2SV_blank>context<S2SV_blank>%p"" , __func__ , handle ) ;pthread_mutex_lock ( & vol_listner_init_lock ) ;list_for_each_safe ( node , temp_node_next , & vol_effect_list ) {if ( ( memcmp ( & ( context -> desc -> uuid ) , & ( recv_contex -> desc -> uuid ) , sizeof ( effect_uuid_t ) ) == 0 )   && ( context -> session_id == recv_contex -> session_id )   && ( context -> stream_type == recv_contex -> stream_type ) ) {ALOGV ( ""---<S2SV_blank>Found<S2SV_blank>something<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>---"" ) ;list_remove ( & context -> effect_list_node ) ;PRINT_STREAM_TYPE ( context -> stream_type ) ;cwe id:CWE-119context: static int vol_prc_lib_release ( effect_handle_t handle ) { struct listnode * node , * temp_node_next ; vol_listener_context_t * context = NULL ; vol_listener_context_t * recv_contex = ( vol_listener_context_t * ) handle ;  int status = - 1 ;  bool recompute_flag = false ; int active_stream_count = 0 ;  ALOGV ( ""%s<S2SV_blank>context<S2SV_blank>%p"" , __func__ , handle ) ;   pthread_mutex_lock ( & vol_listner_init_lock ) ;  list_for_each_safe ( node , temp_node_next , & vol_effect_list ) { context = node_to_item ( node , struct vol_listener_context_s , effect_list_node ) ;  if ( ( memcmp ( & ( context -> desc -> uuid ) , & ( recv_contex -> desc -> uuid ) , sizeof ( effect_uuid_t ) ) == 0 )   && ( context -> session_id == recv_contex -> session_id )   && ( context -> stream_type == recv_contex -> stream_type ) ) {  ALOGV ( ""---<S2SV_blank>Found<S2SV_blank>something<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>---"" ) ;  list_remove ( & context -> effect_list_node ) ;  PRINT_STREAM_TYPE ( context -> stream_type ) ; if ( context -> dev_id && AUDIO_DEVICE_OUT_SPEAKER ) { recompute_flag = true ; } free ( context ) ; status = 0 ; } else { ++ active_stream_count ; } } if ( status != 0 ) { ALOGE ( ""something<S2SV_blank>wrong<S2SV_blank>...<S2SV_blank><<<---<S2SV_blank>Found<S2SV_blank>NOTHING<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>...<S2SV_blank>????<S2SV_blank>--->>>>>"" ) ;  }  if ( active_stream_count == 0 ) { current_gain_dep_cal_level = - 1 ; current_vol = 0.0 ; } if ( recompute_flag ) { check_and_set_gain_dep_cal ( ) ; } if ( dumping_enabled ) { dump_list_l ( ) ; } pthread_mutex_unlock ( & vol_listner_init_lock ) ; return status ; }","int status = - EINVAL ;bool recompute_flag = false ;uint32_t session_id ;uint32_t stream_type ;effect_uuid_t uuid ;ALOGV ( ""%s<S2SV_blank>context<S2SV_blank>%p"" , __func__ , handle ) ;if ( recv_contex == NULL ) {return status ;}pthread_mutex_lock ( & vol_listner_init_lock ) ;session_id = recv_contex -> session_id ;stream_type = recv_contex -> stream_type ;uuid = recv_contex -> desc -> uuid ;list_for_each_safe ( node , temp_node_next , & vol_effect_list ) {if ( ( memcmp ( & ( context -> desc -> uuid ) , & uuid , sizeof ( effect_uuid_t ) ) == 0 ) && ( context -> session_id == session_id ) && ( context -> stream_type == stream_type ) ) {ALOGV ( ""---<S2SV_blank>Found<S2SV_blank>something<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>---"" ) ;list_remove ( node ) ;PRINT_STREAM_TYPE ( context -> stream_type ) ;",2457
419,"buggy line: }if ( active_stream_count == 0 ) {cwe id:CWE-119context: static int vol_prc_lib_release ( effect_handle_t handle ) { struct listnode * node , * temp_node_next ; vol_listener_context_t * context = NULL ; vol_listener_context_t * recv_contex = ( vol_listener_context_t * ) handle ;  int status = - 1 ;  bool recompute_flag = false ; int active_stream_count = 0 ;  ALOGV ( ""%s<S2SV_blank>context<S2SV_blank>%p"" , __func__ , handle ) ;   pthread_mutex_lock ( & vol_listner_init_lock ) ;  list_for_each_safe ( node , temp_node_next , & vol_effect_list ) { context = node_to_item ( node , struct vol_listener_context_s , effect_list_node ) ;  if ( ( memcmp ( & ( context -> desc -> uuid ) , & ( recv_contex -> desc -> uuid ) , sizeof ( effect_uuid_t ) ) == 0 )   && ( context -> session_id == recv_contex -> session_id )   && ( context -> stream_type == recv_contex -> stream_type ) ) {  ALOGV ( ""---<S2SV_blank>Found<S2SV_blank>something<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>---"" ) ;  list_remove ( & context -> effect_list_node ) ;  PRINT_STREAM_TYPE ( context -> stream_type ) ; if ( context -> dev_id && AUDIO_DEVICE_OUT_SPEAKER ) { recompute_flag = true ; } free ( context ) ; status = 0 ; } else { ++ active_stream_count ; } } if ( status != 0 ) { ALOGE ( ""something<S2SV_blank>wrong<S2SV_blank>...<S2SV_blank><<<---<S2SV_blank>Found<S2SV_blank>NOTHING<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>...<S2SV_blank>????<S2SV_blank>--->>>>>"" ) ;  }  if ( active_stream_count == 0 ) { current_gain_dep_cal_level = - 1 ; current_vol = 0.0 ; } if ( recompute_flag ) { check_and_set_gain_dep_cal ( ) ; } if ( dumping_enabled ) { dump_list_l ( ) ; } pthread_mutex_unlock ( & vol_listner_init_lock ) ; return status ; }",pthread_mutex_unlock ( & vol_listner_init_lock ) ;return status ;}if ( active_stream_count == 0 ) {,2457
420,"buggy line: break_type = 1 ;cwe id:CWE-125context: static void wrap_lines_smart ( ASS_Renderer * render_priv , double max_text_width ) { int i ; GlyphInfo * cur , * s1 , * e1 , * s2 , * s3 ; int last_space ; int break_type ; int exit ; double pen_shift_x ; double pen_shift_y ; int cur_line ; int run_offset ; TextInfo * text_info = & render_priv -> text_info ; last_space = - 1 ; text_info -> n_lines = 1 ; break_type = 0 ; s1 = text_info -> glyphs ; for ( i = 0 ; i < text_info -> length ; ++ i ) { int break_at = - 1 ; double s_offset , len ; cur = text_info -> glyphs + i ; s_offset = d6_to_double ( s1 -> bbox . xMin + s1 -> pos . x ) ; len = d6_to_double ( cur -> bbox . xMax + cur -> pos . x ) - s_offset ; if ( cur -> symbol == '\\n' ) { break_type = 2 ; break_at = i ; ass_msg ( render_priv -> library , MSGL_DBG2 , ""forced<S2SV_blank>line<S2SV_blank>break<S2SV_blank>at<S2SV_blank>%d"" , break_at ) ; } else if ( cur -> symbol == '<S2SV_blank>' ) { last_space = i ; } else if ( len >= max_text_width && ( render_priv -> state . wrap_style != 2 ) ) { break_type = 1 ; break_at = last_space ; if ( break_at >= 0 ) ass_msg ( render_priv -> library , MSGL_DBG2 , ""line<S2SV_blank>break<S2SV_blank>at<S2SV_blank>%d"" , break_at ) ; } if ( break_at != - 1 ) { int lead = break_at + 1 ; if ( text_info -> n_lines >= text_info -> max_lines ) { text_info -> max_lines *= 2 ; text_info -> lines = realloc ( text_info -> lines , sizeof ( LineInfo ) * text_info -> max_lines ) ; } if ( lead < text_info -> length ) { text_info -> glyphs [ lead ] . linebreak = break_type ; last_space = - 1 ; s1 = text_info -> glyphs + lead ; text_info -> n_lines ++ ; } } } # define DIFF ( x , y ) ( ( ( x ) < ( y ) ) ? ( y - x ) : ( x - y ) ) exit = 0 ; while ( ! exit && render_priv -> state . wrap_style != 1 ) { exit = 1 ; s3 = text_info -> glyphs ; s1 = s2 = 0 ; for ( i = 0 ; i <= text_info -> length ; ++ i ) { cur = text_info -> glyphs + i ; if ( ( i == text_info -> length ) || cur -> linebreak ) { s1 = s2 ; s2 = s3 ; s3 = cur ; if ( s1 && ( s2 -> linebreak == 1 ) ) { double l1 , l2 , l1_new , l2_new ; GlyphInfo * w = s2 ; do { -- w ; } while ( ( w > s1 ) && ( w -> symbol == '<S2SV_blank>' ) ) ; while ( ( w > s1 ) && ( w -> symbol != '<S2SV_blank>' ) ) { -- w ; } e1 = w ; while ( ( e1 > s1 ) && ( e1 -> symbol == '<S2SV_blank>' ) ) { -- e1 ; } if ( w -> symbol == '<S2SV_blank>' ) ++ w ; l1 = d6_to_double ( ( ( s2 - 1 ) -> bbox . xMax + ( s2 - 1 ) -> pos . x ) - ( s1 -> bbox . xMin + s1 -> pos . x ) ) ; l2 = d6_to_double ( ( ( s3 - 1 ) -> bbox . xMax + ( s3 - 1 ) -> pos . x ) - ( s2 -> bbox . xMin + s2 -> pos . x ) ) ; l1_new = d6_to_double ( ( e1 -> bbox . xMax + e1 -> pos . x ) - ( s1 -> bbox . xMin + s1 -> pos . x ) ) ; l2_new = d6_to_double ( ( ( s3 - 1 ) -> bbox . xMax + ( s3 - 1 ) -> pos . x ) - ( w -> bbox . xMin + w -> pos . x ) ) ; if ( DIFF ( l1_new , l2_new ) < DIFF ( l1 , l2 ) ) {  w -> linebreak = 1 ;  s2 -> linebreak = 0 ; exit = 0 ; } } } if ( i == text_info -> length ) break ; } } assert ( text_info -> n_lines >= 1 ) ; # undef DIFF measure_text ( render_priv ) ; trim_whitespace ( render_priv ) ; cur_line = 1 ; run_offset = 0 ; i = 0 ; cur = text_info -> glyphs + i ; while ( i < text_info -> length && cur -> skip ) cur = text_info -> glyphs + ++ i ; pen_shift_x = d6_to_double ( - cur -> pos . x ) ; pen_shift_y = 0. ; for ( i = 0 ; i < text_info -> length ; ++ i ) { cur = text_info -> glyphs + i ; if ( cur -> linebreak ) { while ( i < text_info -> length && cur -> skip && cur -> symbol != '\\n' ) cur = text_info -> glyphs + ++ i ; double height = text_info -> lines [ cur_line - 1 ] . desc + text_info -> lines [ cur_line ] . asc ; text_info -> lines [ cur_line - 1 ] . len = i - text_info -> lines [ cur_line - 1 ] . offset ; text_info -> lines [ cur_line ] . offset = i ; cur_line ++ ; run_offset ++ ; pen_shift_x = d6_to_double ( - cur -> pos . x ) ; pen_shift_y += height + render_priv -> settings . line_spacing ; } cur -> pos . x += double_to_d6 ( pen_shift_x ) ; cur -> pos . y += double_to_d6 ( pen_shift_y ) ; } text_info -> lines [ cur_line - 1 ] . len = text_info -> length - text_info -> lines [ cur_line - 1 ] . offset ; # if 0 for ( i = 0 ; i < text_info -> n_lines ; i ++ ) { printf ( ""line<S2SV_blank>%d<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\n"" , i , text_info -> lines [ i ] . offset , text_info -> lines [ i ] . len ) ; } # endif }",if ( w -> linebreak || w == text_info -> glyphs ) text_info -> n_lines -- ;if ( w != text_info -> glyphs ) break_type = 1 ;,2458
421,"buggy line: w -> linebreak = 1 ;s2 -> linebreak = 0 ;cwe id:CWE-125context: static void wrap_lines_smart ( ASS_Renderer * render_priv , double max_text_width ) { int i ; GlyphInfo * cur , * s1 , * e1 , * s2 , * s3 ; int last_space ; int break_type ; int exit ; double pen_shift_x ; double pen_shift_y ; int cur_line ; int run_offset ; TextInfo * text_info = & render_priv -> text_info ; last_space = - 1 ; text_info -> n_lines = 1 ; break_type = 0 ; s1 = text_info -> glyphs ; for ( i = 0 ; i < text_info -> length ; ++ i ) { int break_at = - 1 ; double s_offset , len ; cur = text_info -> glyphs + i ; s_offset = d6_to_double ( s1 -> bbox . xMin + s1 -> pos . x ) ; len = d6_to_double ( cur -> bbox . xMax + cur -> pos . x ) - s_offset ; if ( cur -> symbol == '\\n' ) { break_type = 2 ; break_at = i ; ass_msg ( render_priv -> library , MSGL_DBG2 , ""forced<S2SV_blank>line<S2SV_blank>break<S2SV_blank>at<S2SV_blank>%d"" , break_at ) ; } else if ( cur -> symbol == '<S2SV_blank>' ) { last_space = i ; } else if ( len >= max_text_width && ( render_priv -> state . wrap_style != 2 ) ) { break_type = 1 ; break_at = last_space ; if ( break_at >= 0 ) ass_msg ( render_priv -> library , MSGL_DBG2 , ""line<S2SV_blank>break<S2SV_blank>at<S2SV_blank>%d"" , break_at ) ; } if ( break_at != - 1 ) { int lead = break_at + 1 ; if ( text_info -> n_lines >= text_info -> max_lines ) { text_info -> max_lines *= 2 ; text_info -> lines = realloc ( text_info -> lines , sizeof ( LineInfo ) * text_info -> max_lines ) ; } if ( lead < text_info -> length ) { text_info -> glyphs [ lead ] . linebreak = break_type ; last_space = - 1 ; s1 = text_info -> glyphs + lead ; text_info -> n_lines ++ ; } } } # define DIFF ( x , y ) ( ( ( x ) < ( y ) ) ? ( y - x ) : ( x - y ) ) exit = 0 ; while ( ! exit && render_priv -> state . wrap_style != 1 ) { exit = 1 ; s3 = text_info -> glyphs ; s1 = s2 = 0 ; for ( i = 0 ; i <= text_info -> length ; ++ i ) { cur = text_info -> glyphs + i ; if ( ( i == text_info -> length ) || cur -> linebreak ) { s1 = s2 ; s2 = s3 ; s3 = cur ; if ( s1 && ( s2 -> linebreak == 1 ) ) { double l1 , l2 , l1_new , l2_new ; GlyphInfo * w = s2 ; do { -- w ; } while ( ( w > s1 ) && ( w -> symbol == '<S2SV_blank>' ) ) ; while ( ( w > s1 ) && ( w -> symbol != '<S2SV_blank>' ) ) { -- w ; } e1 = w ; while ( ( e1 > s1 ) && ( e1 -> symbol == '<S2SV_blank>' ) ) { -- e1 ; } if ( w -> symbol == '<S2SV_blank>' ) ++ w ; l1 = d6_to_double ( ( ( s2 - 1 ) -> bbox . xMax + ( s2 - 1 ) -> pos . x ) - ( s1 -> bbox . xMin + s1 -> pos . x ) ) ; l2 = d6_to_double ( ( ( s3 - 1 ) -> bbox . xMax + ( s3 - 1 ) -> pos . x ) - ( s2 -> bbox . xMin + s2 -> pos . x ) ) ; l1_new = d6_to_double ( ( e1 -> bbox . xMax + e1 -> pos . x ) - ( s1 -> bbox . xMin + s1 -> pos . x ) ) ; l2_new = d6_to_double ( ( ( s3 - 1 ) -> bbox . xMax + ( s3 - 1 ) -> pos . x ) - ( w -> bbox . xMin + w -> pos . x ) ) ; if ( DIFF ( l1_new , l2_new ) < DIFF ( l1 , l2 ) ) {  w -> linebreak = 1 ;  s2 -> linebreak = 0 ; exit = 0 ; } } } if ( i == text_info -> length ) break ; } } assert ( text_info -> n_lines >= 1 ) ; # undef DIFF measure_text ( render_priv ) ; trim_whitespace ( render_priv ) ; cur_line = 1 ; run_offset = 0 ; i = 0 ; cur = text_info -> glyphs + i ; while ( i < text_info -> length && cur -> skip ) cur = text_info -> glyphs + ++ i ; pen_shift_x = d6_to_double ( - cur -> pos . x ) ; pen_shift_y = 0. ; for ( i = 0 ; i < text_info -> length ; ++ i ) { cur = text_info -> glyphs + i ; if ( cur -> linebreak ) { while ( i < text_info -> length && cur -> skip && cur -> symbol != '\\n' ) cur = text_info -> glyphs + ++ i ; double height = text_info -> lines [ cur_line - 1 ] . desc + text_info -> lines [ cur_line ] . asc ; text_info -> lines [ cur_line - 1 ] . len = i - text_info -> lines [ cur_line - 1 ] . offset ; text_info -> lines [ cur_line ] . offset = i ; cur_line ++ ; run_offset ++ ; pen_shift_x = d6_to_double ( - cur -> pos . x ) ; pen_shift_y += height + render_priv -> settings . line_spacing ; } cur -> pos . x += double_to_d6 ( pen_shift_x ) ; cur -> pos . y += double_to_d6 ( pen_shift_y ) ; } text_info -> lines [ cur_line - 1 ] . len = text_info -> length - text_info -> lines [ cur_line - 1 ] . offset ; # if 0 for ( i = 0 ; i < text_info -> n_lines ; i ++ ) { printf ( ""line<S2SV_blank>%d<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\n"" , i , text_info -> lines [ i ] . offset , text_info -> lines [ i ] . len ) ; } # endif }",w -> linebreak = 1 ;s2 -> linebreak = 0 ;,2458
422,"buggy line: if ( state -> expr_list . size == 0 ) {if ( ! state -> last_str ) {}return make_str_node_and_del ( & state -> last_str , c , n ) ;}if ( state -> last_str ) {expr_ty str = make_str_node_and_del ( & state -> last_str , c , n ) ;if ( ! str || ExprList_Append ( & state -> expr_list , str ) < 0 ) goto error ;}assert ( state -> last_str == NULL ) ;seq = ExprList_Finish ( & state -> expr_list , c -> c_arena ) ;if ( ! seq ) goto error ;if ( seq -> size == 1 )  return seq -> elements [ 0 ] ;cwe id:CWE-125context: static expr_ty FstringParser_Finish ( FstringParser * state , struct compiling * c , const node * n ) { asdl_seq * seq ; FstringParser_check_invariants ( state ) ;  if ( state -> expr_list . size == 0 ) {  if ( ! state -> last_str ) { state -> last_str = PyUnicode_FromStringAndSize ( NULL , 0 ) ; if ( ! state -> last_str ) goto error ; } return make_str_node_and_del ( & state -> last_str , c , n ) ; } if ( state -> last_str ) { expr_ty str = make_str_node_and_del ( & state -> last_str , c , n ) ; if ( ! str || ExprList_Append ( & state -> expr_list , str ) < 0 ) goto error ; } assert ( state -> last_str == NULL ) ; seq = ExprList_Finish ( & state -> expr_list , c -> c_arena ) ; if ( ! seq ) goto error ;  if ( seq -> size == 1 )  return seq -> elements [ 0 ] ; return JoinedStr ( seq , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; error : FstringParser_Dealloc ( state ) ; return NULL ; }",if ( ! state -> fmode ) {assert ( ! state -> expr_list . size ) ;if ( ! state -> last_str ) {,2459
423,"buggy line: if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) {if ( new_len > old_len ) goto Efault ;cwe id:CWE-189context: static struct vm_area_struct * vma_to_resize ( unsigned long addr , unsigned long old_len , unsigned long new_len , unsigned long * p ) { struct mm_struct * mm = current -> mm ; struct vm_area_struct * vma = find_vma ( mm , addr ) ; if ( ! vma || vma -> vm_start > addr ) goto Efault ; if ( is_vm_hugetlb_page ( vma ) ) goto Einval ; if ( old_len > vma -> vm_end - addr ) goto Efault ;  if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) {  if ( new_len > old_len ) goto Efault ; } if ( vma -> vm_flags & VM_LOCKED ) { unsigned long locked , lock_limit ; locked = mm -> locked_vm << PAGE_SHIFT ; lock_limit = rlimit ( RLIMIT_MEMLOCK ) ; locked += new_len - old_len ; if ( locked > lock_limit && ! capable ( CAP_IPC_LOCK ) ) goto Eagain ; } if ( ! may_expand_vm ( mm , ( new_len - old_len ) >> PAGE_SHIFT ) ) goto Enomem ; if ( vma -> vm_flags & VM_ACCOUNT ) { unsigned long charged = ( new_len - old_len ) >> PAGE_SHIFT ; if ( security_vm_enough_memory ( charged ) ) goto Efault ; * p = charged ; } return vma ; Efault : return ERR_PTR ( - EFAULT ) ; Einval : return ERR_PTR ( - EINVAL ) ; Enomem : return ERR_PTR ( - ENOMEM ) ; Eagain : return ERR_PTR ( - EAGAIN ) ; }",if ( new_len > old_len ) {unsigned long pgoff ;if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) goto Efault ;pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ;pgoff += vma -> vm_pgoff ;if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval ;,2460
424,"buggy line: kvm_async_pf_hash_reset ( vcpu ) ;kvm_pmu_init ( vcpu ) ;cwe id:CWE-399context: int kvm_arch_vcpu_init ( struct kvm_vcpu * vcpu ) { struct page * page ; struct kvm * kvm ; int r ; BUG_ON ( vcpu -> kvm == NULL ) ; kvm = vcpu -> kvm ; vcpu -> arch . emulate_ctxt . ops = & emulate_ops ; if ( ! irqchip_in_kernel ( kvm ) || kvm_vcpu_is_bsp ( vcpu ) ) vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ; else vcpu -> arch . mp_state = KVM_MP_STATE_UNINITIALIZED ; page = alloc_page ( GFP_KERNEL | __GFP_ZERO ) ; if ( ! page ) { r = - ENOMEM ; goto fail ; } vcpu -> arch . pio_data = page_address ( page ) ; kvm_set_tsc_khz ( vcpu , max_tsc_khz ) ; r = kvm_mmu_create ( vcpu ) ; if ( r < 0 ) goto fail_free_pio_data ; if ( irqchip_in_kernel ( kvm ) ) { r = kvm_create_lapic ( vcpu ) ; if ( r < 0 ) goto fail_mmu_destroy ; } else static_key_slow_inc ( & kvm_no_apic_vcpu ) ; vcpu -> arch . mce_banks = kzalloc ( KVM_MAX_MCE_BANKS * sizeof ( u64 ) * 4 , GFP_KERNEL ) ; if ( ! vcpu -> arch . mce_banks ) { r = - ENOMEM ; goto fail_free_lapic ; } vcpu -> arch . mcg_cap = KVM_MAX_MCE_BANKS ; if ( ! zalloc_cpumask_var ( & vcpu -> arch . wbinvd_dirty_mask , GFP_KERNEL ) ) goto fail_free_mce_banks ; r = fx_init ( vcpu ) ; if ( r ) goto fail_free_wbinvd_dirty_mask ; vcpu -> arch . ia32_tsc_adjust_msr = 0x0 ;  kvm_async_pf_hash_reset ( vcpu ) ;  kvm_pmu_init ( vcpu ) ; return 0 ; fail_free_wbinvd_dirty_mask : free_cpumask_var ( vcpu -> arch . wbinvd_dirty_mask ) ; fail_free_mce_banks : kfree ( vcpu -> arch . mce_banks ) ; fail_free_lapic : kvm_free_lapic ( vcpu ) ; fail_mmu_destroy : kvm_mmu_destroy ( vcpu ) ; fail_free_pio_data : free_page ( ( unsigned long ) vcpu -> arch . pio_data ) ; fail : return r ; }",vcpu -> arch . pv_time_enabled = false ;kvm_async_pf_hash_reset ( vcpu ) ;kvm_pmu_init ( vcpu ) ;,2461
425,"buggy line: tfrc . tfrctx_x = hc -> tx_x ;tfrc . tfrctx_x_recv = hc -> tx_x_recv ;cwe id:CWE-200context: static int ccid3_hc_tx_getsockopt ( struct sock * sk , const int optname , int len , u32 __user * optval , int __user * optlen ) { const struct ccid3_hc_tx_sock * hc = ccid3_hc_tx_sk ( sk ) ; struct tfrc_tx_info tfrc ; const void * val ; switch ( optname ) { case DCCP_SOCKOPT_CCID_TX_INFO : if ( len < sizeof ( tfrc ) ) return - EINVAL ;  tfrc . tfrctx_x = hc -> tx_x ;  tfrc . tfrctx_x_recv = hc -> tx_x_recv ; tfrc . tfrctx_x_calc = hc -> tx_x_calc ; tfrc . tfrctx_rtt = hc -> tx_rtt ; tfrc . tfrctx_p = hc -> tx_p ; tfrc . tfrctx_rto = hc -> tx_t_rto ; tfrc . tfrctx_ipi = hc -> tx_t_ipi ; len = sizeof ( tfrc ) ; val = & tfrc ; break ; default : return - ENOPROTOOPT ; } if ( put_user ( len , optlen ) || copy_to_user ( optval , val , len ) ) return - EFAULT ; return 0 ; }","memset ( & tfrc , 0 , sizeof ( tfrc ) ) ;tfrc . tfrctx_x = hc -> tx_x ;tfrc . tfrctx_x_recv = hc -> tx_x_recv ;",2462
426,"buggy line: case EXIT_REASON_EXCEPTION_NMI :  if ( ! is_exception ( intr_info ) )  return false ;cwe id:CWE-388context: static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return false ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return true ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI :  if ( ! is_exception ( intr_info ) )  return false ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return false ; else if ( is_debug ( intr_info ) && vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) return false ; else if ( is_breakpoint ( intr_info ) && vcpu -> guest_debug & KVM_GUESTDBG_USE_SW_BP ) return false ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return false ; case EXIT_REASON_TRIPLE_FAULT : return true ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return true ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return false ; return true ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return true ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : case EXIT_REASON_RDTSCP : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID : return true ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_GDTR_IDTR : case EXIT_REASON_LDTR_TR : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_DESC ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return true ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_TRAP_FLAG : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_TRAP_FLAG ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return false ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_APIC_WRITE : case EXIT_REASON_EOI_INDUCED : return true ; case EXIT_REASON_EPT_VIOLATION : return false ; case EXIT_REASON_EPT_MISCONFIG : return false ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return true ; case EXIT_REASON_XSAVES : case EXIT_REASON_XRSTORS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_XSAVES ) ; case EXIT_REASON_PREEMPTION_TIMER : return false ; default : return true ; } }",case EXIT_REASON_EXCEPTION_NMI : if ( is_nmi ( intr_info ) ) return false ;,2463
427,"buggy line: }else   n ++ ;log_debug ( ""%s:<S2SV_blank>%u<S2SV_blank>=<S2SV_blank>%d"" , __func__ , n - 1 , p [ n - 1 ] ) ;cwe id:CWE-787context: static void input_csi_dispatch_sgr_colon ( struct input_ctx * ictx , u_int i ) { struct grid_cell * gc = & ictx -> cell . cell ; char * s = ictx -> param_list [ i ] . str , * copy , * ptr , * out ; int p [ 8 ] ; u_int n ; const char * errstr ; for ( n = 0 ; n < nitems ( p ) ; n ++ ) p [ n ] = - 1 ; n = 0 ; ptr = copy = xstrdup ( s ) ; while ( ( out = strsep ( & ptr , "":"" ) ) != NULL ) { if ( * out != '\\0' ) { p [ n ++ ] = strtonum ( out , 0 , INT_MAX , & errstr ) ; if ( errstr != NULL || n == nitems ( p ) ) { free ( copy ) ; return ; }  } else   n ++ ;  log_debug ( ""%s:<S2SV_blank>%u<S2SV_blank>=<S2SV_blank>%d"" , __func__ , n - 1 , p [ n - 1 ] ) ; } free ( copy ) ; if ( n == 0 ) return ; if ( p [ 0 ] == 4 ) { if ( n != 2 ) return ; switch ( p [ 1 ] ) { case 0 : gc -> attr &= ~ GRID_ATTR_ALL_UNDERSCORE ; break ; case 1 : gc -> attr &= ~ GRID_ATTR_ALL_UNDERSCORE ; gc -> attr |= GRID_ATTR_UNDERSCORE ; break ; case 2 : gc -> attr &= ~ GRID_ATTR_ALL_UNDERSCORE ; gc -> attr |= GRID_ATTR_UNDERSCORE_2 ; break ; case 3 : gc -> attr &= ~ GRID_ATTR_ALL_UNDERSCORE ; gc -> attr |= GRID_ATTR_UNDERSCORE_3 ; break ; case 4 : gc -> attr &= ~ GRID_ATTR_ALL_UNDERSCORE ; gc -> attr |= GRID_ATTR_UNDERSCORE_4 ; break ; case 5 : gc -> attr &= ~ GRID_ATTR_ALL_UNDERSCORE ; gc -> attr |= GRID_ATTR_UNDERSCORE_5 ; break ; } return ; } if ( n < 2 || ( p [ 0 ] != 38 && p [ 0 ] != 48 && p [ 0 ] != 58 ) ) return ; switch ( p [ 1 ] ) { case 2 : if ( n < 3 ) break ; if ( n == 5 ) i = 2 ; else i = 3 ; if ( n < i + 3 ) break ; input_csi_dispatch_sgr_rgb_do ( ictx , p [ 0 ] , p [ i ] , p [ i + 1 ] , p [ i + 2 ] ) ; break ; case 5 : if ( n < 3 ) break ; input_csi_dispatch_sgr_256_do ( ictx , p [ 0 ] , p [ 2 ] ) ; break ; } }","}else {n ++ ;if ( n == nitems ( p ) ) {free ( copy ) ;return ;}}log_debug ( ""%s:<S2SV_blank>%u<S2SV_blank>=<S2SV_blank>%d"" , __func__ , n - 1 , p [ n - 1 ] ) ;",2464
428,buggy line: void ext4_xattr_destroy_cache ( struct mb_cache * cache )  {if ( cache )  mb_cache_destroy ( cache ) ;}cwe id:CWE-19context:  void ext4_xattr_destroy_cache ( struct mb_cache * cache )  { if ( cache )  mb_cache_destroy ( cache ) ;  },void ext4_xattr_destroy_cache ( struct mb2_cache * cache ) {if ( cache ) mb2_cache_destroy ( cache ) ;},2465
429,"buggy line: static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs )  {cwe id:CWE-59context:  static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs )  { FILE * fp = fopen ( dest_filename , ""w"" ) ; if ( ! fp ) return false ; unsigned fd = 0 ; while ( fd <= 99999 ) { sprintf ( source_filename + source_base_ofs , ""fd/%u"" , fd ) ; char * name = malloc_readlink ( source_filename ) ; if ( ! name ) break ; fprintf ( fp , ""%u:%s\\n"" , fd , name ) ; free ( name ) ; sprintf ( source_filename + source_base_ofs , ""fdinfo/%u"" , fd ) ; fd ++ ; FILE * in = fopen ( source_filename , ""r"" ) ; if ( ! in ) continue ; char buf [ 128 ] ; while ( fgets ( buf , sizeof ( buf ) - 1 , in ) ) { char * eol = strchrnul ( buf , '\\n' ) ; eol [ 0 ] = '\\n' ; eol [ 1 ] = '\\0' ; fputs ( buf , fp ) ; } fclose ( in ) ; }  fclose ( fp ) ;  return true ; }","static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) {",2466
430,"buggy line: fclose ( fp ) ;return true ;cwe id:CWE-59context:  static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs )  { FILE * fp = fopen ( dest_filename , ""w"" ) ; if ( ! fp ) return false ; unsigned fd = 0 ; while ( fd <= 99999 ) { sprintf ( source_filename + source_base_ofs , ""fd/%u"" , fd ) ; char * name = malloc_readlink ( source_filename ) ; if ( ! name ) break ; fprintf ( fp , ""%u:%s\\n"" , fd , name ) ; free ( name ) ; sprintf ( source_filename + source_base_ofs , ""fdinfo/%u"" , fd ) ; fd ++ ; FILE * in = fopen ( source_filename , ""r"" ) ; if ( ! in ) continue ; char buf [ 128 ] ; while ( fgets ( buf , sizeof ( buf ) - 1 , in ) ) { char * eol = strchrnul ( buf , '\\n' ) ; eol [ 0 ] = '\\n' ; eol [ 1 ] = '\\0' ; fputs ( buf , fp ) ; } fclose ( in ) ; }  fclose ( fp ) ;  return true ; }","const int dest_fd = fileno ( fp ) ;if ( fchown ( dest_fd , uid , gid ) < 0 ) {perror_msg ( ""Can\\\'t<S2SV_blank>change<S2SV_blank>\\\'%s\\\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu"" , dest_filename , ( long ) uid , ( long ) gid ) ;fclose ( fp ) ;unlink ( dest_filename ) ;return false ;}fclose ( fp ) ;return true ;",2466
431,"buggy line: u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ;ps_dec -> u1_nal_unit_type = u1_nal_unit_type ;cwe id:CWE-119context: WORD32 ih264d_parse_nal_unit ( iv_obj_t * dec_hdl , ivd_video_decode_op_t * ps_dec_op , UWORD8 * pu1_buf , UWORD32 u4_length ) { dec_bit_stream_t * ps_bitstrm ; dec_struct_t * ps_dec = ( dec_struct_t * ) dec_hdl -> pv_codec_handle ; ivd_video_decode_ip_t * ps_dec_in = ( ivd_video_decode_ip_t * ) ps_dec -> pv_dec_in ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; UWORD8 u1_first_byte , u1_nal_ref_idc ; UWORD8 u1_nal_unit_type ; WORD32 i_status = OK ; ps_bitstrm = ps_dec -> ps_bitstrm ; if ( pu1_buf ) { if ( u4_length ) { ps_dec_op -> u4_frame_decoded_flag = 0 ; ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ; SWITCHOFFTRACE ; u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) { H264_DEC_DEBUG_PRINT ( ""\\nForbidden<S2SV_blank>bit<S2SV_blank>set<S2SV_blank>in<S2SV_blank>Nal<S2SV_blank>Unit,<S2SV_blank>Let\'s<S2SV_blank>try\\n"" ) ; }  u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ;  ps_dec -> u1_nal_unit_type = u1_nal_unit_type ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_first_byte ) ) ; switch ( u1_nal_unit_type ) { case SLICE_DATA_PARTITION_A_NAL : case SLICE_DATA_PARTITION_B_NAL : case SLICE_DATA_PARTITION_C_NAL : if ( ! ps_dec -> i4_decode_header ) ih264d_parse_slice_partition ( ps_dec , ps_bitstrm ) ; break ; case IDR_SLICE_NAL : case SLICE_NAL : DEBUG_THREADS_PRINTF ( ""Decoding<S2SV_blank><S2SV_blank>a<S2SV_blank>slice<S2SV_blank>NAL\\n"" ) ; if ( ! ps_dec -> i4_decode_header ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u4_slice_start_code_found = 1 ; ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_decode_slice ( ( UWORD8 ) ( u1_nal_unit_type == IDR_SLICE_NAL ) , u1_nal_ref_idc , ps_dec ) ; if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) && ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) ) { ps_dec -> u4_first_slice_in_pic = 1 ; } if ( i_status != OK ) { return i_status ; } } else { H264_DEC_DEBUG_PRINT ( ""\\nSlice<S2SV_blank>NAL<S2SV_blank>Supplied<S2SV_blank>but<S2SV_blank>no<S2SV_blank>header<S2SV_blank>has<S2SV_blank>been<S2SV_blank>supplied\\n"" ) ; } } break ; case SEI_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sei_message ( ps_dec , ps_bitstrm ) ; if ( i_status != OK ) return i_status ; ih264d_parse_sei ( ps_dec , ps_bitstrm ) ; } break ; case SEQ_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x1 ; break ; case PIC_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_pps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x2 ; break ; case ACCESS_UNIT_DELIMITER_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_access_unit_delimiter_rbsp ( ps_dec ) ; } break ; case END_OF_STREAM_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_end_of_stream ( ps_dec ) ; } break ; case FILLER_DATA_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_filler_data ( ps_dec , ps_bitstrm ) ; } break ; default : H264_DEC_DEBUG_PRINT ( ""\\nUnknown<S2SV_blank>NAL<S2SV_blank>type<S2SV_blank>%d\\n"" , u1_nal_unit_type ) ; break ; } } } return i_status ; }",u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ;if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) {return ERROR_INCOMPLETE_FRAME ;}ps_dec -> u1_nal_unit_type = u1_nal_unit_type ;,2467
432,"buggy line: perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;return 0 ;cwe id:CWE-399context: static int simulate_sync ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == SPEC0 && ( opcode & FUNC ) == SYNC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;  return 0 ; } return - 1 ; }","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;return 0 ;",2468
433,"buggy line: PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;for ( p = val ;zval * * tmp ;namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ;cwe id:CWE-74context: PS_SERIALIZER_DECODE_FUNC ( php_binary ) { const char * p ; char * name ; const char * endptr = val + vallen ; zval * current ; int namelen ; int has_value ; php_unserialize_data_t var_hash ;  PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;  for ( p = val ; p < endptr ; ) {  zval * * tmp ;  namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ; if ( namelen < 0 || namelen > PS_BIN_MAX || ( p + namelen ) >= endptr ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } has_value = * p & PS_BIN_UNDEF ? 0 : 1 ; name = estrndup ( p + 1 , namelen ) ; p += namelen + 1 ; if ( zend_hash_find ( & EG ( symbol_table ) , name , namelen + 1 , ( void * * ) & tmp ) == SUCCESS ) { if ( ( Z_TYPE_PP ( tmp ) == IS_ARRAY && Z_ARRVAL_PP ( tmp ) == & EG ( symbol_table ) ) || * tmp == PS ( http_session_vars ) ) {  efree ( name ) ;  continue ; } } if ( has_value ) { ALLOC_INIT_ZVAL ( current ) ; if ( php_var_unserialize ( & current , ( const unsigned char * * ) & p , ( const unsigned char * ) endptr , & var_hash TSRMLS_CC ) ) {  php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;  } else { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } var_push_dtor_no_addref ( & var_hash , & current ) ; }  PS_ADD_VARL ( name , namelen ) ;  efree ( name ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return SUCCESS ; }",int skip = 0 ;PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;for ( p = val ;zval * * tmp ;skip = 0 ;namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ;,2469
434,"buggy line: efree ( name ) ;continue ;php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;}PS_ADD_VARL ( name , namelen ) ;efree ( name ) ;cwe id:CWE-74context: PS_SERIALIZER_DECODE_FUNC ( php_binary ) { const char * p ; char * name ; const char * endptr = val + vallen ; zval * current ; int namelen ; int has_value ; php_unserialize_data_t var_hash ;  PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;  for ( p = val ; p < endptr ; ) {  zval * * tmp ;  namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ; if ( namelen < 0 || namelen > PS_BIN_MAX || ( p + namelen ) >= endptr ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } has_value = * p & PS_BIN_UNDEF ? 0 : 1 ; name = estrndup ( p + 1 , namelen ) ; p += namelen + 1 ; if ( zend_hash_find ( & EG ( symbol_table ) , name , namelen + 1 , ( void * * ) & tmp ) == SUCCESS ) { if ( ( Z_TYPE_PP ( tmp ) == IS_ARRAY && Z_ARRVAL_PP ( tmp ) == & EG ( symbol_table ) ) || * tmp == PS ( http_session_vars ) ) {  efree ( name ) ;  continue ; } } if ( has_value ) { ALLOC_INIT_ZVAL ( current ) ; if ( php_var_unserialize ( & current , ( const unsigned char * * ) & p , ( const unsigned char * ) endptr , & var_hash TSRMLS_CC ) ) {  php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;  } else { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } var_push_dtor_no_addref ( & var_hash , & current ) ; }  PS_ADD_VARL ( name , namelen ) ;  efree ( name ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return SUCCESS ; }","skip = 1 ;if ( ! skip ) {php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;}}if ( ! skip ) {PS_ADD_VARL ( name , namelen ) ;}efree ( name ) ;",2469
435,"buggy line: if ( mode > 0 ) {r = fchmod ( fd , mode ) ;cwe id:CWE-264context: int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; if ( fd < 0 ) return - errno ;  if ( mode > 0 ) {  r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }","if ( mode != MODE_INVALID ) {r = fchmod ( fd , mode ) ;",2470
436,"buggy line: if ( skb -> protocol == htons ( ETH_P_IP ) ) return tcp_v4_do_rcv ( sk , skb ) ;if ( sk_filter ( sk , skb ) )  goto discard ;cwe id:CWE-284context: static int tcp_v6_do_rcv ( struct sock * sk , struct sk_buff * skb ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp ; struct sk_buff * opt_skb = NULL ; if ( skb -> protocol == htons ( ETH_P_IP ) ) return tcp_v4_do_rcv ( sk , skb ) ;  if ( sk_filter ( sk , skb ) )  goto discard ; if ( np -> rxopt . all ) opt_skb = skb_clone ( skb , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; if ( sk -> sk_state == TCP_ESTABLISHED ) { struct dst_entry * dst = sk -> sk_rx_dst ; sock_rps_save_rxhash ( sk , skb ) ; sk_mark_napi_id ( sk , skb ) ; if ( dst ) { if ( inet_sk ( sk ) -> rx_dst_ifindex != skb -> skb_iif || dst -> ops -> check ( dst , np -> rx_dst_cookie ) == NULL ) { dst_release ( dst ) ; sk -> sk_rx_dst = NULL ; } } tcp_rcv_established ( sk , skb , tcp_hdr ( skb ) , skb -> len ) ; if ( opt_skb ) goto ipv6_pktoptions ; return 0 ; } if ( tcp_checksum_complete ( skb ) ) goto csum_err ; if ( sk -> sk_state == TCP_LISTEN ) { struct sock * nsk = tcp_v6_cookie_check ( sk , skb ) ; if ( ! nsk ) goto discard ; if ( nsk != sk ) { sock_rps_save_rxhash ( nsk , skb ) ; sk_mark_napi_id ( nsk , skb ) ; if ( tcp_child_process ( sk , nsk , skb ) ) goto reset ; if ( opt_skb ) __kfree_skb ( opt_skb ) ; return 0 ; } } else sock_rps_save_rxhash ( sk , skb ) ; if ( tcp_rcv_state_process ( sk , skb ) ) goto reset ; if ( opt_skb ) goto ipv6_pktoptions ; return 0 ; reset : tcp_v6_send_reset ( sk , skb ) ; discard : if ( opt_skb ) __kfree_skb ( opt_skb ) ; kfree_skb ( skb ) ; return 0 ; csum_err : TCP_INC_STATS ( sock_net ( sk ) , TCP_MIB_CSUMERRORS ) ; TCP_INC_STATS ( sock_net ( sk ) , TCP_MIB_INERRS ) ; goto discard ; ipv6_pktoptions : tp = tcp_sk ( sk ) ; if ( TCP_SKB_CB ( opt_skb ) -> end_seq == tp -> rcv_nxt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ) ) ) { if ( np -> rxopt . bits . rxinfo || np -> rxopt . bits . rxoinfo ) np -> mcast_oif = tcp_v6_iif ( opt_skb ) ; if ( np -> rxopt . bits . rxhlim || np -> rxopt . bits . rxohlim ) np -> mcast_hops = ipv6_hdr ( opt_skb ) -> hop_limit ; if ( np -> rxopt . bits . rxflow || np -> rxopt . bits . rxtclass ) np -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( opt_skb ) ) ; if ( np -> repflow ) np -> flow_label = ip6_flowlabel ( ipv6_hdr ( opt_skb ) ) ; if ( ipv6_opt_accepted ( sk , opt_skb , & TCP_SKB_CB ( opt_skb ) -> header . h6 ) ) { skb_set_owner_r ( opt_skb , sk ) ; tcp_v6_restore_cb ( opt_skb ) ; opt_skb = xchg ( & np -> pktoptions , opt_skb ) ; } else { __kfree_skb ( opt_skb ) ; opt_skb = xchg ( & np -> pktoptions , NULL ) ; } } kfree_skb ( opt_skb ) ; return 0 ; }","if ( tcp_filter ( sk , skb ) ;if ( sk_filter ( sk , skb ) ) goto discard ;",2471
437,"buggy line: uint32_t bcount ;infilesize = DoGetFileSize ( infile ) ;cwe id:CWE-119context: int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ;  uint32_t bcount ;  infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) {  int supported = TRUE , format ;  chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }",int format_chunk = 0 ;uint32_t bcount ;infilesize = DoGetFileSize ( infile ) ;,2472
438,"buggy line: int supported = TRUE , format ;chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ;cwe id:CWE-119context: int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ;  uint32_t bcount ;  infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) {  int supported = TRUE , format ;  chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }","int supported = TRUE , format ;if ( format_chunk ++ ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ;",2472
439,buggy line: static int get_max_filter_level ( VP9_COMP * cpi ) {return cpi -> twopass . section_intra_rating > 8 ? MAX_LOOP_FILTER * 3 / 4 : MAX_LOOP_FILTER ;}cwe id:CWE-119context:  static int get_max_filter_level ( VP9_COMP * cpi ) {  return cpi -> twopass . section_intra_rating > 8 ? MAX_LOOP_FILTER * 3 / 4 : MAX_LOOP_FILTER ;  } ,static int get_max_filter_level ( const VP9_COMP * cpi ) {if ( cpi -> oxcf . pass == 2 ) {return cpi -> twopass . section_intra_rating > 8 ? MAX_LOOP_FILTER * 3 / 4 : MAX_LOOP_FILTER ;}else {return MAX_LOOP_FILTER ;}},2473
440,"buggy line: for ( ifa1 = in_dev -> ifa_list ;if ( ifa1 == ifa ) {cwe id:CWE-399context: void fib_del_ifaddr ( struct in_ifaddr * ifa , struct in_ifaddr * iprim ) { struct in_device * in_dev = ifa -> ifa_dev ; struct net_device * dev = in_dev -> dev ; struct in_ifaddr * ifa1 ; struct in_ifaddr * prim = ifa , * prim1 = NULL ; __be32 brd = ifa -> ifa_address | ~ ifa -> ifa_mask ; __be32 any = ifa -> ifa_address & ifa -> ifa_mask ; # define LOCAL_OK 1 # define BRD_OK 2 # define BRD0_OK 4 # define BRD1_OK 8 unsigned int ok = 0 ; int subnet = 0 ; int gone = 1 ; int same_prefsrc = 0 ; if ( ifa -> ifa_flags & IFA_F_SECONDARY ) { prim = inet_ifa_byprefix ( in_dev , any , ifa -> ifa_mask ) ; if ( ! prim ) { pr_warn ( ""%s:<S2SV_blank>bug:<S2SV_blank>prim<S2SV_blank>==<S2SV_blank>NULL\\n"" , __func__ ) ; return ; } if ( iprim && iprim != prim ) { pr_warn ( ""%s:<S2SV_blank>bug:<S2SV_blank>iprim<S2SV_blank>!=<S2SV_blank>prim\\n"" , __func__ ) ; return ; } } else if ( ! ipv4_is_zeronet ( any ) && ( any != ifa -> ifa_local || ifa -> ifa_prefixlen < 32 ) ) { if ( ! ( ifa -> ifa_flags & IFA_F_NOPREFIXROUTE ) ) fib_magic ( RTM_DELROUTE , dev -> flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST , any , ifa -> ifa_prefixlen , prim ) ; subnet = 1 ; }  for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) {  if ( ifa1 == ifa ) { gone = 0 ; continue ; } if ( iprim && ifa1 -> ifa_mask == iprim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , iprim ) ) continue ; if ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) { if ( ifa1 -> ifa_mask == prim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , prim ) ) prim1 = prim ; else { if ( ! same_prefsrc ) continue ; if ( ! prim1 || ifa1 -> ifa_mask != prim1 -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , prim1 ) ) prim1 = inet_ifa_byprefix ( in_dev , ifa1 -> ifa_address , ifa1 -> ifa_mask ) ; if ( ! prim1 ) continue ; if ( prim1 -> ifa_local != prim -> ifa_local ) continue ; } } else { if ( prim -> ifa_local != ifa1 -> ifa_local ) continue ; prim1 = ifa1 ; if ( prim != prim1 ) same_prefsrc = 1 ; } if ( ifa -> ifa_local == ifa1 -> ifa_local ) ok |= LOCAL_OK ; if ( ifa -> ifa_broadcast == ifa1 -> ifa_broadcast ) ok |= BRD_OK ; if ( brd == ifa1 -> ifa_broadcast ) ok |= BRD1_OK ; if ( any == ifa1 -> ifa_broadcast ) ok |= BRD0_OK ; if ( prim1 == ifa1 && ifa1 -> ifa_prefixlen < 31 ) { __be32 brd1 = ifa1 -> ifa_address | ~ ifa1 -> ifa_mask ; __be32 any1 = ifa1 -> ifa_address & ifa1 -> ifa_mask ; if ( ! ipv4_is_zeronet ( any1 ) ) { if ( ifa -> ifa_broadcast == brd1 || ifa -> ifa_broadcast == any1 ) ok |= BRD_OK ; if ( brd == brd1 || brd == any1 ) ok |= BRD1_OK ; if ( any == brd1 || any == any1 ) ok |= BRD0_OK ; } }  }  if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ; if ( subnet && ifa -> ifa_prefixlen < 31 ) { if ( ! ( ok & BRD1_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , brd , 32 , prim ) ; if ( ! ( ok & BRD0_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , any , 32 , prim ) ; } if ( ! ( ok & LOCAL_OK ) ) { unsigned int addr_type ; fib_magic ( RTM_DELROUTE , RTN_LOCAL , ifa -> ifa_local , 32 , prim ) ; addr_type = inet_addr_type_dev_table ( dev_net ( dev ) , dev , ifa -> ifa_local ) ; if ( gone && addr_type != RTN_LOCAL ) { if ( fib_sync_down_addr ( dev_net ( dev ) , ifa -> ifa_local ) ) fib_flush ( dev_net ( dev ) ) ; } } # undef LOCAL_OK # undef BRD_OK # undef BRD0_OK # undef BRD1_OK }",if ( in_dev -> dead ) goto no_promotions ;for ( ifa1 = in_dev -> ifa_list ;if ( ifa1 == ifa ) {,2474
441,"buggy line: }if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ;cwe id:CWE-399context: void fib_del_ifaddr ( struct in_ifaddr * ifa , struct in_ifaddr * iprim ) { struct in_device * in_dev = ifa -> ifa_dev ; struct net_device * dev = in_dev -> dev ; struct in_ifaddr * ifa1 ; struct in_ifaddr * prim = ifa , * prim1 = NULL ; __be32 brd = ifa -> ifa_address | ~ ifa -> ifa_mask ; __be32 any = ifa -> ifa_address & ifa -> ifa_mask ; # define LOCAL_OK 1 # define BRD_OK 2 # define BRD0_OK 4 # define BRD1_OK 8 unsigned int ok = 0 ; int subnet = 0 ; int gone = 1 ; int same_prefsrc = 0 ; if ( ifa -> ifa_flags & IFA_F_SECONDARY ) { prim = inet_ifa_byprefix ( in_dev , any , ifa -> ifa_mask ) ; if ( ! prim ) { pr_warn ( ""%s:<S2SV_blank>bug:<S2SV_blank>prim<S2SV_blank>==<S2SV_blank>NULL\\n"" , __func__ ) ; return ; } if ( iprim && iprim != prim ) { pr_warn ( ""%s:<S2SV_blank>bug:<S2SV_blank>iprim<S2SV_blank>!=<S2SV_blank>prim\\n"" , __func__ ) ; return ; } } else if ( ! ipv4_is_zeronet ( any ) && ( any != ifa -> ifa_local || ifa -> ifa_prefixlen < 32 ) ) { if ( ! ( ifa -> ifa_flags & IFA_F_NOPREFIXROUTE ) ) fib_magic ( RTM_DELROUTE , dev -> flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST , any , ifa -> ifa_prefixlen , prim ) ; subnet = 1 ; }  for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) {  if ( ifa1 == ifa ) { gone = 0 ; continue ; } if ( iprim && ifa1 -> ifa_mask == iprim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , iprim ) ) continue ; if ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) { if ( ifa1 -> ifa_mask == prim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , prim ) ) prim1 = prim ; else { if ( ! same_prefsrc ) continue ; if ( ! prim1 || ifa1 -> ifa_mask != prim1 -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , prim1 ) ) prim1 = inet_ifa_byprefix ( in_dev , ifa1 -> ifa_address , ifa1 -> ifa_mask ) ; if ( ! prim1 ) continue ; if ( prim1 -> ifa_local != prim -> ifa_local ) continue ; } } else { if ( prim -> ifa_local != ifa1 -> ifa_local ) continue ; prim1 = ifa1 ; if ( prim != prim1 ) same_prefsrc = 1 ; } if ( ifa -> ifa_local == ifa1 -> ifa_local ) ok |= LOCAL_OK ; if ( ifa -> ifa_broadcast == ifa1 -> ifa_broadcast ) ok |= BRD_OK ; if ( brd == ifa1 -> ifa_broadcast ) ok |= BRD1_OK ; if ( any == ifa1 -> ifa_broadcast ) ok |= BRD0_OK ; if ( prim1 == ifa1 && ifa1 -> ifa_prefixlen < 31 ) { __be32 brd1 = ifa1 -> ifa_address | ~ ifa1 -> ifa_mask ; __be32 any1 = ifa1 -> ifa_address & ifa1 -> ifa_mask ; if ( ! ipv4_is_zeronet ( any1 ) ) { if ( ifa -> ifa_broadcast == brd1 || ifa -> ifa_broadcast == any1 ) ok |= BRD_OK ; if ( brd == brd1 || brd == any1 ) ok |= BRD1_OK ; if ( any == brd1 || any == any1 ) ok |= BRD0_OK ; } }  }  if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ; if ( subnet && ifa -> ifa_prefixlen < 31 ) { if ( ! ( ok & BRD1_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , brd , 32 , prim ) ; if ( ! ( ok & BRD0_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , any , 32 , prim ) ; } if ( ! ( ok & LOCAL_OK ) ) { unsigned int addr_type ; fib_magic ( RTM_DELROUTE , RTN_LOCAL , ifa -> ifa_local , 32 , prim ) ; addr_type = inet_addr_type_dev_table ( dev_net ( dev ) , dev , ifa -> ifa_local ) ; if ( gone && addr_type != RTN_LOCAL ) { if ( fib_sync_down_addr ( dev_net ( dev ) , ifa -> ifa_local ) ) fib_flush ( dev_net ( dev ) ) ; } } # undef LOCAL_OK # undef BRD_OK # undef BRD0_OK # undef BRD1_OK }","}no_promotions : if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ;",2474
442,"buggy line: if ( ! dir_emit_dots ( file , ctx ) )  return 0 ;pos = 2 ;cwe id:CWE-20context: static int proc_sys_readdir ( struct file * file , struct dir_context * ctx ) { struct ctl_table_header * head = grab_header ( file_inode ( file ) ) ; struct ctl_table_header * h = NULL ; struct ctl_table * entry ; struct ctl_dir * ctl_dir ; unsigned long pos ; if ( IS_ERR ( head ) ) return PTR_ERR ( head ) ; ctl_dir = container_of ( head , struct ctl_dir , header ) ; if ( ! dir_emit_dots ( file , ctx ) )  return 0 ;  pos = 2 ; for ( first_entry ( ctl_dir , & h , & entry ) ; h ; next_entry ( & h , & entry ) ) { if ( ! scan ( h , entry , & pos , file , ctx ) ) { sysctl_head_finish ( h ) ; break ; } }  sysctl_head_finish ( head ) ;  return 0 ; }","if ( ! dir_emit_dots ( file , ctx ) ) goto out ;pos = 2 ;",2475
443,"buggy line: sysctl_head_finish ( head ) ;return 0 ;cwe id:CWE-20context: static int proc_sys_readdir ( struct file * file , struct dir_context * ctx ) { struct ctl_table_header * head = grab_header ( file_inode ( file ) ) ; struct ctl_table_header * h = NULL ; struct ctl_table * entry ; struct ctl_dir * ctl_dir ; unsigned long pos ; if ( IS_ERR ( head ) ) return PTR_ERR ( head ) ; ctl_dir = container_of ( head , struct ctl_dir , header ) ; if ( ! dir_emit_dots ( file , ctx ) )  return 0 ;  pos = 2 ; for ( first_entry ( ctl_dir , & h , & entry ) ; h ; next_entry ( & h , & entry ) ) { if ( ! scan ( h , entry , & pos , file , ctx ) ) { sysctl_head_finish ( h ) ; break ; } }  sysctl_head_finish ( head ) ;  return 0 ; }",out : sysctl_head_finish ( head ) ;return 0 ;,2475
444,"buggy line: char * tmp_str ;GF_Err e ;cwe id:CWE-120context: GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ;  char * tmp_str ;  GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; tmp_strsize = ( u32 ) ptr -> size ; tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ;  if ( ! tmp_str [ i ] )  break ; i ++ ;  }  if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) {  int j = 0 ;  tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ;  if ( ! tmp_str [ j ] )  break ; j ++ ; }  if ( j ) {  gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) {  int j = 0 ;  tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ;  if ( ! tmp_str [ j ] )  break ; j ++ ; }  if ( j ) {  gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ;  while ( tmp_strsize ) {  ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ;  if ( ! tmp_str [ i ] )  break ; i ++ ; }  if ( i ) {  ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ;  while ( tmp_strsize ) {  ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ;  if ( ! tmp_str [ i ] )  break ; i ++ ;  }  if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } gf_free ( tmp_str ) ; return GF_OK ; }",char * tmp_str ;Bool zfound = GF_FALSE ;GF_Err e ;,2476
445,"buggy line: if ( ! tmp_str [ i ] )  break ;}if ( i ) {int j = 0 ;tmp_strsize = ( u32 ) ptr -> size ;if ( ! tmp_str [ j ] )  break ;if ( j ) {gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ;int j = 0 ;tmp_strsize = ( u32 ) ptr -> size ;if ( ! tmp_str [ j ] )  break ;if ( j ) {gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;if ( ! tmp_str [ i ] )  break ;if ( i ) {ptr -> drm_data = gf_strdup ( tmp_str ) ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;if ( ! tmp_str [ i ] )  break ;}if ( i ) {cwe id:CWE-120context: GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ;  char * tmp_str ;  GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; tmp_strsize = ( u32 ) ptr -> size ; tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ;  if ( ! tmp_str [ i ] )  break ; i ++ ;  }  if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) {  int j = 0 ;  tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ;  if ( ! tmp_str [ j ] )  break ; j ++ ; }  if ( j ) {  gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) {  int j = 0 ;  tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ;  if ( ! tmp_str [ j ] )  break ; j ++ ; }  if ( j ) {  gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ;  while ( tmp_strsize ) {  ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ;  if ( ! tmp_str [ i ] )  break ; i ++ ; }  if ( i ) {  ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ;  while ( tmp_strsize ) {  ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ;  if ( ! tmp_str [ i ] )  break ; i ++ ;  }  if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } gf_free ( tmp_str ) ; return GF_OK ; }","if ( ! tmp_str [ i ] ) {zfound = GF_TRUE ;break ;}}if ( ! zfound ) return GF_ISOM_INVALID_FILE ;if ( i ) {int j = 0 ;zfound = GF_FALSE ;tmp_strsize = ( u32 ) ptr -> size ;if ( ! tmp_str [ j ] ) {zfound = GF_TRUE ;break ;}if ( ! zfound ) return GF_ISOM_INVALID_FILE ;if ( j ) {gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ;int j = 0 ;zfound = GF_FALSE ;tmp_strsize = ( u32 ) ptr -> size ;if ( ! tmp_str [ j ] ) {zfound = GF_TRUE ;break ;}if ( ! zfound ) return GF_ISOM_INVALID_FILE ;if ( j ) {gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ;zfound = GF_FALSE ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;if ( ! tmp_str [ i ] ) {zfound = GF_TRUE ;break ;}if ( ! zfound ) return GF_ISOM_INVALID_FILE ;if ( i ) {ptr -> drm_data = gf_strdup ( tmp_str ) ;zfound = GF_FALSE ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;if ( ! tmp_str [ i ] ) {zfound = GF_TRUE ;break ;}}if ( ! zfound ) return GF_ISOM_INVALID_FILE ;if ( i ) {",2476
446,"buggy line: struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ;cwe id:CWE-19context: static int ext4_xattr_block_get ( struct inode * inode , int name_index , const char * name , void * buffer , size_t buffer_size ) { struct buffer_head * bh = NULL ; struct ext4_xattr_entry * entry ; size_t size ; int error ;  struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;  ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ; error = - ENODATA ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { bad_block : EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; entry = BFIRST ( bh ) ; error = ext4_xattr_find_entry ( & entry , name_index , name , bh -> b_size , 1 ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; size = le32_to_cpu ( entry -> e_value_size ) ; if ( buffer ) { error = - ERANGE ; if ( size > buffer_size ) goto cleanup ; memcpy ( buffer , bh -> b_data + le16_to_cpu ( entry -> e_value_offs ) , size ) ; } error = size ; cleanup : brelse ( bh ) ; return error ; }","struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ;",2477
447,"buggy line: for ( s = 0 ;s < ns ;tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ;cwe id:CWE-191context: DECLAREcpFunc ( cpDecodedStrips ) { tsize_t stripsize = TIFFStripSize ( in ) ; tdata_t buf = _TIFFmalloc ( stripsize ) ; ( void ) imagewidth ; ( void ) spp ; if ( buf ) { tstrip_t s , ns = TIFFNumberOfStrips ( in ) ; uint32 row = 0 ; _TIFFmemset ( buf , 0 , stripsize ) ;  for ( s = 0 ; s < ns ; s ++ ) {  tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ; if ( TIFFReadEncodedStrip ( in , s , buf , cc ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>strip<S2SV_blank>%lu"" , ( unsigned long ) s ) ; goto bad ; } if ( TIFFWriteEncodedStrip ( out , s , buf , cc ) < 0 ) { TIFFError ( TIFFFileName ( out ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>write<S2SV_blank>strip<S2SV_blank>%lu"" , ( unsigned long ) s ) ; goto bad ; } row += rowsperstrip ; } _TIFFfree ( buf ) ; return 1 ; } else { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%lu<S2SV_blank>"" ""to<S2SV_blank>read<S2SV_blank>strips"" , ( unsigned long ) stripsize ) ; return 0 ; } bad : _TIFFfree ( buf ) ; return 0 ; }","for ( s = 0 ;s < ns && row < imagelength ;tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ;",2478
448,"buggy line: if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ;cwe id:CWE-000context: int main ( void ) { int fd , len , sock_opt ; int error ; struct cn_msg * message ; struct pollfd pfd ; struct nlmsghdr * incoming_msg ; struct cn_msg * incoming_cn_msg ; struct hv_kvp_msg * hv_msg ; char * p ; char * key_value ; char * key_name ; int op ; int pool ; char * if_name ; struct hv_kvp_ipaddr_value * kvp_ip_val ; daemon ( 1 , 0 ) ; openlog ( ""KVP"" , 0 , LOG_USER ) ; syslog ( LOG_INFO , ""KVP<S2SV_blank>starting;<S2SV_blank>pid<S2SV_blank>is:%d"" , getpid ( ) ) ; kvp_get_os_info ( ) ; if ( kvp_file_init ( ) ) { syslog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>the<S2SV_blank>pools"" ) ; exit ( EXIT_FAILURE ) ; } fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; if ( fd < 0 ) { syslog ( LOG_ERR , ""netlink<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed;<S2SV_blank>error:%d"" , fd ) ; exit ( EXIT_FAILURE ) ; } addr . nl_family = AF_NETLINK ; addr . nl_pad = 0 ; addr . nl_pid = 0 ; addr . nl_groups = CN_KVP_IDX ; error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; if ( error < 0 ) { syslog ( LOG_ERR , ""bind<S2SV_blank>failed;<S2SV_blank>error:%d"" , error ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } sock_opt = addr . nl_groups ; setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; message = ( struct cn_msg * ) kvp_send_buffer ; message -> id . idx = CN_KVP_IDX ; message -> id . val = CN_KVP_VAL ; hv_msg = ( struct hv_kvp_msg * ) message -> data ; hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1 ; message -> ack = 0 ; message -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , message ) ; if ( len < 0 ) { syslog ( LOG_ERR , ""netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } pfd . fd = fd ; while ( 1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; pfd . events = POLLIN ; pfd . revents = 0 ; poll ( & pfd , 1 , - 1 ) ; len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ) ;  if ( len < 0 || addr . nl_pid ) {  syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) ) ; close ( fd ) ; return - 1 ; }  incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;  incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ; hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; op = hv_msg -> kvp_hdr . operation ; pool = hv_msg -> kvp_hdr . pool ; hv_msg -> error = HV_S_OK ; if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) ) { in_hand_shake = 0 ; p = ( char * ) hv_msg -> body . kvp_register . version ; lic_version = malloc ( strlen ( p ) + 1 ) ; if ( lic_version ) { strcpy ( lic_version , p ) ; syslog ( LOG_INFO , ""KVP<S2SV_blank>LIC<S2SV_blank>Version:<S2SV_blank>%s"" , lic_version ) ; } else { syslog ( LOG_ERR , ""malloc<S2SV_blank>failed"" ) ; } continue ; } switch ( op ) { case KVP_OP_GET_IP_INFO : kvp_ip_val = & hv_msg -> body . kvp_ip_val ; if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ) ; if ( if_name == NULL ) { hv_msg -> error = HV_E_FAIL ; break ; } error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ) ; if ( error ) hv_msg -> error = error ; free ( if_name ) ; break ; case KVP_OP_SET_IP_INFO : kvp_ip_val = & hv_msg -> body . kvp_ip_val ; if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ) ; if ( if_name == NULL ) { hv_msg -> error = HV_GUID_NOTFOUND ; break ; } error = kvp_set_ip_info ( if_name , kvp_ip_val ) ; if ( error ) hv_msg -> error = error ; free ( if_name ) ; break ; case KVP_OP_SET : if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) hv_msg -> error = HV_S_CONT ; break ; case KVP_OP_GET : if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) hv_msg -> error = HV_S_CONT ; break ; case KVP_OP_DELETE : if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) ) hv_msg -> error = HV_S_CONT ; break ; default : break ; } if ( op != KVP_OP_ENUMERATE ) goto kvp_done ; if ( pool != KVP_POOL_AUTO ) { if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ) hv_msg -> error = HV_S_CONT ; goto kvp_done ; } hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key ; key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value ; switch ( hv_msg -> body . kvp_enum_data . index ) { case FullyQualifiedDomainName : kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""FullyQualifiedDomainName"" ) ; break ; case IntegrationServicesVersion : strcpy ( key_name , ""IntegrationServicesVersion"" ) ; strcpy ( key_value , lic_version ) ; break ; case NetworkAddressIPv4 : kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""NetworkAddressIPv4"" ) ; break ; case NetworkAddressIPv6 : kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""NetworkAddressIPv6"" ) ; break ; case OSBuildNumber : strcpy ( key_value , os_build ) ; strcpy ( key_name , ""OSBuildNumber"" ) ; break ; case OSName : strcpy ( key_value , os_name ) ; strcpy ( key_name , ""OSName"" ) ; break ; case OSMajorVersion : strcpy ( key_value , os_major ) ; strcpy ( key_name , ""OSMajorVersion"" ) ; break ; case OSMinorVersion : strcpy ( key_value , os_minor ) ; strcpy ( key_name , ""OSMinorVersion"" ) ; break ; case OSVersion : strcpy ( key_value , os_version ) ; strcpy ( key_name , ""OSVersion"" ) ; break ; case ProcessorArchitecture : strcpy ( key_value , processor_arch ) ; strcpy ( key_name , ""ProcessorArchitecture"" ) ; break ; default : hv_msg -> error = HV_S_CONT ; break ; } kvp_done : incoming_cn_msg -> id . idx = CN_KVP_IDX ; incoming_cn_msg -> id . val = CN_KVP_VAL ; incoming_cn_msg -> ack = 0 ; incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , incoming_cn_msg ) ; if ( len < 0 ) { syslog ( LOG_ERR , ""net_link<S2SV_blank>send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; exit ( EXIT_FAILURE ) ; } } }","if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;if ( addr . nl_pid ) {syslog ( LOG_WARNING , ""Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u"" , addr . nl_pid ) ;continue ;}incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ;",2479
449,"buggy line: int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  {cwe id:CWE-125context:  int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  { if ( Stream_GetRemainingLength ( s ) < 12 ) return - 1 ; Stream_Read ( s , header -> Signature , 8 ) ; Stream_Read_UINT32 ( s , header -> MessageType ) ; if ( strncmp ( ( char * ) header -> Signature , NTLM_SIGNATURE , 8 ) != 0 ) return - 1 ; return 1 ; }","static int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) {",2480
450,"buggy line: static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx )  {if ( avctx -> bits_per_raw_sample > 8 ) {av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;return avctx -> pix_fmt ;cwe id:CWE-617context: static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx )  {  if ( avctx -> bits_per_raw_sample > 8 ) {  av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;  return avctx -> pix_fmt ; } if ( avctx -> codec -> id == AV_CODEC_ID_MSS2 ) return AV_PIX_FMT_YUV420P ; if ( CONFIG_GRAY && ( avctx -> flags & AV_CODEC_FLAG_GRAY ) ) { if ( avctx -> color_range == AVCOL_RANGE_UNSPECIFIED ) avctx -> color_range = AVCOL_RANGE_MPEG ; return AV_PIX_FMT_GRAY8 ; } return avctx -> pix_fmt = ff_get_format ( avctx , avctx -> codec -> pix_fmts ) ; }",static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx ) {MpegEncContext * s = avctx -> priv_data ;if ( avctx -> bits_per_raw_sample > 8 ) {av_assert1 ( s -> studio_profile ) ;return avctx -> pix_fmt ;,2481
451,"buggy line: struct in6_addr * saddr = NULL , * final_p , final ;struct flowi6 fl6 ;memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;if ( np -> sndflow ) {fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ;IP6_ECN_flow_init ( fl6 . flowlabel ) ;if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) {struct ip6_flowlabel * flowlabel ;flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ;if ( flowlabel == NULL ) return - EINVAL ;fl6_sock_release ( flowlabel ) ;}}if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 1 ;addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ;if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ;if ( addr_type & IPV6_ADDR_LINKLOCAL ) {if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) {if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) return - EINVAL ;sk -> sk_bound_dev_if = usin -> sin6_scope_id ;}if ( ! sk -> sk_bound_dev_if ) return - EINVAL ;}sk -> sk_v6_daddr = usin -> sin6_addr ;np -> flow_label = fl6 . flowlabel ;if ( addr_type == IPV6_ADDR_MAPPED ) {u32 exthdrlen = icsk -> icsk_ext_hdr_len ;struct sockaddr_in sin ;SOCK_DEBUG ( sk , ""connect:<S2SV_blank>ipv4<S2SV_blank>mapped\\\if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ;sin . sin_family = AF_INET ;sin . sin_port = usin -> sin6_port ;sin . sin_addr . s_addr = usin -> sin6_addr . s6_addr32 [ 3 ] ;icsk -> icsk_af_ops = & dccp_ipv6_mapped ;sk -> sk_backlog_rcv = dccp_v4_do_rcv ;err = dccp_v4_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ;if ( err ) {icsk -> icsk_ext_hdr_len = exthdrlen ;icsk -> icsk_af_ops = & dccp_ipv6_af_ops ;sk -> sk_backlog_rcv = dccp_v6_do_rcv ;goto failure ;}np -> saddr = sk -> sk_v6_rcv_saddr ;return err ;}if ( ! ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) saddr = & sk -> sk_v6_rcv_saddr ;fl6 . flowi6_proto = IPPROTO_DCCP ;fl6 . daddr = sk -> sk_v6_daddr ;fl6 . saddr = saddr ? * saddr : np -> saddr ;fl6 . flowi6_oif = sk -> sk_bound_dev_if ;fl6 . fl6_dport = usin -> sin6_port ;fl6 . fl6_sport = inet -> inet_sport ;security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;cwe id:CWE-264context: static int dccp_v6_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ;  struct in6_addr * saddr = NULL , * final_p , final ;  struct flowi6 fl6 ; struct dst_entry * dst ; int addr_type ; int err ; dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; IP6_ECN_flow_init ( fl6 . flowlabel ) ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { struct ip6_flowlabel * flowlabel ; flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; fl6_sock_release ( flowlabel ) ; } } if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 1 ; addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ; if ( addr_type & IPV6_ADDR_LINKLOCAL ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) { if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) return - EINVAL ; sk -> sk_bound_dev_if = usin -> sin6_scope_id ; } if ( ! sk -> sk_bound_dev_if ) return - EINVAL ; } sk -> sk_v6_daddr = usin -> sin6_addr ; np -> flow_label = fl6 . flowlabel ; if ( addr_type == IPV6_ADDR_MAPPED ) { u32 exthdrlen = icsk -> icsk_ext_hdr_len ; struct sockaddr_in sin ; SOCK_DEBUG ( sk , ""connect:<S2SV_blank>ipv4<S2SV_blank>mapped\\n"" ) ; if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ; sin . sin_family = AF_INET ; sin . sin_port = usin -> sin6_port ; sin . sin_addr . s_addr = usin -> sin6_addr . s6_addr32 [ 3 ] ; icsk -> icsk_af_ops = & dccp_ipv6_mapped ; sk -> sk_backlog_rcv = dccp_v4_do_rcv ; err = dccp_v4_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; if ( err ) { icsk -> icsk_ext_hdr_len = exthdrlen ; icsk -> icsk_af_ops = & dccp_ipv6_af_ops ; sk -> sk_backlog_rcv = dccp_v6_do_rcv ; goto failure ; } np -> saddr = sk -> sk_v6_rcv_saddr ; return err ; } if ( ! ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) saddr = & sk -> sk_v6_rcv_saddr ; fl6 . flowi6_proto = IPPROTO_DCCP ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = saddr ? * saddr : np -> saddr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = usin -> sin6_port ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;  final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;  dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto failure ; } if ( saddr == NULL ) { saddr = & fl6 . saddr ; sk -> sk_v6_rcv_saddr = * saddr ; } np -> saddr = * saddr ; inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; __ip6_dst_store ( sk , dst , NULL , NULL ) ; icsk -> icsk_ext_hdr_len = 0 ;  if ( np -> opt != NULL )   icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen +   np -> opt -> opt_nflen ) ;  inet -> inet_dport = usin -> sin6_port ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet6_hash_connect ( & dccp_death_row , sk ) ; if ( err ) goto late_failure ; dp -> dccps_iss = secure_dccpv6_sequence_number ( np -> saddr . s6_addr32 , sk -> sk_v6_daddr . s6_addr32 , inet -> inet_sport , inet -> inet_dport ) ; err = dccp_connect ( sk ) ; if ( err ) goto late_failure ; return 0 ; late_failure : dccp_set_state ( sk , DCCP_CLOSED ) ; __sk_dst_reset ( sk ) ; failure : inet -> inet_dport = 0 ; sk -> sk_route_caps = 0 ; return err ; }","struct in6_addr * saddr = NULL , * final_p , final ;struct ipv6_txoptions * opt ;struct flowi6 fl6 ;memset ( & fl6 , opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",2482
452,"buggy line: if ( np -> opt != NULL )   icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen +   np -> opt -> opt_nflen ) ;inet -> inet_dport = usin -> sin6_port ;cwe id:CWE-264context: static int dccp_v6_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ;  struct in6_addr * saddr = NULL , * final_p , final ;  struct flowi6 fl6 ; struct dst_entry * dst ; int addr_type ; int err ; dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; IP6_ECN_flow_init ( fl6 . flowlabel ) ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { struct ip6_flowlabel * flowlabel ; flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; fl6_sock_release ( flowlabel ) ; } } if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 1 ; addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ; if ( addr_type & IPV6_ADDR_LINKLOCAL ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) { if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) return - EINVAL ; sk -> sk_bound_dev_if = usin -> sin6_scope_id ; } if ( ! sk -> sk_bound_dev_if ) return - EINVAL ; } sk -> sk_v6_daddr = usin -> sin6_addr ; np -> flow_label = fl6 . flowlabel ; if ( addr_type == IPV6_ADDR_MAPPED ) { u32 exthdrlen = icsk -> icsk_ext_hdr_len ; struct sockaddr_in sin ; SOCK_DEBUG ( sk , ""connect:<S2SV_blank>ipv4<S2SV_blank>mapped\\n"" ) ; if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ; sin . sin_family = AF_INET ; sin . sin_port = usin -> sin6_port ; sin . sin_addr . s_addr = usin -> sin6_addr . s6_addr32 [ 3 ] ; icsk -> icsk_af_ops = & dccp_ipv6_mapped ; sk -> sk_backlog_rcv = dccp_v4_do_rcv ; err = dccp_v4_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; if ( err ) { icsk -> icsk_ext_hdr_len = exthdrlen ; icsk -> icsk_af_ops = & dccp_ipv6_af_ops ; sk -> sk_backlog_rcv = dccp_v6_do_rcv ; goto failure ; } np -> saddr = sk -> sk_v6_rcv_saddr ; return err ; } if ( ! ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) saddr = & sk -> sk_v6_rcv_saddr ; fl6 . flowi6_proto = IPPROTO_DCCP ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = saddr ? * saddr : np -> saddr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = usin -> sin6_port ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;  final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;  dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto failure ; } if ( saddr == NULL ) { saddr = & fl6 . saddr ; sk -> sk_v6_rcv_saddr = * saddr ; } np -> saddr = * saddr ; inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; __ip6_dst_store ( sk , dst , NULL , NULL ) ; icsk -> icsk_ext_hdr_len = 0 ;  if ( np -> opt != NULL )   icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen +   np -> opt -> opt_nflen ) ;  inet -> inet_dport = usin -> sin6_port ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet6_hash_connect ( & dccp_death_row , sk ) ; if ( err ) goto late_failure ; dp -> dccps_iss = secure_dccpv6_sequence_number ( np -> saddr . s6_addr32 , sk -> sk_v6_daddr . s6_addr32 , inet -> inet_sport , inet -> inet_dport ) ; err = dccp_connect ( sk ) ; if ( err ) goto late_failure ; return 0 ; late_failure : dccp_set_state ( sk , DCCP_CLOSED ) ; __sk_dst_reset ( sk ) ; failure : inet -> inet_dport = 0 ; sk -> sk_route_caps = 0 ; return err ; }",if ( np -> opt != NULL ) icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + np -> opt -> opt_nflen ) ;inet -> inet_dport = usin -> sin6_port ;,2482
453,"buggy line: cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ;cm -> refresh_golden_frame = 0 ;cm -> refresh_last_frame = 1 ;cm -> refresh_entropy_probs = 1 ;cwe id:CWE-119context: void vp8_change_config ( VP8_COMP * cpi , VP8_CONFIG * oxcf ) { VP8_COMMON * cm = & cpi -> common ; int last_w , last_h , prev_number_of_layers ; if ( ! cpi ) return ; if ( ! oxcf ) return ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif if ( cm -> version != oxcf -> Version ) { cm -> version = oxcf -> Version ; vp8_setup_version ( cm ) ; } last_w = cpi -> oxcf . Width ; last_h = cpi -> oxcf . Height ; prev_number_of_layers = cpi -> oxcf . number_of_layers ; cpi -> oxcf = * oxcf ; switch ( cpi -> oxcf . Mode ) { case MODE_REALTIME : cpi -> pass = 0 ; cpi -> compressor_speed = 2 ; if ( cpi -> oxcf . cpu_used < - 16 ) { cpi -> oxcf . cpu_used = - 16 ; } if ( cpi -> oxcf . cpu_used > 16 ) cpi -> oxcf . cpu_used = 16 ; break ; case MODE_GOODQUALITY : cpi -> pass = 0 ; cpi -> compressor_speed = 1 ; if ( cpi -> oxcf . cpu_used < - 5 ) { cpi -> oxcf . cpu_used = - 5 ; } if ( cpi -> oxcf . cpu_used > 5 ) cpi -> oxcf . cpu_used = 5 ; break ; case MODE_BESTQUALITY : cpi -> pass = 0 ; cpi -> compressor_speed = 0 ; break ; case MODE_FIRSTPASS : cpi -> pass = 1 ; cpi -> compressor_speed = 1 ; break ; case MODE_SECONDPASS : cpi -> pass = 2 ; cpi -> compressor_speed = 1 ; if ( cpi -> oxcf . cpu_used < - 5 ) { cpi -> oxcf . cpu_used = - 5 ; } if ( cpi -> oxcf . cpu_used > 5 ) cpi -> oxcf . cpu_used = 5 ; break ; case MODE_SECONDPASS_BEST : cpi -> pass = 2 ; cpi -> compressor_speed = 0 ; break ; } if ( cpi -> pass == 0 ) cpi -> auto_worst_q = 1 ; cpi -> oxcf . worst_allowed_q = q_trans [ oxcf -> worst_allowed_q ] ; cpi -> oxcf . best_allowed_q = q_trans [ oxcf -> best_allowed_q ] ; cpi -> oxcf . cq_level = q_trans [ cpi -> oxcf . cq_level ] ; if ( oxcf -> fixed_q >= 0 ) { if ( oxcf -> worst_allowed_q < 0 ) cpi -> oxcf . fixed_q = q_trans [ 0 ] ; else cpi -> oxcf . fixed_q = q_trans [ oxcf -> worst_allowed_q ] ; if ( oxcf -> alt_q < 0 ) cpi -> oxcf . alt_q = q_trans [ 0 ] ; else cpi -> oxcf . alt_q = q_trans [ oxcf -> alt_q ] ; if ( oxcf -> key_q < 0 ) cpi -> oxcf . key_q = q_trans [ 0 ] ; else cpi -> oxcf . key_q = q_trans [ oxcf -> key_q ] ; if ( oxcf -> gold_q < 0 ) cpi -> oxcf . gold_q = q_trans [ 0 ] ; else cpi -> oxcf . gold_q = q_trans [ oxcf -> gold_q ] ; } cpi -> baseline_gf_interval = cpi -> oxcf . alt_freq ? cpi -> oxcf . alt_freq : DEFAULT_GF_INTERVAL ;  cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ;  cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> refresh_entropy_probs = 1 ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) cpi -> oxcf . token_partitions = 3 ; # endif if ( cpi -> oxcf . token_partitions >= 0 && cpi -> oxcf . token_partitions <= 3 ) cm -> multi_token_partition = ( TOKEN_PARTITION ) cpi -> oxcf . token_partitions ; setup_features ( cpi ) ; { int i ; for ( i = 0 ; i < MAX_MB_SEGMENTS ; i ++ ) cpi -> segment_encode_breakout [ i ] = cpi -> oxcf . encode_breakout ; } if ( cpi -> oxcf . fixed_q > MAXQ ) cpi -> oxcf . fixed_q = MAXQ ; if ( cpi -> oxcf . end_usage == USAGE_LOCAL_FILE_PLAYBACK ) { cpi -> oxcf . starting_buffer_level = 60000 ; cpi -> oxcf . optimal_buffer_level = 60000 ; cpi -> oxcf . maximum_buffer_size = 240000 ; cpi -> oxcf . starting_buffer_level_in_ms = 60000 ; cpi -> oxcf . optimal_buffer_level_in_ms = 60000 ; cpi -> oxcf . maximum_buffer_size_in_ms = 240000 ; } cpi -> oxcf . target_bandwidth *= 1000 ; cpi -> oxcf . starting_buffer_level = rescale ( ( int ) cpi -> oxcf . starting_buffer_level , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> oxcf . optimal_buffer_level == 0 ) cpi -> oxcf . optimal_buffer_level = cpi -> oxcf . target_bandwidth / 8 ; else cpi -> oxcf . optimal_buffer_level = rescale ( ( int ) cpi -> oxcf . optimal_buffer_level , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> oxcf . maximum_buffer_size == 0 ) cpi -> oxcf . maximum_buffer_size = cpi -> oxcf . target_bandwidth / 8 ; else cpi -> oxcf . maximum_buffer_size = rescale ( ( int ) cpi -> oxcf . maximum_buffer_size , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) { cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; cpi -> buffer_level = cpi -> bits_off_target ; } vp8_new_framerate ( cpi , cpi -> framerate ) ; cpi -> worst_quality = cpi -> oxcf . worst_allowed_q ; cpi -> best_quality = cpi -> oxcf . best_allowed_q ; if ( cpi -> active_worst_quality > cpi -> oxcf . worst_allowed_q ) { cpi -> active_worst_quality = cpi -> oxcf . worst_allowed_q ; } else if ( cpi -> active_worst_quality < cpi -> oxcf . best_allowed_q ) { cpi -> active_worst_quality = cpi -> oxcf . best_allowed_q ; } if ( cpi -> active_best_quality < cpi -> oxcf . best_allowed_q ) { cpi -> active_best_quality = cpi -> oxcf . best_allowed_q ; } else if ( cpi -> active_best_quality > cpi -> oxcf . worst_allowed_q ) { cpi -> active_best_quality = cpi -> oxcf . worst_allowed_q ; } cpi -> buffered_mode = cpi -> oxcf . optimal_buffer_level > 0 ; cpi -> cq_target_quality = cpi -> oxcf . cq_level ; cpi -> drop_frames_allowed = cpi -> oxcf . allow_df && cpi -> buffered_mode ; cpi -> target_bandwidth = cpi -> oxcf . target_bandwidth ; if ( cpi -> oxcf . number_of_layers != prev_number_of_layers ) {  cpi -> temporal_pattern_counter = 0 ;  reset_temporal_layer_change ( cpi , oxcf , prev_number_of_layers ) ; }  cm -> Width = cpi -> oxcf . Width ;   cm -> Height = cpi -> oxcf . Height ;  if ( cpi -> oxcf . Sharpness > 7 ) cpi -> oxcf . Sharpness = 7 ; cm -> sharpness_level = cpi -> oxcf . Sharpness ; if ( cm -> horiz_scale != NORMAL || cm -> vert_scale != NORMAL ) { int UNINITIALIZED_IS_SAFE ( hr ) , UNINITIALIZED_IS_SAFE ( hs ) ; int UNINITIALIZED_IS_SAFE ( vr ) , UNINITIALIZED_IS_SAFE ( vs ) ; Scale2Ratio ( cm -> horiz_scale , & hr , & hs ) ; Scale2Ratio ( cm -> vert_scale , & vr , & vs ) ; cm -> Width = ( hs - 1 + cpi -> oxcf . Width * hr ) / hs ; cm -> Height = ( vs - 1 + cpi -> oxcf . Height * vr ) / vs ; } if ( last_w != cpi -> oxcf . Width || last_h != cpi -> oxcf . Height ) cpi -> force_next_frame_intra = 1 ; if ( ( ( cm -> Width + 15 ) & 0xfffffff0 ) != cm -> yv12_fb [ cm -> lst_fb_idx ] . y_width || ( ( cm -> Height + 15 ) & 0xfffffff0 ) != cm -> yv12_fb [ cm -> lst_fb_idx ] . y_height || cm -> yv12_fb [ cm -> lst_fb_idx ] . y_width == 0 ) { dealloc_raw_frame_buffers ( cpi ) ; alloc_raw_frame_buffers ( cpi ) ; vp8_alloc_compressor_data ( cpi ) ; } if ( cpi -> oxcf . fixed_q >= 0 ) { cpi -> last_q [ 0 ] = cpi -> oxcf . fixed_q ; cpi -> last_q [ 1 ] = cpi -> oxcf . fixed_q ; } cpi -> Speed = cpi -> oxcf . cpu_used ; if ( cpi -> oxcf . lag_in_frames == 0 ) { cpi -> oxcf . allow_lag = 0 ; } else if ( cpi -> oxcf . lag_in_frames > MAX_LAG_BUFFERS ) cpi -> oxcf . lag_in_frames = MAX_LAG_BUFFERS ; cpi -> alt_ref_source = NULL ; cpi -> is_src_frame_alt_ref = 0 ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { if ( ! cpi -> denoiser . yv12_mc_running_avg . buffer_alloc ) { int width = ( cpi -> oxcf . Width + 15 ) & ~ 15 ; int height = ( cpi -> oxcf . Height + 15 ) & ~ 15 ;  vp8_denoiser_allocate ( & cpi -> denoiser , width , height ) ;  } } # endif # if 0 cpi -> frame_distortion = 0 ; cpi -> last_frame_distortion = 0 ; # endif }","
",2483
454,"buggy line: cpi -> temporal_pattern_counter = 0 ;reset_temporal_layer_change ( cpi , oxcf , prev_number_of_layers ) ;cm -> Width = cpi -> oxcf . Width ;cm -> Height = cpi -> oxcf . Height ;if ( cpi -> oxcf . Sharpness > 7 ) cpi -> oxcf . Sharpness = 7 ;cwe id:CWE-119context: void vp8_change_config ( VP8_COMP * cpi , VP8_CONFIG * oxcf ) { VP8_COMMON * cm = & cpi -> common ; int last_w , last_h , prev_number_of_layers ; if ( ! cpi ) return ; if ( ! oxcf ) return ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif if ( cm -> version != oxcf -> Version ) { cm -> version = oxcf -> Version ; vp8_setup_version ( cm ) ; } last_w = cpi -> oxcf . Width ; last_h = cpi -> oxcf . Height ; prev_number_of_layers = cpi -> oxcf . number_of_layers ; cpi -> oxcf = * oxcf ; switch ( cpi -> oxcf . Mode ) { case MODE_REALTIME : cpi -> pass = 0 ; cpi -> compressor_speed = 2 ; if ( cpi -> oxcf . cpu_used < - 16 ) { cpi -> oxcf . cpu_used = - 16 ; } if ( cpi -> oxcf . cpu_used > 16 ) cpi -> oxcf . cpu_used = 16 ; break ; case MODE_GOODQUALITY : cpi -> pass = 0 ; cpi -> compressor_speed = 1 ; if ( cpi -> oxcf . cpu_used < - 5 ) { cpi -> oxcf . cpu_used = - 5 ; } if ( cpi -> oxcf . cpu_used > 5 ) cpi -> oxcf . cpu_used = 5 ; break ; case MODE_BESTQUALITY : cpi -> pass = 0 ; cpi -> compressor_speed = 0 ; break ; case MODE_FIRSTPASS : cpi -> pass = 1 ; cpi -> compressor_speed = 1 ; break ; case MODE_SECONDPASS : cpi -> pass = 2 ; cpi -> compressor_speed = 1 ; if ( cpi -> oxcf . cpu_used < - 5 ) { cpi -> oxcf . cpu_used = - 5 ; } if ( cpi -> oxcf . cpu_used > 5 ) cpi -> oxcf . cpu_used = 5 ; break ; case MODE_SECONDPASS_BEST : cpi -> pass = 2 ; cpi -> compressor_speed = 0 ; break ; } if ( cpi -> pass == 0 ) cpi -> auto_worst_q = 1 ; cpi -> oxcf . worst_allowed_q = q_trans [ oxcf -> worst_allowed_q ] ; cpi -> oxcf . best_allowed_q = q_trans [ oxcf -> best_allowed_q ] ; cpi -> oxcf . cq_level = q_trans [ cpi -> oxcf . cq_level ] ; if ( oxcf -> fixed_q >= 0 ) { if ( oxcf -> worst_allowed_q < 0 ) cpi -> oxcf . fixed_q = q_trans [ 0 ] ; else cpi -> oxcf . fixed_q = q_trans [ oxcf -> worst_allowed_q ] ; if ( oxcf -> alt_q < 0 ) cpi -> oxcf . alt_q = q_trans [ 0 ] ; else cpi -> oxcf . alt_q = q_trans [ oxcf -> alt_q ] ; if ( oxcf -> key_q < 0 ) cpi -> oxcf . key_q = q_trans [ 0 ] ; else cpi -> oxcf . key_q = q_trans [ oxcf -> key_q ] ; if ( oxcf -> gold_q < 0 ) cpi -> oxcf . gold_q = q_trans [ 0 ] ; else cpi -> oxcf . gold_q = q_trans [ oxcf -> gold_q ] ; } cpi -> baseline_gf_interval = cpi -> oxcf . alt_freq ? cpi -> oxcf . alt_freq : DEFAULT_GF_INTERVAL ;  cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ;  cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> refresh_entropy_probs = 1 ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) cpi -> oxcf . token_partitions = 3 ; # endif if ( cpi -> oxcf . token_partitions >= 0 && cpi -> oxcf . token_partitions <= 3 ) cm -> multi_token_partition = ( TOKEN_PARTITION ) cpi -> oxcf . token_partitions ; setup_features ( cpi ) ; { int i ; for ( i = 0 ; i < MAX_MB_SEGMENTS ; i ++ ) cpi -> segment_encode_breakout [ i ] = cpi -> oxcf . encode_breakout ; } if ( cpi -> oxcf . fixed_q > MAXQ ) cpi -> oxcf . fixed_q = MAXQ ; if ( cpi -> oxcf . end_usage == USAGE_LOCAL_FILE_PLAYBACK ) { cpi -> oxcf . starting_buffer_level = 60000 ; cpi -> oxcf . optimal_buffer_level = 60000 ; cpi -> oxcf . maximum_buffer_size = 240000 ; cpi -> oxcf . starting_buffer_level_in_ms = 60000 ; cpi -> oxcf . optimal_buffer_level_in_ms = 60000 ; cpi -> oxcf . maximum_buffer_size_in_ms = 240000 ; } cpi -> oxcf . target_bandwidth *= 1000 ; cpi -> oxcf . starting_buffer_level = rescale ( ( int ) cpi -> oxcf . starting_buffer_level , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> oxcf . optimal_buffer_level == 0 ) cpi -> oxcf . optimal_buffer_level = cpi -> oxcf . target_bandwidth / 8 ; else cpi -> oxcf . optimal_buffer_level = rescale ( ( int ) cpi -> oxcf . optimal_buffer_level , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> oxcf . maximum_buffer_size == 0 ) cpi -> oxcf . maximum_buffer_size = cpi -> oxcf . target_bandwidth / 8 ; else cpi -> oxcf . maximum_buffer_size = rescale ( ( int ) cpi -> oxcf . maximum_buffer_size , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) { cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; cpi -> buffer_level = cpi -> bits_off_target ; } vp8_new_framerate ( cpi , cpi -> framerate ) ; cpi -> worst_quality = cpi -> oxcf . worst_allowed_q ; cpi -> best_quality = cpi -> oxcf . best_allowed_q ; if ( cpi -> active_worst_quality > cpi -> oxcf . worst_allowed_q ) { cpi -> active_worst_quality = cpi -> oxcf . worst_allowed_q ; } else if ( cpi -> active_worst_quality < cpi -> oxcf . best_allowed_q ) { cpi -> active_worst_quality = cpi -> oxcf . best_allowed_q ; } if ( cpi -> active_best_quality < cpi -> oxcf . best_allowed_q ) { cpi -> active_best_quality = cpi -> oxcf . best_allowed_q ; } else if ( cpi -> active_best_quality > cpi -> oxcf . worst_allowed_q ) { cpi -> active_best_quality = cpi -> oxcf . worst_allowed_q ; } cpi -> buffered_mode = cpi -> oxcf . optimal_buffer_level > 0 ; cpi -> cq_target_quality = cpi -> oxcf . cq_level ; cpi -> drop_frames_allowed = cpi -> oxcf . allow_df && cpi -> buffered_mode ; cpi -> target_bandwidth = cpi -> oxcf . target_bandwidth ; if ( cpi -> oxcf . number_of_layers != prev_number_of_layers ) {  cpi -> temporal_pattern_counter = 0 ;  reset_temporal_layer_change ( cpi , oxcf , prev_number_of_layers ) ; }  cm -> Width = cpi -> oxcf . Width ;   cm -> Height = cpi -> oxcf . Height ;  if ( cpi -> oxcf . Sharpness > 7 ) cpi -> oxcf . Sharpness = 7 ; cm -> sharpness_level = cpi -> oxcf . Sharpness ; if ( cm -> horiz_scale != NORMAL || cm -> vert_scale != NORMAL ) { int UNINITIALIZED_IS_SAFE ( hr ) , UNINITIALIZED_IS_SAFE ( hs ) ; int UNINITIALIZED_IS_SAFE ( vr ) , UNINITIALIZED_IS_SAFE ( vs ) ; Scale2Ratio ( cm -> horiz_scale , & hr , & hs ) ; Scale2Ratio ( cm -> vert_scale , & vr , & vs ) ; cm -> Width = ( hs - 1 + cpi -> oxcf . Width * hr ) / hs ; cm -> Height = ( vs - 1 + cpi -> oxcf . Height * vr ) / vs ; } if ( last_w != cpi -> oxcf . Width || last_h != cpi -> oxcf . Height ) cpi -> force_next_frame_intra = 1 ; if ( ( ( cm -> Width + 15 ) & 0xfffffff0 ) != cm -> yv12_fb [ cm -> lst_fb_idx ] . y_width || ( ( cm -> Height + 15 ) & 0xfffffff0 ) != cm -> yv12_fb [ cm -> lst_fb_idx ] . y_height || cm -> yv12_fb [ cm -> lst_fb_idx ] . y_width == 0 ) { dealloc_raw_frame_buffers ( cpi ) ; alloc_raw_frame_buffers ( cpi ) ; vp8_alloc_compressor_data ( cpi ) ; } if ( cpi -> oxcf . fixed_q >= 0 ) { cpi -> last_q [ 0 ] = cpi -> oxcf . fixed_q ; cpi -> last_q [ 1 ] = cpi -> oxcf . fixed_q ; } cpi -> Speed = cpi -> oxcf . cpu_used ; if ( cpi -> oxcf . lag_in_frames == 0 ) { cpi -> oxcf . allow_lag = 0 ; } else if ( cpi -> oxcf . lag_in_frames > MAX_LAG_BUFFERS ) cpi -> oxcf . lag_in_frames = MAX_LAG_BUFFERS ; cpi -> alt_ref_source = NULL ; cpi -> is_src_frame_alt_ref = 0 ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { if ( ! cpi -> denoiser . yv12_mc_running_avg . buffer_alloc ) { int width = ( cpi -> oxcf . Width + 15 ) & ~ 15 ; int height = ( cpi -> oxcf . Height + 15 ) & ~ 15 ;  vp8_denoiser_allocate ( & cpi -> denoiser , width , height ) ;  } } # endif # if 0 cpi -> frame_distortion = 0 ; cpi -> last_frame_distortion = 0 ; # endif }","if ( cpi -> temporal_layer_id > 0 ) {cpi -> temporal_layer_id = 0 ;cpi -> temporal_pattern_counter = 0 ;reset_temporal_layer_change ( cpi , oxcf , prev_number_of_layers ) ;}if ( ! cpi -> initial_width ) {cpi -> initial_width = cpi -> oxcf . Width ;cpi -> initial_height = cpi -> oxcf . Height ;assert ( cm -> Width <= cpi -> initial_width ) ;assert ( cm -> Height <= cpi -> initial_height ) ;}cm -> Width = cpi -> oxcf . Width ;cm -> Height = cpi -> oxcf . Height ;if ( cpi -> oxcf . Sharpness > 7 ) cpi -> oxcf . Sharpness = 7 ;",2483
455,"buggy line: vp8_denoiser_allocate ( & cpi -> denoiser , width , height ) ;}cwe id:CWE-119context: void vp8_change_config ( VP8_COMP * cpi , VP8_CONFIG * oxcf ) { VP8_COMMON * cm = & cpi -> common ; int last_w , last_h , prev_number_of_layers ; if ( ! cpi ) return ; if ( ! oxcf ) return ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif if ( cm -> version != oxcf -> Version ) { cm -> version = oxcf -> Version ; vp8_setup_version ( cm ) ; } last_w = cpi -> oxcf . Width ; last_h = cpi -> oxcf . Height ; prev_number_of_layers = cpi -> oxcf . number_of_layers ; cpi -> oxcf = * oxcf ; switch ( cpi -> oxcf . Mode ) { case MODE_REALTIME : cpi -> pass = 0 ; cpi -> compressor_speed = 2 ; if ( cpi -> oxcf . cpu_used < - 16 ) { cpi -> oxcf . cpu_used = - 16 ; } if ( cpi -> oxcf . cpu_used > 16 ) cpi -> oxcf . cpu_used = 16 ; break ; case MODE_GOODQUALITY : cpi -> pass = 0 ; cpi -> compressor_speed = 1 ; if ( cpi -> oxcf . cpu_used < - 5 ) { cpi -> oxcf . cpu_used = - 5 ; } if ( cpi -> oxcf . cpu_used > 5 ) cpi -> oxcf . cpu_used = 5 ; break ; case MODE_BESTQUALITY : cpi -> pass = 0 ; cpi -> compressor_speed = 0 ; break ; case MODE_FIRSTPASS : cpi -> pass = 1 ; cpi -> compressor_speed = 1 ; break ; case MODE_SECONDPASS : cpi -> pass = 2 ; cpi -> compressor_speed = 1 ; if ( cpi -> oxcf . cpu_used < - 5 ) { cpi -> oxcf . cpu_used = - 5 ; } if ( cpi -> oxcf . cpu_used > 5 ) cpi -> oxcf . cpu_used = 5 ; break ; case MODE_SECONDPASS_BEST : cpi -> pass = 2 ; cpi -> compressor_speed = 0 ; break ; } if ( cpi -> pass == 0 ) cpi -> auto_worst_q = 1 ; cpi -> oxcf . worst_allowed_q = q_trans [ oxcf -> worst_allowed_q ] ; cpi -> oxcf . best_allowed_q = q_trans [ oxcf -> best_allowed_q ] ; cpi -> oxcf . cq_level = q_trans [ cpi -> oxcf . cq_level ] ; if ( oxcf -> fixed_q >= 0 ) { if ( oxcf -> worst_allowed_q < 0 ) cpi -> oxcf . fixed_q = q_trans [ 0 ] ; else cpi -> oxcf . fixed_q = q_trans [ oxcf -> worst_allowed_q ] ; if ( oxcf -> alt_q < 0 ) cpi -> oxcf . alt_q = q_trans [ 0 ] ; else cpi -> oxcf . alt_q = q_trans [ oxcf -> alt_q ] ; if ( oxcf -> key_q < 0 ) cpi -> oxcf . key_q = q_trans [ 0 ] ; else cpi -> oxcf . key_q = q_trans [ oxcf -> key_q ] ; if ( oxcf -> gold_q < 0 ) cpi -> oxcf . gold_q = q_trans [ 0 ] ; else cpi -> oxcf . gold_q = q_trans [ oxcf -> gold_q ] ; } cpi -> baseline_gf_interval = cpi -> oxcf . alt_freq ? cpi -> oxcf . alt_freq : DEFAULT_GF_INTERVAL ;  cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ;  cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> refresh_entropy_probs = 1 ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) cpi -> oxcf . token_partitions = 3 ; # endif if ( cpi -> oxcf . token_partitions >= 0 && cpi -> oxcf . token_partitions <= 3 ) cm -> multi_token_partition = ( TOKEN_PARTITION ) cpi -> oxcf . token_partitions ; setup_features ( cpi ) ; { int i ; for ( i = 0 ; i < MAX_MB_SEGMENTS ; i ++ ) cpi -> segment_encode_breakout [ i ] = cpi -> oxcf . encode_breakout ; } if ( cpi -> oxcf . fixed_q > MAXQ ) cpi -> oxcf . fixed_q = MAXQ ; if ( cpi -> oxcf . end_usage == USAGE_LOCAL_FILE_PLAYBACK ) { cpi -> oxcf . starting_buffer_level = 60000 ; cpi -> oxcf . optimal_buffer_level = 60000 ; cpi -> oxcf . maximum_buffer_size = 240000 ; cpi -> oxcf . starting_buffer_level_in_ms = 60000 ; cpi -> oxcf . optimal_buffer_level_in_ms = 60000 ; cpi -> oxcf . maximum_buffer_size_in_ms = 240000 ; } cpi -> oxcf . target_bandwidth *= 1000 ; cpi -> oxcf . starting_buffer_level = rescale ( ( int ) cpi -> oxcf . starting_buffer_level , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> oxcf . optimal_buffer_level == 0 ) cpi -> oxcf . optimal_buffer_level = cpi -> oxcf . target_bandwidth / 8 ; else cpi -> oxcf . optimal_buffer_level = rescale ( ( int ) cpi -> oxcf . optimal_buffer_level , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> oxcf . maximum_buffer_size == 0 ) cpi -> oxcf . maximum_buffer_size = cpi -> oxcf . target_bandwidth / 8 ; else cpi -> oxcf . maximum_buffer_size = rescale ( ( int ) cpi -> oxcf . maximum_buffer_size , cpi -> oxcf . target_bandwidth , 1000 ) ; if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) { cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; cpi -> buffer_level = cpi -> bits_off_target ; } vp8_new_framerate ( cpi , cpi -> framerate ) ; cpi -> worst_quality = cpi -> oxcf . worst_allowed_q ; cpi -> best_quality = cpi -> oxcf . best_allowed_q ; if ( cpi -> active_worst_quality > cpi -> oxcf . worst_allowed_q ) { cpi -> active_worst_quality = cpi -> oxcf . worst_allowed_q ; } else if ( cpi -> active_worst_quality < cpi -> oxcf . best_allowed_q ) { cpi -> active_worst_quality = cpi -> oxcf . best_allowed_q ; } if ( cpi -> active_best_quality < cpi -> oxcf . best_allowed_q ) { cpi -> active_best_quality = cpi -> oxcf . best_allowed_q ; } else if ( cpi -> active_best_quality > cpi -> oxcf . worst_allowed_q ) { cpi -> active_best_quality = cpi -> oxcf . worst_allowed_q ; } cpi -> buffered_mode = cpi -> oxcf . optimal_buffer_level > 0 ; cpi -> cq_target_quality = cpi -> oxcf . cq_level ; cpi -> drop_frames_allowed = cpi -> oxcf . allow_df && cpi -> buffered_mode ; cpi -> target_bandwidth = cpi -> oxcf . target_bandwidth ; if ( cpi -> oxcf . number_of_layers != prev_number_of_layers ) {  cpi -> temporal_pattern_counter = 0 ;  reset_temporal_layer_change ( cpi , oxcf , prev_number_of_layers ) ; }  cm -> Width = cpi -> oxcf . Width ;   cm -> Height = cpi -> oxcf . Height ;  if ( cpi -> oxcf . Sharpness > 7 ) cpi -> oxcf . Sharpness = 7 ; cm -> sharpness_level = cpi -> oxcf . Sharpness ; if ( cm -> horiz_scale != NORMAL || cm -> vert_scale != NORMAL ) { int UNINITIALIZED_IS_SAFE ( hr ) , UNINITIALIZED_IS_SAFE ( hs ) ; int UNINITIALIZED_IS_SAFE ( vr ) , UNINITIALIZED_IS_SAFE ( vs ) ; Scale2Ratio ( cm -> horiz_scale , & hr , & hs ) ; Scale2Ratio ( cm -> vert_scale , & vr , & vs ) ; cm -> Width = ( hs - 1 + cpi -> oxcf . Width * hr ) / hs ; cm -> Height = ( vs - 1 + cpi -> oxcf . Height * vr ) / vs ; } if ( last_w != cpi -> oxcf . Width || last_h != cpi -> oxcf . Height ) cpi -> force_next_frame_intra = 1 ; if ( ( ( cm -> Width + 15 ) & 0xfffffff0 ) != cm -> yv12_fb [ cm -> lst_fb_idx ] . y_width || ( ( cm -> Height + 15 ) & 0xfffffff0 ) != cm -> yv12_fb [ cm -> lst_fb_idx ] . y_height || cm -> yv12_fb [ cm -> lst_fb_idx ] . y_width == 0 ) { dealloc_raw_frame_buffers ( cpi ) ; alloc_raw_frame_buffers ( cpi ) ; vp8_alloc_compressor_data ( cpi ) ; } if ( cpi -> oxcf . fixed_q >= 0 ) { cpi -> last_q [ 0 ] = cpi -> oxcf . fixed_q ; cpi -> last_q [ 1 ] = cpi -> oxcf . fixed_q ; } cpi -> Speed = cpi -> oxcf . cpu_used ; if ( cpi -> oxcf . lag_in_frames == 0 ) { cpi -> oxcf . allow_lag = 0 ; } else if ( cpi -> oxcf . lag_in_frames > MAX_LAG_BUFFERS ) cpi -> oxcf . lag_in_frames = MAX_LAG_BUFFERS ; cpi -> alt_ref_source = NULL ; cpi -> is_src_frame_alt_ref = 0 ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { if ( ! cpi -> denoiser . yv12_mc_running_avg . buffer_alloc ) { int width = ( cpi -> oxcf . Width + 15 ) & ~ 15 ; int height = ( cpi -> oxcf . Height + 15 ) & ~ 15 ;  vp8_denoiser_allocate ( & cpi -> denoiser , width , height ) ;  } } # endif # if 0 cpi -> frame_distortion = 0 ; cpi -> last_frame_distortion = 0 ; # endif }","vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ;}",2483
456,"buggy line: if ( tcp -> csty & J2K_CP_CSTY_SOP ) {c [ 0 ] = 255 ;cwe id:CWE-787context: static OPJ_BOOL opj_t2_encode_packet ( OPJ_UINT32 tileno , opj_tcd_tile_t * tile , opj_tcp_t * tcp , opj_pi_iterator_t * pi , OPJ_BYTE * dest , OPJ_UINT32 * p_data_written , OPJ_UINT32 length , opj_codestream_info_t * cstr_info , J2K_T2_MODE p_t2_mode , opj_event_mgr_t * p_manager ) { OPJ_UINT32 bandno , cblkno ; OPJ_BYTE * c = dest ; OPJ_UINT32 l_nb_bytes ; OPJ_UINT32 compno = pi -> compno ; OPJ_UINT32 resno = pi -> resno ; OPJ_UINT32 precno = pi -> precno ; OPJ_UINT32 layno = pi -> layno ; OPJ_UINT32 l_nb_blocks ; opj_tcd_band_t * band = 00 ; opj_tcd_cblk_enc_t * cblk = 00 ; opj_tcd_pass_t * pass = 00 ; opj_tcd_tilecomp_t * tilec = & tile -> comps [ compno ] ; opj_tcd_resolution_t * res = & tilec -> resolutions [ resno ] ; opj_bio_t * bio = 00 ; OPJ_BOOL packet_empty = OPJ_TRUE ;  if ( tcp -> csty & J2K_CP_CSTY_SOP ) {  c [ 0 ] = 255 ; c [ 1 ] = 145 ; c [ 2 ] = 0 ; c [ 3 ] = 4 ; # if 0 c [ 4 ] = ( tile -> packno % 65536 ) / 256 ; c [ 5 ] = ( tile -> packno % 65536 ) % 256 ; # else c [ 4 ] = ( tile -> packno >> 8 ) & 0xff ; c [ 5 ] = tile -> packno & 0xff ; # endif c += 6 ; length -= 6 ; } if ( ! layno ) { band = res -> bands ; for ( bandno = 0 ; bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; opj_tgt_reset ( prc -> incltree ) ; opj_tgt_reset ( prc -> imsbtree ) ; l_nb_blocks = prc -> cw * prc -> ch ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { cblk = & prc -> cblks . enc [ cblkno ] ; cblk -> numpasses = 0 ; opj_tgt_setvalue ( prc -> imsbtree , cblkno , band -> numbps - ( OPJ_INT32 ) cblk -> numbps ) ; } } } bio = opj_bio_create ( ) ; if ( ! bio ) { return OPJ_FALSE ; } opj_bio_init_enc ( bio , c , length ) ; band = res -> bands ; for ( bandno = 0 ; bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; cblkno ++ , ++ cblk ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! layer -> numpasses ) { continue ; } packet_empty = OPJ_FALSE ; break ; } if ( ! packet_empty ) { break ; } } opj_bio_write ( bio , packet_empty ? 0 : 1 , 1 ) ; band = res -> bands ; for ( bandno = 0 ; ! packet_empty && bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! cblk -> numpasses && layer -> numpasses ) { opj_tgt_setvalue ( prc -> incltree , cblkno , ( OPJ_INT32 ) layno ) ; } ++ cblk ; } cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; cblkno ++ ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; OPJ_UINT32 increment = 0 ; OPJ_UINT32 nump = 0 ; OPJ_UINT32 len = 0 , passno ; OPJ_UINT32 l_nb_passes ; if ( ! cblk -> numpasses ) { opj_tgt_encode ( bio , prc -> incltree , cblkno , ( OPJ_INT32 ) ( layno + 1 ) ) ; } else { opj_bio_write ( bio , layer -> numpasses != 0 , 1 ) ; } if ( ! layer -> numpasses ) { ++ cblk ; continue ; } if ( ! cblk -> numpasses ) { cblk -> numlenbits = 3 ; opj_tgt_encode ( bio , prc -> imsbtree , cblkno , 999 ) ; } opj_t2_putnumpasses ( bio , layer -> numpasses ) ; l_nb_passes = cblk -> numpasses + layer -> numpasses ; pass = cblk -> passes + cblk -> numpasses ; for ( passno = cblk -> numpasses ; passno < l_nb_passes ; ++ passno ) { ++ nump ; len += pass -> len ; if ( pass -> term || passno == ( cblk -> numpasses + layer -> numpasses ) - 1 ) { increment = ( OPJ_UINT32 ) opj_int_max ( ( OPJ_INT32 ) increment , opj_int_floorlog2 ( ( OPJ_INT32 ) len ) + 1 - ( ( OPJ_INT32 ) cblk -> numlenbits + opj_int_floorlog2 ( ( OPJ_INT32 ) nump ) ) ) ; len = 0 ; nump = 0 ; } ++ pass ; } opj_t2_putcommacode ( bio , ( OPJ_INT32 ) increment ) ; cblk -> numlenbits += increment ; pass = cblk -> passes + cblk -> numpasses ; for ( passno = cblk -> numpasses ; passno < l_nb_passes ; ++ passno ) { nump ++ ; len += pass -> len ; if ( pass -> term || passno == ( cblk -> numpasses + layer -> numpasses ) - 1 ) { opj_bio_write ( bio , ( OPJ_UINT32 ) len , cblk -> numlenbits + ( OPJ_UINT32 ) opj_int_floorlog2 ( ( OPJ_INT32 ) nump ) ) ; len = 0 ; nump = 0 ; } ++ pass ; } ++ cblk ; } } if ( ! opj_bio_flush ( bio ) ) { opj_bio_destroy ( bio ) ; return OPJ_FALSE ; } l_nb_bytes = ( OPJ_UINT32 ) opj_bio_numbytes ( bio ) ; c += l_nb_bytes ; length -= l_nb_bytes ; opj_bio_destroy ( bio ) ;  if ( tcp -> csty & J2K_CP_CSTY_EPH ) {  c [ 0 ] = 255 ; c [ 1 ] = 146 ; c += 2 ; length -= 2 ; } if ( cstr_info && cstr_info -> index_write ) { opj_packet_info_t * info_PK = & cstr_info -> tile [ tileno ] . packet [ cstr_info -> packno ] ; info_PK -> end_ph_pos = ( OPJ_INT32 ) ( c - dest ) ; } band = res -> bands ; for ( bandno = 0 ; ! packet_empty && bandno < res -> numbands ; bandno ++ , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! layer -> numpasses ) { ++ cblk ; continue ; } if ( layer -> len > length ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , layer -> len ) ; } return OPJ_FALSE ; } memcpy ( c , layer -> data , layer -> len ) ; cblk -> numpasses += layer -> numpasses ; c += layer -> len ; length -= layer -> len ; if ( cstr_info && cstr_info -> index_write ) { opj_packet_info_t * info_PK = & cstr_info -> tile [ tileno ] . packet [ cstr_info -> packno ] ; info_PK -> disto += layer -> disto ; if ( cstr_info -> D_max < info_PK -> disto ) { cstr_info -> D_max = info_PK -> disto ; } } ++ cblk ; } } assert ( c >= dest ) ; * p_data_written += ( OPJ_UINT32 ) ( c - dest ) ; return OPJ_TRUE ; }","if ( tcp -> csty & J2K_CP_CSTY_SOP ) {if ( length < 6 ) {if ( p_t2_mode == FINAL_PASS ) {opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\\}return OPJ_FALSE ;}c [ 0 ] = 255 ;",2484
457,"buggy line: if ( tcp -> csty & J2K_CP_CSTY_EPH ) {c [ 0 ] = 255 ;cwe id:CWE-787context: static OPJ_BOOL opj_t2_encode_packet ( OPJ_UINT32 tileno , opj_tcd_tile_t * tile , opj_tcp_t * tcp , opj_pi_iterator_t * pi , OPJ_BYTE * dest , OPJ_UINT32 * p_data_written , OPJ_UINT32 length , opj_codestream_info_t * cstr_info , J2K_T2_MODE p_t2_mode , opj_event_mgr_t * p_manager ) { OPJ_UINT32 bandno , cblkno ; OPJ_BYTE * c = dest ; OPJ_UINT32 l_nb_bytes ; OPJ_UINT32 compno = pi -> compno ; OPJ_UINT32 resno = pi -> resno ; OPJ_UINT32 precno = pi -> precno ; OPJ_UINT32 layno = pi -> layno ; OPJ_UINT32 l_nb_blocks ; opj_tcd_band_t * band = 00 ; opj_tcd_cblk_enc_t * cblk = 00 ; opj_tcd_pass_t * pass = 00 ; opj_tcd_tilecomp_t * tilec = & tile -> comps [ compno ] ; opj_tcd_resolution_t * res = & tilec -> resolutions [ resno ] ; opj_bio_t * bio = 00 ; OPJ_BOOL packet_empty = OPJ_TRUE ;  if ( tcp -> csty & J2K_CP_CSTY_SOP ) {  c [ 0 ] = 255 ; c [ 1 ] = 145 ; c [ 2 ] = 0 ; c [ 3 ] = 4 ; # if 0 c [ 4 ] = ( tile -> packno % 65536 ) / 256 ; c [ 5 ] = ( tile -> packno % 65536 ) % 256 ; # else c [ 4 ] = ( tile -> packno >> 8 ) & 0xff ; c [ 5 ] = tile -> packno & 0xff ; # endif c += 6 ; length -= 6 ; } if ( ! layno ) { band = res -> bands ; for ( bandno = 0 ; bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; opj_tgt_reset ( prc -> incltree ) ; opj_tgt_reset ( prc -> imsbtree ) ; l_nb_blocks = prc -> cw * prc -> ch ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { cblk = & prc -> cblks . enc [ cblkno ] ; cblk -> numpasses = 0 ; opj_tgt_setvalue ( prc -> imsbtree , cblkno , band -> numbps - ( OPJ_INT32 ) cblk -> numbps ) ; } } } bio = opj_bio_create ( ) ; if ( ! bio ) { return OPJ_FALSE ; } opj_bio_init_enc ( bio , c , length ) ; band = res -> bands ; for ( bandno = 0 ; bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; cblkno ++ , ++ cblk ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! layer -> numpasses ) { continue ; } packet_empty = OPJ_FALSE ; break ; } if ( ! packet_empty ) { break ; } } opj_bio_write ( bio , packet_empty ? 0 : 1 , 1 ) ; band = res -> bands ; for ( bandno = 0 ; ! packet_empty && bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! cblk -> numpasses && layer -> numpasses ) { opj_tgt_setvalue ( prc -> incltree , cblkno , ( OPJ_INT32 ) layno ) ; } ++ cblk ; } cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; cblkno ++ ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; OPJ_UINT32 increment = 0 ; OPJ_UINT32 nump = 0 ; OPJ_UINT32 len = 0 , passno ; OPJ_UINT32 l_nb_passes ; if ( ! cblk -> numpasses ) { opj_tgt_encode ( bio , prc -> incltree , cblkno , ( OPJ_INT32 ) ( layno + 1 ) ) ; } else { opj_bio_write ( bio , layer -> numpasses != 0 , 1 ) ; } if ( ! layer -> numpasses ) { ++ cblk ; continue ; } if ( ! cblk -> numpasses ) { cblk -> numlenbits = 3 ; opj_tgt_encode ( bio , prc -> imsbtree , cblkno , 999 ) ; } opj_t2_putnumpasses ( bio , layer -> numpasses ) ; l_nb_passes = cblk -> numpasses + layer -> numpasses ; pass = cblk -> passes + cblk -> numpasses ; for ( passno = cblk -> numpasses ; passno < l_nb_passes ; ++ passno ) { ++ nump ; len += pass -> len ; if ( pass -> term || passno == ( cblk -> numpasses + layer -> numpasses ) - 1 ) { increment = ( OPJ_UINT32 ) opj_int_max ( ( OPJ_INT32 ) increment , opj_int_floorlog2 ( ( OPJ_INT32 ) len ) + 1 - ( ( OPJ_INT32 ) cblk -> numlenbits + opj_int_floorlog2 ( ( OPJ_INT32 ) nump ) ) ) ; len = 0 ; nump = 0 ; } ++ pass ; } opj_t2_putcommacode ( bio , ( OPJ_INT32 ) increment ) ; cblk -> numlenbits += increment ; pass = cblk -> passes + cblk -> numpasses ; for ( passno = cblk -> numpasses ; passno < l_nb_passes ; ++ passno ) { nump ++ ; len += pass -> len ; if ( pass -> term || passno == ( cblk -> numpasses + layer -> numpasses ) - 1 ) { opj_bio_write ( bio , ( OPJ_UINT32 ) len , cblk -> numlenbits + ( OPJ_UINT32 ) opj_int_floorlog2 ( ( OPJ_INT32 ) nump ) ) ; len = 0 ; nump = 0 ; } ++ pass ; } ++ cblk ; } } if ( ! opj_bio_flush ( bio ) ) { opj_bio_destroy ( bio ) ; return OPJ_FALSE ; } l_nb_bytes = ( OPJ_UINT32 ) opj_bio_numbytes ( bio ) ; c += l_nb_bytes ; length -= l_nb_bytes ; opj_bio_destroy ( bio ) ;  if ( tcp -> csty & J2K_CP_CSTY_EPH ) {  c [ 0 ] = 255 ; c [ 1 ] = 146 ; c += 2 ; length -= 2 ; } if ( cstr_info && cstr_info -> index_write ) { opj_packet_info_t * info_PK = & cstr_info -> tile [ tileno ] . packet [ cstr_info -> packno ] ; info_PK -> end_ph_pos = ( OPJ_INT32 ) ( c - dest ) ; } band = res -> bands ; for ( bandno = 0 ; ! packet_empty && bandno < res -> numbands ; bandno ++ , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! layer -> numpasses ) { ++ cblk ; continue ; } if ( layer -> len > length ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , layer -> len ) ; } return OPJ_FALSE ; } memcpy ( c , layer -> data , layer -> len ) ; cblk -> numpasses += layer -> numpasses ; c += layer -> len ; length -= layer -> len ; if ( cstr_info && cstr_info -> index_write ) { opj_packet_info_t * info_PK = & cstr_info -> tile [ tileno ] . packet [ cstr_info -> packno ] ; info_PK -> disto += layer -> disto ; if ( cstr_info -> D_max < info_PK -> disto ) { cstr_info -> D_max = info_PK -> disto ; } } ++ cblk ; } } assert ( c >= dest ) ; * p_data_written += ( OPJ_UINT32 ) ( c - dest ) ; return OPJ_TRUE ; }","if ( tcp -> csty & J2K_CP_CSTY_EPH ) {if ( length < 2 ) {if ( p_t2_mode == FINAL_PASS ) {opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\\}return OPJ_FALSE ;}c [ 0 ] = 255 ;",2484
458,"buggy line: cwe id:CWE-125context: static int lha_read_file_header_1 ( struct archive_read * a , struct lha * lha ) { const unsigned char * p ; size_t extdsize ; int i , err , err2 ; int namelen , padding ; unsigned char headersum , sum_calculated ; err = ARCHIVE_OK ; if ( ( p = __archive_read_ahead ( a , H1_FIXED_SIZE , NULL ) ) == NULL ) return ( truncated_error ( a ) ) ; lha -> header_size = p [ H1_HEADER_SIZE_OFFSET ] + 2 ; headersum = p [ H1_HEADER_SUM_OFFSET ] ; lha -> compsize = archive_le32dec ( p + H1_COMP_SIZE_OFFSET ) ; lha -> origsize = archive_le32dec ( p + H1_ORIG_SIZE_OFFSET ) ; lha -> mtime = lha_dos_time ( p + H1_DOS_TIME_OFFSET ) ; namelen = p [ H1_NAME_LEN_OFFSET ] ; padding = ( ( int ) lha -> header_size ) - H1_FIXED_SIZE - namelen ; if ( namelen > 230 || padding < 0 ) goto invalid ; if ( ( p = __archive_read_ahead ( a , lha -> header_size , NULL ) ) == NULL ) return ( truncated_error ( a ) ) ; for ( i = 0 ; i < namelen ; i ++ ) { if ( p [ i + H1_FILE_NAME_OFFSET ] == 0xff ) goto invalid ; } archive_strncpy ( & lha -> filename , p + H1_FILE_NAME_OFFSET , namelen ) ; lha -> crc = archive_le16dec ( p + H1_FILE_NAME_OFFSET + namelen ) ; lha -> setflag |= CRC_IS_SET ; sum_calculated = lha_calcsum ( 0 , p , 2 , lha -> header_size - 2 ) ; __archive_read_consume ( a , lha -> header_size - 2 ) ; err2 = lha_read_file_extended_header ( a , lha , NULL , 2 , ( size_t ) ( lha -> compsize + 2 ) , & extdsize ) ; if ( err2 < ARCHIVE_WARN ) return ( err2 ) ; if ( err2 < err ) err = err2 ; lha -> compsize -= extdsize - 2 ;  if ( sum_calculated != headersum ) {  archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ; return ( ARCHIVE_FATAL ) ; } return ( err ) ; invalid : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>LHa<S2SV_blank>header"" ) ; return ( ARCHIVE_FATAL ) ; }",if ( lha -> compsize < 0 ) goto invalid ;,2485
459,"buggy line: if ( sum_calculated != headersum ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ;cwe id:CWE-125context: static int lha_read_file_header_1 ( struct archive_read * a , struct lha * lha ) { const unsigned char * p ; size_t extdsize ; int i , err , err2 ; int namelen , padding ; unsigned char headersum , sum_calculated ; err = ARCHIVE_OK ; if ( ( p = __archive_read_ahead ( a , H1_FIXED_SIZE , NULL ) ) == NULL ) return ( truncated_error ( a ) ) ; lha -> header_size = p [ H1_HEADER_SIZE_OFFSET ] + 2 ; headersum = p [ H1_HEADER_SUM_OFFSET ] ; lha -> compsize = archive_le32dec ( p + H1_COMP_SIZE_OFFSET ) ; lha -> origsize = archive_le32dec ( p + H1_ORIG_SIZE_OFFSET ) ; lha -> mtime = lha_dos_time ( p + H1_DOS_TIME_OFFSET ) ; namelen = p [ H1_NAME_LEN_OFFSET ] ; padding = ( ( int ) lha -> header_size ) - H1_FIXED_SIZE - namelen ; if ( namelen > 230 || padding < 0 ) goto invalid ; if ( ( p = __archive_read_ahead ( a , lha -> header_size , NULL ) ) == NULL ) return ( truncated_error ( a ) ) ; for ( i = 0 ; i < namelen ; i ++ ) { if ( p [ i + H1_FILE_NAME_OFFSET ] == 0xff ) goto invalid ; } archive_strncpy ( & lha -> filename , p + H1_FILE_NAME_OFFSET , namelen ) ; lha -> crc = archive_le16dec ( p + H1_FILE_NAME_OFFSET + namelen ) ; lha -> setflag |= CRC_IS_SET ; sum_calculated = lha_calcsum ( 0 , p , 2 , lha -> header_size - 2 ) ; __archive_read_consume ( a , lha -> header_size - 2 ) ; err2 = lha_read_file_extended_header ( a , lha , NULL , 2 , ( size_t ) ( lha -> compsize + 2 ) , & extdsize ) ; if ( err2 < ARCHIVE_WARN ) return ( err2 ) ; if ( err2 < err ) err = err2 ; lha -> compsize -= extdsize - 2 ;  if ( sum_calculated != headersum ) {  archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ; return ( ARCHIVE_FATAL ) ; } return ( err ) ; invalid : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>LHa<S2SV_blank>header"" ) ; return ( ARCHIVE_FATAL ) ; }","if ( sum_calculated != headersum ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ;",2485
460,"buggy line: cwe id:CWE-125context: static bool checkreturn decode_pointer_field ( pb_istream_t * stream , pb_wire_type_t wire_type , pb_field_iter_t * field ) { # ifndef PB_ENABLE_MALLOC PB_UNUSED ( wire_type ) ; PB_UNUSED ( field ) ; PB_RETURN_ERROR ( stream , ""no<S2SV_blank>malloc<S2SV_blank>support"" ) ; # else switch ( PB_HTYPE ( field -> type ) ) { case PB_HTYPE_REQUIRED : case PB_HTYPE_OPTIONAL : case PB_HTYPE_ONEOF : if ( ! check_wire_type ( wire_type , field ) ) PB_RETURN_ERROR ( stream , ""wrong<S2SV_blank>wire<S2SV_blank>type"" ) ; if ( PB_LTYPE_IS_SUBMSG ( field -> type ) && * ( void * * ) field -> pField != NULL ) { pb_release_single_field ( field ) ; } if ( PB_HTYPE ( field -> type ) == PB_HTYPE_ONEOF ) { * ( pb_size_t * ) field -> pSize = field -> tag ; } if ( PB_LTYPE ( field -> type ) == PB_LTYPE_STRING || PB_LTYPE ( field -> type ) == PB_LTYPE_BYTES ) { field -> pData = field -> pField ; return decode_basic_field ( stream , field ) ; } else { if ( ! allocate_field ( stream , field -> pField , field -> data_size , 1 ) ) return false ; field -> pData = * ( void * * ) field -> pField ; initialize_pointer_field ( field -> pData , field ) ; return decode_basic_field ( stream , field ) ; } case PB_HTYPE_REPEATED : if ( wire_type == PB_WT_STRING && PB_LTYPE ( field -> type ) <= PB_LTYPE_LAST_PACKABLE ) { bool status = true ; pb_size_t * size = ( pb_size_t * ) field -> pSize ; size_t allocated_size = * size ; pb_istream_t substream ; if ( ! pb_make_string_substream ( stream , & substream ) ) return false ; while ( substream . bytes_left ) { if ( ( size_t ) * size + 1 > allocated_size ) { allocated_size += ( substream . bytes_left - 1 ) / field -> data_size + 1 ; if ( ! allocate_field ( & substream , field -> pField , field -> data_size , allocated_size ) ) { status = false ; break ; } } field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size ) ; initialize_pointer_field ( field -> pData , field ) ; if ( ! decode_basic_field ( & substream , field ) ) { status = false ; break ; } if ( * size == PB_SIZE_MAX ) { # ifndef PB_NO_ERRMSG stream -> errmsg = ""too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries"" ; # endif status = false ; break ; } ( * size ) ++ ; } if ( ! pb_close_string_substream ( stream , & substream ) ) return false ; return status ; } else { pb_size_t * size = ( pb_size_t * ) field -> pSize ; if ( * size == PB_SIZE_MAX ) PB_RETURN_ERROR ( stream , ""too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries"" ) ; if ( ! check_wire_type ( wire_type , field ) ) PB_RETURN_ERROR ( stream , ""wrong<S2SV_blank>wire<S2SV_blank>type"" ) ;  ( * size ) ++ ;  if ( ! allocate_field ( stream , field -> pField , field -> data_size , * size ) ) return false ; field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size - 1 ) ; initialize_pointer_field ( field -> pData , field ) ; return decode_basic_field ( stream , field ) ; } default : PB_RETURN_ERROR ( stream , ""invalid<S2SV_blank>field<S2SV_blank>type"" ) ; } # endif }","if ( ! allocate_field ( stream , field -> pField , field -> data_size , ( size_t ) ( * size + 1 ) ) ) return false ;field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size ) ;",2486
461,"buggy line: }if ( ! pb_close_string_substream ( stream , & substream ) ) return false ;return status ;}else {pb_size_t * size = ( pb_size_t * ) field -> pSize ;if ( * size == PB_SIZE_MAX ) PB_RETURN_ERROR ( stream , ""too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries"" ) ;if ( ! check_wire_type ( wire_type , field ) ) PB_RETURN_ERROR ( stream , ""wrong<S2SV_blank>wire<S2SV_blank>type"" ) ;( * size ) ++ ;if ( ! allocate_field ( stream , field -> pField , field -> data_size , * size ) ) return false ;field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size - 1 ) ;cwe id:CWE-125context: static bool checkreturn decode_pointer_field ( pb_istream_t * stream , pb_wire_type_t wire_type , pb_field_iter_t * field ) { # ifndef PB_ENABLE_MALLOC PB_UNUSED ( wire_type ) ; PB_UNUSED ( field ) ; PB_RETURN_ERROR ( stream , ""no<S2SV_blank>malloc<S2SV_blank>support"" ) ; # else switch ( PB_HTYPE ( field -> type ) ) { case PB_HTYPE_REQUIRED : case PB_HTYPE_OPTIONAL : case PB_HTYPE_ONEOF : if ( ! check_wire_type ( wire_type , field ) ) PB_RETURN_ERROR ( stream , ""wrong<S2SV_blank>wire<S2SV_blank>type"" ) ; if ( PB_LTYPE_IS_SUBMSG ( field -> type ) && * ( void * * ) field -> pField != NULL ) { pb_release_single_field ( field ) ; } if ( PB_HTYPE ( field -> type ) == PB_HTYPE_ONEOF ) { * ( pb_size_t * ) field -> pSize = field -> tag ; } if ( PB_LTYPE ( field -> type ) == PB_LTYPE_STRING || PB_LTYPE ( field -> type ) == PB_LTYPE_BYTES ) { field -> pData = field -> pField ; return decode_basic_field ( stream , field ) ; } else { if ( ! allocate_field ( stream , field -> pField , field -> data_size , 1 ) ) return false ; field -> pData = * ( void * * ) field -> pField ; initialize_pointer_field ( field -> pData , field ) ; return decode_basic_field ( stream , field ) ; } case PB_HTYPE_REPEATED : if ( wire_type == PB_WT_STRING && PB_LTYPE ( field -> type ) <= PB_LTYPE_LAST_PACKABLE ) { bool status = true ; pb_size_t * size = ( pb_size_t * ) field -> pSize ; size_t allocated_size = * size ; pb_istream_t substream ; if ( ! pb_make_string_substream ( stream , & substream ) ) return false ; while ( substream . bytes_left ) { if ( ( size_t ) * size + 1 > allocated_size ) { allocated_size += ( substream . bytes_left - 1 ) / field -> data_size + 1 ; if ( ! allocate_field ( & substream , field -> pField , field -> data_size , allocated_size ) ) { status = false ; break ; } } field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size ) ; initialize_pointer_field ( field -> pData , field ) ; if ( ! decode_basic_field ( & substream , field ) ) { status = false ; break ; } if ( * size == PB_SIZE_MAX ) { # ifndef PB_NO_ERRMSG stream -> errmsg = ""too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries"" ; # endif status = false ; break ; } ( * size ) ++ ; } if ( ! pb_close_string_substream ( stream , & substream ) ) return false ; return status ; } else { pb_size_t * size = ( pb_size_t * ) field -> pSize ; if ( * size == PB_SIZE_MAX ) PB_RETURN_ERROR ( stream , ""too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries"" ) ; if ( ! check_wire_type ( wire_type , field ) ) PB_RETURN_ERROR ( stream , ""wrong<S2SV_blank>wire<S2SV_blank>type"" ) ;  ( * size ) ++ ;  if ( ! allocate_field ( stream , field -> pField , field -> data_size , * size ) ) return false ; field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size - 1 ) ; initialize_pointer_field ( field -> pData , field ) ; return decode_basic_field ( stream , field ) ; } default : PB_RETURN_ERROR ( stream , ""invalid<S2SV_blank>field<S2SV_blank>type"" ) ; } # endif }","
",2486
462,"buggy line: rfcomm_dlc_accept ( d ) ;return 0 ;cwe id:CWE-200context: static int rfcomm_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rfcomm_dlc * d = rfcomm_pi ( sk ) -> dlc ; int len ; if ( test_and_clear_bit ( RFCOMM_DEFER_SETUP , & d -> flags ) ) {  rfcomm_dlc_accept ( d ) ;  return 0 ; } len = bt_sock_stream_recvmsg ( iocb , sock , msg , size , flags ) ; lock_sock ( sk ) ; if ( ! ( flags & MSG_PEEK ) && len > 0 ) atomic_sub ( len , & sk -> sk_rmem_alloc ) ; if ( atomic_read ( & sk -> sk_rmem_alloc ) <= ( sk -> sk_rcvbuf >> 2 ) ) rfcomm_dlc_unthrottle ( rfcomm_pi ( sk ) -> dlc ) ; release_sock ( sk ) ; return len ; }",rfcomm_dlc_accept ( d ) ;msg -> msg_namelen = 0 ;return 0 ;,2487
463,"buggy line: static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {cwe id:CWE-119context:  static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) { int update = va_arg ( args , int ) ; vp8_update_reference ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }","static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2488
464,"buggy line: memcpy ( & bss_cfg -> wmm_info , wmm_ie +   sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;priv -> wmm_enabled = 1 ;cwe id:CWE-787context: void mwifiex_set_wmm_params ( struct mwifiex_private * priv , struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { const u8 * vendor_ie ; const u8 * wmm_ie ; u8 wmm_oui [ ] = { 0x00 , 0x50 , 0xf2 , 0x02 } ; vendor_ie = cfg80211_find_vendor_ie ( WLAN_OUI_MICROSOFT , WLAN_OUI_TYPE_MICROSOFT_WMM , params -> beacon . tail , params -> beacon . tail_len ) ; if ( vendor_ie ) { wmm_ie = vendor_ie ;  memcpy ( & bss_cfg -> wmm_info , wmm_ie +   sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;  priv -> wmm_enabled = 1 ; } else { memset ( & bss_cfg -> wmm_info , 0 , sizeof ( bss_cfg -> wmm_info ) ) ; memcpy ( & bss_cfg -> wmm_info . oui , wmm_oui , sizeof ( wmm_oui ) ) ; bss_cfg -> wmm_info . subtype = MWIFIEX_WMM_SUBTYPE ; bss_cfg -> wmm_info . version = MWIFIEX_WMM_VERSION ; priv -> wmm_enabled = 0 ; } bss_cfg -> qos_info = 0x00 ; return ; }","if ( * ( wmm_ie + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return ;memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;priv -> wmm_enabled = 1 ;",2489
465,"buggy line: FILE * file = fopen ( dump_file , ""w"" ) ;if ( ! file ) {cwe id:CWE-59context: void vrrp_print_data ( void ) {  FILE * file = fopen ( dump_file , ""w"" ) ;  if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , dump_file , errno , strerror ( errno ) ) ; return ; } dump_data_vrrp ( file ) ; fclose ( file ) ; }","FILE * file = fopen_safe ( dump_file , ""w"" ) ;if ( ! file ) {",2490
466,"buggy line: if ( d_mountpoint ( dentry ) )  return 1 ;if ( nfsd4_is_junction ( dentry ) ) return 1 ;if ( ! ( exp -> ex_flags & NFSEXP_V4ROOT ) )  return 0 ;return d_inode ( dentry ) != NULL ;}cwe id:CWE-404context: int nfsd_mountpoint ( struct dentry * dentry , struct svc_export * exp ) {  if ( d_mountpoint ( dentry ) )  return 1 ; if ( nfsd4_is_junction ( dentry ) ) return 1 ;  if ( ! ( exp -> ex_flags & NFSEXP_V4ROOT ) )  return 0 ;  return d_inode ( dentry ) != NULL ;  }",if ( ! d_inode ( dentry ) ) return 0 ;if ( d_mountpoint ( dentry ) ) return 2 ;return 0 ;},2491
467,"buggy line: StringValue ( data ) ;in = ( unsigned char * ) RSTRING_PTR ( data ) ;cwe id:CWE-310context: static VALUE ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; unsigned char * in ; long in_len , out_len ; VALUE data , str ; rb_scan_args ( argc , argv , ""11"" , & data , & str ) ;  StringValue ( data ) ;  in = ( unsigned char * ) RSTRING_PTR ( data ) ; if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) ossl_raise ( rb_eArgError , ""data<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty"" ) ; GetCipher ( self , ctx ) ; out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ; if ( out_len <= 0 ) { ossl_raise ( rb_eRangeError , ""data<S2SV_blank>too<S2SV_blank>big<S2SV_blank>to<S2SV_blank>make<S2SV_blank>output<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>bytes"" , in_len ) ; } if ( NIL_P ( str ) ) { str = rb_str_new ( 0 , out_len ) ; } else { StringValue ( str ) ; rb_str_resize ( str , out_len ) ; } if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) ossl_raise ( eCipherError , NULL ) ; assert ( out_len < RSTRING_LEN ( str ) ) ; rb_str_set_len ( str , out_len ) ; return str ; }","if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ;StringValue ( data ) ;in = ( unsigned char * ) RSTRING_PTR ( data ) ;",2492
468,"buggy line: p = strchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;cwe id:CWE-20context: error_t httpClientSetUri ( HttpClientContext * context , const char_t * uri ) { size_t m ; size_t n ; char_t * p ; char_t * q ; if ( context == NULL || uri == NULL ) return ERROR_INVALID_PARAMETER ; if ( uri [ 0 ] == '\\0' ) return ERROR_INVALID_PARAMETER ; if ( context -> requestState != HTTP_REQ_STATE_FORMAT_HEADER ) return ERROR_WRONG_STATE ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ;  p = strchr ( context -> buffer , '<S2SV_blank>' ) ;  if ( p == NULL ) return ERROR_INVALID_SYNTAX ; p ++ ; q = strpbrk ( p , ""<S2SV_blank>?"" ) ; if ( q == NULL ) return ERROR_INVALID_SYNTAX ; m = q - p ; n = osStrlen ( uri ) ; if ( ( context -> bufferLen + n - m ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + n , q , context -> buffer + context -> bufferLen + 1 - q ) ; osStrncpy ( p , uri , n ) ; context -> bufferLen = context -> bufferLen + n - m ; return NO_ERROR ; }","p = osStrchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;",2493
469,"buggy line: int pkt_len , pktnum , hr , min , sec , csec ;char channel [ 10 ] , direction [ 10 ] ;cwe id:CWE-20context: static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ;  int pkt_len , pktnum , hr , min , sec , csec ;  char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , ""%9d]<S2SV_blank>%2d:%2d:%2d.%9d<S2SV_blank>%9s<S2SV_blank>%9s"" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>record<S2SV_blank>header<S2SV_blank>isn\'t<S2SV_blank>valid"" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\0' ; } while ( strcmp ( line , ""OFFSET<S2SV_blank>0001-0203"" ) != 0 ) ;  num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ;  if ( num_items_scanned != 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ; return FALSE ; }  phdr -> rec_type = REC_TYPE_PACKET ;  phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; phdr -> ts . secs = hr * 3600 + min * 60 + sec ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> caplen = pkt_len ; phdr -> len = pkt_len ; switch ( channel [ 0 ] ) { case 'B' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = ( guint8 ) strtol ( & channel [ 1 ] , NULL , 10 ) ; break ; case 'D' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = 0 ; break ; default : phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; pseudo_header -> eth . fcs_len = - 1 ; break ; }  ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ;  pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( ! parse_single_hex_dump_line ( line , pd , i * 16 ) ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>not<S2SV_blank>valid"" ) ; return FALSE ; } } return TRUE ; }","guint pkt_len ;int pktnum , hr , min , sec , csec ;char channel [ 10 ] , direction [ 10 ] ;",2494
470,"buggy line: num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {phdr -> rec_type = REC_TYPE_PACKET ;phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ;cwe id:CWE-20context: static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ;  int pkt_len , pktnum , hr , min , sec , csec ;  char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , ""%9d]<S2SV_blank>%2d:%2d:%2d.%9d<S2SV_blank>%9s<S2SV_blank>%9s"" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>record<S2SV_blank>header<S2SV_blank>isn\'t<S2SV_blank>valid"" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\0' ; } while ( strcmp ( line , ""OFFSET<S2SV_blank>0001-0203"" ) != 0 ) ;  num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ;  if ( num_items_scanned != 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ; return FALSE ; }  phdr -> rec_type = REC_TYPE_PACKET ;  phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; phdr -> ts . secs = hr * 3600 + min * 60 + sec ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> caplen = pkt_len ; phdr -> len = pkt_len ; switch ( channel [ 0 ] ) { case 'B' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = ( guint8 ) strtol ( & channel [ 1 ] , NULL , 10 ) ; break ; case 'D' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = 0 ; break ; default : phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; pseudo_header -> eth . fcs_len = - 1 ; break ; }  ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ;  pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( ! parse_single_hex_dump_line ( line , pd , i * 16 ) ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>not<S2SV_blank>valid"" ) ; return FALSE ; } } return TRUE ; }","num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {if ( pkt_len > WTAP_MAX_PACKET_SIZE ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup_printf ( ""toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ;return FALSE ;}phdr -> rec_type = REC_TYPE_PACKET ;phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ;",2494
471,"buggy line: ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ;pd = ws_buffer_start_ptr ( buf ) ;cwe id:CWE-20context: static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ;  int pkt_len , pktnum , hr , min , sec , csec ;  char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , ""%9d]<S2SV_blank>%2d:%2d:%2d.%9d<S2SV_blank>%9s<S2SV_blank>%9s"" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>record<S2SV_blank>header<S2SV_blank>isn\'t<S2SV_blank>valid"" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\0' ; } while ( strcmp ( line , ""OFFSET<S2SV_blank>0001-0203"" ) != 0 ) ;  num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ;  if ( num_items_scanned != 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ; return FALSE ; }  phdr -> rec_type = REC_TYPE_PACKET ;  phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; phdr -> ts . secs = hr * 3600 + min * 60 + sec ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> caplen = pkt_len ; phdr -> len = pkt_len ; switch ( channel [ 0 ] ) { case 'B' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = ( guint8 ) strtol ( & channel [ 1 ] , NULL , 10 ) ; break ; case 'D' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = 0 ; break ; default : phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; pseudo_header -> eth . fcs_len = - 1 ; break ; }  ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ;  pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( ! parse_single_hex_dump_line ( line , pd , i * 16 ) ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>not<S2SV_blank>valid"" ) ; return FALSE ; } } return TRUE ; }","ws_buffer_assure_space ( buf , pkt_len ) ;pd = ws_buffer_start_ptr ( buf ) ;",2494
472,"buggy line: long timeo ;msg -> msg_namelen = 0 ;cwe id:CWE-20context: static int llc_ui_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sockaddr_llc * uaddr = ( struct sockaddr_llc * ) msg -> msg_name ; const int nonblock = flags & MSG_DONTWAIT ; struct sk_buff * skb = NULL ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; unsigned long cpu_flags ; size_t copied = 0 ; u32 peek_seq = 0 ; u32 * seq ; unsigned long used ; int target ;  long timeo ;  msg -> msg_namelen = 0 ; lock_sock ( sk ) ; copied = - ENOTCONN ; if ( unlikely ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_LISTEN ) ) goto out ; timeo = sock_rcvtimeo ( sk , nonblock ) ; seq = & llc -> copied_seq ; if ( flags & MSG_PEEK ) { peek_seq = llc -> copied_seq ; seq = & peek_seq ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; copied = 0 ; do { u32 offset ; if ( signal_pending ( current ) ) { if ( copied ) break ; copied = timeo ? sock_intr_errno ( timeo ) : - EAGAIN ; break ; } skb = skb_peek ( & sk -> sk_receive_queue ) ; if ( skb ) { offset = * seq ; goto found_ok_skb ; } if ( copied >= target && ! sk -> sk_backlog . tail ) break ; if ( copied ) { if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ! timeo || ( flags & MSG_PEEK ) ) break ; } else { if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { copied = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) { copied = - ENOTCONN ; break ; } break ; } if ( ! timeo ) { copied = - EAGAIN ; break ; } } if ( copied >= target ) { release_sock ( sk ) ; lock_sock ( sk ) ; } else sk_wait_data ( sk , & timeo ) ; if ( ( flags & MSG_PEEK ) && peek_seq != llc -> copied_seq ) { net_dbg_ratelimited ( ""LLC(%s:%d):<S2SV_blank>Application<S2SV_blank>bug,<S2SV_blank>race<S2SV_blank>in<S2SV_blank>MSG_PEEK\\n"" , current -> comm , task_pid_nr ( current ) ) ; peek_seq = llc -> copied_seq ; } continue ; found_ok_skb : used = skb -> len - offset ; if ( len < used ) used = len ; if ( ! ( flags & MSG_TRUNC ) ) { int rc = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , used ) ; if ( rc ) { if ( ! copied ) copied = - EFAULT ; break ; } } * seq += used ; copied += used ; len -= used ; if ( sk -> sk_type != SOCK_STREAM ) goto copy_uaddr ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } if ( used + offset < skb -> len ) continue ; } while ( len > 0 ) ; out : release_sock ( sk ) ; return copied ; copy_uaddr : if ( uaddr != NULL && skb != NULL ) { memcpy ( uaddr , llc_ui_skb_cb ( skb ) , sizeof ( * uaddr ) ) ; msg -> msg_namelen = sizeof ( * uaddr ) ; } if ( llc_sk ( sk ) -> cmsg_flags ) llc_cmsg_rcv ( msg , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } goto out ; }",long timeo ;,2495
473,"buggy line: int nNew = MAX ( 128 , p -> nAlloc * 2 ) ;while ( nByte > nNew ) nNew = nNew * 2 ;cwe id:CWE-190context: static int vdbePmaReadBlob ( PmaReader * p , int nByte , u8 * * ppOut ) { int iBuf ; int nAvail ; if ( p -> aMap ) { * ppOut = & p -> aMap [ p -> iReadOff ] ; p -> iReadOff += nByte ; return SQLITE_OK ; } assert ( p -> aBuffer ) ; iBuf = p -> iReadOff % p -> nBuffer ; if ( iBuf == 0 ) { int nRead ; int rc ; if ( ( p -> iEof - p -> iReadOff ) > ( i64 ) p -> nBuffer ) { nRead = p -> nBuffer ; } else { nRead = ( int ) ( p -> iEof - p -> iReadOff ) ; } assert ( nRead > 0 ) ; rc = sqlite3OsRead ( p -> pFd , p -> aBuffer , nRead , p -> iReadOff ) ; assert ( rc != SQLITE_IOERR_SHORT_READ ) ; if ( rc != SQLITE_OK ) return rc ; } nAvail = p -> nBuffer - iBuf ; if ( nByte <= nAvail ) { * ppOut = & p -> aBuffer [ iBuf ] ; p -> iReadOff += nByte ; } else { int nRem ; if ( p -> nAlloc < nByte ) { u8 * aNew ;  int nNew = MAX ( 128 , p -> nAlloc * 2 ) ;  while ( nByte > nNew ) nNew = nNew * 2 ; aNew = sqlite3Realloc ( p -> aAlloc , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; p -> nAlloc = nNew ; p -> aAlloc = aNew ; } memcpy ( p -> aAlloc , & p -> aBuffer [ iBuf ] , nAvail ) ; p -> iReadOff += nAvail ; nRem = nByte - nAvail ; while ( nRem > 0 ) { int rc ; int nCopy ; u8 * aNext ; nCopy = nRem ; if ( nRem > p -> nBuffer ) nCopy = p -> nBuffer ; rc = vdbePmaReadBlob ( p , nCopy , & aNext ) ; if ( rc != SQLITE_OK ) return rc ; assert ( aNext != p -> aAlloc ) ; memcpy ( & p -> aAlloc [ nByte - nRem ] , aNext , nCopy ) ; nRem -= nCopy ; } * ppOut = p -> aAlloc ; } return SQLITE_OK ; }","sqlite3_int64 nNew = MAX ( 128 , 2 * ( sqlite3_int64 ) p -> nAlloc ) ;while ( nByte > nNew ) nNew = nNew * 2 ;",2496
474,"buggy line: void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest ,  int stride , int eob ) {cwe id:CWE-119context:  void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest ,  int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct16x16_add ( input , dest , stride , eob ) ; } else { vp9_iht16x16_256_add ( input , dest , stride , tx_type ) ; } }","void vp9_iht16x16_add ( TX_TYPE tx_type , const tran_low_t * input , uint8_t * dest , int stride , int eob ) {",2497
475,"buggy line: xfs_daddr_t blkno = map [ 0 ] . bm_bn ;int numblks = 0 ;pag = xfs_perag_get ( btp -> bt_mount ,  xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ;cwe id:CWE-20context: xfs_buf_t * _xfs_buf_find ( struct xfs_buftarg * btp , struct xfs_buf_map * map , int nmaps , xfs_buf_flags_t flags , xfs_buf_t * new_bp ) { size_t numbytes ; struct xfs_perag * pag ; struct rb_node * * rbp ; struct rb_node * parent ; xfs_buf_t * bp ;  xfs_daddr_t blkno = map [ 0 ] . bm_bn ;  int numblks = 0 ; int i ; for ( i = 0 ; i < nmaps ; i ++ ) numblks += map [ i ] . bm_len ; numbytes = BBTOB ( numblks ) ; ASSERT ( ! ( numbytes < ( 1 << btp -> bt_sshift ) ) ) ; ASSERT ( ! ( BBTOB ( blkno ) & ( xfs_off_t ) btp -> bt_smask ) ) ;  pag = xfs_perag_get ( btp -> bt_mount ,  xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ; spin_lock ( & pag -> pag_buf_lock ) ; rbp = & pag -> pag_buf_tree . rb_node ; parent = NULL ; bp = NULL ; while ( * rbp ) { parent = * rbp ; bp = rb_entry ( parent , struct xfs_buf , b_rbnode ) ; if ( blkno < bp -> b_bn ) rbp = & ( * rbp ) -> rb_left ; else if ( blkno > bp -> b_bn ) rbp = & ( * rbp ) -> rb_right ; else { if ( bp -> b_length != numblks ) { ASSERT ( bp -> b_flags & XBF_STALE ) ; rbp = & ( * rbp ) -> rb_right ; continue ; } atomic_inc ( & bp -> b_hold ) ; goto found ; } } if ( new_bp ) { rb_link_node ( & new_bp -> b_rbnode , parent , rbp ) ; rb_insert_color ( & new_bp -> b_rbnode , & pag -> pag_buf_tree ) ; new_bp -> b_pag = pag ; spin_unlock ( & pag -> pag_buf_lock ) ; } else { XFS_STATS_INC ( xb_miss_locked ) ; spin_unlock ( & pag -> pag_buf_lock ) ; xfs_perag_put ( pag ) ; } return new_bp ; found : spin_unlock ( & pag -> pag_buf_lock ) ; xfs_perag_put ( pag ) ; if ( ! xfs_buf_trylock ( bp ) ) { if ( flags & XBF_TRYLOCK ) { xfs_buf_rele ( bp ) ; XFS_STATS_INC ( xb_busy_locked ) ; return NULL ; } xfs_buf_lock ( bp ) ; XFS_STATS_INC ( xb_get_locked_waited ) ; } if ( bp -> b_flags & XBF_STALE ) { ASSERT ( ( bp -> b_flags & _XBF_DELWRI_Q ) == 0 ) ; ASSERT ( bp -> b_iodone == NULL ) ; bp -> b_flags &= _XBF_KMEM | _XBF_PAGES ; bp -> b_ops = NULL ; } trace_xfs_buf_find ( bp , flags , _RET_IP_ ) ; XFS_STATS_INC ( xb_get_locked ) ; return bp ; }","xfs_daddr_t blkno = map [ 0 ] . bm_bn ;xfs_daddr_t eofs ;int numblks = 0 ;eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ;if ( blkno >= eofs ) {xfs_alert ( btp -> bt_mount , ""%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>"" , __func__ , blkno , eofs ) ;return NULL ;}pag = xfs_perag_get ( btp -> bt_mount , xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ;",2498
476,"buggy line: fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;fptr_orig = io_get_open_fptr ( mrb , orig ) ;cwe id:CWE-416context: mrb_value mrb_io_initialize_copy ( mrb_state * mrb , mrb_value copy ) { mrb_value orig ; mrb_value buf ; struct mrb_io * fptr_copy ; struct mrb_io * fptr_orig ; mrb_bool failed = TRUE ; mrb_get_args ( mrb , ""o"" , & orig ) ;  fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;  if ( fptr_copy != NULL ) { fptr_finalize ( mrb , fptr_copy , FALSE ) ; mrb_free ( mrb , fptr_copy ) ; }  fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;  fptr_orig = io_get_open_fptr ( mrb , orig ) ; DATA_TYPE ( copy ) = & mrb_io_type ; DATA_PTR ( copy ) = fptr_copy ; buf = mrb_iv_get ( mrb , orig , mrb_intern_cstr ( mrb , ""@buf"" ) ) ; mrb_iv_set ( mrb , copy , mrb_intern_cstr ( mrb , ""@buf"" ) , buf ) ; fptr_copy -> fd = mrb_dup ( mrb , fptr_orig -> fd , & failed ) ; if ( failed ) { mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd ) ; if ( fptr_orig -> fd2 != - 1 ) { fptr_copy -> fd2 = mrb_dup ( mrb , fptr_orig -> fd2 , & failed ) ; if ( failed ) { close ( fptr_copy -> fd ) ; mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd2 ) ; } fptr_copy -> pid = fptr_orig -> pid ; fptr_copy -> readable = fptr_orig -> readable ; fptr_copy -> writable = fptr_orig -> writable ; fptr_copy -> sync = fptr_orig -> sync ; fptr_copy -> is_socket = fptr_orig -> is_socket ; return copy ; }","fptr_orig = io_get_open_fptr ( mrb , orig ) ;fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;",2499
477,"buggy line: ret = poll ( pfds , 1 , 50 ) ;if ( ret < 0 ) {cwe id:CWE-284context: static void * btif_hh_poll_event_thread ( void * arg ) { btif_hh_device_t * p_dev = arg ; APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>Thread<S2SV_blank>created<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; struct pollfd pfds [ 1 ] ; int ret ; pfds [ 0 ] . fd = p_dev -> fd ; pfds [ 0 ] . events = POLLIN ; uhid_set_non_blocking ( p_dev -> fd ) ; while ( p_dev -> hh_keep_polling ) {  ret = poll ( pfds , 1 , 50 ) ;  if ( ret < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Cannot<S2SV_blank>poll<S2SV_blank>for<S2SV_blank>fds:<S2SV_blank>%s\\n"" , __FUNCTION__ , strerror ( errno ) ) ; break ; } if ( pfds [ 0 ] . revents & POLLIN ) { APPL_TRACE_DEBUG ( ""btif_hh_poll_event_thread:<S2SV_blank>POLLIN"" ) ; ret = uhid_event ( p_dev ) ; if ( ret ) { break ; } } } p_dev -> hh_poll_thread_id = - 1 ; return 0 ; }","ret = TEMP_FAILURE_RETRY ( poll ( pfds , 1 , 50 ) ) ;if ( ret < 0 ) {",2500
478,"buggy line: struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ;int err = 0 ;int is_udplite = IS_UDPLITE ( sk ) ;cwe id:CWE-399context: static int udp_v6_push_pending_frames ( struct sock * sk ) { struct sk_buff * skb ; struct udphdr * uh ; struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ;  struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ;   int err = 0 ;  int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( ( skb = skb_peek ( & sk -> sk_write_queue ) ) == NULL ) goto out ; uh = udp_hdr ( skb ) ; uh -> source = fl6 -> fl6_sport ; uh -> dest = fl6 -> fl6_dport ; uh -> len = htons ( up -> len ) ; uh -> check = 0 ; if ( is_udplite ) csum = udplite_csum_outgoing ( sk , skb ) ; else if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { udp6_hwcsum_outgoing ( sk , skb , & fl6 -> saddr , & fl6 -> daddr , up -> len ) ; goto send ; } else csum = udp_csum_outgoing ( sk , skb ) ; uh -> check = csum_ipv6_magic ( & fl6 -> saddr , & fl6 -> daddr , up -> len , fl6 -> flowi6_proto , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; send : err = ip6_push_pending_frames ( sk ) ; if ( err ) { if ( err == - ENOBUFS && ! inet6_sk ( sk ) -> recverr ) { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; err = 0 ; } } else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_OUTDATAGRAMS , is_udplite ) ; out : up -> len = 0 ; up -> pending = 0 ; return err ; }",struct flowi6 * fl6 ;int err = 0 ;int is_udplite = IS_UDPLITE ( sk ) ;if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ;fl6 = & inet -> cork . fl . u . ip6 ;,2501
479,"buggy line: while ( c && cJSON_strcasecmp ( c -> string , string ) ) {++ i ;c = c -> next ;}if ( c ) {cwe id:CWE-119context: void cJSON_ReplaceItemInObject ( cJSON * object , const char * string , cJSON * newitem ) { int i = 0 ; cJSON * c = object -> child ;  while ( c && cJSON_strcasecmp ( c -> string , string ) ) {  ++ i ; c = c -> next ;  }  if ( c ) { newitem -> string = cJSON_strdup ( string ) ; cJSON_ReplaceItemInArray ( object , i , newitem ) ; } }","+ i ;while ( c && cJSON_strcasecmp ( c -> string , string ) ) i ++ , c = c -> next ;}if ( c ) {",2502
480,"buggy line: # if ENABLE_BGP_VNC  case BGP_ATTR_VNC : attrname = ""VNC"" ;cwe id:CWE-436context: static void bgp_packet_mpattr_tea ( struct bgp * bgp , struct peer * peer , struct stream * s , struct attr * attr , uint8_t attrtype ) { unsigned int attrlenfield = 0 ; unsigned int attrhdrlen = 0 ; struct bgp_attr_encap_subtlv * subtlvs ; struct bgp_attr_encap_subtlv * st ; const char * attrname ; if ( ! attr || ( attrtype == BGP_ATTR_ENCAP && ( ! attr -> encap_tunneltype || attr -> encap_tunneltype == BGP_ENCAP_TYPE_MPLS ) ) ) return ; switch ( attrtype ) { case BGP_ATTR_ENCAP : attrname = ""Tunnel<S2SV_blank>Encap"" ; subtlvs = attr -> encap_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 2 + 2 ; attrhdrlen = 1 + 1 ; break ;  # if ENABLE_BGP_VNC  case BGP_ATTR_VNC : attrname = ""VNC"" ; subtlvs = attr -> vnc_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 0 ; attrhdrlen = 2 + 2 ; break ; # endif default : assert ( 0 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { attrlenfield += ( attrhdrlen + st -> length ) ; } if ( attrlenfield > 0xffff ) { zlog_info ( ""%s<S2SV_blank>attribute<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(length=%d),<S2SV_blank>can\'t<S2SV_blank>send<S2SV_blank>it"" , attrname , attrlenfield ) ; return ; } if ( attrlenfield > 0xff ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , attrtype ) ; stream_putw ( s , attrlenfield & 0xffff ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , attrtype ) ; stream_putc ( s , attrlenfield & 0xff ) ; } if ( attrtype == BGP_ATTR_ENCAP ) { stream_putw ( s , attr -> encap_tunneltype ) ; stream_putw ( s , attrlenfield - 4 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { if ( attrtype == BGP_ATTR_ENCAP ) { stream_putc ( s , st -> type ) ; stream_putc ( s , st -> length ) ; # if ENABLE_BGP_VNC } else { stream_putw ( s , st -> type ) ; stream_putw ( s , st -> length ) ; # endif } stream_put ( s , st -> value , st -> length ) ; } }","# if ENABLE_BGP_VNC_ATTR case BGP_ATTR_VNC : attrname = ""VNC"" ;",2503
481,"buggy line: if ( err ) goto out ;upperdentry = ovl_dentry_upper ( dentry ) ;if ( upperdentry ) {mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ;}err = ovl_copy_up_last ( dentry , attr , false ) ;cwe id:CWE-264context: int ovl_setattr ( struct dentry * dentry , struct iattr * attr ) { int err ; struct dentry * upperdentry ; err = ovl_want_write ( dentry ) ; if ( err ) goto out ;  upperdentry = ovl_dentry_upper ( dentry ) ;   if ( upperdentry ) {  mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ; err = notify_change ( upperdentry , attr , NULL ) ; mutex_unlock ( & upperdentry -> d_inode -> i_mutex ) ;  } else {  err = ovl_copy_up_last ( dentry , attr , false ) ; } ovl_drop_write ( dentry ) ; out : return err ; }","mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ;}err = ovl_copy_up_last ( dentry , attr , false ) ;",2504
482,"buggy line: if ( copy_from_user ( & info , u_info , sizeof ( info ) ) )  return - EFAULT ;if ( idx == - 1 ) idx = info . entry_number ;cwe id:CWE-264context: int do_set_thread_area ( struct task_struct * p , int idx , struct user_desc __user * u_info , int can_allocate ) { struct user_desc info ; if ( copy_from_user ( & info , u_info , sizeof ( info ) ) )  return - EFAULT ;  if ( idx == - 1 ) idx = info . entry_number ; if ( idx == - 1 && can_allocate ) { idx = get_free_idx ( ) ; if ( idx < 0 ) return idx ; if ( put_user ( idx , & u_info -> entry_number ) ) return - EFAULT ; } if ( idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX ) return - EINVAL ; set_tls_desc ( p , idx , & info , 1 ) ; return 0 ; }","if ( copy_from_user ( & info , u_info , sizeof ( info ) ) ) return - EFAULT ;if ( ! tls_desc_okay ( & info ) ) return - EINVAL ;if ( idx == - 1 ) idx = info . entry_number ;",2505
483,"buggy line: cwe id:CWE-74context: int pop_open_connection ( struct PopAccountData * adata ) { char buf [ 1024 ] ; int rc = pop_connect ( adata ) ; if ( rc < 0 ) return rc ; rc = pop_capabilities ( adata , 0 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; # ifdef USE_SSL if ( ! adata -> conn -> ssf && ( adata -> cmd_stls || C_SslForceTls ) ) { if ( C_SslForceTls ) adata -> use_stls = 2 ; if ( adata -> use_stls == 0 ) { enum QuadOption ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ; if ( ans == MUTT_ABORT ) return - 2 ; adata -> use_stls = 1 ; if ( ans == MUTT_YES ) adata -> use_stls = 2 ; } if ( adata -> use_stls == 2 ) { mutt_str_strfcpy ( buf , ""STLS\\r\\n"" , sizeof ( buf ) ) ; rc = pop_query ( adata , buf , sizeof ( buf ) ) ;  if ( rc == - 1 )  goto err_conn ; if ( rc != 0 ) { mutt_error ( ""%s"" , adata -> err_msg ) ; } else if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; return - 2 ; } else { rc = pop_capabilities ( adata , 1 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; } } } if ( C_SslForceTls && ! adata -> conn -> ssf ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; return - 2 ; } # endif rc = pop_authenticate ( adata ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 3 ) mutt_clear_error ( ) ; if ( rc != 0 ) return rc ; rc = pop_capabilities ( adata , 2 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; mutt_str_strfcpy ( buf , ""STAT\\r\\n"" , sizeof ( buf ) ) ; rc = pop_query ( adata , buf , sizeof ( buf ) ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) { mutt_error ( ""%s"" , adata -> err_msg ) ; return rc ; } unsigned int n = 0 , size = 0 ; sscanf ( buf , ""+OK<S2SV_blank>%u<S2SV_blank>%u"" , & n , & size ) ; adata -> size = size ; return 0 ; err_conn : adata -> status = POP_DISCONNECTED ; mutt_error ( _ ( ""Server<S2SV_blank>closed<S2SV_blank>connection"" ) ) ; return - 1 ; }",mutt_socket_empty ( adata -> conn ) ;,2506
484,"buggy line: if ( rc == - 1 )  goto err_conn ;cwe id:CWE-74context: int pop_open_connection ( struct PopAccountData * adata ) { char buf [ 1024 ] ; int rc = pop_connect ( adata ) ; if ( rc < 0 ) return rc ; rc = pop_capabilities ( adata , 0 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; # ifdef USE_SSL if ( ! adata -> conn -> ssf && ( adata -> cmd_stls || C_SslForceTls ) ) { if ( C_SslForceTls ) adata -> use_stls = 2 ; if ( adata -> use_stls == 0 ) { enum QuadOption ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ; if ( ans == MUTT_ABORT ) return - 2 ; adata -> use_stls = 1 ; if ( ans == MUTT_YES ) adata -> use_stls = 2 ; } if ( adata -> use_stls == 2 ) { mutt_str_strfcpy ( buf , ""STLS\\r\\n"" , sizeof ( buf ) ) ; rc = pop_query ( adata , buf , sizeof ( buf ) ) ;  if ( rc == - 1 )  goto err_conn ; if ( rc != 0 ) { mutt_error ( ""%s"" , adata -> err_msg ) ; } else if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; return - 2 ; } else { rc = pop_capabilities ( adata , 1 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; } } } if ( C_SslForceTls && ! adata -> conn -> ssf ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; return - 2 ; } # endif rc = pop_authenticate ( adata ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 3 ) mutt_clear_error ( ) ; if ( rc != 0 ) return rc ; rc = pop_capabilities ( adata , 2 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; mutt_str_strfcpy ( buf , ""STAT\\r\\n"" , sizeof ( buf ) ) ; rc = pop_query ( adata , buf , sizeof ( buf ) ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) { mutt_error ( ""%s"" , adata -> err_msg ) ; return rc ; } unsigned int n = 0 , size = 0 ; sscanf ( buf , ""+OK<S2SV_blank>%u<S2SV_blank>%u"" , & n , & size ) ; adata -> size = size ; return 0 ; err_conn : adata -> status = POP_DISCONNECTED ; mutt_error ( _ ( ""Server<S2SV_blank>closed<S2SV_blank>connection"" ) ) ; return - 1 ; }",if ( rc == - 1 ) goto err_conn ;,2506
485,"buggy line: char data [ 8 ] ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;return - EIO ;}return - EIO ;}return snprintf ( buf , PAGE_SIZE , ""%d\\\cwe id:CWE-119context: static ssize_t k90_show_current_profile ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int current_profile ;  char data [ 8 ] ;  ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ;  return - EIO ;  } current_profile = data [ 7 ] ; if ( current_profile < 1 || current_profile > 3 ) { dev_warn ( dev , ""Read<S2SV_blank>invalid<S2SV_blank>current<S2SV_blank>profile:<S2SV_blank>%02hhx.\\n"" , data [ 7 ] ) ;  return - EIO ;   }  return snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; }","char * data ;data = kmalloc ( 8 , GFP_KERNEL ) ;if ( ! data ) return - ENOMEM ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;ret = - EIO ;goto out ;}ret = - EIO ;goto out ;}ret = snprintf ( buf , PAGE_SIZE , ""%d\\\out : kfree ( data ) ;return ret ;",2507
486,"buggy line: static void set_fdc ( int drive )  {if ( drive >= 0 && drive < N_DRIVE ) {fdc = FDC ( drive ) ;current_drive = drive ;if ( fdc != 1 && fdc != 0 ) {pr_info ( ""bad<S2SV_blank>fdc<S2SV_blank>value\\\}set_dor ( fdc , ~ 0 , 8 ) ;cwe id:CWE-125context: static void set_fdc ( int drive )  {  if ( drive >= 0 && drive < N_DRIVE ) {  fdc = FDC ( drive ) ;  current_drive = drive ; }  if ( fdc != 1 && fdc != 0 ) {  pr_info ( ""bad<S2SV_blank>fdc<S2SV_blank>value\\n"" ) ; return ;  }  set_dor ( fdc , ~ 0 , 8 ) ; # if N_FDC > 1 set_dor ( 1 - fdc , ~ 8 , 0 ) ; # endif if ( FDCS -> rawcmd == 2 ) reset_fdc_info ( 1 ) ; if ( fd_inb ( FD_STATUS ) != STATUS_READY ) FDCS -> reset = 1 ; }","static void set_fdc ( int drive ) {unsigned int new_fdc = fdc ;if ( drive >= 0 && drive < N_DRIVE ) {new_fdc = FDC ( drive ) ;current_drive = drive ;if ( new_fdc >= N_FDC ) {pr_info ( ""bad<S2SV_blank>fdc<S2SV_blank>value\\\}fdc = new_fdc ;set_dor ( fdc , ~ 0 , 8 ) ;",2508
487,"buggy line: BREAK_TO_DEBUGGER ( ) ;return NULL ;cwe id:CWE-401context: struct resource_pool * dcn10_create_resource_pool ( const struct dc_init_data * init_data , struct dc * dc ) { struct dcn10_resource_pool * pool = kzalloc ( sizeof ( struct dcn10_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( init_data -> num_virtual_links , dc , pool ) ) return & pool -> base ;  BREAK_TO_DEBUGGER ( ) ;  return NULL ; }",kfree ( pool ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,2509
488,"buggy line: # if ! ( CONFIG_FAST_UNALIGNED )  dst [ 0 ] = src [ 0 ] ;dst [ 1 ] = src [ 1 ] ;dst [ 2 ] = src [ 2 ] ;dst [ 3 ] = src [ 3 ] ;dst [ 4 ] = src [ 4 ] ;dst [ 5 ] = src [ 5 ] ;dst [ 6 ] = src [ 6 ] ;dst [ 7 ] = src [ 7 ] ;dst [ 8 ] = src [ 8 ] ;dst [ 9 ] = src [ 9 ] ;dst [ 10 ] = src [ 10 ] ;dst [ 11 ] = src [ 11 ] ;dst [ 12 ] = src [ 12 ] ;dst [ 13 ] = src [ 13 ] ;dst [ 14 ] = src [ 14 ] ;dst [ 15 ] = src [ 15 ] ;# else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ;( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ;( ( uint32_t * ) dst ) [ 2 ] = ( ( uint32_t * ) src ) [ 2 ] ;( ( uint32_t * ) dst ) [ 3 ] = ( ( uint32_t * ) src ) [ 3 ] ;# endif src += src_stride ;cwe id:CWE-119context: void vp8_copy_mem16x16_c ( unsigned char * src , int src_stride , unsigned char * dst , int dst_stride ) { int r ; for ( r = 0 ; r < 16 ; r ++ ) {  # if ! ( CONFIG_FAST_UNALIGNED )  dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; dst [ 4 ] = src [ 4 ] ; dst [ 5 ] = src [ 5 ] ; dst [ 6 ] = src [ 6 ] ; dst [ 7 ] = src [ 7 ] ; dst [ 8 ] = src [ 8 ] ; dst [ 9 ] = src [ 9 ] ; dst [ 10 ] = src [ 10 ] ; dst [ 11 ] = src [ 11 ] ; dst [ 12 ] = src [ 12 ] ; dst [ 13 ] = src [ 13 ] ; dst [ 14 ] = src [ 14 ] ; dst [ 15 ] = src [ 15 ] ; # else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ; ( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ; ( ( uint32_t * ) dst ) [ 2 ] = ( ( uint32_t * ) src ) [ 2 ] ; ( ( uint32_t * ) dst ) [ 3 ] = ( ( uint32_t * ) src ) [ 3 ] ; # endif src += src_stride ; dst += dst_stride ; } }","memcpy ( dst , src , 16 ) ;src += src_stride ;",2510
489,"buggy line: spin_lock ( & desc -> iuspin ) ;clear_bit ( WDM_RESPONDING , & desc -> flags ) ;cwe id:CWE-119context: static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ;  spin_lock ( & desc -> iuspin ) ;  clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ENOENT"" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ECONNRESET"" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ESHUTDOWN"" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-EPIPE\\n"" ) ; break ; default : dev_err ( & desc -> intf -> dev , ""Unexpected<S2SV_blank>error<S2SV_blank>%d\\n"" , status ) ; break ; } } desc -> rerr = status ;  desc -> reslength = urb -> actual_length ;   memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ;  desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }","int length = urb -> actual_length ;spin_lock ( & desc -> iuspin ) ;clear_bit ( WDM_RESPONDING , & desc -> flags ) ;",2511
490,"buggy line: desc -> reslength = urb -> actual_length ;memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ;desc -> length += desc -> reslength ;cwe id:CWE-119context: static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ;  spin_lock ( & desc -> iuspin ) ;  clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ENOENT"" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ECONNRESET"" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ESHUTDOWN"" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-EPIPE\\n"" ) ; break ; default : dev_err ( & desc -> intf -> dev , ""Unexpected<S2SV_blank>error<S2SV_blank>%d\\n"" , status ) ; break ; } } desc -> rerr = status ;  desc -> reslength = urb -> actual_length ;   memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ;  desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }","if ( length + desc -> length > desc -> wMaxCommand ) {set_bit ( WDM_OVERFLOW , & desc -> flags ) ;}else {if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) {memmove ( desc -> ubuf + desc -> length , desc -> inbuf , length ) ;desc -> length += length ;desc -> reslength = length ;}}",2511
491,"buggy line: if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) )  timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ;remaining = kc -> timer_remaining ( timr , now ) ;cwe id:CWE-190context: void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; sig_none = timr -> it_sigev_notify == SIGEV_NONE ; iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) )  timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ;  remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }","if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ;remaining = kc -> timer_remaining ( timr , now ) ;",2512
492,"buggy line: cwe id:CWE-20context: static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { int buf_size = avpkt -> size ; FlashSVContext * s = avctx -> priv_data ; int h_blocks , v_blocks , h_part , v_part , i , j , ret ; GetBitContext gb ; int last_blockwidth = s -> block_width ; int last_blockheight = s -> block_height ; if ( buf_size == 0 ) return 0 ; if ( buf_size < 4 ) return - 1 ; init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_width = get_bits ( & gb , 12 ) ; s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_height = get_bits ( & gb , 12 ) ; if ( last_blockwidth != s -> block_width || last_blockheight != s -> block_height ) av_freep ( & s -> blocks ) ; if ( s -> ver == 2 ) { skip_bits ( & gb , 6 ) ; if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , ""iframe"" ) ; return AVERROR_PATCHWELCOME ; } if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , ""Custom<S2SV_blank>palette"" ) ; return AVERROR_PATCHWELCOME ; } } h_blocks = s -> image_width / s -> block_width ; h_part = s -> image_width % s -> block_width ; v_blocks = s -> image_height / s -> block_height ; v_part = s -> image_height % s -> block_height ; if ( s -> block_size < s -> block_width * s -> block_height ) { int tmpblock_size = 3 * s -> block_width * s -> block_height ; s -> tmpblock = av_realloc ( s -> tmpblock , tmpblock_size ) ; if ( ! s -> tmpblock ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'t<S2SV_blank>allocate<S2SV_blank>decompression<S2SV_blank>buffer.\\n"" ) ; return AVERROR ( ENOMEM ) ; } if ( s -> ver == 2 ) { s -> deflate_block_size = calc_deflate_block_size ( tmpblock_size ) ; if ( s -> deflate_block_size <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'t<S2SV_blank>determine<S2SV_blank>deflate<S2SV_blank>buffer<S2SV_blank>size.\\n"" ) ; return - 1 ; } s -> deflate_block = av_realloc ( s -> deflate_block , s -> deflate_block_size ) ; if ( ! s -> deflate_block ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'t<S2SV_blank>allocate<S2SV_blank>deflate<S2SV_blank>buffer.\\n"" ) ; return AVERROR ( ENOMEM ) ; } } } s -> block_size = s -> block_width * s -> block_height ; if ( avctx -> width == 0 && avctx -> height == 0 ) { avcodec_set_dimensions ( avctx , s -> image_width , s -> image_height ) ; } if ( avctx -> width != s -> image_width || avctx -> height != s -> image_height ) { av_log ( avctx , AV_LOG_ERROR , ""Frame<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>differs<S2SV_blank>from<S2SV_blank>first<S2SV_blank>frame!\\n"" ) ; av_log ( avctx , AV_LOG_ERROR , ""fh<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>fv<S2SV_blank>%d<S2SV_blank><S2SV_blank>vs<S2SV_blank><S2SV_blank>ch<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cv<S2SV_blank>=<S2SV_blank>%d\\n"" , avctx -> height , avctx -> width , s -> image_height , s -> image_width ) ; return AVERROR_INVALIDDATA ; } s -> is_keyframe = ( avpkt -> flags & AV_PKT_FLAG_KEY ) && ( s -> ver == 2 ) ; if ( s -> is_keyframe ) { s -> keyframedata = av_realloc ( s -> keyframedata , avpkt -> size ) ; memcpy ( s -> keyframedata , avpkt -> data , avpkt -> size ) ; } if ( s -> ver == 2 && ! s -> blocks ) s -> blocks = av_mallocz ( ( v_blocks + ! ! v_part ) * ( h_blocks + ! ! h_part ) * sizeof ( s -> blocks [ 0 ] ) ) ; av_dlog ( avctx , ""image:<S2SV_blank>%dx%d<S2SV_blank>block:<S2SV_blank>%dx%d<S2SV_blank>num:<S2SV_blank>%dx%d<S2SV_blank>part:<S2SV_blank>%dx%d\\n"" , s -> image_width , s -> image_height , s -> block_width , s -> block_height , h_blocks , v_blocks , h_part , v_part ) ; if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) return ret ; for ( j = 0 ; j < v_blocks + ( v_part ? 1 : 0 ) ; j ++ ) { int y_pos = j * s -> block_height ; int cur_blk_height = ( j < v_blocks ) ? s -> block_height : v_part ; for ( i = 0 ; i < h_blocks + ( h_part ? 1 : 0 ) ; i ++ ) { int x_pos = i * s -> block_width ; int cur_blk_width = ( i < h_blocks ) ? s -> block_width : h_part ; int has_diff = 0 ; int size = get_bits ( & gb , 16 ) ; s -> color_depth = 0 ; s -> zlibprime_curr = 0 ; s -> zlibprime_prev = 0 ; s -> diff_start = 0 ; s -> diff_height = cur_blk_height ; if ( 8 * size > get_bits_left ( & gb ) ) { av_frame_unref ( & s -> frame ) ; return AVERROR_INVALIDDATA ; } if ( s -> ver == 2 && size ) { skip_bits ( & gb , 3 ) ; s -> color_depth = get_bits ( & gb , 2 ) ; has_diff = get_bits1 ( & gb ) ; s -> zlibprime_curr = get_bits1 ( & gb ) ; s -> zlibprime_prev = get_bits1 ( & gb ) ; if ( s -> color_depth != 0 && s -> color_depth != 2 ) { av_log ( avctx , AV_LOG_ERROR , ""%dx%d<S2SV_blank>invalid<S2SV_blank>color<S2SV_blank>depth<S2SV_blank>%d\\n"" , i , j , s -> color_depth ) ; return AVERROR_INVALIDDATA ; } if ( has_diff ) { if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , ""inter<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>keyframe\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> diff_start = get_bits ( & gb , 8 ) ; s -> diff_height = get_bits ( & gb , 8 ) ;  av_log ( avctx , AV_LOG_DEBUG ,  ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\n"" , i , j , s -> diff_start , s -> diff_height ) ; size -= 2 ; } if ( s -> zlibprime_prev ) av_log ( avctx , AV_LOG_DEBUG , ""%dx%d<S2SV_blank>zlibprime_prev\\n"" , i , j ) ; if ( s -> zlibprime_curr ) { int col = get_bits ( & gb , 8 ) ; int row = get_bits ( & gb , 8 ) ; av_log ( avctx , AV_LOG_DEBUG , ""%dx%d<S2SV_blank>zlibprime_curr<S2SV_blank>%dx%d\\n"" , i , j , col , row ) ; size -= 2 ; avpriv_request_sample ( avctx , ""zlibprime_curr"" ) ; return AVERROR_PATCHWELCOME ; } if ( ! s -> blocks && ( s -> zlibprime_curr || s -> zlibprime_prev ) ) { av_log ( avctx , AV_LOG_ERROR , ""no<S2SV_blank>data<S2SV_blank>available<S2SV_blank>for<S2SV_blank>zlib<S2SV_blank>"" ""priming\\n"" ) ; return AVERROR_INVALIDDATA ; } size -- ; } if ( has_diff ) { int k ; int off = ( s -> image_height - y_pos - 1 ) * s -> frame . linesize [ 0 ] ; for ( k = 0 ; k < cur_blk_height ; k ++ ) memcpy ( s -> frame . data [ 0 ] + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , s -> keyframe + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , cur_blk_width * 3 ) ; } if ( size ) { if ( flashsv_decode_block ( avctx , avpkt , & gb , size , cur_blk_width , cur_blk_height , x_pos , y_pos , i + j * ( h_blocks + ! ! h_part ) ) ) av_log ( avctx , AV_LOG_ERROR , ""error<S2SV_blank>in<S2SV_blank>decompression<S2SV_blank>of<S2SV_blank>block<S2SV_blank>%dx%d\\n"" , i , j ) ; } } } if ( s -> is_keyframe && s -> ver == 2 ) { if ( ! s -> keyframe ) { s -> keyframe = av_malloc ( s -> frame . linesize [ 0 ] * avctx -> height ) ; if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , ""Cannot<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\n"" ) ; return AVERROR ( ENOMEM ) ; } } memcpy ( s -> keyframe , s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] * avctx -> height ) ; } if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ; * got_frame = 1 ; if ( ( get_bits_count ( & gb ) / 8 ) != buf_size ) av_log ( avctx , AV_LOG_ERROR , ""buffer<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>consumed<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%d)\\n"" , buf_size , ( get_bits_count ( & gb ) / 8 ) ) ; return buf_size ; }","if ( s -> diff_start + s -> diff_height > cur_blk_height ) {av_log ( avctx , AV_LOG_ERROR , ""Block<S2SV_blank>parameters<S2SV_blank>invalid\\\return AVERROR_INVALIDDATA ;}",2513
493,"buggy line: av_log ( avctx , AV_LOG_DEBUG ,  ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\cwe id:CWE-20context: static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { int buf_size = avpkt -> size ; FlashSVContext * s = avctx -> priv_data ; int h_blocks , v_blocks , h_part , v_part , i , j , ret ; GetBitContext gb ; int last_blockwidth = s -> block_width ; int last_blockheight = s -> block_height ; if ( buf_size == 0 ) return 0 ; if ( buf_size < 4 ) return - 1 ; init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_width = get_bits ( & gb , 12 ) ; s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_height = get_bits ( & gb , 12 ) ; if ( last_blockwidth != s -> block_width || last_blockheight != s -> block_height ) av_freep ( & s -> blocks ) ; if ( s -> ver == 2 ) { skip_bits ( & gb , 6 ) ; if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , ""iframe"" ) ; return AVERROR_PATCHWELCOME ; } if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , ""Custom<S2SV_blank>palette"" ) ; return AVERROR_PATCHWELCOME ; } } h_blocks = s -> image_width / s -> block_width ; h_part = s -> image_width % s -> block_width ; v_blocks = s -> image_height / s -> block_height ; v_part = s -> image_height % s -> block_height ; if ( s -> block_size < s -> block_width * s -> block_height ) { int tmpblock_size = 3 * s -> block_width * s -> block_height ; s -> tmpblock = av_realloc ( s -> tmpblock , tmpblock_size ) ; if ( ! s -> tmpblock ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'t<S2SV_blank>allocate<S2SV_blank>decompression<S2SV_blank>buffer.\\n"" ) ; return AVERROR ( ENOMEM ) ; } if ( s -> ver == 2 ) { s -> deflate_block_size = calc_deflate_block_size ( tmpblock_size ) ; if ( s -> deflate_block_size <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'t<S2SV_blank>determine<S2SV_blank>deflate<S2SV_blank>buffer<S2SV_blank>size.\\n"" ) ; return - 1 ; } s -> deflate_block = av_realloc ( s -> deflate_block , s -> deflate_block_size ) ; if ( ! s -> deflate_block ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'t<S2SV_blank>allocate<S2SV_blank>deflate<S2SV_blank>buffer.\\n"" ) ; return AVERROR ( ENOMEM ) ; } } } s -> block_size = s -> block_width * s -> block_height ; if ( avctx -> width == 0 && avctx -> height == 0 ) { avcodec_set_dimensions ( avctx , s -> image_width , s -> image_height ) ; } if ( avctx -> width != s -> image_width || avctx -> height != s -> image_height ) { av_log ( avctx , AV_LOG_ERROR , ""Frame<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>differs<S2SV_blank>from<S2SV_blank>first<S2SV_blank>frame!\\n"" ) ; av_log ( avctx , AV_LOG_ERROR , ""fh<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>fv<S2SV_blank>%d<S2SV_blank><S2SV_blank>vs<S2SV_blank><S2SV_blank>ch<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cv<S2SV_blank>=<S2SV_blank>%d\\n"" , avctx -> height , avctx -> width , s -> image_height , s -> image_width ) ; return AVERROR_INVALIDDATA ; } s -> is_keyframe = ( avpkt -> flags & AV_PKT_FLAG_KEY ) && ( s -> ver == 2 ) ; if ( s -> is_keyframe ) { s -> keyframedata = av_realloc ( s -> keyframedata , avpkt -> size ) ; memcpy ( s -> keyframedata , avpkt -> data , avpkt -> size ) ; } if ( s -> ver == 2 && ! s -> blocks ) s -> blocks = av_mallocz ( ( v_blocks + ! ! v_part ) * ( h_blocks + ! ! h_part ) * sizeof ( s -> blocks [ 0 ] ) ) ; av_dlog ( avctx , ""image:<S2SV_blank>%dx%d<S2SV_blank>block:<S2SV_blank>%dx%d<S2SV_blank>num:<S2SV_blank>%dx%d<S2SV_blank>part:<S2SV_blank>%dx%d\\n"" , s -> image_width , s -> image_height , s -> block_width , s -> block_height , h_blocks , v_blocks , h_part , v_part ) ; if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) return ret ; for ( j = 0 ; j < v_blocks + ( v_part ? 1 : 0 ) ; j ++ ) { int y_pos = j * s -> block_height ; int cur_blk_height = ( j < v_blocks ) ? s -> block_height : v_part ; for ( i = 0 ; i < h_blocks + ( h_part ? 1 : 0 ) ; i ++ ) { int x_pos = i * s -> block_width ; int cur_blk_width = ( i < h_blocks ) ? s -> block_width : h_part ; int has_diff = 0 ; int size = get_bits ( & gb , 16 ) ; s -> color_depth = 0 ; s -> zlibprime_curr = 0 ; s -> zlibprime_prev = 0 ; s -> diff_start = 0 ; s -> diff_height = cur_blk_height ; if ( 8 * size > get_bits_left ( & gb ) ) { av_frame_unref ( & s -> frame ) ; return AVERROR_INVALIDDATA ; } if ( s -> ver == 2 && size ) { skip_bits ( & gb , 3 ) ; s -> color_depth = get_bits ( & gb , 2 ) ; has_diff = get_bits1 ( & gb ) ; s -> zlibprime_curr = get_bits1 ( & gb ) ; s -> zlibprime_prev = get_bits1 ( & gb ) ; if ( s -> color_depth != 0 && s -> color_depth != 2 ) { av_log ( avctx , AV_LOG_ERROR , ""%dx%d<S2SV_blank>invalid<S2SV_blank>color<S2SV_blank>depth<S2SV_blank>%d\\n"" , i , j , s -> color_depth ) ; return AVERROR_INVALIDDATA ; } if ( has_diff ) { if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , ""inter<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>keyframe\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> diff_start = get_bits ( & gb , 8 ) ; s -> diff_height = get_bits ( & gb , 8 ) ;  av_log ( avctx , AV_LOG_DEBUG ,  ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\n"" , i , j , s -> diff_start , s -> diff_height ) ; size -= 2 ; } if ( s -> zlibprime_prev ) av_log ( avctx , AV_LOG_DEBUG , ""%dx%d<S2SV_blank>zlibprime_prev\\n"" , i , j ) ; if ( s -> zlibprime_curr ) { int col = get_bits ( & gb , 8 ) ; int row = get_bits ( & gb , 8 ) ; av_log ( avctx , AV_LOG_DEBUG , ""%dx%d<S2SV_blank>zlibprime_curr<S2SV_blank>%dx%d\\n"" , i , j , col , row ) ; size -= 2 ; avpriv_request_sample ( avctx , ""zlibprime_curr"" ) ; return AVERROR_PATCHWELCOME ; } if ( ! s -> blocks && ( s -> zlibprime_curr || s -> zlibprime_prev ) ) { av_log ( avctx , AV_LOG_ERROR , ""no<S2SV_blank>data<S2SV_blank>available<S2SV_blank>for<S2SV_blank>zlib<S2SV_blank>"" ""priming\\n"" ) ; return AVERROR_INVALIDDATA ; } size -- ; } if ( has_diff ) { int k ; int off = ( s -> image_height - y_pos - 1 ) * s -> frame . linesize [ 0 ] ; for ( k = 0 ; k < cur_blk_height ; k ++ ) memcpy ( s -> frame . data [ 0 ] + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , s -> keyframe + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , cur_blk_width * 3 ) ; } if ( size ) { if ( flashsv_decode_block ( avctx , avpkt , & gb , size , cur_blk_width , cur_blk_height , x_pos , y_pos , i + j * ( h_blocks + ! ! h_part ) ) ) av_log ( avctx , AV_LOG_ERROR , ""error<S2SV_blank>in<S2SV_blank>decompression<S2SV_blank>of<S2SV_blank>block<S2SV_blank>%dx%d\\n"" , i , j ) ; } } } if ( s -> is_keyframe && s -> ver == 2 ) { if ( ! s -> keyframe ) { s -> keyframe = av_malloc ( s -> frame . linesize [ 0 ] * avctx -> height ) ; if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , ""Cannot<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\n"" ) ; return AVERROR ( ENOMEM ) ; } } memcpy ( s -> keyframe , s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] * avctx -> height ) ; } if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ; * got_frame = 1 ; if ( ( get_bits_count ( & gb ) / 8 ) != buf_size ) av_log ( avctx , AV_LOG_ERROR , ""buffer<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>consumed<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%d)\\n"" , buf_size , ( get_bits_count ( & gb ) / 8 ) ) ; return buf_size ; }","av_log ( avctx , AV_LOG_DEBUG , ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\",2513
494,"buggy line: struct sshcomp * comp ;int r , mode ;for ( mode = 0 ;mode < MODE_MAX ;mode ++ ) {if ( ssh -> state -> newkeys [ mode ] == NULL ) continue ;comp = & ssh -> state -> newkeys [ mode ] -> comp ;if ( comp && comp -> enabled &&  ( r = ssh_packet_init_compression ( ssh ) ) != 0 )  return r ;}return 0 ;cwe id:CWE-119context: static int ssh_packet_set_postauth ( struct ssh * ssh ) {  struct sshcomp * comp ;  int r , mode ; debug ( ""%s:<S2SV_blank>called"" , __func__ ) ; ssh -> state -> after_authentication = 1 ; ssh -> state -> rekeying = 0 ;  for ( mode = 0 ; mode < MODE_MAX ; mode ++ ) {  if ( ssh -> state -> newkeys [ mode ] == NULL ) continue ; comp = & ssh -> state -> newkeys [ mode ] -> comp ; if ( comp && comp -> enabled &&  ( r = ssh_packet_init_compression ( ssh ) ) != 0 )  return r ;  }  return 0 ; }",int r ;if ( ( r = ssh_packet_init_compression ( ssh ) ) != 0 ) return r ;}return 0 ;,2514
495,"buggy line: logger ( Protocol , Debug , ""rdpdr_process()"" ) ;in_uint16 ( s , component ) ;cwe id:CWE-787context: static void rdpdr_process ( STREAM s ) { uint32 handle ; uint16 vmin ; uint16 component ; uint16 pakid ;  logger ( Protocol , Debug , ""rdpdr_process()"" ) ;  in_uint16 ( s , component ) ; in_uint16 ( s , pakid ) ; if ( component == RDPDR_CTYP_CORE ) { switch ( pakid ) { case PAKID_CORE_DEVICE_IOREQUEST : rdpdr_process_irp ( s ) ; break ; case PAKID_CORE_SERVER_ANNOUNCE : in_uint8s ( s , 2 ) ; in_uint16_le ( s , vmin ) ;  in_uint32_le ( s , g_client_id ) ;  if ( vmin < 0x000c ) g_client_id = 0x815ed39d ; g_epoch ++ ; # if WITH_SCARD scard_release_all_contexts ( ) ; # endif rdpdr_send_client_announce_reply ( ) ; rdpdr_send_client_name_request ( ) ; break ; case PAKID_CORE_CLIENTID_CONFIRM : rdpdr_send_client_device_list_announce ( ) ; break ; case PAKID_CORE_DEVICE_REPLY : in_uint32 ( s , handle ) ; logger ( Protocol , Debug , ""rdpdr_process(),<S2SV_blank>server<S2SV_blank>connected<S2SV_blank>to<S2SV_blank>resource<S2SV_blank>%d"" , handle ) ; break ; case PAKID_CORE_SERVER_CAPABILITY : rdpdr_send_client_capability_response ( ) ; break ; default : logger ( Protocol , Debug , ""rdpdr_process(),<S2SV_blank>pakid<S2SV_blank>0x%x<S2SV_blank>of<S2SV_blank>component<S2SV_blank>0x%x"" , pakid , component ) ; break ; } } else if ( component == RDPDR_CTYP_PRN ) { if ( pakid == PAKID_PRN_CACHE_DATA ) printercache_process ( s ) ; } else logger ( Protocol , Warning , ""rdpdr_process(),<S2SV_blank>unhandled<S2SV_blank>component<S2SV_blank>0x%x"" , component ) ; }","struct stream packet = * s ;logger ( Protocol , Debug , ""rdpdr_process()"" ) ;in_uint16 ( s , component ) ;",2515
496,"buggy line: in_uint32_le ( s , g_client_id ) ;if ( vmin < 0x000c ) g_client_id = 0x815ed39d ;cwe id:CWE-787context: static void rdpdr_process ( STREAM s ) { uint32 handle ; uint16 vmin ; uint16 component ; uint16 pakid ;  logger ( Protocol , Debug , ""rdpdr_process()"" ) ;  in_uint16 ( s , component ) ; in_uint16 ( s , pakid ) ; if ( component == RDPDR_CTYP_CORE ) { switch ( pakid ) { case PAKID_CORE_DEVICE_IOREQUEST : rdpdr_process_irp ( s ) ; break ; case PAKID_CORE_SERVER_ANNOUNCE : in_uint8s ( s , 2 ) ; in_uint16_le ( s , vmin ) ;  in_uint32_le ( s , g_client_id ) ;  if ( vmin < 0x000c ) g_client_id = 0x815ed39d ; g_epoch ++ ; # if WITH_SCARD scard_release_all_contexts ( ) ; # endif rdpdr_send_client_announce_reply ( ) ; rdpdr_send_client_name_request ( ) ; break ; case PAKID_CORE_CLIENTID_CONFIRM : rdpdr_send_client_device_list_announce ( ) ; break ; case PAKID_CORE_DEVICE_REPLY : in_uint32 ( s , handle ) ; logger ( Protocol , Debug , ""rdpdr_process(),<S2SV_blank>server<S2SV_blank>connected<S2SV_blank>to<S2SV_blank>resource<S2SV_blank>%d"" , handle ) ; break ; case PAKID_CORE_SERVER_CAPABILITY : rdpdr_send_client_capability_response ( ) ; break ; default : logger ( Protocol , Debug , ""rdpdr_process(),<S2SV_blank>pakid<S2SV_blank>0x%x<S2SV_blank>of<S2SV_blank>component<S2SV_blank>0x%x"" , pakid , component ) ; break ; } } else if ( component == RDPDR_CTYP_PRN ) { if ( pakid == PAKID_PRN_CACHE_DATA ) printercache_process ( s ) ; } else logger ( Protocol , Warning , ""rdpdr_process(),<S2SV_blank>unhandled<S2SV_blank>component<S2SV_blank>0x%x"" , component ) ; }","in_uint32_le ( s , g_client_id ) ;if ( ! s_check ( s ) ) {rdp_protocol_error ( ""rdpdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>g_client_id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>did<S2SV_blank>overrun"" , & packet ) ;}if ( vmin < 0x000c ) g_client_id = 0x815ed39d ;",2515
497,"buggy line: static void filter_selectively_vert_row2 ( PLANE_TYPE plane_type ,  uint8_t * s , int pitch , unsigned int mask_16x16_l , unsigned int mask_8x8_l , unsigned int mask_4x4_l , unsigned int mask_4x4_int_l , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) {const int mask_shift = plane_type ? 4 : 8 ;const int mask_cutoff = plane_type ? 0xf : 0xff ;const int lfl_forward = plane_type ? 4 : 8 ;unsigned int mask_16x16_0 = mask_16x16_l & mask_cutoff ;cwe id:CWE-119context:  static void filter_selectively_vert_row2 ( PLANE_TYPE plane_type ,  uint8_t * s , int pitch , unsigned int mask_16x16_l , unsigned int mask_8x8_l , unsigned int mask_4x4_l , unsigned int mask_4x4_int_l , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) {  const int mask_shift = plane_type ? 4 : 8 ;   const int mask_cutoff = plane_type ? 0xf : 0xff ;   const int lfl_forward = plane_type ? 4 : 8 ;  unsigned int mask_16x16_0 = mask_16x16_l & mask_cutoff ; unsigned int mask_8x8_0 = mask_8x8_l & mask_cutoff ; unsigned int mask_4x4_0 = mask_4x4_l & mask_cutoff ; unsigned int mask_4x4_int_0 = mask_4x4_int_l & mask_cutoff ; unsigned int mask_16x16_1 = ( mask_16x16_l >> mask_shift ) & mask_cutoff ; unsigned int mask_8x8_1 = ( mask_8x8_l >> mask_shift ) & mask_cutoff ; unsigned int mask_4x4_1 = ( mask_4x4_l >> mask_shift ) & mask_cutoff ; unsigned int mask_4x4_int_1 = ( mask_4x4_int_l >> mask_shift ) & mask_cutoff ; unsigned int mask ; for ( mask = mask_16x16_0 | mask_8x8_0 | mask_4x4_0 | mask_4x4_int_0 | mask_16x16_1 | mask_8x8_1 | mask_4x4_1 | mask_4x4_int_1 ; mask ; mask >>= 1 ) { const loop_filter_thresh * lfi0 = lfi_n -> lfthr + * lfl ; const loop_filter_thresh * lfi1 = lfi_n -> lfthr + * ( lfl + lfl_forward ) ; if ( mask & 1 ) { if ( ( mask_16x16_0 | mask_16x16_1 ) & 1 ) { if ( ( mask_16x16_0 & mask_16x16_1 ) & 1 ) {  vp9_lpf_vertical_16_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr ) ; } else if ( mask_16x16_0 & 1 ) {  vp9_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr ) ; } else {  vp9_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim ,  lfi1 -> lim , lfi1 -> hev_thr ) ; } } if ( ( mask_8x8_0 | mask_8x8_1 ) & 1 ) { if ( ( mask_8x8_0 & mask_8x8_1 ) & 1 ) {  vp9_lpf_vertical_8_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ; } else if ( mask_8x8_0 & 1 ) {  vp9_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ,  1 ) ; } else {  vp9_lpf_vertical_8 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ; } } if ( ( mask_4x4_0 | mask_4x4_1 ) & 1 ) { if ( ( mask_4x4_0 & mask_4x4_1 ) & 1 ) {  vp9_lpf_vertical_4_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ; } else if ( mask_4x4_0 & 1 ) {  vp9_lpf_vertical_4 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ,  1 ) ; } else {  vp9_lpf_vertical_4 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ; } } if ( ( mask_4x4_int_0 | mask_4x4_int_1 ) & 1 ) { if ( ( mask_4x4_int_0 & mask_4x4_int_1 ) & 1 ) {  vp9_lpf_vertical_4_dual ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ; } else if ( mask_4x4_int_0 & 1 ) {  vp9_lpf_vertical_4 ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , 1 ) ; } else {  vp9_lpf_vertical_4 ( s + 8 * pitch + 4 , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ; } } } s += 8 ; lfl += 1 ; mask_16x16_0 >>= 1 ; mask_8x8_0 >>= 1 ; mask_4x4_0 >>= 1 ; mask_4x4_int_0 >>= 1 ; mask_16x16_1 >>= 1 ; mask_8x8_1 >>= 1 ; mask_4x4_1 >>= 1 ; mask_4x4_int_1 >>= 1 ; } }","static void filter_selectively_vert_row2 ( int subsampling_factor , uint8_t * s , int pitch , unsigned int mask_16x16_l , unsigned int mask_8x8_l , unsigned int mask_4x4_l , unsigned int mask_4x4_int_l , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) {const int mask_shift = subsampling_factor ? 4 : 8 ;const int mask_cutoff = subsampling_factor ? 0xf : 0xff ;const int lfl_forward = subsampling_factor ? 4 : 8 ;unsigned int mask_16x16_0 = mask_16x16_l & mask_cutoff ;",2516
498,"buggy line: const loop_filter_thresh * lfi0 = lfi_n -> lfthr + * lfl ;const loop_filter_thresh * lfi1 = lfi_n -> lfthr + * ( lfl + lfl_forward ) ;if ( mask & 1 ) {if ( ( mask_16x16_0 | mask_16x16_1 ) & 1 ) {if ( ( mask_16x16_0 & mask_16x16_1 ) & 1 ) {vp9_lpf_vertical_16_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim ,  lfi1 -> lim , lfi1 -> hev_thr ) ;if ( ( mask_8x8_0 & mask_8x8_1 ) & 1 ) {vp9_lpf_vertical_8_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ,  1 ) ;vp9_lpf_vertical_8 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ;if ( ( mask_4x4_0 & mask_4x4_1 ) & 1 ) {vp9_lpf_vertical_4_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_4 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ,  1 ) ;vp9_lpf_vertical_4 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ;vp9_lpf_vertical_4_dual ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_4 ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , 1 ) ;vp9_lpf_vertical_4 ( s + 8 * pitch + 4 , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ;cwe id:CWE-119context:  static void filter_selectively_vert_row2 ( PLANE_TYPE plane_type ,  uint8_t * s , int pitch , unsigned int mask_16x16_l , unsigned int mask_8x8_l , unsigned int mask_4x4_l , unsigned int mask_4x4_int_l , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) {  const int mask_shift = plane_type ? 4 : 8 ;   const int mask_cutoff = plane_type ? 0xf : 0xff ;   const int lfl_forward = plane_type ? 4 : 8 ;  unsigned int mask_16x16_0 = mask_16x16_l & mask_cutoff ; unsigned int mask_8x8_0 = mask_8x8_l & mask_cutoff ; unsigned int mask_4x4_0 = mask_4x4_l & mask_cutoff ; unsigned int mask_4x4_int_0 = mask_4x4_int_l & mask_cutoff ; unsigned int mask_16x16_1 = ( mask_16x16_l >> mask_shift ) & mask_cutoff ; unsigned int mask_8x8_1 = ( mask_8x8_l >> mask_shift ) & mask_cutoff ; unsigned int mask_4x4_1 = ( mask_4x4_l >> mask_shift ) & mask_cutoff ; unsigned int mask_4x4_int_1 = ( mask_4x4_int_l >> mask_shift ) & mask_cutoff ; unsigned int mask ; for ( mask = mask_16x16_0 | mask_8x8_0 | mask_4x4_0 | mask_4x4_int_0 | mask_16x16_1 | mask_8x8_1 | mask_4x4_1 | mask_4x4_int_1 ; mask ; mask >>= 1 ) { const loop_filter_thresh * lfi0 = lfi_n -> lfthr + * lfl ; const loop_filter_thresh * lfi1 = lfi_n -> lfthr + * ( lfl + lfl_forward ) ; if ( mask & 1 ) { if ( ( mask_16x16_0 | mask_16x16_1 ) & 1 ) { if ( ( mask_16x16_0 & mask_16x16_1 ) & 1 ) {  vp9_lpf_vertical_16_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr ) ; } else if ( mask_16x16_0 & 1 ) {  vp9_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr ) ; } else {  vp9_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim ,  lfi1 -> lim , lfi1 -> hev_thr ) ; } } if ( ( mask_8x8_0 | mask_8x8_1 ) & 1 ) { if ( ( mask_8x8_0 & mask_8x8_1 ) & 1 ) {  vp9_lpf_vertical_8_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ; } else if ( mask_8x8_0 & 1 ) {  vp9_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ,  1 ) ; } else {  vp9_lpf_vertical_8 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ; } } if ( ( mask_4x4_0 | mask_4x4_1 ) & 1 ) { if ( ( mask_4x4_0 & mask_4x4_1 ) & 1 ) {  vp9_lpf_vertical_4_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ; } else if ( mask_4x4_0 & 1 ) {  vp9_lpf_vertical_4 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ,  1 ) ; } else {  vp9_lpf_vertical_4 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ; } } if ( ( mask_4x4_int_0 | mask_4x4_int_1 ) & 1 ) { if ( ( mask_4x4_int_0 & mask_4x4_int_1 ) & 1 ) {  vp9_lpf_vertical_4_dual ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ; } else if ( mask_4x4_int_0 & 1 ) {  vp9_lpf_vertical_4 ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , 1 ) ; } else {  vp9_lpf_vertical_4 ( s + 8 * pitch + 4 , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ; } } } s += 8 ; lfl += 1 ; mask_16x16_0 >>= 1 ; mask_8x8_0 >>= 1 ; mask_4x4_0 >>= 1 ; mask_4x4_int_0 >>= 1 ; mask_16x16_1 >>= 1 ; mask_8x8_1 >>= 1 ; mask_4x4_1 >>= 1 ; mask_4x4_int_1 >>= 1 ; } }","vpx_lpf_vertical_16_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vpx_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , 1 ) ;vpx_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr , 1 ) ;vpx_lpf_vertical_8_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vpx_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , 1 ) ;vpx_lpf_vertical_8 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr , 1 ) ;vp9_lpf_vertical_4_dual ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_4 ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , 1 ) ;vpx_lpf_vertical_4 ( s + 8 * pitch + 4 , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr , 1 ) ;",2516
499,"buggy line: struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ;struct netdev_desc * desc ;case SIOCDEVPRIVATE :  break ;case SIOCDEVPRIVATE + 1 :   miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ;break ;case SIOCDEVPRIVATE + 2 :   mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ;break ;cwe id:CWE-264context: static int rio_ioctl ( struct net_device * dev , struct ifreq * rq , int cmd ) { int phy_addr ; struct netdev_private * np = netdev_priv ( dev ) ;  struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ;  struct netdev_desc * desc ; int i ; phy_addr = np -> phy_addr ; switch ( cmd ) {  case SIOCDEVPRIVATE :  break ;  case SIOCDEVPRIVATE + 1 :   miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ;  break ;  case SIOCDEVPRIVATE + 2 :   mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ;  break ; case SIOCDEVPRIVATE + 3 : break ; case SIOCDEVPRIVATE + 4 : break ; case SIOCDEVPRIVATE + 5 : netif_stop_queue ( dev ) ; break ; case SIOCDEVPRIVATE + 6 : netif_wake_queue ( dev ) ; break ; case SIOCDEVPRIVATE + 7 : printk ( ""tx_full=%x<S2SV_blank>cur_tx=%lx<S2SV_blank>old_tx=%lx<S2SV_blank>cur_rx=%lx<S2SV_blank>old_rx=%lx\\n"" , netif_queue_stopped ( dev ) , np -> cur_tx , np -> old_tx , np -> cur_rx , np -> old_rx ) ; break ; case SIOCDEVPRIVATE + 8 : printk ( ""TX<S2SV_blank>ring:\\n"" ) ; for ( i = 0 ; i < TX_RING_SIZE ; i ++ ) { desc = & np -> tx_ring [ i ] ; printk ( ""%02x:cur:%08x<S2SV_blank>next:%08x<S2SV_blank>status:%08x<S2SV_blank>frag1:%08x<S2SV_blank>frag0:%08x"" , i , ( u32 ) ( np -> tx_ring_dma + i * sizeof ( * desc ) ) , ( u32 ) le64_to_cpu ( desc -> next_desc ) , ( u32 ) le64_to_cpu ( desc -> status ) , ( u32 ) ( le64_to_cpu ( desc -> fraginfo ) >> 32 ) , ( u32 ) le64_to_cpu ( desc -> fraginfo ) ) ; printk ( ""\\n"" ) ; } printk ( ""\\n"" ) ; break ; default : return - EOPNOTSUPP ; } return 0 ; }","struct mii_ioctl_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ;struct netdev_desc * desc ;case SIOCGMIIPHY : miidata -> phy_id = phy_addr ;break ;case SIOCGMIIREG : miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ;break ;case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ;mii_write ( dev , phy_addr , miidata -> val_in ) ;break ;",2517
500,"buggy line: if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) {log ( ""cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>fractal<S2SV_blank>heap<S2SV_blank>indirect<S2SV_blank>block\\\log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s\\\if ( fgetc ( reader -> fhd ) != 0 ) {cwe id:CWE-787context: static int directblockRead ( struct READER * reader , struct DATAOBJECT * dataobject , struct FRACTALHEAP * fractalheap ) { char buf [ 4 ] , * name , * value ; int size , offset_size , length_size , err , len ; uint8_t typeandversion ; uint64_t unknown , heap_header_address , block_offset , block_size , offset , length ; long store ; struct DIR * dir ; struct MYSOFA_ATTRIBUTE * attr ; UNUSED ( offset ) ; UNUSED ( block_size ) ; UNUSED ( block_offset ) ;  if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) {  log ( ""cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>fractal<S2SV_blank>heap<S2SV_blank>indirect<S2SV_blank>block\\n"" ) ; return MYSOFA_INVALID_FORMAT ; }  log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s\\n"" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ;  if ( fgetc ( reader -> fhd ) != 0 ) { log ( ""object<S2SV_blank>FHDB<S2SV_blank>must<S2SV_blank>have<S2SV_blank>version<S2SV_blank>0\\n"" ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } if ( fseek ( reader -> fhd , reader -> superblock . size_of_offsets , SEEK_CUR ) < 0 ) return errno ; size = ( fractalheap -> maximum_heap_size + 7 ) / 8 ; block_offset = readValue ( reader , size ) ; if ( fractalheap -> flags & 2 ) if ( fseek ( reader -> fhd , 4 , SEEK_CUR ) ) return errno ; offset_size = ceilf ( log2f ( fractalheap -> maximum_heap_size ) / 8 ) ; if ( fractalheap -> maximum_direct_block_size < fractalheap -> maximum_size ) length_size = ceilf ( log2f ( fractalheap -> maximum_direct_block_size ) / 8 ) ; else length_size = ceilf ( log2f ( fractalheap -> maximum_size ) / 8 ) ; log ( ""<S2SV_blank>%d<S2SV_blank>%"" PRIu64 ""<S2SV_blank>%d\\n"" , size , block_offset , offset_size ) ; do { typeandversion = ( uint8_t ) fgetc ( reader -> fhd ) ; offset = readValue ( reader , offset_size ) ; length = readValue ( reader , length_size ) ; if ( offset > 0x10000000 || length > 0x10000000 ) return MYSOFA_UNSUPPORTED_FORMAT ; log ( ""<S2SV_blank>%d<S2SV_blank>%4"" PRIX64 ""<S2SV_blank>%"" PRIX64 ""<S2SV_blank>%08lX\\n"" , typeandversion , offset , length , ftell ( reader -> fhd ) ) ; if ( typeandversion == 3 ) { if ( readValue ( reader , 5 ) != 0x0000040008 ) { log ( ""FHDB<S2SV_blank>type<S2SV_blank>3<S2SV_blank>unsupported<S2SV_blank>values"" ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } if ( ! ( name = malloc ( length + 1 ) ) ) return MYSOFA_NO_MEMORY ; if ( fread ( name , 1 , length , reader -> fhd ) != length ) { free ( name ) ; return MYSOFA_READ_ERROR ; } name [ length ] = 0 ; if ( readValue ( reader , 4 ) != 0x00000013 ) { log ( ""FHDB<S2SV_blank>type<S2SV_blank>3<S2SV_blank>unsupported<S2SV_blank>values"" ) ; free ( name ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } len = ( int ) readValue ( reader , 2 ) ; if ( len > 0x1000 || len < 0 ) { free ( name ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } unknown = readValue ( reader , 6 ) ; if ( unknown == 0x000000020200 ) value = NULL ; else if ( unknown == 0x000000020000 ) { if ( ! ( value = malloc ( len + 1 ) ) ) { free ( name ) ; return MYSOFA_NO_MEMORY ; } if ( fread ( value , 1 , len , reader -> fhd ) != len ) { free ( value ) ; free ( name ) ; return MYSOFA_READ_ERROR ; } value [ len ] = 0 ; } else if ( unknown == 0x20000020000 ) { if ( ! ( value = malloc ( 5 ) ) ) { free ( name ) ; return MYSOFA_NO_MEMORY ; } strcpy ( value , """" ) ; } else { log ( ""FHDB<S2SV_blank>type<S2SV_blank>3<S2SV_blank>unsupported<S2SV_blank>values:<S2SV_blank>%12"" PRIX64 ""\\n"" , unknown ) ; free ( name ) ; return MYSOFA_OK ; } log ( ""<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s\\n"" , name , value ) ; attr = malloc ( sizeof ( struct MYSOFA_ATTRIBUTE ) ) ; attr -> name = name ; attr -> value = value ; attr -> next = dataobject -> attributes ; dataobject -> attributes = attr ; } else if ( typeandversion == 1 ) { unknown = readValue ( reader , 6 ) ; if ( unknown ) { log ( ""FHDB<S2SV_blank>type<S2SV_blank>1<S2SV_blank>unsupported<S2SV_blank>values\\n"" ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } len = fgetc ( reader -> fhd ) ; if ( len < 0 ) return MYSOFA_READ_ERROR ; assert ( len < 0x100 ) ; if ( ! ( name = malloc ( len + 1 ) ) ) return MYSOFA_NO_MEMORY ; if ( fread ( name , 1 , len , reader -> fhd ) != len ) { free ( name ) ; return MYSOFA_READ_ERROR ; } name [ len ] = 0 ; heap_header_address = readValue ( reader , reader -> superblock . size_of_offsets ) ; log ( ""\\nfractal<S2SV_blank>head<S2SV_blank>type<S2SV_blank>1<S2SV_blank>length<S2SV_blank>%4"" PRIX64 ""<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>%"" PRIX64 ""\\n"" , length , name , heap_header_address ) ; dir = malloc ( sizeof ( struct DIR ) ) ; if ( ! dir ) { free ( name ) ; return MYSOFA_NO_MEMORY ; } memset ( dir , 0 , sizeof ( * dir ) ) ; dir -> next = dataobject -> directory ; dataobject -> directory = dir ; store = ftell ( reader -> fhd ) ; if ( fseek ( reader -> fhd , heap_header_address , SEEK_SET ) ) { free ( name ) ; return errno ; } err = dataobjectRead ( reader , & dir -> dataobject , name ) ; if ( err ) { return err ; } if ( store < 0 ) { return errno ; } if ( fseek ( reader -> fhd , store , SEEK_SET ) < 0 ) return errno ; } else if ( typeandversion != 0 ) { log ( ""fractal<S2SV_blank>head<S2SV_blank>unknown<S2SV_blank>type<S2SV_blank>%d\\n"" , typeandversion ) ; return MYSOFA_OK ; } } while ( typeandversion != 0 ) ;  return MYSOFA_OK ;  }","if ( reader -> recursive_counter >= 10 ) return MYSOFA_INVALID_FORMAT ;else reader -> recursive_counter ++ ;if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) {log ( ""cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>fractal<S2SV_blank>heap<S2SV_blank>indirect<S2SV_blank>block\\\log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s<S2SV_blank>stack<S2SV_blank>%d\\\if ( fgetc ( reader -> fhd ) != 0 ) {",2518
501,"buggy line: return MYSOFA_OK ;}cwe id:CWE-787context: static int directblockRead ( struct READER * reader , struct DATAOBJECT * dataobject , struct FRACTALHEAP * fractalheap ) { char buf [ 4 ] , * name , * value ; int size , offset_size , length_size , err , len ; uint8_t typeandversion ; uint64_t unknown , heap_header_address , block_offset , block_size , offset , length ; long store ; struct DIR * dir ; struct MYSOFA_ATTRIBUTE * attr ; UNUSED ( offset ) ; UNUSED ( block_size ) ; UNUSED ( block_offset ) ;  if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) {  log ( ""cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>fractal<S2SV_blank>heap<S2SV_blank>indirect<S2SV_blank>block\\n"" ) ; return MYSOFA_INVALID_FORMAT ; }  log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s\\n"" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ;  if ( fgetc ( reader -> fhd ) != 0 ) { log ( ""object<S2SV_blank>FHDB<S2SV_blank>must<S2SV_blank>have<S2SV_blank>version<S2SV_blank>0\\n"" ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } if ( fseek ( reader -> fhd , reader -> superblock . size_of_offsets , SEEK_CUR ) < 0 ) return errno ; size = ( fractalheap -> maximum_heap_size + 7 ) / 8 ; block_offset = readValue ( reader , size ) ; if ( fractalheap -> flags & 2 ) if ( fseek ( reader -> fhd , 4 , SEEK_CUR ) ) return errno ; offset_size = ceilf ( log2f ( fractalheap -> maximum_heap_size ) / 8 ) ; if ( fractalheap -> maximum_direct_block_size < fractalheap -> maximum_size ) length_size = ceilf ( log2f ( fractalheap -> maximum_direct_block_size ) / 8 ) ; else length_size = ceilf ( log2f ( fractalheap -> maximum_size ) / 8 ) ; log ( ""<S2SV_blank>%d<S2SV_blank>%"" PRIu64 ""<S2SV_blank>%d\\n"" , size , block_offset , offset_size ) ; do { typeandversion = ( uint8_t ) fgetc ( reader -> fhd ) ; offset = readValue ( reader , offset_size ) ; length = readValue ( reader , length_size ) ; if ( offset > 0x10000000 || length > 0x10000000 ) return MYSOFA_UNSUPPORTED_FORMAT ; log ( ""<S2SV_blank>%d<S2SV_blank>%4"" PRIX64 ""<S2SV_blank>%"" PRIX64 ""<S2SV_blank>%08lX\\n"" , typeandversion , offset , length , ftell ( reader -> fhd ) ) ; if ( typeandversion == 3 ) { if ( readValue ( reader , 5 ) != 0x0000040008 ) { log ( ""FHDB<S2SV_blank>type<S2SV_blank>3<S2SV_blank>unsupported<S2SV_blank>values"" ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } if ( ! ( name = malloc ( length + 1 ) ) ) return MYSOFA_NO_MEMORY ; if ( fread ( name , 1 , length , reader -> fhd ) != length ) { free ( name ) ; return MYSOFA_READ_ERROR ; } name [ length ] = 0 ; if ( readValue ( reader , 4 ) != 0x00000013 ) { log ( ""FHDB<S2SV_blank>type<S2SV_blank>3<S2SV_blank>unsupported<S2SV_blank>values"" ) ; free ( name ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } len = ( int ) readValue ( reader , 2 ) ; if ( len > 0x1000 || len < 0 ) { free ( name ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } unknown = readValue ( reader , 6 ) ; if ( unknown == 0x000000020200 ) value = NULL ; else if ( unknown == 0x000000020000 ) { if ( ! ( value = malloc ( len + 1 ) ) ) { free ( name ) ; return MYSOFA_NO_MEMORY ; } if ( fread ( value , 1 , len , reader -> fhd ) != len ) { free ( value ) ; free ( name ) ; return MYSOFA_READ_ERROR ; } value [ len ] = 0 ; } else if ( unknown == 0x20000020000 ) { if ( ! ( value = malloc ( 5 ) ) ) { free ( name ) ; return MYSOFA_NO_MEMORY ; } strcpy ( value , """" ) ; } else { log ( ""FHDB<S2SV_blank>type<S2SV_blank>3<S2SV_blank>unsupported<S2SV_blank>values:<S2SV_blank>%12"" PRIX64 ""\\n"" , unknown ) ; free ( name ) ; return MYSOFA_OK ; } log ( ""<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s\\n"" , name , value ) ; attr = malloc ( sizeof ( struct MYSOFA_ATTRIBUTE ) ) ; attr -> name = name ; attr -> value = value ; attr -> next = dataobject -> attributes ; dataobject -> attributes = attr ; } else if ( typeandversion == 1 ) { unknown = readValue ( reader , 6 ) ; if ( unknown ) { log ( ""FHDB<S2SV_blank>type<S2SV_blank>1<S2SV_blank>unsupported<S2SV_blank>values\\n"" ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } len = fgetc ( reader -> fhd ) ; if ( len < 0 ) return MYSOFA_READ_ERROR ; assert ( len < 0x100 ) ; if ( ! ( name = malloc ( len + 1 ) ) ) return MYSOFA_NO_MEMORY ; if ( fread ( name , 1 , len , reader -> fhd ) != len ) { free ( name ) ; return MYSOFA_READ_ERROR ; } name [ len ] = 0 ; heap_header_address = readValue ( reader , reader -> superblock . size_of_offsets ) ; log ( ""\\nfractal<S2SV_blank>head<S2SV_blank>type<S2SV_blank>1<S2SV_blank>length<S2SV_blank>%4"" PRIX64 ""<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>%"" PRIX64 ""\\n"" , length , name , heap_header_address ) ; dir = malloc ( sizeof ( struct DIR ) ) ; if ( ! dir ) { free ( name ) ; return MYSOFA_NO_MEMORY ; } memset ( dir , 0 , sizeof ( * dir ) ) ; dir -> next = dataobject -> directory ; dataobject -> directory = dir ; store = ftell ( reader -> fhd ) ; if ( fseek ( reader -> fhd , heap_header_address , SEEK_SET ) ) { free ( name ) ; return errno ; } err = dataobjectRead ( reader , & dir -> dataobject , name ) ; if ( err ) { return err ; } if ( store < 0 ) { return errno ; } if ( fseek ( reader -> fhd , store , SEEK_SET ) < 0 ) return errno ; } else if ( typeandversion != 0 ) { log ( ""fractal<S2SV_blank>head<S2SV_blank>unknown<S2SV_blank>type<S2SV_blank>%d\\n"" , typeandversion ) ; return MYSOFA_OK ; } } while ( typeandversion != 0 ) ;  return MYSOFA_OK ;  }",reader -> recursive_counter -- ;return MYSOFA_OK ;},2518
502,"buggy line: rhost_old [ 0 ] = \'\\\\0\' ;r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ;cwe id:CWE-476context: int upnp_redirect ( const char * rhost , unsigned short eport , const char * iaddr , unsigned short iport , const char * protocol , const char * desc , unsigned int leaseduration ) { int proto , r ; char iaddr_old [ 32 ] ; char rhost_old [ 32 ] ; unsigned short iport_old ; struct in_addr address ; unsigned int timestamp ; proto = proto_atoi ( protocol ) ; if ( inet_aton ( iaddr , & address ) <= 0 ) { syslog ( LOG_ERR , ""inet_aton(%s)<S2SV_blank>FAILED"" , iaddr ) ; return - 1 ; } if ( ! check_upnp_rule_against_permissions ( upnppermlist , num_upnpperm , eport , address , iport ) ) { syslog ( LOG_INFO , ""redirection<S2SV_blank>permission<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>"" ""%hu->%s:%hu<S2SV_blank>%s"" , eport , iaddr , iport , protocol ) ; return - 3 ; }  rhost_old [ 0 ] = '\\0' ;  r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ; if ( r == 0 ) { if ( strcmp ( iaddr , iaddr_old ) == 0 && ( ( rhost == NULL && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , ""*"" ) == 0 ) && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , rhost_old ) == 0 ) ) ) ) { syslog ( LOG_INFO , ""updating<S2SV_blank>existing<S2SV_blank>port<S2SV_blank>mapping<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>=><S2SV_blank>%s:%hu"" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; if ( iport != iport_old ) { r = update_portmapping ( ext_if_name , eport , proto , iport , desc , timestamp ) ; } else { r = update_portmapping_desc_timestamp ( ext_if_name , eport , proto , desc , timestamp ) ; } # ifdef ENABLE_LEASEFILE if ( r == 0 ) { lease_file_remove ( eport , proto ) ; lease_file_add ( eport , iaddr , iport , proto , desc , timestamp ) ; } # endif return r ; } else { syslog ( LOG_INFO , ""port<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>already<S2SV_blank>redirected<S2SV_blank>to<S2SV_blank>%s:%hu"" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; return - 2 ; } # ifdef CHECK_PORTINUSE } else if ( port_in_use ( ext_if_name , eport , proto , iaddr , iport ) > 0 ) { syslog ( LOG_INFO , ""port<S2SV_blank>%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use"" , eport , protocol ) ; return - 4 ; # endif } else { timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; syslog ( LOG_INFO , ""redirecting<S2SV_blank>port<S2SV_blank>%hu<S2SV_blank>to<S2SV_blank>%s:%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>for:<S2SV_blank>%s"" , eport , iaddr , iport , protocol , desc ) ; return upnp_redirect_internal ( rhost , eport , iaddr , iport , proto , desc , timestamp ) ; } }","if ( desc == NULL ) desc = """" ;rhost_old [ 0 ] = \'\\\\0\' ;r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ;",2519
503,"buggy line: static int  _PyMemoTable_ResizeTable ( PyMemoTable * self , Py_ssize_t min_size )  {Py_ssize_t new_size = MT_MINSIZE ;Py_ssize_t to_process ;assert ( min_size > 0 ) ;while ( new_size < min_size && new_size > 0 )  new_size <<= 1 ;if ( new_size <= 0 ) {cwe id:CWE-190context: static int  _PyMemoTable_ResizeTable ( PyMemoTable * self , Py_ssize_t min_size )  { PyMemoEntry * oldtable = NULL ; PyMemoEntry * oldentry , * newentry ;  Py_ssize_t new_size = MT_MINSIZE ;   Py_ssize_t to_process ;  assert ( min_size > 0 ) ;  while ( new_size < min_size && new_size > 0 )  new_size <<= 1 ; if ( new_size <= 0 ) { PyErr_NoMemory ( ) ; return - 1 ; } assert ( ( new_size & ( new_size - 1 ) ) == 0 ) ; oldtable = self -> mt_table ; self -> mt_table = PyMem_NEW ( PyMemoEntry , new_size ) ; if ( self -> mt_table == NULL ) { self -> mt_table = oldtable ; PyErr_NoMemory ( ) ; return - 1 ; } self -> mt_allocated = new_size ; self -> mt_mask = new_size - 1 ; memset ( self -> mt_table , 0 , sizeof ( PyMemoEntry ) * new_size ) ; to_process = self -> mt_used ; for ( oldentry = oldtable ; to_process > 0 ; oldentry ++ ) { if ( oldentry -> me_key != NULL ) { to_process -- ; newentry = _PyMemoTable_Lookup ( self , oldentry -> me_key ) ; newentry -> me_key = oldentry -> me_key ; newentry -> me_value = oldentry -> me_value ; } } PyMem_FREE ( oldtable ) ; return 0 ; }","static int _PyMemoTable_ResizeTable ( PyMemoTable * self , size_t min_size ) {size_t new_size = MT_MINSIZE ;Py_ssize_t to_process ;assert ( min_size > 0 ) ;if ( min_size > PY_SSIZE_T_MAX ) {while ( new_size < min_size ) {new_size <<= 1 ;}",2520
504,"buggy line: struct stat st ;size_t pathlen ;cwe id:CWE-59context: static int get_default_root ( pool * p , int allow_symlinks , char * * root ) { config_rec * c = NULL ; char * dir = NULL ; int res ; c = find_config ( main_server -> conf , CONF_PARAM , ""DefaultRoot"" , FALSE ) ; while ( c ) { pr_signals_handle ( ) ; if ( c -> argc < 2 ) { dir = c -> argv [ 0 ] ; break ; } res = pr_expr_eval_group_and ( ( ( char * * ) c -> argv ) + 1 ) ; if ( res ) { dir = c -> argv [ 0 ] ; break ; } c = find_config_next ( c , c -> next , CONF_PARAM , ""DefaultRoot"" , FALSE ) ; } if ( dir ) { char * new_dir ; new_dir = path_subst_uservar ( p , & dir ) ; if ( new_dir != NULL ) { dir = new_dir ; } if ( strncmp ( dir , ""/"" , 2 ) == 0 ) { dir = NULL ; } else { char * realdir ; int xerrno = 0 ; if ( allow_symlinks == FALSE ) { char * path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ;  struct stat st ;  size_t pathlen ; path = dir ; if ( * path != '/' ) { if ( * path == '~' ) { if ( pr_fs_interpolate ( dir , target_path , sizeof ( target_path ) - 1 ) < 0 ) { return - 1 ; } path = target_path ; } } pathlen = strlen ( path ) ; if ( pathlen > 1 && path [ pathlen - 1 ] == '/' ) { path [ pathlen - 1 ] = '\\0' ; }  pr_fs_clear_cache ( ) ;  res = pr_fsio_lstat ( path , & st ) ; if ( res < 0 ) {  xerrno = errno ;   pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path ,  strerror ( xerrno ) ) ; errno = xerrno ; return - 1 ; } if ( S_ISLNK ( st . st_mode ) ) { pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>"" ""config)"" , path ) ; errno = EPERM ; return - 1 ; } } PRIVS_USER realdir = dir_realpath ( p , dir ) ; xerrno = errno ; PRIVS_RELINQUISH if ( realdir ) { dir = realdir ; } else { char interp_dir [ PR_TUNABLE_PATH_MAX + 1 ] ; memset ( interp_dir , '\\0' , sizeof ( interp_dir ) ) ; ( void ) pr_fs_interpolate ( dir , interp_dir , sizeof ( interp_dir ) - 1 ) ; pr_log_pri ( PR_LOG_NOTICE , ""notice:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>DefaultRoot<S2SV_blank>\'%s\'<S2SV_blank>[resolved<S2SV_blank>to<S2SV_blank>\'%s\']:<S2SV_blank>%s"" , dir , interp_dir , strerror ( xerrno ) ) ; errno = xerrno ; } } } * root = dir ; return 0 ; }",size_t pathlen ;,2521
505,"buggy line: pr_fs_clear_cache ( ) ;res = pr_fsio_lstat ( path , & st ) ;xerrno = errno ;pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path ,  strerror ( xerrno ) ) ;errno = xerrno ;return - 1 ;if ( S_ISLNK ( st . st_mode ) ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>"" ""config)"" , path ) ;cwe id:CWE-59context: static int get_default_root ( pool * p , int allow_symlinks , char * * root ) { config_rec * c = NULL ; char * dir = NULL ; int res ; c = find_config ( main_server -> conf , CONF_PARAM , ""DefaultRoot"" , FALSE ) ; while ( c ) { pr_signals_handle ( ) ; if ( c -> argc < 2 ) { dir = c -> argv [ 0 ] ; break ; } res = pr_expr_eval_group_and ( ( ( char * * ) c -> argv ) + 1 ) ; if ( res ) { dir = c -> argv [ 0 ] ; break ; } c = find_config_next ( c , c -> next , CONF_PARAM , ""DefaultRoot"" , FALSE ) ; } if ( dir ) { char * new_dir ; new_dir = path_subst_uservar ( p , & dir ) ; if ( new_dir != NULL ) { dir = new_dir ; } if ( strncmp ( dir , ""/"" , 2 ) == 0 ) { dir = NULL ; } else { char * realdir ; int xerrno = 0 ; if ( allow_symlinks == FALSE ) { char * path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ;  struct stat st ;  size_t pathlen ; path = dir ; if ( * path != '/' ) { if ( * path == '~' ) { if ( pr_fs_interpolate ( dir , target_path , sizeof ( target_path ) - 1 ) < 0 ) { return - 1 ; } path = target_path ; } } pathlen = strlen ( path ) ; if ( pathlen > 1 && path [ pathlen - 1 ] == '/' ) { path [ pathlen - 1 ] = '\\0' ; }  pr_fs_clear_cache ( ) ;  res = pr_fsio_lstat ( path , & st ) ; if ( res < 0 ) {  xerrno = errno ;   pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path ,  strerror ( xerrno ) ) ; errno = xerrno ; return - 1 ; } if ( S_ISLNK ( st . st_mode ) ) { pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>"" ""config)"" , path ) ; errno = EPERM ; return - 1 ; } } PRIVS_USER realdir = dir_realpath ( p , dir ) ; xerrno = errno ; PRIVS_RELINQUISH if ( realdir ) { dir = realdir ; } else { char interp_dir [ PR_TUNABLE_PATH_MAX + 1 ] ; memset ( interp_dir , '\\0' , sizeof ( interp_dir ) ) ; ( void ) pr_fs_interpolate ( dir , interp_dir , sizeof ( interp_dir ) - 1 ) ; pr_log_pri ( PR_LOG_NOTICE , ""notice:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>DefaultRoot<S2SV_blank>\'%s\'<S2SV_blank>[resolved<S2SV_blank>to<S2SV_blank>\'%s\']:<S2SV_blank>%s"" , dir , interp_dir , strerror ( xerrno ) ) ; errno = xerrno ; } } } * root = dir ; return 0 ; }","res = is_symlink_path ( p , path , pathlen ) ;if ( errno == EPERM ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ;",2521
506,"buggy line: static void prefetch_dec ( void )  {prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ;cwe id:CWE-310context: static void prefetch_dec ( void )  {  prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ; }","static void prefetch_dec ( void ) {dec_tables . counter_head ++ ;dec_tables . counter_tail ++ ;prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ;",2522
507,"buggy line: gdImageWBMPCtx ( im , fg , out ) ;rv = gdDPExtractData ( out , size ) ;out -> gd_free ( out ) ;cwe id:CWE-415context: void * gdImageWBMPPtr ( gdImagePtr im , int * size , int fg ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;  gdImageWBMPCtx ( im , fg , out ) ;   rv = gdDPExtractData ( out , size ) ;  out -> gd_free ( out ) ; return rv ; }","if ( ! _gdImageWBMPCtx ( im , fg , out ) ) {rv = gdDPExtractData ( out , size ) ;}else {rv = NULL ;}out -> gd_free ( out ) ;",2523
508,"buggy line: parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;parameters -> prch_init [ i ] = 256 ;}cwe id:CWE-787context: static void opj_j2k_set_cinema_parameters ( opj_cparameters_t * parameters , opj_image_t * image , opj_event_mgr_t * p_manager ) { int i ; parameters -> tile_size_on = OPJ_FALSE ; parameters -> cp_tdx = 1 ; parameters -> cp_tdy = 1 ; parameters -> tp_flag = 'C' ; parameters -> tp_on = 1 ; parameters -> cp_tx0 = 0 ; parameters -> cp_ty0 = 0 ; parameters -> image_offset_x0 = 0 ; parameters -> image_offset_y0 = 0 ; parameters -> cblockw_init = 32 ; parameters -> cblockh_init = 32 ; parameters -> mode = 0 ; parameters -> roi_compno = - 1 ; parameters -> subsampling_dx = 1 ; parameters -> subsampling_dy = 1 ; parameters -> irreversible = 1 ; if ( parameters -> tcp_numlayers > 1 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""1<S2SV_blank>single<S2SV_blank>quality<S2SV_blank>layer"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>layers<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" ""-><S2SV_blank>Rate<S2SV_blank>of<S2SV_blank>the<S2SV_blank>last<S2SV_blank>layer<S2SV_blank>(%3.1f)<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used"" , parameters -> tcp_numlayers , parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ) ; parameters -> tcp_rates [ 0 ] = parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ; parameters -> tcp_numlayers = 1 ; } switch ( parameters -> rsiz ) { case OPJ_PROFILE_CINEMA_2K : if ( parameters -> numresolution > 6 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>(2k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank><=<S2SV_blank>5\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>5<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 6 ; } break ; case OPJ_PROFILE_CINEMA_4K : if ( parameters -> numresolution < 2 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 1 ; } else if ( parameters -> numresolution > 7 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>6<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 7 ; } break ; default : break ; } parameters -> csty |= 0x01 ;  parameters -> res_spec = parameters -> numresolution - 1 ;  for ( i = 0 ; i < parameters -> res_spec ; i ++ ) { parameters -> prcw_init [ i ] = 256 ;  parameters -> prch_init [ i ] = 256 ;  } parameters -> prog_order = OPJ_CPRL ; if ( parameters -> rsiz == OPJ_PROFILE_CINEMA_4K ) { parameters -> numpocs = ( OPJ_UINT32 ) opj_j2k_initialise_4K_poc ( parameters -> POC , parameters -> numresolution ) ; } else { parameters -> numpocs = 0 ; } parameters -> cp_disto_alloc = 1 ; if ( parameters -> max_cs_size <= 0 ) { parameters -> max_cs_size = OPJ_CINEMA_24_CS ; opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n"" ) ; } else if ( parameters -> max_cs_size > OPJ_CINEMA_24_CS ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1302083<S2SV_blank>bytes.\\n"" ) ; parameters -> max_cs_size = OPJ_CINEMA_24_CS ; } if ( parameters -> max_comp_size <= 0 ) { parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n"" ) ; } else if ( parameters -> max_comp_size > OPJ_CINEMA_24_COMP ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1041666<S2SV_blank>bytes.\\n"" ) ; parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; } parameters -> tcp_rates [ 0 ] = ( OPJ_FLOAT32 ) ( image -> numcomps * image -> comps [ 0 ] . w * image -> comps [ 0 ] . h * image -> comps [ 0 ] . prec ) / ( OPJ_FLOAT32 ) ( ( ( OPJ_UINT32 ) parameters -> max_cs_size ) * 8 * image -> comps [ 0 ] . dx * image -> comps [ 0 ] . dy ) ; }",if ( parameters -> numresolution == 1 ) {parameters -> res_spec = 1 ;parameters -> prcw_init [ 0 ] = 128 ;parameters -> prch_init [ 0 ] = 128 ;}else {parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;}parameters -> prch_init [ i ] = 256 ;},2524
509,"buggy line: int copied , error = - EINVAL ;if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ;cwe id:CWE-200context: int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ;  int copied , error = - EINVAL ;  if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( ""%d<S2SV_blank>-=<S2SV_blank>%d\\n"" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }","int copied , error = - EINVAL ;msg -> msg_namelen = 0 ;if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ;",2525
510,"buggy line: goto try_again ;req -> status = 0 ;req -> zero = 0 ;req -> length = count ;req -> complete = f_hidg_req_complete ;req -> context = hidg ;status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ;if ( status < 0 ) {ERROR ( hidg -> func . config -> cdev , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\\goto release_write_pending_unlocked ;}spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;return status ;release_write_pending_unlocked :  hidg -> write_pending = 0 ;cwe id:CWE-189context: static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - ENOMEM ; if ( ! access_ok ( buffer , count ) ) return - EFAULT ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; # define WRITE_COND ( ! hidg -> write_pending ) try_again : while ( ! WRITE_COND ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & O_NONBLOCK ) return - EAGAIN ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , WRITE_COND ) ) return - ERESTARTSYS ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { ERROR ( hidg -> func . config -> cdev , ""copy_from_user<S2SV_blank>error\\n"" ) ; status = - EINVAL ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ;  status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ;  if ( status < 0 ) { ERROR ( hidg -> func . config -> cdev , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n"" , status ) ;  goto release_write_pending_unlocked ;  } else { status = count ; }  spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;  return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ;  release_write_pending_unlocked :  hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }","goto release_write_pending ;spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;return status ;release_write_pending_unlocked : hidg -> write_pending = 0 ;",2526
511,"buggy line: struct usmStateReference * old_ref = ( struct usmStateReference * ) old ;if ( old_ref ) {if ( old_ref -> usr_name_length ) SNMP_FREE ( old_ref -> usr_name ) ;if ( old_ref -> usr_engine_id_length )  SNMP_FREE ( old_ref -> usr_engine_id ) ;if ( old_ref -> usr_auth_protocol_length )  SNMP_FREE ( old_ref -> usr_auth_protocol ) ;if ( old_ref -> usr_priv_protocol_length )  SNMP_FREE ( old_ref -> usr_priv_protocol ) ;if ( old_ref -> usr_auth_key_length && old_ref -> usr_auth_key ) {SNMP_ZERO ( old_ref -> usr_auth_key , old_ref -> usr_auth_key_length ) ;SNMP_FREE ( old_ref -> usr_auth_key ) ;}if ( old_ref -> usr_priv_key_length && old_ref -> usr_priv_key ) {SNMP_ZERO ( old_ref -> usr_priv_key , old_ref -> usr_priv_key_length ) ;SNMP_FREE ( old_ref -> usr_priv_key ) ;}SNMP_ZERO ( old_ref , sizeof ( * old_ref ) ) ;SNMP_FREE ( old_ref ) ;}cwe id:CWE-415context: static void usm_free_usmStateReference ( void * old ) {  struct usmStateReference * old_ref = ( struct usmStateReference * ) old ;   if ( old_ref ) {  if ( old_ref -> usr_name_length ) SNMP_FREE ( old_ref -> usr_name ) ;  if ( old_ref -> usr_engine_id_length )  SNMP_FREE ( old_ref -> usr_engine_id ) ;  if ( old_ref -> usr_auth_protocol_length )  SNMP_FREE ( old_ref -> usr_auth_protocol ) ;  if ( old_ref -> usr_priv_protocol_length )  SNMP_FREE ( old_ref -> usr_priv_protocol ) ;  if ( old_ref -> usr_auth_key_length && old_ref -> usr_auth_key ) {   SNMP_ZERO ( old_ref -> usr_auth_key , old_ref -> usr_auth_key_length ) ;   SNMP_FREE ( old_ref -> usr_auth_key ) ;  }  if ( old_ref -> usr_priv_key_length && old_ref -> usr_priv_key ) {   SNMP_ZERO ( old_ref -> usr_priv_key , old_ref -> usr_priv_key_length ) ;   SNMP_FREE ( old_ref -> usr_priv_key ) ;  }  SNMP_ZERO ( old_ref , sizeof ( * old_ref ) ) ;  SNMP_FREE ( old_ref ) ; }  } ","struct usmStateReference * ref = old ;if ( old_ref ) {if ( old_ref -> usr_name_length ) SNMP_FREE ( old_ref -> usr_name ) ;SNMP_FREE ( ref -> usr_engine_id ) ;if ( old_ref -> usr_auth_protocol_length ) SNMP_FREE ( old_ref -> usr_auth_protocol ) ;SNMP_FREE ( ref -> usr_priv_protocol ) ;if ( old_ref -> usr_auth_key_length && old_ref -> usr_auth_key ) {SNMP_ZERO ( ref -> usr_auth_key , old_ref -> usr_auth_key_length ) ;SNMP_FREE ( ref -> usr_auth_key ) ;}if ( ref -> usr_priv_key_length && old_ref -> usr_priv_key ) {SNMP_ZERO ( ref -> usr_priv_key , old_ref -> usr_priv_key_length ) ;SNMP_FREE ( ref -> usr_priv_key ) ;}SNMP_ZERO ( old_ref , sizeof ( * old_ref ) ) ;SNMP_FREE ( old_ref ) ;}",2527
512,"buggy line: if ( status ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\cwe id:CWE-119context: static void command_port_read_callback ( struct urb * urb ) { struct usb_serial_port * command_port = urb -> context ; struct whiteheat_command_private * command_info ; int status = urb -> status ; unsigned char * data = urb -> transfer_buffer ; int result ; command_info = usb_get_serial_port_data ( command_port ) ; if ( ! command_info ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>command_info<S2SV_blank>is<S2SV_blank>NULL,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; }  if ( status ) {  dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\n"" , __func__ , status ) ; if ( status != - ENOENT ) command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; return ; } usb_serial_debug_data ( & command_port -> dev , __func__ , urb -> actual_length , data ) ; if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE ) { command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) { command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_EVENT ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>event<S2SV_blank>received\\n"" , __func__ ) ;  } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) {  memcpy ( command_info -> result_buffer , & data [ 1 ] ,  urb -> actual_length - 1 ) ;  command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>reply<S2SV_blank>from<S2SV_blank>firmware\\n"" , __func__ ) ; result = usb_submit_urb ( command_port -> read_urb , GFP_ATOMIC ) ; if ( result ) dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>resubmitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n"" , __func__ , result ) ; }","if ( ! urb -> actual_length ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\\return ;}if ( status ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\",2528
513,"buggy line: else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) {}else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) {memcpy ( command_info -> result_buffer , & data [ 1 ] ,  urb -> actual_length - 1 ) ;command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;cwe id:CWE-119context: static void command_port_read_callback ( struct urb * urb ) { struct usb_serial_port * command_port = urb -> context ; struct whiteheat_command_private * command_info ; int status = urb -> status ; unsigned char * data = urb -> transfer_buffer ; int result ; command_info = usb_get_serial_port_data ( command_port ) ; if ( ! command_info ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>command_info<S2SV_blank>is<S2SV_blank>NULL,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; }  if ( status ) {  dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\n"" , __func__ , status ) ; if ( status != - ENOENT ) command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; return ; } usb_serial_debug_data ( & command_port -> dev , __func__ , urb -> actual_length , data ) ; if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE ) { command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) { command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_EVENT ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>event<S2SV_blank>received\\n"" , __func__ ) ;  } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) {  memcpy ( command_info -> result_buffer , & data [ 1 ] ,  urb -> actual_length - 1 ) ;  command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>reply<S2SV_blank>from<S2SV_blank>firmware\\n"" , __func__ ) ; result = usb_submit_urb ( command_port -> read_urb , GFP_ATOMIC ) ; if ( result ) dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>resubmitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n"" , __func__ , result ) ; }","else if ( ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) {}else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) && ( urb -> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) {memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 ) ;command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;",2528
514,"buggy line: void ptrace_triggered ( struct perf_event * bp , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {cwe id:CWE-400context:  void ptrace_triggered ( struct perf_event * bp , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event_attr attr ; attr = bp -> attr ; attr . disabled = true ; modify_user_hw_breakpoint ( bp , & attr ) ; }","void ptrace_triggered ( struct perf_event * bp , struct perf_sample_data * data , struct pt_regs * regs ) {",2529
515,"buggy line: if ( plen > 1024 * 1024 - 1 ) goto error ;ret = key_get_type_from_user ( type , _type , sizeof ( type ) ) ;if ( ret < 0 ) goto error ;description = NULL ;if ( _description ) {description = strndup_user ( _description , KEY_MAX_DESC_SIZE ) ;if ( IS_ERR ( description ) ) {cwe id:CWE-476context: SYSCALL_DEFINE5 ( add_key , const char __user * , _type , const char __user * , _description , const void __user * , _payload , size_t , plen , key_serial_t , ringid ) { key_ref_t keyring_ref , key_ref ; char type [ 32 ] , * description ; void * payload ; long ret ; ret = - EINVAL ; if ( plen > 1024 * 1024 - 1 ) goto error ; ret = key_get_type_from_user ( type , _type , sizeof ( type ) ) ; if ( ret < 0 ) goto error ; description = NULL ; if ( _description ) { description = strndup_user ( _description , KEY_MAX_DESC_SIZE ) ; if ( IS_ERR ( description ) ) { ret = PTR_ERR ( description ) ; goto error ; } if ( ! * description ) { kfree ( description ) ; description = NULL ; } else if ( ( description [ 0 ] == '.' ) && ( strncmp ( type , ""keyring"" , 7 ) == 0 ) ) { ret = - EPERM ; goto error2 ; } } payload = NULL ;  if ( _payload ) {  ret = - ENOMEM ; payload = kvmalloc ( plen , GFP_KERNEL ) ; if ( ! payload ) goto error2 ; ret = - EFAULT ; if ( copy_from_user ( payload , _payload , plen ) != 0 ) goto error3 ; } keyring_ref = lookup_user_key ( ringid , KEY_LOOKUP_CREATE , KEY_NEED_WRITE ) ; if ( IS_ERR ( keyring_ref ) ) { ret = PTR_ERR ( keyring_ref ) ; goto error3 ; } key_ref = key_create_or_update ( keyring_ref , type , description , payload , plen , KEY_PERM_UNDEF , KEY_ALLOC_IN_QUOTA ) ; if ( ! IS_ERR ( key_ref ) ) { ret = key_ref_to_ptr ( key_ref ) -> serial ; key_ref_put ( key_ref ) ; } else { ret = PTR_ERR ( key_ref ) ; } key_ref_put ( keyring_ref ) ; error3 : kvfree ( payload ) ; error2 : kfree ( description ) ; error : return ret ; }",if ( plen ) {,2530
516,"buggy line: if ( _payload ) {ret = - ENOMEM ;cwe id:CWE-476context: SYSCALL_DEFINE5 ( add_key , const char __user * , _type , const char __user * , _description , const void __user * , _payload , size_t , plen , key_serial_t , ringid ) { key_ref_t keyring_ref , key_ref ; char type [ 32 ] , * description ; void * payload ; long ret ; ret = - EINVAL ; if ( plen > 1024 * 1024 - 1 ) goto error ; ret = key_get_type_from_user ( type , _type , sizeof ( type ) ) ; if ( ret < 0 ) goto error ; description = NULL ; if ( _description ) { description = strndup_user ( _description , KEY_MAX_DESC_SIZE ) ; if ( IS_ERR ( description ) ) { ret = PTR_ERR ( description ) ; goto error ; } if ( ! * description ) { kfree ( description ) ; description = NULL ; } else if ( ( description [ 0 ] == '.' ) && ( strncmp ( type , ""keyring"" , 7 ) == 0 ) ) { ret = - EPERM ; goto error2 ; } } payload = NULL ;  if ( _payload ) {  ret = - ENOMEM ; payload = kvmalloc ( plen , GFP_KERNEL ) ; if ( ! payload ) goto error2 ; ret = - EFAULT ; if ( copy_from_user ( payload , _payload , plen ) != 0 ) goto error3 ; } keyring_ref = lookup_user_key ( ringid , KEY_LOOKUP_CREATE , KEY_NEED_WRITE ) ; if ( IS_ERR ( keyring_ref ) ) { ret = PTR_ERR ( keyring_ref ) ; goto error3 ; } key_ref = key_create_or_update ( keyring_ref , type , description , payload , plen , KEY_PERM_UNDEF , KEY_ALLOC_IN_QUOTA ) ; if ( ! IS_ERR ( key_ref ) ) { ret = key_ref_to_ptr ( key_ref ) -> serial ; key_ref_put ( key_ref ) ; } else { ret = PTR_ERR ( key_ref ) ; } key_ref_put ( keyring_ref ) ; error3 : kvfree ( payload ) ; error2 : kfree ( description ) ; error : return ret ; }",if ( _payload ) {ret = - ENOMEM ;,2530
517,"buggy line: static void save_context ( VP9_COMP * cpi , int mi_row , int mi_col ,  ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {const MACROBLOCK * const x = & cpi -> mb ;const MACROBLOCKD * const xd = & x -> e_mbd ;cwe id:CWE-119context:  static void save_context ( VP9_COMP * cpi , int mi_row , int mi_col ,  ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {  const MACROBLOCK * const x = & cpi -> mb ;  const MACROBLOCKD * const xd = & x -> e_mbd ; int p ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; for ( p = 0 ; p < MAX_MB_PLANE ; ++ p ) {  vpx_memcpy (  a + num_4x4_blocks_wide * p , xd -> above_context [ p ] + ( mi_col * 2 >> xd -> plane [ p ] . subsampling_x ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;  vpx_memcpy (  l + num_4x4_blocks_high * p , xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ; }  vpx_memcpy ( sa , xd -> above_seg_context + mi_col ,  sizeof ( * xd -> above_seg_context ) * mi_width ) ;  vpx_memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) ,  sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ; }","static void save_context ( MACROBLOCK * const x , int mi_row , int mi_col , ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {const MACROBLOCKD * const xd = & x -> e_mbd ;",2531
518,"buggy line: vpx_memcpy (  a + num_4x4_blocks_wide * p , xd -> above_context [ p ] + ( mi_col * 2 >> xd -> plane [ p ] . subsampling_x ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;vpx_memcpy (  l + num_4x4_blocks_high * p , xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;vpx_memcpy ( sa , xd -> above_seg_context + mi_col ,  sizeof ( * xd -> above_seg_context ) * mi_width ) ;vpx_memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) ,  sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;cwe id:CWE-119context:  static void save_context ( VP9_COMP * cpi , int mi_row , int mi_col ,  ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {  const MACROBLOCK * const x = & cpi -> mb ;  const MACROBLOCKD * const xd = & x -> e_mbd ; int p ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; for ( p = 0 ; p < MAX_MB_PLANE ; ++ p ) {  vpx_memcpy (  a + num_4x4_blocks_wide * p , xd -> above_context [ p ] + ( mi_col * 2 >> xd -> plane [ p ] . subsampling_x ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;  vpx_memcpy (  l + num_4x4_blocks_high * p , xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ; }  vpx_memcpy ( sa , xd -> above_seg_context + mi_col ,  sizeof ( * xd -> above_seg_context ) * mi_width ) ;  vpx_memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) ,  sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ; }","memcpy ( a + num_4x4_blocks_wide * p , xd -> above_context [ p ] + ( mi_col * 2 >> xd -> plane [ p ] . subsampling_x ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;memcpy ( l + num_4x4_blocks_high * p , xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;memcpy ( sa , xd -> above_seg_context + mi_col , sizeof ( * xd -> above_seg_context ) * mi_width ) ;memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) , sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;",2531
519,"buggy line: int blockstodecode ;av_assert0 ( s -> samples >= 0 ) ;cwe id:CWE-125context: static int ape_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) { AVFrame * frame = data ; const uint8_t * buf = avpkt -> data ; APEContext * s = avctx -> priv_data ; uint8_t * sample8 ; int16_t * sample16 ; int32_t * sample24 ; int i , ch , ret ;  int blockstodecode ;  av_assert0 ( s -> samples >= 0 ) ; if ( ! s -> samples ) { uint32_t nblocks , offset ; int buf_size ; if ( ! avpkt -> size ) { * got_frame_ptr = 0 ; return 0 ; } if ( avpkt -> size < 8 ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } buf_size = avpkt -> size & ~ 3 ; if ( buf_size != avpkt -> size ) { av_log ( avctx , AV_LOG_WARNING , ""packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4.<S2SV_blank>"" ""extra<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>the<S2SV_blank>end<S2SV_blank>will<S2SV_blank>be<S2SV_blank>skipped.\\n"" ) ; } if ( s -> fileversion < 3950 ) buf_size += 2 ; av_fast_padded_malloc ( & s -> data , & s -> data_size , buf_size ) ; if ( ! s -> data ) return AVERROR ( ENOMEM ) ; s -> bdsp . bswap_buf ( ( uint32_t * ) s -> data , ( const uint32_t * ) buf , buf_size >> 2 ) ; memset ( s -> data + ( buf_size & ~ 3 ) , 0 , buf_size & 3 ) ; s -> ptr = s -> data ; s -> data_end = s -> data + buf_size ; nblocks = bytestream_get_be32 ( & s -> ptr ) ; offset = bytestream_get_be32 ( & s -> ptr ) ; if ( s -> fileversion >= 3900 ) { if ( offset > 3 ) { av_log ( avctx , AV_LOG_ERROR , ""Incorrect<S2SV_blank>offset<S2SV_blank>passed\\n"" ) ; s -> data = NULL ; return AVERROR_INVALIDDATA ; } if ( s -> data_end - s -> ptr < offset ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> ptr += offset ; } else { if ( ( ret = init_get_bits8 ( & s -> gb , s -> ptr , s -> data_end - s -> ptr ) ) < 0 ) return ret ; if ( s -> fileversion > 3800 ) skip_bits_long ( & s -> gb , offset * 8 ) ; else skip_bits_long ( & s -> gb , offset ) ; }  if ( ! nblocks || nblocks > INT_MAX ) {  av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\n"" , nblocks ) ; return AVERROR_INVALIDDATA ; } if ( init_frame_decoder ( s ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>reading<S2SV_blank>frame<S2SV_blank>header\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> samples = nblocks ; } if ( ! s -> data ) { * got_frame_ptr = 0 ; return avpkt -> size ; } blockstodecode = FFMIN ( s -> blocks_per_loop , s -> samples ) ; if ( s -> fileversion < 3930 ) blockstodecode = s -> samples ;  av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size ,   2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ;  if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ; memset ( s -> decoded_buffer , 0 , s -> decoded_size ) ; s -> decoded [ 0 ] = s -> decoded_buffer ; s -> decoded [ 1 ] = s -> decoded_buffer + FFALIGN ( blockstodecode , 8 ) ; frame -> nb_samples = blockstodecode ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; s -> error = 0 ; if ( ( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ) ) ape_unpack_mono ( s , blockstodecode ) ; else ape_unpack_stereo ( s , blockstodecode ) ; emms_c ( ) ; if ( s -> error ) { s -> samples = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>decoding<S2SV_blank>frame\\n"" ) ; return AVERROR_INVALIDDATA ; } switch ( s -> bps ) { case 8 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample8 = ( uint8_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample8 ++ = ( s -> decoded [ ch ] [ i ] + 0x80 ) & 0xff ; } break ; case 16 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample16 = ( int16_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample16 ++ = s -> decoded [ ch ] [ i ] ; } break ; case 24 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample24 = ( int32_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample24 ++ = s -> decoded [ ch ] [ i ] << 8 ; } break ; } s -> samples -= blockstodecode ; * got_frame_ptr = 1 ; return ! s -> samples ? avpkt -> size : 0 ; }",int blockstodecode ;uint64_t decoded_buffer_size ;av_assert0 ( s -> samples >= 0 ) ;,2532
520,"buggy line: if ( ! nblocks || nblocks > INT_MAX ) {av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\\cwe id:CWE-125context: static int ape_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) { AVFrame * frame = data ; const uint8_t * buf = avpkt -> data ; APEContext * s = avctx -> priv_data ; uint8_t * sample8 ; int16_t * sample16 ; int32_t * sample24 ; int i , ch , ret ;  int blockstodecode ;  av_assert0 ( s -> samples >= 0 ) ; if ( ! s -> samples ) { uint32_t nblocks , offset ; int buf_size ; if ( ! avpkt -> size ) { * got_frame_ptr = 0 ; return 0 ; } if ( avpkt -> size < 8 ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } buf_size = avpkt -> size & ~ 3 ; if ( buf_size != avpkt -> size ) { av_log ( avctx , AV_LOG_WARNING , ""packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4.<S2SV_blank>"" ""extra<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>the<S2SV_blank>end<S2SV_blank>will<S2SV_blank>be<S2SV_blank>skipped.\\n"" ) ; } if ( s -> fileversion < 3950 ) buf_size += 2 ; av_fast_padded_malloc ( & s -> data , & s -> data_size , buf_size ) ; if ( ! s -> data ) return AVERROR ( ENOMEM ) ; s -> bdsp . bswap_buf ( ( uint32_t * ) s -> data , ( const uint32_t * ) buf , buf_size >> 2 ) ; memset ( s -> data + ( buf_size & ~ 3 ) , 0 , buf_size & 3 ) ; s -> ptr = s -> data ; s -> data_end = s -> data + buf_size ; nblocks = bytestream_get_be32 ( & s -> ptr ) ; offset = bytestream_get_be32 ( & s -> ptr ) ; if ( s -> fileversion >= 3900 ) { if ( offset > 3 ) { av_log ( avctx , AV_LOG_ERROR , ""Incorrect<S2SV_blank>offset<S2SV_blank>passed\\n"" ) ; s -> data = NULL ; return AVERROR_INVALIDDATA ; } if ( s -> data_end - s -> ptr < offset ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> ptr += offset ; } else { if ( ( ret = init_get_bits8 ( & s -> gb , s -> ptr , s -> data_end - s -> ptr ) ) < 0 ) return ret ; if ( s -> fileversion > 3800 ) skip_bits_long ( & s -> gb , offset * 8 ) ; else skip_bits_long ( & s -> gb , offset ) ; }  if ( ! nblocks || nblocks > INT_MAX ) {  av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\n"" , nblocks ) ; return AVERROR_INVALIDDATA ; } if ( init_frame_decoder ( s ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>reading<S2SV_blank>frame<S2SV_blank>header\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> samples = nblocks ; } if ( ! s -> data ) { * got_frame_ptr = 0 ; return avpkt -> size ; } blockstodecode = FFMIN ( s -> blocks_per_loop , s -> samples ) ; if ( s -> fileversion < 3930 ) blockstodecode = s -> samples ;  av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size ,   2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ;  if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ; memset ( s -> decoded_buffer , 0 , s -> decoded_size ) ; s -> decoded [ 0 ] = s -> decoded_buffer ; s -> decoded [ 1 ] = s -> decoded_buffer + FFALIGN ( blockstodecode , 8 ) ; frame -> nb_samples = blockstodecode ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; s -> error = 0 ; if ( ( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ) ) ape_unpack_mono ( s , blockstodecode ) ; else ape_unpack_stereo ( s , blockstodecode ) ; emms_c ( ) ; if ( s -> error ) { s -> samples = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>decoding<S2SV_blank>frame\\n"" ) ; return AVERROR_INVALIDDATA ; } switch ( s -> bps ) { case 8 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample8 = ( uint8_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample8 ++ = ( s -> decoded [ ch ] [ i ] + 0x80 ) & 0xff ; } break ; case 16 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample16 = ( int16_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample16 ++ = s -> decoded [ ch ] [ i ] ; } break ; case 24 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample24 = ( int32_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample24 ++ = s -> decoded [ ch ] [ i ] << 8 ; } break ; } s -> samples -= blockstodecode ; * got_frame_ptr = 1 ; return ! s -> samples ? avpkt -> size : 0 ; }","if ( ! nblocks || nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 ) {av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\\",2532
521,"buggy line: av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size ,   2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ;if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ;cwe id:CWE-125context: static int ape_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) { AVFrame * frame = data ; const uint8_t * buf = avpkt -> data ; APEContext * s = avctx -> priv_data ; uint8_t * sample8 ; int16_t * sample16 ; int32_t * sample24 ; int i , ch , ret ;  int blockstodecode ;  av_assert0 ( s -> samples >= 0 ) ; if ( ! s -> samples ) { uint32_t nblocks , offset ; int buf_size ; if ( ! avpkt -> size ) { * got_frame_ptr = 0 ; return 0 ; } if ( avpkt -> size < 8 ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } buf_size = avpkt -> size & ~ 3 ; if ( buf_size != avpkt -> size ) { av_log ( avctx , AV_LOG_WARNING , ""packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4.<S2SV_blank>"" ""extra<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>the<S2SV_blank>end<S2SV_blank>will<S2SV_blank>be<S2SV_blank>skipped.\\n"" ) ; } if ( s -> fileversion < 3950 ) buf_size += 2 ; av_fast_padded_malloc ( & s -> data , & s -> data_size , buf_size ) ; if ( ! s -> data ) return AVERROR ( ENOMEM ) ; s -> bdsp . bswap_buf ( ( uint32_t * ) s -> data , ( const uint32_t * ) buf , buf_size >> 2 ) ; memset ( s -> data + ( buf_size & ~ 3 ) , 0 , buf_size & 3 ) ; s -> ptr = s -> data ; s -> data_end = s -> data + buf_size ; nblocks = bytestream_get_be32 ( & s -> ptr ) ; offset = bytestream_get_be32 ( & s -> ptr ) ; if ( s -> fileversion >= 3900 ) { if ( offset > 3 ) { av_log ( avctx , AV_LOG_ERROR , ""Incorrect<S2SV_blank>offset<S2SV_blank>passed\\n"" ) ; s -> data = NULL ; return AVERROR_INVALIDDATA ; } if ( s -> data_end - s -> ptr < offset ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> ptr += offset ; } else { if ( ( ret = init_get_bits8 ( & s -> gb , s -> ptr , s -> data_end - s -> ptr ) ) < 0 ) return ret ; if ( s -> fileversion > 3800 ) skip_bits_long ( & s -> gb , offset * 8 ) ; else skip_bits_long ( & s -> gb , offset ) ; }  if ( ! nblocks || nblocks > INT_MAX ) {  av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\n"" , nblocks ) ; return AVERROR_INVALIDDATA ; } if ( init_frame_decoder ( s ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>reading<S2SV_blank>frame<S2SV_blank>header\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> samples = nblocks ; } if ( ! s -> data ) { * got_frame_ptr = 0 ; return avpkt -> size ; } blockstodecode = FFMIN ( s -> blocks_per_loop , s -> samples ) ; if ( s -> fileversion < 3930 ) blockstodecode = s -> samples ;  av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size ,   2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ;  if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ; memset ( s -> decoded_buffer , 0 , s -> decoded_size ) ; s -> decoded [ 0 ] = s -> decoded_buffer ; s -> decoded [ 1 ] = s -> decoded_buffer + FFALIGN ( blockstodecode , 8 ) ; frame -> nb_samples = blockstodecode ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; s -> error = 0 ; if ( ( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ) ) ape_unpack_mono ( s , blockstodecode ) ; else ape_unpack_stereo ( s , blockstodecode ) ; emms_c ( ) ; if ( s -> error ) { s -> samples = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>decoding<S2SV_blank>frame\\n"" ) ; return AVERROR_INVALIDDATA ; } switch ( s -> bps ) { case 8 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample8 = ( uint8_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample8 ++ = ( s -> decoded [ ch ] [ i ] + 0x80 ) & 0xff ; } break ; case 16 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample16 = ( int16_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample16 ++ = s -> decoded [ ch ] [ i ] ; } break ; case 24 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample24 = ( int32_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample24 ++ = s -> decoded [ ch ] [ i ] << 8 ; } break ; } s -> samples -= blockstodecode ; * got_frame_ptr = 1 ; return ! s -> samples ? avpkt -> size : 0 ; }","decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ;av_assert0 ( decoded_buffer_size <= INT_MAX ) ;av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , decoded_buffer_size ) ;if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ;",2532
522,"buggy line: int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ;unsigned v = get_symbol ( c , state , 0 ) ;cwe id:CWE-119context: static int read_header ( FFV1Context * f ) { uint8_t state [ CONTEXT_SIZE ] ; int i , j , context_count = - 1 ; RangeCoder * const c = & f -> slice_context [ 0 ] -> c ; memset ( state , 128 , sizeof ( state ) ) ; if ( f -> version < 2 ) {  int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ;  unsigned v = get_symbol ( c , state , 0 ) ; if ( v >= 2 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ver01<S2SV_blank>header\\n"" , v ) ; return AVERROR_INVALIDDATA ; } f -> version = v ; f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ) ; if ( f -> ac > 1 ) { for ( i = 1 ; i < 256 ; i ++ ) f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ] ; }  f -> colorspace = get_symbol ( c , state , 0 ) ;   if ( f -> version > 0 )   f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ;   chroma_planes = get_rac ( c , state ) ;   chroma_h_shift = get_symbol ( c , state , 0 ) ;  chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency = get_rac ( c , state ) ; if ( f -> plane_count ) {  if ( chroma_planes != f -> chroma_planes  || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n"" ) ; return AVERROR_INVALIDDATA ; }  }  f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency ; f -> plane_count = 2 + f -> transparency ; } if ( f -> colorspace == 0 ) { if ( ! f -> transparency && ! f -> chroma_planes ) { if ( f -> avctx -> bits_per_raw_sample <= 8 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; else f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16 ; } else if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency ) { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P ; break ; case 0x01 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; break ; case 0x20 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P ; break ; case 0x22 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency ) { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample == 9 ) { f -> packed_at_lsb = 1 ; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample == 10 ) { f -> packed_at_lsb = 1 ; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } } else if ( f -> colorspace == 1 ) { if ( f -> chroma_h_shift || f -> chroma_v_shift ) { av_log ( f -> avctx , AV_LOG_ERROR , ""chroma<S2SV_blank>subsampling<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>colorspace\\n"" ) ; return AVERROR ( ENOSYS ) ; } if ( f -> avctx -> bits_per_raw_sample == 9 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9 ; else if ( f -> avctx -> bits_per_raw_sample == 10 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10 ; else if ( f -> avctx -> bits_per_raw_sample == 12 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12 ; else if ( f -> avctx -> bits_per_raw_sample == 14 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14 ; else if ( f -> transparency ) f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32 ; else f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32 ; } else { av_log ( f -> avctx , AV_LOG_ERROR , ""colorspace<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } av_dlog ( f -> avctx , ""%d<S2SV_blank>%d<S2SV_blank>%d\\n"" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ) ; if ( f -> version < 2 ) { context_count = read_quant_tables ( c , f -> quant_table ) ; if ( context_count < 0 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""read_quant_table<S2SV_blank>error\\n"" ) ; return AVERROR_INVALIDDATA ; } } else if ( f -> version < 3 ) { f -> slice_count = get_symbol ( c , state , 0 ) ; } else { const uint8_t * p = c -> bytestream_end ; for ( f -> slice_count = 0 ; f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start ; f -> slice_count ++ ) { int trailer = 3 + 5 * ! ! f -> ec ; int size = AV_RB24 ( p - trailer ) ; if ( size + trailer > p - c -> bytestream_start ) break ; p -= size + trailer ; } } if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""slice<S2SV_blank>count<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n"" , f -> slice_count ) ; return AVERROR_INVALIDDATA ; } for ( j = 0 ; j < f -> slice_count ; j ++ ) { FFV1Context * fs = f -> slice_context [ j ] ; fs -> ac = f -> ac ; fs -> packed_at_lsb = f -> packed_at_lsb ; fs -> slice_damaged = 0 ; if ( f -> version == 2 ) { fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width ; fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height ; fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x ; fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y ; fs -> slice_x /= f -> num_h_slices ; fs -> slice_y /= f -> num_v_slices ; fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x ; fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y ; if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height ) return AVERROR_INVALIDDATA ; if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height ) return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < f -> plane_count ; i ++ ) { PlaneContext * const p = & fs -> plane [ i ] ; if ( f -> version == 2 ) { int idx = get_symbol ( c , state , 0 ) ; if ( idx > ( unsigned ) f -> quant_table_count ) { av_log ( f -> avctx , AV_LOG_ERROR , ""quant_table_index<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" ) ; return AVERROR_INVALIDDATA ; } p -> quant_table_index = idx ; memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ) ; context_count = f -> context_count [ idx ] ; } else { memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ) ; } if ( f -> version <= 2 ) { av_assert0 ( context_count >= 0 ) ; if ( p -> context_count < context_count ) { av_freep ( & p -> state ) ; av_freep ( & p -> vlc_state ) ; } p -> context_count = context_count ; } } } return 0 ; }","int chroma_planes , chroma_h_shift , chroma_v_shift , transparency , colorspace , bits_per_raw_sample ;unsigned v = get_symbol ( c , state , 0 ) ;",2533
523,"buggy line: f -> colorspace = get_symbol ( c , state , 0 ) ;if ( f -> version > 0 )   f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ;chroma_planes = get_rac ( c , state ) ;chroma_h_shift = get_symbol ( c , state , 0 ) ;chroma_v_shift = get_symbol ( c , state , 0 ) ;if ( chroma_planes != f -> chroma_planes  || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) {}f -> chroma_planes = chroma_planes ;cwe id:CWE-119context: static int read_header ( FFV1Context * f ) { uint8_t state [ CONTEXT_SIZE ] ; int i , j , context_count = - 1 ; RangeCoder * const c = & f -> slice_context [ 0 ] -> c ; memset ( state , 128 , sizeof ( state ) ) ; if ( f -> version < 2 ) {  int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ;  unsigned v = get_symbol ( c , state , 0 ) ; if ( v >= 2 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ver01<S2SV_blank>header\\n"" , v ) ; return AVERROR_INVALIDDATA ; } f -> version = v ; f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ) ; if ( f -> ac > 1 ) { for ( i = 1 ; i < 256 ; i ++ ) f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ] ; }  f -> colorspace = get_symbol ( c , state , 0 ) ;   if ( f -> version > 0 )   f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ;   chroma_planes = get_rac ( c , state ) ;   chroma_h_shift = get_symbol ( c , state , 0 ) ;  chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency = get_rac ( c , state ) ; if ( f -> plane_count ) {  if ( chroma_planes != f -> chroma_planes  || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n"" ) ; return AVERROR_INVALIDDATA ; }  }  f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency ; f -> plane_count = 2 + f -> transparency ; } if ( f -> colorspace == 0 ) { if ( ! f -> transparency && ! f -> chroma_planes ) { if ( f -> avctx -> bits_per_raw_sample <= 8 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; else f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16 ; } else if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency ) { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P ; break ; case 0x01 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; break ; case 0x20 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P ; break ; case 0x22 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency ) { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample == 9 ) { f -> packed_at_lsb = 1 ; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample == 10 ) { f -> packed_at_lsb = 1 ; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } } else if ( f -> colorspace == 1 ) { if ( f -> chroma_h_shift || f -> chroma_v_shift ) { av_log ( f -> avctx , AV_LOG_ERROR , ""chroma<S2SV_blank>subsampling<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>colorspace\\n"" ) ; return AVERROR ( ENOSYS ) ; } if ( f -> avctx -> bits_per_raw_sample == 9 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9 ; else if ( f -> avctx -> bits_per_raw_sample == 10 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10 ; else if ( f -> avctx -> bits_per_raw_sample == 12 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12 ; else if ( f -> avctx -> bits_per_raw_sample == 14 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14 ; else if ( f -> transparency ) f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32 ; else f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32 ; } else { av_log ( f -> avctx , AV_LOG_ERROR , ""colorspace<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } av_dlog ( f -> avctx , ""%d<S2SV_blank>%d<S2SV_blank>%d\\n"" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ) ; if ( f -> version < 2 ) { context_count = read_quant_tables ( c , f -> quant_table ) ; if ( context_count < 0 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""read_quant_table<S2SV_blank>error\\n"" ) ; return AVERROR_INVALIDDATA ; } } else if ( f -> version < 3 ) { f -> slice_count = get_symbol ( c , state , 0 ) ; } else { const uint8_t * p = c -> bytestream_end ; for ( f -> slice_count = 0 ; f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start ; f -> slice_count ++ ) { int trailer = 3 + 5 * ! ! f -> ec ; int size = AV_RB24 ( p - trailer ) ; if ( size + trailer > p - c -> bytestream_start ) break ; p -= size + trailer ; } } if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""slice<S2SV_blank>count<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n"" , f -> slice_count ) ; return AVERROR_INVALIDDATA ; } for ( j = 0 ; j < f -> slice_count ; j ++ ) { FFV1Context * fs = f -> slice_context [ j ] ; fs -> ac = f -> ac ; fs -> packed_at_lsb = f -> packed_at_lsb ; fs -> slice_damaged = 0 ; if ( f -> version == 2 ) { fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width ; fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height ; fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x ; fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y ; fs -> slice_x /= f -> num_h_slices ; fs -> slice_y /= f -> num_v_slices ; fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x ; fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y ; if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height ) return AVERROR_INVALIDDATA ; if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height ) return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < f -> plane_count ; i ++ ) { PlaneContext * const p = & fs -> plane [ i ] ; if ( f -> version == 2 ) { int idx = get_symbol ( c , state , 0 ) ; if ( idx > ( unsigned ) f -> quant_table_count ) { av_log ( f -> avctx , AV_LOG_ERROR , ""quant_table_index<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" ) ; return AVERROR_INVALIDDATA ; } p -> quant_table_index = idx ; memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ) ; context_count = f -> context_count [ idx ] ; } else { memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ) ; } if ( f -> version <= 2 ) { av_assert0 ( context_count >= 0 ) ; if ( p -> context_count < context_count ) { av_freep ( & p -> state ) ; av_freep ( & p -> vlc_state ) ; } p -> context_count = context_count ; } } } return 0 ; }","colorspace = get_symbol ( c , state , 0 ) ;bits_per_raw_sample = f -> version > 0 ) f -> avctx -> bits_per_raw_sample ;chroma_planes = get_rac ( c , state ) ;chroma_h_shift = get_symbol ( c , state , 0 ) ;chroma_v_shift = get_symbol ( c , state , 0 ) ;if ( colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) {}f -> colorspace = colorspace ;f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ;f -> chroma_planes = chroma_planes ;",2533
524,"buggy line: frame_end :  ff_er_frame_end ( & s -> er ) ;cwe id:CWE-617context: int ff_h263_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; MpegEncContext * s = avctx -> priv_data ; int ret ; int slice_ret = 0 ; AVFrame * pict = data ; if ( buf_size == 0 ) { if ( s -> low_delay == 0 && s -> next_picture_ptr ) { if ( ( ret = av_frame_ref ( pict , s -> next_picture_ptr -> f ) ) < 0 ) return ret ; s -> next_picture_ptr = NULL ; * got_frame = 1 ; } return 0 ; } if ( s -> avctx -> flags & AV_CODEC_FLAG_TRUNCATED ) { int next ; if ( CONFIG_MPEG4_DECODER && s -> codec_id == AV_CODEC_ID_MPEG4 ) { next = ff_mpeg4_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else if ( CONFIG_H263_DECODER && s -> codec_id == AV_CODEC_ID_H263 ) { next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else if ( CONFIG_H263P_DECODER && s -> codec_id == AV_CODEC_ID_H263P ) { next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else { av_log ( s -> avctx , AV_LOG_ERROR , ""this<S2SV_blank>codec<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>truncated<S2SV_blank>bitstreams\\n"" ) ; return AVERROR ( ENOSYS ) ; } if ( ff_combine_frame ( & s -> parse_context , next , ( const uint8_t * * ) & buf , & buf_size ) < 0 ) return buf_size ; } retry : if ( s -> divx_packed && s -> bitstream_buffer_size ) { int i ; for ( i = 0 ; i < buf_size - 3 ; i ++ ) { if ( buf [ i ] == 0 && buf [ i + 1 ] == 0 && buf [ i + 2 ] == 1 ) { if ( buf [ i + 3 ] == 0xB0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>excessive<S2SV_blank>bitstream<S2SV_blank>in<S2SV_blank>packed<S2SV_blank>xvid\\n"" ) ; s -> bitstream_buffer_size = 0 ; } break ; } } } if ( s -> bitstream_buffer_size && ( s -> divx_packed || buf_size <= MAX_NVOP_SIZE ) ) ret = init_get_bits8 ( & s -> gb , s -> bitstream_buffer , s -> bitstream_buffer_size ) ; else ret = init_get_bits8 ( & s -> gb , buf , buf_size ) ; s -> bitstream_buffer_size = 0 ; if ( ret < 0 ) return ret ; if ( ! s -> context_initialized ) ff_mpv_idct_init ( s ) ; if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { ret = ff_wmv2_decode_picture_header ( s ) ; } else if ( CONFIG_MSMPEG4_DECODER && s -> msmpeg4_version ) { ret = ff_msmpeg4_decode_picture_header ( s ) ; } else if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( s -> avctx -> extradata_size && s -> picture_number == 0 ) { GetBitContext gb ; if ( init_get_bits8 ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size ) >= 0 ) ff_mpeg4_decode_picture_header ( avctx -> priv_data , & gb ) ; } ret = ff_mpeg4_decode_picture_header ( avctx -> priv_data , & s -> gb ) ; } else if ( CONFIG_H263I_DECODER && s -> codec_id == AV_CODEC_ID_H263I ) { ret = ff_intel_h263_decode_picture_header ( s ) ; } else if ( CONFIG_FLV_DECODER && s -> h263_flv ) { ret = ff_flv_decode_picture_header ( s ) ; } else { ret = ff_h263_decode_picture_header ( s ) ; } if ( ret < 0 || ret == FRAME_SKIPPED ) { if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height ) { av_log ( s -> avctx , AV_LOG_WARNING , ""Reverting<S2SV_blank>picture<S2SV_blank>dimensions<S2SV_blank>change<S2SV_blank>due<S2SV_blank>to<S2SV_blank>header<S2SV_blank>decoding<S2SV_blank>failure\\n"" ) ; s -> width = avctx -> coded_width ; s -> height = avctx -> coded_height ; } } if ( ret == FRAME_SKIPPED ) return get_consumed_bytes ( s , buf_size ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""header<S2SV_blank>damaged\\n"" ) ; return ret ; } if ( ! s -> context_initialized ) { avctx -> pix_fmt = h263_get_format ( avctx ) ; if ( ( ret = ff_mpv_common_init ( s ) ) < 0 ) return ret ; } if ( ! s -> current_picture_ptr || s -> current_picture_ptr -> f -> data [ 0 ] ) { int i = ff_find_unused_picture ( s -> avctx , s -> picture , 0 ) ; if ( i < 0 ) return i ; s -> current_picture_ptr = & s -> picture [ i ] ; } avctx -> has_b_frames = ! s -> low_delay ; if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( ff_mpeg4_workaround_bugs ( avctx ) == 1 ) goto retry ; if ( s -> studio_profile != ( s -> idsp . idct == NULL ) ) ff_mpv_idct_init ( s ) ; } if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height || s -> context_reinit ) { s -> context_reinit = 0 ; ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ; if ( ret < 0 ) return ret ; ff_set_sar ( avctx , avctx -> sample_aspect_ratio ) ; if ( ( ret = ff_mpv_common_frame_size_change ( s ) ) ) return ret ; if ( avctx -> pix_fmt != h263_get_format ( avctx ) ) { av_log ( avctx , AV_LOG_ERROR , ""format<S2SV_blank>change<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; avctx -> pix_fmt = AV_PIX_FMT_NONE ; return AVERROR_UNKNOWN ; } } if ( s -> codec_id == AV_CODEC_ID_H263 || s -> codec_id == AV_CODEC_ID_H263P || s -> codec_id == AV_CODEC_ID_H263I ) s -> gob_index = H263_GOB_HEIGHT ( s -> height ) ; s -> current_picture . f -> pict_type = s -> pict_type ; s -> current_picture . f -> key_frame = s -> pict_type == AV_PICTURE_TYPE_I ; if ( ! s -> last_picture_ptr && ( s -> pict_type == AV_PICTURE_TYPE_B || s -> droppable ) ) return get_consumed_bytes ( s , buf_size ) ; if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && s -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL ) return get_consumed_bytes ( s , buf_size ) ; if ( s -> next_p_frame_damaged ) { if ( s -> pict_type == AV_PICTURE_TYPE_B ) return get_consumed_bytes ( s , buf_size ) ; else s -> next_p_frame_damaged = 0 ; } if ( ( ! s -> no_rounding ) || s -> pict_type == AV_PICTURE_TYPE_B ) { s -> me . qpel_put = s -> qdsp . put_qpel_pixels_tab ; s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; } else { s -> me . qpel_put = s -> qdsp . put_no_rnd_qpel_pixels_tab ; s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; } if ( ( ret = ff_mpv_frame_start ( s , avctx ) ) < 0 ) return ret ; if ( ! s -> divx_packed ) ff_thread_finish_setup ( avctx ) ; if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> start_frame ( avctx , s -> gb . buffer , s -> gb . buffer_end - s -> gb . buffer ) ; if ( ret < 0 ) return ret ; } ff_mpeg_er_frame_start ( s ) ; if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { ret = ff_wmv2_decode_secondary_picture_header ( s ) ; if ( ret < 0 ) return ret ; if ( ret == 1 ) goto frame_end ; } s -> mb_x = 0 ; s -> mb_y = 0 ; slice_ret = decode_slice ( s ) ; while ( s -> mb_y < s -> mb_height ) { if ( s -> msmpeg4_version ) { if ( s -> slice_height == 0 || s -> mb_x != 0 || slice_ret < 0 || ( s -> mb_y % s -> slice_height ) != 0 || get_bits_left ( & s -> gb ) < 0 ) break ; } else { int prev_x = s -> mb_x , prev_y = s -> mb_y ; if ( ff_h263_resync ( s ) < 0 ) break ; if ( prev_y * s -> mb_width + prev_x < s -> mb_y * s -> mb_width + s -> mb_x ) s -> er . error_occurred = 1 ; } if ( s -> msmpeg4_version < 4 && s -> h263_pred ) ff_mpeg4_clean_buffers ( s ) ; if ( decode_slice ( s ) < 0 ) slice_ret = AVERROR_INVALIDDATA ; } if ( s -> msmpeg4_version && s -> msmpeg4_version < 4 && s -> pict_type == AV_PICTURE_TYPE_I ) if ( ! CONFIG_MSMPEG4_DECODER || ff_msmpeg4_decode_ext_header ( s , buf_size ) < 0 ) s -> er . error_status_table [ s -> mb_num - 1 ] = ER_MB_ERROR ; av_assert1 ( s -> bitstream_buffer_size == 0 ) ;  frame_end :  ff_er_frame_end ( & s -> er ) ; if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> end_frame ( avctx ) ; if ( ret < 0 ) return ret ; } ff_mpv_frame_end ( s ) ; if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) ff_mpeg4_frame_end ( avctx , buf , buf_size ) ; if ( ! s -> divx_packed && avctx -> hwaccel ) ff_thread_finish_setup ( avctx ) ; av_assert1 ( s -> current_picture . f -> pict_type == s -> current_picture_ptr -> f -> pict_type ) ; av_assert1 ( s -> current_picture . f -> pict_type == s -> pict_type ) ; if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { if ( ( ret = av_frame_ref ( pict , s -> current_picture_ptr -> f ) ) < 0 ) return ret ; ff_print_debug_info ( s , s -> current_picture_ptr , pict ) ; ff_mpv_export_qp_table ( s , pict , s -> current_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; } else if ( s -> last_picture_ptr ) { if ( ( ret = av_frame_ref ( pict , s -> last_picture_ptr -> f ) ) < 0 ) return ret ; ff_print_debug_info ( s , s -> last_picture_ptr , pict ) ; ff_mpv_export_qp_table ( s , pict , s -> last_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; } if ( s -> last_picture_ptr || s -> low_delay ) { if ( pict -> format == AV_PIX_FMT_YUV420P && ( s -> codec_tag == AV_RL32 ( ""GEOV"" ) || s -> codec_tag == AV_RL32 ( ""GEOX"" ) ) ) { int x , y , p ; av_frame_make_writable ( pict ) ; for ( p = 0 ; p < 3 ; p ++ ) { int w = AV_CEIL_RSHIFT ( pict -> width , ! ! p ) ; int h = AV_CEIL_RSHIFT ( pict -> height , ! ! p ) ; int linesize = pict -> linesize [ p ] ; for ( y = 0 ; y < ( h >> 1 ) ; y ++ ) for ( x = 0 ; x < w ; x ++ ) FFSWAP ( int , pict -> data [ p ] [ x + y * linesize ] , pict -> data [ p ] [ x + ( h - 1 - y ) * linesize ] ) ; } } * got_frame = 1 ; } if ( slice_ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) return slice_ret ; else return get_consumed_bytes ( s , buf_size ) ; }",frame_end : if ( ! s -> studio_profile ) ff_er_frame_end ( & s -> er ) ;,2534
525,"buggy line: sas_port_delete ( port -> port ) ;port -> port = NULL ;cwe id:CWE-000context: void sas_deform_port ( struct asd_sas_phy * phy , int gone ) { struct sas_ha_struct * sas_ha = phy -> ha ; struct asd_sas_port * port = phy -> port ; struct sas_internal * si = to_sas_internal ( sas_ha -> core . shost -> transportt ) ; struct domain_device * dev ; unsigned long flags ; if ( ! port ) return ; dev = port -> port_dev ; if ( dev ) dev -> pathways -- ; if ( port -> num_phys == 1 ) { sas_unregister_domain_devices ( port , gone ) ;  sas_port_delete ( port -> port ) ;  port -> port = NULL ; } else { sas_port_delete_phy ( port -> port , phy -> phy ) ; sas_device_set_phy ( dev , port -> port ) ; } if ( si -> dft -> lldd_port_deformed ) si -> dft -> lldd_port_deformed ( phy ) ; spin_lock_irqsave ( & sas_ha -> phy_port_lock , flags ) ; spin_lock ( & port -> phy_list_lock ) ; list_del_init ( & phy -> port_phy_el ) ; sas_phy_set_target ( phy , NULL ) ; phy -> port = NULL ; port -> num_phys -- ; port -> phy_mask &= ~ ( 1U << phy -> id ) ; if ( port -> num_phys == 0 ) { INIT_LIST_HEAD ( & port -> phy_list ) ; memset ( port -> sas_addr , 0 , SAS_ADDR_SIZE ) ; memset ( port -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; port -> class = 0 ; port -> iproto = 0 ; port -> tproto = 0 ; port -> oob_mode = 0 ; port -> phy_mask = 0 ; } spin_unlock ( & port -> phy_list_lock ) ; spin_unlock_irqrestore ( & sas_ha -> phy_port_lock , flags ) ; return ; }",sas_destruct_devices ( port ) ;sas_port_delete ( port -> port ) ;port -> port = NULL ;,2535
526,"buggy line: case OBJECT_TYPE_INTEGER :  ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ;break ;case OBJECT_TYPE_STRING :  ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;break ;cwe id:CWE-416context: int yr_object_copy ( YR_OBJECT * object , YR_OBJECT * * object_copy ) { YR_OBJECT * copy ; YR_OBJECT * o ; YR_STRUCTURE_MEMBER * structure_member ; YR_OBJECT_FUNCTION * func ; YR_OBJECT_FUNCTION * func_copy ; int i ; * object_copy = NULL ; FAIL_ON_ERROR ( yr_object_create ( object -> type , object -> identifier , NULL , & copy ) ) ; switch ( object -> type ) { case OBJECT_TYPE_INTEGER :  ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ;  break ; case OBJECT_TYPE_STRING :  ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;  break ; case OBJECT_TYPE_FUNCTION : func = ( YR_OBJECT_FUNCTION * ) object ; func_copy = ( YR_OBJECT_FUNCTION * ) copy ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_copy ( func -> return_obj , & func_copy -> return_obj ) , yr_object_destroy ( copy ) ) ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) func_copy -> prototypes [ i ] = func -> prototypes [ i ] ; break ; case OBJECT_TYPE_STRUCTURE : structure_member = ( ( YR_OBJECT_STRUCTURE * ) object ) -> members ; while ( structure_member != NULL ) { FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_copy ( structure_member -> object , & o ) , yr_object_destroy ( copy ) ) ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_structure_set_member ( copy , o ) , yr_free ( o ) ; yr_object_destroy ( copy ) ) ; structure_member = structure_member -> next ; } break ; case OBJECT_TYPE_ARRAY : yr_object_copy ( ( ( YR_OBJECT_ARRAY * ) object ) -> prototype_item , & o ) ; ( ( YR_OBJECT_ARRAY * ) copy ) -> prototype_item = o ; break ; case OBJECT_TYPE_DICTIONARY : yr_object_copy ( ( ( YR_OBJECT_DICTIONARY * ) object ) -> prototype_item , & o ) ; ( ( YR_OBJECT_DICTIONARY * ) copy ) -> prototype_item = o ; break ; default : assert ( FALSE ) ; } * object_copy = copy ; return ERROR_SUCCESS ; }",case OBJECT_TYPE_INTEGER : ( ( YR_OBJECT_INTEGER * ) copy ) -> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value ;break ;case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) object ) -> value != NULL ) {( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ;}else {( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;}break ;case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value ;break ;,2536
527,"buggy line: if ( ! vct_iscrlf ( * r ) ) {r ++ ;cwe id:CWE-000context: static uint16_t http_dissect_hdrs ( struct worker * w , struct http * hp , int fd , char * p , const struct http_conn * htc ) { char * q , * r ; txt t = htc -> rxbuf ; if ( * p == '\\r' ) p ++ ; hp -> nhd = HTTP_HDR_FIRST ; hp -> conds = 0 ; r = NULL ; for ( ; p < t . e ; p = r ) { q = r = p ; while ( r < t . e ) {  if ( ! vct_iscrlf ( * r ) ) {  r ++ ; continue ; } q = r ; assert ( r < t . e ) ; r += vct_skipcrlf ( r ) ; if ( r >= t . e ) break ; if ( ! vct_issp ( * r ) ) break ; while ( vct_islws ( * q ) ) * q ++ = '<S2SV_blank>' ; } if ( q - p > htc -> maxhdr ) { VSC_C_main -> losthdr ++ ; WSL ( w , SLT_LostHeader , fd , ""%.*s"" , q - p > 20 ? 20 : q - p , p ) ; return ( 413 ) ; } if ( p == q ) break ; if ( ( p [ 0 ] == 'i' || p [ 0 ] == 'I' ) && ( p [ 1 ] == 'f' || p [ 1 ] == 'F' ) && p [ 2 ] == '-' ) hp -> conds = 1 ; while ( q > p && vct_issp ( q [ - 1 ] ) ) q -- ; * q = '\\0' ; if ( hp -> nhd < hp -> shd ) { hp -> hdf [ hp -> nhd ] = 0 ; hp -> hd [ hp -> nhd ] . b = p ; hp -> hd [ hp -> nhd ] . e = q ; WSLH ( w , fd , hp , hp -> nhd ) ; hp -> nhd ++ ; } else { VSC_C_main -> losthdr ++ ; WSL ( w , SLT_LostHeader , fd , ""%.*s"" , q - p > 20 ? 20 : q - p , p ) ; return ( 413 ) ; } } return ( 0 ) ; }",if ( ! vct_iscrlf ( r ) ) {r ++ ;,2537
528,buggy line: unsigned int random_variable = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {random_variable = get_random_int ( ) & STACK_RND_MASK ;random_variable <<= PAGE_SHIFT ;cwe id:CWE-264context: static unsigned long randomize_stack_top ( unsigned long stack_top ) {  unsigned int random_variable = 0 ;  if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {  random_variable = get_random_int ( ) & STACK_RND_MASK ;  random_variable <<= PAGE_SHIFT ; } # ifdef CONFIG_STACK_GROWSUP return PAGE_ALIGN ( stack_top ) + random_variable ; # else return PAGE_ALIGN ( stack_top ) - random_variable ; # endif },unsigned long random_variable = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {random_variable = ( unsigned long ) get_random_int ( ) ;random_variable &= STACK_RND_MASK ;random_variable <<= PAGE_SHIFT ;,2538
529,"buggy line: unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;buf [ 1 ] |= 1 << offset ;buf [ 2 ] = gpio_push_pull ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ;if ( ret < 0 ) {hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\\goto fail ;}spin_unlock_irqrestore ( & dev -> lock , flags ) ;cp2112_gpio_set ( chip , offset , value ) ;fail :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret < 0 ? ret : - EIO ;cwe id:CWE-404context: static int cp2112_gpio_direction_output ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ;  unsigned long flags ;  int ret ;  spin_lock_irqsave ( & dev -> lock , flags ) ;  ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_CONFIG_LENGTH ) { hid_err ( hdev , ""error<S2SV_blank>requesting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n"" , ret ) ; goto fail ; } buf [ 1 ] |= 1 << offset ; buf [ 2 ] = gpio_push_pull ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) { hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n"" , ret ) ; goto fail ; }  spin_unlock_irqrestore ( & dev -> lock , flags ) ;  cp2112_gpio_set ( chip , offset , value ) ; return 0 ; fail :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;  return ret < 0 ? ret : - EIO ; }","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;mutex_unlock ( & dev -> lock , flags ) ;cp2112_gpio_set ( chip , offset , value ) ;fail : spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret < 0 ? ret : - EIO ;",2539
530,"buggy line: spin_lock ( & inode -> i_lock ) ;inode -> i_blocks -= ( blocks_per_huge_page ( h ) * freed ) ;spin_unlock ( & inode -> i_lock ) ;hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ;hugetlb_acct_memory ( h , - ( chg - freed ) ) ;cwe id:CWE-399context: void hugetlb_unreserve_pages ( struct inode * inode , long offset , long freed ) { struct hstate * h = hstate_inode ( inode ) ; long chg = region_truncate ( & inode -> i_mapping -> private_list , offset ) ;  spin_lock ( & inode -> i_lock ) ;  inode -> i_blocks -= ( blocks_per_huge_page ( h ) * freed ) ; spin_unlock ( & inode -> i_lock ) ;  hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ;  hugetlb_acct_memory ( h , - ( chg - freed ) ) ; }","struct hugepage_subpool * spool = subpool_inode ( inode ) ;spin_lock ( & inode -> i_lock ) ;hugepage_subpool_put_pages ( spool , ( chg - freed ) ) ;hugetlb_acct_memory ( h , - ( chg - freed ) ) ;",2540
531,"buggy line: if ( keyring_key -> type != & key_type_logon ) {printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\\down_read ( & keyring_key -> sem ) ;ukp = user_key_payload ( keyring_key ) ;if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) {up_read ( & keyring_key -> sem ) ;cwe id:CWE-416context: static int validate_user_key ( struct fscrypt_info * crypt_info , struct fscrypt_context * ctx , u8 * raw_key , const char * prefix ) { char * description ; struct key * keyring_key ; struct fscrypt_key * master_key ; const struct user_key_payload * ukp ; int res ; description = kasprintf ( GFP_NOFS , ""%s%*phN"" , prefix , FS_KEY_DESCRIPTOR_SIZE , ctx -> master_key_descriptor ) ; if ( ! description ) return - ENOMEM ; keyring_key = request_key ( & key_type_logon , description , NULL ) ; kfree ( description ) ; if ( IS_ERR ( keyring_key ) ) return PTR_ERR ( keyring_key ) ;  if ( keyring_key -> type != & key_type_logon ) {  printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\n"" , __func__ ) ; res = - ENOKEY ; goto out ; }  down_read ( & keyring_key -> sem ) ;   ukp = user_key_payload ( keyring_key ) ;  if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { res = - EINVAL ; up_read ( & keyring_key -> sem ) ; goto out ; } master_key = ( struct fscrypt_key * ) ukp -> data ; BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n"" , __func__ , master_key -> size ) ; res = - ENOKEY ; up_read ( & keyring_key -> sem ) ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; up_read ( & keyring_key -> sem ) ; if ( res ) goto out ; crypt_info -> ci_keyring_key = keyring_key ; return 0 ; out : key_put ( keyring_key ) ; return res ; }","down_read ( & keyring_key -> sem ) ;if ( keyring_key -> type != & key_type_logon ) {printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\\ukp = user_key_payload ( keyring_key ) ;if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) {",2541
532,"buggy line: up_read ( & keyring_key -> sem ) ;up_read ( & keyring_key -> sem ) ;if ( res ) goto out ;crypt_info -> ci_keyring_key = keyring_key ;return 0 ;out : key_put ( keyring_key ) ;cwe id:CWE-416context: static int validate_user_key ( struct fscrypt_info * crypt_info , struct fscrypt_context * ctx , u8 * raw_key , const char * prefix ) { char * description ; struct key * keyring_key ; struct fscrypt_key * master_key ; const struct user_key_payload * ukp ; int res ; description = kasprintf ( GFP_NOFS , ""%s%*phN"" , prefix , FS_KEY_DESCRIPTOR_SIZE , ctx -> master_key_descriptor ) ; if ( ! description ) return - ENOMEM ; keyring_key = request_key ( & key_type_logon , description , NULL ) ; kfree ( description ) ; if ( IS_ERR ( keyring_key ) ) return PTR_ERR ( keyring_key ) ;  if ( keyring_key -> type != & key_type_logon ) {  printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\n"" , __func__ ) ; res = - ENOKEY ; goto out ; }  down_read ( & keyring_key -> sem ) ;   ukp = user_key_payload ( keyring_key ) ;  if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { res = - EINVAL ; up_read ( & keyring_key -> sem ) ; goto out ; } master_key = ( struct fscrypt_key * ) ukp -> data ; BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n"" , __func__ , master_key -> size ) ; res = - ENOKEY ; up_read ( & keyring_key -> sem ) ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; up_read ( & keyring_key -> sem ) ; if ( res ) goto out ; crypt_info -> ci_keyring_key = keyring_key ; return 0 ; out : key_put ( keyring_key ) ; return res ; }",out : up_read ( & keyring_key -> sem ) ;key_put ( keyring_key ) ;,2541
533,"buggy line: memcpy ( res , dbg_data , nb10sz ) ;res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ;cwe id:CWE-125context: static void get_nb10 ( ut8 * dbg_data , SCV_NB10_HEADER * res ) { const int nb10sz = 16 ;  memcpy ( res , dbg_data , nb10sz ) ;  res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ; }","
",2542
534,"buggy line: int need_error_free = 0 ;int local_rcache = 0 , local_authcon = 0 ;if ( strcmp ( inbuf . data , sendauth_version ) ) {problem = KRB5_SENDAUTH_BADAUTHVERS ;cwe id:CWE-000context: static krb5_error_code recvauth_common ( krb5_context context , krb5_auth_context * auth_context , krb5_pointer fd , char * appl_version , krb5_principal server , krb5_int32 flags , krb5_keytab keytab , krb5_ticket * * ticket , krb5_data * version ) { krb5_auth_context new_auth_context ; krb5_flags ap_option = 0 ; krb5_error_code retval , problem ; krb5_data inbuf ; krb5_data outbuf ; krb5_rcache rcache = 0 ; krb5_octet response ; krb5_data null_server ;  int need_error_free = 0 ;  int local_rcache = 0 , local_authcon = 0 ; problem = 0 ; response = 0 ; if ( ! ( flags & KRB5_RECVAUTH_SKIP_VERSION ) ) { if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return ( retval ) ;  if ( strcmp ( inbuf . data , sendauth_version ) ) {  problem = KRB5_SENDAUTH_BADAUTHVERS ; response = 1 ; } free ( inbuf . data ) ; } if ( flags & KRB5_RECVAUTH_BADAUTHVERS ) { problem = KRB5_SENDAUTH_BADAUTHVERS ; response = 1 ; } if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return ( retval ) ;  if ( appl_version && strcmp ( inbuf . data , appl_version ) ) {  if ( ! problem ) { problem = KRB5_SENDAUTH_BADAPPLVERS ; response = 2 ; } } if ( version && ! problem ) * version = inbuf ; else free ( inbuf . data ) ; if ( ( krb5_net_write ( context , * ( ( int * ) fd ) , ( char * ) & response , 1 ) ) < 0 ) { return ( problem ) ; } if ( problem ) return ( problem ) ; if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return retval ; if ( * auth_context == NULL ) { problem = krb5_auth_con_init ( context , & new_auth_context ) ; * auth_context = new_auth_context ; local_authcon = 1 ; } krb5_auth_con_getrcache ( context , * auth_context , & rcache ) ; if ( ( ! problem ) && rcache == NULL ) { if ( server != NULL && server -> length > 0 ) { problem = krb5_get_server_rcache ( context , & server -> data [ 0 ] , & rcache ) ; } else { null_server . length = 7 ; null_server . data = ""default"" ; problem = krb5_get_server_rcache ( context , & null_server , & rcache ) ; } if ( ! problem ) problem = krb5_auth_con_setrcache ( context , * auth_context , rcache ) ; local_rcache = 1 ; } if ( ! problem ) { problem = krb5_rd_req ( context , auth_context , & inbuf , server , keytab , & ap_option , ticket ) ; free ( inbuf . data ) ; } if ( problem ) { krb5_error error ; const char * message ; memset ( & error , 0 , sizeof ( error ) ) ; krb5_us_timeofday ( context , & error . stime , & error . susec ) ; if ( server ) error . server = server ; else { ( void ) krb5_parse_name ( context , ""????"" , & error . server ) ; need_error_free = 1 ; } error . error = problem - ERROR_TABLE_BASE_krb5 ; if ( error . error > 127 ) error . error = KRB_ERR_GENERIC ; message = error_message ( problem ) ; error . text . length = strlen ( message ) + 1 ; error . text . data = strdup ( message ) ; if ( ! error . text . data ) { retval = ENOMEM ; goto cleanup ; } if ( ( retval = krb5_mk_error ( context , & error , & outbuf ) ) ) { free ( error . text . data ) ; goto cleanup ; } free ( error . text . data ) ; if ( need_error_free ) krb5_free_principal ( context , error . server ) ; } else { outbuf . length = 0 ; outbuf . data = 0 ; } retval = krb5_write_message ( context , fd , & outbuf ) ; if ( outbuf . data ) { free ( outbuf . data ) ; retval = problem ; goto cleanup ; } if ( retval ) goto cleanup ; if ( ( ap_option & AP_OPTS_MUTUAL_REQUIRED ) ) { if ( ( retval = krb5_mk_rep ( context , * auth_context , & outbuf ) ) ) { return ( retval ) ; } retval = krb5_write_message ( context , fd , & outbuf ) ; free ( outbuf . data ) ; } cleanup : ; if ( retval ) { if ( local_authcon ) { krb5_auth_con_free ( context , * auth_context ) ; } else if ( local_rcache && rcache != NULL ) { krb5_rc_close ( context , rcache ) ; krb5_auth_con_setrcache ( context , * auth_context , NULL ) ; } } return retval ; }","krb5_data d ;int need_error_free = 0 ;int local_rcache = 0 , local_authcon = 0 ;d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ;if ( ! data_eq ( inbuf , d ) ) {problem = KRB5_SENDAUTH_BADAUTHVERS ;",2543
535,"buggy line: if ( appl_version && strcmp ( inbuf . data , appl_version ) ) {if ( ! problem ) {cwe id:CWE-000context: static krb5_error_code recvauth_common ( krb5_context context , krb5_auth_context * auth_context , krb5_pointer fd , char * appl_version , krb5_principal server , krb5_int32 flags , krb5_keytab keytab , krb5_ticket * * ticket , krb5_data * version ) { krb5_auth_context new_auth_context ; krb5_flags ap_option = 0 ; krb5_error_code retval , problem ; krb5_data inbuf ; krb5_data outbuf ; krb5_rcache rcache = 0 ; krb5_octet response ; krb5_data null_server ;  int need_error_free = 0 ;  int local_rcache = 0 , local_authcon = 0 ; problem = 0 ; response = 0 ; if ( ! ( flags & KRB5_RECVAUTH_SKIP_VERSION ) ) { if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return ( retval ) ;  if ( strcmp ( inbuf . data , sendauth_version ) ) {  problem = KRB5_SENDAUTH_BADAUTHVERS ; response = 1 ; } free ( inbuf . data ) ; } if ( flags & KRB5_RECVAUTH_BADAUTHVERS ) { problem = KRB5_SENDAUTH_BADAUTHVERS ; response = 1 ; } if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return ( retval ) ;  if ( appl_version && strcmp ( inbuf . data , appl_version ) ) {  if ( ! problem ) { problem = KRB5_SENDAUTH_BADAPPLVERS ; response = 2 ; } } if ( version && ! problem ) * version = inbuf ; else free ( inbuf . data ) ; if ( ( krb5_net_write ( context , * ( ( int * ) fd ) , ( char * ) & response , 1 ) ) < 0 ) { return ( problem ) ; } if ( problem ) return ( problem ) ; if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return retval ; if ( * auth_context == NULL ) { problem = krb5_auth_con_init ( context , & new_auth_context ) ; * auth_context = new_auth_context ; local_authcon = 1 ; } krb5_auth_con_getrcache ( context , * auth_context , & rcache ) ; if ( ( ! problem ) && rcache == NULL ) { if ( server != NULL && server -> length > 0 ) { problem = krb5_get_server_rcache ( context , & server -> data [ 0 ] , & rcache ) ; } else { null_server . length = 7 ; null_server . data = ""default"" ; problem = krb5_get_server_rcache ( context , & null_server , & rcache ) ; } if ( ! problem ) problem = krb5_auth_con_setrcache ( context , * auth_context , rcache ) ; local_rcache = 1 ; } if ( ! problem ) { problem = krb5_rd_req ( context , auth_context , & inbuf , server , keytab , & ap_option , ticket ) ; free ( inbuf . data ) ; } if ( problem ) { krb5_error error ; const char * message ; memset ( & error , 0 , sizeof ( error ) ) ; krb5_us_timeofday ( context , & error . stime , & error . susec ) ; if ( server ) error . server = server ; else { ( void ) krb5_parse_name ( context , ""????"" , & error . server ) ; need_error_free = 1 ; } error . error = problem - ERROR_TABLE_BASE_krb5 ; if ( error . error > 127 ) error . error = KRB_ERR_GENERIC ; message = error_message ( problem ) ; error . text . length = strlen ( message ) + 1 ; error . text . data = strdup ( message ) ; if ( ! error . text . data ) { retval = ENOMEM ; goto cleanup ; } if ( ( retval = krb5_mk_error ( context , & error , & outbuf ) ) ) { free ( error . text . data ) ; goto cleanup ; } free ( error . text . data ) ; if ( need_error_free ) krb5_free_principal ( context , error . server ) ; } else { outbuf . length = 0 ; outbuf . data = 0 ; } retval = krb5_write_message ( context , fd , & outbuf ) ; if ( outbuf . data ) { free ( outbuf . data ) ; retval = problem ; goto cleanup ; } if ( retval ) goto cleanup ; if ( ( ap_option & AP_OPTS_MUTUAL_REQUIRED ) ) { if ( ( retval = krb5_mk_rep ( context , * auth_context , & outbuf ) ) ) { return ( retval ) ; } retval = krb5_write_message ( context , fd , & outbuf ) ; free ( outbuf . data ) ; } cleanup : ; if ( retval ) { if ( local_authcon ) { krb5_auth_con_free ( context , * auth_context ) ; } else if ( local_rcache && rcache != NULL ) { krb5_rc_close ( context , rcache ) ; krb5_auth_con_setrcache ( context , * auth_context , NULL ) ; } } return retval ; }","if ( appl_version != NULL && ! problem ) {d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ;if ( ! data_eq ( inbuf , d ) ) {",2543
536,"buggy line: list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;ptr = buf ;cwe id:CWE-189context: Datum ltree_in ( PG_FUNCTION_ARGS ) { char * buf = ( char * ) PG_GETARG_POINTER ( 0 ) ; char * ptr ; nodeitem * list , * lptr ; int num = 0 , totallen = 0 ; int state = LTPRS_WAITNAME ; ltree * result ; ltree_level * curlevel ; int charlen ; int pos = 0 ; ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( charlen == 1 && t_iseq ( ptr , '.' ) ) num ++ ; ptr += charlen ; }  list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;  ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( state == LTPRS_WAITNAME ) { if ( ISALNUM ( ptr ) ) { lptr -> start = ptr ; lptr -> wlen = 0 ; state = LTPRS_WAITDELIM ; } else UNCHAR ; } else if ( state == LTPRS_WAITDELIM ) { if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { lptr -> len = ptr - lptr -> start ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; totallen += MAXALIGN ( lptr -> len + LEVEL_HDRSIZE ) ; lptr ++ ; state = LTPRS_WAITNAME ; } else if ( ! ISALNUM ( ptr ) ) UNCHAR ; } else elog ( ERROR , ""internal<S2SV_blank>error<S2SV_blank>in<S2SV_blank>parser"" ) ; ptr += charlen ; lptr -> wlen ++ ; pos ++ ; } if ( state == LTPRS_WAITDELIM ) { lptr -> len = ptr - lptr -> start ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; totallen += MAXALIGN ( lptr -> len + LEVEL_HDRSIZE ) ; lptr ++ ; } else if ( ! ( state == LTPRS_WAITNAME && lptr == list ) ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line."" ) ) ) ; result = ( ltree * ) palloc0 ( LTREE_HDRSIZE + totallen ) ; SET_VARSIZE ( result , LTREE_HDRSIZE + totallen ) ; result -> numlevel = lptr - list ; curlevel = LTREE_FIRST ( result ) ; lptr = list ; while ( lptr - list < result -> numlevel ) { curlevel -> len = ( uint16 ) lptr -> len ; memcpy ( curlevel -> name , lptr -> start , lptr -> len ) ; curlevel = LEVEL_NEXT ( curlevel ) ; lptr ++ ; } pfree ( list ) ; PG_RETURN_POINTER ( result ) ; }","if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ;list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;ptr = buf ;",2544
537,"buggy line: hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ;}cwe id:CWE-189context: static inline void x86_assign_hw_event ( struct perf_event * event , struct cpu_hw_events * cpuc , int i ) { struct hw_perf_event * hwc = & event -> hw ; hwc -> idx = cpuc -> assign [ i ] ; hwc -> last_cpu = smp_processor_id ( ) ; hwc -> last_tag = ++ cpuc -> tags [ i ] ; if ( hwc -> idx == X86_PMC_IDX_FIXED_BTS ) { hwc -> config_base = 0 ; hwc -> event_base = 0 ; } else if ( hwc -> idx >= X86_PMC_IDX_FIXED ) { hwc -> config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL ;  hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ;  } else { hwc -> config_base = x86_pmu_config_addr ( hwc -> idx ) ; hwc -> event_base = x86_pmu_event_addr ( hwc -> idx ) ; } }",hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + ( hwc -> idx - X86_PMC_IDX_FIXED ) ;},2545
538,"buggy line: unsigned long flags ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;cwe id:CWE-119context: static struct nvmet_fc_tgt_queue * nvmet_fc_find_target_queue ( struct nvmet_fc_tgtport * tgtport , u64 connection_id ) { struct nvmet_fc_tgt_assoc * assoc ; struct nvmet_fc_tgt_queue * queue ; u64 association_id = nvmet_fc_getassociationid ( connection_id ) ; u16 qid = nvmet_fc_getqueueid ( connection_id ) ;  unsigned long flags ;  spin_lock_irqsave ( & tgtport -> lock , flags ) ; list_for_each_entry ( assoc , & tgtport -> assoc_list , a_list ) { if ( association_id == assoc -> association_id ) { queue = assoc -> queues [ qid ] ; if ( queue && ( ! atomic_read ( & queue -> connected ) || ! nvmet_fc_tgt_q_get ( queue ) ) ) queue = NULL ; spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return queue ; } } spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return NULL ; }","unsigned long flags ;if ( qid > NVMET_NR_QUEUES ) return NULL ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;",2546
539,"buggy line: if ( msg -> maxsize - msg -> cursize < 4 ) {msg -> overflowed = qtrue ;cwe id:CWE-119context: void MSG_WriteBits ( msg_t * msg , int value , int bits ) { int i ; oldsize += bits ;  if ( msg -> maxsize - msg -> cursize < 4 ) {  msg -> overflowed = qtrue ; return ; } if ( bits == 0 || bits < - 31 || bits > 32 ) { Com_Error ( ERR_DROP , ""MSG_WriteBits:<S2SV_blank>bad<S2SV_blank>bits<S2SV_blank>%i"" , bits ) ; } if ( bits < 0 ) { bits = - bits ; } if ( msg -> oob ) {  if ( bits == 8 ) {  msg -> data [ msg -> cursize ] = value ; msg -> cursize += 1 ; msg -> bit += 8 ; } else if ( bits == 16 ) { short temp = value ; CopyLittleShort ( & msg -> data [ msg -> cursize ] , & temp ) ; msg -> cursize += 2 ; msg -> bit += 16 ; } else if ( bits == 32 ) { CopyLittleLong ( & msg -> data [ msg -> cursize ] , & value ) ; msg -> cursize += 4 ; msg -> bit += 32 ; } else { Com_Error ( ERR_DROP , ""can\'t<S2SV_blank>write<S2SV_blank>%d<S2SV_blank>bits"" , bits ) ; } } else { value &= ( 0xffffffff >> ( 32 - bits ) ) ; if ( bits & 7 ) { int nbits ;  nbits = bits & 7 ;  for ( i = 0 ; i < nbits ; i ++ ) { Huff_putBit ( ( value & 1 ) , msg -> data , & msg -> bit ) ; value = ( value >> 1 ) ; } bits = bits - nbits ; } if ( bits ) { for ( i = 0 ; i < bits ; i += 8 ) {  Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;  value = ( value >> 8 ) ;  }  } msg -> cursize = ( msg -> bit >> 3 ) + 1 ; } }",if ( msg -> overflowed ) {,2547
540,"buggy line: if ( bits == 8 ) {msg -> data [ msg -> cursize ] = value ;cwe id:CWE-119context: void MSG_WriteBits ( msg_t * msg , int value , int bits ) { int i ; oldsize += bits ;  if ( msg -> maxsize - msg -> cursize < 4 ) {  msg -> overflowed = qtrue ; return ; } if ( bits == 0 || bits < - 31 || bits > 32 ) { Com_Error ( ERR_DROP , ""MSG_WriteBits:<S2SV_blank>bad<S2SV_blank>bits<S2SV_blank>%i"" , bits ) ; } if ( bits < 0 ) { bits = - bits ; } if ( msg -> oob ) {  if ( bits == 8 ) {  msg -> data [ msg -> cursize ] = value ; msg -> cursize += 1 ; msg -> bit += 8 ; } else if ( bits == 16 ) { short temp = value ; CopyLittleShort ( & msg -> data [ msg -> cursize ] , & temp ) ; msg -> cursize += 2 ; msg -> bit += 16 ; } else if ( bits == 32 ) { CopyLittleLong ( & msg -> data [ msg -> cursize ] , & value ) ; msg -> cursize += 4 ; msg -> bit += 32 ; } else { Com_Error ( ERR_DROP , ""can\'t<S2SV_blank>write<S2SV_blank>%d<S2SV_blank>bits"" , bits ) ; } } else { value &= ( 0xffffffff >> ( 32 - bits ) ) ; if ( bits & 7 ) { int nbits ;  nbits = bits & 7 ;  for ( i = 0 ; i < nbits ; i ++ ) { Huff_putBit ( ( value & 1 ) , msg -> data , & msg -> bit ) ; value = ( value >> 1 ) ; } bits = bits - nbits ; } if ( bits ) { for ( i = 0 ; i < bits ; i += 8 ) {  Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;  value = ( value >> 8 ) ;  }  } msg -> cursize = ( msg -> bit >> 3 ) + 1 ; } }",if ( msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) {msg -> overflowed = qtrue ;return ;}if ( bits == 8 ) {msg -> data [ msg -> cursize ] = value ;,2547
541,"buggy line: nbits = bits & 7 ;for ( i = 0 ;cwe id:CWE-119context: void MSG_WriteBits ( msg_t * msg , int value , int bits ) { int i ; oldsize += bits ;  if ( msg -> maxsize - msg -> cursize < 4 ) {  msg -> overflowed = qtrue ; return ; } if ( bits == 0 || bits < - 31 || bits > 32 ) { Com_Error ( ERR_DROP , ""MSG_WriteBits:<S2SV_blank>bad<S2SV_blank>bits<S2SV_blank>%i"" , bits ) ; } if ( bits < 0 ) { bits = - bits ; } if ( msg -> oob ) {  if ( bits == 8 ) {  msg -> data [ msg -> cursize ] = value ; msg -> cursize += 1 ; msg -> bit += 8 ; } else if ( bits == 16 ) { short temp = value ; CopyLittleShort ( & msg -> data [ msg -> cursize ] , & temp ) ; msg -> cursize += 2 ; msg -> bit += 16 ; } else if ( bits == 32 ) { CopyLittleLong ( & msg -> data [ msg -> cursize ] , & value ) ; msg -> cursize += 4 ; msg -> bit += 32 ; } else { Com_Error ( ERR_DROP , ""can\'t<S2SV_blank>write<S2SV_blank>%d<S2SV_blank>bits"" , bits ) ; } } else { value &= ( 0xffffffff >> ( 32 - bits ) ) ; if ( bits & 7 ) { int nbits ;  nbits = bits & 7 ;  for ( i = 0 ; i < nbits ; i ++ ) { Huff_putBit ( ( value & 1 ) , msg -> data , & msg -> bit ) ; value = ( value >> 1 ) ; } bits = bits - nbits ; } if ( bits ) { for ( i = 0 ; i < bits ; i += 8 ) {  Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;  value = ( value >> 8 ) ;  }  } msg -> cursize = ( msg -> bit >> 3 ) + 1 ; } }","nbits = bits & 7 ;if ( msg -> bit , msg -> maxsize << 3 + nbits > msg -> maxsize << 3 ) {msg -> overflowed = qtrue ;return ;}for ( i = 0 ;",2547
542,"buggy line: Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;value = ( value >> 8 ) ;}}cwe id:CWE-119context: void MSG_WriteBits ( msg_t * msg , int value , int bits ) { int i ; oldsize += bits ;  if ( msg -> maxsize - msg -> cursize < 4 ) {  msg -> overflowed = qtrue ; return ; } if ( bits == 0 || bits < - 31 || bits > 32 ) { Com_Error ( ERR_DROP , ""MSG_WriteBits:<S2SV_blank>bad<S2SV_blank>bits<S2SV_blank>%i"" , bits ) ; } if ( bits < 0 ) { bits = - bits ; } if ( msg -> oob ) {  if ( bits == 8 ) {  msg -> data [ msg -> cursize ] = value ; msg -> cursize += 1 ; msg -> bit += 8 ; } else if ( bits == 16 ) { short temp = value ; CopyLittleShort ( & msg -> data [ msg -> cursize ] , & temp ) ; msg -> cursize += 2 ; msg -> bit += 16 ; } else if ( bits == 32 ) { CopyLittleLong ( & msg -> data [ msg -> cursize ] , & value ) ; msg -> cursize += 4 ; msg -> bit += 32 ; } else { Com_Error ( ERR_DROP , ""can\'t<S2SV_blank>write<S2SV_blank>%d<S2SV_blank>bits"" , bits ) ; } } else { value &= ( 0xffffffff >> ( 32 - bits ) ) ; if ( bits & 7 ) { int nbits ;  nbits = bits & 7 ;  for ( i = 0 ; i < nbits ; i ++ ) { Huff_putBit ( ( value & 1 ) , msg -> data , & msg -> bit ) ; value = ( value >> 1 ) ; } bits = bits - nbits ; } if ( bits ) { for ( i = 0 ; i < bits ; i += 8 ) {  Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;  value = ( value >> 8 ) ;  }  } msg -> cursize = ( msg -> bit >> 3 ) + 1 ; } }","Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;value = ( value >> 8 ) ;if ( msg -> bit > msg -> maxsize << 3 ) {msg -> overflowed = qtrue ;return ;}}}",2547
543,"buggy line: ( NULL != ptr ) # if KEEP_NIS_AT_END  && ( NULL != ptr -> line )   && ( ( '+' != ptr -> line [ 0 ] )   && ( '-' != ptr -> line [ 0 ] ) )  # endif ;# if KEEP_NIS_AT_END  if ( ( NULL != ptr ) && ( NULL != ptr -> line ) ) {nis = ptr ;cwe id:CWE-119context: int commonio_sort ( struct commonio_db * db , int ( * cmp ) ( const void * , const void * ) ) { struct commonio_entry * * entries , * ptr ; size_t n = 0 , i ; # if KEEP_NIS_AT_END struct commonio_entry * nis = NULL ; # endif for ( ptr = db -> head ; ( NULL != ptr ) # if KEEP_NIS_AT_END  && ( NULL != ptr -> line )   && ( ( '+' != ptr -> line [ 0 ] )   && ( '-' != ptr -> line [ 0 ] ) )  # endif ; ptr = ptr -> next ) { n ++ ; } # if KEEP_NIS_AT_END  if ( ( NULL != ptr ) && ( NULL != ptr -> line ) ) {  nis = ptr ; } # endif if ( n <= 1 ) { return 0 ; } entries = malloc ( n * sizeof ( struct commonio_entry * ) ) ; if ( entries == NULL ) { return - 1 ; } n = 0 ; for ( ptr = db -> head ; # if KEEP_NIS_AT_END nis != ptr ; # else NULL != ptr ; # endif ptr = ptr -> next ) { entries [ n ] = ptr ; n ++ ; } qsort ( entries , n , sizeof ( struct commonio_entry * ) , cmp ) ; db -> head = entries [ 0 ] ; n -- ; # if KEEP_NIS_AT_END if ( NULL == nis ) # endif { db -> tail = entries [ n ] ; } db -> head -> prev = NULL ; db -> head -> next = entries [ 1 ] ; entries [ n ] -> prev = entries [ n - 1 ] ; # if KEEP_NIS_AT_END entries [ n ] -> next = nis ; # else entries [ n ] -> next = NULL ; # endif for ( i = 1 ; i < n ; i ++ ) { entries [ i ] -> prev = entries [ i - 1 ] ; entries [ i ] -> next = entries [ i + 1 ] ; } free ( entries ) ; db -> changed = true ; return 0 ; }",( NULL != ptr ) # if KEEP_NIS_AT_END && ( ( NULL == ptr -> line ) && ( ( '+' != ptr -> line [ 0 ] ) ) ) # endif ;# if KEEP_NIS_AT_END if ( NULL != ptr ) {nis = ptr ;,2548
544,"buggy line: if ( interpolation ) {if ( source < source_base ) source = source_base ;horiz_line_scale ( source , source_width , temp_area , dest_width ) ;}for ( k = 0 ;k < ( int ) ( dest_height + dest_band_height - 1 ) / dest_band_height ;k ++ ) {for ( i = 0 ;i < source_band_height ;i ++ ) {line_src = ( unsigned char * ) source + i * source_pitch ;if ( line_src < source_base ) line_src = source_base ;horiz_line_scale ( line_src , source_width , temp_area + ( i + 1 ) * dest_pitch , dest_width ) ;}vert_band_scale ( temp_area + dest_pitch , dest_pitch , dest , dest_pitch , dest_width ) ;if ( interpolation )  vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ;source += ( unsigned long ) source_band_height * source_pitch ;cwe id:CWE-119context: static void Scale2D ( unsigned char * source , int source_pitch , unsigned int source_width , unsigned int source_height , unsigned char * dest , int dest_pitch , unsigned int dest_width , unsigned int dest_height , unsigned char * temp_area , unsigned char temp_area_height , unsigned int hscale , unsigned int hratio , unsigned int vscale , unsigned int vratio , unsigned int interlaced ) { int i , j , k ; int bands ; int dest_band_height ; int source_band_height ; typedef void ( * Scale1D ) ( const unsigned char * source , int source_step , unsigned int source_scale , unsigned int source_length , unsigned char * dest , int dest_step , unsigned int dest_scale , unsigned int dest_length ) ; Scale1D Scale1Dv = scale1d_c ; Scale1D Scale1Dh = scale1d_c ; void ( * horiz_line_scale ) ( const unsigned char * , unsigned int , unsigned char * , unsigned int ) = NULL ; void ( * vert_band_scale ) ( unsigned char * , unsigned int , unsigned char * , unsigned int , unsigned int ) = NULL ; int ratio_scalable = 1 ; int interpolation = 0 ; unsigned char * source_base ; unsigned char * line_src ; source_base = ( unsigned char * ) source ; if ( source_pitch < 0 ) { int offset ; offset = ( source_height - 1 ) ; offset *= source_pitch ; source_base += offset ; } switch ( hratio * 10 / hscale ) { case 8 : horiz_line_scale = vp8_horizontal_line_5_4_scale ; break ; case 6 : horiz_line_scale = vp8_horizontal_line_5_3_scale ; break ; case 5 : horiz_line_scale = vp8_horizontal_line_2_1_scale ; break ; default : ratio_scalable = 0 ; break ; } switch ( vratio * 10 / vscale ) { case 8 : vert_band_scale = vp8_vertical_band_5_4_scale ; source_band_height = 5 ; dest_band_height = 4 ; break ; case 6 : vert_band_scale = vp8_vertical_band_5_3_scale ; source_band_height = 5 ; dest_band_height = 3 ; break ; case 5 : if ( interlaced ) { vert_band_scale = vp8_vertical_band_2_1_scale ; } else { interpolation = 1 ; vert_band_scale = vp8_vertical_band_2_1_scale_i ; } source_band_height = 2 ; dest_band_height = 1 ; break ; default : ratio_scalable = 0 ; break ; } if ( ratio_scalable ) { if ( source_height == dest_height ) { for ( k = 0 ; k < ( int ) dest_height ; k ++ ) { horiz_line_scale ( source , source_width , dest , dest_width ) ; source += source_pitch ; dest += dest_pitch ; } return ; } if ( interpolation ) { if ( source < source_base ) source = source_base ; horiz_line_scale ( source , source_width , temp_area , dest_width ) ; } for ( k = 0 ; k < ( int ) ( dest_height + dest_band_height - 1 ) / dest_band_height ; k ++ ) { for ( i = 0 ; i < source_band_height ; i ++ ) { line_src = ( unsigned char * ) source + i * source_pitch ; if ( line_src < source_base ) line_src = source_base ; horiz_line_scale ( line_src , source_width , temp_area + ( i + 1 ) * dest_pitch , dest_width ) ; } vert_band_scale ( temp_area + dest_pitch , dest_pitch , dest , dest_pitch , dest_width ) ; if ( interpolation )  vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ;  source += ( unsigned long ) source_band_height * source_pitch ; dest += ( unsigned long ) dest_band_height * dest_pitch ; } return ; } if ( hscale == 2 && hratio == 1 ) Scale1Dh = scale1d_2t1_ps ; if ( vscale == 2 && vratio == 1 ) { if ( interlaced ) Scale1Dv = scale1d_2t1_ps ; else Scale1Dv = scale1d_2t1_i ; } if ( source_height == dest_height ) { for ( k = 0 ; k < ( int ) dest_height ; k ++ ) { Scale1Dh ( source , 1 , hscale , source_width + 1 , dest , 1 , hratio , dest_width ) ; source += source_pitch ; dest += dest_pitch ; } return ; } if ( dest_height > source_height ) { dest_band_height = temp_area_height - 1 ; source_band_height = dest_band_height * source_height / dest_height ; } else { source_band_height = temp_area_height - 1 ; dest_band_height = source_band_height * vratio / vscale ; } Scale1Dh ( source , 1 , hscale , source_width + 1 , temp_area , 1 , hratio , dest_width ) ; bands = ( dest_height + dest_band_height - 1 ) / dest_band_height ; for ( k = 0 ; k < bands ; k ++ ) { for ( i = 1 ; i < source_band_height + 1 ; i ++ ) { if ( k * source_band_height + i < ( int ) source_height ) { Scale1Dh ( source + i * source_pitch , 1 , hscale , source_width + 1 , temp_area + i * dest_pitch , 1 , hratio , dest_width ) ; } else {  vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ;  } } for ( j = 0 ; j < ( int ) dest_width ; j ++ ) { Scale1Dv ( & temp_area [ j ] , dest_pitch , vscale , source_band_height + 1 , & dest [ j ] , dest_pitch , vratio , dest_band_height ) ; }  vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ;  source += source_band_height * source_pitch ; dest += dest_band_height * dest_pitch ; } }","if ( interpolation ) memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ;source += ( unsigned long ) source_band_height * source_pitch ;",2549
545,"buggy line: source_band_height = temp_area_height - 1 ;dest_band_height = source_band_height * vratio / vscale ;Scale1Dh ( source , 1 , hscale , source_width + 1 , temp_area , 1 , hratio , dest_width ) ;bands = ( dest_height + dest_band_height - 1 ) / dest_band_height ;for ( k = 0 ;k < bands ;k ++ ) {for ( i = 1 ;i < source_band_height + 1 ;i ++ ) {if ( k * source_band_height + i < ( int ) source_height ) {Scale1Dh ( source + i * source_pitch , 1 , hscale , source_width + 1 , temp_area + i * dest_pitch , 1 , hratio , dest_width ) ;}else {vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ;}vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ;source += source_band_height * source_pitch ;cwe id:CWE-119context: static void Scale2D ( unsigned char * source , int source_pitch , unsigned int source_width , unsigned int source_height , unsigned char * dest , int dest_pitch , unsigned int dest_width , unsigned int dest_height , unsigned char * temp_area , unsigned char temp_area_height , unsigned int hscale , unsigned int hratio , unsigned int vscale , unsigned int vratio , unsigned int interlaced ) { int i , j , k ; int bands ; int dest_band_height ; int source_band_height ; typedef void ( * Scale1D ) ( const unsigned char * source , int source_step , unsigned int source_scale , unsigned int source_length , unsigned char * dest , int dest_step , unsigned int dest_scale , unsigned int dest_length ) ; Scale1D Scale1Dv = scale1d_c ; Scale1D Scale1Dh = scale1d_c ; void ( * horiz_line_scale ) ( const unsigned char * , unsigned int , unsigned char * , unsigned int ) = NULL ; void ( * vert_band_scale ) ( unsigned char * , unsigned int , unsigned char * , unsigned int , unsigned int ) = NULL ; int ratio_scalable = 1 ; int interpolation = 0 ; unsigned char * source_base ; unsigned char * line_src ; source_base = ( unsigned char * ) source ; if ( source_pitch < 0 ) { int offset ; offset = ( source_height - 1 ) ; offset *= source_pitch ; source_base += offset ; } switch ( hratio * 10 / hscale ) { case 8 : horiz_line_scale = vp8_horizontal_line_5_4_scale ; break ; case 6 : horiz_line_scale = vp8_horizontal_line_5_3_scale ; break ; case 5 : horiz_line_scale = vp8_horizontal_line_2_1_scale ; break ; default : ratio_scalable = 0 ; break ; } switch ( vratio * 10 / vscale ) { case 8 : vert_band_scale = vp8_vertical_band_5_4_scale ; source_band_height = 5 ; dest_band_height = 4 ; break ; case 6 : vert_band_scale = vp8_vertical_band_5_3_scale ; source_band_height = 5 ; dest_band_height = 3 ; break ; case 5 : if ( interlaced ) { vert_band_scale = vp8_vertical_band_2_1_scale ; } else { interpolation = 1 ; vert_band_scale = vp8_vertical_band_2_1_scale_i ; } source_band_height = 2 ; dest_band_height = 1 ; break ; default : ratio_scalable = 0 ; break ; } if ( ratio_scalable ) { if ( source_height == dest_height ) { for ( k = 0 ; k < ( int ) dest_height ; k ++ ) { horiz_line_scale ( source , source_width , dest , dest_width ) ; source += source_pitch ; dest += dest_pitch ; } return ; } if ( interpolation ) { if ( source < source_base ) source = source_base ; horiz_line_scale ( source , source_width , temp_area , dest_width ) ; } for ( k = 0 ; k < ( int ) ( dest_height + dest_band_height - 1 ) / dest_band_height ; k ++ ) { for ( i = 0 ; i < source_band_height ; i ++ ) { line_src = ( unsigned char * ) source + i * source_pitch ; if ( line_src < source_base ) line_src = source_base ; horiz_line_scale ( line_src , source_width , temp_area + ( i + 1 ) * dest_pitch , dest_width ) ; } vert_band_scale ( temp_area + dest_pitch , dest_pitch , dest , dest_pitch , dest_width ) ; if ( interpolation )  vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ;  source += ( unsigned long ) source_band_height * source_pitch ; dest += ( unsigned long ) dest_band_height * dest_pitch ; } return ; } if ( hscale == 2 && hratio == 1 ) Scale1Dh = scale1d_2t1_ps ; if ( vscale == 2 && vratio == 1 ) { if ( interlaced ) Scale1Dv = scale1d_2t1_ps ; else Scale1Dv = scale1d_2t1_i ; } if ( source_height == dest_height ) { for ( k = 0 ; k < ( int ) dest_height ; k ++ ) { Scale1Dh ( source , 1 , hscale , source_width + 1 , dest , 1 , hratio , dest_width ) ; source += source_pitch ; dest += dest_pitch ; } return ; } if ( dest_height > source_height ) { dest_band_height = temp_area_height - 1 ; source_band_height = dest_band_height * source_height / dest_height ; } else { source_band_height = temp_area_height - 1 ; dest_band_height = source_band_height * vratio / vscale ; } Scale1Dh ( source , 1 , hscale , source_width + 1 , temp_area , 1 , hratio , dest_width ) ; bands = ( dest_height + dest_band_height - 1 ) / dest_band_height ; for ( k = 0 ; k < bands ; k ++ ) { for ( i = 1 ; i < source_band_height + 1 ; i ++ ) { if ( k * source_band_height + i < ( int ) source_height ) { Scale1Dh ( source + i * source_pitch , 1 , hscale , source_width + 1 , temp_area + i * dest_pitch , 1 , hratio , dest_width ) ; } else {  vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ;  } } for ( j = 0 ; j < ( int ) dest_width ; j ++ ) { Scale1Dv ( & temp_area [ j ] , dest_pitch , vscale , source_band_height + 1 , & dest [ j ] , dest_pitch , vratio , dest_band_height ) ; }  vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ;  source += source_band_height * source_pitch ; dest += dest_band_height * dest_pitch ; } }","memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ;vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ;source += source_band_height * source_pitch ;",2549
546,"buggy line: if ( ack -> subh . addip_hdr -> serial == serial ) {sctp_chunk_hold ( ack ) ;cwe id:CWE-399context: struct sctp_chunk * sctp_assoc_lookup_asconf_ack ( const struct sctp_association * asoc , __be32 serial ) { struct sctp_chunk * ack ; list_for_each_entry ( ack , & asoc -> asconf_ack_list , transmitted_list ) {  if ( ack -> subh . addip_hdr -> serial == serial ) {  sctp_chunk_hold ( ack ) ; return ack ; } } return NULL ; }",if ( sctp_chunk_pending ( ack ) ) continue ;if ( ack -> subh . addip_hdr -> serial == serial ) {sctp_chunk_hold ( ack ) ;,2550
547,"buggy line: if ( IS_ERR ( blkg ) ) {blkg_free ( new_blkg ) ;return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;cwe id:CWE-415context: int blkcg_init_queue ( struct request_queue * q ) { struct blkcg_gq * new_blkg , * blkg ; bool preloaded ; int ret ; new_blkg = blkg_alloc ( & blkcg_root , q , GFP_KERNEL ) ; if ( ! new_blkg ) return - ENOMEM ; preloaded = ! radix_tree_preload ( GFP_KERNEL ) ; rcu_read_lock ( ) ; spin_lock_irq ( q -> queue_lock ) ; blkg = blkg_create ( & blkcg_root , q , new_blkg ) ; spin_unlock_irq ( q -> queue_lock ) ; rcu_read_unlock ( ) ; if ( preloaded ) radix_tree_preload_end ( ) ;  if ( IS_ERR ( blkg ) ) {  blkg_free ( new_blkg ) ; return PTR_ERR ( blkg ) ;  }  q -> root_blkg = blkg ; q -> root_rl . blkg = blkg ; ret = blk_throtl_init ( q ) ; if ( ret ) { spin_lock_irq ( q -> queue_lock ) ; blkg_destroy_all ( q ) ; spin_unlock_irq ( q -> queue_lock ) ; } return ret ; }",if ( IS_ERR ( blkg ) ) return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;,2551
548,"buggy line: static int  mptctl_do_fw_download ( int ioc , char __user * ufwbuf , size_t fwlen )  {MPT_FRAME_HDR * mf ;MPT_ADAPTER * iocp ;cwe id:CWE-362context: static int  mptctl_do_fw_download ( int ioc , char __user * ufwbuf , size_t fwlen )  { FWDownload_t * dlmsg ;  MPT_FRAME_HDR * mf ;  MPT_ADAPTER * iocp ; FWDownloadTCSGE_t * ptsge ; MptSge_t * sgl , * sgIn ; char * sgOut ; struct buflist * buflist ; struct buflist * bl ; dma_addr_t sgl_dma ; int ret ; int numfrags = 0 ; int maxfrags ; int n = 0 ; u32 sgdir ; u32 nib ; int fw_bytes_copied = 0 ; int i ; int sge_offset = 0 ; u16 iocstat ; pFWDownloadReply_t ReplyMsg = NULL ; unsigned long timeleft ;  if ( mpt_verify_adapter ( ioc , & iocp ) < 0 ) {  printk ( KERN_DEBUG MYNAM ""ioctl_fwdl<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , ioc ) ; return - ENODEV ; } else { if ( ( mf = mpt_get_msg_frame ( mptctl_id , iocp ) ) == NULL ) return - EAGAIN ;  }  dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_fwdl<S2SV_blank>called.<S2SV_blank>mptctl_id<S2SV_blank>=<S2SV_blank>%xh.\\n"" , iocp -> name , mptctl_id ) ) ; dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.bufp<S2SV_blank><S2SV_blank>=<S2SV_blank>%p\\n"" , iocp -> name , ufwbuf ) ) ; dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.fwlen<S2SV_blank>=<S2SV_blank>%d\\n"" ,  iocp -> name , ( int ) fwlen ) ) ;  dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.ioc<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%04xh\\n"" , iocp -> name , ioc ) ) ; dlmsg = ( FWDownload_t * ) mf ; ptsge = ( FWDownloadTCSGE_t * ) & dlmsg -> SGL ; sgOut = ( char * ) ( ptsge + 1 ) ; dlmsg -> ImageType = MPI_FW_DOWNLOAD_ITYPE_FW ; dlmsg -> Reserved = 0 ; dlmsg -> ChainOffset = 0 ; dlmsg -> Function = MPI_FUNCTION_FW_DOWNLOAD ; dlmsg -> Reserved1 [ 0 ] = dlmsg -> Reserved1 [ 1 ] = dlmsg -> Reserved1 [ 2 ] = 0 ; if ( iocp -> facts . MsgVersion >= MPI_VERSION_01_05 ) dlmsg -> MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT ; else dlmsg -> MsgFlags = 0 ; ptsge -> Reserved = 0 ; ptsge -> ContextSize = 0 ; ptsge -> DetailsLength = 12 ; ptsge -> Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT ; ptsge -> Reserved_0100_Checksum = 0 ; ptsge -> ImageOffset = 0 ; ptsge -> ImageSize = cpu_to_le32 ( fwlen ) ; sgdir = 0x04000000 ; sge_offset = sizeof ( MPIHeader_t ) + sizeof ( FWDownloadTCSGE_t ) ; if ( ( sgl = kbuf_alloc_2_sgl ( fwlen , sgdir , sge_offset , & numfrags , & buflist , & sgl_dma , iocp ) ) == NULL ) return - ENOMEM ; maxfrags = ( iocp -> req_sz - sizeof ( MPIHeader_t ) - sizeof ( FWDownloadTCSGE_t ) ) / iocp -> SGE_size ; if ( numfrags > maxfrags ) { ret = - EMLINK ; goto fwdl_out ; } dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>sgl<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>%p,<S2SV_blank>sgfrags<S2SV_blank>=<S2SV_blank>%d\\n"" , iocp -> name , sgl , numfrags ) ) ; ret = - EFAULT ; sgIn = sgl ; bl = buflist ; for ( i = 0 ; i < numfrags ; i ++ ) { nib = ( sgIn -> FlagsLength & 0x30000000 ) >> 28 ; if ( nib == 0 || nib == 3 ) { ; } else if ( sgIn -> Address ) { iocp -> add_sge ( sgOut , sgIn -> FlagsLength , sgIn -> Address ) ; n ++ ; if ( copy_from_user ( bl -> kptr , ufwbuf + fw_bytes_copied , bl -> len ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::_ioctl_fwdl<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>f/w<S2SV_blank>buffer<S2SV_blank>hunk#%d<S2SV_blank>@<S2SV_blank>%p\\n"" , iocp -> name , __FILE__ , __LINE__ , n , ufwbuf ) ; goto fwdl_out ; } fw_bytes_copied += bl -> len ; } sgIn ++ ; bl ++ ; sgOut += iocp -> SGE_size ; } DBG_DUMP_FW_DOWNLOAD ( iocp , ( u32 * ) mf , numfrags ) ; ReplyMsg = NULL ; SET_MGMT_MSG_CONTEXT ( iocp -> ioctl_cmds . msg_context , dlmsg -> MsgContext ) ; INITIALIZE_MGMT_STATUS ( iocp -> ioctl_cmds . status ) mpt_put_msg_frame ( mptctl_id , iocp , mf ) ; retry_wait : timeleft = wait_for_completion_timeout ( & iocp -> ioctl_cmds . done , HZ * 60 ) ; if ( ! ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) ) { ret = - ETIME ; printk ( MYIOC_s_WARN_FMT ""%s:<S2SV_blank>failed\\n"" , iocp -> name , __func__ ) ; if ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_DID_IOCRESET ) { mpt_free_msg_frame ( iocp , mf ) ; goto fwdl_out ; } if ( ! timeleft ) { printk ( MYIOC_s_WARN_FMT ""FW<S2SV_blank>download<S2SV_blank>timeout,<S2SV_blank>doorbell=0x%08x\\n"" , iocp -> name , mpt_GetIocState ( iocp , 0 ) ) ; mptctl_timeout_expired ( iocp , mf ) ; } else goto retry_wait ; goto fwdl_out ; } if ( ! ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_RF_VALID ) ) { printk ( MYIOC_s_WARN_FMT ""%s:<S2SV_blank>failed\\n"" , iocp -> name , __func__ ) ; mpt_free_msg_frame ( iocp , mf ) ; ret = - ENODATA ; goto fwdl_out ; } if ( sgl ) kfree_sgl ( sgl , sgl_dma , buflist , iocp ) ; ReplyMsg = ( pFWDownloadReply_t ) iocp -> ioctl_cmds . reply ; iocstat = le16_to_cpu ( ReplyMsg -> IOCStatus ) & MPI_IOCSTATUS_MASK ; if ( iocstat == MPI_IOCSTATUS_SUCCESS ) { printk ( MYIOC_s_INFO_FMT ""F/W<S2SV_blank>update<S2SV_blank>successful!\\n"" , iocp -> name ) ; return 0 ; } else if ( iocstat == MPI_IOCSTATUS_INVALID_FUNCTION ) { printk ( MYIOC_s_WARN_FMT ""Hmmm...<S2SV_blank><S2SV_blank>F/W<S2SV_blank>download<S2SV_blank>not<S2SV_blank>supported!?!\\n"" , iocp -> name ) ; printk ( MYIOC_s_WARN_FMT ""(time<S2SV_blank>to<S2SV_blank>go<S2SV_blank>bang<S2SV_blank>on<S2SV_blank>somebodies<S2SV_blank>door)\\n"" , iocp -> name ) ; return - EBADRQC ; } else if ( iocstat == MPI_IOCSTATUS_BUSY ) { printk ( MYIOC_s_WARN_FMT ""IOC_BUSY!\\n"" , iocp -> name ) ; printk ( MYIOC_s_WARN_FMT ""(try<S2SV_blank>again<S2SV_blank>later?)\\n"" , iocp -> name ) ; return - EBUSY ; } else { printk ( MYIOC_s_WARN_FMT ""ioctl_fwdl()<S2SV_blank>returned<S2SV_blank>[bad]<S2SV_blank>status<S2SV_blank>=<S2SV_blank>%04xh\\n"" , iocp -> name , iocstat ) ; printk ( MYIOC_s_WARN_FMT ""(bad<S2SV_blank>VooDoo)\\n"" , iocp -> name ) ; return - ENOMSG ; } return 0 ; fwdl_out : CLEAR_MGMT_STATUS ( iocp -> ioctl_cmds . status ) ; SET_MGMT_MSG_CONTEXT ( iocp -> ioctl_cmds . msg_context , 0 ) ; kfree_sgl ( sgl , sgl_dma , buflist , iocp ) ; return ret ; }","static int mptctl_do_fw_download ( MPT_ADAPTER * iocp , char __user * ufwbuf , size_t fwlen ) {MPT_FRAME_HDR * mf ;",2552
549,"buggy line: if ( mpt_verify_adapter ( ioc , & iocp ) < 0 ) {printk ( KERN_DEBUG MYNAM ""ioctl_fwdl<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;}else {}dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_fwdl<S2SV_blank>called.<S2SV_blank>mptctl_id<S2SV_blank>=<S2SV_blank>%xh.\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.fwlen<S2SV_blank>=<S2SV_blank>%d\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.ioc<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%04xh\\\cwe id:CWE-362context: static int  mptctl_do_fw_download ( int ioc , char __user * ufwbuf , size_t fwlen )  { FWDownload_t * dlmsg ;  MPT_FRAME_HDR * mf ;  MPT_ADAPTER * iocp ; FWDownloadTCSGE_t * ptsge ; MptSge_t * sgl , * sgIn ; char * sgOut ; struct buflist * buflist ; struct buflist * bl ; dma_addr_t sgl_dma ; int ret ; int numfrags = 0 ; int maxfrags ; int n = 0 ; u32 sgdir ; u32 nib ; int fw_bytes_copied = 0 ; int i ; int sge_offset = 0 ; u16 iocstat ; pFWDownloadReply_t ReplyMsg = NULL ; unsigned long timeleft ;  if ( mpt_verify_adapter ( ioc , & iocp ) < 0 ) {  printk ( KERN_DEBUG MYNAM ""ioctl_fwdl<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , ioc ) ; return - ENODEV ; } else { if ( ( mf = mpt_get_msg_frame ( mptctl_id , iocp ) ) == NULL ) return - EAGAIN ;  }  dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_fwdl<S2SV_blank>called.<S2SV_blank>mptctl_id<S2SV_blank>=<S2SV_blank>%xh.\\n"" , iocp -> name , mptctl_id ) ) ; dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.bufp<S2SV_blank><S2SV_blank>=<S2SV_blank>%p\\n"" , iocp -> name , ufwbuf ) ) ; dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.fwlen<S2SV_blank>=<S2SV_blank>%d\\n"" ,  iocp -> name , ( int ) fwlen ) ) ;  dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.ioc<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%04xh\\n"" , iocp -> name , ioc ) ) ; dlmsg = ( FWDownload_t * ) mf ; ptsge = ( FWDownloadTCSGE_t * ) & dlmsg -> SGL ; sgOut = ( char * ) ( ptsge + 1 ) ; dlmsg -> ImageType = MPI_FW_DOWNLOAD_ITYPE_FW ; dlmsg -> Reserved = 0 ; dlmsg -> ChainOffset = 0 ; dlmsg -> Function = MPI_FUNCTION_FW_DOWNLOAD ; dlmsg -> Reserved1 [ 0 ] = dlmsg -> Reserved1 [ 1 ] = dlmsg -> Reserved1 [ 2 ] = 0 ; if ( iocp -> facts . MsgVersion >= MPI_VERSION_01_05 ) dlmsg -> MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT ; else dlmsg -> MsgFlags = 0 ; ptsge -> Reserved = 0 ; ptsge -> ContextSize = 0 ; ptsge -> DetailsLength = 12 ; ptsge -> Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT ; ptsge -> Reserved_0100_Checksum = 0 ; ptsge -> ImageOffset = 0 ; ptsge -> ImageSize = cpu_to_le32 ( fwlen ) ; sgdir = 0x04000000 ; sge_offset = sizeof ( MPIHeader_t ) + sizeof ( FWDownloadTCSGE_t ) ; if ( ( sgl = kbuf_alloc_2_sgl ( fwlen , sgdir , sge_offset , & numfrags , & buflist , & sgl_dma , iocp ) ) == NULL ) return - ENOMEM ; maxfrags = ( iocp -> req_sz - sizeof ( MPIHeader_t ) - sizeof ( FWDownloadTCSGE_t ) ) / iocp -> SGE_size ; if ( numfrags > maxfrags ) { ret = - EMLINK ; goto fwdl_out ; } dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>sgl<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>%p,<S2SV_blank>sgfrags<S2SV_blank>=<S2SV_blank>%d\\n"" , iocp -> name , sgl , numfrags ) ) ; ret = - EFAULT ; sgIn = sgl ; bl = buflist ; for ( i = 0 ; i < numfrags ; i ++ ) { nib = ( sgIn -> FlagsLength & 0x30000000 ) >> 28 ; if ( nib == 0 || nib == 3 ) { ; } else if ( sgIn -> Address ) { iocp -> add_sge ( sgOut , sgIn -> FlagsLength , sgIn -> Address ) ; n ++ ; if ( copy_from_user ( bl -> kptr , ufwbuf + fw_bytes_copied , bl -> len ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::_ioctl_fwdl<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>f/w<S2SV_blank>buffer<S2SV_blank>hunk#%d<S2SV_blank>@<S2SV_blank>%p\\n"" , iocp -> name , __FILE__ , __LINE__ , n , ufwbuf ) ; goto fwdl_out ; } fw_bytes_copied += bl -> len ; } sgIn ++ ; bl ++ ; sgOut += iocp -> SGE_size ; } DBG_DUMP_FW_DOWNLOAD ( iocp , ( u32 * ) mf , numfrags ) ; ReplyMsg = NULL ; SET_MGMT_MSG_CONTEXT ( iocp -> ioctl_cmds . msg_context , dlmsg -> MsgContext ) ; INITIALIZE_MGMT_STATUS ( iocp -> ioctl_cmds . status ) mpt_put_msg_frame ( mptctl_id , iocp , mf ) ; retry_wait : timeleft = wait_for_completion_timeout ( & iocp -> ioctl_cmds . done , HZ * 60 ) ; if ( ! ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) ) { ret = - ETIME ; printk ( MYIOC_s_WARN_FMT ""%s:<S2SV_blank>failed\\n"" , iocp -> name , __func__ ) ; if ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_DID_IOCRESET ) { mpt_free_msg_frame ( iocp , mf ) ; goto fwdl_out ; } if ( ! timeleft ) { printk ( MYIOC_s_WARN_FMT ""FW<S2SV_blank>download<S2SV_blank>timeout,<S2SV_blank>doorbell=0x%08x\\n"" , iocp -> name , mpt_GetIocState ( iocp , 0 ) ) ; mptctl_timeout_expired ( iocp , mf ) ; } else goto retry_wait ; goto fwdl_out ; } if ( ! ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_RF_VALID ) ) { printk ( MYIOC_s_WARN_FMT ""%s:<S2SV_blank>failed\\n"" , iocp -> name , __func__ ) ; mpt_free_msg_frame ( iocp , mf ) ; ret = - ENODATA ; goto fwdl_out ; } if ( sgl ) kfree_sgl ( sgl , sgl_dma , buflist , iocp ) ; ReplyMsg = ( pFWDownloadReply_t ) iocp -> ioctl_cmds . reply ; iocstat = le16_to_cpu ( ReplyMsg -> IOCStatus ) & MPI_IOCSTATUS_MASK ; if ( iocstat == MPI_IOCSTATUS_SUCCESS ) { printk ( MYIOC_s_INFO_FMT ""F/W<S2SV_blank>update<S2SV_blank>successful!\\n"" , iocp -> name ) ; return 0 ; } else if ( iocstat == MPI_IOCSTATUS_INVALID_FUNCTION ) { printk ( MYIOC_s_WARN_FMT ""Hmmm...<S2SV_blank><S2SV_blank>F/W<S2SV_blank>download<S2SV_blank>not<S2SV_blank>supported!?!\\n"" , iocp -> name ) ; printk ( MYIOC_s_WARN_FMT ""(time<S2SV_blank>to<S2SV_blank>go<S2SV_blank>bang<S2SV_blank>on<S2SV_blank>somebodies<S2SV_blank>door)\\n"" , iocp -> name ) ; return - EBADRQC ; } else if ( iocstat == MPI_IOCSTATUS_BUSY ) { printk ( MYIOC_s_WARN_FMT ""IOC_BUSY!\\n"" , iocp -> name ) ; printk ( MYIOC_s_WARN_FMT ""(try<S2SV_blank>again<S2SV_blank>later?)\\n"" , iocp -> name ) ; return - EBUSY ; } else { printk ( MYIOC_s_WARN_FMT ""ioctl_fwdl()<S2SV_blank>returned<S2SV_blank>[bad]<S2SV_blank>status<S2SV_blank>=<S2SV_blank>%04xh\\n"" , iocp -> name , iocstat ) ; printk ( MYIOC_s_WARN_FMT ""(bad<S2SV_blank>VooDoo)\\n"" , iocp -> name ) ; return - ENOMSG ; } return 0 ; fwdl_out : CLEAR_MGMT_STATUS ( iocp -> ioctl_cmds . status ) ; SET_MGMT_MSG_CONTEXT ( iocp -> ioctl_cmds . msg_context , 0 ) ; kfree_sgl ( sgl , sgl_dma , buflist , iocp ) ; return ret ; }","}dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_fwdl<S2SV_blank>called.<S2SV_blank>mptctl_id<S2SV_blank>=<S2SV_blank>%xh.\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.fwlen<S2SV_blank>=<S2SV_blank>%d\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.ioc<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%04xh\\\",2552
550,"buggy line: skb -> sk = sk ;llc_sap_state_process ( sap , skb ) ;cwe id:CWE-20context: static void llc_sap_rcv ( struct llc_sap * sap , struct sk_buff * skb , struct sock * sk ) { struct llc_sap_state_ev * ev = llc_sap_ev ( skb ) ; ev -> type = LLC_SAP_EV_TYPE_PDU ; ev -> reason = 0 ;  skb -> sk = sk ;  llc_sap_state_process ( sap , skb ) ; }","skb_orphan ( skb ) ;sock_hold ( sk ) ;skb -> sk = sk ;skb -> destructor = sock_efree ;llc_sap_state_process ( sap , skb ) ;",2553
551,"buggy line: # if HAVE_NEON  int64_t store_reg [ 8 ] ;# endif VP8_COMMON * cm ;cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }",VP8_COMMON * cm ;,2554
552,"buggy line: return VPX_CODEC_CORRUPT_FRAME ;}cpi -> common . error . setjmp = 1 ;# if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {vp8_push_neon ( store_reg ) ;# endif vpx_usec_timer_start ( & cmptimer ) ;cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }",vp8_clear_system_state ( ) ;return VPX_CODEC_CORRUPT_FRAME ;cpi -> common . error . setjmp = 1 ;vpx_usec_timer_start ( & cmptimer ) ;,2554
553,"buggy line: # endif if ( ! cpi -> source ) {if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) {if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ;cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }",# endif return - 1 ;,2554
554,"buggy line: # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }",# endif # if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {,2554
555,"buggy line: if ( cpi -> oxcf . number_of_layers > 1 )  {unsigned int i ;assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;for ( i = 0 ;i < cpi -> oxcf . number_of_layers ;i ++ )  {cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }",# if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_total_resolutions > 1 ) {LOWER_RES_FRAME_INFO * low_res_frame_info = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ;if ( cpi -> oxcf . mr_encoder_id ) {cpi -> ref_framerate = low_res_frame_info -> low_res_framerate ;}else {low_res_frame_info -> low_res_framerate = cpi -> ref_framerate ;}}# endif if ( cpi -> oxcf . number_of_layers && i < VPX_TS_MAX_LAYERS ;++ i ) {,2554
556,"buggy line: layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;restore_layer_context ( cpi , layer ) ;vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ;}if ( cpi -> compressor_speed == 2 ) {vpx_usec_timer_start ( & tsctimer ) ;vpx_usec_timer_start ( & ticktimer ) ;}cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ;# if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING {int i ;const int num_part = ( 1 << cm -> multi_token_partition ) ;const unsigned long dest_size = dest_end - dest ;const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ;unsigned char * dp = dest ;cpi -> partition_d [ 0 ] = dp ;dp += dest_size / 10 ;cpi -> partition_d_end [ 0 ] = dp ;for ( i = 0 ;i < num_part ;i ++ ) {cpi -> partition_d [ i + 1 ] = dp ;dp += tok_part_buff_size ;cpi -> partition_d_end [ i + 1 ] = dp ;}}# endif * size = 0 ;vp8_clear_system_state ( ) ;cm -> frame_type = INTER_FRAME ;cm -> frame_flags = * frame_flags ;# if 0 if ( cm -> refresh_alt_ref_frame ) {cm -> refresh_golden_frame = 0 ;cm -> refresh_last_frame = 0 ;}else {cm -> refresh_golden_frame = 0 ;cm -> refresh_last_frame = 1 ;}# endif {int i = 0 ;for ( ;i < NUM_YV12_BUFFERS ;i ++ ) {if ( ! cm -> yv12_fb [ i ] . flags ) {cm -> new_fb_idx = i ;break ;}}assert ( i < NUM_YV12_BUFFERS ) ;# if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) {Pass1Encode ( cpi , size , dest , frame_flags ) ;}else if ( cpi -> pass == 2 ) {Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ;}else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ;if ( cpi -> compressor_speed == 2 ) {unsigned int duration , duration2 ;vpx_usec_timer_mark ( & tsctimer ) ;vpx_usec_timer_mark ( & ticktimer ) ;duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ;duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ;if ( cm -> frame_type != KEY_FRAME ) {if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ;else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ;}if ( duration2 ) {{if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ;else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ;}}}if ( cm -> refresh_entropy_probs == 0 ) {vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;}if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( * size > 0 ) {cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }","if ( cpi -> temporal_layer_id >= 0 ) {memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_alt_ref_frame ) vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_golden_frame ) vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_last_frame ) vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( * size > 0 ) {",2554
557,"buggy line: int y_samples = orig -> y_height * orig -> y_width ;int uv_samples = orig -> uv_height * orig -> uv_width ;int t_samples = y_samples + 2 * uv_samples ;double sq_error , sq_error2 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }","unsigned int y_width = cpi -> common . Width ;unsigned int y_height = cpi -> common . Height ;unsigned int uv_width = ( y_width + 1 ) / 2 ;unsigned int uv_height = ( y_height + 1 ) / 2 ;int y_samples = orig -> y_height * orig -> y_width ;int uv_samples = orig -> uv_height * orig -> uv_width ;int t_samples = y_samples + 2 * uv_samples ;double sq_error , sq_error2 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;",2554
558,"buggy line: double frame_psnr2 , frame_ssim2 = 0 ;double weight = 0 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }","double frame_psnr2 , frame_ssim2 = 0 ;double weight = 0 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , y_width , y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , uv_width , uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> u_buffer , pp -> uv_stride , uv_width , uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;",2554
559,"buggy line: frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;cpi -> summed_quality += frame_ssim2 * weight ;cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }","frame_ssim2 = vpx_calc_ssim ( cpi -> Source , & cm -> post_proc_buffer , & weight ) ;cpi -> summed_quality += frame_ssim2 * weight ;",2554
560,"buggy line: frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ;cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }","frame_all = vpx_calc_ssimg ( cpi -> Source , cm -> frame_to_show , & y , & u , & v ) ;",2554
561,"buggy line: # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {vp8_pop_neon ( store_reg ) ;}# endif cpi -> common . error . setjmp = 0 ;cwe id:CWE-119context: int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {  # if HAVE_NEON  int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ;  return VPX_CODEC_CORRUPT_FRAME ;  } cpi -> common . error . setjmp = 1 ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; }  if ( cpi -> oxcf . number_of_layers > 1 )  { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ;  layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;  restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;  } if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;  if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;  int y_samples = orig -> y_height * orig -> y_width ;   int uv_samples = orig -> uv_height * orig -> uv_width ;  int t_samples = y_samples + 2 * uv_samples ;  double sq_error , sq_error2 ;  ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;  double frame_psnr2 , frame_ssim2 = 0 ;  double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;   ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;  ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ;  frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;  cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ;  frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }",# endif # endif cpi -> common . error . setjmp = 0 ;,2554
562,"buggy line: ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;image = DestroyImage ( image ) ;cwe id:CWE-401context: static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox ""BoundingBox:"" # define BeginDocument ""BeginDocument:"" # define BeginXMPPacket ""<?xpacket<S2SV_blank>begin="" # define EndXMPPacket ""<?xpacket<S2SV_blank>end="" # define ICCProfile ""BeginICCProfile:"" # define CMYKCustomColor ""CMYKCustomColor:"" # define CMYKProcessColor ""CMYKProcessColor:"" # define DocumentMedia ""DocumentMedia:"" # define DocumentCustomColors ""DocumentCustomColors:"" # define DocumentProcessColors ""DocumentProcessColors:"" # define EndDocument ""EndDocument:"" # define HiResBoundingBox ""HiResBoundingBox:"" # define ImageData ""ImageData:"" # define PageBoundingBox ""PageBoundingBox:"" # define LanguageLevel ""LanguageLevel:"" # define PageMedia ""PageMedia:"" # define Pages ""Pages:"" # define PhotoshopProfile ""BeginPhotoshop:"" # define PostscriptLevel ""!PS-"" # define RenderPostscriptText ""<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>"" # define SpotColor ""+<S2SV_blank>"" char command [ MagickPathExtent ] , * density , filename [ MagickPathExtent ] , geometry [ MagickPathExtent ] , input_filename [ MagickPathExtent ] , message [ MagickPathExtent ] , * options , postscript_filename [ MagickPathExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length ; ssize_t count , priority ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> resolution . x == 0.0 ) || ( image -> resolution . y == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution = image -> resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) memset ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; columns = 0 ; rows = 0 ; priority = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; pages = ( ~ 0UL ) ; skip = MagickFalse ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , ""ps:Level"" , command + 4 , exception ) ; if ( GlobExpression ( command , ""*EPSF-*"" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel ""<S2SV_blank>%lu"" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages ""<S2SV_blank>%lu"" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData ""<S2SV_blank>%lu<S2SV_blank>%lu"" , & columns , & rows ) ; length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , ""*Cyan*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Magenta*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Yellow*"" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MagickPathExtent ] , * value ; register char * q ; ( void ) FormatLocaleString ( property , MagickPathExtent , ""ps:SpotColor-%.20g"" , ( double ) ( spotcolor ++ ) ) ; for ( q = command ; * q != '\\0' ; q ++ ) if ( isspace ( ( int ) ( unsigned char ) * q ) != 0 ) break ; value = ConstantString ( q ) ; ( void ) SubstituteString ( & value , ""("" , """" ) ; ( void ) SubstituteString ( & value , "")"" , """" ) ; ( void ) StripString ( value ) ; if ( * value != '\\0' ) ( void ) SetImageProperty ( image , property , value , exception ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%gx%g%+.15g%+.15g"" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , ""ps:HiResBoundingBox"" , geometry , exception ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , ""eps:fit-page"" ) ; if ( option != ( char * ) NULL ) { char * page_geometry ; page_geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( page_geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\'"" , option ) ;  image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> resolution . y / delta . y ) - 0.5 ) ; page_geometry = DestroyString ( page_geometry ) ; fitPage = MagickTrue ; } if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , ""/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{"" ""dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n"" ""<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n"" , MagickPathExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MagickPathExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MagickPathExtent , ""%g<S2SV_blank>%g<S2SV_blank>translate\\n"" , - bounds . x1 , - bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:mono"" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:cmyk"" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( ""ps:alpha"" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( """" ) ; options = AcquireString ( """" ) ; ( void ) FormatLocaleString ( density , MagickPathExtent , ""%gx%g"" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MagickPathExtent , ""-g%.20gx%.20g<S2SV_blank>"" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MagickPathExtent ] ; ( void ) FormatLocaleString ( pages , MagickPathExtent , ""-dFirstPage=%.20g<S2SV_blank>"" ""-dLastPage=%.20g<S2SV_blank>"" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MagickPathExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , ""eps:use-cropbox"" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , ""-dEPSCrop<S2SV_blank>"" , MagickPathExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , ""-dEPSFitPage<S2SV_blank>"" , MagickPathExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MagickPathExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , ""%d"" , MagickPathExtent ) ; ( void ) FormatLocaleString ( command , MagickPathExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename , exception ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , ""<S2SV_blank>-c<S2SV_blank>showpage"" , MagickPathExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename , exception ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename , exception ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , ""PostscriptDelegateFailed"" , ""`%s\'"" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , ""BMP"" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MagickPathExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * q ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile ""<S2SV_blank>%lu"" , & extent ) ; if ( count != 1 ) continue ; length = extent ; if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { q = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * q ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , ""8bim"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { p = command ; profile = StringToStringInfo ( command ) ; for ( i = ( ssize_t ) GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , ( size_t ) ( i + 1 ) ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , ( size_t ) i ) ; ( void ) SetImageProfile ( image , ""xmp"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; continue ; } } ( void ) CloseBlob ( image ) ; if ( image_info -> number_scenes != 0 ) { Image * clone_image ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MagickPathExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MagickPathExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }","( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;page_geometry = DestroyString ( page_geometry ) ;image = DestroyImage ( image ) ;",2555
563,"buggy line: if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) )  return cid ;cid ++ )  if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) )  return cid ;cwe id:CWE-125context: Id repodata_schema2id ( Repodata * data , Id * schema , int create ) { int h , len , i ; Id * sp , cid ; Id * schematahash ; if ( ! * schema ) return 0 ; if ( ( schematahash = data -> schematahash ) == 0 ) { data -> schematahash = schematahash = solv_calloc ( 256 , sizeof ( Id ) ) ; for ( i = 1 ; i < data -> nschemata ; i ++ ) { for ( sp = data -> schemadata + data -> schemata [ i ] , h = 0 ; * sp ; ) h = h * 7 + * sp ++ ; h &= 255 ; schematahash [ h ] = i ; } data -> schemadata = solv_extend_resize ( data -> schemadata , data -> schemadatalen , sizeof ( Id ) , SCHEMATADATA_BLOCK ) ; data -> schemata = solv_extend_resize ( data -> schemata , data -> nschemata , sizeof ( Id ) , SCHEMATA_BLOCK ) ; } for ( sp = schema , len = 0 , h = 0 ; * sp ; len ++ ) h = h * 7 + * sp ++ ; h &= 255 ; len ++ ; cid = schematahash [ h ] ; if ( cid ) {  if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) )  return cid ; for ( cid = 1 ; cid < data -> nschemata ; cid ++ )  if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) )  return cid ; } if ( ! create ) return 0 ; data -> schemadata = solv_extend ( data -> schemadata , data -> schemadatalen , len , sizeof ( Id ) , SCHEMATADATA_BLOCK ) ; data -> schemata = solv_extend ( data -> schemata , data -> nschemata , 1 , sizeof ( Id ) , SCHEMATA_BLOCK ) ; memcpy ( data -> schemadata + data -> schemadatalen , schema , len * sizeof ( Id ) ) ; data -> schemata [ data -> nschemata ] = data -> schemadatalen ; data -> schemadatalen += len ; schematahash [ h ] = data -> nschemata ; # if 0 fprintf ( stderr , ""schema2id:<S2SV_blank>new<S2SV_blank>schema\\n"" ) ; # endif return data -> nschemata ++ ; }","if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) return cid ;cid ++ ) if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) return cid ;",2556
564,"buggy line: exit ( - 1 ) ;}exit ( - 1 ) ;}exit ( - 1 ) ;}exit ( - 1 ) ;}cwe id:CWE-20context: char * ReadInput ( char * filename ) { FILE * finput ; long filesize , num ; char * buffer ; if ( ( finput = fopen ( filename , ""r"" ) ) == 0 ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s\\n"" , axohelp , filename ) ;  exit ( - 1 ) ;  } if ( ( fseek ( finput , 0 , SEEK_END ) != 0 ) || ( ( filesize = ftell ( finput ) ) < 0 ) || ( fseek ( finput , 0 , SEEK_SET ) != 0 ) ) { fprintf ( stderr , ""%s:<S2SV_blank>File<S2SV_blank>error<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s\\n"" , axohelp , filename ) ;  exit ( - 1 ) ;  } if ( ( buffer = malloc ( ( filesize + 1 ) * sizeof ( char ) ) ) == 0 ) { fprintf ( stderr , ""%s:<S2SV_blank>Error<S2SV_blank>allocating<S2SV_blank>%ld<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory"" , axohelp , filesize + 1 ) ;  exit ( - 1 ) ;  } num = fread ( buffer , 1 , filesize , finput ) ; if ( ferror ( finput ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>file<S2SV_blank>%s\\n"" , axohelp , filename ) ;  exit ( - 1 ) ;  } buffer [ num ] = 0 ; fclose ( finput ) ; return ( buffer ) ; }",exit ( 1 ) ;}exit ( 1 ) ;}exit ( 1 ) ;}exit ( 1 ) ;},2557
565,"buggy line: struct efx_nic * efx = netdev_priv ( net_dev ) ;if ( ring -> rx_mini_pending || ring -> rx_jumbo_pending || ring -> rx_pending > EFX_MAX_DMAQ_SIZE || ring -> tx_pending > EFX_MAX_DMAQ_SIZE ) return - EINVAL ;if ( ring -> rx_pending < EFX_MIN_RING_SIZE ||  ring -> tx_pending < EFX_MIN_RING_SIZE ) {netif_err ( efx , drv , efx -> net_dev ,  ""TX<S2SV_blank>and<S2SV_blank>RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%ld\\\return efx_realloc_channels ( efx , ring -> rx_pending , ring -> tx_pending ) ;}cwe id:CWE-189context: static int efx_ethtool_set_ringparam ( struct net_device * net_dev , struct ethtool_ringparam * ring ) {  struct efx_nic * efx = netdev_priv ( net_dev ) ;  if ( ring -> rx_mini_pending || ring -> rx_jumbo_pending || ring -> rx_pending > EFX_MAX_DMAQ_SIZE || ring -> tx_pending > EFX_MAX_DMAQ_SIZE ) return - EINVAL ;  if ( ring -> rx_pending < EFX_MIN_RING_SIZE ||  ring -> tx_pending < EFX_MIN_RING_SIZE ) { netif_err ( efx , drv , efx -> net_dev ,  ""TX<S2SV_blank>and<S2SV_blank>RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%ld\\n"" ,  EFX_MIN_RING_SIZE ) ; return - EINVAL ; }  return efx_realloc_channels ( efx , ring -> rx_pending , ring -> tx_pending ) ;  }","struct efx_nic * efx = netdev_priv ( net_dev ) ;u32 txq_entries ;if ( ring -> rx_mini_pending || ring -> rx_jumbo_pending || ring -> rx_pending > EFX_MAX_DMAQ_SIZE || ring -> tx_pending > EFX_MAX_DMAQ_SIZE ) return - EINVAL ;if ( ring -> rx_pending < EFX_RXQ_MIN_ENT ) {netif_err ( efx , drv , efx -> net_dev , ""RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%u\\\txq_entries = max ( ring -> tx_pending , EFX_TXQ_MIN_ENT ( efx ) ) ;if ( txq_entries != ring -> tx_pending ) netif_warn ( efx , drv , efx -> net_dev , ""increasing<S2SV_blank>TX<S2SV_blank>queue<S2SV_blank>size<S2SV_blank>to<S2SV_blank>minimum<S2SV_blank>of<S2SV_blank>%u\\\return efx_realloc_channels ( efx , ring -> rx_pending , txq_entries ) ;}",2558
566,"buggy line: bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ;}cwe id:CWE-125context: static void rtc_irq_eoi_tracking_reset ( struct kvm_ioapic * ioapic ) { ioapic -> rtc_status . pending_eoi = 0 ;  bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ;  }","bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPU_ID ) ;}",2559
567,"buggy line: if ( shdr -> sh_size < 1 ) {return NULL ;cwe id:CWE-119context: static Sdb * store_versioninfo_gnu_verneed ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { ut8 * end , * need = NULL ; const char * section_name = """" ; Elf_ ( Shdr ) * link_shdr = NULL ; const char * link_section_name = """" ; Sdb * sdb_vernaux = NULL ; Sdb * sdb_version = NULL ; Sdb * sdb = NULL ; int i , cnt ; if ( ! bin || ! bin -> dynstr ) { return NULL ; } if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return NULL ; }  if ( shdr -> sh_size < 1 ) {  return NULL ; } sdb = sdb_new0 ( ) ; if ( ! sdb ) { return NULL ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! ( need = ( ut8 * ) calloc ( R_MAX ( 1 , shdr -> sh_size ) , sizeof ( ut8 ) ) ) ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Elf_(Verneed)\\n"" ) ; goto beach ; } end = need + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""num_entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) { goto beach ; } if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) { goto beach ; } i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ; if ( i < 0 ) goto beach ; for ( i = 0 , cnt = 0 ; cnt < shdr -> sh_info ; ++ cnt ) { int j , isum ; ut8 * vstart = need + i ; Elf_ ( Verneed ) vvn = { 0 } ; if ( vstart + sizeof ( Elf_ ( Verneed ) ) > end ) { goto beach ; } Elf_ ( Verneed ) * entry = & vvn ; char key [ 32 ] = { 0 } ; sdb_version = sdb_new0 ( ) ; if ( ! sdb_version ) { goto beach ; } j = 0 ; vvn . vn_version = READ16 ( vstart , j ) vvn . vn_cnt = READ16 ( vstart , j ) vvn . vn_file = READ32 ( vstart , j ) vvn . vn_aux = READ32 ( vstart , j ) vvn . vn_next = READ32 ( vstart , j ) sdb_num_set ( sdb_version , ""vn_version"" , entry -> vn_version , 0 ) ; sdb_num_set ( sdb_version , ""idx"" , i , 0 ) ; if ( entry -> vn_file > bin -> dynstr_size ) { goto beach ; } { char * s = r_str_ndup ( & bin -> dynstr [ entry -> vn_file ] , 16 ) ; sdb_set ( sdb_version , ""file_name"" , s , 0 ) ; free ( s ) ; } sdb_num_set ( sdb_version , ""cnt"" , entry -> vn_cnt , 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux ; for ( j = 0 , isum = i + entry -> vn_aux ; j < entry -> vn_cnt && vstart + sizeof ( Elf_ ( Vernaux ) ) <= end ; ++ j ) { int k ; Elf_ ( Vernaux ) * aux = NULL ; Elf_ ( Vernaux ) vaux = { 0 } ; sdb_vernaux = sdb_new0 ( ) ; if ( ! sdb_vernaux ) { goto beach ; } aux = ( Elf_ ( Vernaux ) * ) & vaux ; k = 0 ; vaux . vna_hash = READ32 ( vstart , k ) vaux . vna_flags = READ16 ( vstart , k ) vaux . vna_other = READ16 ( vstart , k ) vaux . vna_name = READ32 ( vstart , k ) vaux . vna_next = READ32 ( vstart , k ) if ( aux -> vna_name > bin -> dynstr_size ) { goto beach ; } sdb_num_set ( sdb_vernaux , ""idx"" , isum , 0 ) ; if ( aux -> vna_name > 0 && aux -> vna_name + 8 < bin -> dynstr_size ) { char name [ 16 ] ; strncpy ( name , & bin -> dynstr [ aux -> vna_name ] , sizeof ( name ) - 1 ) ; name [ sizeof ( name ) - 1 ] = 0 ; sdb_set ( sdb_vernaux , ""name"" , name , 0 ) ; } sdb_set ( sdb_vernaux , ""flags"" , get_ver_flags ( aux -> vna_flags ) , 0 ) ; sdb_num_set ( sdb_vernaux , ""version"" , aux -> vna_other , 0 ) ; isum += aux -> vna_next ; vstart += aux -> vna_next ; snprintf ( key , sizeof ( key ) , ""vernaux%d"" , j ) ; sdb_ns_set ( sdb_version , key , sdb_vernaux ) ; } if ( ( int ) entry -> vn_next < 0 ) { bprintf ( ""Invalid<S2SV_blank>vn_next\\n"" ) ; break ; } i += entry -> vn_next ; snprintf ( key , sizeof ( key ) , ""version%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_version ) ; if ( ! entry -> vn_next ) { break ; } } free ( need ) ; return sdb ; beach : free ( need ) ; sdb_free ( sdb_vernaux ) ; sdb_free ( sdb_version ) ; sdb_free ( sdb ) ; return NULL ; }",if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return NULL ;,2560
568,"buggy line: if ( header_len > LEVEL_3_MAX_HEADER_LEN ) {return 0 ;cwe id:CWE-190context: static int decode_level3_header ( LHAFileHeader * * header , LHAInputStream * stream ) { unsigned int header_len ; if ( lha_decode_uint16 ( & RAW_DATA ( header , 0 ) ) != 4 ) { return 0 ; } if ( ! extend_raw_data ( header , stream , LEVEL_3_HEADER_LEN - RAW_DATA_LEN ( header ) ) ) { return 0 ; } header_len = lha_decode_uint32 ( & RAW_DATA ( header , 24 ) ) ;  if ( header_len > LEVEL_3_MAX_HEADER_LEN ) {  return 0 ; } if ( ! extend_raw_data ( header , stream , header_len - RAW_DATA_LEN ( header ) ) ) { return 0 ; } memcpy ( ( * header ) -> compress_method , & RAW_DATA ( header , 2 ) , 5 ) ; ( * header ) -> compress_method [ 5 ] = '\\0' ; ( * header ) -> compressed_length = lha_decode_uint32 ( & RAW_DATA ( header , 7 ) ) ; ( * header ) -> length = lha_decode_uint32 ( & RAW_DATA ( header , 11 ) ) ; ( * header ) -> timestamp = lha_decode_uint32 ( & RAW_DATA ( header , 15 ) ) ; ( * header ) -> crc = lha_decode_uint16 ( & RAW_DATA ( header , 21 ) ) ; ( * header ) -> os_type = RAW_DATA ( header , 23 ) ; if ( ! decode_extended_headers ( header , 28 ) ) { return 0 ; } return 1 ; }",if ( header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header ) ) {return 0 ;,2561
569,"buggy line: image -> columns = image -> rows = 0 ;image -> colors = 0 ;cwe id:CWE-787context: static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; one = 1 ; image = AcquireImage ( image_info ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> x_resolution = BitmapHeader1 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> x_resolution = BitmapHeader2 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ;  image -> columns = image -> rows = 0 ;  image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( BImgBuff , i , image , bpp ) ; } if ( BImgBuff )  BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ;  break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }",image -> columns = image -> rows = 0 ;image -> colors = 0 ;,2562
570,"buggy line: if ( BImgBuff )  BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ;;break ;cwe id:CWE-787context: static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; one = 1 ; image = AcquireImage ( image_info ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> x_resolution = BitmapHeader1 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> x_resolution = BitmapHeader2 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ;  image -> columns = image -> rows = 0 ;  image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( BImgBuff , i , image , bpp ) ; } if ( BImgBuff )  BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ;  break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }",if ( BImgBuff ) ;break ;,2562
571,"buggy line: void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi )  {__issue_discard_cmd ( sbi , false ) ;__drop_discard_cmd ( sbi ) ;__wait_discard_cmd ( sbi , false ) ;}cwe id:CWE-20context:  void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi )  { __issue_discard_cmd ( sbi , false ) ; __drop_discard_cmd ( sbi ) ;  __wait_discard_cmd ( sbi , false ) ;  }","void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi , bool umount ) {__issue_discard_cmd ( sbi , ! umount ) ;}",2563
572,"buggy line: dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\bsg_set_block ( bd , file ) ;cwe id:CWE-416context: static ssize_t bsg_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos ) { struct bsg_device * bd = file -> private_data ; ssize_t bytes_written ; int ret ;  dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n"" , bd -> name , count ) ;  bsg_set_block ( bd , file ) ; bytes_written = 0 ; ret = __bsg_write ( bd , buf , count , & bytes_written , file -> f_mode & FMODE_WRITE ) ; * ppos = bytes_written ; if ( ! bytes_written || err_block_err ( ret ) ) bytes_written = ret ; dprintk ( ""%s:<S2SV_blank>returning<S2SV_blank>%Zd\\n"" , bd -> name , bytes_written ) ; return bytes_written ; }","dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ;bsg_set_block ( bd , file ) ;",2564
573,"buggy line: if ( check_stack_guard_page ( vma , address ) < 0 )  return VM_FAULT_SIGSEGV ;cwe id:CWE-20context: static int do_anonymous_page ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags ) { struct mem_cgroup * memcg ; struct page * page ; spinlock_t * ptl ; pte_t entry ; pte_unmap ( page_table ) ;  if ( check_stack_guard_page ( vma , address ) < 0 )  return VM_FAULT_SIGSEGV ; if ( ! ( flags & FAULT_FLAG_WRITE ) && ! mm_forbids_zeropage ( mm ) ) { entry = pte_mkspecial ( pfn_pte ( my_zero_pfn ( address ) , vma -> vm_page_prot ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto unlock ; goto setpte ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) goto oom ; page = alloc_zeroed_user_highpage_movable ( vma , address ) ; if ( ! page ) goto oom ; if ( mem_cgroup_try_charge ( page , mm , GFP_KERNEL , & memcg ) ) goto oom_free_page ; __SetPageUptodate ( page ) ; entry = mk_pte ( page , vma -> vm_page_prot ) ; if ( vma -> vm_flags & VM_WRITE ) entry = pte_mkwrite ( pte_mkdirty ( entry ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto release ; inc_mm_counter_fast ( mm , MM_ANONPAGES ) ; page_add_new_anon_rmap ( page , vma , address ) ; mem_cgroup_commit_charge ( page , memcg , false ) ; lru_cache_add_active_or_unevictable ( page , vma ) ; setpte : set_pte_at ( mm , address , page_table , entry ) ; update_mmu_cache ( vma , address , page_table ) ; unlock : pte_unmap_unlock ( page_table , ptl ) ; return 0 ; release : mem_cgroup_cancel_charge ( page , memcg ) ; page_cache_release ( page ) ; goto unlock ; oom_free_page : page_cache_release ( page ) ; oom : return VM_FAULT_OOM ; }","if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ;if ( check_stack_guard_page ( vma , address ) < 0 ) return VM_FAULT_SIGSEGV ;",2565
574,"buggy line: if ( ! mm )  return 0 ;cwe id:CWE-362context: static ssize_t environ_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { char * page ; unsigned long src = * ppos ; int ret = 0 ; struct mm_struct * mm = file -> private_data ; unsigned long env_start , env_end ;  if ( ! mm )  return 0 ; page = ( char * ) __get_free_page ( GFP_TEMPORARY ) ; if ( ! page ) return - ENOMEM ; ret = 0 ; if ( ! atomic_inc_not_zero ( & mm -> mm_users ) ) goto free ; down_read ( & mm -> mmap_sem ) ; env_start = mm -> env_start ; env_end = mm -> env_end ; up_read ( & mm -> mmap_sem ) ; while ( count > 0 ) { size_t this_len , max_len ; int retval ; if ( src >= ( env_end - env_start ) ) break ; this_len = env_end - ( env_start + src ) ; max_len = min_t ( size_t , PAGE_SIZE , count ) ; this_len = min ( max_len , this_len ) ; retval = access_remote_vm ( mm , ( env_start + src ) , page , this_len , 0 ) ; if ( retval <= 0 ) { ret = retval ; break ; } if ( copy_to_user ( buf , page , retval ) ) { ret = - EFAULT ; break ; } ret += retval ; src += retval ; buf += retval ; count -= retval ; } * ppos = src ; mmput ( mm ) ; free : free_page ( ( unsigned long ) page ) ; return ret ; }",if ( ! mm || ! mm -> env_end ) return 0 ;,2566
575,"buggy line: static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe ,  struct pipe_buffer * buf ) {ref -> ref ++ ;}cwe id:CWE-416context:  static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe ,  struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;  ref -> ref ++ ;   } ","static bool buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {if ( ref -> ref > INT_MAX / 2 ) return false ;ref -> ref ++ ;return true ;}",2567
576,"buggy line: cork -> length += length ;if ( length > mtu ) {int proto = sk -> sk_protocol ;if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ;if ( proto == IPPROTO_UDP &&  ( rt -> dst . dev -> features & NETIF_F_UFO ) ) {}if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ;cwe id:CWE-119context: int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb , * skb_prev = NULL ; unsigned int maxfraglen , fragheaderlen , mtu ; int exthdrlen ; int dst_exthdrlen ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; if ( flags & MSG_PROBE ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( WARN_ON ( np -> cork . opt ) ) return - EINVAL ; np -> cork . opt = kzalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == NULL ) ) return - ENOBUFS ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ; np -> cork . opt -> dst0opt = ip6_opt_dup ( opt -> dst0opt , sk -> sk_allocation ) ; if ( opt -> dst0opt && ! np -> cork . opt -> dst0opt ) return - ENOBUFS ; np -> cork . opt -> dst1opt = ip6_opt_dup ( opt -> dst1opt , sk -> sk_allocation ) ; if ( opt -> dst1opt && ! np -> cork . opt -> dst1opt ) return - ENOBUFS ; np -> cork . opt -> hopopt = ip6_opt_dup ( opt -> hopopt , sk -> sk_allocation ) ; if ( opt -> hopopt && ! np -> cork . opt -> hopopt ) return - ENOBUFS ; np -> cork . opt -> srcrt = ip6_rthdr_dup ( opt -> srcrt , sk -> sk_allocation ) ; if ( opt -> srcrt && ! np -> cork . opt -> srcrt ) return - ENOBUFS ; } dst_hold ( & rt -> dst ) ; cork -> dst = & rt -> dst ; inet -> cork . fl . u . ip6 = * fl6 ; np -> cork . hop_limit = hlimit ; np -> cork . tclass = tclass ; if ( rt -> dst . flags & DST_XFRM_TUNNEL ) mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( & rt -> dst ) ; else mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; if ( np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } cork -> fragsize = mtu ; if ( dst_allfrag ( rt -> dst . path ) ) cork -> flags |= IPCORK_ALLFRAG ; cork -> length = 0 ; exthdrlen = ( opt ? opt -> opt_flen : 0 ) ; length += exthdrlen ; transhdrlen += exthdrlen ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } else { rt = ( struct rt6_info * ) cork -> dst ; fl6 = & inet -> cork . fl . u . ip6 ; opt = np -> cork . opt ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; mtu = cork -> fragsize ; } hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; if ( mtu <= sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ) { if ( cork -> length + length > sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN - fragheaderlen ) { ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } } if ( sk -> sk_type == SOCK_DGRAM ) sock_tx_timestamp ( sk , & tx_flags ) ;  cork -> length += length ;   if ( length > mtu ) {  int proto = sk -> sk_protocol ;  if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {  ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; }  if ( proto == IPPROTO_UDP &&  ( rt -> dst . dev -> features & NETIF_F_UFO ) ) { err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , transhdrlen , mtu , flags , rt ) ; if ( err ) goto error ; return 0 ; }  }  if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( skb == NULL || skb_prev == NULL ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( skb == NULL ) ) err = - ENOBUFS ; else { tx_flags = 0 ; } } if ( skb == NULL ) goto error ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = CHECKSUM_NONE ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; if ( sk -> sk_type == SOCK_DGRAM ) skb_shinfo ( skb ) -> tx_flags = tx_flags ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; struct page_frag * pfrag = sk_page_frag ( sk ) ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }","if ( ( length > mtu ) {int proto = sk -> sk_protocol ;if ( dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ;skb = skb_peek_tail ( & sk -> sk_write_queue ) ;cork -> length += length ;if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) ) {if ( ! skb ) goto alloc_new_skb ;",2568
577,"buggy line: INST_HANDLER ( sts ) {int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;cwe id:CWE-125context:  INST_HANDLER ( sts ) {  int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; ESIL_A ( ""r%d,"" , r ) ; __generic_ld_st ( op , ""ram"" , 0 , 1 , 0 , k , 1 ) ; op -> cycles = 2 ; }",INST_HANDLER ( sts ) {if ( len < 4 ) {return ;}int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,2569
578,"buggy line: if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) )  if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;cwe id:CWE-125context: static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) iris_info . name ) ; iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; ( void ) count ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; }  if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) )  if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;",2570
579,"buggy line: return kvm_x86_ops -> set_msr ( vcpu , msr ) ;}cwe id:CWE-000context: int kvm_set_msr ( struct kvm_vcpu * vcpu , struct msr_data * msr ) {  return kvm_x86_ops -> set_msr ( vcpu , msr ) ;  }","switch ( msr -> index ) {case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ;break ;case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ;}return kvm_x86_ops -> set_msr ( vcpu , msr ) ;}",2571
580,"buggy line: char file [ PATH_MAX ] ;strlcat ( info -> path , ""maps"" , sizeof ( info -> path ) ) ;while ( fscanf ( maps , ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%s<S2SV_blank>%ld<S2SV_blank>%s\\\cwe id:CWE-20context: static void print_maps ( struct pid_info_t * info ) { FILE * maps ; size_t offset ; char device [ 10 ] ; long int inode ;  char file [ PATH_MAX ] ;  strlcat ( info -> path , ""maps"" , sizeof ( info -> path ) ) ; maps = fopen ( info -> path , ""r"" ) ; if ( ! maps ) goto out ;  while ( fscanf ( maps , ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%s<S2SV_blank>%ld<S2SV_blank>%s\\n"" , & offset , device , & inode ,  file ) == 4 ) { if ( inode == 0 || ! strcmp ( device , ""00:00"" ) ) continue ; printf ( ""%-9s<S2SV_blank>%5d<S2SV_blank>%10s<S2SV_blank>%4s<S2SV_blank>%9s<S2SV_blank>%18s<S2SV_blank>%9zd<S2SV_blank>%10ld<S2SV_blank>%s\\n"" , info -> cmdline , info -> pid , info -> user , ""mem"" , ""???"" , device , offset , inode , file ) ; } fclose ( maps ) ; out : info -> path [ info -> parent_length ] = '\\0' ; }","char file [ 1024 ] ;strlcat ( info -> path , ""maps"" , sizeof ( info -> path ) ) ;while ( fscanf ( maps , ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%5s<S2SV_blank>%ld<S2SV_blank>%1023s\\\",2572
581,"buggy line: int is_pdf ;char * header ;header = get_header ( fp ) ;if ( header && strstr ( header , ""%PDF-"" ) )  is_pdf = 1 ;else is_pdf = 0 ;cwe id:CWE-787context: int pdf_is_pdf ( FILE * fp ) {  int is_pdf ;  char * header ;  header = get_header ( fp ) ;   if ( header && strstr ( header , ""%PDF-"" ) )  is_pdf = 1 ; else is_pdf = 0 ; free ( header ) ; return is_pdf ; }","char * header ;if ( ! ( header = get_header ( fp ) ) ) return 0 ;const char * c = strstr ( header , ""%PDF-"" ) ;const int is_pdf = c && ( ( c - header + strlen ( ""%PDF-M.m"" ) ) < 1024 ) ;",2573
582,"buggy line: uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ;nblks += dblocks ;cwe id:CWE-19context: STATIC int xfs_attr_calc_size ( struct xfs_inode * ip , int namelen , int valuelen , int * local ) { struct xfs_mount * mp = ip -> i_mount ; int size ; int nblks ; size = xfs_attr_leaf_newentsize ( namelen , valuelen , mp -> m_sb . sb_blocksize , local ) ; nblks = XFS_DAENTER_SPACE_RES ( mp , XFS_ATTR_FORK ) ; if ( * local ) { if ( size > ( mp -> m_sb . sb_blocksize >> 1 ) ) { nblks *= 2 ; } } else {  uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ;  nblks += dblocks ; nblks += XFS_NEXTENTADD_SPACE_RES ( mp , dblocks , XFS_ATTR_FORK ) ; } return nblks ; }","uint dblocks = xfs_attr3_rmt_blocks ( mp , valuelen ) ;nblks += dblocks ;",2574
583,"buggy line: archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC ,   ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;archive_clear_error ( & a -> archive ) ;cwe id:CWE-189context: static ssize_t _archive_write_data ( struct archive * _a , const void * buff , size_t s ) { struct archive_write * a = ( struct archive_write * ) _a ;  archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC ,   ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;  archive_clear_error ( & a -> archive ) ; return ( ( a -> format_write_data ) ( a , buff , s ) ) ; }","const size_t max_write = INT_MAX ;archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;if ( s > max_write ) s = max_write ;archive_clear_error ( & a -> archive ) ;",2575
584,"buggy line: case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE :  case RAPTOR_OPTION_RELATIVE_URIS :  case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ;cwe id:CWE-200context: int raptor_turtle_writer_get_option ( raptor_turtle_writer * turtle_writer , raptor_option option ) { int result = - 1 ; switch ( option ) { case RAPTOR_OPTION_WRITER_AUTO_INDENT : result = TURTLE_WRITER_AUTO_INDENT ( turtle_writer ) ; break ; case RAPTOR_OPTION_WRITER_INDENT_WIDTH : result = turtle_writer -> indent ; break ; case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE :  case RAPTOR_OPTION_RELATIVE_URIS :  case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ; } return result ; }",case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case RAPTOR_OPTION_RELATIVE_URIS : case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ;,2576
585,"buggy line: cwe id:CWE-125context: static alias_ty alias_for_import_name ( struct compiling * c , const node * n , int store ) { identifier str , name ; loop : switch ( TYPE ( n ) ) { case import_as_name : { node * name_node = CHILD ( n , 0 ) ; str = NULL ; name = NEW_IDENTIFIER ( name_node ) ; if ( ! name ) return NULL ; if ( NCH ( n ) == 3 ) { node * str_node = CHILD ( n , 2 ) ; str = NEW_IDENTIFIER ( str_node ) ; if ( ! str ) return NULL ; if ( store && forbidden_name ( c , str , str_node , 0 ) ) return NULL ; } else { if ( forbidden_name ( c , name , name_node , 0 ) ) return NULL ; } return alias ( name , str , c -> c_arena ) ; } case dotted_as_name : if ( NCH ( n ) == 1 ) { n = CHILD ( n , 0 ) ; goto loop ; } else { node * asname_node = CHILD ( n , 2 ) ; alias_ty a = alias_for_import_name ( c , CHILD ( n , 0 ) , 0 ) ; if ( ! a ) return NULL ; assert ( ! a -> asname ) ; a -> asname = NEW_IDENTIFIER ( asname_node ) ; if ( ! a -> asname ) return NULL ; if ( forbidden_name ( c , a -> asname , asname_node , 0 ) ) return NULL ; return a ; } break ; case dotted_name : if ( NCH ( n ) == 1 ) { node * name_node = CHILD ( n , 0 ) ; name = NEW_IDENTIFIER ( name_node ) ; if ( ! name ) return NULL ; if ( store && forbidden_name ( c , name , name_node , 0 ) ) return NULL ; return alias ( name , NULL , c -> c_arena ) ; } else { int i ; size_t len ; char * s ; PyObject * uni ; len = 0 ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) len += strlen ( STR ( CHILD ( n , i ) ) ) + 1 ; len -- ; str = PyBytes_FromStringAndSize ( NULL , len ) ; if ( ! str ) return NULL ; s = PyBytes_AS_STRING ( str ) ; if ( ! s ) return NULL ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { char * sch = STR ( CHILD ( n , i ) ) ; strcpy ( s , STR ( CHILD ( n , i ) ) ) ; s += strlen ( sch ) ; * s ++ = '.' ; } -- s ; * s = '\\0' ; uni = PyUnicode_DecodeUTF8 ( PyBytes_AS_STRING ( str ) , PyBytes_GET_SIZE ( str ) , NULL ) ; Py_DECREF ( str ) ; if ( ! uni ) return NULL ; str = uni ; PyUnicode_InternInPlace ( & str ) ; if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) { Py_DECREF ( str ) ; return NULL ; } return alias ( str , NULL , c -> c_arena ) ; } break ; case STAR : str = PyUnicode_InternFromString ( ""*"" ) ;  if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) {  Py_DECREF ( str ) ; return NULL ; } return alias ( str , NULL , c -> c_arena ) ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>import<S2SV_blank>name:<S2SV_blank>%d"" , TYPE ( n ) ) ; return NULL ; } PyErr_SetString ( PyExc_SystemError , ""unhandled<S2SV_blank>import<S2SV_blank>name<S2SV_blank>condition"" ) ; return NULL ; }",if ( ! str ) return NULL ;,2577
586,"buggy line: if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) {Py_DECREF ( str ) ;cwe id:CWE-125context: static alias_ty alias_for_import_name ( struct compiling * c , const node * n , int store ) { identifier str , name ; loop : switch ( TYPE ( n ) ) { case import_as_name : { node * name_node = CHILD ( n , 0 ) ; str = NULL ; name = NEW_IDENTIFIER ( name_node ) ; if ( ! name ) return NULL ; if ( NCH ( n ) == 3 ) { node * str_node = CHILD ( n , 2 ) ; str = NEW_IDENTIFIER ( str_node ) ; if ( ! str ) return NULL ; if ( store && forbidden_name ( c , str , str_node , 0 ) ) return NULL ; } else { if ( forbidden_name ( c , name , name_node , 0 ) ) return NULL ; } return alias ( name , str , c -> c_arena ) ; } case dotted_as_name : if ( NCH ( n ) == 1 ) { n = CHILD ( n , 0 ) ; goto loop ; } else { node * asname_node = CHILD ( n , 2 ) ; alias_ty a = alias_for_import_name ( c , CHILD ( n , 0 ) , 0 ) ; if ( ! a ) return NULL ; assert ( ! a -> asname ) ; a -> asname = NEW_IDENTIFIER ( asname_node ) ; if ( ! a -> asname ) return NULL ; if ( forbidden_name ( c , a -> asname , asname_node , 0 ) ) return NULL ; return a ; } break ; case dotted_name : if ( NCH ( n ) == 1 ) { node * name_node = CHILD ( n , 0 ) ; name = NEW_IDENTIFIER ( name_node ) ; if ( ! name ) return NULL ; if ( store && forbidden_name ( c , name , name_node , 0 ) ) return NULL ; return alias ( name , NULL , c -> c_arena ) ; } else { int i ; size_t len ; char * s ; PyObject * uni ; len = 0 ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) len += strlen ( STR ( CHILD ( n , i ) ) ) + 1 ; len -- ; str = PyBytes_FromStringAndSize ( NULL , len ) ; if ( ! str ) return NULL ; s = PyBytes_AS_STRING ( str ) ; if ( ! s ) return NULL ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { char * sch = STR ( CHILD ( n , i ) ) ; strcpy ( s , STR ( CHILD ( n , i ) ) ) ; s += strlen ( sch ) ; * s ++ = '.' ; } -- s ; * s = '\\0' ; uni = PyUnicode_DecodeUTF8 ( PyBytes_AS_STRING ( str ) , PyBytes_GET_SIZE ( str ) , NULL ) ; Py_DECREF ( str ) ; if ( ! uni ) return NULL ; str = uni ; PyUnicode_InternInPlace ( & str ) ; if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) { Py_DECREF ( str ) ; return NULL ; } return alias ( str , NULL , c -> c_arena ) ; } break ; case STAR : str = PyUnicode_InternFromString ( ""*"" ) ;  if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) {  Py_DECREF ( str ) ; return NULL ; } return alias ( str , NULL , c -> c_arena ) ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>import<S2SV_blank>name:<S2SV_blank>%d"" , TYPE ( n ) ) ; return NULL ; } PyErr_SetString ( PyExc_SystemError , ""unhandled<S2SV_blank>import<S2SV_blank>name<S2SV_blank>condition"" ) ; return NULL ; }","if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) {Py_DECREF ( str ) ;",2577
587,"buggy line: if ( ( error_code >> 16 ) != 0x8009 )  return WindowsErrorString ( ) ;cwe id:CWE-494context: const char * WinPKIErrorString ( void ) { static char error_string [ 64 ] ; DWORD error_code = GetLastError ( ) ;  if ( ( error_code >> 16 ) != 0x8009 )  return WindowsErrorString ( ) ; switch ( error_code ) { case NTE_BAD_UID : return ""Bad<S2SV_blank>UID."" ; case CRYPT_E_MSG_ERROR : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>performing<S2SV_blank>an<S2SV_blank>operation<S2SV_blank>on<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message."" ; case CRYPT_E_UNKNOWN_ALGO : return ""Unknown<S2SV_blank>cryptographic<S2SV_blank>algorithm."" ; case CRYPT_E_INVALID_MSG_TYPE : return ""Invalid<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>type."" ; case CRYPT_E_HASH_VALUE : return ""The<S2SV_blank>hash<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct"" ; case CRYPT_E_ISSUER_SERIALNUMBER : return ""Invalid<S2SV_blank>issuer<S2SV_blank>and/or<S2SV_blank>serial<S2SV_blank>number."" ; case CRYPT_E_BAD_LEN : return ""The<S2SV_blank>length<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>data<S2SV_blank>was<S2SV_blank>insufficient."" ; case CRYPT_E_BAD_ENCODE : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>during<S2SV_blank>encode<S2SV_blank>or<S2SV_blank>decode<S2SV_blank>operation."" ; case CRYPT_E_FILE_ERROR : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>or<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file."" ; case CRYPT_E_NOT_FOUND : return ""Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property."" ; case CRYPT_E_EXISTS : return ""The<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property<S2SV_blank>already<S2SV_blank>exists."" ; case CRYPT_E_NO_PROVIDER : return ""No<S2SV_blank>provider<S2SV_blank>was<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>store<S2SV_blank>or<S2SV_blank>object."" ; case CRYPT_E_DELETED_PREV : return ""The<S2SV_blank>previous<S2SV_blank>certificate<S2SV_blank>or<S2SV_blank>CRL<S2SV_blank>context<S2SV_blank>was<S2SV_blank>deleted."" ; case CRYPT_E_NO_MATCH : return ""Cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>requested<S2SV_blank>object."" ; case CRYPT_E_UNEXPECTED_MSG_TYPE : case CRYPT_E_NO_KEY_PROPERTY : case CRYPT_E_NO_DECRYPT_CERT : return ""Private<S2SV_blank>key<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>issue"" ; case CRYPT_E_BAD_MSG : return ""Not<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message."" ; case CRYPT_E_NO_SIGNER : return ""The<S2SV_blank>signed<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>a<S2SV_blank>signer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>signer<S2SV_blank>index."" ; case CRYPT_E_REVOKED : return ""The<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>revoked."" ; case CRYPT_E_NO_REVOCATION_DLL : case CRYPT_E_NO_REVOCATION_CHECK : case CRYPT_E_REVOCATION_OFFLINE : case CRYPT_E_NOT_IN_REVOCATION_DATABASE : return ""Cannot<S2SV_blank>check<S2SV_blank>certificate<S2SV_blank>revocation."" ; case CRYPT_E_INVALID_NUMERIC_STRING : case CRYPT_E_INVALID_PRINTABLE_STRING : case CRYPT_E_INVALID_IA5_STRING : case CRYPT_E_INVALID_X500_STRING : case CRYPT_E_NOT_CHAR_STRING : return ""Invalid<S2SV_blank>string."" ; case CRYPT_E_SECURITY_SETTINGS : return ""The<S2SV_blank>cryptographic<S2SV_blank>operation<S2SV_blank>failed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>a<S2SV_blank>local<S2SV_blank>security<S2SV_blank>option<S2SV_blank>setting."" ; case CRYPT_E_NO_VERIFY_USAGE_CHECK : case CRYPT_E_VERIFY_USAGE_OFFLINE : return ""Cannot<S2SV_blank>complete<S2SV_blank>usage<S2SV_blank>check."" ; case CRYPT_E_NO_TRUSTED_SIGNER :  return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ;  default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ; return error_string ; } }",if ( ( ( error_code >> 16 ) != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) return WindowsErrorString ( ) ;,2578
588,"buggy line: case CRYPT_E_NO_TRUSTED_SIGNER :  return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ;default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ;cwe id:CWE-494context: const char * WinPKIErrorString ( void ) { static char error_string [ 64 ] ; DWORD error_code = GetLastError ( ) ;  if ( ( error_code >> 16 ) != 0x8009 )  return WindowsErrorString ( ) ; switch ( error_code ) { case NTE_BAD_UID : return ""Bad<S2SV_blank>UID."" ; case CRYPT_E_MSG_ERROR : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>performing<S2SV_blank>an<S2SV_blank>operation<S2SV_blank>on<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message."" ; case CRYPT_E_UNKNOWN_ALGO : return ""Unknown<S2SV_blank>cryptographic<S2SV_blank>algorithm."" ; case CRYPT_E_INVALID_MSG_TYPE : return ""Invalid<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>type."" ; case CRYPT_E_HASH_VALUE : return ""The<S2SV_blank>hash<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct"" ; case CRYPT_E_ISSUER_SERIALNUMBER : return ""Invalid<S2SV_blank>issuer<S2SV_blank>and/or<S2SV_blank>serial<S2SV_blank>number."" ; case CRYPT_E_BAD_LEN : return ""The<S2SV_blank>length<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>data<S2SV_blank>was<S2SV_blank>insufficient."" ; case CRYPT_E_BAD_ENCODE : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>during<S2SV_blank>encode<S2SV_blank>or<S2SV_blank>decode<S2SV_blank>operation."" ; case CRYPT_E_FILE_ERROR : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>or<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file."" ; case CRYPT_E_NOT_FOUND : return ""Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property."" ; case CRYPT_E_EXISTS : return ""The<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property<S2SV_blank>already<S2SV_blank>exists."" ; case CRYPT_E_NO_PROVIDER : return ""No<S2SV_blank>provider<S2SV_blank>was<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>store<S2SV_blank>or<S2SV_blank>object."" ; case CRYPT_E_DELETED_PREV : return ""The<S2SV_blank>previous<S2SV_blank>certificate<S2SV_blank>or<S2SV_blank>CRL<S2SV_blank>context<S2SV_blank>was<S2SV_blank>deleted."" ; case CRYPT_E_NO_MATCH : return ""Cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>requested<S2SV_blank>object."" ; case CRYPT_E_UNEXPECTED_MSG_TYPE : case CRYPT_E_NO_KEY_PROPERTY : case CRYPT_E_NO_DECRYPT_CERT : return ""Private<S2SV_blank>key<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>issue"" ; case CRYPT_E_BAD_MSG : return ""Not<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message."" ; case CRYPT_E_NO_SIGNER : return ""The<S2SV_blank>signed<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>a<S2SV_blank>signer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>signer<S2SV_blank>index."" ; case CRYPT_E_REVOKED : return ""The<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>revoked."" ; case CRYPT_E_NO_REVOCATION_DLL : case CRYPT_E_NO_REVOCATION_CHECK : case CRYPT_E_REVOCATION_OFFLINE : case CRYPT_E_NOT_IN_REVOCATION_DATABASE : return ""Cannot<S2SV_blank>check<S2SV_blank>certificate<S2SV_blank>revocation."" ; case CRYPT_E_INVALID_NUMERIC_STRING : case CRYPT_E_INVALID_PRINTABLE_STRING : case CRYPT_E_INVALID_IA5_STRING : case CRYPT_E_INVALID_X500_STRING : case CRYPT_E_NOT_CHAR_STRING : return ""Invalid<S2SV_blank>string."" ; case CRYPT_E_SECURITY_SETTINGS : return ""The<S2SV_blank>cryptographic<S2SV_blank>operation<S2SV_blank>failed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>a<S2SV_blank>local<S2SV_blank>security<S2SV_blank>option<S2SV_blank>setting."" ; case CRYPT_E_NO_VERIFY_USAGE_CHECK : case CRYPT_E_VERIFY_USAGE_OFFLINE : return ""Cannot<S2SV_blank>complete<S2SV_blank>usage<S2SV_blank>check."" ; case CRYPT_E_NO_TRUSTED_SIGNER :  return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ;  default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ; return error_string ; } }","case CRYPT_E_NO_TRUSTED_SIGNER : return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ;case CERT_E_UNTRUSTEDROOT : return ""The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted."" ;case TRUST_E_NOSIGNATURE : return ""Not<S2SV_blank>digitally<S2SV_blank>signed."" ;case TRUST_E_EXPLICIT_DISTRUST : return ""One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."" ;default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ;",2578
589,"buggy line: if ( perf_event_overflow ( event , 1 , & data , regs ) )  x86_pmu_stop ( event , 0 ) ;cwe id:CWE-400context: static int x86_pmu_handle_irq ( struct pt_regs * regs ) { struct perf_sample_data data ; struct cpu_hw_events * cpuc ; struct perf_event * event ; int idx , handled = 0 ; u64 val ; perf_sample_data_init ( & data , 0 ) ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; apic_write ( APIC_LVTPC , APIC_DM_NMI ) ; for ( idx = 0 ; idx < x86_pmu . num_counters ; idx ++ ) { if ( ! test_bit ( idx , cpuc -> active_mask ) ) { if ( __test_and_clear_bit ( idx , cpuc -> running ) ) handled ++ ; continue ; } event = cpuc -> events [ idx ] ; val = x86_perf_event_update ( event ) ; if ( val & ( 1ULL << ( x86_pmu . cntval_bits - 1 ) ) ) continue ; handled ++ ; data . period = event -> hw . last_period ; if ( ! x86_perf_event_set_period ( event ) ) continue ;  if ( perf_event_overflow ( event , 1 , & data , regs ) )  x86_pmu_stop ( event , 0 ) ; } if ( handled ) inc_irq_stat ( apic_perf_irqs ) ; return handled ; }","if ( perf_event_overflow ( event , & data , regs ) ) x86_pmu_stop ( event , 0 ) ;",2579
590,"buggy line: cwe id:CWE-119context: int vp9_get_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) { int i ; InternalFrameBufferList * const int_fb_list = ( InternalFrameBufferList * ) cb_priv ; if ( int_fb_list == NULL ) return - 1 ; for ( i = 0 ; i < int_fb_list -> num_internal_frame_buffers ; ++ i ) { if ( ! int_fb_list -> int_fb [ i ] . in_use ) break ; } if ( i == int_fb_list -> num_internal_frame_buffers ) return - 1 ; if ( int_fb_list -> int_fb [ i ] . size < min_size ) { int_fb_list -> int_fb [ i ] . data = ( uint8_t * ) vpx_realloc ( int_fb_list -> int_fb [ i ] . data , min_size ) ; if ( ! int_fb_list -> int_fb [ i ] . data ) return - 1 ;  int_fb_list -> int_fb [ i ] . size = min_size ;  } fb -> data = int_fb_list -> int_fb [ i ] . data ; fb -> size = int_fb_list -> int_fb [ i ] . size ; int_fb_list -> int_fb [ i ] . in_use = 1 ; fb -> priv = & int_fb_list -> int_fb [ i ] ; return 0 ; }","memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ;",2580
591,"buggy line: int_fb_list -> int_fb [ i ] . size = min_size ;}cwe id:CWE-119context: int vp9_get_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) { int i ; InternalFrameBufferList * const int_fb_list = ( InternalFrameBufferList * ) cb_priv ; if ( int_fb_list == NULL ) return - 1 ; for ( i = 0 ; i < int_fb_list -> num_internal_frame_buffers ; ++ i ) { if ( ! int_fb_list -> int_fb [ i ] . in_use ) break ; } if ( i == int_fb_list -> num_internal_frame_buffers ) return - 1 ; if ( int_fb_list -> int_fb [ i ] . size < min_size ) { int_fb_list -> int_fb [ i ] . data = ( uint8_t * ) vpx_realloc ( int_fb_list -> int_fb [ i ] . data , min_size ) ; if ( ! int_fb_list -> int_fb [ i ] . data ) return - 1 ;  int_fb_list -> int_fb [ i ] . size = min_size ;  } fb -> data = int_fb_list -> int_fb [ i ] . data ; fb -> size = int_fb_list -> int_fb [ i ] . size ; int_fb_list -> int_fb [ i ] . in_use = 1 ; fb -> priv = & int_fb_list -> int_fb [ i ] ; return 0 ; }",int_fb_list -> int_fb [ i ] . size = min_size ;},2580
592,"buggy line: box -> info = boxinfo ;box -> ops = & boxinfo -> ops ;if ( extlen > 0xffffffffUL ) {jas_eprintf ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\\extlen = 0xffffffffUL ;}box -> len = extlen ;box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ;}else {box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ;}if ( box -> len != 0 && box -> len < 8 ) {goto error ;}dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ;if ( dataflag ) {if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) {goto error ;}if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) {box -> ops = & jp2_boxinfo_unk . ops ;jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\goto error ;}jas_stream_rewind ( tmpstream ) ;if ( box -> ops -> getdata ) {cwe id:CWE-476context: jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ;  box -> info = boxinfo ;  box -> ops = & boxinfo -> ops ; box -> len = len ; JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ) ; if ( box -> len == 1 ) { if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n"" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) {  box -> ops = & jp2_boxinfo_unk . ops ;  jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; }  jas_stream_rewind ( tmpstream ) ;  if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( ""cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }","box -> info = boxinfo ;box -> ops = & boxinfo -> ops ;jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\jas_stream_rewind ( tmpstream ) ;box -> ops = & boxinfo -> ops ;if ( box -> ops -> getdata ) {",2581
593,"buggy line: __evtchn_fifo_handle_events ( cpu , true ) ;return 0 ;cwe id:CWE-400context: static int evtchn_fifo_percpu_deinit ( unsigned int cpu ) {  __evtchn_fifo_handle_events ( cpu , true ) ;  return 0 ; }","__evtchn_fifo_handle_events ( cpu , NULL ) ;return 0 ;",2582
594,"buggy line: ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ;if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;return - 1 ;}cwe id:CWE-310context: int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {  ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;  return - 1 ; } EVP_MD_CTX_init ( & ctx ) ; if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } } inl = ASN1_item_i2d ( asn , & buf_in , it ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } ret = EVP_DigestVerifyUpdate ( & ctx , buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_DigestVerifyFinal ( & ctx , signature -> data , ( size_t ) signature -> length ) <= 0 ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }","ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;",2583
595,"buggy line: l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;if  ( ! l_current_pi -> include ) {cwe id:CWE-125context: opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ;  l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;   if  ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }","l_current_pi -> include = 00 ;if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}if ( ! l_current_pi -> include ) {",2584
596,"buggy line: if ( c == EOF ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}file = ( FILE * ) NULL ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;}length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ;( void ) length ;filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ;for ( i = 0 ;i < ( ssize_t ) filesize ;i ++ ) {c = ReadBlobByte ( pwp_image ) ;if ( c == EOF ) break ;( void ) fputc ( c , file ) ;}cwe id:CWE-20context: static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] ; FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MagickPathExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } pwp_image = image ; memset ( magick , 0 , sizeof ( magick ) ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , ""SFW95"" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""sfw:%s"" , filename ) ; for ( ; ; ) { ( void ) memset ( magick , 0 , sizeof ( magick ) ) ; for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) == 0 ) break ; } if ( c == EOF ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; if ( c == EOF ) break ;  ( void ) fputc ( c , file ) ;  } ( void ) fclose ( file ) ; if ( c == EOF ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MagickPathExtent , ""slide_%02ld.sfw"" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( image != ( Image * ) NULL ) { if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""UnexpectedEndOfFile"" , ""`%s\':<S2SV_blank>%s"" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; } return ( GetFirstImageInList ( image ) ) ; }","if ( fputc ( c , file ) != c ) break ;",2585
597,"buggy line: if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {ret = key -> type -> instantiate ( key , prep ) ;set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ;if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;cwe id:CWE-20context: static int __key_instantiate_and_link ( struct key * key , struct key_preparsed_payload * prep , struct key * keyring , struct key * authkey , struct assoc_array_edit * * _edit ) { int ret , awaken ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; mutex_lock ( & key_construction_mutex ) ;  if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {  ret = key -> type -> instantiate ( key , prep ) ; if ( ret == 0 ) { atomic_inc ( & key -> user -> nikeys ) ;  set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ;  if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; if ( keyring ) { if ( test_bit ( KEY_FLAG_KEEP , & keyring -> flags ) ) set_bit ( KEY_FLAG_KEEP , & key -> flags ) ; __key_link ( key , _edit ) ; } if ( authkey ) key_revoke ( authkey ) ; if ( prep -> expiry != TIME_T_MAX ) { key -> expiry = prep -> expiry ; key_schedule_gc ( prep -> expiry + key_gc_delay ) ; } } } mutex_unlock ( & key_construction_mutex ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret ; }","if ( key -> state == KEY_IS_UNINSTANTIATED ) {ret = key -> type -> instantiate ( key , prep ) ;mark_key_instantiated ( key , 0 ) ;if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;",2586
598,"buggy line: const int sb_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ;int min_log2 = 0 , max_log2 = 0 ;while ( ( sb_cols >> max_log2 ) >= MIN_TILE_WIDTH_B64 ) ++ max_log2 ;-- max_log2 ;if ( max_log2 < 0 ) max_log2 = 0 ;while ( ( MAX_TILE_WIDTH_B64 << min_log2 ) < sb_cols ) ++ min_log2 ;assert ( min_log2 <= max_log2 ) ;* min_log2_tile_cols = min_log2 ;* max_log2_tile_cols = max_log2 ;}cwe id:CWE-119context: void vp9_get_tile_n_bits ( int mi_cols , int * min_log2_tile_cols , int * max_log2_tile_cols ) {  const int sb_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ;   int min_log2 = 0 , max_log2 = 0 ;  while ( ( sb_cols >> max_log2 ) >= MIN_TILE_WIDTH_B64 ) ++ max_log2 ; -- max_log2 ; if ( max_log2 < 0 ) max_log2 = 0 ; while ( ( MAX_TILE_WIDTH_B64 << min_log2 ) < sb_cols ) ++ min_log2 ; assert ( min_log2 <= max_log2 ) ;  * min_log2_tile_cols = min_log2 ;   * max_log2_tile_cols = max_log2 ;  }",const int sb64_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ;* min_log2_tile_cols = min_log2 ;* max_log2_tile_cols = get_max_log2_tile_cols ( sb64_cols ) ;assert ( * min_log2_tile_cols <= * max_log2_tile_cols ) ;},2587
599,"buggy line: if ( lf -> last_sharpness_level != lf -> sharpness_level ) {update_sharpness ( lfi , lf -> sharpness_level ) ;lf -> last_sharpness_level = lf -> sharpness_level ;}for ( seg_id = 0 ;seg_id < MAX_SEGMENTS ;seg_id ++ ) {int lvl_seg = default_filt_lvl ;if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) {const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ;lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ;vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ;}cwe id:CWE-119context: void vp9_loop_filter_frame_init ( VP9_COMMON * cm , int default_filt_lvl ) { int seg_id ; const int scale = 1 << ( default_filt_lvl >> 5 ) ; loop_filter_info_n * const lfi = & cm -> lf_info ; struct loopfilter * const lf = & cm -> lf ; const struct segmentation * const seg = & cm -> seg ; if ( lf -> last_sharpness_level != lf -> sharpness_level ) { update_sharpness ( lfi , lf -> sharpness_level ) ; lf -> last_sharpness_level = lf -> sharpness_level ; } for ( seg_id = 0 ; seg_id < MAX_SEGMENTS ; seg_id ++ ) { int lvl_seg = default_filt_lvl ;  if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) {   const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ;  lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ; } if ( ! lf -> mode_ref_delta_enabled ) {  vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ;  } else { int ref , mode ; const int intra_lvl = lvl_seg + lf -> ref_deltas [ INTRA_FRAME ] * scale ; lfi -> lvl [ seg_id ] [ INTRA_FRAME ] [ 0 ] = clamp ( intra_lvl , 0 , MAX_LOOP_FILTER ) ; for ( ref = LAST_FRAME ; ref < MAX_REF_FRAMES ; ++ ref ) { for ( mode = 0 ; mode < MAX_MODE_LF_DELTAS ; ++ mode ) { const int inter_lvl = lvl_seg + lf -> ref_deltas [ ref ] * scale + lf -> mode_deltas [ mode ] * scale ; lfi -> lvl [ seg_id ] [ ref ] [ mode ] = clamp ( inter_lvl , 0 , MAX_LOOP_FILTER ) ; } } } } }","if ( segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) {const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ;lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ;vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ;}",2588
600,"buggy line: dev_net_set ( dev , net ) ;dev -> rtnl_link_ops = & tun_link_ops ;cwe id:CWE-476context: static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = ""tun%d"" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = ""tap%d"" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ;  dev_net_set ( dev , net ) ;  dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , ""tun_set_iff\\n"" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }","err = dev_get_valid_name ( net , dev , name ) ;if ( err ) goto err_free_dev ;dev_net_set ( dev , net ) ;dev -> rtnl_link_ops = & tun_link_ops ;",2589
601,"buggy line: ctxt -> dst . type = OP_REG ;ctxt -> dst . addr . reg = & ctxt -> _eip ;ctxt -> dst . bytes = ctxt -> op_bytes ;rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;cwe id:CWE-000context: static int em_ret_near_imm ( struct x86_emulate_ctxt * ctxt ) { int rc ;  ctxt -> dst . type = OP_REG ;  ctxt -> dst . addr . reg = & ctxt -> _eip ; ctxt -> dst . bytes = ctxt -> op_bytes ;  rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;  if ( rc != X86EMUL_CONTINUE ) return rc ; rsp_increment ( ctxt , ctxt -> src . val ) ; return X86EMUL_CONTINUE ; }","unsigned long eip ;rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;rc = assign_eip_near ( ctxt , eip ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;",2590
602,"buggy line: BREAK_TO_DEBUGGER ( ) ;return NULL ;cwe id:CWE-401context: struct resource_pool * dce110_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc , struct hw_asic_id asic_id ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( num_virtual_links , dc , pool , asic_id ) ) return & pool -> base ;  BREAK_TO_DEBUGGER ( ) ;  return NULL ; }",kfree ( pool ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,2591
603,"buggy line: if ( size > INT_MAX )  size = INT_MAX ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;cwe id:CWE-264context: SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX )  size = INT_MAX ;  sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; iov . iov_len = size ; iov . iov_base = ubuf ; iov_iter_init ( & msg . msg_iter , READ , & iov , 1 , size ) ; msg . msg_name = addr ? ( struct sockaddr * ) & address : NULL ; msg . msg_namelen = 0 ; if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }","if ( size > INT_MAX ) size = INT_MAX ;if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;",2592
604,"buggy line: if ( attr >= 0 ) {xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ;cwe id:CWE-20context: static void _out_verify ( conn_t out , nad_t nad ) { int attr , ns ; jid_t from , to ; conn_t in ; char * rkey ; int valid ; attr = nad_find_attr ( nad , 0 , - 1 , ""from"" , NULL ) ; if ( attr < 0 || ( from = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , ""missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>from<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet"" ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , ""to"" , NULL ) ; if ( attr < 0 || ( to = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , ""missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>to<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet"" ) ; jid_free ( from ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , ""id"" , NULL ) ; if ( attr < 0 ) { log_debug ( ZONE , ""missing<S2SV_blank>id<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet"" ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } in = xhash_getx ( out -> s2s -> in , NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ; if ( in == NULL ) { log_debug ( ZONE , ""got<S2SV_blank>a<S2SV_blank>verify<S2SV_blank>for<S2SV_blank>incoming<S2SV_blank>conn<S2SV_blank>%.*s,<S2SV_blank>but<S2SV_blank>it<S2SV_blank>doesn\'t<S2SV_blank>exist,<S2SV_blank>dropping<S2SV_blank>the<S2SV_blank>packet"" , NAD_AVAL_L ( nad , attr ) , NAD_AVAL ( nad , attr ) ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } rkey = s2s_route_key ( NULL , to -> domain , from -> domain ) ; attr = nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) ;  if ( attr >= 0 ) {  xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ; log_write ( in -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>incoming<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , in -> fd -> fd , in -> ip , in -> port , rkey , ( in -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , in -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ; valid = 1 ; } else { log_write ( in -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>incoming<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>invalid"" , in -> fd -> fd , in -> ip , in -> port , rkey ) ; valid = 0 ; } free ( rkey ) ; nad_free ( nad ) ; -- out -> verify ; nad = nad_new ( ) ; ns = nad_add_namespace ( nad , uri_DIALBACK , ""db"" ) ; nad_append_elem ( nad , ns , ""result"" , 0 ) ; nad_append_attr ( nad , - 1 , ""to"" , from -> domain ) ; nad_append_attr ( nad , - 1 , ""from"" , to -> domain ) ; nad_append_attr ( nad , - 1 , ""type"" , valid ? ""valid"" : ""invalid"" ) ; sx_nad_write ( in -> s , nad ) ; if ( ! valid ) { sx_error ( in -> s , stream_err_INVALID_ID , ""dialback<S2SV_blank>negotiation<S2SV_blank>failed"" ) ; sx_close ( in -> s ) ; } jid_free ( from ) ; jid_free ( to ) ; }","if ( attr >= 0 && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS ) {xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ;",2593
605,"buggy line: n = r -> iov . iov_len / 512 ;if ( n ) {qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ;cwe id:CWE-119context: static void scsi_write_data ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; uint32_t n ; assert ( r -> req . aiocb == NULL ) ; if ( r -> req . cmd . mode != SCSI_XFER_TO_DEV ) { DPRINTF ( ""Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\n"" ) ; scsi_write_complete ( r , - EINVAL ) ; return ; }  n = r -> iov . iov_len / 512 ;  if ( n ) { if ( s -> tray_open ) { scsi_write_complete ( r , - ENOMEDIUM ) ; }  qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;  bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ; r -> req . aiocb = bdrv_aio_writev ( s -> bs , r -> sector , & r -> qiov , n , scsi_write_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_write_complete ( r , - ENOMEM ) ; } } else { scsi_write_complete ( r , 0 ) ; } }","n = r -> qiov . size / 512 ;if ( n ) {bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ;",2594
606,"buggy line: case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED : dev_replace -> srcdev = btrfs_find_device ( fs_info -> fs_devices ,  src_devid , NULL , NULL ) ;dev_replace -> tgtdev = btrfs_find_device ( fs_info -> fs_devices , BTRFS_DEV_REPLACE_DEVID ,  NULL , NULL ) ;if ( ! dev_replace -> srcdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) {cwe id:CWE-476context: int btrfs_init_dev_replace ( struct btrfs_fs_info * fs_info ) { struct btrfs_key key ; struct btrfs_root * dev_root = fs_info -> dev_root ; struct btrfs_dev_replace * dev_replace = & fs_info -> dev_replace ; struct extent_buffer * eb ; int slot ; int ret = 0 ; struct btrfs_path * path = NULL ; int item_size ; struct btrfs_dev_replace_item * ptr ; u64 src_devid ; path = btrfs_alloc_path ( ) ; if ( ! path ) { ret = - ENOMEM ; goto out ; } key . objectid = 0 ; key . type = BTRFS_DEV_REPLACE_KEY ; key . offset = 0 ; ret = btrfs_search_slot ( NULL , dev_root , & key , path , 0 , 0 ) ; if ( ret ) { no_valid_dev_replace_entry_found : ret = 0 ; dev_replace -> replace_state = BTRFS_DEV_REPLACE_ITEM_STATE_NEVER_STARTED ; dev_replace -> cont_reading_from_srcdev_mode = BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_ALWAYS ; dev_replace -> time_started = 0 ; dev_replace -> time_stopped = 0 ; atomic64_set ( & dev_replace -> num_write_errors , 0 ) ; atomic64_set ( & dev_replace -> num_uncorrectable_read_errors , 0 ) ; dev_replace -> cursor_left = 0 ; dev_replace -> committed_cursor_left = 0 ; dev_replace -> cursor_left_last_write_of_item = 0 ; dev_replace -> cursor_right = 0 ; dev_replace -> srcdev = NULL ; dev_replace -> tgtdev = NULL ; dev_replace -> is_valid = 0 ; dev_replace -> item_needs_writeback = 0 ; goto out ; } slot = path -> slots [ 0 ] ; eb = path -> nodes [ 0 ] ; item_size = btrfs_item_size_nr ( eb , slot ) ; ptr = btrfs_item_ptr ( eb , slot , struct btrfs_dev_replace_item ) ; if ( item_size != sizeof ( struct btrfs_dev_replace_item ) ) { btrfs_warn ( fs_info , ""dev_replace<S2SV_blank>entry<S2SV_blank>found<S2SV_blank>has<S2SV_blank>unexpected<S2SV_blank>size,<S2SV_blank>ignore<S2SV_blank>entry"" ) ; goto no_valid_dev_replace_entry_found ; } src_devid = btrfs_dev_replace_src_devid ( eb , ptr ) ; dev_replace -> cont_reading_from_srcdev_mode = btrfs_dev_replace_cont_reading_from_srcdev_mode ( eb , ptr ) ; dev_replace -> replace_state = btrfs_dev_replace_replace_state ( eb , ptr ) ; dev_replace -> time_started = btrfs_dev_replace_time_started ( eb , ptr ) ; dev_replace -> time_stopped = btrfs_dev_replace_time_stopped ( eb , ptr ) ; atomic64_set ( & dev_replace -> num_write_errors , btrfs_dev_replace_num_write_errors ( eb , ptr ) ) ; atomic64_set ( & dev_replace -> num_uncorrectable_read_errors , btrfs_dev_replace_num_uncorrectable_read_errors ( eb , ptr ) ) ; dev_replace -> cursor_left = btrfs_dev_replace_cursor_left ( eb , ptr ) ; dev_replace -> committed_cursor_left = dev_replace -> cursor_left ; dev_replace -> cursor_left_last_write_of_item = dev_replace -> cursor_left ; dev_replace -> cursor_right = btrfs_dev_replace_cursor_right ( eb , ptr ) ; dev_replace -> is_valid = 1 ; dev_replace -> item_needs_writeback = 0 ; switch ( dev_replace -> replace_state ) { case BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED : case BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED : dev_replace -> srcdev = NULL ; dev_replace -> tgtdev = NULL ; break ; case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED : dev_replace -> srcdev = btrfs_find_device ( fs_info -> fs_devices ,  src_devid , NULL , NULL ) ;  dev_replace -> tgtdev = btrfs_find_device ( fs_info -> fs_devices , BTRFS_DEV_REPLACE_DEVID ,  NULL , NULL ) ;  if ( ! dev_replace -> srcdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) { ret = - EIO ; btrfs_warn ( fs_info , ""cannot<S2SV_blank>mount<S2SV_blank>because<S2SV_blank>device<S2SV_blank>replace<S2SV_blank>operation<S2SV_blank>is<S2SV_blank>ongoing<S2SV_blank>and"" ) ; btrfs_warn ( fs_info , ""srcdev<S2SV_blank>(devid<S2SV_blank>%llu)<S2SV_blank>is<S2SV_blank>missing,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>\'btrfs<S2SV_blank>dev<S2SV_blank>scan\'?"" , src_devid ) ; } if ( ! dev_replace -> tgtdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) { ret = - EIO ; btrfs_warn ( fs_info , ""cannot<S2SV_blank>mount<S2SV_blank>because<S2SV_blank>device<S2SV_blank>replace<S2SV_blank>operation<S2SV_blank>is<S2SV_blank>ongoing<S2SV_blank>and"" ) ; btrfs_warn ( fs_info , ""tgtdev<S2SV_blank>(devid<S2SV_blank>%llu)<S2SV_blank>is<S2SV_blank>missing,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>\'btrfs<S2SV_blank>dev<S2SV_blank>scan\'?"" , BTRFS_DEV_REPLACE_DEVID ) ; } if ( dev_replace -> tgtdev ) { if ( dev_replace -> srcdev ) { dev_replace -> tgtdev -> total_bytes = dev_replace -> srcdev -> total_bytes ; dev_replace -> tgtdev -> disk_total_bytes = dev_replace -> srcdev -> disk_total_bytes ; dev_replace -> tgtdev -> commit_total_bytes = dev_replace -> srcdev -> commit_total_bytes ; dev_replace -> tgtdev -> bytes_used = dev_replace -> srcdev -> bytes_used ; dev_replace -> tgtdev -> commit_bytes_used = dev_replace -> srcdev -> commit_bytes_used ; } set_bit ( BTRFS_DEV_STATE_REPLACE_TGT , & dev_replace -> tgtdev -> dev_state ) ; WARN_ON ( fs_info -> fs_devices -> rw_devices == 0 ) ; dev_replace -> tgtdev -> io_width = fs_info -> sectorsize ; dev_replace -> tgtdev -> io_align = fs_info -> sectorsize ; dev_replace -> tgtdev -> sector_size = fs_info -> sectorsize ; dev_replace -> tgtdev -> fs_info = fs_info ; set_bit ( BTRFS_DEV_STATE_IN_FS_METADATA , & dev_replace -> tgtdev -> dev_state ) ; } break ; } out : btrfs_free_path ( path ) ; return ret ; }","case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED : dev_replace -> srcdev = btrfs_find_device ( fs_info -> fs_devices , src_devid , NULL , NULL , true ) ;dev_replace -> tgtdev = btrfs_find_device ( fs_info -> fs_devices , BTRFS_DEV_REPLACE_DEVID , NULL , NULL , true ) ;if ( ! dev_replace -> srcdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) {",2595
607,"buggy line: cwe id:CWE-310context: int ssl3_get_key_exchange ( SSL * s ) { # ifndef OPENSSL_NO_RSA unsigned char * q , md_buf [ EVP_MAX_MD_SIZE * 2 ] ; # endif EVP_MD_CTX md_ctx ; unsigned char * param , * p ; int al , j , ok ; long i , param_len , n , alg_k , alg_a ; EVP_PKEY * pkey = NULL ; const EVP_MD * md = NULL ; # ifndef OPENSSL_NO_RSA RSA * rsa = NULL ; # endif # ifndef OPENSSL_NO_DH DH * dh = NULL ; # endif # ifndef OPENSSL_NO_ECDH EC_KEY * ecdh = NULL ; BN_CTX * bn_ctx = NULL ; EC_POINT * srvr_ecpoint = NULL ; int curve_nid = 0 ; int encoded_pt_len = 0 ; # endif EVP_MD_CTX_init ( & md_ctx ) ; n = s -> method -> ssl_get_message ( s , SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; if ( s -> s3 -> tmp . message_type != SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } # ifndef OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = s -> s3 -> tmp . new_cipher -> algorithm_auth ; al = SSL_AD_DECODE_ERROR ; # ifndef OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { char tmp_id_hint [ PSK_MAX_IDENTITY_LEN + 1 ] ; param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > PSK_MAX_IDENTITY_LEN ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_DATA_LENGTH_TOO_LONG ) ; goto f_err ; } if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH ) ; goto f_err ; } param_len += i ; memcpy ( tmp_id_hint , p , i ) ; memset ( tmp_id_hint + i , 0 , PSK_MAX_IDENTITY_LEN + 1 - i ) ; if ( s -> ctx -> psk_identity_hint != NULL ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = BUF_strdup ( tmp_id_hint ) ; if ( s -> ctx -> psk_identity_hint == NULL ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } p += i ; n -= param_len ; } else # endif # ifndef OPENSSL_NO_SRP if ( alg_k & SSL_kSRP ) { param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_N_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . N = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_G_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . g = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 1 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 1 ; i = ( unsigned int ) ( p [ 0 ] ) ; p ++ ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_S_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . s = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_B_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . B = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( ! srp_verify_server_param ( s , & al ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_PARAMETERS ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DSA else if ( alg_a & SSL_aDSS ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_DSA_SIGN ] . x509 ) ; # endif } else # endif # ifndef OPENSSL_NO_RSA if ( alg_k & SSL_kRSA ) {  if ( ( rsa = RSA_new ( ) ) == NULL )  { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_MODULUS_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( rsa -> n = BN_bin2bn ( p , i , rsa -> n ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_E_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( rsa -> e = BN_bin2bn ( p , i , rsa -> e ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; else { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } s -> session -> sess_cert -> peer_rsa_tmp = rsa ; rsa = NULL ; } # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DH else if ( alg_k & SSL_kDHE ) { if ( ( dh = DH_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_DH_LIB ) ; goto err ; } param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_P_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> p = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_G_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> g = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_PUB_KEY_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> pub_key = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( ! ssl_security ( s , SSL_SECOP_TMP_DH , DH_security_bits ( dh ) , 0 , dh ) ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_DH_KEY_TOO_SMALL ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DSA else if ( alg_a & SSL_aDSS ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_DSA_SIGN ] . x509 ) ; # endif s -> session -> sess_cert -> peer_dh_tmp = dh ; dh = NULL ; } else if ( ( alg_k & SSL_kDHr ) || ( alg_k & SSL_kDHd ) ) { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER ) ; goto f_err ; } # endif # ifndef OPENSSL_NO_ECDH else if ( alg_k & SSL_kECDHE ) { EC_GROUP * ngroup ; const EC_GROUP * group ; if ( ( ecdh = EC_KEY_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } param_len = 4 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } if ( ! tls1_check_curve ( s , p , 3 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_WRONG_CURVE ) ; goto f_err ; } if ( ( curve_nid = tls1_ec_curve_id2nid ( * ( p + 2 ) ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS ) ; goto f_err ; } ngroup = EC_GROUP_new_by_curve_name ( curve_nid ) ; if ( ngroup == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_EC_LIB ) ; goto err ; } if ( EC_KEY_set_group ( ecdh , ngroup ) == 0 ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_EC_LIB ) ; goto err ; } EC_GROUP_free ( ngroup ) ; group = EC_KEY_get0_group ( ecdh ) ; if ( SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) && ( EC_GROUP_get_degree ( group ) > 163 ) ) { al = SSL_AD_EXPORT_RESTRICTION ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER ) ; goto f_err ; } p += 3 ; if ( ( ( srvr_ecpoint = EC_POINT_new ( group ) ) == NULL ) || ( ( bn_ctx = BN_CTX_new ( ) ) == NULL ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } encoded_pt_len = * p ; p += 1 ; if ( ( encoded_pt_len > n - param_len ) || ( EC_POINT_oct2point ( group , srvr_ecpoint , p , encoded_pt_len , bn_ctx ) == 0 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_ECPOINT ) ; goto f_err ; } param_len += encoded_pt_len ; n -= param_len ; p += encoded_pt_len ; if ( 0 ) ; # ifndef OPENSSL_NO_RSA else if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # endif # ifndef OPENSSL_NO_ECDSA else if ( alg_a & SSL_aECDSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_ECC ] . x509 ) ; # endif EC_KEY_set_public_key ( ecdh , srvr_ecpoint ) ; s -> session -> sess_cert -> peer_ecdh_tmp = ecdh ; ecdh = NULL ; BN_CTX_free ( bn_ctx ) ; bn_ctx = NULL ; EC_POINT_free ( srvr_ecpoint ) ; srvr_ecpoint = NULL ; } else if ( alg_k ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } # endif if ( pkey != NULL ) { if ( SSL_USE_SIGALGS ( s ) ) { int rv ; if ( 2 > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } rv = tls12_check_peer_sigalg ( & md , s , p , pkey ) ; if ( rv == - 1 ) goto err ; else if ( rv == 0 ) { goto f_err ; } # ifdef SSL_DEBUG fprintf ( stderr , ""USING<S2SV_blank>TLSv1.2<S2SV_blank>HASH<S2SV_blank>%s\\n"" , EVP_MD_name ( md ) ) ; # endif p += 2 ; n -= 2 ; } else md = EVP_sha1 ( ) ; if ( 2 > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; n -= 2 ; j = EVP_PKEY_size ( pkey ) ; if ( ( i != n ) || ( n > j ) || ( n <= 0 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_WRONG_SIGNATURE_LENGTH ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( pkey -> type == EVP_PKEY_RSA && ! SSL_USE_SIGALGS ( s ) ) { int num ; unsigned int size ; j = 0 ; q = md_buf ; for ( num = 2 ; num > 0 ; num -- ) { EVP_MD_CTX_set_flags ( & md_ctx , EVP_MD_CTX_FLAG_NON_FIPS_ALLOW ) ; EVP_DigestInit_ex ( & md_ctx , ( num == 2 ) ? s -> ctx -> md5 : s -> ctx -> sha1 , NULL ) ; EVP_DigestUpdate ( & md_ctx , & ( s -> s3 -> client_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_DigestUpdate ( & md_ctx , & ( s -> s3 -> server_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_DigestUpdate ( & md_ctx , param , param_len ) ; EVP_DigestFinal_ex ( & md_ctx , q , & size ) ; q += size ; j += size ; } i = RSA_verify ( NID_md5_sha1 , md_buf , j , p , n , pkey -> pkey . rsa ) ; if ( i < 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_DECRYPT ) ; goto f_err ; } if ( i == 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } else # endif { EVP_VerifyInit_ex ( & md_ctx , md , NULL ) ; EVP_VerifyUpdate ( & md_ctx , & ( s -> s3 -> client_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_VerifyUpdate ( & md_ctx , & ( s -> s3 -> server_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_VerifyUpdate ( & md_ctx , param , param_len ) ; if ( EVP_VerifyFinal ( & md_ctx , p , ( int ) n , pkey ) <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } } else { if ( ! ( alg_a & ( SSL_aNULL | SSL_aSRP ) ) && ! ( alg_k & SSL_kPSK ) ) { if ( ssl3_check_cert_and_algorithm ( s ) ) SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ( n != 0 ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_EXTRA_DATA_IN_MESSAGE ) ; goto f_err ; } } EVP_PKEY_free ( pkey ) ; EVP_MD_CTX_cleanup ( & md_ctx ) ; return ( 1 ) ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : EVP_PKEY_free ( pkey ) ; # ifndef OPENSSL_NO_RSA if ( rsa != NULL ) RSA_free ( rsa ) ; # endif # ifndef OPENSSL_NO_DH if ( dh != NULL ) DH_free ( dh ) ; # endif # ifndef OPENSSL_NO_ECDH BN_CTX_free ( bn_ctx ) ; EC_POINT_free ( srvr_ecpoint ) ; if ( ecdh != NULL ) EC_KEY_free ( ecdh ) ; # endif EVP_MD_CTX_cleanup ( & md_ctx ) ; return ( - 1 ) ; }","if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) {al = SSL_AD_UNEXPECTED_MESSAGE ;SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ;goto f_err ;}",2596
608,"buggy line: if ( ( rsa = RSA_new ( ) ) == NULL )  {cwe id:CWE-310context: int ssl3_get_key_exchange ( SSL * s ) { # ifndef OPENSSL_NO_RSA unsigned char * q , md_buf [ EVP_MAX_MD_SIZE * 2 ] ; # endif EVP_MD_CTX md_ctx ; unsigned char * param , * p ; int al , j , ok ; long i , param_len , n , alg_k , alg_a ; EVP_PKEY * pkey = NULL ; const EVP_MD * md = NULL ; # ifndef OPENSSL_NO_RSA RSA * rsa = NULL ; # endif # ifndef OPENSSL_NO_DH DH * dh = NULL ; # endif # ifndef OPENSSL_NO_ECDH EC_KEY * ecdh = NULL ; BN_CTX * bn_ctx = NULL ; EC_POINT * srvr_ecpoint = NULL ; int curve_nid = 0 ; int encoded_pt_len = 0 ; # endif EVP_MD_CTX_init ( & md_ctx ) ; n = s -> method -> ssl_get_message ( s , SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; if ( s -> s3 -> tmp . message_type != SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } # ifndef OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = s -> s3 -> tmp . new_cipher -> algorithm_auth ; al = SSL_AD_DECODE_ERROR ; # ifndef OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { char tmp_id_hint [ PSK_MAX_IDENTITY_LEN + 1 ] ; param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > PSK_MAX_IDENTITY_LEN ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_DATA_LENGTH_TOO_LONG ) ; goto f_err ; } if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH ) ; goto f_err ; } param_len += i ; memcpy ( tmp_id_hint , p , i ) ; memset ( tmp_id_hint + i , 0 , PSK_MAX_IDENTITY_LEN + 1 - i ) ; if ( s -> ctx -> psk_identity_hint != NULL ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = BUF_strdup ( tmp_id_hint ) ; if ( s -> ctx -> psk_identity_hint == NULL ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } p += i ; n -= param_len ; } else # endif # ifndef OPENSSL_NO_SRP if ( alg_k & SSL_kSRP ) { param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_N_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . N = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_G_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . g = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 1 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 1 ; i = ( unsigned int ) ( p [ 0 ] ) ; p ++ ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_S_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . s = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_B_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . B = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( ! srp_verify_server_param ( s , & al ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_PARAMETERS ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DSA else if ( alg_a & SSL_aDSS ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_DSA_SIGN ] . x509 ) ; # endif } else # endif # ifndef OPENSSL_NO_RSA if ( alg_k & SSL_kRSA ) {  if ( ( rsa = RSA_new ( ) ) == NULL )  { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_MODULUS_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( rsa -> n = BN_bin2bn ( p , i , rsa -> n ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_E_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( rsa -> e = BN_bin2bn ( p , i , rsa -> e ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; else { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } s -> session -> sess_cert -> peer_rsa_tmp = rsa ; rsa = NULL ; } # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DH else if ( alg_k & SSL_kDHE ) { if ( ( dh = DH_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_DH_LIB ) ; goto err ; } param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_P_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> p = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_G_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> g = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_PUB_KEY_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> pub_key = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( ! ssl_security ( s , SSL_SECOP_TMP_DH , DH_security_bits ( dh ) , 0 , dh ) ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_DH_KEY_TOO_SMALL ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DSA else if ( alg_a & SSL_aDSS ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_DSA_SIGN ] . x509 ) ; # endif s -> session -> sess_cert -> peer_dh_tmp = dh ; dh = NULL ; } else if ( ( alg_k & SSL_kDHr ) || ( alg_k & SSL_kDHd ) ) { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER ) ; goto f_err ; } # endif # ifndef OPENSSL_NO_ECDH else if ( alg_k & SSL_kECDHE ) { EC_GROUP * ngroup ; const EC_GROUP * group ; if ( ( ecdh = EC_KEY_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } param_len = 4 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } if ( ! tls1_check_curve ( s , p , 3 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_WRONG_CURVE ) ; goto f_err ; } if ( ( curve_nid = tls1_ec_curve_id2nid ( * ( p + 2 ) ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS ) ; goto f_err ; } ngroup = EC_GROUP_new_by_curve_name ( curve_nid ) ; if ( ngroup == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_EC_LIB ) ; goto err ; } if ( EC_KEY_set_group ( ecdh , ngroup ) == 0 ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_EC_LIB ) ; goto err ; } EC_GROUP_free ( ngroup ) ; group = EC_KEY_get0_group ( ecdh ) ; if ( SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) && ( EC_GROUP_get_degree ( group ) > 163 ) ) { al = SSL_AD_EXPORT_RESTRICTION ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER ) ; goto f_err ; } p += 3 ; if ( ( ( srvr_ecpoint = EC_POINT_new ( group ) ) == NULL ) || ( ( bn_ctx = BN_CTX_new ( ) ) == NULL ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } encoded_pt_len = * p ; p += 1 ; if ( ( encoded_pt_len > n - param_len ) || ( EC_POINT_oct2point ( group , srvr_ecpoint , p , encoded_pt_len , bn_ctx ) == 0 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_ECPOINT ) ; goto f_err ; } param_len += encoded_pt_len ; n -= param_len ; p += encoded_pt_len ; if ( 0 ) ; # ifndef OPENSSL_NO_RSA else if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # endif # ifndef OPENSSL_NO_ECDSA else if ( alg_a & SSL_aECDSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_ECC ] . x509 ) ; # endif EC_KEY_set_public_key ( ecdh , srvr_ecpoint ) ; s -> session -> sess_cert -> peer_ecdh_tmp = ecdh ; ecdh = NULL ; BN_CTX_free ( bn_ctx ) ; bn_ctx = NULL ; EC_POINT_free ( srvr_ecpoint ) ; srvr_ecpoint = NULL ; } else if ( alg_k ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } # endif if ( pkey != NULL ) { if ( SSL_USE_SIGALGS ( s ) ) { int rv ; if ( 2 > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } rv = tls12_check_peer_sigalg ( & md , s , p , pkey ) ; if ( rv == - 1 ) goto err ; else if ( rv == 0 ) { goto f_err ; } # ifdef SSL_DEBUG fprintf ( stderr , ""USING<S2SV_blank>TLSv1.2<S2SV_blank>HASH<S2SV_blank>%s\\n"" , EVP_MD_name ( md ) ) ; # endif p += 2 ; n -= 2 ; } else md = EVP_sha1 ( ) ; if ( 2 > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; n -= 2 ; j = EVP_PKEY_size ( pkey ) ; if ( ( i != n ) || ( n > j ) || ( n <= 0 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_WRONG_SIGNATURE_LENGTH ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( pkey -> type == EVP_PKEY_RSA && ! SSL_USE_SIGALGS ( s ) ) { int num ; unsigned int size ; j = 0 ; q = md_buf ; for ( num = 2 ; num > 0 ; num -- ) { EVP_MD_CTX_set_flags ( & md_ctx , EVP_MD_CTX_FLAG_NON_FIPS_ALLOW ) ; EVP_DigestInit_ex ( & md_ctx , ( num == 2 ) ? s -> ctx -> md5 : s -> ctx -> sha1 , NULL ) ; EVP_DigestUpdate ( & md_ctx , & ( s -> s3 -> client_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_DigestUpdate ( & md_ctx , & ( s -> s3 -> server_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_DigestUpdate ( & md_ctx , param , param_len ) ; EVP_DigestFinal_ex ( & md_ctx , q , & size ) ; q += size ; j += size ; } i = RSA_verify ( NID_md5_sha1 , md_buf , j , p , n , pkey -> pkey . rsa ) ; if ( i < 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_DECRYPT ) ; goto f_err ; } if ( i == 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } else # endif { EVP_VerifyInit_ex ( & md_ctx , md , NULL ) ; EVP_VerifyUpdate ( & md_ctx , & ( s -> s3 -> client_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_VerifyUpdate ( & md_ctx , & ( s -> s3 -> server_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_VerifyUpdate ( & md_ctx , param , param_len ) ; if ( EVP_VerifyFinal ( & md_ctx , p , ( int ) n , pkey ) <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } } else { if ( ! ( alg_a & ( SSL_aNULL | SSL_aSRP ) ) && ! ( alg_k & SSL_kPSK ) ) { if ( ssl3_check_cert_and_algorithm ( s ) ) SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ( n != 0 ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_EXTRA_DATA_IN_MESSAGE ) ; goto f_err ; } } EVP_PKEY_free ( pkey ) ; EVP_MD_CTX_cleanup ( & md_ctx ) ; return ( 1 ) ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : EVP_PKEY_free ( pkey ) ; # ifndef OPENSSL_NO_RSA if ( rsa != NULL ) RSA_free ( rsa ) ; # endif # ifndef OPENSSL_NO_DH if ( dh != NULL ) DH_free ( dh ) ; # endif # ifndef OPENSSL_NO_ECDH BN_CTX_free ( bn_ctx ) ; EC_POINT_free ( srvr_ecpoint ) ; if ( ecdh != NULL ) EC_KEY_free ( ecdh ) ; # endif EVP_MD_CTX_cleanup ( & md_ctx ) ; return ( - 1 ) ; }",if ( ( rsa = RSA_new ( ) ) == NULL ) {,2596
609,"buggy line: if ( header_len > LEVEL_3_MAX_HEADER_LEN ) {return 0 ;cwe id:CWE-190context: static int decode_level3_header ( LHAFileHeader * * header , LHAInputStream * stream ) { unsigned int header_len ; if ( lha_decode_uint16 ( & RAW_DATA ( header , 0 ) ) != 4 ) { return 0 ; } if ( ! extend_raw_data ( header , stream , LEVEL_3_HEADER_LEN - RAW_DATA_LEN ( header ) ) ) { return 0 ; } header_len = lha_decode_uint32 ( & RAW_DATA ( header , 24 ) ) ;  if ( header_len > LEVEL_3_MAX_HEADER_LEN ) {  return 0 ; } if ( ! extend_raw_data ( header , stream , header_len - RAW_DATA_LEN ( header ) ) ) { return 0 ; } memcpy ( ( * header ) -> compress_method , & RAW_DATA ( header , 2 ) , 5 ) ; ( * header ) -> compress_method [ 5 ] = '\\0' ; ( * header ) -> compressed_length = lha_decode_uint32 ( & RAW_DATA ( header , 7 ) ) ; ( * header ) -> length = lha_decode_uint32 ( & RAW_DATA ( header , 11 ) ) ; ( * header ) -> timestamp = lha_decode_uint32 ( & RAW_DATA ( header , 15 ) ) ; ( * header ) -> crc = lha_decode_uint16 ( & RAW_DATA ( header , 21 ) ) ; ( * header ) -> os_type = RAW_DATA ( header , 23 ) ; if ( ! decode_extended_headers ( header , 28 ) ) { return 0 ; } return 1 ; }",if ( header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header ) ) {return 0 ;,2597
610,buggy line: crypto_free_skcipher ( private ) ;}cwe id:CWE-476context: static void skcipher_release ( void * private ) {  crypto_free_skcipher ( private ) ;  },struct skcipher_tfm * tfm = private ;crypto_free_skcipher ( tfm -> skcipher ) ;kfree ( tfm ) ;},2598
611,"buggy line: static void restore_context ( VP9_COMP * cpi , int mi_row , int mi_col ,  ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;cwe id:CWE-119context:  static void restore_context ( VP9_COMP * cpi , int mi_row , int mi_col ,  ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; int p ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; for ( p = 0 ; p < MAX_MB_PLANE ; p ++ ) {  vpx_memcpy (  xd -> above_context [ p ] + ( ( mi_col * 2 ) >> xd -> plane [ p ] . subsampling_x ) , a + num_4x4_blocks_wide * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;  vpx_memcpy (  xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , l + num_4x4_blocks_high * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ; }  vpx_memcpy ( xd -> above_seg_context + mi_col , sa ,  sizeof ( * xd -> above_seg_context ) * mi_width ) ;  vpx_memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl ,  sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ; }","static void restore_context ( MACROBLOCK * const x , int mi_row , int mi_col , ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {MACROBLOCKD * const xd = & x -> e_mbd ;",2599
612,"buggy line: vpx_memcpy (  xd -> above_context [ p ] + ( ( mi_col * 2 ) >> xd -> plane [ p ] . subsampling_x ) , a + num_4x4_blocks_wide * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;vpx_memcpy (  xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , l + num_4x4_blocks_high * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;vpx_memcpy ( xd -> above_seg_context + mi_col , sa ,  sizeof ( * xd -> above_seg_context ) * mi_width ) ;vpx_memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl ,  sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;cwe id:CWE-119context:  static void restore_context ( VP9_COMP * cpi , int mi_row , int mi_col ,  ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; int p ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; for ( p = 0 ; p < MAX_MB_PLANE ; p ++ ) {  vpx_memcpy (  xd -> above_context [ p ] + ( ( mi_col * 2 ) >> xd -> plane [ p ] . subsampling_x ) , a + num_4x4_blocks_wide * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;  vpx_memcpy (  xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , l + num_4x4_blocks_high * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ; }  vpx_memcpy ( xd -> above_seg_context + mi_col , sa ,  sizeof ( * xd -> above_seg_context ) * mi_width ) ;  vpx_memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl ,  sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ; }","memcpy ( xd -> above_context [ p ] + ( ( mi_col * 2 ) >> xd -> plane [ p ] . subsampling_x ) , a + num_4x4_blocks_wide * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;memcpy ( xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , l + num_4x4_blocks_high * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;memcpy ( xd -> above_seg_context + mi_col , sa , sizeof ( * xd -> above_seg_context ) * mi_width ) ;memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl , sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;",2599
613,"buggy line: ND_TCHECK ( dp [ 0 ] ) ;cwe id:CWE-125context: void nfsreq_print_noaddr ( netdissect_options * ndo , register const u_char * bp , u_int length , register const u_char * bp2 ) { register const struct sunrpc_msg * rp ; register const uint32_t * dp ; nfs_type type ; int v3 ; uint32_t proc ; uint32_t access_flags ; struct nfsv3_sattr sa3 ; ND_PRINT ( ( ndo , ""%d"" , length ) ) ; nfserr = 0 ; rp = ( const struct sunrpc_msg * ) bp ; if ( ! xid_map_enter ( ndo , rp , bp2 ) ) goto trunc ; v3 = ( EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) == NFS_VER3 ) ; proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : case NFSPROC_SETATTR : case NFSPROC_READLINK : case NFSPROC_FSSTAT : case NFSPROC_FSINFO : case NFSPROC_PATHCONF : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefh ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_LOOKUP : case NFSPROC_CREATE : case NFSPROC_MKDIR : case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefhn ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_ACCESS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 0 ] ) ; access_flags = EXTRACT_32BITS ( & dp [ 0 ] ) ; if ( access_flags & ~ NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%04x"" , access_flags ) ) ; } else if ( ( access_flags & NFSV3ACCESS_FULL ) == NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_FULL"" ) ) ; } else { char separator = '<S2SV_blank>' ; if ( access_flags & NFSV3ACCESS_READ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_READ"" ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_LOOKUP ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_LOOKUP"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_MODIFY ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_MODIFY"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXTEND ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXTEND"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_DELETE ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_DELETE"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXECUTE ) ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXECUTE"" , separator ) ) ; } return ; } break ; case NFSPROC_READ : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_WRITE : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) {  ND_TCHECK ( dp [ 2 ] ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) {  dp += 3 ;  ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ; } } else { ND_TCHECK ( dp [ 3 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u<S2SV_blank>(%u)"" , EXTRACT_32BITS ( & dp [ 3 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_SYMLINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( v3 && ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; if ( parsefn ( ndo , dp ) == NULL ) break ; if ( v3 && ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_MKNOD : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( * dp ) ; type = ( nfs_type ) EXTRACT_32BITS ( dp ) ; dp ++ ; if ( ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( type2str , ""unk-ft<S2SV_blank>%d"" , type ) ) ) ; if ( ndo -> ndo_vflag && ( type == NFCHR || type == NFBLK ) ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%u"" , EXTRACT_32BITS ( & dp [ 0 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ; dp += 2 ; } if ( ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_RENAME : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>verf<S2SV_blank>%08x%08x"" , dp [ 2 ] , dp [ 3 ] ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%d"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_READDIRPLUS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 5 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>verf<S2SV_blank>%08x%08x"" , EXTRACT_32BITS ( & dp [ 5 ] ) , dp [ 2 ] , dp [ 3 ] ) ) ; } return ; } break ; case NFSPROC_COMMIT : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; return ; } break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }",ND_TCHECK ( dp [ 4 ] ) ;,2600
614,"buggy line: ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;dp += 3 ;ND_TCHECK ( dp [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ;cwe id:CWE-125context: void nfsreq_print_noaddr ( netdissect_options * ndo , register const u_char * bp , u_int length , register const u_char * bp2 ) { register const struct sunrpc_msg * rp ; register const uint32_t * dp ; nfs_type type ; int v3 ; uint32_t proc ; uint32_t access_flags ; struct nfsv3_sattr sa3 ; ND_PRINT ( ( ndo , ""%d"" , length ) ) ; nfserr = 0 ; rp = ( const struct sunrpc_msg * ) bp ; if ( ! xid_map_enter ( ndo , rp , bp2 ) ) goto trunc ; v3 = ( EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) == NFS_VER3 ) ; proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : case NFSPROC_SETATTR : case NFSPROC_READLINK : case NFSPROC_FSSTAT : case NFSPROC_FSINFO : case NFSPROC_PATHCONF : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefh ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_LOOKUP : case NFSPROC_CREATE : case NFSPROC_MKDIR : case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefhn ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_ACCESS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 0 ] ) ; access_flags = EXTRACT_32BITS ( & dp [ 0 ] ) ; if ( access_flags & ~ NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%04x"" , access_flags ) ) ; } else if ( ( access_flags & NFSV3ACCESS_FULL ) == NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_FULL"" ) ) ; } else { char separator = '<S2SV_blank>' ; if ( access_flags & NFSV3ACCESS_READ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_READ"" ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_LOOKUP ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_LOOKUP"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_MODIFY ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_MODIFY"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXTEND ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXTEND"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_DELETE ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_DELETE"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXECUTE ) ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXECUTE"" , separator ) ) ; } return ; } break ; case NFSPROC_READ : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_WRITE : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) {  ND_TCHECK ( dp [ 2 ] ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) {  dp += 3 ;  ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ; } } else { ND_TCHECK ( dp [ 3 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u<S2SV_blank>(%u)"" , EXTRACT_32BITS ( & dp [ 3 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_SYMLINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( v3 && ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; if ( parsefn ( ndo , dp ) == NULL ) break ; if ( v3 && ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_MKNOD : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( * dp ) ; type = ( nfs_type ) EXTRACT_32BITS ( dp ) ; dp ++ ; if ( ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( type2str , ""unk-ft<S2SV_blank>%d"" , type ) ) ) ; if ( ndo -> ndo_vflag && ( type == NFCHR || type == NFBLK ) ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%u"" , EXTRACT_32BITS ( & dp [ 0 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ; dp += 2 ; } if ( ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_RENAME : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>verf<S2SV_blank>%08x%08x"" , dp [ 2 ] , dp [ 3 ] ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%d"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_READDIRPLUS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 5 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>verf<S2SV_blank>%08x%08x"" , EXTRACT_32BITS ( & dp [ 5 ] ) , dp [ 2 ] , dp [ 3 ] ) ) ; } return ; } break ; case NFSPROC_COMMIT : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; return ; } break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] ) ) ) ) ;",2600
615,"buggy line: case BSD_AFNUM_ISO :  isoclns_print ( ndo , p , length , caplen ) ;break ;cwe id:CWE-125context: u_int null_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int length = h -> len ; u_int caplen = h -> caplen ; u_int family ; if ( caplen < NULL_HDRLEN ) { ND_PRINT ( ( ndo , ""[|null]"" ) ) ; return ( NULL_HDRLEN ) ; } memcpy ( ( char * ) & family , ( const char * ) p , sizeof ( family ) ) ; if ( ( family & 0xFFFF0000 ) != 0 ) family = SWAPLONG ( family ) ; if ( ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length ) ; length -= NULL_HDRLEN ; caplen -= NULL_HDRLEN ; p += NULL_HDRLEN ; switch ( family ) { case BSD_AFNUM_INET : ip_print ( ndo , p , length ) ; break ; case BSD_AFNUM_INET6_BSD : case BSD_AFNUM_INET6_FREEBSD : case BSD_AFNUM_INET6_DARWIN : ip6_print ( ndo , p , length ) ; break ; case BSD_AFNUM_ISO :  isoclns_print ( ndo , p , length , caplen ) ;  break ; case BSD_AFNUM_APPLETALK : atalk_print ( ndo , p , length ) ; break ; case BSD_AFNUM_IPX : ipx_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length + NULL_HDRLEN ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; } return ( NULL_HDRLEN ) ; }","case BSD_AFNUM_ISO : isoclns_print ( ndo , p , length , caplen ) ;break ;",2601
616,"buggy line: # endif  if ( name == NULL ) {spacePop ( ctxt ) ;cwe id:CWE-000context: void xmlParseElement ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; const xmlChar * prefix = NULL ; const xmlChar * URI = NULL ; xmlParserNodeInfo node_info ; int line , tlen ; xmlNodePtr ret ; int nsNr = ctxt -> nsNr ; if ( ( ( unsigned int ) ctxt -> nameNr > xmlParserMaxDepth ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) { xmlFatalErrMsgInt ( ctxt , XML_ERR_INTERNAL_ERROR , ""Excessive<S2SV_blank>depth<S2SV_blank>in<S2SV_blank>document:<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>XML_PARSE_HUGE<S2SV_blank>option\\n"" , xmlParserMaxDepth ) ; ctxt -> instate = XML_PARSER_EOF ; return ; } if ( ctxt -> record_info ) { node_info . begin_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . begin_line = ctxt -> input -> line ; } if ( ctxt -> spaceNr == 0 ) spacePush ( ctxt , - 1 ) ; else if ( * ctxt -> space == - 2 ) spacePush ( ctxt , - 1 ) ; else spacePush ( ctxt , * ctxt -> space ) ; line = ctxt -> input -> line ; # ifdef LIBXML_SAX1_ENABLED if ( ctxt -> sax2 ) # endif name = xmlParseStartTag2 ( ctxt , & prefix , & URI , & tlen ) ; # ifdef LIBXML_SAX1_ENABLED else name = xmlParseStartTag ( ctxt ) ; # endif  if ( name == NULL ) {  spacePop ( ctxt ) ; return ; } namePush ( ctxt , name ) ; ret = ctxt -> node ; # ifdef LIBXML_VALID_ENABLED if ( ctxt -> validate && ctxt -> wellFormed && ctxt -> myDoc && ctxt -> node && ( ctxt -> node == ctxt -> myDoc -> children ) ) ctxt -> valid &= xmlValidateRoot ( & ctxt -> vctxt , ctxt -> myDoc ) ; # endif if ( ( RAW == '/' ) && ( NXT ( 1 ) == '>' ) ) { SKIP ( 2 ) ; if ( ctxt -> sax2 ) { if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> endElementNs != NULL ) && ( ! ctxt -> disableSAX ) ) ctxt -> sax -> endElementNs ( ctxt -> userData , name , prefix , URI ) ; # ifdef LIBXML_SAX1_ENABLED } else { if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> endElement != NULL ) && ( ! ctxt -> disableSAX ) ) ctxt -> sax -> endElement ( ctxt -> userData , name ) ; # endif } namePop ( ctxt ) ; spacePop ( ctxt ) ; if ( nsNr != ctxt -> nsNr ) nsPop ( ctxt , ctxt -> nsNr - nsNr ) ; if ( ret != NULL && ctxt -> record_info ) { node_info . end_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . end_line = ctxt -> input -> line ; node_info . node = ret ; xmlParserAddNodeInfo ( ctxt , & node_info ) ; } return ; } if ( RAW == '>' ) { NEXT1 ; } else { xmlFatalErrMsgStrIntStr ( ctxt , XML_ERR_GT_REQUIRED , ""Couldn\'t<S2SV_blank>find<S2SV_blank>end<S2SV_blank>of<S2SV_blank>Start<S2SV_blank>Tag<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d\\n"" , name , line , NULL ) ; nodePop ( ctxt ) ; namePop ( ctxt ) ; spacePop ( ctxt ) ; if ( nsNr != ctxt -> nsNr ) nsPop ( ctxt , ctxt -> nsNr - nsNr ) ; if ( ret != NULL && ctxt -> record_info ) { node_info . end_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . end_line = ctxt -> input -> line ; node_info . node = ret ; xmlParserAddNodeInfo ( ctxt , & node_info ) ; } return ; } xmlParseContent ( ctxt ) ; if ( ! IS_BYTE_CHAR ( RAW ) ) { xmlFatalErrMsgStrIntStr ( ctxt , XML_ERR_TAG_NOT_FINISHED , ""Premature<S2SV_blank>end<S2SV_blank>of<S2SV_blank>data<S2SV_blank>in<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d\\n"" , name , line , NULL ) ; nodePop ( ctxt ) ; namePop ( ctxt ) ; spacePop ( ctxt ) ; if ( nsNr != ctxt -> nsNr ) nsPop ( ctxt , ctxt -> nsNr - nsNr ) ; return ; } if ( ctxt -> sax2 ) { xmlParseEndTag2 ( ctxt , prefix , URI , line , ctxt -> nsNr - nsNr , tlen ) ; namePop ( ctxt ) ; } # ifdef LIBXML_SAX1_ENABLED else xmlParseEndTag1 ( ctxt , line ) ; # endif if ( ret != NULL && ctxt -> record_info ) { node_info . end_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . end_line = ctxt -> input -> line ; node_info . node = ret ; xmlParserAddNodeInfo ( ctxt , & node_info ) ; } }",# endif if ( ctxt -> instate == XML_PARSER_EOF ) return ;if ( name == NULL ) {spacePop ( ctxt ) ;,2602
617,"buggy line: cwe id:CWE-119context: static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = SADB_X_SPDFLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;  pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;  return 0 ; }",hdr -> sadb_msg_reserved = 0 ;,2603
618,"buggy line: pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;cwe id:CWE-119context: static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = SADB_X_SPDFLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;  pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;  return 0 ; }","pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;",2603
619,"buggy line: void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\cwe id:CWE-119context:  void usage_exit ( ) {  fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\",2604
620,"buggy line: if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}cwe id:CWE-125context: opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; l_current_pi -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {  l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;  } if ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }","if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}",2605
621,buggy line: assert ( dev -> lintr . pin > 0 ) ;pthread_mutex_lock ( & dev -> lintr . lock ) ;cwe id:CWE-617context: void pci_lintr_assert ( struct pci_vdev * dev ) {  assert ( dev -> lintr . pin > 0 ) ;  pthread_mutex_lock ( & dev -> lintr . lock ) ; if ( dev -> lintr . state == IDLE ) { if ( pci_lintr_permitted ( dev ) ) { dev -> lintr . state = ASSERTED ; pci_irq_assert ( dev ) ; } else dev -> lintr . state = PENDING ; } pthread_mutex_unlock ( & dev -> lintr . lock ) ; },"if ( dev -> lintr . pin <= 0 ) {pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\\return ;}pthread_mutex_lock ( & dev -> lintr . lock ) ;",2606
622,"buggy line: ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;image = DestroyImage ( image ) ;cwe id:CWE-399context: static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox ""BoundingBox:"" # define BeginDocument ""BeginDocument:"" # define BeginXMPPacket ""<?xpacket<S2SV_blank>begin="" # define EndXMPPacket ""<?xpacket<S2SV_blank>end="" # define ICCProfile ""BeginICCProfile:"" # define CMYKCustomColor ""CMYKCustomColor:"" # define CMYKProcessColor ""CMYKProcessColor:"" # define DocumentMedia ""DocumentMedia:"" # define DocumentCustomColors ""DocumentCustomColors:"" # define DocumentProcessColors ""DocumentProcessColors:"" # define EndDocument ""EndDocument:"" # define HiResBoundingBox ""HiResBoundingBox:"" # define ImageData ""ImageData:"" # define PageBoundingBox ""PageBoundingBox:"" # define LanguageLevel ""LanguageLevel:"" # define PageMedia ""PageMedia:"" # define Pages ""Pages:"" # define PhotoshopProfile ""BeginPhotoshop:"" # define PostscriptLevel ""!PS-"" # define RenderPostscriptText ""<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>"" # define SpotColor ""+<S2SV_blank>"" char command [ MaxTextExtent ] , * density , filename [ MaxTextExtent ] , geometry [ MaxTextExtent ] , input_filename [ MaxTextExtent ] , message [ MaxTextExtent ] , * options , postscript_filename [ MaxTextExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length , priority ; ssize_t count ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> x_resolution == 0.0 ) || ( image -> y_resolution == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution . x = image -> x_resolution ; resolution . y = image -> y_resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) memset ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; priority = 0 ; columns = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; skip = MagickFalse ; pages = ( ~ 0UL ) ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , ""ps:Level"" , command + 4 ) ; if ( GlobExpression ( command , ""*EPSF-*"" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel ""<S2SV_blank>%lu"" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages ""<S2SV_blank>%lu"" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData ""<S2SV_blank>%lu<S2SV_blank>%lu"" , & columns , & rows ) ; length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , ""*Cyan*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Magenta*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Yellow*"" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MaxTextExtent ] , * value ; register char * p ; ( void ) FormatLocaleString ( property , MaxTextExtent , ""ps:SpotColor-%.20g"" , ( double ) ( spotcolor ++ ) ) ; for ( p = command ; * p != '\\0' ; p ++ ) if ( isspace ( ( int ) ( unsigned char ) * p ) != 0 ) break ; value = ConstantString ( p ) ; ( void ) SubstituteString ( & value , ""("" , """" ) ; ( void ) SubstituteString ( & value , "")"" , """" ) ; ( void ) StripString ( value ) ; if ( * value != '\\0' ) ( void ) SetImageProperty ( image , property , value ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = ( size_t ) i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%gx%g%+.15g%+.15g"" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , ""ps:HiResBoundingBox"" , geometry ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , ""eps:fit-page"" ) ; if ( option != ( char * ) NULL ) { char * geometry ; MagickStatusType flags ; geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\'"" , option ) ;  image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> x_resolution / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> y_resolution / delta . y ) - 0.5 ) ; geometry = DestroyString ( geometry ) ; fitPage = MagickTrue ; } if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( & image -> exception , FileOpenError , ""UnableToOpenFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , ""/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{"" ""dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n"" ""<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n"" , MaxTextExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MaxTextExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MaxTextExtent , ""%g<S2SV_blank>%g<S2SV_blank>translate\\n"" , - hires_bounds . x1 , - hires_bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:mono"" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:cmyk"" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( ""ps:alpha"" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( """" ) ; options = AcquireString ( """" ) ; ( void ) FormatLocaleString ( density , MaxTextExtent , ""%gx%g"" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MaxTextExtent , ""-g%.20gx%.20g<S2SV_blank>"" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pages , MaxTextExtent , ""-dFirstPage=%.20g<S2SV_blank>"" ""-dLastPage=%.20g<S2SV_blank>"" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MaxTextExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , ""eps:use-cropbox"" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , ""-dEPSCrop<S2SV_blank>"" , MaxTextExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , ""-dEPSFitPage<S2SV_blank>"" , MaxTextExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MaxTextExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , ""%d"" , MaxTextExtent ) ; ( void ) FormatLocaleString ( command , MaxTextExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , ""<S2SV_blank>-c<S2SV_blank>showpage"" , MaxTextExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , ""PostscriptDelegateFailed"" , ""`%s\'"" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , ""BMP"" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , ""ps:Level"" , command + 4 ) ; if ( GlobExpression ( command , ""*EPSF-*"" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel ""<S2SV_blank>%lu"" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages ""<S2SV_blank>%lu"" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData ""<S2SV_blank>%lu<S2SV_blank>%lu"" , & columns , & rows ) ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MaxTextExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , ""icc"" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * p ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile ""<S2SV_blank>%lu"" , & extent ) ; if ( count != 1 ) continue ; length = extent ; if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * p ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , ""8bim"" , profile ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { register size_t i ; p = command ; profile = StringToStringInfo ( command ) ; for ( i = GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , ( size_t ) ( i + 1 ) ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , ( size_t ) i ) ; ( void ) SetImageProfile ( image , ""xmp"" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } } ( void ) CloseBlob ( image ) ; if ( image_info -> number_scenes != 0 ) { Image * clone_image ; register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MaxTextExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MaxTextExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }","( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;geometry = DestroyString ( geometry ) ;image = DestroyImage ( image ) ;",2607
623,"buggy line: ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ;return ;}if ( ! ndo -> ndo_eflag ) {ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ;}if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) {ND_PRINT ( ( ndo , ""%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ) ;case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;if ( ATMTHRD_LEN ( ap ) != 0 ) {ND_PRINT ( ( ndo , "")"" ) ) ;}ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_NAK :  ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;cwe id:CWE-125context: static void atmarp_print ( netdissect_options * ndo , const u_char * bp , u_int length , u_int caplen ) { const struct atmarp_pkthdr * ap ; u_short pro , hrd , op ; ap = ( const struct atmarp_pkthdr * ) bp ; ND_TCHECK ( * ap ) ; hrd = ATMHRD ( ap ) ; pro = ATMPRO ( ap ) ; op = ATMOP ( ap ) ; if ( ! ND_TTEST2 ( * aar_tpa ( ap ) , ATMTPROTO_LEN ( ap ) ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; return ; } if ( ! ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ; } if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ) ; if ( ! ndo -> ndo_vflag ) { goto out ; } } ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>"" , ndo -> ndo_vflag ? "",<S2SV_blank>"" : """" , tok2str ( arpop_values , ""Unknown<S2SV_blank>(%u)"" , op ) ) ) ; switch ( op ) { case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;  if ( ATMTHRD_LEN ( ap ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; }  ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;  break ; case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;  atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>"" ) ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREPLY : atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;  ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;  break ; case ARPOP_NAK :  ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;  break ; default : ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; return ; } out : ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","ND_PRINT ( ( ndo , ""who-has<S2SV_blank>"" ) ) ;atmarp_tpaddr_print ( ndo , ap , pro ) ;case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;if ( ATMTHRD_LEN ( ap ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;break ;case ARPOP_REPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ""at<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""for<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_NAK : ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;",2608
624,"buggy line: if ( ! ext_dp -> icmp_length ) {vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . len = hlen ;hlen -= 4 ;obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ;cwe id:CWE-125context: void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , ""#%d<S2SV_blank>%%s<S2SV_blank>unreachable"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , ""redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , ""router<S2SV_blank>advertisement"" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , ""<S2SV_blank>lifetime<S2SV_blank>"" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u"" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u"" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u:%02u"" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>%d:"" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>[size<S2SV_blank>%d]"" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>{%s<S2SV_blank>%u}"" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = ""time<S2SV_blank>exceeded<S2SV_blank>in-transit"" ; break ; case ICMP_TIMXCEED_REASS : str = ""ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded"" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>exceeded-#%d"" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%d"" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%d"" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>recv<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>xmit<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , ""type-#%d"" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , ""ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , icmp_sum ; if ( ND_TTEST2 ( * bp , plen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; if ( sum != 0 ) { icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)"" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; ip = ( const struct ip * ) bp ; snapend_save = ndo -> ndo_snapend ; ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ;  if ( ! ext_dp -> icmp_length ) {  vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , ""\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u"" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ;  vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;  vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? ""in"" : """" , hlen ) ) ;  hlen -= 4 ;  obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( icmp_mpls_ext_obj_values , ""unknown"" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u"" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp]"" ) ) ; }","if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) {vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) {}vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . len = hlen ;hlen -= 4 ;obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ;",2609
625,"buggy line: void show_object_with_name ( FILE * out , struct object * obj ,  struct strbuf * path , const char * component )  {fputc ( \'\\\free ( name ) ;}cwe id:CWE-119context: void show_object_with_name ( FILE * out , struct object * obj ,  struct strbuf * path , const char * component )  { char * name = path_name ( path , component ) ; char * p ; fprintf ( out , ""%s<S2SV_blank>"" , oid_to_hex ( & obj -> oid ) ) ; for ( p = name ; * p && * p != '\\n' ; p ++ ) fputc ( * p , out ) ; fputc ( '\\n' , out ) ;  free ( name ) ;  }","void show_object_with_name ( FILE * out , struct object * obj , const char * component ) {}",2610
626,"buggy line: usleep ( us_delay ) ;pthread_mutex_unlock ( & out -> common . lock ) ;cwe id:CWE-284context: static ssize_t out_write ( struct audio_stream_out * stream , const void * buffer , size_t bytes ) { struct a2dp_stream_out * out = ( struct a2dp_stream_out * ) stream ; int sent ; DEBUG ( ""write<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>(fd<S2SV_blank>%d)"" , bytes , out -> common . audio_fd ) ; pthread_mutex_lock ( & out -> common . lock ) ; if ( out -> common . state == AUDIO_A2DP_STATE_SUSPENDED ) { DEBUG ( ""stream<S2SV_blank>suspended"" ) ; pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } if ( ( out -> common . state == AUDIO_A2DP_STATE_STOPPED ) || ( out -> common . state == AUDIO_A2DP_STATE_STANDBY ) ) { if ( start_audio_datapath ( & out -> common ) < 0 ) { int us_delay = calc_audiotime ( out -> common . cfg , bytes ) ; DEBUG ( ""emulate<S2SV_blank>a2dp<S2SV_blank>write<S2SV_blank>delay<S2SV_blank>(%d<S2SV_blank>us)"" , us_delay ) ;  usleep ( us_delay ) ;  pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } } else if ( out -> common . state != AUDIO_A2DP_STATE_STARTED ) { ERROR ( ""stream<S2SV_blank>not<S2SV_blank>in<S2SV_blank>stopped<S2SV_blank>or<S2SV_blank>standby"" ) ; pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } pthread_mutex_unlock ( & out -> common . lock ) ; sent = skt_write ( out -> common . audio_fd , buffer , bytes ) ; if ( sent == - 1 ) { skt_disconnect ( out -> common . audio_fd ) ; out -> common . audio_fd = AUDIO_SKT_DISCONNECTED ; if ( out -> common . state != AUDIO_A2DP_STATE_SUSPENDED ) out -> common . state = AUDIO_A2DP_STATE_STOPPED ; else ERROR ( ""write<S2SV_blank>failed<S2SV_blank>:<S2SV_blank>stream<S2SV_blank>suspended,<S2SV_blank>avoid<S2SV_blank>resetting<S2SV_blank>state"" ) ; } else { const size_t frames = bytes / audio_stream_out_frame_size ( stream ) ; out -> frames_rendered += frames ; out -> frames_presented += frames ; } DEBUG ( ""wrote<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes"" , sent , bytes ) ; return sent ; }",TEMP_FAILURE_RETRY ( usleep ( us_delay ) ) ;pthread_mutex_unlock ( & out -> common . lock ) ;,2611
627,"buggy line: int err ;if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) {struct frag_hdr fhdr ;skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;skb -> ip_summed = CHECKSUM_PARTIAL ;skb -> csum = 0 ;__skb_queue_tail ( & sk -> sk_write_queue , skb ) ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;cwe id:CWE-264context: static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) { struct sk_buff * skb ;  int err ;  if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) {  struct frag_hdr fhdr ;  skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> protocol = htons ( ETH_P_IPV6 ) ;  skb -> ip_summed = CHECKSUM_PARTIAL ;  skb -> csum = 0 ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; ipv6_select_ident ( & fhdr , rt ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ;  __skb_queue_tail ( & sk -> sk_write_queue , skb ) ;  } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; }","struct frag_hdr fhdr ;int err ;if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) {skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;skb -> csum = 0 ;__skb_queue_tail ( & sk -> sk_write_queue , skb ) ;}else if ( skb_is_gso ( skb ) ) {goto append ;}skb -> ip_summed = CHECKSUM_PARTIAL ;append : return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",2612
628,"buggy line: else ND_PRINT ( ( ndo , ""[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>"" ) ) ;}}ND_PRINT ( ( ndo , ""ICMP6,<S2SV_blank>%s"" , tok2str ( icmp6_type_values , ""unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)"" , dp -> icmp6_type ) ) ) ;if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ;cwe id:CWE-125context: void icmp6_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 , int fragmented ) { const struct icmp6_hdr * dp ; const struct ip6_hdr * ip ; const struct ip6_hdr * oip ; const struct udphdr * ouh ; int dport ; const u_char * ep ; u_int prot ; dp = ( const struct icmp6_hdr * ) bp ; ip = ( const struct ip6_hdr * ) bp2 ; oip = ( const struct ip6_hdr * ) ( dp + 1 ) ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> icmp6_cksum ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , udp_sum ; if ( ND_TTEST2 ( bp [ 0 ] , length ) ) { udp_sum = EXTRACT_16BITS ( & dp -> icmp6_cksum ) ; sum = icmp6_cksum ( ndo , ip , dp , length ) ; if ( sum != 0 ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>icmp6<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>-><S2SV_blank>0x%04x!]<S2SV_blank>"" , udp_sum , in_cksum_shouldbe ( udp_sum , sum ) ) ) ; else ND_PRINT ( ( ndo , ""[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>"" ) ) ; } } ND_PRINT ( ( ndo , ""ICMP6,<S2SV_blank>%s"" , tok2str ( icmp6_type_values , ""unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)"" , dp -> icmp6_type ) ) ) ; if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; switch ( dp -> icmp6_type ) { case ICMP6_DST_UNREACH : ND_TCHECK ( oip -> ip6_dst ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , tok2str ( icmp6_dst_unreach_code_values , ""unknown<S2SV_blank>unreach<S2SV_blank>code<S2SV_blank>(%u)"" , dp -> icmp6_code ) ) ) ; switch ( dp -> icmp6_code ) { case ICMP6_DST_UNREACH_NOROUTE : case ICMP6_DST_UNREACH_ADMIN : case ICMP6_DST_UNREACH_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_DST_UNREACH_BEYONDSCOPE : ND_PRINT ( ( ndo , ""<S2SV_blank>%s,<S2SV_blank>source<S2SV_blank>address<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , ip6addr_string ( ndo , & oip -> ip6_src ) ) ) ; break ; case ICMP6_DST_UNREACH_NOPORT : if ( ( ouh = get_upperlayer ( ndo , ( const u_char * ) oip , & prot ) ) == NULL ) goto trunc ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( prot ) { case IPPROTO_TCP : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; break ; case IPPROTO_UDP : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , udpport_string ( ndo , dport ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , oip -> ip6_nxt , dport ) ) ; break ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , bp , ""\\n\\t"" , length ) ; return ; } break ; } break ; case ICMP6_PACKET_TOO_BIG : ND_TCHECK ( dp -> icmp6_mtu ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>mtu<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_mtu ) ) ) ; break ; case ICMP6_TIME_EXCEEDED : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_TIME_EXCEED_TRANSIT : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_TIME_EXCEED_REASSEMBLY : ND_PRINT ( ( ndo , ""<S2SV_blank>(reassembly)"" ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>unknown<S2SV_blank>code<S2SV_blank>(%u)"" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_PARAM_PROB : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_PARAMPROB_HEADER : ND_PRINT ( ( ndo , "",<S2SV_blank>erroneous<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_NEXTHEADER : ND_PRINT ( ( ndo , "",<S2SV_blank>next<S2SV_blank>header<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_OPTION : ND_PRINT ( ( ndo , "",<S2SV_blank>option<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>code-#%d"" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_ECHO_REQUEST : case ICMP6_ECHO_REPLY : ND_TCHECK ( dp -> icmp6_seq ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp6_seq ) ) ) ; break ; case ICMP6_MEMBERSHIP_QUERY : if ( length == MLD_MINLEN ) { mld6_print ( ndo , ( const u_char * ) dp ) ; } else if ( length >= MLDV2_MINLEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>v2"" ) ) ; mldv2_query_print ( ndo , ( const u_char * ) dp , length ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>unknown-version<S2SV_blank>(len<S2SV_blank>%u)<S2SV_blank>"" , length ) ) ; } break ; case ICMP6_MEMBERSHIP_REPORT : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ICMP6_MEMBERSHIP_REDUCTION : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ND_ROUTER_SOLICIT : # define RTSOLLEN 8 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + RTSOLLEN , length - RTSOLLEN ) ; } break ; case ND_ROUTER_ADVERT : # define RTADVLEN 16 if ( ndo -> ndo_vflag ) { const struct nd_router_advert * p ; p = ( const struct nd_router_advert * ) dp ; ND_TCHECK ( p -> nd_ra_retransmit ) ; ND_PRINT ( ( ndo , ""\\n\\thop<S2SV_blank>limit<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]"" "",<S2SV_blank>pref<S2SV_blank>%s,<S2SV_blank>router<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>reachable<S2SV_blank>time<S2SV_blank>%us,<S2SV_blank>retrans<S2SV_blank>time<S2SV_blank>%us"" , ( u_int ) p -> nd_ra_curhoplimit , bittok2str ( icmp6_opt_ra_flag_values , ""none"" , ( p -> nd_ra_flags_reserved ) ) , get_rtpref ( p -> nd_ra_flags_reserved ) , EXTRACT_16BITS ( & p -> nd_ra_router_lifetime ) , EXTRACT_32BITS ( & p -> nd_ra_reachable ) , EXTRACT_32BITS ( & p -> nd_ra_retransmit ) ) ) ; icmp6_opt_print ( ndo , ( const u_char * ) dp + RTADVLEN , length - RTADVLEN ) ; } break ; case ND_NEIGHBOR_SOLICIT : { const struct nd_neighbor_solicit * p ; p = ( const struct nd_neighbor_solicit * ) dp ; ND_TCHECK ( p -> nd_ns_target ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>who<S2SV_blank>has<S2SV_blank>%s"" , ip6addr_string ( ndo , & p -> nd_ns_target ) ) ) ; if ( ndo -> ndo_vflag ) { # define NDSOLLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDSOLLEN , length - NDSOLLEN ) ; } } break ; case ND_NEIGHBOR_ADVERT : { const struct nd_neighbor_advert * p ; p = ( const struct nd_neighbor_advert * ) dp ; ND_TCHECK ( p -> nd_na_target ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>tgt<S2SV_blank>is<S2SV_blank>%s"" , ip6addr_string ( ndo , & p -> nd_na_target ) ) ) ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( icmp6_nd_na_flag_values , ""none"" , EXTRACT_32BITS ( & p -> nd_na_flags_reserved ) ) ) ) ; # define NDADVLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDADVLEN , length - NDADVLEN ) ; # undef NDADVLEN } } break ; case ND_REDIRECT : # define RDR ( i ) ( ( const struct nd_redirect * ) ( i ) ) ND_TCHECK ( RDR ( dp ) -> nd_rd_dst ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_dst ) ) ) ; ND_TCHECK ( RDR ( dp ) -> nd_rd_target ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>to<S2SV_blank>%s"" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_target ) ) ) ; # define REDIRECTLEN 40 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + REDIRECTLEN , length - REDIRECTLEN ) ; } break ; # undef REDIRECTLEN # undef RDR case ICMP6_ROUTER_RENUMBERING : icmp6_rrenum_print ( ndo , bp , ep ) ; break ; case ICMP6_NI_QUERY : case ICMP6_NI_REPLY : icmp6_nodeinfo_print ( ndo , length , bp , ep ) ; break ; case IND_SOLICIT : case IND_ADVERT : break ; case ICMP6_V2_MEMBERSHIP_REPORT : mldv2_report_print ( ndo , ( const u_char * ) dp , length ) ; break ; case ICMP6_MOBILEPREFIX_SOLICIT : case ICMP6_HADISCOV_REQUEST : ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; break ; case ICMP6_HADISCOV_REPLY : if ( ndo -> ndo_vflag ) { const struct in6_addr * in6 ; const u_char * cp ; ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; cp = ( const u_char * ) dp + length ; in6 = ( const struct in6_addr * ) ( dp + 1 ) ; for ( ; ( const u_char * ) in6 < cp ; in6 ++ ) { ND_TCHECK ( * in6 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , in6 ) ) ) ; } } break ; case ICMP6_MOBILEPREFIX_ADVERT : if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ;  if ( dp -> icmp6_data16 [ 1 ] & 0xc0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;  if ( dp -> icmp6_data16 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""M"" ) ) ;  if ( dp -> icmp6_data16 [ 1 ] & 0x40 )  ND_PRINT ( ( ndo , ""O"" ) ) ; # define MPADVLEN 8 icmp6_opt_print ( ndo , ( const u_char * ) dp + MPADVLEN , length - MPADVLEN ) ; } break ; case ND_RPL_MESSAGE : rpl_print ( ndo , dp , & dp -> icmp6_data8 [ 0 ] , length - sizeof ( struct icmp6_hdr ) + 4 ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , bp , ""\\n\\t"" , length ) ; return ; } if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; }","ND_TCHECK ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ;",2613
629,"buggy line: if ( dp -> icmp6_data16 [ 1 ] & 0xc0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""M"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x40 )  ND_PRINT ( ( ndo , ""O"" ) ) ;cwe id:CWE-125context: void icmp6_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 , int fragmented ) { const struct icmp6_hdr * dp ; const struct ip6_hdr * ip ; const struct ip6_hdr * oip ; const struct udphdr * ouh ; int dport ; const u_char * ep ; u_int prot ; dp = ( const struct icmp6_hdr * ) bp ; ip = ( const struct ip6_hdr * ) bp2 ; oip = ( const struct ip6_hdr * ) ( dp + 1 ) ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> icmp6_cksum ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , udp_sum ; if ( ND_TTEST2 ( bp [ 0 ] , length ) ) { udp_sum = EXTRACT_16BITS ( & dp -> icmp6_cksum ) ; sum = icmp6_cksum ( ndo , ip , dp , length ) ; if ( sum != 0 ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>icmp6<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>-><S2SV_blank>0x%04x!]<S2SV_blank>"" , udp_sum , in_cksum_shouldbe ( udp_sum , sum ) ) ) ; else ND_PRINT ( ( ndo , ""[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>"" ) ) ; } } ND_PRINT ( ( ndo , ""ICMP6,<S2SV_blank>%s"" , tok2str ( icmp6_type_values , ""unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)"" , dp -> icmp6_type ) ) ) ; if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; switch ( dp -> icmp6_type ) { case ICMP6_DST_UNREACH : ND_TCHECK ( oip -> ip6_dst ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , tok2str ( icmp6_dst_unreach_code_values , ""unknown<S2SV_blank>unreach<S2SV_blank>code<S2SV_blank>(%u)"" , dp -> icmp6_code ) ) ) ; switch ( dp -> icmp6_code ) { case ICMP6_DST_UNREACH_NOROUTE : case ICMP6_DST_UNREACH_ADMIN : case ICMP6_DST_UNREACH_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_DST_UNREACH_BEYONDSCOPE : ND_PRINT ( ( ndo , ""<S2SV_blank>%s,<S2SV_blank>source<S2SV_blank>address<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , ip6addr_string ( ndo , & oip -> ip6_src ) ) ) ; break ; case ICMP6_DST_UNREACH_NOPORT : if ( ( ouh = get_upperlayer ( ndo , ( const u_char * ) oip , & prot ) ) == NULL ) goto trunc ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( prot ) { case IPPROTO_TCP : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; break ; case IPPROTO_UDP : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , udpport_string ( ndo , dport ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , oip -> ip6_nxt , dport ) ) ; break ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , bp , ""\\n\\t"" , length ) ; return ; } break ; } break ; case ICMP6_PACKET_TOO_BIG : ND_TCHECK ( dp -> icmp6_mtu ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>mtu<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_mtu ) ) ) ; break ; case ICMP6_TIME_EXCEEDED : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_TIME_EXCEED_TRANSIT : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_TIME_EXCEED_REASSEMBLY : ND_PRINT ( ( ndo , ""<S2SV_blank>(reassembly)"" ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>unknown<S2SV_blank>code<S2SV_blank>(%u)"" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_PARAM_PROB : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_PARAMPROB_HEADER : ND_PRINT ( ( ndo , "",<S2SV_blank>erroneous<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_NEXTHEADER : ND_PRINT ( ( ndo , "",<S2SV_blank>next<S2SV_blank>header<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_OPTION : ND_PRINT ( ( ndo , "",<S2SV_blank>option<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>code-#%d"" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_ECHO_REQUEST : case ICMP6_ECHO_REPLY : ND_TCHECK ( dp -> icmp6_seq ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp6_seq ) ) ) ; break ; case ICMP6_MEMBERSHIP_QUERY : if ( length == MLD_MINLEN ) { mld6_print ( ndo , ( const u_char * ) dp ) ; } else if ( length >= MLDV2_MINLEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>v2"" ) ) ; mldv2_query_print ( ndo , ( const u_char * ) dp , length ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>unknown-version<S2SV_blank>(len<S2SV_blank>%u)<S2SV_blank>"" , length ) ) ; } break ; case ICMP6_MEMBERSHIP_REPORT : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ICMP6_MEMBERSHIP_REDUCTION : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ND_ROUTER_SOLICIT : # define RTSOLLEN 8 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + RTSOLLEN , length - RTSOLLEN ) ; } break ; case ND_ROUTER_ADVERT : # define RTADVLEN 16 if ( ndo -> ndo_vflag ) { const struct nd_router_advert * p ; p = ( const struct nd_router_advert * ) dp ; ND_TCHECK ( p -> nd_ra_retransmit ) ; ND_PRINT ( ( ndo , ""\\n\\thop<S2SV_blank>limit<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]"" "",<S2SV_blank>pref<S2SV_blank>%s,<S2SV_blank>router<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>reachable<S2SV_blank>time<S2SV_blank>%us,<S2SV_blank>retrans<S2SV_blank>time<S2SV_blank>%us"" , ( u_int ) p -> nd_ra_curhoplimit , bittok2str ( icmp6_opt_ra_flag_values , ""none"" , ( p -> nd_ra_flags_reserved ) ) , get_rtpref ( p -> nd_ra_flags_reserved ) , EXTRACT_16BITS ( & p -> nd_ra_router_lifetime ) , EXTRACT_32BITS ( & p -> nd_ra_reachable ) , EXTRACT_32BITS ( & p -> nd_ra_retransmit ) ) ) ; icmp6_opt_print ( ndo , ( const u_char * ) dp + RTADVLEN , length - RTADVLEN ) ; } break ; case ND_NEIGHBOR_SOLICIT : { const struct nd_neighbor_solicit * p ; p = ( const struct nd_neighbor_solicit * ) dp ; ND_TCHECK ( p -> nd_ns_target ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>who<S2SV_blank>has<S2SV_blank>%s"" , ip6addr_string ( ndo , & p -> nd_ns_target ) ) ) ; if ( ndo -> ndo_vflag ) { # define NDSOLLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDSOLLEN , length - NDSOLLEN ) ; } } break ; case ND_NEIGHBOR_ADVERT : { const struct nd_neighbor_advert * p ; p = ( const struct nd_neighbor_advert * ) dp ; ND_TCHECK ( p -> nd_na_target ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>tgt<S2SV_blank>is<S2SV_blank>%s"" , ip6addr_string ( ndo , & p -> nd_na_target ) ) ) ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( icmp6_nd_na_flag_values , ""none"" , EXTRACT_32BITS ( & p -> nd_na_flags_reserved ) ) ) ) ; # define NDADVLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDADVLEN , length - NDADVLEN ) ; # undef NDADVLEN } } break ; case ND_REDIRECT : # define RDR ( i ) ( ( const struct nd_redirect * ) ( i ) ) ND_TCHECK ( RDR ( dp ) -> nd_rd_dst ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_dst ) ) ) ; ND_TCHECK ( RDR ( dp ) -> nd_rd_target ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>to<S2SV_blank>%s"" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_target ) ) ) ; # define REDIRECTLEN 40 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + REDIRECTLEN , length - REDIRECTLEN ) ; } break ; # undef REDIRECTLEN # undef RDR case ICMP6_ROUTER_RENUMBERING : icmp6_rrenum_print ( ndo , bp , ep ) ; break ; case ICMP6_NI_QUERY : case ICMP6_NI_REPLY : icmp6_nodeinfo_print ( ndo , length , bp , ep ) ; break ; case IND_SOLICIT : case IND_ADVERT : break ; case ICMP6_V2_MEMBERSHIP_REPORT : mldv2_report_print ( ndo , ( const u_char * ) dp , length ) ; break ; case ICMP6_MOBILEPREFIX_SOLICIT : case ICMP6_HADISCOV_REQUEST : ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; break ; case ICMP6_HADISCOV_REPLY : if ( ndo -> ndo_vflag ) { const struct in6_addr * in6 ; const u_char * cp ; ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; cp = ( const u_char * ) dp + length ; in6 = ( const struct in6_addr * ) ( dp + 1 ) ; for ( ; ( const u_char * ) in6 < cp ; in6 ++ ) { ND_TCHECK ( * in6 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , in6 ) ) ) ; } } break ; case ICMP6_MOBILEPREFIX_ADVERT : if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ;  if ( dp -> icmp6_data16 [ 1 ] & 0xc0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;  if ( dp -> icmp6_data16 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""M"" ) ) ;  if ( dp -> icmp6_data16 [ 1 ] & 0x40 )  ND_PRINT ( ( ndo , ""O"" ) ) ; # define MPADVLEN 8 icmp6_opt_print ( ndo , ( const u_char * ) dp + MPADVLEN , length - MPADVLEN ) ; } break ; case ND_RPL_MESSAGE : rpl_print ( ndo , dp , & dp -> icmp6_data8 [ 0 ] , length - sizeof ( struct icmp6_hdr ) + 4 ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , bp , ""\\n\\t"" , length ) ; return ; } if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; }","if ( dp -> icmp6_data16 [ 1 ] ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;",2613
630,"buggy line: PureFileInfo * r ;int d ;cwe id:CWE-400context: static void listdir ( unsigned int depth , int f , void * const tls_fd , const char * name ) { PureFileInfo * dir ; char * names ; PureFileInfo * s ;  PureFileInfo * r ;  int d ; if ( depth >= max_ls_depth || matches >= max_ls_files ) { return ; } if ( ( dir = sreaddir ( & names ) ) == NULL ) { addreply ( 226 , MSG_CANT_READ_FILE , name ) ; return ; } s = dir ; while ( s -> name_offset != ( size_t ) - 1 ) { d = 0 ; if ( FI_NAME ( s ) [ 0 ] != '.' ) { d = listfile ( s , NULL ) ; } else if ( opt_a ) { if ( FI_NAME ( s ) [ 1 ] == 0 || ( FI_NAME ( s ) [ 1 ] == '.' && FI_NAME ( s ) [ 2 ] == 0 ) ) { listfile ( s , NULL ) ; } else { d = listfile ( s , NULL ) ; } } if ( ! d ) { s -> name_offset = ( size_t ) - 1 ; } s ++ ; } outputfiles ( f , tls_fd ) ; r = dir ;  while ( opt_R && r != s ) {  if ( r -> name_offset != ( size_t ) - 1 && ! chdir ( FI_NAME ( r ) ) ) {  char * alloca_subdir ;  const size_t sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } if ( SNCHECK ( snprintf ( alloca_subdir , sizeof_subdir , ""%s/%s"" , name , FI_NAME ( r ) ) , sizeof_subdir ) ) { goto nolist ; } wrstr ( f , tls_fd , ""\\r\\n\\r\\n"" ) ; wrstr ( f , tls_fd , alloca_subdir ) ; wrstr ( f , tls_fd , "":\\r\\n\\r\\n"" ) ; listdir ( depth + 1U , f , tls_fd , alloca_subdir ) ; nolist :  ALLOCA_FREE ( alloca_subdir ) ;  if ( matches >= max_ls_files ) { goto toomany ; } if ( chdir ( "".."" ) ) { if ( chdir ( wd ) || chdir ( name ) ) { die ( 421 , LOG_ERR , ""chdir:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } } r ++ ; } toomany :  free ( names ) ;  free ( dir ) ; names = NULL ; }",PureFileInfo * r ;char * alloca_subdir ;size_t sizeof_subdir ;int d ;,2614
631,"buggy line: cwe id:CWE-400context: static void listdir ( unsigned int depth , int f , void * const tls_fd , const char * name ) { PureFileInfo * dir ; char * names ; PureFileInfo * s ;  PureFileInfo * r ;  int d ; if ( depth >= max_ls_depth || matches >= max_ls_files ) { return ; } if ( ( dir = sreaddir ( & names ) ) == NULL ) { addreply ( 226 , MSG_CANT_READ_FILE , name ) ; return ; } s = dir ; while ( s -> name_offset != ( size_t ) - 1 ) { d = 0 ; if ( FI_NAME ( s ) [ 0 ] != '.' ) { d = listfile ( s , NULL ) ; } else if ( opt_a ) { if ( FI_NAME ( s ) [ 1 ] == 0 || ( FI_NAME ( s ) [ 1 ] == '.' && FI_NAME ( s ) [ 2 ] == 0 ) ) { listfile ( s , NULL ) ; } else { d = listfile ( s , NULL ) ; } } if ( ! d ) { s -> name_offset = ( size_t ) - 1 ; } s ++ ; } outputfiles ( f , tls_fd ) ; r = dir ;  while ( opt_R && r != s ) {  if ( r -> name_offset != ( size_t ) - 1 && ! chdir ( FI_NAME ( r ) ) ) {  char * alloca_subdir ;  const size_t sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } if ( SNCHECK ( snprintf ( alloca_subdir , sizeof_subdir , ""%s/%s"" , name , FI_NAME ( r ) ) , sizeof_subdir ) ) { goto nolist ; } wrstr ( f , tls_fd , ""\\r\\n\\r\\n"" ) ; wrstr ( f , tls_fd , alloca_subdir ) ; wrstr ( f , tls_fd , "":\\r\\n\\r\\n"" ) ; listdir ( depth + 1U , f , tls_fd , alloca_subdir ) ; nolist :  ALLOCA_FREE ( alloca_subdir ) ;  if ( matches >= max_ls_files ) { goto toomany ; } if ( chdir ( "".."" ) ) { if ( chdir ( wd ) || chdir ( name ) ) { die ( 421 , LOG_ERR , ""chdir:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } } r ++ ; } toomany :  free ( names ) ;  free ( dir ) ; names = NULL ; }",sizeof_subdir = PATH_MAX + 1U ;if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) {goto toomany ;},2614
632,"buggy line: listfile ( s , NULL ) ;}else {d = listfile ( s , NULL ) ;}}if ( ! d ) {s -> name_offset = ( size_t ) - 1 ;}s ++ ;}outputfiles ( f , tls_fd ) ;r = dir ;while ( opt_R && r != s ) {if ( r -> name_offset != ( size_t ) - 1 && ! chdir ( FI_NAME ( r ) ) ) {char * alloca_subdir ;const size_t sizeof_subdir = PATH_MAX + 1U ;if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) {goto toomany ;}cwe id:CWE-400context: static void listdir ( unsigned int depth , int f , void * const tls_fd , const char * name ) { PureFileInfo * dir ; char * names ; PureFileInfo * s ;  PureFileInfo * r ;  int d ; if ( depth >= max_ls_depth || matches >= max_ls_files ) { return ; } if ( ( dir = sreaddir ( & names ) ) == NULL ) { addreply ( 226 , MSG_CANT_READ_FILE , name ) ; return ; } s = dir ; while ( s -> name_offset != ( size_t ) - 1 ) { d = 0 ; if ( FI_NAME ( s ) [ 0 ] != '.' ) { d = listfile ( s , NULL ) ; } else if ( opt_a ) { if ( FI_NAME ( s ) [ 1 ] == 0 || ( FI_NAME ( s ) [ 1 ] == '.' && FI_NAME ( s ) [ 2 ] == 0 ) ) { listfile ( s , NULL ) ; } else { d = listfile ( s , NULL ) ; } } if ( ! d ) { s -> name_offset = ( size_t ) - 1 ; } s ++ ; } outputfiles ( f , tls_fd ) ; r = dir ;  while ( opt_R && r != s ) {  if ( r -> name_offset != ( size_t ) - 1 && ! chdir ( FI_NAME ( r ) ) ) {  char * alloca_subdir ;  const size_t sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } if ( SNCHECK ( snprintf ( alloca_subdir , sizeof_subdir , ""%s/%s"" , name , FI_NAME ( r ) ) , sizeof_subdir ) ) { goto nolist ; } wrstr ( f , tls_fd , ""\\r\\n\\r\\n"" ) ; wrstr ( f , tls_fd , alloca_subdir ) ; wrstr ( f , tls_fd , "":\\r\\n\\r\\n"" ) ; listdir ( depth + 1U , f , tls_fd , alloca_subdir ) ; nolist :  ALLOCA_FREE ( alloca_subdir ) ;  if ( matches >= max_ls_files ) { goto toomany ; } if ( chdir ( "".."" ) ) { if ( chdir ( wd ) || chdir ( name ) ) { die ( 421 , LOG_ERR , ""chdir:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } } r ++ ; } toomany :  free ( names ) ;  free ( dir ) ; names = NULL ; }","
",2614
633,"buggy line: nolist :  ALLOCA_FREE ( alloca_subdir ) ;if ( matches >= max_ls_files ) {cwe id:CWE-400context: static void listdir ( unsigned int depth , int f , void * const tls_fd , const char * name ) { PureFileInfo * dir ; char * names ; PureFileInfo * s ;  PureFileInfo * r ;  int d ; if ( depth >= max_ls_depth || matches >= max_ls_files ) { return ; } if ( ( dir = sreaddir ( & names ) ) == NULL ) { addreply ( 226 , MSG_CANT_READ_FILE , name ) ; return ; } s = dir ; while ( s -> name_offset != ( size_t ) - 1 ) { d = 0 ; if ( FI_NAME ( s ) [ 0 ] != '.' ) { d = listfile ( s , NULL ) ; } else if ( opt_a ) { if ( FI_NAME ( s ) [ 1 ] == 0 || ( FI_NAME ( s ) [ 1 ] == '.' && FI_NAME ( s ) [ 2 ] == 0 ) ) { listfile ( s , NULL ) ; } else { d = listfile ( s , NULL ) ; } } if ( ! d ) { s -> name_offset = ( size_t ) - 1 ; } s ++ ; } outputfiles ( f , tls_fd ) ; r = dir ;  while ( opt_R && r != s ) {  if ( r -> name_offset != ( size_t ) - 1 && ! chdir ( FI_NAME ( r ) ) ) {  char * alloca_subdir ;  const size_t sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } if ( SNCHECK ( snprintf ( alloca_subdir , sizeof_subdir , ""%s/%s"" , name , FI_NAME ( r ) ) , sizeof_subdir ) ) { goto nolist ; } wrstr ( f , tls_fd , ""\\r\\n\\r\\n"" ) ; wrstr ( f , tls_fd , alloca_subdir ) ; wrstr ( f , tls_fd , "":\\r\\n\\r\\n"" ) ; listdir ( depth + 1U , f , tls_fd , alloca_subdir ) ; nolist :  ALLOCA_FREE ( alloca_subdir ) ;  if ( matches >= max_ls_files ) { goto toomany ; } if ( chdir ( "".."" ) ) { if ( chdir ( wd ) || chdir ( name ) ) { die ( 421 , LOG_ERR , ""chdir:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } } r ++ ; } toomany :  free ( names ) ;  free ( dir ) ; names = NULL ; }",nolist : ALLOCA_FREE ( alloca_subdir ) ;if ( matches >= max_ls_files ) {,2614
634,"buggy line: toomany :  free ( names ) ;free ( dir ) ;cwe id:CWE-400context: static void listdir ( unsigned int depth , int f , void * const tls_fd , const char * name ) { PureFileInfo * dir ; char * names ; PureFileInfo * s ;  PureFileInfo * r ;  int d ; if ( depth >= max_ls_depth || matches >= max_ls_files ) { return ; } if ( ( dir = sreaddir ( & names ) ) == NULL ) { addreply ( 226 , MSG_CANT_READ_FILE , name ) ; return ; } s = dir ; while ( s -> name_offset != ( size_t ) - 1 ) { d = 0 ; if ( FI_NAME ( s ) [ 0 ] != '.' ) { d = listfile ( s , NULL ) ; } else if ( opt_a ) { if ( FI_NAME ( s ) [ 1 ] == 0 || ( FI_NAME ( s ) [ 1 ] == '.' && FI_NAME ( s ) [ 2 ] == 0 ) ) { listfile ( s , NULL ) ; } else { d = listfile ( s , NULL ) ; } } if ( ! d ) { s -> name_offset = ( size_t ) - 1 ; } s ++ ; } outputfiles ( f , tls_fd ) ; r = dir ;  while ( opt_R && r != s ) {  if ( r -> name_offset != ( size_t ) - 1 && ! chdir ( FI_NAME ( r ) ) ) {  char * alloca_subdir ;  const size_t sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } if ( SNCHECK ( snprintf ( alloca_subdir , sizeof_subdir , ""%s/%s"" , name , FI_NAME ( r ) ) , sizeof_subdir ) ) { goto nolist ; } wrstr ( f , tls_fd , ""\\r\\n\\r\\n"" ) ; wrstr ( f , tls_fd , alloca_subdir ) ; wrstr ( f , tls_fd , "":\\r\\n\\r\\n"" ) ; listdir ( depth + 1U , f , tls_fd , alloca_subdir ) ; nolist :  ALLOCA_FREE ( alloca_subdir ) ;  if ( matches >= max_ls_files ) { goto toomany ; } if ( chdir ( "".."" ) ) { if ( chdir ( wd ) || chdir ( name ) ) { die ( 421 , LOG_ERR , ""chdir:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } } r ++ ; } toomany :  free ( names ) ;  free ( dir ) ; names = NULL ; }",toomany : ALLOCA_FREE ( alloca_subdir ) ;free ( names ) ;free ( dir ) ;,2614
635,"buggy line: cwe id:CWE-310context: int use_env ( ) { int indent ; size_t flags = 0 ; json_t * json ; json_error_t error ; # ifdef _WIN32 _setmode ( _fileno ( stdout ) , _O_BINARY ) ; _setmode ( _fileno ( stderr ) , _O_BINARY ) ; # endif indent = getenv_int ( ""JSON_INDENT"" ) ; if ( indent < 0 || indent > 255 ) { fprintf ( stderr , ""invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>JSON_INDENT:<S2SV_blank>%d\\n"" , indent ) ; return 2 ; } if ( indent > 0 ) flags |= JSON_INDENT ( indent ) ; if ( getenv_int ( ""JSON_COMPACT"" ) > 0 ) flags |= JSON_COMPACT ; if ( getenv_int ( ""JSON_ENSURE_ASCII"" ) ) flags |= JSON_ENSURE_ASCII ; if ( getenv_int ( ""JSON_PRESERVE_ORDER"" ) ) flags |= JSON_PRESERVE_ORDER ; if ( getenv_int ( ""JSON_SORT_KEYS"" ) ) flags |= JSON_SORT_KEYS ;  if ( getenv_int ( ""STRIP"" ) ) {  size_t size = 0 , used = 0 ; char * buffer = NULL ; while ( 1 ) { size_t count ; size = ( size == 0 ? 128 : size * 2 ) ; buffer = realloc ( buffer , size ) ; if ( ! buffer ) { fprintf ( stderr , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) size ) ; return 1 ; } count = fread ( buffer + used , 1 , size - used , stdin ) ; if ( count < size - used ) { buffer [ used + count ] = '\\0' ; break ; } used += count ; } json = json_loads ( strip ( buffer ) , 0 , & error ) ; free ( buffer ) ; } else json = json_loadf ( stdin , 0 , & error ) ; if ( ! json ) { fprintf ( stderr , ""%d<S2SV_blank>%d<S2SV_blank>%d\\n%s\\n"" , error . line , error . column , error . position , error . text ) ; return 1 ; } json_dumpf ( json , stdout , flags ) ; json_decref ( json ) ; return 0 ; }","if ( getenv ( ""HASHSEED"" ) ) json_object_seed ( getenv_int ( ""HASHSEED"" ) ) ;",2615
636,"buggy line: if ( getenv_int ( ""STRIP"" ) ) {size_t size = 0 , used = 0 ;cwe id:CWE-310context: int use_env ( ) { int indent ; size_t flags = 0 ; json_t * json ; json_error_t error ; # ifdef _WIN32 _setmode ( _fileno ( stdout ) , _O_BINARY ) ; _setmode ( _fileno ( stderr ) , _O_BINARY ) ; # endif indent = getenv_int ( ""JSON_INDENT"" ) ; if ( indent < 0 || indent > 255 ) { fprintf ( stderr , ""invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>JSON_INDENT:<S2SV_blank>%d\\n"" , indent ) ; return 2 ; } if ( indent > 0 ) flags |= JSON_INDENT ( indent ) ; if ( getenv_int ( ""JSON_COMPACT"" ) > 0 ) flags |= JSON_COMPACT ; if ( getenv_int ( ""JSON_ENSURE_ASCII"" ) ) flags |= JSON_ENSURE_ASCII ; if ( getenv_int ( ""JSON_PRESERVE_ORDER"" ) ) flags |= JSON_PRESERVE_ORDER ; if ( getenv_int ( ""JSON_SORT_KEYS"" ) ) flags |= JSON_SORT_KEYS ;  if ( getenv_int ( ""STRIP"" ) ) {  size_t size = 0 , used = 0 ; char * buffer = NULL ; while ( 1 ) { size_t count ; size = ( size == 0 ? 128 : size * 2 ) ; buffer = realloc ( buffer , size ) ; if ( ! buffer ) { fprintf ( stderr , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) size ) ; return 1 ; } count = fread ( buffer + used , 1 , size - used , stdin ) ; if ( count < size - used ) { buffer [ used + count ] = '\\0' ; break ; } used += count ; } json = json_loads ( strip ( buffer ) , 0 , & error ) ; free ( buffer ) ; } else json = json_loadf ( stdin , 0 , & error ) ; if ( ! json ) { fprintf ( stderr , ""%d<S2SV_blank>%d<S2SV_blank>%d\\n%s\\n"" , error . line , error . column , error . position , error . text ) ; return 1 ; } json_dumpf ( json , stdout , flags ) ; json_decref ( json ) ; return 0 ; }","if ( getenv_int ( ""STRIP"" ) ) {size_t size = 0 , used = 0 ;",2615
637,"buggy line: oe_errno = 0 ;if ( ! sock )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( addrlen )  addrlen_in = * addrlen ;if ( oe_syscall_getsockname_ocall ( & ret , sock -> host_fd ,  ( struct oe_sockaddr * ) addr ,  addrlen_in ,  addrlen ) != OE_OK )  {done :  return ret ;cwe id:CWE-552context: static int _hostsock_getsockname ( oe_fd_t * sock_ , struct oe_sockaddr * addr , oe_socklen_t * addrlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t addrlen_in = 0 ;  oe_errno = 0 ;   if ( ! sock )  OE_RAISE_ERRNO ( OE_EINVAL ) ;  if ( addrlen )  addrlen_in = * addrlen ; if ( oe_syscall_getsockname_ocall ( & ret , sock -> host_fd ,  ( struct oe_sockaddr * ) addr ,  addrlen_in ,  addrlen ) != OE_OK )  { OE_RAISE_ERRNO ( OE_EINVAL ) ; }  done :  return ret ; }","oe_socklen_t addrlen_out = 0 ;oe_errno = 0 ;if ( oe_syscall_getsockname_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , addrlen ) != OE_OK ) {if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( addrlen_in >= addrlen_out ) * addrlen = addrlen_out ;done : return ret ;",2616
638,"buggy line: err = - EFAULT ;goto out ;}if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) {u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR :  case PSR_AA32_MODE_FIQ :  case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND :  case PSR_MODE_EL0t :  case PSR_MODE_EL1t :  case PSR_MODE_EL1h :  break ;cwe id:CWE-20context: static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) {  u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;  switch ( mode ) { case PSR_AA32_MODE_USR :  case PSR_AA32_MODE_FIQ :  case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND :  case PSR_MODE_EL0t :  case PSR_MODE_EL1t :  case PSR_MODE_EL1h :  break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }",u64 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ;break ;case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;,2617
639,"buggy line: return ret ;}cwe id:CWE-401context: static int fsl_lpspi_probe ( struct platform_device * pdev ) { struct device_node * np = pdev -> dev . of_node ; struct fsl_lpspi_data * fsl_lpspi ; struct spi_controller * controller ; struct spi_imx_master * lpspi_platform_info = dev_get_platdata ( & pdev -> dev ) ; struct resource * res ; int i , ret , irq ; u32 temp ; bool is_slave ; is_slave = of_property_read_bool ( ( & pdev -> dev ) -> of_node , ""spi-slave"" ) ; if ( is_slave ) controller = spi_alloc_slave ( & pdev -> dev , sizeof ( struct fsl_lpspi_data ) ) ; else controller = spi_alloc_master ( & pdev -> dev , sizeof ( struct fsl_lpspi_data ) ) ; if ( ! controller ) return - ENOMEM ; platform_set_drvdata ( pdev , controller ) ; fsl_lpspi = spi_controller_get_devdata ( controller ) ; fsl_lpspi -> dev = & pdev -> dev ; fsl_lpspi -> is_slave = is_slave ; if ( ! fsl_lpspi -> is_slave ) { for ( i = 0 ; i < controller -> num_chipselect ; i ++ ) { int cs_gpio = of_get_named_gpio ( np , ""cs-gpios"" , i ) ; if ( ! gpio_is_valid ( cs_gpio ) && lpspi_platform_info ) cs_gpio = lpspi_platform_info -> chipselect [ i ] ; fsl_lpspi -> chipselect [ i ] = cs_gpio ; if ( ! gpio_is_valid ( cs_gpio ) ) continue ; ret = devm_gpio_request ( & pdev -> dev , fsl_lpspi -> chipselect [ i ] , DRIVER_NAME ) ; if ( ret ) { dev_err ( & pdev -> dev , ""can\'t<S2SV_blank>get<S2SV_blank>cs<S2SV_blank>gpios\\n"" ) ; goto out_controller_put ; } } controller -> cs_gpios = fsl_lpspi -> chipselect ; controller -> prepare_message = fsl_lpspi_prepare_message ; } controller -> bits_per_word_mask = SPI_BPW_RANGE_MASK ( 8 , 32 ) ; controller -> transfer_one = fsl_lpspi_transfer_one ; controller -> prepare_transfer_hardware = lpspi_prepare_xfer_hardware ; controller -> unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware ; controller -> mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH ; controller -> flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX ; controller -> dev . of_node = pdev -> dev . of_node ; controller -> bus_num = pdev -> id ; controller -> slave_abort = fsl_lpspi_slave_abort ; init_completion ( & fsl_lpspi -> xfer_done ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; fsl_lpspi -> base = devm_ioremap_resource ( & pdev -> dev , res ) ; if ( IS_ERR ( fsl_lpspi -> base ) ) { ret = PTR_ERR ( fsl_lpspi -> base ) ; goto out_controller_put ; } fsl_lpspi -> base_phys = res -> start ; irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { ret = irq ; goto out_controller_put ; } ret = devm_request_irq ( & pdev -> dev , irq , fsl_lpspi_isr , 0 , dev_name ( & pdev -> dev ) , fsl_lpspi ) ; if ( ret ) { dev_err ( & pdev -> dev , ""can\'t<S2SV_blank>get<S2SV_blank>irq%d:<S2SV_blank>%d\\n"" , irq , ret ) ; goto out_controller_put ; } fsl_lpspi -> clk_per = devm_clk_get ( & pdev -> dev , ""per"" ) ; if ( IS_ERR ( fsl_lpspi -> clk_per ) ) { ret = PTR_ERR ( fsl_lpspi -> clk_per ) ; goto out_controller_put ; } fsl_lpspi -> clk_ipg = devm_clk_get ( & pdev -> dev , ""ipg"" ) ; if ( IS_ERR ( fsl_lpspi -> clk_ipg ) ) { ret = PTR_ERR ( fsl_lpspi -> clk_ipg ) ; goto out_controller_put ; } ret = fsl_lpspi_init_rpm ( fsl_lpspi ) ; if ( ret ) goto out_controller_put ; ret = pm_runtime_get_sync ( fsl_lpspi -> dev ) ; if ( ret < 0 ) { dev_err ( fsl_lpspi -> dev , ""failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>clock\\n"" ) ;  return ret ;  } temp = readl ( fsl_lpspi -> base + IMX7ULP_PARAM ) ; fsl_lpspi -> txfifosize = 1 << ( temp & 0x0f ) ; fsl_lpspi -> rxfifosize = 1 << ( ( temp >> 8 ) & 0x0f ) ; ret = fsl_lpspi_dma_init ( & pdev -> dev , fsl_lpspi , controller ) ; if ( ret == - EPROBE_DEFER ) goto out_controller_put ; if ( ret < 0 ) dev_err ( & pdev -> dev , ""dma<S2SV_blank>setup<S2SV_blank>error<S2SV_blank>%d,<S2SV_blank>use<S2SV_blank>pio\\n"" , ret ) ; ret = devm_spi_register_controller ( & pdev -> dev , controller ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , ""spi_register_controller<S2SV_blank>error.\\n"" ) ; goto out_controller_put ; } return 0 ; out_controller_put : spi_controller_put ( controller ) ; return ret ; }",goto out_controller_put ;},2618
640,"buggy line: for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;cwe id:CWE-119context: static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ;  for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) {  struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ;  if ( unix_sock_count ) {  for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) unix_inflight ( scm -> fp -> fp [ i ] ) ;  }  return max_level ; }",if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ;for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;,2619
641,"buggy line: if ( unix_sock_count ) {for ( i = scm -> fp -> count - 1 ;}return max_level ;cwe id:CWE-119context: static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ;  for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) {  struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ;  if ( unix_sock_count ) {  for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) unix_inflight ( scm -> fp -> fp [ i ] ) ;  }  return max_level ; }",for ( i = scm -> fp -> count - 1 ;return max_level ;,2619
642,"buggy line: register const u_char * ep ;register u_char type ;ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;cwe id:CWE-125context: void pimv1_print ( netdissect_options * ndo , register const u_char * bp , register u_int len ) {  register const u_char * ep ;  register u_char type ;  ep = ( const u_char * ) ndo -> ndo_snapend ;  if ( bp >= ep ) return ; ND_TCHECK ( bp [ 1 ] ) ; type = bp [ 1 ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( pimv1_type_str , ""[type<S2SV_blank>%u]"" , type ) ) ) ; switch ( type ) { case PIMV1_TYPE_QUERY : if ( ND_TTEST ( bp [ 8 ] ) ) { switch ( bp [ 8 ] >> 4 ) { case 0 : ND_PRINT ( ( ndo , ""<S2SV_blank>Dense-mode"" ) ) ; break ; case 1 : ND_PRINT ( ( ndo , ""<S2SV_blank>Sparse-mode"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""<S2SV_blank>Sparse-Dense-mode"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>mode-%d"" , bp [ 8 ] >> 4 ) ) ; break ; } } if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( bp [ 10 ] , 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(Hold-time<S2SV_blank>"" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 10 ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } break ; case PIMV1_TYPE_REGISTER : ND_TCHECK2 ( bp [ 8 ] , 20 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 20 ] ) , ipaddr_string ( ndo , & bp [ 24 ] ) ) ) ; break ; case PIMV1_TYPE_REGISTER_STOP : ND_TCHECK2 ( bp [ 12 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 8 ] ) , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ; break ; case PIMV1_TYPE_RP_REACHABILITY : if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( bp [ 22 ] , 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>group<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( EXTRACT_32BITS ( & bp [ 12 ] ) != 0xffffffff ) ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>RP<S2SV_blank>%s<S2SV_blank>hold<S2SV_blank>"" , ipaddr_string ( ndo , & bp [ 16 ] ) ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 22 ] ) ) ; } break ; case PIMV1_TYPE_ASSERT : ND_TCHECK2 ( bp [ 16 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 16 ] ) , ipaddr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( EXTRACT_32BITS ( & bp [ 12 ] ) != 0xffffffff ) ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ; ND_TCHECK2 ( bp [ 24 ] , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>pref<S2SV_blank>%d<S2SV_blank>metric<S2SV_blank>%d"" , ( bp [ 20 ] & 0x80 ) ? ""RP-tree"" : ""SPT"" , EXTRACT_32BITS ( & bp [ 20 ] ) & 0x7fffffff , EXTRACT_32BITS ( & bp [ 24 ] ) ) ) ; break ; case PIMV1_TYPE_JOIN_PRUNE : case PIMV1_TYPE_GRAFT : case PIMV1_TYPE_GRAFT_ACK :  if ( ndo -> ndo_vflag )  pimv1_join_prune_print ( ndo , & bp [ 8 ] , len - 8 ) ;  break ;  } ND_TCHECK ( bp [ 4 ] ) ; if ( ( bp [ 4 ] >> 4 ) != 1 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[v%d]"" , bp [ 4 ] >> 4 ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pim]"" ) ) ; return ; }",register u_char type ;ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;,2620
643,"buggy line: cwe id:CWE-125context: void pimv1_print ( netdissect_options * ndo , register const u_char * bp , register u_int len ) {  register const u_char * ep ;  register u_char type ;  ep = ( const u_char * ) ndo -> ndo_snapend ;  if ( bp >= ep ) return ; ND_TCHECK ( bp [ 1 ] ) ; type = bp [ 1 ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( pimv1_type_str , ""[type<S2SV_blank>%u]"" , type ) ) ) ; switch ( type ) { case PIMV1_TYPE_QUERY : if ( ND_TTEST ( bp [ 8 ] ) ) { switch ( bp [ 8 ] >> 4 ) { case 0 : ND_PRINT ( ( ndo , ""<S2SV_blank>Dense-mode"" ) ) ; break ; case 1 : ND_PRINT ( ( ndo , ""<S2SV_blank>Sparse-mode"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""<S2SV_blank>Sparse-Dense-mode"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>mode-%d"" , bp [ 8 ] >> 4 ) ) ; break ; } } if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( bp [ 10 ] , 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(Hold-time<S2SV_blank>"" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 10 ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } break ; case PIMV1_TYPE_REGISTER : ND_TCHECK2 ( bp [ 8 ] , 20 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 20 ] ) , ipaddr_string ( ndo , & bp [ 24 ] ) ) ) ; break ; case PIMV1_TYPE_REGISTER_STOP : ND_TCHECK2 ( bp [ 12 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 8 ] ) , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ; break ; case PIMV1_TYPE_RP_REACHABILITY : if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( bp [ 22 ] , 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>group<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( EXTRACT_32BITS ( & bp [ 12 ] ) != 0xffffffff ) ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>RP<S2SV_blank>%s<S2SV_blank>hold<S2SV_blank>"" , ipaddr_string ( ndo , & bp [ 16 ] ) ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 22 ] ) ) ; } break ; case PIMV1_TYPE_ASSERT : ND_TCHECK2 ( bp [ 16 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 16 ] ) , ipaddr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( EXTRACT_32BITS ( & bp [ 12 ] ) != 0xffffffff ) ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ; ND_TCHECK2 ( bp [ 24 ] , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>pref<S2SV_blank>%d<S2SV_blank>metric<S2SV_blank>%d"" , ( bp [ 20 ] & 0x80 ) ? ""RP-tree"" : ""SPT"" , EXTRACT_32BITS ( & bp [ 20 ] ) & 0x7fffffff , EXTRACT_32BITS ( & bp [ 24 ] ) ) ) ; break ; case PIMV1_TYPE_JOIN_PRUNE : case PIMV1_TYPE_GRAFT : case PIMV1_TYPE_GRAFT_ACK :  if ( ndo -> ndo_vflag )  pimv1_join_prune_print ( ndo , & bp [ 8 ] , len - 8 ) ;  break ;  } ND_TCHECK ( bp [ 4 ] ) ; if ( ( bp [ 4 ] >> 4 ) != 1 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[v%d]"" , bp [ 4 ] >> 4 ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pim]"" ) ) ; return ; }",if ( len < 8 ) goto trunc ;{,2620
644,"buggy line: case PIMV1_TYPE_JOIN_PRUNE : case PIMV1_TYPE_GRAFT : case PIMV1_TYPE_GRAFT_ACK :  if ( ndo -> ndo_vflag )  pimv1_join_prune_print ( ndo , & bp [ 8 ] , len - 8 ) ;break ;}cwe id:CWE-125context: void pimv1_print ( netdissect_options * ndo , register const u_char * bp , register u_int len ) {  register const u_char * ep ;  register u_char type ;  ep = ( const u_char * ) ndo -> ndo_snapend ;  if ( bp >= ep ) return ; ND_TCHECK ( bp [ 1 ] ) ; type = bp [ 1 ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( pimv1_type_str , ""[type<S2SV_blank>%u]"" , type ) ) ) ; switch ( type ) { case PIMV1_TYPE_QUERY : if ( ND_TTEST ( bp [ 8 ] ) ) { switch ( bp [ 8 ] >> 4 ) { case 0 : ND_PRINT ( ( ndo , ""<S2SV_blank>Dense-mode"" ) ) ; break ; case 1 : ND_PRINT ( ( ndo , ""<S2SV_blank>Sparse-mode"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""<S2SV_blank>Sparse-Dense-mode"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>mode-%d"" , bp [ 8 ] >> 4 ) ) ; break ; } } if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( bp [ 10 ] , 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(Hold-time<S2SV_blank>"" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 10 ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } break ; case PIMV1_TYPE_REGISTER : ND_TCHECK2 ( bp [ 8 ] , 20 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 20 ] ) , ipaddr_string ( ndo , & bp [ 24 ] ) ) ) ; break ; case PIMV1_TYPE_REGISTER_STOP : ND_TCHECK2 ( bp [ 12 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 8 ] ) , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ; break ; case PIMV1_TYPE_RP_REACHABILITY : if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( bp [ 22 ] , 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>group<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( EXTRACT_32BITS ( & bp [ 12 ] ) != 0xffffffff ) ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>RP<S2SV_blank>%s<S2SV_blank>hold<S2SV_blank>"" , ipaddr_string ( ndo , & bp [ 16 ] ) ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 22 ] ) ) ; } break ; case PIMV1_TYPE_ASSERT : ND_TCHECK2 ( bp [ 16 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & bp [ 16 ] ) , ipaddr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( EXTRACT_32BITS ( & bp [ 12 ] ) != 0xffffffff ) ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ; ND_TCHECK2 ( bp [ 24 ] , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>pref<S2SV_blank>%d<S2SV_blank>metric<S2SV_blank>%d"" , ( bp [ 20 ] & 0x80 ) ? ""RP-tree"" : ""SPT"" , EXTRACT_32BITS ( & bp [ 20 ] ) & 0x7fffffff , EXTRACT_32BITS ( & bp [ 24 ] ) ) ) ; break ; case PIMV1_TYPE_JOIN_PRUNE : case PIMV1_TYPE_GRAFT : case PIMV1_TYPE_GRAFT_ACK :  if ( ndo -> ndo_vflag )  pimv1_join_prune_print ( ndo , & bp [ 8 ] , len - 8 ) ;  break ;  } ND_TCHECK ( bp [ 4 ] ) ; if ( ( bp [ 4 ] >> 4 ) != 1 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[v%d]"" , bp [ 4 ] >> 4 ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pim]"" ) ) ; return ; }","case PIMV1_TYPE_JOIN_PRUNE : case PIMV1_TYPE_GRAFT : case PIMV1_TYPE_GRAFT_ACK : if ( ndo -> ndo_vflag ) pimv1_join_prune_print ( ndo , & bp [ 8 ] , len - 8 ) ;}break ;}",2620
645,"buggy line: if ( offset != 0 )  csum = csum_sub ( csum ,  csum_partial ( skb_transport_header ( skb ) + tlen ,   offset , 0 ) ) ;put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ;cwe id:CWE-125context: static void ip_cmsg_recv_checksum ( struct msghdr * msg , struct sk_buff * skb , int tlen , int offset ) { __wsum csum = skb -> csum ; if ( skb -> ip_summed != CHECKSUM_COMPLETE ) return ;  if ( offset != 0 )  csum = csum_sub ( csum ,  csum_partial ( skb_transport_header ( skb ) + tlen ,   offset , 0 ) ) ;  put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ; }","if ( offset != 0 ) {int tend_off = skb_transport_offset ( skb ) + tlen ;csum = csum_sub ( csum , skb_checksum ( skb , tend_off , offset , 0 ) ) ;}put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ;",2621
646,"buggy line: int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {cwe id:CWE-125context: int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ;  int max_bytes_matched = input_size ;  input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { int cb_result = callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ; switch ( cb_result ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_MATCHES : return - 3 ; default : if ( cb_result != ERROR_SUCCESS ) return - 4 ; } break ; } else { return bytes_matched ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } return - 1 ; }","int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {",2622
647,"buggy line: int max_bytes_matched = input_size ;input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;cwe id:CWE-125context: int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ;  int max_bytes_matched = input_size ;  input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { int cb_result = callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ; switch ( cb_result ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_MATCHES : return - 3 ; default : if ( cb_result != ERROR_SUCCESS ) return - 4 ; } break ; } else { return bytes_matched ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } return - 1 ; }",int max_bytes_matched ;max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size ;input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;,2622
648,"buggy line: set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ;cwe id:CWE-119context: int module_load ( YR_SCAN_CONTEXT * context , YR_OBJECT * module_object , void * module_data , size_t module_data_size ) { set_integer ( 1 , module_object , ""constants.one"" ) ; set_integer ( 2 , module_object , ""constants.two"" ) ; set_string ( ""foo"" , module_object , ""constants.foo"" ) ; set_string ( """" , module_object , ""constants.empty"" ) ; set_integer ( 1 , module_object , ""struct_array[1].i"" ) ; set_integer ( 0 , module_object , ""integer_array[%i]"" , 0 ) ; set_integer ( 1 , module_object , ""integer_array[%i]"" , 1 ) ; set_integer ( 2 , module_object , ""integer_array[%i]"" , 2 ) ;  set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;  set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ; set_string ( ""baz"" , module_object , ""string_array[%i]"" , 2 ) ; set_sized_string ( ""foo\\0bar"" , 7 , module_object , ""string_array[%i]"" , 3 ) ; set_string ( ""foo"" , module_object , ""string_dict[%s]"" , ""foo"" ) ; set_string ( ""bar"" , module_object , ""string_dict[\\""bar\\""]"" ) ; set_string ( ""foo"" , module_object , ""struct_dict[%s].s"" , ""foo"" ) ; set_integer ( 1 , module_object , ""struct_dict[%s].i"" , ""foo"" ) ; return ERROR_SUCCESS ; }","set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ;set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ;",2623
649,"buggy line: file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ;if ( ! file ) return - ENOMEM ;cwe id:CWE-200context: static int get_bitmap_file ( struct mddev * mddev , void __user * arg ) { mdu_bitmap_file_t * file = NULL ; char * ptr ; int err ;  file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ;  if ( ! file ) return - ENOMEM ; err = 0 ; spin_lock ( & mddev -> lock ) ; if ( ! mddev -> bitmap_info . file ) file -> pathname [ 0 ] = '\\0' ; else if ( ( ptr = file_path ( mddev -> bitmap_info . file , file -> pathname , sizeof ( file -> pathname ) ) ) , IS_ERR ( ptr ) ) err = PTR_ERR ( ptr ) ; else memmove ( file -> pathname , ptr , sizeof ( file -> pathname ) - ( ptr - file -> pathname ) ) ; spin_unlock ( & mddev -> lock ) ; if ( err == 0 && copy_to_user ( arg , file , sizeof ( * file ) ) ) err = - EFAULT ; kfree ( file ) ; return err ; }","file = kzalloc ( sizeof ( * file ) , GFP_NOIO ) ;if ( ! file ) return - ENOMEM ;",2624
650,"buggy line: # endif  if ( ( user = getpwnam ( username ) ) == NULL ) {cwe id:CWE-476context: static int daemon_AuthUserPwd ( char * username , char * password , char * errbuf ) { # ifdef _WIN32 HANDLE Token ; if ( LogonUser ( username , ""."" , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , ""LogonUser()<S2SV_blank>failed"" ) ; return - 1 ; } if ( ImpersonateLoggedOnUser ( Token ) == 0 ) { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , ""ImpersonateLoggedOnUser()<S2SV_blank>failed"" ) ; CloseHandle ( Token ) ; return - 1 ; } CloseHandle ( Token ) ; return 0 ; # else struct passwd * user ; char * user_password ; # ifdef HAVE_GETSPNAM struct spwd * usersp ;  # endif  if ( ( user = getpwnam ( username ) ) == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; return - 1 ; } # ifdef HAVE_GETSPNAM if ( ( usersp = getspnam ( username ) ) == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; return - 1 ; } user_password = usersp -> sp_pwdp ; # else user_password = user -> pw_passwd ; # endif  if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 )  { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; return - 1 ; } if ( setuid ( user -> pw_uid ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , ""setuid"" ) ; return - 1 ; } return 0 ; # endif }",# endif char * crypt_password ;if ( ( user = getpwnam ( username ) ) == NULL ) {,2625
651,"buggy line: # endif  if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 )  {cwe id:CWE-476context: static int daemon_AuthUserPwd ( char * username , char * password , char * errbuf ) { # ifdef _WIN32 HANDLE Token ; if ( LogonUser ( username , ""."" , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , ""LogonUser()<S2SV_blank>failed"" ) ; return - 1 ; } if ( ImpersonateLoggedOnUser ( Token ) == 0 ) { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , ""ImpersonateLoggedOnUser()<S2SV_blank>failed"" ) ; CloseHandle ( Token ) ; return - 1 ; } CloseHandle ( Token ) ; return 0 ; # else struct passwd * user ; char * user_password ; # ifdef HAVE_GETSPNAM struct spwd * usersp ;  # endif  if ( ( user = getpwnam ( username ) ) == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; return - 1 ; } # ifdef HAVE_GETSPNAM if ( ( usersp = getspnam ( username ) ) == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; return - 1 ; } user_password = usersp -> sp_pwdp ; # else user_password = user -> pw_passwd ; # endif  if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 )  { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; return - 1 ; } if ( setuid ( user -> pw_uid ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , ""setuid"" ) ; return - 1 ; } return 0 ; # endif }","# endif crypt_password = crypt ( password , user_password ) ;if ( crypt_password == NULL ) {pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ;return - 1 ;}if ( strcmp ( user_password , crypt_password ) != 0 ) {",2625
652,"buggy line: if ( atomic_dec_and_test ( & ucounts -> count ) ) {spin_lock_irqsave ( & ucounts_lock , flags ) ;hlist_del_init ( & ucounts -> node ) ;spin_unlock_irqrestore ( & ucounts_lock , flags ) ;}cwe id:CWE-362context: static void put_ucounts ( struct ucounts * ucounts ) { unsigned long flags ;  if ( atomic_dec_and_test ( & ucounts -> count ) ) {  spin_lock_irqsave ( & ucounts_lock , flags ) ;  hlist_del_init ( & ucounts -> node ) ;  spin_unlock_irqrestore ( & ucounts_lock , flags ) ; kfree ( ucounts ) ; }  } ","spin_lock_irqsave ( & ucounts_lock , flags ) ;ucounts -> count -= 1 ;if ( ! ucounts -> count ) hlist_del_init ( & ucounts -> node ) ;else ucounts = NULL ;spin_unlock_irqrestore ( & ucounts_lock , flags ) ;",2626
653,"buggy line: cwe id:CWE-20context: static int lz4_uncompress ( const char * source , char * dest , int osize ) { const BYTE * ip = ( const BYTE * ) source ; const BYTE * ref ; BYTE * op = ( BYTE * ) dest ; BYTE * const oend = op + osize ; BYTE * cpy ; unsigned token ; size_t length ; size_t dec32table [ ] = { 0 , 3 , 2 , 3 , 0 , 0 , 0 , 0 } ; # if LZ4_ARCH64 size_t dec64table [ ] = { 0 , 0 , 0 , - 1 , 0 , 1 , 2 , 3 } ; # endif while ( 1 ) { token = * ip ++ ; length = ( token >> ML_BITS ) ; if ( length == RUN_MASK ) { size_t len ; len = * ip ++ ; for ( ; len == 255 ; length += 255 ) len = * ip ++ ;  length += len ;  } cpy = op + length ; if ( unlikely ( cpy > oend - COPYLENGTH ) ) { if ( cpy != oend ) goto _output_error ; memcpy ( op , ip , length ) ; ip += length ; break ; } LZ4_WILDCOPY ( ip , op , cpy ) ; ip -= ( op - cpy ) ; op = cpy ; LZ4_READ_LITTLEENDIAN_16 ( ref , cpy , ip ) ; ip += 2 ; if ( unlikely ( ref < ( BYTE * const ) dest ) ) goto _output_error ; length = token & ML_MASK ; if ( length == ML_MASK ) { for ( ; * ip == 255 ; length += 255 ) ip ++ ; length += * ip ++ ; } if ( unlikely ( ( op - ref ) < STEPSIZE ) ) { # if LZ4_ARCH64 size_t dec64 = dec64table [ op - ref ] ; # else const int dec64 = 0 ; # endif op [ 0 ] = ref [ 0 ] ; op [ 1 ] = ref [ 1 ] ; op [ 2 ] = ref [ 2 ] ; op [ 3 ] = ref [ 3 ] ; op += 4 ; ref += 4 ; ref -= dec32table [ op - ref ] ; PUT4 ( ref , op ) ; op += STEPSIZE - 4 ; ref -= dec64 ; } else { LZ4_COPYSTEP ( ref , op ) ; } cpy = op + length - ( STEPSIZE - 4 ) ; if ( cpy > ( oend - COPYLENGTH ) ) { if ( cpy > oend ) goto _output_error ; LZ4_SECURECOPY ( ref , op , ( oend - COPYLENGTH ) ) ; while ( op < cpy ) * op ++ = * ref ++ ; op = cpy ; if ( op == oend ) goto _output_error ; continue ; } LZ4_SECURECOPY ( ref , op , cpy ) ; op = cpy ; } return ( int ) ( ( ( char * ) ip ) - source ) ; _output_error : return ( int ) ( - ( ( ( char * ) ip ) - source ) ) ; }",if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ;,2627
654,"buggy line: length += len ;}cwe id:CWE-20context: static int lz4_uncompress ( const char * source , char * dest , int osize ) { const BYTE * ip = ( const BYTE * ) source ; const BYTE * ref ; BYTE * op = ( BYTE * ) dest ; BYTE * const oend = op + osize ; BYTE * cpy ; unsigned token ; size_t length ; size_t dec32table [ ] = { 0 , 3 , 2 , 3 , 0 , 0 , 0 , 0 } ; # if LZ4_ARCH64 size_t dec64table [ ] = { 0 , 0 , 0 , - 1 , 0 , 1 , 2 , 3 } ; # endif while ( 1 ) { token = * ip ++ ; length = ( token >> ML_BITS ) ; if ( length == RUN_MASK ) { size_t len ; len = * ip ++ ; for ( ; len == 255 ; length += 255 ) len = * ip ++ ;  length += len ;  } cpy = op + length ; if ( unlikely ( cpy > oend - COPYLENGTH ) ) { if ( cpy != oend ) goto _output_error ; memcpy ( op , ip , length ) ; ip += length ; break ; } LZ4_WILDCOPY ( ip , op , cpy ) ; ip -= ( op - cpy ) ; op = cpy ; LZ4_READ_LITTLEENDIAN_16 ( ref , cpy , ip ) ; ip += 2 ; if ( unlikely ( ref < ( BYTE * const ) dest ) ) goto _output_error ; length = token & ML_MASK ; if ( length == ML_MASK ) { for ( ; * ip == 255 ; length += 255 ) ip ++ ; length += * ip ++ ; } if ( unlikely ( ( op - ref ) < STEPSIZE ) ) { # if LZ4_ARCH64 size_t dec64 = dec64table [ op - ref ] ; # else const int dec64 = 0 ; # endif op [ 0 ] = ref [ 0 ] ; op [ 1 ] = ref [ 1 ] ; op [ 2 ] = ref [ 2 ] ; op [ 3 ] = ref [ 3 ] ; op += 4 ; ref += 4 ; ref -= dec32table [ op - ref ] ; PUT4 ( ref , op ) ; op += STEPSIZE - 4 ; ref -= dec64 ; } else { LZ4_COPYSTEP ( ref , op ) ; } cpy = op + length - ( STEPSIZE - 4 ) ; if ( cpy > ( oend - COPYLENGTH ) ) { if ( cpy > oend ) goto _output_error ; LZ4_SECURECOPY ( ref , op , ( oend - COPYLENGTH ) ) ; while ( op < cpy ) * op ++ = * ref ++ ; op = cpy ; if ( op == oend ) goto _output_error ; continue ; } LZ4_SECURECOPY ( ref , op , cpy ) ; op = cpy ; } return ( int ) ( ( ( char * ) ip ) - source ) ; _output_error : return ( int ) ( - ( ( ( char * ) ip ) - source ) ) ; }",length += len ;},2627
655,"buggy line: if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) )  {cwe id:CWE-200context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;  if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) )  { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { ValidateColormapValue ( image , * p & mask , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) {",2628
656,"buggy line: }read_lock ( & tasklist_lock ) ;cwe id:CWE-119context: static int kill_something_info ( int sig , struct siginfo * info , pid_t pid ) { int ret ; if ( pid > 0 ) { rcu_read_lock ( ) ; ret = kill_pid_info ( sig , info , find_vpid ( pid ) ) ; rcu_read_unlock ( ) ; return ret ;  }  read_lock ( & tasklist_lock ) ; if ( pid != - 1 ) { ret = __kill_pgrp_info ( sig , info , pid ? find_vpid ( - pid ) : task_pgrp ( current ) ) ; } else { int retval = 0 , count = 0 ; struct task_struct * p ; for_each_process ( p ) { if ( task_pid_vnr ( p ) > 1 && ! same_thread_group ( p , current ) ) { int err = group_send_sig_info ( sig , info , p ) ; ++ count ; if ( err != - EPERM ) retval = err ; } } ret = count ? retval : - ESRCH ; } read_unlock ( & tasklist_lock ) ; return ret ; }",}if ( pid == INT_MIN ) return - ESRCH ;read_lock ( & tasklist_lock ) ;,2629
657,buggy line: free ( mem ) ;}cwe id:CWE-119context: static void mspack_fmap_free ( void * mem ) {  free ( mem ) ;   } ,if ( mem ) {free ( mem ) ;mem = NULL ;}return ;},2630
658,"buggy line: size_t ld ;const char * data = luaL_checklstring ( L , 2 , & ld ) ;size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ;int n = 0 ;size_t size = optsize ( L , opt , & fmt ) ;pos += gettoalign ( pos , & h , opt , size ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;cwe id:CWE-190context: static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ;  size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ;  int n = 0 ; defaultoptions ( & h ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ;  luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;  luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; lua_pushnumber ( L , res ) ; n ++ ; break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; lua_pushnumber ( L , f ) ; n ++ ; break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; lua_pushnumber ( L , d ) ; n ++ ; break ; } case 'c' : { if ( size == 0 ) { if ( n == 0 || ! lua_isnumber ( L , - 1 ) ) luaL_error ( L , ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; size = lua_tonumber ( L , - 1 ) ; lua_pop ( L , 1 ) ; n -- ; luaL_argcheck ( L , size <= ld && pos <= ld - size , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; } lua_pushlstring ( L , data + pos , size ) ; n ++ ; break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , ""unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data"" ) ; size = ( e - ( data + pos ) ) + 1 ; lua_pushlstring ( L , data + pos , size - 1 ) ; n ++ ; break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; return n + 1 ; }","luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ;pos -- ;int n = 0 ;size_t size = optsize ( L , size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;",2631
659,"buggy line: if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 )  {cwe id:CWE-284context: static int a2dp_command ( struct a2dp_stream_common * common , char cmd ) { char ack ; DEBUG ( ""A2DP<S2SV_blank>COMMAND<S2SV_blank>%s"" , dump_a2dp_ctrl_event ( cmd ) ) ;  if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 )  { ERROR ( ""cmd<S2SV_blank>failed<S2SV_blank>(%s)"" , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } if ( a2dp_ctrl_receive ( common , & ack , 1 ) < 0 ) return - 1 ; DEBUG ( ""A2DP<S2SV_blank>COMMAND<S2SV_blank>%s<S2SV_blank>DONE<S2SV_blank>STATUS<S2SV_blank>%d"" , dump_a2dp_ctrl_event ( cmd ) , ack ) ; if ( ack == A2DP_CTRL_ACK_INCALL_FAILURE ) return ack ; if ( ack != A2DP_CTRL_ACK_SUCCESS ) return - 1 ; return 0 ; }","if ( TEMP_FAILURE_RETRY ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) ) == - 1 ) {",2632
660,"buggy line: bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ;if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) {bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\\free ( bin -> dyld_info ) ;return false ;cwe id:CWE-416context: static int init_items ( struct MACH0_ ( obj_t ) * bin ) { struct load_command lc = { 0 , 0 } ; ut8 loadc [ sizeof ( struct load_command ) ] = { 0 } ; bool is_first_thread = true ; ut64 off = 0LL ; int i , len ; bin -> uuidn = 0 ; bin -> os = 0 ; bin -> has_crypto = 0 ; if ( bin -> hdr . sizeofcmds > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>chopping<S2SV_blank>hdr.sizeofcmds\\n"" ) ; bin -> hdr . sizeofcmds = bin -> size - 128 ; } for ( i = 0 , off = sizeof ( struct MACH0_ ( mach_header ) ) ; i < bin -> hdr . ncmds ; i ++ , off += lc . cmdsize ) { if ( off > bin -> size || off + sizeof ( struct load_command ) > bin -> size ) { bprintf ( ""mach0:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>command\\n"" ) ; return false ; } len = r_buf_read_at ( bin -> b , off , loadc , sizeof ( struct load_command ) ) ; if ( len < 1 ) { bprintf ( ""Error:<S2SV_blank>read<S2SV_blank>(lc)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; return false ; } lc . cmd = r_read_ble32 ( & loadc [ 0 ] , bin -> big_endian ) ; lc . cmdsize = r_read_ble32 ( & loadc [ 4 ] , bin -> big_endian ) ; if ( lc . cmdsize < 1 || off + lc . cmdsize > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>mach0_header<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>cmdsize<1.\\n"" , i ) ; break ; } sdb_num_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.offset"" , i ) , off , 0 ) ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.format"" , i ) , ""xd<S2SV_blank>cmd<S2SV_blank>size"" , 0 ) ; switch ( lc . cmd ) { case LC_DATA_IN_CODE : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""data_in_code"" , 0 ) ; break ; case LC_RPATH : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""rpath"" , 0 ) ; break ; case LC_SEGMENT_64 : case LC_SEGMENT : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""segment"" , 0 ) ; bin -> nsegs ++ ; if ( ! parse_segments ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>segment\\n"" ) ; bin -> nsegs -- ; return false ; } break ; case LC_SYMTAB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""symtab"" , 0 ) ; if ( ! parse_symtab ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>symtab\\n"" ) ; return false ; } break ; case LC_DYSYMTAB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dysymtab"" , 0 ) ; if ( ! parse_dysymtab ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>dysymtab\\n"" ) ; return false ; } break ; case LC_DYLIB_CODE_SIGN_DRS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylib_code_sign_drs"" , 0 ) ; break ; case LC_VERSION_MIN_MACOSX : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_macosx"" , 0 ) ; bin -> os = 1 ; break ; case LC_VERSION_MIN_IPHONEOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_iphoneos"" , 0 ) ; bin -> os = 2 ; break ; case LC_VERSION_MIN_TVOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_tvos"" , 0 ) ; bin -> os = 4 ; break ; case LC_VERSION_MIN_WATCHOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_watchos"" , 0 ) ; bin -> os = 3 ; break ; case LC_UUID : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""uuid"" , 0 ) ; { struct uuid_command uc = { 0 } ; if ( off + sizeof ( struct uuid_command ) > bin -> size ) { bprintf ( ""UUID<S2SV_blank>out<S2SV_blank>of<S2SV_blank>obunds\\n"" ) ; return false ; } if ( r_buf_fread_at ( bin -> b , off , ( ut8 * ) & uc , ""24c"" , 1 ) != - 1 ) { char key [ 128 ] ; char val [ 128 ] ; snprintf ( key , sizeof ( key ) - 1 , ""uuid.%d"" , bin -> uuidn ++ ) ; r_hex_bin2str ( ( ut8 * ) & uc . uuid , 16 , val ) ; sdb_set ( bin -> kv , key , val , 0 ) ; } } break ; case LC_ENCRYPTION_INFO_64 : case LC_ENCRYPTION_INFO : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""encryption_info"" , 0 ) ; { struct MACH0_ ( encryption_info_command ) eic = { 0 } ; ut8 seic [ sizeof ( struct MACH0_ ( encryption_info_command ) ) ] = { 0 } ; if ( off + sizeof ( struct MACH0_ ( encryption_info_command ) ) > bin -> size ) { bprintf ( ""encryption<S2SV_blank>info<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return false ; } if ( r_buf_read_at ( bin -> b , off , seic , sizeof ( struct MACH0_ ( encryption_info_command ) ) ) != - 1 ) { eic . cmd = r_read_ble32 ( & seic [ 0 ] , bin -> big_endian ) ; eic . cmdsize = r_read_ble32 ( & seic [ 4 ] , bin -> big_endian ) ; eic . cryptoff = r_read_ble32 ( & seic [ 8 ] , bin -> big_endian ) ; eic . cryptsize = r_read_ble32 ( & seic [ 12 ] , bin -> big_endian ) ; eic . cryptid = r_read_ble32 ( & seic [ 16 ] , bin -> big_endian ) ; bin -> has_crypto = eic . cryptid ; sdb_set ( bin -> kv , ""crypto"" , ""true"" , 0 ) ; sdb_num_set ( bin -> kv , ""cryptid"" , eic . cryptid , 0 ) ; sdb_num_set ( bin -> kv , ""cryptoff"" , eic . cryptoff , 0 ) ; sdb_num_set ( bin -> kv , ""cryptsize"" , eic . cryptsize , 0 ) ; sdb_num_set ( bin -> kv , ""cryptheader"" , off , 0 ) ; } } break ; case LC_LOAD_DYLINKER : { sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylinker"" , 0 ) ; free ( bin -> intrp ) ; bin -> intrp = NULL ; struct dylinker_command dy = { 0 } ; ut8 sdy [ sizeof ( struct dylinker_command ) ] = { 0 } ; if ( off + sizeof ( struct dylinker_command ) > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>parse<S2SV_blank>dylinker<S2SV_blank>command\\n"" ) ; return false ; } if ( r_buf_read_at ( bin -> b , off , sdy , sizeof ( struct dylinker_command ) ) == - 1 ) { bprintf ( ""Warning:<S2SV_blank>read<S2SV_blank>(LC_DYLD_INFO)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; } else { dy . cmd = r_read_ble32 ( & sdy [ 0 ] , bin -> big_endian ) ; dy . cmdsize = r_read_ble32 ( & sdy [ 4 ] , bin -> big_endian ) ; dy . name = r_read_ble32 ( & sdy [ 8 ] , bin -> big_endian ) ; int len = dy . cmdsize ; char * buf = malloc ( len + 1 ) ; if ( buf ) { r_buf_read_at ( bin -> b , off + 0xc , ( ut8 * ) buf , len ) ; buf [ len ] = 0 ; free ( bin -> intrp ) ; bin -> intrp = buf ; } } } break ; case LC_MAIN : { struct { ut64 eo ; ut64 ss ; } ep = { 0 } ; ut8 sep [ 2 * sizeof ( ut64 ) ] = { 0 } ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""main"" , 0 ) ; if ( ! is_first_thread ) { bprintf ( ""Error:<S2SV_blank>LC_MAIN<S2SV_blank>with<S2SV_blank>other<S2SV_blank>threads\\n"" ) ; return false ; } if ( off + 8 > bin -> size || off + sizeof ( ep ) > bin -> size ) { bprintf ( ""invalid<S2SV_blank>command<S2SV_blank>size<S2SV_blank>for<S2SV_blank>main\\n"" ) ; return false ; } r_buf_read_at ( bin -> b , off + 8 , sep , 2 * sizeof ( ut64 ) ) ; ep . eo = r_read_ble64 ( & sep [ 0 ] , bin -> big_endian ) ; ep . ss = r_read_ble64 ( & sep [ 8 ] , bin -> big_endian ) ; bin -> entry = ep . eo ; bin -> main_cmd = lc ; sdb_num_set ( bin -> kv , ""mach0.entry.offset"" , off + 8 , 0 ) ; sdb_num_set ( bin -> kv , ""stacksize"" , ep . ss , 0 ) ; is_first_thread = false ; } break ; case LC_UNIXTHREAD : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""unixthread"" , 0 ) ; if ( ! is_first_thread ) { bprintf ( ""Error:<S2SV_blank>LC_UNIXTHREAD<S2SV_blank>with<S2SV_blank>other<S2SV_blank>threads\\n"" ) ; return false ; } case LC_THREAD : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""thread"" , 0 ) ; if ( ! parse_thread ( bin , & lc , off , is_first_thread ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>thread\\n"" ) ; return false ; } is_first_thread = false ; break ; case LC_LOAD_DYLIB : case LC_LOAD_WEAK_DYLIB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""load_dylib"" , 0 ) ; bin -> nlibs ++ ; if ( ! parse_dylib ( bin , off ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dylib\\n"" ) ; bin -> nlibs -- ; return false ; } break ; case LC_DYLD_INFO : case LC_DYLD_INFO_ONLY : { ut8 dyldi [ sizeof ( struct dyld_info_command ) ] = { 0 } ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dyld_info"" , 0 ) ;  bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ;   if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) {  bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\n"" ) ;  free ( bin -> dyld_info ) ;  return false ; } if ( r_buf_read_at ( bin -> b , off , dyldi , sizeof ( struct dyld_info_command ) ) == - 1 ) { free ( bin -> dyld_info ) ; bin -> dyld_info = NULL ; bprintf ( ""Error:<S2SV_blank>read<S2SV_blank>(LC_DYLD_INFO)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; } else { bin -> dyld_info -> cmd = r_read_ble32 ( & dyldi [ 0 ] , bin -> big_endian ) ; bin -> dyld_info -> cmdsize = r_read_ble32 ( & dyldi [ 4 ] , bin -> big_endian ) ; bin -> dyld_info -> rebase_off = r_read_ble32 ( & dyldi [ 8 ] , bin -> big_endian ) ; bin -> dyld_info -> rebase_size = r_read_ble32 ( & dyldi [ 12 ] , bin -> big_endian ) ; bin -> dyld_info -> bind_off = r_read_ble32 ( & dyldi [ 16 ] , bin -> big_endian ) ; bin -> dyld_info -> bind_size = r_read_ble32 ( & dyldi [ 20 ] , bin -> big_endian ) ; bin -> dyld_info -> weak_bind_off = r_read_ble32 ( & dyldi [ 24 ] , bin -> big_endian ) ; bin -> dyld_info -> weak_bind_size = r_read_ble32 ( & dyldi [ 28 ] , bin -> big_endian ) ; bin -> dyld_info -> lazy_bind_off = r_read_ble32 ( & dyldi [ 32 ] , bin -> big_endian ) ; bin -> dyld_info -> lazy_bind_size = r_read_ble32 ( & dyldi [ 36 ] , bin -> big_endian ) ; bin -> dyld_info -> export_off = r_read_ble32 ( & dyldi [ 40 ] , bin -> big_endian ) ; bin -> dyld_info -> export_size = r_read_ble32 ( & dyldi [ 44 ] , bin -> big_endian ) ; } }  break ;  case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""signature"" , 0 ) ; break ; case LC_SOURCE_VERSION : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version"" , 0 ) ; break ; case LC_SEGMENT_SPLIT_INFO : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""split_info"" , 0 ) ; break ; case LC_FUNCTION_STARTS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""function_starts"" , 0 ) ; if ( ! parse_function_starts ( bin , off ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>LC_FUNCTION_STARTS\\n"" ) ; } break ; case LC_REEXPORT_DYLIB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylib"" , 0 ) ; break ; default : break ; } } return true ; }","bin -> dyld_info = calloc ( 1 , sizeof ( struct dyld_info_command ) ) ;if ( bin -> dyld_info ) {if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) {bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\\R_FREE ( bin -> dyld_info ) ;return false ;",2633
661,"buggy line: break ;case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ;cwe id:CWE-416context: static int init_items ( struct MACH0_ ( obj_t ) * bin ) { struct load_command lc = { 0 , 0 } ; ut8 loadc [ sizeof ( struct load_command ) ] = { 0 } ; bool is_first_thread = true ; ut64 off = 0LL ; int i , len ; bin -> uuidn = 0 ; bin -> os = 0 ; bin -> has_crypto = 0 ; if ( bin -> hdr . sizeofcmds > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>chopping<S2SV_blank>hdr.sizeofcmds\\n"" ) ; bin -> hdr . sizeofcmds = bin -> size - 128 ; } for ( i = 0 , off = sizeof ( struct MACH0_ ( mach_header ) ) ; i < bin -> hdr . ncmds ; i ++ , off += lc . cmdsize ) { if ( off > bin -> size || off + sizeof ( struct load_command ) > bin -> size ) { bprintf ( ""mach0:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>command\\n"" ) ; return false ; } len = r_buf_read_at ( bin -> b , off , loadc , sizeof ( struct load_command ) ) ; if ( len < 1 ) { bprintf ( ""Error:<S2SV_blank>read<S2SV_blank>(lc)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; return false ; } lc . cmd = r_read_ble32 ( & loadc [ 0 ] , bin -> big_endian ) ; lc . cmdsize = r_read_ble32 ( & loadc [ 4 ] , bin -> big_endian ) ; if ( lc . cmdsize < 1 || off + lc . cmdsize > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>mach0_header<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>cmdsize<1.\\n"" , i ) ; break ; } sdb_num_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.offset"" , i ) , off , 0 ) ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.format"" , i ) , ""xd<S2SV_blank>cmd<S2SV_blank>size"" , 0 ) ; switch ( lc . cmd ) { case LC_DATA_IN_CODE : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""data_in_code"" , 0 ) ; break ; case LC_RPATH : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""rpath"" , 0 ) ; break ; case LC_SEGMENT_64 : case LC_SEGMENT : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""segment"" , 0 ) ; bin -> nsegs ++ ; if ( ! parse_segments ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>segment\\n"" ) ; bin -> nsegs -- ; return false ; } break ; case LC_SYMTAB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""symtab"" , 0 ) ; if ( ! parse_symtab ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>symtab\\n"" ) ; return false ; } break ; case LC_DYSYMTAB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dysymtab"" , 0 ) ; if ( ! parse_dysymtab ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>dysymtab\\n"" ) ; return false ; } break ; case LC_DYLIB_CODE_SIGN_DRS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylib_code_sign_drs"" , 0 ) ; break ; case LC_VERSION_MIN_MACOSX : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_macosx"" , 0 ) ; bin -> os = 1 ; break ; case LC_VERSION_MIN_IPHONEOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_iphoneos"" , 0 ) ; bin -> os = 2 ; break ; case LC_VERSION_MIN_TVOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_tvos"" , 0 ) ; bin -> os = 4 ; break ; case LC_VERSION_MIN_WATCHOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_watchos"" , 0 ) ; bin -> os = 3 ; break ; case LC_UUID : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""uuid"" , 0 ) ; { struct uuid_command uc = { 0 } ; if ( off + sizeof ( struct uuid_command ) > bin -> size ) { bprintf ( ""UUID<S2SV_blank>out<S2SV_blank>of<S2SV_blank>obunds\\n"" ) ; return false ; } if ( r_buf_fread_at ( bin -> b , off , ( ut8 * ) & uc , ""24c"" , 1 ) != - 1 ) { char key [ 128 ] ; char val [ 128 ] ; snprintf ( key , sizeof ( key ) - 1 , ""uuid.%d"" , bin -> uuidn ++ ) ; r_hex_bin2str ( ( ut8 * ) & uc . uuid , 16 , val ) ; sdb_set ( bin -> kv , key , val , 0 ) ; } } break ; case LC_ENCRYPTION_INFO_64 : case LC_ENCRYPTION_INFO : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""encryption_info"" , 0 ) ; { struct MACH0_ ( encryption_info_command ) eic = { 0 } ; ut8 seic [ sizeof ( struct MACH0_ ( encryption_info_command ) ) ] = { 0 } ; if ( off + sizeof ( struct MACH0_ ( encryption_info_command ) ) > bin -> size ) { bprintf ( ""encryption<S2SV_blank>info<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return false ; } if ( r_buf_read_at ( bin -> b , off , seic , sizeof ( struct MACH0_ ( encryption_info_command ) ) ) != - 1 ) { eic . cmd = r_read_ble32 ( & seic [ 0 ] , bin -> big_endian ) ; eic . cmdsize = r_read_ble32 ( & seic [ 4 ] , bin -> big_endian ) ; eic . cryptoff = r_read_ble32 ( & seic [ 8 ] , bin -> big_endian ) ; eic . cryptsize = r_read_ble32 ( & seic [ 12 ] , bin -> big_endian ) ; eic . cryptid = r_read_ble32 ( & seic [ 16 ] , bin -> big_endian ) ; bin -> has_crypto = eic . cryptid ; sdb_set ( bin -> kv , ""crypto"" , ""true"" , 0 ) ; sdb_num_set ( bin -> kv , ""cryptid"" , eic . cryptid , 0 ) ; sdb_num_set ( bin -> kv , ""cryptoff"" , eic . cryptoff , 0 ) ; sdb_num_set ( bin -> kv , ""cryptsize"" , eic . cryptsize , 0 ) ; sdb_num_set ( bin -> kv , ""cryptheader"" , off , 0 ) ; } } break ; case LC_LOAD_DYLINKER : { sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylinker"" , 0 ) ; free ( bin -> intrp ) ; bin -> intrp = NULL ; struct dylinker_command dy = { 0 } ; ut8 sdy [ sizeof ( struct dylinker_command ) ] = { 0 } ; if ( off + sizeof ( struct dylinker_command ) > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>parse<S2SV_blank>dylinker<S2SV_blank>command\\n"" ) ; return false ; } if ( r_buf_read_at ( bin -> b , off , sdy , sizeof ( struct dylinker_command ) ) == - 1 ) { bprintf ( ""Warning:<S2SV_blank>read<S2SV_blank>(LC_DYLD_INFO)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; } else { dy . cmd = r_read_ble32 ( & sdy [ 0 ] , bin -> big_endian ) ; dy . cmdsize = r_read_ble32 ( & sdy [ 4 ] , bin -> big_endian ) ; dy . name = r_read_ble32 ( & sdy [ 8 ] , bin -> big_endian ) ; int len = dy . cmdsize ; char * buf = malloc ( len + 1 ) ; if ( buf ) { r_buf_read_at ( bin -> b , off + 0xc , ( ut8 * ) buf , len ) ; buf [ len ] = 0 ; free ( bin -> intrp ) ; bin -> intrp = buf ; } } } break ; case LC_MAIN : { struct { ut64 eo ; ut64 ss ; } ep = { 0 } ; ut8 sep [ 2 * sizeof ( ut64 ) ] = { 0 } ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""main"" , 0 ) ; if ( ! is_first_thread ) { bprintf ( ""Error:<S2SV_blank>LC_MAIN<S2SV_blank>with<S2SV_blank>other<S2SV_blank>threads\\n"" ) ; return false ; } if ( off + 8 > bin -> size || off + sizeof ( ep ) > bin -> size ) { bprintf ( ""invalid<S2SV_blank>command<S2SV_blank>size<S2SV_blank>for<S2SV_blank>main\\n"" ) ; return false ; } r_buf_read_at ( bin -> b , off + 8 , sep , 2 * sizeof ( ut64 ) ) ; ep . eo = r_read_ble64 ( & sep [ 0 ] , bin -> big_endian ) ; ep . ss = r_read_ble64 ( & sep [ 8 ] , bin -> big_endian ) ; bin -> entry = ep . eo ; bin -> main_cmd = lc ; sdb_num_set ( bin -> kv , ""mach0.entry.offset"" , off + 8 , 0 ) ; sdb_num_set ( bin -> kv , ""stacksize"" , ep . ss , 0 ) ; is_first_thread = false ; } break ; case LC_UNIXTHREAD : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""unixthread"" , 0 ) ; if ( ! is_first_thread ) { bprintf ( ""Error:<S2SV_blank>LC_UNIXTHREAD<S2SV_blank>with<S2SV_blank>other<S2SV_blank>threads\\n"" ) ; return false ; } case LC_THREAD : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""thread"" , 0 ) ; if ( ! parse_thread ( bin , & lc , off , is_first_thread ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>thread\\n"" ) ; return false ; } is_first_thread = false ; break ; case LC_LOAD_DYLIB : case LC_LOAD_WEAK_DYLIB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""load_dylib"" , 0 ) ; bin -> nlibs ++ ; if ( ! parse_dylib ( bin , off ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dylib\\n"" ) ; bin -> nlibs -- ; return false ; } break ; case LC_DYLD_INFO : case LC_DYLD_INFO_ONLY : { ut8 dyldi [ sizeof ( struct dyld_info_command ) ] = { 0 } ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dyld_info"" , 0 ) ;  bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ;   if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) {  bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\n"" ) ;  free ( bin -> dyld_info ) ;  return false ; } if ( r_buf_read_at ( bin -> b , off , dyldi , sizeof ( struct dyld_info_command ) ) == - 1 ) { free ( bin -> dyld_info ) ; bin -> dyld_info = NULL ; bprintf ( ""Error:<S2SV_blank>read<S2SV_blank>(LC_DYLD_INFO)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; } else { bin -> dyld_info -> cmd = r_read_ble32 ( & dyldi [ 0 ] , bin -> big_endian ) ; bin -> dyld_info -> cmdsize = r_read_ble32 ( & dyldi [ 4 ] , bin -> big_endian ) ; bin -> dyld_info -> rebase_off = r_read_ble32 ( & dyldi [ 8 ] , bin -> big_endian ) ; bin -> dyld_info -> rebase_size = r_read_ble32 ( & dyldi [ 12 ] , bin -> big_endian ) ; bin -> dyld_info -> bind_off = r_read_ble32 ( & dyldi [ 16 ] , bin -> big_endian ) ; bin -> dyld_info -> bind_size = r_read_ble32 ( & dyldi [ 20 ] , bin -> big_endian ) ; bin -> dyld_info -> weak_bind_off = r_read_ble32 ( & dyldi [ 24 ] , bin -> big_endian ) ; bin -> dyld_info -> weak_bind_size = r_read_ble32 ( & dyldi [ 28 ] , bin -> big_endian ) ; bin -> dyld_info -> lazy_bind_off = r_read_ble32 ( & dyldi [ 32 ] , bin -> big_endian ) ; bin -> dyld_info -> lazy_bind_size = r_read_ble32 ( & dyldi [ 36 ] , bin -> big_endian ) ; bin -> dyld_info -> export_off = r_read_ble32 ( & dyldi [ 40 ] , bin -> big_endian ) ; bin -> dyld_info -> export_size = r_read_ble32 ( & dyldi [ 44 ] , bin -> big_endian ) ; } }  break ;  case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""signature"" , 0 ) ; break ; case LC_SOURCE_VERSION : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version"" , 0 ) ; break ; case LC_SEGMENT_SPLIT_INFO : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""split_info"" , 0 ) ; break ; case LC_FUNCTION_STARTS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""function_starts"" , 0 ) ; if ( ! parse_function_starts ( bin , off ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>LC_FUNCTION_STARTS\\n"" ) ; } break ; case LC_REEXPORT_DYLIB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylib"" , 0 ) ; break ; default : break ; } } return true ; }","}break ;case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ;",2633
662,"buggy line: COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;cwe id:CWE-000context: void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""usage:<S2SV_blank>condump<S2SV_blank><filename>\\n"" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ;  COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;  f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( ""ERROR:<S2SV_blank>couldn\'t<S2SV_blank>open<S2SV_blank>%s.\\n"" , filename ) ; return ; } Com_Printf ( ""Dumped<S2SV_blank>console<S2SV_blank>text<S2SV_blank>to<S2SV_blank>%s.\\n"" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != '<S2SV_blank>' ) break ; if ( x != con . linewidth ) break ; } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == '<S2SV_blank>' ) buffer [ x ] = 0 ; else break ; } # ifdef _WIN32 Q_strcat ( buffer , bufferlen , ""\\r\\n"" ) ; # else Q_strcat ( buffer , bufferlen , ""\\n"" ) ; # endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",2634
663,"buggy line: else {vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}cwe id:CWE-119context: void vp8_dequant_idct_add_y_block_c ( short * q , short * dq , unsigned char * dst , int stride , char * eobs ) { int i , j ; for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) { if ( * eobs ++ > 1 ) vp8_dequant_idct_add_c ( q , dq , dst , stride ) ; else { vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ;  vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;  } q += 16 ; dst += 4 ; } dst += 4 * stride - 16 ; } }","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",2635
664,"buggy line: unix_state_double_unlock ( sk , other ) ;if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ;cwe id:CWE-000context: static int unix_dgram_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct sockaddr_un * sunaddr = ( struct sockaddr_un * ) addr ; struct sock * other ; unsigned int hash ; int err ; if ( addr -> sa_family != AF_UNSPEC ) { err = unix_mkname ( sunaddr , alen , & hash ) ; if ( err < 0 ) goto out ; alen = err ; if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! unix_sk ( sk ) -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; restart : other = unix_find_other ( net , sunaddr , alen , sock -> type , hash , & err ) ; if ( ! other ) goto out ; unix_state_double_lock ( sk , other ) ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; goto restart ; } err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } else { other = NULL ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) ) { struct sock * old_peer = unix_peer ( sk ) ; unix_peer ( sk ) = other ;  unix_state_double_unlock ( sk , other ) ;  if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ; sock_put ( old_peer ) ; } else { unix_peer ( sk ) = other ; unix_state_double_unlock ( sk , other ) ; } return 0 ; out_unlock : unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; out : return err ; }","unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;unix_state_double_unlock ( sk , other ) ;if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ;",2636
665,"buggy line: void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) {bloc = * offset ;while ( node && node -> symbol == INTERNAL_NODE ) {if ( get_bit ( fin ) ) {cwe id:CWE-119context:  void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) {  bloc = * offset ;  while ( node && node -> symbol == INTERNAL_NODE ) {  if ( get_bit ( fin ) ) { node = node -> right ; } else { node = node -> left ; } } if ( ! node ) { * ch = 0 ; return ; } * ch = node -> symbol ; * offset = bloc ; }","void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset , int maxoffset ) {bloc = * offset ;while ( node && node -> symbol == INTERNAL_NODE ) {if ( bloc >= maxoffset ) {* ch = 0 ;* offset = maxoffset + 1 ;return ;}if ( get_bit ( fin ) ) {",2637
666,"buggy line: if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;cwe id:CWE-000context: OM_uint32 kg_unseal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int * conf_state , gss_qop_t * qop_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; OM_uint32 code ; ctx = ( krb5_gss_ctx_id_rec * ) context_handle ;  if ( ! ctx -> established ) {  * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_STREAM ) != NULL ) { code = kg_unseal_stream_iov ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } else { code = kg_unseal_iov_token ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } return code ; }",if ( ctx -> terminated || ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,2638
667,"buggy line: if ( enable_apicv ) {for ( msr = 0x800 ;cwe id:CWE-264context: static __init int hardware_setup ( void ) { int r = - ENOMEM , i , msr ; rdmsrl_safe ( MSR_EFER , & host_efer ) ; for ( i = 0 ; i < ARRAY_SIZE ( vmx_msr_index ) ; ++ i ) kvm_define_shared_msr ( i , vmx_msr_index [ i ] ) ; vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_a ) return r ; vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_b ) goto out ; vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy ) goto out1 ; vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy_x2apic ) goto out2 ; vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode ) goto out3 ; vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode_x2apic ) goto out4 ; if ( nested ) { vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_nested ) goto out5 ; } vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmread_bitmap ) goto out6 ; vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmwrite_bitmap ) goto out7 ; memset ( vmx_vmread_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_vmwrite_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_io_bitmap_a , 0xff , PAGE_SIZE ) ; clear_bit ( 0x80 , vmx_io_bitmap_a ) ; memset ( vmx_io_bitmap_b , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_legacy , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_longmode , 0xff , PAGE_SIZE ) ; if ( nested ) memset ( vmx_msr_bitmap_nested , 0xff , PAGE_SIZE ) ; if ( setup_vmcs_config ( & vmcs_config ) < 0 ) { r = - EIO ; goto out8 ; } if ( boot_cpu_has ( X86_FEATURE_NX ) ) kvm_enable_efer_bits ( EFER_NX ) ; if ( ! cpu_has_vmx_vpid ( ) ) enable_vpid = 0 ; if ( ! cpu_has_vmx_shadow_vmcs ( ) ) enable_shadow_vmcs = 0 ; if ( enable_shadow_vmcs ) init_vmcs_shadow_fields ( ) ; if ( ! cpu_has_vmx_ept ( ) || ! cpu_has_vmx_ept_4levels ( ) ) { enable_ept = 0 ; enable_unrestricted_guest = 0 ; enable_ept_ad_bits = 0 ; } if ( ! cpu_has_vmx_ept_ad_bits ( ) ) enable_ept_ad_bits = 0 ; if ( ! cpu_has_vmx_unrestricted_guest ( ) ) enable_unrestricted_guest = 0 ; if ( ! cpu_has_vmx_flexpriority ( ) ) flexpriority_enabled = 0 ; if ( ! flexpriority_enabled ) kvm_x86_ops -> set_apic_access_page_addr = NULL ; if ( ! cpu_has_vmx_tpr_shadow ( ) ) kvm_x86_ops -> update_cr8_intercept = NULL ; if ( enable_ept && ! cpu_has_vmx_ept_2m_page ( ) ) kvm_disable_largepages ( ) ; if ( ! cpu_has_vmx_ple ( ) ) ple_gap = 0 ; if ( ! cpu_has_vmx_apicv ( ) ) enable_apicv = 0 ; if ( cpu_has_vmx_tsc_scaling ( ) ) { kvm_has_tsc_control = true ; kvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX ; kvm_tsc_scaling_ratio_frac_bits = 48 ; } vmx_disable_intercept_for_msr ( MSR_FS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_GS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_KERNEL_GS_BASE , true ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_CS , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_ESP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_EIP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_BNDCFGS , true ) ; memcpy ( vmx_msr_bitmap_legacy_x2apic , vmx_msr_bitmap_legacy , PAGE_SIZE ) ; memcpy ( vmx_msr_bitmap_longmode_x2apic , vmx_msr_bitmap_longmode , PAGE_SIZE ) ; set_bit ( 0 , vmx_vpid_bitmap ) ;  if ( enable_apicv ) {  for ( msr = 0x800 ; msr <= 0x8ff ; msr ++ ) vmx_disable_intercept_msr_read_x2apic ( msr ) ; vmx_enable_intercept_msr_read_x2apic ( 0x802 ) ; vmx_enable_intercept_msr_read_x2apic ( 0x839 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x808 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x80b ) ; vmx_disable_intercept_msr_write_x2apic ( 0x83f ) ;  }  if ( enable_ept ) { kvm_mmu_set_mask_ptes ( 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_ACCESS_BIT : 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_DIRTY_BIT : 0ull , 0ull , VMX_EPT_EXECUTABLE_MASK ) ; ept_set_mmio_spte_mask ( ) ; kvm_enable_tdp ( ) ; } else kvm_disable_tdp ( ) ; update_ple_window_actual_max ( ) ; if ( ! enable_ept || ! enable_ept_ad_bits || ! cpu_has_vmx_pml ( ) ) enable_pml = 0 ; if ( ! enable_pml ) { kvm_x86_ops -> slot_enable_log_dirty = NULL ; kvm_x86_ops -> slot_disable_log_dirty = NULL ; kvm_x86_ops -> flush_log_dirty = NULL ; kvm_x86_ops -> enable_log_dirty_pt_masked = NULL ; } kvm_set_posted_intr_wakeup_handler ( wakeup_handler ) ; return alloc_kvm_area ( ) ; out8 : free_page ( ( unsigned long ) vmx_vmwrite_bitmap ) ; out7 : free_page ( ( unsigned long ) vmx_vmread_bitmap ) ; out6 : if ( nested ) free_page ( ( unsigned long ) vmx_msr_bitmap_nested ) ; out5 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode_x2apic ) ; out4 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode ) ; out3 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy_x2apic ) ; out2 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy ) ; out1 : free_page ( ( unsigned long ) vmx_io_bitmap_b ) ; out : free_page ( ( unsigned long ) vmx_io_bitmap_a ) ; return r ; }",for ( msr = 0x800 ;,2639
668,"buggy line: }if ( enable_ept ) {cwe id:CWE-264context: static __init int hardware_setup ( void ) { int r = - ENOMEM , i , msr ; rdmsrl_safe ( MSR_EFER , & host_efer ) ; for ( i = 0 ; i < ARRAY_SIZE ( vmx_msr_index ) ; ++ i ) kvm_define_shared_msr ( i , vmx_msr_index [ i ] ) ; vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_a ) return r ; vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_b ) goto out ; vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy ) goto out1 ; vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy_x2apic ) goto out2 ; vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode ) goto out3 ; vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode_x2apic ) goto out4 ; if ( nested ) { vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_nested ) goto out5 ; } vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmread_bitmap ) goto out6 ; vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmwrite_bitmap ) goto out7 ; memset ( vmx_vmread_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_vmwrite_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_io_bitmap_a , 0xff , PAGE_SIZE ) ; clear_bit ( 0x80 , vmx_io_bitmap_a ) ; memset ( vmx_io_bitmap_b , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_legacy , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_longmode , 0xff , PAGE_SIZE ) ; if ( nested ) memset ( vmx_msr_bitmap_nested , 0xff , PAGE_SIZE ) ; if ( setup_vmcs_config ( & vmcs_config ) < 0 ) { r = - EIO ; goto out8 ; } if ( boot_cpu_has ( X86_FEATURE_NX ) ) kvm_enable_efer_bits ( EFER_NX ) ; if ( ! cpu_has_vmx_vpid ( ) ) enable_vpid = 0 ; if ( ! cpu_has_vmx_shadow_vmcs ( ) ) enable_shadow_vmcs = 0 ; if ( enable_shadow_vmcs ) init_vmcs_shadow_fields ( ) ; if ( ! cpu_has_vmx_ept ( ) || ! cpu_has_vmx_ept_4levels ( ) ) { enable_ept = 0 ; enable_unrestricted_guest = 0 ; enable_ept_ad_bits = 0 ; } if ( ! cpu_has_vmx_ept_ad_bits ( ) ) enable_ept_ad_bits = 0 ; if ( ! cpu_has_vmx_unrestricted_guest ( ) ) enable_unrestricted_guest = 0 ; if ( ! cpu_has_vmx_flexpriority ( ) ) flexpriority_enabled = 0 ; if ( ! flexpriority_enabled ) kvm_x86_ops -> set_apic_access_page_addr = NULL ; if ( ! cpu_has_vmx_tpr_shadow ( ) ) kvm_x86_ops -> update_cr8_intercept = NULL ; if ( enable_ept && ! cpu_has_vmx_ept_2m_page ( ) ) kvm_disable_largepages ( ) ; if ( ! cpu_has_vmx_ple ( ) ) ple_gap = 0 ; if ( ! cpu_has_vmx_apicv ( ) ) enable_apicv = 0 ; if ( cpu_has_vmx_tsc_scaling ( ) ) { kvm_has_tsc_control = true ; kvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX ; kvm_tsc_scaling_ratio_frac_bits = 48 ; } vmx_disable_intercept_for_msr ( MSR_FS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_GS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_KERNEL_GS_BASE , true ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_CS , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_ESP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_EIP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_BNDCFGS , true ) ; memcpy ( vmx_msr_bitmap_legacy_x2apic , vmx_msr_bitmap_legacy , PAGE_SIZE ) ; memcpy ( vmx_msr_bitmap_longmode_x2apic , vmx_msr_bitmap_longmode , PAGE_SIZE ) ; set_bit ( 0 , vmx_vpid_bitmap ) ;  if ( enable_apicv ) {  for ( msr = 0x800 ; msr <= 0x8ff ; msr ++ ) vmx_disable_intercept_msr_read_x2apic ( msr ) ; vmx_enable_intercept_msr_read_x2apic ( 0x802 ) ; vmx_enable_intercept_msr_read_x2apic ( 0x839 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x808 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x80b ) ; vmx_disable_intercept_msr_write_x2apic ( 0x83f ) ;  }  if ( enable_ept ) { kvm_mmu_set_mask_ptes ( 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_ACCESS_BIT : 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_DIRTY_BIT : 0ull , 0ull , VMX_EPT_EXECUTABLE_MASK ) ; ept_set_mmio_spte_mask ( ) ; kvm_enable_tdp ( ) ; } else kvm_disable_tdp ( ) ; update_ple_window_actual_max ( ) ; if ( ! enable_ept || ! enable_ept_ad_bits || ! cpu_has_vmx_pml ( ) ) enable_pml = 0 ; if ( ! enable_pml ) { kvm_x86_ops -> slot_enable_log_dirty = NULL ; kvm_x86_ops -> slot_disable_log_dirty = NULL ; kvm_x86_ops -> flush_log_dirty = NULL ; kvm_x86_ops -> enable_log_dirty_pt_masked = NULL ; } kvm_set_posted_intr_wakeup_handler ( wakeup_handler ) ; return alloc_kvm_area ( ) ; out8 : free_page ( ( unsigned long ) vmx_vmwrite_bitmap ) ; out7 : free_page ( ( unsigned long ) vmx_vmread_bitmap ) ; out6 : if ( nested ) free_page ( ( unsigned long ) vmx_msr_bitmap_nested ) ; out5 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode_x2apic ) ; out4 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode ) ; out3 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy_x2apic ) ; out2 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy ) ; out1 : free_page ( ( unsigned long ) vmx_io_bitmap_b ) ; out : free_page ( ( unsigned long ) vmx_io_bitmap_a ) ; return r ; }",if ( enable_ept ) {,2639
669,"buggy line: state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ;if ( ! state -> frame [ 0 ] ) {init_func_state ( env , state -> frame [ 0 ] , BPF_MAIN_FUNC , 0 , 0 ) ;for ( ;;) {struct bpf_insn * insn ;u8 class ;int err ;if ( env -> insn_idx >= insn_cnt ) {verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\\verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\\return - E2BIG ;}err = is_state_visited ( env , env -> insn_idx ) ;if ( do_print_state )  verbose ( env , ""\\\else verbose ( env , ""%d:<S2SV_blank>safe\\\cwe id:CWE-189context: static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len , i ; int insn_processed = 0 ; bool do_print_state = false ; env -> prev_linfo = NULL ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; state -> curframe = 0 ;  state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ;  if ( ! state -> frame [ 0 ] ) { kfree ( state ) ; return - ENOMEM ; } env -> cur_state = state ; init_func_state ( env , state -> frame [ 0 ] , BPF_MAIN_FUNC , 0 , 0 ) ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( env -> insn_idx >= insn_cnt ) { verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , env -> insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ env -> insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , env -> insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state )  verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" ,   env -> prev_insn_idx , env -> insn_idx ) ;  else verbose ( env , ""%d:<S2SV_blank>safe\\n"" , env -> insn_idx ) ; } goto process_bpf_exit ; } if ( signal_pending ( current ) ) return - EAGAIN ; if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , ""%d:"" , env -> insn_idx ) ; else  verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" ,   env -> prev_insn_idx , env -> insn_idx ) ;  print_verifier_state ( env , state -> frame [ state -> curframe ] ) ; do_print_state = false ; } if ( env -> log . level ) { const struct bpf_insn_cbs cbs = { . cb_print = verbose , . private_data = env , } ; verbose_linfo ( env , env -> insn_idx , "";<S2SV_blank>"" ) ; verbose ( env , ""%d:<S2SV_blank>"" , env -> insn_idx ) ; print_bpf_insn ( & cbs , insn , env -> allow_ptr_leaks ) ; } if ( bpf_prog_is_dev_bound ( env -> prog -> aux ) ) { err = bpf_prog_offload_verify_insn ( env , env -> insn_idx , env -> prev_insn_idx ) ; if ( err ) return err ; } regs = cur_regs ( env ) ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg , false ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( reg_type_mismatch ( src_reg_type , * prev_src_type ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , env -> insn_idx , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg , false ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( reg_type_mismatch ( dst_reg_type , * prev_dst_type ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_ctx_reg ( env , insn -> dst_reg ) ) { verbose ( env , ""BPF_ST<S2SV_blank>stores<S2SV_blank>into<S2SV_blank>R%d<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n"" , insn -> dst_reg , reg_type_str [ reg_state ( env , insn -> dst_reg ) -> type ] ) ; return - EACCES ; } err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 , false ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || ( insn -> src_reg != BPF_REG_0 && insn -> src_reg != BPF_PSEUDO_CALL ) || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( insn -> src_reg == BPF_PSEUDO_CALL ) err = check_func_call ( env , insn , & env -> insn_idx ) ; else err = check_helper_call ( env , insn -> imm , env -> insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } env -> insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( state -> curframe ) { env -> prev_insn_idx = env -> insn_idx ; err = prepare_func_exit ( env , & env -> insn_idx ) ; if ( err ) return err ; do_print_state = true ; continue ; } err = check_reference_leak ( env ) ; if ( err ) return err ; err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & env -> prev_insn_idx , & env -> insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & env -> insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; } else { verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } } else { verbose ( env , ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , class ) ; return - EINVAL ; } env -> insn_idx ++ ; } verbose ( env , ""processed<S2SV_blank>%d<S2SV_blank>insns<S2SV_blank>(limit<S2SV_blank>%d),<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>"" , insn_processed , BPF_COMPLEXITY_LIMIT_INSNS ) ; for ( i = 0 ; i < env -> subprog_cnt ; i ++ ) { u32 depth = env -> subprog_info [ i ] . stack_depth ; verbose ( env , ""%d"" , depth ) ; if ( i + 1 < env -> subprog_cnt ) verbose ( env , ""+"" ) ; } verbose ( env , ""\\n"" ) ; env -> prog -> aux -> stack_depth = env -> subprog_info [ 0 ] . stack_depth ; return 0 ; }","state -> speculative = false ;state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ;if ( ! state -> frame [ 0 ] ) {init_func_state ( env , ""\\\verbose ( env , ""\\\if ( do_print_state ) verbose ( env , ""\\\else verbose ( env , ""%d:<S2SV_blank>safe\\\",2640
670,"buggy line: else  verbose ( env , ""\\\print_verifier_state ( env , state -> frame [ state -> curframe ] ) ;cwe id:CWE-189context: static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len , i ; int insn_processed = 0 ; bool do_print_state = false ; env -> prev_linfo = NULL ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; state -> curframe = 0 ;  state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ;  if ( ! state -> frame [ 0 ] ) { kfree ( state ) ; return - ENOMEM ; } env -> cur_state = state ; init_func_state ( env , state -> frame [ 0 ] , BPF_MAIN_FUNC , 0 , 0 ) ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( env -> insn_idx >= insn_cnt ) { verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , env -> insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ env -> insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , env -> insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state )  verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" ,   env -> prev_insn_idx , env -> insn_idx ) ;  else verbose ( env , ""%d:<S2SV_blank>safe\\n"" , env -> insn_idx ) ; } goto process_bpf_exit ; } if ( signal_pending ( current ) ) return - EAGAIN ; if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , ""%d:"" , env -> insn_idx ) ; else  verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" ,   env -> prev_insn_idx , env -> insn_idx ) ;  print_verifier_state ( env , state -> frame [ state -> curframe ] ) ; do_print_state = false ; } if ( env -> log . level ) { const struct bpf_insn_cbs cbs = { . cb_print = verbose , . private_data = env , } ; verbose_linfo ( env , env -> insn_idx , "";<S2SV_blank>"" ) ; verbose ( env , ""%d:<S2SV_blank>"" , env -> insn_idx ) ; print_bpf_insn ( & cbs , insn , env -> allow_ptr_leaks ) ; } if ( bpf_prog_is_dev_bound ( env -> prog -> aux ) ) { err = bpf_prog_offload_verify_insn ( env , env -> insn_idx , env -> prev_insn_idx ) ; if ( err ) return err ; } regs = cur_regs ( env ) ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg , false ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( reg_type_mismatch ( src_reg_type , * prev_src_type ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , env -> insn_idx , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg , false ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( reg_type_mismatch ( dst_reg_type , * prev_dst_type ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_ctx_reg ( env , insn -> dst_reg ) ) { verbose ( env , ""BPF_ST<S2SV_blank>stores<S2SV_blank>into<S2SV_blank>R%d<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n"" , insn -> dst_reg , reg_type_str [ reg_state ( env , insn -> dst_reg ) -> type ] ) ; return - EACCES ; } err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 , false ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || ( insn -> src_reg != BPF_REG_0 && insn -> src_reg != BPF_PSEUDO_CALL ) || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( insn -> src_reg == BPF_PSEUDO_CALL ) err = check_func_call ( env , insn , & env -> insn_idx ) ; else err = check_helper_call ( env , insn -> imm , env -> insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } env -> insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( state -> curframe ) { env -> prev_insn_idx = env -> insn_idx ; err = prepare_func_exit ( env , & env -> insn_idx ) ; if ( err ) return err ; do_print_state = true ; continue ; } err = check_reference_leak ( env ) ; if ( err ) return err ; err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & env -> prev_insn_idx , & env -> insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & env -> insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; } else { verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } } else { verbose ( env , ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , class ) ; return - EINVAL ; } env -> insn_idx ++ ; } verbose ( env , ""processed<S2SV_blank>%d<S2SV_blank>insns<S2SV_blank>(limit<S2SV_blank>%d),<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>"" , insn_processed , BPF_COMPLEXITY_LIMIT_INSNS ) ; for ( i = 0 ; i < env -> subprog_cnt ; i ++ ) { u32 depth = env -> subprog_info [ i ] . stack_depth ; verbose ( env , ""%d"" , depth ) ; if ( i + 1 < env -> subprog_cnt ) verbose ( env , ""+"" ) ; } verbose ( env , ""\\n"" ) ; env -> prog -> aux -> stack_depth = env -> subprog_info [ 0 ] . stack_depth ; return 0 ; }","else verbose ( env , ""\\\print_verifier_state ( env , state -> frame [ state -> curframe ] ) ;",2640
671,"buggy line: if ( in ) {dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;dev -> out_pipe = usb_sndbulkpipe ( udev ,  out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;}if ( iso_in ) {cwe id:CWE-476context: static int get_endpoints ( struct usbtest_dev * dev , struct usb_interface * intf ) { int tmp ; struct usb_host_interface * alt ; struct usb_host_endpoint * in , * out ; struct usb_host_endpoint * iso_in , * iso_out ; struct usb_host_endpoint * int_in , * int_out ; struct usb_device * udev ; for ( tmp = 0 ; tmp < intf -> num_altsetting ; tmp ++ ) { unsigned ep ; in = out = NULL ; iso_in = iso_out = NULL ; int_in = int_out = NULL ; alt = intf -> altsetting + tmp ; if ( override_alt >= 0 && override_alt != alt -> desc . bAlternateSetting ) continue ; for ( ep = 0 ; ep < alt -> desc . bNumEndpoints ; ep ++ ) { struct usb_host_endpoint * e ; int edi ; e = alt -> endpoint + ep ; edi = usb_endpoint_dir_in ( & e -> desc ) ; switch ( usb_endpoint_type ( & e -> desc ) ) { case USB_ENDPOINT_XFER_BULK : endpoint_update ( edi , & in , & out , e ) ; continue ; case USB_ENDPOINT_XFER_INT : if ( dev -> info -> intr ) endpoint_update ( edi , & int_in , & int_out , e ) ; continue ; case USB_ENDPOINT_XFER_ISOC : if ( dev -> info -> iso ) endpoint_update ( edi , & iso_in , & iso_out , e ) ; default : continue ; } } if ( ( in && out ) || iso_in || iso_out || int_in || int_out ) goto found ; } return - EINVAL ; found : udev = testdev_to_usbdev ( dev ) ; dev -> info -> alt = alt -> desc . bAlternateSetting ; if ( alt -> desc . bAlternateSetting != 0 ) { tmp = usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ; if ( tmp < 0 ) return tmp ; }  if ( in ) {  dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;  dev -> out_pipe = usb_sndbulkpipe ( udev ,  out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;  }  if ( iso_in ) { dev -> iso_in = & iso_in -> desc ; dev -> in_iso_pipe = usb_rcvisocpipe ( udev , iso_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( iso_out ) { dev -> iso_out = & iso_out -> desc ; dev -> out_iso_pipe = usb_sndisocpipe ( udev , iso_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_in ) { dev -> int_in = & int_in -> desc ; dev -> in_int_pipe = usb_rcvintpipe ( udev , int_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_out ) { dev -> int_out = & int_out -> desc ; dev -> out_int_pipe = usb_sndintpipe ( udev , int_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } return 0 ; }","if ( in ) dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;if ( iso_in ) {",2641
672,"buggy line: if ( flags & MSG_OOB )  goto out ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;cwe id:CWE-200context: static int l2tp_ip_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB )  goto out ;  if ( addr_len ) * addr_len = sizeof ( * sin ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;  }  if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : return err ? err : copied ; }",if ( flags & MSG_OOB ) goto out ;,2642
673,"buggy line: }if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;cwe id:CWE-200context: static int l2tp_ip_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB )  goto out ;  if ( addr_len ) * addr_len = sizeof ( * sin ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;  }  if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : return err ? err : copied ; }","* addr_len = sizeof ( * sin ) ;}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;",2642
674,"buggy line: case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE |  VM_SHARED | VM_MAYSHARE |  VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ;case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE |  VM_SHARED | VM_MAYSHARE |  VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ;cwe id:CWE-399context: int hugepage_madvise ( struct vm_area_struct * vma , unsigned long * vm_flags , int advice ) { switch ( advice ) { case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE |  VM_SHARED | VM_MAYSHARE |  VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ; * vm_flags &= ~ VM_NOHUGEPAGE ; * vm_flags |= VM_HUGEPAGE ; if ( unlikely ( khugepaged_enter_vma_merge ( vma ) ) ) return - ENOMEM ; break ; case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE |  VM_SHARED | VM_MAYSHARE |  VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ; * vm_flags &= ~ VM_HUGEPAGE ; * vm_flags |= VM_NOHUGEPAGE ; break ; } return 0 ; }",case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE | VM_NO_THP ) ) return - EINVAL ;case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE | VM_NO_THP ) ) return - EINVAL ;,2643
675,"buggy line: cwe id:CWE-264context: static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; if ( ret < 0 ) {  ops -> destroy ( dev ) ;  mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; return ret ; } kvm_get_kvm ( kvm ) ; cd -> fd = ret ; return 0 ; }",mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;,2644
676,"buggy line: ops -> destroy ( dev ) ;mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;cwe id:CWE-264context: static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; if ( ret < 0 ) {  ops -> destroy ( dev ) ;  mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; return ret ; } kvm_get_kvm ( kvm ) ; cd -> fd = ret ; return 0 ; }",ops -> destroy ( dev ) ;,2644
677,"buggy line: if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) )  return FALSE ;cwe id:CWE-74context: gboolean flatpak_run_app ( FlatpakDecomposed * app_ref , FlatpakDeploy * app_deploy , FlatpakContext * extra_context , const char * custom_runtime , const char * custom_runtime_version , const char * custom_runtime_commit , int parent_pid , FlatpakRunFlags flags , const char * cwd , const char * custom_command , char * args [ ] , int n_args , int instance_id_fd , char * * instance_dir_out , GCancellable * cancellable , GError * * error ) { g_autoptr ( FlatpakDeploy ) runtime_deploy = NULL ; g_autoptr ( GBytes ) runtime_deploy_data = NULL ; g_autoptr ( GBytes ) app_deploy_data = NULL ; g_autoptr ( GFile ) app_files = NULL ; g_autoptr ( GFile ) runtime_files = NULL ; g_autoptr ( GFile ) bin_ldconfig = NULL ; g_autoptr ( GFile ) app_id_dir = NULL ; g_autoptr ( GFile ) real_app_id_dir = NULL ; g_autofree char * default_runtime_pref = NULL ; g_autoptr ( FlatpakDecomposed ) default_runtime = NULL ; g_autofree char * default_command = NULL ; g_autoptr ( GKeyFile ) metakey = NULL ; g_autoptr ( GKeyFile ) runtime_metakey = NULL ; g_autoptr ( FlatpakBwrap ) bwrap = NULL ; const char * command = ""/bin/sh"" ; g_autoptr ( GError ) my_error = NULL ; g_autoptr ( FlatpakDecomposed ) runtime_ref = NULL ; int i ; g_autoptr ( GPtrArray ) previous_app_id_dirs = NULL ; g_autofree char * app_id = NULL ; g_autofree char * app_arch = NULL ; g_autofree char * app_info_path = NULL ; g_autofree char * instance_id_host_dir = NULL ; g_autoptr ( FlatpakContext ) app_context = NULL ; g_autoptr ( FlatpakContext ) overrides = NULL ; g_autoptr ( FlatpakExports ) exports = NULL ; g_autofree char * commandline = NULL ; g_autofree char * doc_mount_path = NULL ; g_autofree char * app_extensions = NULL ; g_autofree char * runtime_extensions = NULL ; g_autofree char * checksum = NULL ; int ld_so_fd = - 1 ; g_autoptr ( GFile ) runtime_ld_so_conf = NULL ; gboolean generate_ld_so_conf = TRUE ; gboolean use_ld_so_cache = TRUE ; gboolean sandboxed = ( flags & FLATPAK_RUN_FLAG_SANDBOX ) != 0 ; gboolean parent_expose_pids = ( flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS ) != 0 ; gboolean parent_share_pids = ( flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS ) != 0 ; struct stat s ; if ( ! check_sudo ( error ) ) return FALSE ; app_id = flatpak_decomposed_dup_id ( app_ref ) ; app_arch = flatpak_decomposed_dup_arch ( app_ref ) ; if ( ! check_parental_controls ( app_ref , app_deploy , cancellable , error ) ) return FALSE ; bwrap = flatpak_bwrap_new ( NULL ) ; flatpak_bwrap_add_arg ( bwrap , flatpak_get_bwrap ( ) ) ; if ( app_deploy == NULL ) { g_assert ( flatpak_decomposed_is_runtime ( app_ref ) ) ; default_runtime_pref = flatpak_decomposed_dup_pref ( app_ref ) ; } else { const gchar * key ; app_deploy_data = flatpak_deploy_get_deploy_data ( app_deploy , FLATPAK_DEPLOY_VERSION_ANY , cancellable , error ) ; if ( app_deploy_data == NULL ) return FALSE ; if ( ( flags & FLATPAK_RUN_FLAG_DEVEL ) != 0 ) key = FLATPAK_METADATA_KEY_SDK ; else key = FLATPAK_METADATA_KEY_RUNTIME ; metakey = flatpak_deploy_get_metadata ( app_deploy ) ; default_runtime_pref = g_key_file_get_string ( metakey , FLATPAK_METADATA_GROUP_APPLICATION , key , & my_error ) ; if ( my_error ) { g_propagate_error ( error , g_steal_pointer ( & my_error ) ) ; return FALSE ; } } default_runtime = flatpak_decomposed_new_from_pref ( FLATPAK_KINDS_RUNTIME , default_runtime_pref , error ) ; if ( default_runtime == NULL ) return FALSE ; if ( custom_runtime != NULL || custom_runtime_version != NULL ) { g_auto ( GStrv ) custom_runtime_parts = NULL ; const char * custom_runtime_id = NULL ; const char * custom_runtime_arch = NULL ; if ( custom_runtime ) { custom_runtime_parts = g_strsplit ( custom_runtime , ""/"" , 0 ) ; for ( i = 0 ; i < 3 && custom_runtime_parts [ i ] != NULL ; i ++ ) { if ( strlen ( custom_runtime_parts [ i ] ) > 0 ) { if ( i == 0 ) custom_runtime_id = custom_runtime_parts [ i ] ; if ( i == 1 ) custom_runtime_arch = custom_runtime_parts [ i ] ; if ( i == 2 && custom_runtime_version == NULL ) custom_runtime_version = custom_runtime_parts [ i ] ; } } } runtime_ref = flatpak_decomposed_new_from_decomposed ( default_runtime , FLATPAK_KINDS_RUNTIME , custom_runtime_id , custom_runtime_arch , custom_runtime_version , error ) ; if ( runtime_ref == NULL ) return FALSE ; } else runtime_ref = flatpak_decomposed_ref ( default_runtime ) ; runtime_deploy = flatpak_find_deploy_for_ref ( flatpak_decomposed_get_ref ( runtime_ref ) , custom_runtime_commit , NULL , cancellable , error ) ; if ( runtime_deploy == NULL ) return FALSE ; runtime_deploy_data = flatpak_deploy_get_deploy_data ( runtime_deploy , FLATPAK_DEPLOY_VERSION_ANY , cancellable , error ) ; if ( runtime_deploy_data == NULL ) return FALSE ; runtime_metakey = flatpak_deploy_get_metadata ( runtime_deploy ) ; app_context = flatpak_app_compute_permissions ( metakey , runtime_metakey , error ) ; if ( app_context == NULL ) return FALSE ; if ( app_deploy != NULL ) { overrides = flatpak_deploy_get_overrides ( app_deploy ) ; flatpak_context_merge ( app_context , overrides ) ; } if ( sandboxed ) flatpak_context_make_sandboxed ( app_context ) ; if ( extra_context ) flatpak_context_merge ( app_context , extra_context ) ; runtime_files = flatpak_deploy_get_files ( runtime_deploy ) ; bin_ldconfig = g_file_resolve_relative_path ( runtime_files , ""bin/ldconfig"" ) ; if ( ! g_file_query_exists ( bin_ldconfig , NULL ) ) use_ld_so_cache = FALSE ; if ( app_deploy != NULL ) { g_autofree const char * * previous_ids = NULL ; gsize len = 0 ; gboolean do_migrate ; real_app_id_dir = flatpak_get_data_dir ( app_id ) ; app_files = flatpak_deploy_get_files ( app_deploy ) ; previous_app_id_dirs = g_ptr_array_new_with_free_func ( g_object_unref ) ; previous_ids = flatpak_deploy_data_get_previous_ids ( app_deploy_data , & len ) ; do_migrate = ! g_file_query_exists ( real_app_id_dir , cancellable ) ; for ( i = len - 1 ; i >= 0 ; i -- ) { g_autoptr ( GFile ) previous_app_id_dir = NULL ; g_autoptr ( GFileInfo ) previous_app_id_dir_info = NULL ; g_autoptr ( GError ) local_error = NULL ; previous_app_id_dir = flatpak_get_data_dir ( previous_ids [ i ] ) ; previous_app_id_dir_info = g_file_query_info ( previous_app_id_dir , G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK "","" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , cancellable , & local_error ) ; if ( previous_app_id_dir_info == NULL ) { if ( ! g_error_matches ( local_error , G_IO_ERROR , G_IO_ERROR_NOT_FOUND ) && do_migrate ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>migrate<S2SV_blank>from<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , local_error -> message ) ; do_migrate = FALSE ; } g_clear_error ( & local_error ) ; continue ; } if ( do_migrate ) { do_migrate = FALSE ; if ( ! flatpak_file_rename ( previous_app_id_dir , real_app_id_dir , cancellable , & local_error ) ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>migrate<S2SV_blank>old<S2SV_blank>app<S2SV_blank>data<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>new<S2SV_blank>name<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , app_id , local_error -> message ) ; } else { if ( ! g_file_make_symbolic_link ( previous_app_id_dir , app_id , cancellable , & local_error ) ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>while<S2SV_blank>migrating<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , local_error -> message ) ; } } } g_ptr_array_add ( previous_app_id_dirs , g_steal_pointer ( & previous_app_id_dir ) ) ; } if ( ! flatpak_ensure_data_dir ( real_app_id_dir , cancellable , error ) ) return FALSE ; if ( ! sandboxed ) app_id_dir = g_object_ref ( real_app_id_dir ) ; } flatpak_run_apply_env_default ( bwrap , use_ld_so_cache ) ; flatpak_run_apply_env_vars ( bwrap , app_context ) ; flatpak_run_apply_env_prompt ( bwrap , app_id ) ; if ( real_app_id_dir ) { g_autoptr ( GFile ) sandbox_dir = g_file_get_child ( real_app_id_dir , ""sandbox"" ) ; flatpak_bwrap_set_env ( bwrap , ""FLATPAK_SANDBOX_DIR"" , flatpak_file_get_path_cached ( sandbox_dir ) , TRUE ) ; } flatpak_bwrap_add_args ( bwrap , ""--ro-bind"" , flatpak_file_get_path_cached ( runtime_files ) , ""/usr"" , ""--lock-file"" , ""/usr/.ref"" , NULL ) ; if ( app_files != NULL ) flatpak_bwrap_add_args ( bwrap , ""--ro-bind"" , flatpak_file_get_path_cached ( app_files ) , ""/app"" , ""--lock-file"" , ""/app/.ref"" , NULL ) ; else flatpak_bwrap_add_args ( bwrap , ""--dir"" , ""/app"" , NULL ) ; if ( metakey != NULL && ! flatpak_run_add_extension_args ( bwrap , metakey , app_ref , use_ld_so_cache , & app_extensions , cancellable , error ) ) return FALSE ; if ( ! flatpak_run_add_extension_args ( bwrap , runtime_metakey , runtime_ref , use_ld_so_cache , & runtime_extensions , cancellable , error ) ) return FALSE ; runtime_ld_so_conf = g_file_resolve_relative_path ( runtime_files , ""etc/ld.so.conf"" ) ; if ( lstat ( flatpak_file_get_path_cached ( runtime_ld_so_conf ) , & s ) == 0 ) generate_ld_so_conf = S_ISREG ( s . st_mode ) && s . st_size == 0 ; if ( use_ld_so_cache ) { checksum = calculate_ld_cache_checksum ( app_deploy_data , runtime_deploy_data , app_extensions , runtime_extensions ) ; ld_so_fd = regenerate_ld_cache ( bwrap -> argv , bwrap -> fds , app_id_dir , checksum , runtime_files , generate_ld_so_conf , cancellable , error ) ; if ( ld_so_fd == - 1 ) return FALSE ; flatpak_bwrap_add_fd ( bwrap , ld_so_fd ) ; } flags |= flatpak_context_get_run_flags ( app_context ) ; if ( ! flatpak_run_setup_base_argv ( bwrap , runtime_files , app_id_dir , app_arch , flags , error ) ) return FALSE ; if ( generate_ld_so_conf ) { if ( ! add_ld_so_conf ( bwrap , error ) ) return FALSE ; } if ( ld_so_fd != - 1 ) { flatpak_bwrap_add_arg ( bwrap , ""--ro-bind-data"" ) ; flatpak_bwrap_add_arg_printf ( bwrap , ""%d"" , ld_so_fd ) ; flatpak_bwrap_add_arg ( bwrap , ""/etc/ld.so.cache"" ) ; } if ( ! flatpak_run_add_app_info_args ( bwrap , app_files , app_deploy_data , app_extensions , runtime_files , runtime_deploy_data , runtime_extensions , app_id , flatpak_decomposed_get_branch ( app_ref ) , runtime_ref , app_id_dir , app_context , extra_context , sandboxed , FALSE , flags & FLATPAK_RUN_FLAG_DEVEL , & app_info_path , instance_id_fd , & instance_id_host_dir , error ) ) return FALSE ; if ( ! flatpak_run_add_dconf_args ( bwrap , app_id , metakey , error ) ) return FALSE ; if ( ! sandboxed && ! ( flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL ) ) add_document_portal_args ( bwrap , app_id , & doc_mount_path ) ; if ( ! flatpak_run_add_environment_args ( bwrap , app_info_path , flags , app_id , app_context , app_id_dir , previous_app_id_dirs , & exports , cancellable , error ) ) return FALSE ; if ( ( app_context -> shares & FLATPAK_CONTEXT_SHARED_NETWORK ) != 0 ) flatpak_run_add_resolved_args ( bwrap ) ; flatpak_run_add_journal_args ( bwrap ) ; add_font_path_args ( bwrap ) ; add_icon_path_args ( bwrap ) ; flatpak_bwrap_add_args ( bwrap , ""--symlink"" , ""/app/lib/debug/source"" , ""/run/build"" , ""--symlink"" , ""/usr/lib/debug/source"" , ""/run/build-runtime"" , NULL ) ; if ( cwd ) flatpak_bwrap_add_args ( bwrap , ""--chdir"" , cwd , NULL ) ; if ( parent_expose_pids || parent_share_pids ) { g_autofree char * userns_path = NULL ; g_autofree char * pidns_path = NULL ; g_autofree char * userns2_path = NULL ; int userns_fd , userns2_fd , pidns_fd ; if ( parent_pid == 0 ) return flatpak_fail ( error , ""No<S2SV_blank>parent<S2SV_blank>pid<S2SV_blank>specified"" ) ; userns_path = g_strdup_printf ( ""/proc/%d/root/run/.userns"" , parent_pid ) ; userns_fd = open_namespace_fd_if_needed ( userns_path , ""/proc/self/ns/user"" ) ; if ( userns_fd != - 1 ) { flatpak_bwrap_add_args_data_fd ( bwrap , ""--userns"" , userns_fd , NULL ) ; userns2_path = g_strdup_printf ( ""/proc/%d/ns/user"" , parent_pid ) ; userns2_fd = open_namespace_fd_if_needed ( userns2_path , userns_path ) ; if ( userns2_fd != - 1 ) flatpak_bwrap_add_args_data_fd ( bwrap , ""--userns2"" , userns2_fd , NULL ) ; } pidns_path = g_strdup_printf ( ""/proc/%d/ns/pid"" , parent_pid ) ; pidns_fd = open ( pidns_path , O_RDONLY | O_CLOEXEC ) ; if ( pidns_fd != - 1 ) flatpak_bwrap_add_args_data_fd ( bwrap , ""--pidns"" , pidns_fd , NULL ) ; } if ( custom_command ) { command = custom_command ; } else if ( metakey ) { default_command = g_key_file_get_string ( metakey , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_COMMAND , & my_error ) ; if ( my_error ) { g_propagate_error ( error , g_steal_pointer ( & my_error ) ) ; return FALSE ; } command = default_command ; }  if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) )  return FALSE ; flatpak_bwrap_add_arg ( bwrap , command ) ; if ( ! add_rest_args ( bwrap , app_id , exports , ( flags & FLATPAK_RUN_FLAG_FILE_FORWARDING ) != 0 , doc_mount_path , args , n_args , error ) ) return FALSE ; flatpak_bwrap_finish ( bwrap ) ; commandline = flatpak_quote_argv ( ( const char * * ) bwrap -> argv -> pdata , - 1 ) ; g_debug ( ""Running<S2SV_blank>\'%s\'"" , commandline ) ; if ( ( flags & FLATPAK_RUN_FLAG_BACKGROUND ) != 0 ) { GPid child_pid ; char pid_str [ 64 ] ; g_autofree char * pid_path = NULL ; GSpawnFlags spawn_flags ; spawn_flags = G_SPAWN_SEARCH_PATH ; if ( flags & FLATPAK_RUN_FLAG_DO_NOT_REAP ) spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD ; spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN ;  if ( ! g_spawn_async ( NULL ,  ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return FALSE ; g_snprintf ( pid_str , sizeof ( pid_str ) , ""%d"" , child_pid ) ; pid_path = g_build_filename ( instance_id_host_dir , ""pid"" , NULL ) ; g_file_set_contents ( pid_path , pid_str , - 1 , NULL ) ; } else { char pid_str [ 64 ] ; g_autofree char * pid_path = NULL ; g_snprintf ( pid_str , sizeof ( pid_str ) , ""%d"" , getpid ( ) ) ; pid_path = g_build_filename ( instance_id_host_dir , ""pid"" , NULL ) ; g_file_set_contents ( pid_path , pid_str , - 1 , NULL ) ; flatpak_bwrap_child_setup ( bwrap -> fds , FALSE ) ;  if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 )  { g_set_error_literal ( error , G_IO_ERROR , g_io_error_from_errno ( errno ) , _ ( ""Unable<S2SV_blank>to<S2SV_blank>start<S2SV_blank>app"" ) ) ; return FALSE ; } } if ( instance_dir_out ) * instance_dir_out = g_steal_pointer ( & instance_id_host_dir ) ; return TRUE ; }","flatpak_bwrap_envp_to_args ( bwrap ) ;if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) ) return FALSE ;",2645
678,"buggy line: if ( ! g_spawn_async ( NULL ,  ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return FALSE ;cwe id:CWE-74context: gboolean flatpak_run_app ( FlatpakDecomposed * app_ref , FlatpakDeploy * app_deploy , FlatpakContext * extra_context , const char * custom_runtime , const char * custom_runtime_version , const char * custom_runtime_commit , int parent_pid , FlatpakRunFlags flags , const char * cwd , const char * custom_command , char * args [ ] , int n_args , int instance_id_fd , char * * instance_dir_out , GCancellable * cancellable , GError * * error ) { g_autoptr ( FlatpakDeploy ) runtime_deploy = NULL ; g_autoptr ( GBytes ) runtime_deploy_data = NULL ; g_autoptr ( GBytes ) app_deploy_data = NULL ; g_autoptr ( GFile ) app_files = NULL ; g_autoptr ( GFile ) runtime_files = NULL ; g_autoptr ( GFile ) bin_ldconfig = NULL ; g_autoptr ( GFile ) app_id_dir = NULL ; g_autoptr ( GFile ) real_app_id_dir = NULL ; g_autofree char * default_runtime_pref = NULL ; g_autoptr ( FlatpakDecomposed ) default_runtime = NULL ; g_autofree char * default_command = NULL ; g_autoptr ( GKeyFile ) metakey = NULL ; g_autoptr ( GKeyFile ) runtime_metakey = NULL ; g_autoptr ( FlatpakBwrap ) bwrap = NULL ; const char * command = ""/bin/sh"" ; g_autoptr ( GError ) my_error = NULL ; g_autoptr ( FlatpakDecomposed ) runtime_ref = NULL ; int i ; g_autoptr ( GPtrArray ) previous_app_id_dirs = NULL ; g_autofree char * app_id = NULL ; g_autofree char * app_arch = NULL ; g_autofree char * app_info_path = NULL ; g_autofree char * instance_id_host_dir = NULL ; g_autoptr ( FlatpakContext ) app_context = NULL ; g_autoptr ( FlatpakContext ) overrides = NULL ; g_autoptr ( FlatpakExports ) exports = NULL ; g_autofree char * commandline = NULL ; g_autofree char * doc_mount_path = NULL ; g_autofree char * app_extensions = NULL ; g_autofree char * runtime_extensions = NULL ; g_autofree char * checksum = NULL ; int ld_so_fd = - 1 ; g_autoptr ( GFile ) runtime_ld_so_conf = NULL ; gboolean generate_ld_so_conf = TRUE ; gboolean use_ld_so_cache = TRUE ; gboolean sandboxed = ( flags & FLATPAK_RUN_FLAG_SANDBOX ) != 0 ; gboolean parent_expose_pids = ( flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS ) != 0 ; gboolean parent_share_pids = ( flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS ) != 0 ; struct stat s ; if ( ! check_sudo ( error ) ) return FALSE ; app_id = flatpak_decomposed_dup_id ( app_ref ) ; app_arch = flatpak_decomposed_dup_arch ( app_ref ) ; if ( ! check_parental_controls ( app_ref , app_deploy , cancellable , error ) ) return FALSE ; bwrap = flatpak_bwrap_new ( NULL ) ; flatpak_bwrap_add_arg ( bwrap , flatpak_get_bwrap ( ) ) ; if ( app_deploy == NULL ) { g_assert ( flatpak_decomposed_is_runtime ( app_ref ) ) ; default_runtime_pref = flatpak_decomposed_dup_pref ( app_ref ) ; } else { const gchar * key ; app_deploy_data = flatpak_deploy_get_deploy_data ( app_deploy , FLATPAK_DEPLOY_VERSION_ANY , cancellable , error ) ; if ( app_deploy_data == NULL ) return FALSE ; if ( ( flags & FLATPAK_RUN_FLAG_DEVEL ) != 0 ) key = FLATPAK_METADATA_KEY_SDK ; else key = FLATPAK_METADATA_KEY_RUNTIME ; metakey = flatpak_deploy_get_metadata ( app_deploy ) ; default_runtime_pref = g_key_file_get_string ( metakey , FLATPAK_METADATA_GROUP_APPLICATION , key , & my_error ) ; if ( my_error ) { g_propagate_error ( error , g_steal_pointer ( & my_error ) ) ; return FALSE ; } } default_runtime = flatpak_decomposed_new_from_pref ( FLATPAK_KINDS_RUNTIME , default_runtime_pref , error ) ; if ( default_runtime == NULL ) return FALSE ; if ( custom_runtime != NULL || custom_runtime_version != NULL ) { g_auto ( GStrv ) custom_runtime_parts = NULL ; const char * custom_runtime_id = NULL ; const char * custom_runtime_arch = NULL ; if ( custom_runtime ) { custom_runtime_parts = g_strsplit ( custom_runtime , ""/"" , 0 ) ; for ( i = 0 ; i < 3 && custom_runtime_parts [ i ] != NULL ; i ++ ) { if ( strlen ( custom_runtime_parts [ i ] ) > 0 ) { if ( i == 0 ) custom_runtime_id = custom_runtime_parts [ i ] ; if ( i == 1 ) custom_runtime_arch = custom_runtime_parts [ i ] ; if ( i == 2 && custom_runtime_version == NULL ) custom_runtime_version = custom_runtime_parts [ i ] ; } } } runtime_ref = flatpak_decomposed_new_from_decomposed ( default_runtime , FLATPAK_KINDS_RUNTIME , custom_runtime_id , custom_runtime_arch , custom_runtime_version , error ) ; if ( runtime_ref == NULL ) return FALSE ; } else runtime_ref = flatpak_decomposed_ref ( default_runtime ) ; runtime_deploy = flatpak_find_deploy_for_ref ( flatpak_decomposed_get_ref ( runtime_ref ) , custom_runtime_commit , NULL , cancellable , error ) ; if ( runtime_deploy == NULL ) return FALSE ; runtime_deploy_data = flatpak_deploy_get_deploy_data ( runtime_deploy , FLATPAK_DEPLOY_VERSION_ANY , cancellable , error ) ; if ( runtime_deploy_data == NULL ) return FALSE ; runtime_metakey = flatpak_deploy_get_metadata ( runtime_deploy ) ; app_context = flatpak_app_compute_permissions ( metakey , runtime_metakey , error ) ; if ( app_context == NULL ) return FALSE ; if ( app_deploy != NULL ) { overrides = flatpak_deploy_get_overrides ( app_deploy ) ; flatpak_context_merge ( app_context , overrides ) ; } if ( sandboxed ) flatpak_context_make_sandboxed ( app_context ) ; if ( extra_context ) flatpak_context_merge ( app_context , extra_context ) ; runtime_files = flatpak_deploy_get_files ( runtime_deploy ) ; bin_ldconfig = g_file_resolve_relative_path ( runtime_files , ""bin/ldconfig"" ) ; if ( ! g_file_query_exists ( bin_ldconfig , NULL ) ) use_ld_so_cache = FALSE ; if ( app_deploy != NULL ) { g_autofree const char * * previous_ids = NULL ; gsize len = 0 ; gboolean do_migrate ; real_app_id_dir = flatpak_get_data_dir ( app_id ) ; app_files = flatpak_deploy_get_files ( app_deploy ) ; previous_app_id_dirs = g_ptr_array_new_with_free_func ( g_object_unref ) ; previous_ids = flatpak_deploy_data_get_previous_ids ( app_deploy_data , & len ) ; do_migrate = ! g_file_query_exists ( real_app_id_dir , cancellable ) ; for ( i = len - 1 ; i >= 0 ; i -- ) { g_autoptr ( GFile ) previous_app_id_dir = NULL ; g_autoptr ( GFileInfo ) previous_app_id_dir_info = NULL ; g_autoptr ( GError ) local_error = NULL ; previous_app_id_dir = flatpak_get_data_dir ( previous_ids [ i ] ) ; previous_app_id_dir_info = g_file_query_info ( previous_app_id_dir , G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK "","" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , cancellable , & local_error ) ; if ( previous_app_id_dir_info == NULL ) { if ( ! g_error_matches ( local_error , G_IO_ERROR , G_IO_ERROR_NOT_FOUND ) && do_migrate ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>migrate<S2SV_blank>from<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , local_error -> message ) ; do_migrate = FALSE ; } g_clear_error ( & local_error ) ; continue ; } if ( do_migrate ) { do_migrate = FALSE ; if ( ! flatpak_file_rename ( previous_app_id_dir , real_app_id_dir , cancellable , & local_error ) ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>migrate<S2SV_blank>old<S2SV_blank>app<S2SV_blank>data<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>new<S2SV_blank>name<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , app_id , local_error -> message ) ; } else { if ( ! g_file_make_symbolic_link ( previous_app_id_dir , app_id , cancellable , & local_error ) ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>while<S2SV_blank>migrating<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , local_error -> message ) ; } } } g_ptr_array_add ( previous_app_id_dirs , g_steal_pointer ( & previous_app_id_dir ) ) ; } if ( ! flatpak_ensure_data_dir ( real_app_id_dir , cancellable , error ) ) return FALSE ; if ( ! sandboxed ) app_id_dir = g_object_ref ( real_app_id_dir ) ; } flatpak_run_apply_env_default ( bwrap , use_ld_so_cache ) ; flatpak_run_apply_env_vars ( bwrap , app_context ) ; flatpak_run_apply_env_prompt ( bwrap , app_id ) ; if ( real_app_id_dir ) { g_autoptr ( GFile ) sandbox_dir = g_file_get_child ( real_app_id_dir , ""sandbox"" ) ; flatpak_bwrap_set_env ( bwrap , ""FLATPAK_SANDBOX_DIR"" , flatpak_file_get_path_cached ( sandbox_dir ) , TRUE ) ; } flatpak_bwrap_add_args ( bwrap , ""--ro-bind"" , flatpak_file_get_path_cached ( runtime_files ) , ""/usr"" , ""--lock-file"" , ""/usr/.ref"" , NULL ) ; if ( app_files != NULL ) flatpak_bwrap_add_args ( bwrap , ""--ro-bind"" , flatpak_file_get_path_cached ( app_files ) , ""/app"" , ""--lock-file"" , ""/app/.ref"" , NULL ) ; else flatpak_bwrap_add_args ( bwrap , ""--dir"" , ""/app"" , NULL ) ; if ( metakey != NULL && ! flatpak_run_add_extension_args ( bwrap , metakey , app_ref , use_ld_so_cache , & app_extensions , cancellable , error ) ) return FALSE ; if ( ! flatpak_run_add_extension_args ( bwrap , runtime_metakey , runtime_ref , use_ld_so_cache , & runtime_extensions , cancellable , error ) ) return FALSE ; runtime_ld_so_conf = g_file_resolve_relative_path ( runtime_files , ""etc/ld.so.conf"" ) ; if ( lstat ( flatpak_file_get_path_cached ( runtime_ld_so_conf ) , & s ) == 0 ) generate_ld_so_conf = S_ISREG ( s . st_mode ) && s . st_size == 0 ; if ( use_ld_so_cache ) { checksum = calculate_ld_cache_checksum ( app_deploy_data , runtime_deploy_data , app_extensions , runtime_extensions ) ; ld_so_fd = regenerate_ld_cache ( bwrap -> argv , bwrap -> fds , app_id_dir , checksum , runtime_files , generate_ld_so_conf , cancellable , error ) ; if ( ld_so_fd == - 1 ) return FALSE ; flatpak_bwrap_add_fd ( bwrap , ld_so_fd ) ; } flags |= flatpak_context_get_run_flags ( app_context ) ; if ( ! flatpak_run_setup_base_argv ( bwrap , runtime_files , app_id_dir , app_arch , flags , error ) ) return FALSE ; if ( generate_ld_so_conf ) { if ( ! add_ld_so_conf ( bwrap , error ) ) return FALSE ; } if ( ld_so_fd != - 1 ) { flatpak_bwrap_add_arg ( bwrap , ""--ro-bind-data"" ) ; flatpak_bwrap_add_arg_printf ( bwrap , ""%d"" , ld_so_fd ) ; flatpak_bwrap_add_arg ( bwrap , ""/etc/ld.so.cache"" ) ; } if ( ! flatpak_run_add_app_info_args ( bwrap , app_files , app_deploy_data , app_extensions , runtime_files , runtime_deploy_data , runtime_extensions , app_id , flatpak_decomposed_get_branch ( app_ref ) , runtime_ref , app_id_dir , app_context , extra_context , sandboxed , FALSE , flags & FLATPAK_RUN_FLAG_DEVEL , & app_info_path , instance_id_fd , & instance_id_host_dir , error ) ) return FALSE ; if ( ! flatpak_run_add_dconf_args ( bwrap , app_id , metakey , error ) ) return FALSE ; if ( ! sandboxed && ! ( flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL ) ) add_document_portal_args ( bwrap , app_id , & doc_mount_path ) ; if ( ! flatpak_run_add_environment_args ( bwrap , app_info_path , flags , app_id , app_context , app_id_dir , previous_app_id_dirs , & exports , cancellable , error ) ) return FALSE ; if ( ( app_context -> shares & FLATPAK_CONTEXT_SHARED_NETWORK ) != 0 ) flatpak_run_add_resolved_args ( bwrap ) ; flatpak_run_add_journal_args ( bwrap ) ; add_font_path_args ( bwrap ) ; add_icon_path_args ( bwrap ) ; flatpak_bwrap_add_args ( bwrap , ""--symlink"" , ""/app/lib/debug/source"" , ""/run/build"" , ""--symlink"" , ""/usr/lib/debug/source"" , ""/run/build-runtime"" , NULL ) ; if ( cwd ) flatpak_bwrap_add_args ( bwrap , ""--chdir"" , cwd , NULL ) ; if ( parent_expose_pids || parent_share_pids ) { g_autofree char * userns_path = NULL ; g_autofree char * pidns_path = NULL ; g_autofree char * userns2_path = NULL ; int userns_fd , userns2_fd , pidns_fd ; if ( parent_pid == 0 ) return flatpak_fail ( error , ""No<S2SV_blank>parent<S2SV_blank>pid<S2SV_blank>specified"" ) ; userns_path = g_strdup_printf ( ""/proc/%d/root/run/.userns"" , parent_pid ) ; userns_fd = open_namespace_fd_if_needed ( userns_path , ""/proc/self/ns/user"" ) ; if ( userns_fd != - 1 ) { flatpak_bwrap_add_args_data_fd ( bwrap , ""--userns"" , userns_fd , NULL ) ; userns2_path = g_strdup_printf ( ""/proc/%d/ns/user"" , parent_pid ) ; userns2_fd = open_namespace_fd_if_needed ( userns2_path , userns_path ) ; if ( userns2_fd != - 1 ) flatpak_bwrap_add_args_data_fd ( bwrap , ""--userns2"" , userns2_fd , NULL ) ; } pidns_path = g_strdup_printf ( ""/proc/%d/ns/pid"" , parent_pid ) ; pidns_fd = open ( pidns_path , O_RDONLY | O_CLOEXEC ) ; if ( pidns_fd != - 1 ) flatpak_bwrap_add_args_data_fd ( bwrap , ""--pidns"" , pidns_fd , NULL ) ; } if ( custom_command ) { command = custom_command ; } else if ( metakey ) { default_command = g_key_file_get_string ( metakey , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_COMMAND , & my_error ) ; if ( my_error ) { g_propagate_error ( error , g_steal_pointer ( & my_error ) ) ; return FALSE ; } command = default_command ; }  if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) )  return FALSE ; flatpak_bwrap_add_arg ( bwrap , command ) ; if ( ! add_rest_args ( bwrap , app_id , exports , ( flags & FLATPAK_RUN_FLAG_FILE_FORWARDING ) != 0 , doc_mount_path , args , n_args , error ) ) return FALSE ; flatpak_bwrap_finish ( bwrap ) ; commandline = flatpak_quote_argv ( ( const char * * ) bwrap -> argv -> pdata , - 1 ) ; g_debug ( ""Running<S2SV_blank>\'%s\'"" , commandline ) ; if ( ( flags & FLATPAK_RUN_FLAG_BACKGROUND ) != 0 ) { GPid child_pid ; char pid_str [ 64 ] ; g_autofree char * pid_path = NULL ; GSpawnFlags spawn_flags ; spawn_flags = G_SPAWN_SEARCH_PATH ; if ( flags & FLATPAK_RUN_FLAG_DO_NOT_REAP ) spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD ; spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN ;  if ( ! g_spawn_async ( NULL ,  ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return FALSE ; g_snprintf ( pid_str , sizeof ( pid_str ) , ""%d"" , child_pid ) ; pid_path = g_build_filename ( instance_id_host_dir , ""pid"" , NULL ) ; g_file_set_contents ( pid_path , pid_str , - 1 , NULL ) ; } else { char pid_str [ 64 ] ; g_autofree char * pid_path = NULL ; g_snprintf ( pid_str , sizeof ( pid_str ) , ""%d"" , getpid ( ) ) ; pid_path = g_build_filename ( instance_id_host_dir , ""pid"" , NULL ) ; g_file_set_contents ( pid_path , pid_str , - 1 , NULL ) ; flatpak_bwrap_child_setup ( bwrap -> fds , FALSE ) ;  if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 )  { g_set_error_literal ( error , G_IO_ERROR , g_io_error_from_errno ( errno ) , _ ( ""Unable<S2SV_blank>to<S2SV_blank>start<S2SV_blank>app"" ) ) ; return FALSE ; } } if ( instance_dir_out ) * instance_dir_out = g_steal_pointer ( & instance_id_host_dir ) ; return TRUE ; }","g_assert ( bwrap -> envp != NULL ) ;g_assert ( bwrap -> envp [ 0 ] == NULL ) ;if ( ! g_spawn_async ( NULL , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return FALSE ;",2645
679,"buggy line: if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 )  {cwe id:CWE-74context: gboolean flatpak_run_app ( FlatpakDecomposed * app_ref , FlatpakDeploy * app_deploy , FlatpakContext * extra_context , const char * custom_runtime , const char * custom_runtime_version , const char * custom_runtime_commit , int parent_pid , FlatpakRunFlags flags , const char * cwd , const char * custom_command , char * args [ ] , int n_args , int instance_id_fd , char * * instance_dir_out , GCancellable * cancellable , GError * * error ) { g_autoptr ( FlatpakDeploy ) runtime_deploy = NULL ; g_autoptr ( GBytes ) runtime_deploy_data = NULL ; g_autoptr ( GBytes ) app_deploy_data = NULL ; g_autoptr ( GFile ) app_files = NULL ; g_autoptr ( GFile ) runtime_files = NULL ; g_autoptr ( GFile ) bin_ldconfig = NULL ; g_autoptr ( GFile ) app_id_dir = NULL ; g_autoptr ( GFile ) real_app_id_dir = NULL ; g_autofree char * default_runtime_pref = NULL ; g_autoptr ( FlatpakDecomposed ) default_runtime = NULL ; g_autofree char * default_command = NULL ; g_autoptr ( GKeyFile ) metakey = NULL ; g_autoptr ( GKeyFile ) runtime_metakey = NULL ; g_autoptr ( FlatpakBwrap ) bwrap = NULL ; const char * command = ""/bin/sh"" ; g_autoptr ( GError ) my_error = NULL ; g_autoptr ( FlatpakDecomposed ) runtime_ref = NULL ; int i ; g_autoptr ( GPtrArray ) previous_app_id_dirs = NULL ; g_autofree char * app_id = NULL ; g_autofree char * app_arch = NULL ; g_autofree char * app_info_path = NULL ; g_autofree char * instance_id_host_dir = NULL ; g_autoptr ( FlatpakContext ) app_context = NULL ; g_autoptr ( FlatpakContext ) overrides = NULL ; g_autoptr ( FlatpakExports ) exports = NULL ; g_autofree char * commandline = NULL ; g_autofree char * doc_mount_path = NULL ; g_autofree char * app_extensions = NULL ; g_autofree char * runtime_extensions = NULL ; g_autofree char * checksum = NULL ; int ld_so_fd = - 1 ; g_autoptr ( GFile ) runtime_ld_so_conf = NULL ; gboolean generate_ld_so_conf = TRUE ; gboolean use_ld_so_cache = TRUE ; gboolean sandboxed = ( flags & FLATPAK_RUN_FLAG_SANDBOX ) != 0 ; gboolean parent_expose_pids = ( flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS ) != 0 ; gboolean parent_share_pids = ( flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS ) != 0 ; struct stat s ; if ( ! check_sudo ( error ) ) return FALSE ; app_id = flatpak_decomposed_dup_id ( app_ref ) ; app_arch = flatpak_decomposed_dup_arch ( app_ref ) ; if ( ! check_parental_controls ( app_ref , app_deploy , cancellable , error ) ) return FALSE ; bwrap = flatpak_bwrap_new ( NULL ) ; flatpak_bwrap_add_arg ( bwrap , flatpak_get_bwrap ( ) ) ; if ( app_deploy == NULL ) { g_assert ( flatpak_decomposed_is_runtime ( app_ref ) ) ; default_runtime_pref = flatpak_decomposed_dup_pref ( app_ref ) ; } else { const gchar * key ; app_deploy_data = flatpak_deploy_get_deploy_data ( app_deploy , FLATPAK_DEPLOY_VERSION_ANY , cancellable , error ) ; if ( app_deploy_data == NULL ) return FALSE ; if ( ( flags & FLATPAK_RUN_FLAG_DEVEL ) != 0 ) key = FLATPAK_METADATA_KEY_SDK ; else key = FLATPAK_METADATA_KEY_RUNTIME ; metakey = flatpak_deploy_get_metadata ( app_deploy ) ; default_runtime_pref = g_key_file_get_string ( metakey , FLATPAK_METADATA_GROUP_APPLICATION , key , & my_error ) ; if ( my_error ) { g_propagate_error ( error , g_steal_pointer ( & my_error ) ) ; return FALSE ; } } default_runtime = flatpak_decomposed_new_from_pref ( FLATPAK_KINDS_RUNTIME , default_runtime_pref , error ) ; if ( default_runtime == NULL ) return FALSE ; if ( custom_runtime != NULL || custom_runtime_version != NULL ) { g_auto ( GStrv ) custom_runtime_parts = NULL ; const char * custom_runtime_id = NULL ; const char * custom_runtime_arch = NULL ; if ( custom_runtime ) { custom_runtime_parts = g_strsplit ( custom_runtime , ""/"" , 0 ) ; for ( i = 0 ; i < 3 && custom_runtime_parts [ i ] != NULL ; i ++ ) { if ( strlen ( custom_runtime_parts [ i ] ) > 0 ) { if ( i == 0 ) custom_runtime_id = custom_runtime_parts [ i ] ; if ( i == 1 ) custom_runtime_arch = custom_runtime_parts [ i ] ; if ( i == 2 && custom_runtime_version == NULL ) custom_runtime_version = custom_runtime_parts [ i ] ; } } } runtime_ref = flatpak_decomposed_new_from_decomposed ( default_runtime , FLATPAK_KINDS_RUNTIME , custom_runtime_id , custom_runtime_arch , custom_runtime_version , error ) ; if ( runtime_ref == NULL ) return FALSE ; } else runtime_ref = flatpak_decomposed_ref ( default_runtime ) ; runtime_deploy = flatpak_find_deploy_for_ref ( flatpak_decomposed_get_ref ( runtime_ref ) , custom_runtime_commit , NULL , cancellable , error ) ; if ( runtime_deploy == NULL ) return FALSE ; runtime_deploy_data = flatpak_deploy_get_deploy_data ( runtime_deploy , FLATPAK_DEPLOY_VERSION_ANY , cancellable , error ) ; if ( runtime_deploy_data == NULL ) return FALSE ; runtime_metakey = flatpak_deploy_get_metadata ( runtime_deploy ) ; app_context = flatpak_app_compute_permissions ( metakey , runtime_metakey , error ) ; if ( app_context == NULL ) return FALSE ; if ( app_deploy != NULL ) { overrides = flatpak_deploy_get_overrides ( app_deploy ) ; flatpak_context_merge ( app_context , overrides ) ; } if ( sandboxed ) flatpak_context_make_sandboxed ( app_context ) ; if ( extra_context ) flatpak_context_merge ( app_context , extra_context ) ; runtime_files = flatpak_deploy_get_files ( runtime_deploy ) ; bin_ldconfig = g_file_resolve_relative_path ( runtime_files , ""bin/ldconfig"" ) ; if ( ! g_file_query_exists ( bin_ldconfig , NULL ) ) use_ld_so_cache = FALSE ; if ( app_deploy != NULL ) { g_autofree const char * * previous_ids = NULL ; gsize len = 0 ; gboolean do_migrate ; real_app_id_dir = flatpak_get_data_dir ( app_id ) ; app_files = flatpak_deploy_get_files ( app_deploy ) ; previous_app_id_dirs = g_ptr_array_new_with_free_func ( g_object_unref ) ; previous_ids = flatpak_deploy_data_get_previous_ids ( app_deploy_data , & len ) ; do_migrate = ! g_file_query_exists ( real_app_id_dir , cancellable ) ; for ( i = len - 1 ; i >= 0 ; i -- ) { g_autoptr ( GFile ) previous_app_id_dir = NULL ; g_autoptr ( GFileInfo ) previous_app_id_dir_info = NULL ; g_autoptr ( GError ) local_error = NULL ; previous_app_id_dir = flatpak_get_data_dir ( previous_ids [ i ] ) ; previous_app_id_dir_info = g_file_query_info ( previous_app_id_dir , G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK "","" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , cancellable , & local_error ) ; if ( previous_app_id_dir_info == NULL ) { if ( ! g_error_matches ( local_error , G_IO_ERROR , G_IO_ERROR_NOT_FOUND ) && do_migrate ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>migrate<S2SV_blank>from<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , local_error -> message ) ; do_migrate = FALSE ; } g_clear_error ( & local_error ) ; continue ; } if ( do_migrate ) { do_migrate = FALSE ; if ( ! flatpak_file_rename ( previous_app_id_dir , real_app_id_dir , cancellable , & local_error ) ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>migrate<S2SV_blank>old<S2SV_blank>app<S2SV_blank>data<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>new<S2SV_blank>name<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , app_id , local_error -> message ) ; } else { if ( ! g_file_make_symbolic_link ( previous_app_id_dir , app_id , cancellable , & local_error ) ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>while<S2SV_blank>migrating<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , local_error -> message ) ; } } } g_ptr_array_add ( previous_app_id_dirs , g_steal_pointer ( & previous_app_id_dir ) ) ; } if ( ! flatpak_ensure_data_dir ( real_app_id_dir , cancellable , error ) ) return FALSE ; if ( ! sandboxed ) app_id_dir = g_object_ref ( real_app_id_dir ) ; } flatpak_run_apply_env_default ( bwrap , use_ld_so_cache ) ; flatpak_run_apply_env_vars ( bwrap , app_context ) ; flatpak_run_apply_env_prompt ( bwrap , app_id ) ; if ( real_app_id_dir ) { g_autoptr ( GFile ) sandbox_dir = g_file_get_child ( real_app_id_dir , ""sandbox"" ) ; flatpak_bwrap_set_env ( bwrap , ""FLATPAK_SANDBOX_DIR"" , flatpak_file_get_path_cached ( sandbox_dir ) , TRUE ) ; } flatpak_bwrap_add_args ( bwrap , ""--ro-bind"" , flatpak_file_get_path_cached ( runtime_files ) , ""/usr"" , ""--lock-file"" , ""/usr/.ref"" , NULL ) ; if ( app_files != NULL ) flatpak_bwrap_add_args ( bwrap , ""--ro-bind"" , flatpak_file_get_path_cached ( app_files ) , ""/app"" , ""--lock-file"" , ""/app/.ref"" , NULL ) ; else flatpak_bwrap_add_args ( bwrap , ""--dir"" , ""/app"" , NULL ) ; if ( metakey != NULL && ! flatpak_run_add_extension_args ( bwrap , metakey , app_ref , use_ld_so_cache , & app_extensions , cancellable , error ) ) return FALSE ; if ( ! flatpak_run_add_extension_args ( bwrap , runtime_metakey , runtime_ref , use_ld_so_cache , & runtime_extensions , cancellable , error ) ) return FALSE ; runtime_ld_so_conf = g_file_resolve_relative_path ( runtime_files , ""etc/ld.so.conf"" ) ; if ( lstat ( flatpak_file_get_path_cached ( runtime_ld_so_conf ) , & s ) == 0 ) generate_ld_so_conf = S_ISREG ( s . st_mode ) && s . st_size == 0 ; if ( use_ld_so_cache ) { checksum = calculate_ld_cache_checksum ( app_deploy_data , runtime_deploy_data , app_extensions , runtime_extensions ) ; ld_so_fd = regenerate_ld_cache ( bwrap -> argv , bwrap -> fds , app_id_dir , checksum , runtime_files , generate_ld_so_conf , cancellable , error ) ; if ( ld_so_fd == - 1 ) return FALSE ; flatpak_bwrap_add_fd ( bwrap , ld_so_fd ) ; } flags |= flatpak_context_get_run_flags ( app_context ) ; if ( ! flatpak_run_setup_base_argv ( bwrap , runtime_files , app_id_dir , app_arch , flags , error ) ) return FALSE ; if ( generate_ld_so_conf ) { if ( ! add_ld_so_conf ( bwrap , error ) ) return FALSE ; } if ( ld_so_fd != - 1 ) { flatpak_bwrap_add_arg ( bwrap , ""--ro-bind-data"" ) ; flatpak_bwrap_add_arg_printf ( bwrap , ""%d"" , ld_so_fd ) ; flatpak_bwrap_add_arg ( bwrap , ""/etc/ld.so.cache"" ) ; } if ( ! flatpak_run_add_app_info_args ( bwrap , app_files , app_deploy_data , app_extensions , runtime_files , runtime_deploy_data , runtime_extensions , app_id , flatpak_decomposed_get_branch ( app_ref ) , runtime_ref , app_id_dir , app_context , extra_context , sandboxed , FALSE , flags & FLATPAK_RUN_FLAG_DEVEL , & app_info_path , instance_id_fd , & instance_id_host_dir , error ) ) return FALSE ; if ( ! flatpak_run_add_dconf_args ( bwrap , app_id , metakey , error ) ) return FALSE ; if ( ! sandboxed && ! ( flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL ) ) add_document_portal_args ( bwrap , app_id , & doc_mount_path ) ; if ( ! flatpak_run_add_environment_args ( bwrap , app_info_path , flags , app_id , app_context , app_id_dir , previous_app_id_dirs , & exports , cancellable , error ) ) return FALSE ; if ( ( app_context -> shares & FLATPAK_CONTEXT_SHARED_NETWORK ) != 0 ) flatpak_run_add_resolved_args ( bwrap ) ; flatpak_run_add_journal_args ( bwrap ) ; add_font_path_args ( bwrap ) ; add_icon_path_args ( bwrap ) ; flatpak_bwrap_add_args ( bwrap , ""--symlink"" , ""/app/lib/debug/source"" , ""/run/build"" , ""--symlink"" , ""/usr/lib/debug/source"" , ""/run/build-runtime"" , NULL ) ; if ( cwd ) flatpak_bwrap_add_args ( bwrap , ""--chdir"" , cwd , NULL ) ; if ( parent_expose_pids || parent_share_pids ) { g_autofree char * userns_path = NULL ; g_autofree char * pidns_path = NULL ; g_autofree char * userns2_path = NULL ; int userns_fd , userns2_fd , pidns_fd ; if ( parent_pid == 0 ) return flatpak_fail ( error , ""No<S2SV_blank>parent<S2SV_blank>pid<S2SV_blank>specified"" ) ; userns_path = g_strdup_printf ( ""/proc/%d/root/run/.userns"" , parent_pid ) ; userns_fd = open_namespace_fd_if_needed ( userns_path , ""/proc/self/ns/user"" ) ; if ( userns_fd != - 1 ) { flatpak_bwrap_add_args_data_fd ( bwrap , ""--userns"" , userns_fd , NULL ) ; userns2_path = g_strdup_printf ( ""/proc/%d/ns/user"" , parent_pid ) ; userns2_fd = open_namespace_fd_if_needed ( userns2_path , userns_path ) ; if ( userns2_fd != - 1 ) flatpak_bwrap_add_args_data_fd ( bwrap , ""--userns2"" , userns2_fd , NULL ) ; } pidns_path = g_strdup_printf ( ""/proc/%d/ns/pid"" , parent_pid ) ; pidns_fd = open ( pidns_path , O_RDONLY | O_CLOEXEC ) ; if ( pidns_fd != - 1 ) flatpak_bwrap_add_args_data_fd ( bwrap , ""--pidns"" , pidns_fd , NULL ) ; } if ( custom_command ) { command = custom_command ; } else if ( metakey ) { default_command = g_key_file_get_string ( metakey , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_COMMAND , & my_error ) ; if ( my_error ) { g_propagate_error ( error , g_steal_pointer ( & my_error ) ) ; return FALSE ; } command = default_command ; }  if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) )  return FALSE ; flatpak_bwrap_add_arg ( bwrap , command ) ; if ( ! add_rest_args ( bwrap , app_id , exports , ( flags & FLATPAK_RUN_FLAG_FILE_FORWARDING ) != 0 , doc_mount_path , args , n_args , error ) ) return FALSE ; flatpak_bwrap_finish ( bwrap ) ; commandline = flatpak_quote_argv ( ( const char * * ) bwrap -> argv -> pdata , - 1 ) ; g_debug ( ""Running<S2SV_blank>\'%s\'"" , commandline ) ; if ( ( flags & FLATPAK_RUN_FLAG_BACKGROUND ) != 0 ) { GPid child_pid ; char pid_str [ 64 ] ; g_autofree char * pid_path = NULL ; GSpawnFlags spawn_flags ; spawn_flags = G_SPAWN_SEARCH_PATH ; if ( flags & FLATPAK_RUN_FLAG_DO_NOT_REAP ) spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD ; spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN ;  if ( ! g_spawn_async ( NULL ,  ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return FALSE ; g_snprintf ( pid_str , sizeof ( pid_str ) , ""%d"" , child_pid ) ; pid_path = g_build_filename ( instance_id_host_dir , ""pid"" , NULL ) ; g_file_set_contents ( pid_path , pid_str , - 1 , NULL ) ; } else { char pid_str [ 64 ] ; g_autofree char * pid_path = NULL ; g_snprintf ( pid_str , sizeof ( pid_str ) , ""%d"" , getpid ( ) ) ; pid_path = g_build_filename ( instance_id_host_dir , ""pid"" , NULL ) ; g_file_set_contents ( pid_path , pid_str , - 1 , NULL ) ; flatpak_bwrap_child_setup ( bwrap -> fds , FALSE ) ;  if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 )  { g_set_error_literal ( error , G_IO_ERROR , g_io_error_from_errno ( errno ) , _ ( ""Unable<S2SV_blank>to<S2SV_blank>start<S2SV_blank>app"" ) ) ; return FALSE ; } } if ( instance_dir_out ) * instance_dir_out = g_steal_pointer ( & instance_id_host_dir ) ; return TRUE ; }","g_assert ( bwrap -> envp != NULL ) ;g_assert ( bwrap -> envp [ 0 ] == NULL ) ;if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 ) {",2645
680,"buggy line: record_and_restart ( event , val , regs , nmi ) ;}cwe id:CWE-400context: static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ;  record_and_restart ( event , val , regs , nmi ) ;  } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; if ( pmc_overflow ( val ) ) write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }","record_and_restart ( event , val , regs ) ;}",2646
681,"buggy line: static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {cwe id:CWE-119context:  static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) { int * update_info = va_arg ( args , int * ) ; if ( update_info && ! ctx -> yv12_frame_buffers . use_frame_threads ) { VP8D_COMP * pbi = ( VP8D_COMP * ) ctx -> yv12_frame_buffers . pbi [ 0 ] ; * update_info = pbi -> common . refresh_alt_ref_frame * ( int ) VP8_ALTR_FRAME + pbi -> common . refresh_golden_frame * ( int ) VP8_GOLD_FRAME + pbi -> common . refresh_last_frame * ( int ) VP8_LAST_FRAME ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }","static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2647
682,"buggy line: if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;pc -> buffer = new_buffer ;cwe id:CWE-119context: int ff_combine_frame ( ParseContext * pc , int next , const uint8_t * * buf , int * buf_size ) { if ( pc -> overread ) { av_dlog ( NULL , ""overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n"" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , ""%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n"" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } for ( ; pc -> overread > 0 ; pc -> overread -- ) { pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ] ; } if ( ! * buf_size && next == END_NOT_FOUND ) { next = 0 ; } pc -> last_index = pc -> index ; if ( next == END_NOT_FOUND ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ;  if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;  pc -> buffer = new_buffer ; memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ) ; pc -> index += * buf_size ; return - 1 ; } * buf_size = pc -> overread_index = pc -> index + next ; if ( pc -> index ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ;  if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;  pc -> buffer = new_buffer ; if ( next > - FF_INPUT_BUFFER_PADDING_SIZE ) memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ) ; pc -> index = 0 ; * buf = pc -> buffer ; } for ( ; next < 0 ; next ++ ) { pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> overread ++ ; } if ( pc -> overread ) { av_dlog ( NULL , ""overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n"" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , ""%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n"" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } return 0 ; }",if ( ! new_buffer ) {pc -> index = 0 ;return AVERROR ( ENOMEM ) ;}pc -> buffer = new_buffer ;,2648
683,"buggy line: if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;pc -> buffer = new_buffer ;cwe id:CWE-119context: int ff_combine_frame ( ParseContext * pc , int next , const uint8_t * * buf , int * buf_size ) { if ( pc -> overread ) { av_dlog ( NULL , ""overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n"" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , ""%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n"" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } for ( ; pc -> overread > 0 ; pc -> overread -- ) { pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ] ; } if ( ! * buf_size && next == END_NOT_FOUND ) { next = 0 ; } pc -> last_index = pc -> index ; if ( next == END_NOT_FOUND ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ;  if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;  pc -> buffer = new_buffer ; memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ) ; pc -> index += * buf_size ; return - 1 ; } * buf_size = pc -> overread_index = pc -> index + next ; if ( pc -> index ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ;  if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;  pc -> buffer = new_buffer ; if ( next > - FF_INPUT_BUFFER_PADDING_SIZE ) memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ) ; pc -> index = 0 ; * buf = pc -> buffer ; } for ( ; next < 0 ; next ++ ) { pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> overread ++ ; } if ( pc -> overread ) { av_dlog ( NULL , ""overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n"" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , ""%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n"" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } return 0 ; }",if ( ! new_buffer ) {pc -> overread_index = pc -> index = 0 ;return AVERROR ( ENOMEM ) ;}pc -> buffer = new_buffer ;,2648
684,"buggy line: struct fsnotify_group * group ;struct user_struct * user ;user = get_current_user ( ) ;if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) {ret = - EMFILE ;}group = inotify_new_group ( user , inotify_max_queued_events ) ;if ( IS_ERR ( group ) ) {ret = PTR_ERR ( group ) ;goto out_free_uid ;if ( ret >= 0 )  return ret ;fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;cwe id:CWE-399context: SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) {  struct fsnotify_group * group ;  struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ;  user = get_current_user ( ) ;  if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; }  group = inotify_new_group ( user , inotify_max_queued_events ) ;   if ( IS_ERR ( group ) ) {   ret = PTR_ERR ( group ) ;  goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( ""inotify"" , & inotify_fops , group , O_RDONLY | flags ) ;  if ( ret >= 0 )  return ret ;  fsnotify_put_group ( group ) ;  atomic_dec ( & user -> inotify_devs ) ; out_free_uid : free_uid ( user ) ; return ret ; }","struct fsnotify_group * group ;group = inotify_new_group ( user , inotify_max_queued_events ) ;if ( IS_ERR ( group ) ) {ret = PTR_ERR ( group ) ;if ( ret < 0 ) fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;",2649
685,"buggy line: static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile ,  vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ,  int mi_row , int mi_col ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;MODE_INFO * m ;set_mi_row_col ( xd , tile ,  mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ;write_mb_modes_kf ( cpi , xd -> mi , w ) ;}pack_mb_tokens ( w , tok , tok_end ) ;}cwe id:CWE-119context: static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile ,  vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ,  int mi_row , int mi_col ) {  VP9_COMMON * const cm = & cpi -> common ;   MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;  MODE_INFO * m ; xd -> mi = cm -> mi_grid_visible + ( mi_row * cm -> mi_stride + mi_col ) ; m = xd -> mi [ 0 ] ;  set_mi_row_col ( xd , tile ,  mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ; if ( frame_is_intra_only ( cm ) ) {  write_mb_modes_kf ( cpi , xd -> mi , w ) ;  } else { pack_inter_mode_mvs ( cpi , m , w ) ; } assert ( * tok < tok_end ) ;  pack_mb_tokens ( w , tok , tok_end ) ;  }","static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile , vpx_writer * w , TOKENEXTRA * * tok , const TOKENEXTRA * const tok_end , int mi_row , int mi_col ) {const VP9_COMMON * const cm = & cpi -> td . common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;MODE_INFO * m ;cpi -> td . mb . mbmi_ext = cpi -> td . mb . mbmi_ext_base + ( mi_row * cm -> mi_cols + mi_col ) ;set_mi_row_col ( xd , tile , mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ;write_mb_modes_kf ( cm , xd , xd -> mi , w ) ;}pack_mb_tokens ( w , tok , tok_end , cm -> bit_depth ) ;}",2650
686,"buggy line: mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\\if ( table -> total == table -> max ) {cwe id:CWE-119context: int mlx4_register_mac ( struct mlx4_dev * dev , u8 port , u64 mac , int * index ) { struct mlx4_mac_table * table = & mlx4_priv ( dev ) -> port [ port ] . mac_table ; int i , err = 0 ; int free = - 1 ; mlx4_dbg ( dev , ""Registering<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n"" , ( unsigned long long ) mac ) ; mutex_lock ( & table -> mutex ) ; for ( i = 0 ; i < MLX4_MAX_MAC_NUM - 1 ; i ++ ) { if ( free < 0 && ! table -> refs [ i ] ) { free = i ; continue ; } if ( mac == ( MLX4_MAC_MASK & be64_to_cpu ( table -> entries [ i ] ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } }  mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n"" , free ) ;  if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be64 ( mac | MLX4_MAC_VALID ) ; err = mlx4_set_port_mac_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_err ( dev , ""Failed<S2SV_blank>adding<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n"" , ( unsigned long long ) mac ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }","if ( free < 0 ) {err = - ENOMEM ;goto out ;}mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\\if ( table -> total == table -> max ) {",2651
687,"buggy line: aof_fsync ( server . appendfd ) ;if ( server . vm_enabled ) unlink ( server . vm_swap_file ) ;cwe id:CWE-20context: int prepareForShutdown ( ) { redisLog ( REDIS_WARNING , ""User<S2SV_blank>requested<S2SV_blank>shutdown,<S2SV_blank>saving<S2SV_blank>DB..."" ) ; if ( server . bgsavechildpid != - 1 ) { redisLog ( REDIS_WARNING , ""There<S2SV_blank>is<S2SV_blank>a<S2SV_blank>live<S2SV_blank>saving<S2SV_blank>child.<S2SV_blank>Killing<S2SV_blank>it!"" ) ; kill ( server . bgsavechildpid , SIGKILL ) ; rdbRemoveTempFile ( server . bgsavechildpid ) ; } if ( server . appendonly ) {  aof_fsync ( server . appendfd ) ;  if ( server . vm_enabled ) unlink ( server . vm_swap_file ) ; } else if ( server . saveparamslen > 0 ) { if ( rdbSave ( server . dbfilename ) != REDIS_OK ) { redisLog ( REDIS_WARNING , ""Error<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>save<S2SV_blank>the<S2SV_blank>DB,<S2SV_blank>can\'t<S2SV_blank>exit"" ) ; return REDIS_ERR ; } } else { redisLog ( REDIS_WARNING , ""Not<S2SV_blank>saving<S2SV_blank>DB."" ) ; } if ( server . daemonize ) unlink ( server . pidfile ) ; redisLog ( REDIS_WARNING , ""Server<S2SV_blank>exit<S2SV_blank>now,<S2SV_blank>bye<S2SV_blank>bye..."" ) ; return REDIS_OK ; }",aof_fsync ( server . appendfd ) ;,2652
688,"buggy line: ACCESS_MASK access = FILE_READ_ATTRIBUTES ;cwe id:CWE-119context: NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ;  byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;  if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;  EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) {  offset . QuadPart = 0 ;  ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;  if ( NT_SUCCESS ( ntStatus ) )  { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else {  Irp -> IoStatus . Status = ntStatus ;   Irp -> IoStatus . Information = 0 ;  } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }","size_t devicePathLen = 0 ;if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\\\\\Device\\\\\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) {byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ;if ( ! readBuffer ) {Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ;Irp -> IoStatus . Information = 0 ;}else {Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;break ;}",2653
689,"buggy line: cwe id:CWE-119context: NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ;  byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;  if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;  EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) {  offset . QuadPart = 0 ;  ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;  if ( NT_SUCCESS ( ntStatus ) )  { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else {  Irp -> IoStatus . Status = ntStatus ;   Irp -> IoStatus . Information = 0 ;  } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }",if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) {,2653
690,"buggy line: cwe id:CWE-119context: NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ;  byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;  if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;  EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) {  offset . QuadPart = 0 ;  ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;  if ( NT_SUCCESS ( ntStatus ) )  { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else {  Irp -> IoStatus . Status = ntStatus ;   Irp -> IoStatus . Information = 0 ;  } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }",Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;}TCfree ( readBuffer ) ;}}else {,2653
691,"buggy line: byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) )  {cwe id:CWE-119context: NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ;  byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;  if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;  EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) {  offset . QuadPart = 0 ;  ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;  if ( NT_SUCCESS ( ntStatus ) )  { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else {  Irp -> IoStatus . Status = ntStatus ;   Irp -> IoStatus . Information = 0 ;  } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }","byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , sizeof ( readBuffer ) , & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) ) {",2653
692,"buggy line: Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;}cwe id:CWE-119context: NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ;  byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;  if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;  EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) {  offset . QuadPart = 0 ;  ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;  if ( NT_SUCCESS ( ntStatus ) )  { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else {  Irp -> IoStatus . Status = ntStatus ;   Irp -> IoStatus . Information = 0 ;  } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }",Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;},2653
693,"buggy line: fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {cwe id:CWE-200context: static int isofs_export_encode_fh ( struct inode * inode , __u32 * fh32 , int * max_len , struct inode * parent ) { struct iso_inode_info * ei = ISOFS_I ( inode ) ; int len = * max_len ; int type = 1 ; __u16 * fh16 = ( __u16 * ) fh32 ; if ( parent && ( len < 5 ) ) { * max_len = 5 ; return 255 ; } else if ( len < 3 ) { * max_len = 3 ; return 255 ; } len = 3 ; fh32 [ 0 ] = ei -> i_iget5_block ; fh16 [ 2 ] = ( __u16 ) ei -> i_iget5_offset ;  fh32 [ 2 ] = inode -> i_generation ;  if ( parent ) { struct iso_inode_info * eparent ; eparent = ISOFS_I ( parent ) ; fh32 [ 3 ] = eparent -> i_iget5_block ; fh16 [ 3 ] = ( __u16 ) eparent -> i_iget5_offset ; fh32 [ 4 ] = parent -> i_generation ; len = 5 ; type = 2 ; } * max_len = len ; return type ; }",fh16 [ 3 ] = 0 ;fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {,2654
694,"buggy line: int err ;if ( rt ) return 0 ;daddr = inet -> inet_daddr ;if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ;cwe id:CWE-362context: int inet_sk_rebuild_header ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; struct rtable * rt = ( struct rtable * ) __sk_dst_check ( sk , 0 ) ; __be32 daddr ;  int err ;  if ( rt ) return 0 ;  daddr = inet -> inet_daddr ;   if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ; rt = ip_route_output_ports ( sock_net ( sk ) , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; if ( ! IS_ERR ( rt ) ) { err = 0 ; sk_setup_caps ( sk , & rt -> dst ) ; } else { err = PTR_ERR ( rt ) ; sk -> sk_route_caps = 0 ; if ( ! sysctl_ip_dynaddr || sk -> sk_state != TCP_SYN_SENT || ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) || ( err = inet_sk_reselect_saddr ( sk ) ) != 0 ) sk -> sk_err_soft = - err ; } return err ; }",struct ip_options_rcu * inet_opt ;int err ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;rcu_read_unlock ( ) ;,2655
695,"buggy line: static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type ,  u32 * mask ) {if ( IS_ERR ( algt ) )  return ;if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) )  * type |= CRYPTO_ALG_INTERNAL ;if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) )  * mask |= CRYPTO_ALG_INTERNAL ;cwe id:CWE-476context:  static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type ,  u32 * mask ) { struct crypto_attr_type * algt ; algt = crypto_get_attr_type ( tb ) ; if ( IS_ERR ( algt ) )  return ;   if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) )  * type |= CRYPTO_ALG_INTERNAL ;  if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) )  * mask |= CRYPTO_ALG_INTERNAL ; }","static inline bool mcryptd_check_internal ( struct rtattr * * tb , u32 * type , u32 * mask ) {if ( IS_ERR ( algt ) ) return false ;* type |= algt -> type & CRYPTO_ALG_INTERNAL ;* mask |= algt -> mask & CRYPTO_ALG_INTERNAL ;if ( * type & * mask & CRYPTO_ALG_INTERNAL ) return true ;else return false ;",2656
696,"buggy line: priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;cwe id:CWE-000context: static int cypress_generic_port_probe ( struct usb_serial_port * port ) { struct usb_serial * serial = port -> serial ; struct cypress_private * priv ;  priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;  if ( ! priv ) return - ENOMEM ; priv -> comm_is_ok = ! 0 ; spin_lock_init ( & priv -> lock ) ; if ( kfifo_alloc ( & priv -> write_fifo , CYPRESS_BUF_SIZE , GFP_KERNEL ) ) { kfree ( priv ) ; return - ENOMEM ; } if ( ! is_frwd ( serial -> dev ) ) usb_reset_configuration ( serial -> dev ) ; priv -> cmd_ctrl = 0 ; priv -> line_control = 0 ; priv -> termios_initialized = 0 ; priv -> rx_flags = 0 ; if ( port -> interrupt_out_size > 9 ) priv -> pkt_fmt = packet_format_1 ; else priv -> pkt_fmt = packet_format_2 ; if ( interval > 0 ) { priv -> write_urb_interval = interval ; priv -> read_urb_interval = interval ; dev_dbg ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>read<S2SV_blank>&<S2SV_blank>write<S2SV_blank>intervals<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>%d\\n"" , __func__ , interval ) ; } else { priv -> write_urb_interval = port -> interrupt_out_urb -> interval ; priv -> read_urb_interval = port -> interrupt_in_urb -> interval ; dev_dbg ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>intervals:<S2SV_blank>read=%d<S2SV_blank>write=%d\\n"" , __func__ , priv -> read_urb_interval , priv -> write_urb_interval ) ; } usb_set_serial_port_data ( port , priv ) ; port -> port . drain_delay = 256 ; return 0 ; }","if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) {dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\\return - ENODEV ;}priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;",2657
697,"buggy line: int yy , mm , dd , hr , min , sec , csec ;guint pkt_len ;if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) {num_items_scanned = sscanf ( line ,  ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;cwe id:CWE-119context: static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ;  int yy , mm , dd , hr , min , sec , csec ;  guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = """" , direction [ 6 ] = """" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line ,  ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values"" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line ,  ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output"" ) ; return FALSE ; }  yy = mm = dd = hr = min = sec = csec = 0 ;  } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , ""TEST:"" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , ""PPoATM:"" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , ""PPoFR:"" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , ""ATM:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , ""FR:"" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , ""HDLC:"" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , ""PPP:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , ""ETH:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , ""l2-tx"" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , ""l2-rx"" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers"" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }","int yy , mm , dd , hr , min , sec , csec , pkt_len ;if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) {num_items_scanned = sscanf ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;",2658
698,"buggy line: num_items_scanned = sscanf ( line ,  ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;yy = mm = dd = hr = min = sec = csec = 0 ;}cwe id:CWE-119context: static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ;  int yy , mm , dd , hr , min , sec , csec ;  guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = """" , direction [ 6 ] = """" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line ,  ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values"" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line ,  ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output"" ) ; return FALSE ; }  yy = mm = dd = hr = min = sec = csec = 0 ;  } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , ""TEST:"" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , ""PPoATM:"" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , ""PPoFR:"" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , ""ATM:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , ""FR:"" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , ""HDLC:"" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , ""PPP:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , ""ETH:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , ""l2-tx"" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , ""l2-rx"" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers"" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }","num_items_scanned = sscanf ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;yy = mm = dd = hr = min = sec = csec = 0 ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;}",2658
699,"buggy line: ND_TCHECK ( dp -> ip6f_offlg ) ;if ( ndo -> ndo_vflag ) {cwe id:CWE-125context: int frag6_print ( netdissect_options * ndo , register const u_char * bp , register const u_char * bp2 ) { register const struct ip6_frag * dp ; register const struct ip6_hdr * ip6 ; dp = ( const struct ip6_frag * ) bp ; ip6 = ( const struct ip6_hdr * ) bp2 ;  ND_TCHECK ( dp -> ip6f_offlg ) ;  if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""frag<S2SV_blank>(0x%08x:%d|%ld)"" , EXTRACT_32BITS ( & dp -> ip6f_ident ) , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } else { ND_PRINT ( ( ndo , ""frag<S2SV_blank>(%d|%ld)"" , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } if ( ( EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK ) != 0 ) return - 1 ; else { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; return sizeof ( struct ip6_frag ) ; } trunc : ND_PRINT ( ( ndo , ""[|frag]"" ) ) ; return - 1 ; }",ND_TCHECK ( * dp ) ;if ( ndo -> ndo_vflag ) {,2659
700,"buggy line: ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" ,  ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , ""none"" , * p & 0xc0 ) , length ) ) ;cwe id:CWE-125context: static void handle_mlppp ( netdissect_options * ndo , const u_char * p , int length ) { if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""MLPPP,<S2SV_blank>"" ) ) ;  ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" ,  ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , ""none"" , * p & 0xc0 ) , length ) ) ; }","if ( length < 2 ) {ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ;return ;}if ( ! ND_TTEST_16BITS ( p ) ) {ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ;return ;}ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , ""none"" , * p & 0xc0 ) , length ) ) ;",2660
701,"buggy line: return vp8_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ;}cwe id:CWE-119context: static int get_prediction_error ( BLOCK * be , BLOCKD * b ) { unsigned char * sptr ; unsigned char * dptr ; sptr = ( * ( be -> base_src ) + be -> src ) ; dptr = b -> predictor ;  return vp8_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ;  }","return vpx_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ;}",2661
702,"buggy line: if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ;__TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ;if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ;th = ( const struct tcphdr * ) skb -> data ;if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ;if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ;if ( skb_checksum_init ( skb , IPPROTO_TCP , ip6_compute_pseudo ) ) goto csum_error ;th = ( const struct tcphdr * ) skb -> data ;hdr = ipv6_hdr ( skb ) ;lookup : sk = __inet6_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , inet6_iif ( skb ) , & refcounted ) ;if ( ! sk ) goto no_tcp_socket ;process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ;if ( sk -> sk_state == TCP_NEW_SYN_RECV ) {struct request_sock * req = inet_reqsk ( sk ) ;struct sock * nsk ;sk = req -> rsk_listener ;tcp_v6_fill_cb ( skb , hdr , th ) ;if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) {cwe id:CWE-284context: static int tcp_v6_rcv ( struct sk_buff * skb ) { const struct tcphdr * th ; const struct ipv6hdr * hdr ; bool refcounted ; struct sock * sk ; int ret ; struct net * net = dev_net ( skb -> dev ) ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; __TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ; if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ; th = ( const struct tcphdr * ) skb -> data ; if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ; if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ; if ( skb_checksum_init ( skb , IPPROTO_TCP , ip6_compute_pseudo ) ) goto csum_error ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb ) ; lookup : sk = __inet6_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , inet6_iif ( skb ) , & refcounted ) ; if ( ! sk ) goto no_tcp_socket ; process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ; if ( sk -> sk_state == TCP_NEW_SYN_RECV ) { struct request_sock * req = inet_reqsk ( sk ) ; struct sock * nsk ; sk = req -> rsk_listener ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) { sk_drops_add ( sk , skb ) ; reqsk_put ( req ) ; goto discard_it ; } if ( unlikely ( sk -> sk_state != TCP_LISTEN ) ) { inet_csk_reqsk_queue_drop_and_put ( sk , req ) ; goto lookup ; } sock_hold ( sk ) ; refcounted = true ; nsk = tcp_check_req ( sk , skb , req , false ) ; if ( ! nsk ) { reqsk_put ( req ) ; goto discard_and_relse ; } if ( nsk == sk ) { reqsk_put ( req ) ; tcp_v6_restore_cb ( skb ) ; } else if ( tcp_child_process ( sk , nsk , skb ) ) { tcp_v6_send_reset ( nsk , skb ) ; goto discard_and_relse ; } else { sock_put ( sk ) ; return 0 ; } } if ( hdr -> hop_limit < inet6_sk ( sk ) -> min_hopcount ) { __NET_INC_STATS ( net , LINUX_MIB_TCPMINTTLDROP ) ; goto discard_and_relse ; } if ( ! xfrm6_policy_check ( sk , XFRM_POLICY_IN , skb ) ) goto discard_and_relse ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) goto discard_and_relse ;  if ( sk_filter ( sk , skb ) )   goto discard_and_relse ;  skb -> dev = NULL ; if ( sk -> sk_state == TCP_LISTEN ) { ret = tcp_v6_do_rcv ( sk , skb ) ; goto put_and_return ; } sk_incoming_cpu_update ( sk ) ; bh_lock_sock_nested ( sk ) ; tcp_segs_in ( tcp_sk ( sk ) , skb ) ; ret = 0 ; if ( ! sock_owned_by_user ( sk ) ) { if ( ! tcp_prequeue ( sk , skb ) ) ret = tcp_v6_do_rcv ( sk , skb ) ; } else if ( tcp_add_backlog ( sk , skb ) ) { goto discard_and_relse ; } bh_unlock_sock ( sk ) ; put_and_return : if ( refcounted ) sock_put ( sk ) ; return ret ? - 1 : 0 ; no_tcp_socket : if ( ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) goto discard_it ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_checksum_complete ( skb ) ) { csum_error : __TCP_INC_STATS ( net , TCP_MIB_CSUMERRORS ) ; bad_packet : __TCP_INC_STATS ( net , TCP_MIB_INERRS ) ; } else { tcp_v6_send_reset ( NULL , skb ) ; } discard_it : kfree_skb ( skb ) ; return 0 ; discard_and_relse : sk_drops_add ( sk , skb ) ; if ( refcounted ) sock_put ( sk ) ; goto discard_it ; do_time_wait : if ( ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto discard_it ; } tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_checksum_complete ( skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto csum_error ; } switch ( tcp_timewait_state_process ( inet_twsk ( sk ) , skb , th ) ) { case TCP_TW_SYN : { struct sock * sk2 ; sk2 = inet6_lookup_listener ( dev_net ( skb -> dev ) , & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , & ipv6_hdr ( skb ) -> saddr , th -> source , & ipv6_hdr ( skb ) -> daddr , ntohs ( th -> dest ) , tcp_v6_iif ( skb ) ) ; if ( sk2 ) { struct inet_timewait_sock * tw = inet_twsk ( sk ) ; inet_twsk_deschedule_put ( tw ) ; sk = sk2 ; tcp_v6_restore_cb ( skb ) ; refcounted = false ; goto process ; } } case TCP_TW_ACK : tcp_v6_timewait_ack ( sk , skb ) ; break ; case TCP_TW_RST : tcp_v6_restore_cb ( skb ) ; tcp_v6_send_reset ( sk , skb ) ; inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; goto discard_it ; case TCP_TW_SUCCESS : ; } goto discard_it ; }","if ( tcp_filter ( sk , skb ) ) {",2662
703,"buggy line: if ( sk_filter ( sk , skb ) )   goto discard_and_relse ;skb -> dev = NULL ;cwe id:CWE-284context: static int tcp_v6_rcv ( struct sk_buff * skb ) { const struct tcphdr * th ; const struct ipv6hdr * hdr ; bool refcounted ; struct sock * sk ; int ret ; struct net * net = dev_net ( skb -> dev ) ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; __TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ; if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ; th = ( const struct tcphdr * ) skb -> data ; if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ; if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ; if ( skb_checksum_init ( skb , IPPROTO_TCP , ip6_compute_pseudo ) ) goto csum_error ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb ) ; lookup : sk = __inet6_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , inet6_iif ( skb ) , & refcounted ) ; if ( ! sk ) goto no_tcp_socket ; process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ; if ( sk -> sk_state == TCP_NEW_SYN_RECV ) { struct request_sock * req = inet_reqsk ( sk ) ; struct sock * nsk ; sk = req -> rsk_listener ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) { sk_drops_add ( sk , skb ) ; reqsk_put ( req ) ; goto discard_it ; } if ( unlikely ( sk -> sk_state != TCP_LISTEN ) ) { inet_csk_reqsk_queue_drop_and_put ( sk , req ) ; goto lookup ; } sock_hold ( sk ) ; refcounted = true ; nsk = tcp_check_req ( sk , skb , req , false ) ; if ( ! nsk ) { reqsk_put ( req ) ; goto discard_and_relse ; } if ( nsk == sk ) { reqsk_put ( req ) ; tcp_v6_restore_cb ( skb ) ; } else if ( tcp_child_process ( sk , nsk , skb ) ) { tcp_v6_send_reset ( nsk , skb ) ; goto discard_and_relse ; } else { sock_put ( sk ) ; return 0 ; } } if ( hdr -> hop_limit < inet6_sk ( sk ) -> min_hopcount ) { __NET_INC_STATS ( net , LINUX_MIB_TCPMINTTLDROP ) ; goto discard_and_relse ; } if ( ! xfrm6_policy_check ( sk , XFRM_POLICY_IN , skb ) ) goto discard_and_relse ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) goto discard_and_relse ;  if ( sk_filter ( sk , skb ) )   goto discard_and_relse ;  skb -> dev = NULL ; if ( sk -> sk_state == TCP_LISTEN ) { ret = tcp_v6_do_rcv ( sk , skb ) ; goto put_and_return ; } sk_incoming_cpu_update ( sk ) ; bh_lock_sock_nested ( sk ) ; tcp_segs_in ( tcp_sk ( sk ) , skb ) ; ret = 0 ; if ( ! sock_owned_by_user ( sk ) ) { if ( ! tcp_prequeue ( sk , skb ) ) ret = tcp_v6_do_rcv ( sk , skb ) ; } else if ( tcp_add_backlog ( sk , skb ) ) { goto discard_and_relse ; } bh_unlock_sock ( sk ) ; put_and_return : if ( refcounted ) sock_put ( sk ) ; return ret ? - 1 : 0 ; no_tcp_socket : if ( ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) goto discard_it ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_checksum_complete ( skb ) ) { csum_error : __TCP_INC_STATS ( net , TCP_MIB_CSUMERRORS ) ; bad_packet : __TCP_INC_STATS ( net , TCP_MIB_INERRS ) ; } else { tcp_v6_send_reset ( NULL , skb ) ; } discard_it : kfree_skb ( skb ) ; return 0 ; discard_and_relse : sk_drops_add ( sk , skb ) ; if ( refcounted ) sock_put ( sk ) ; goto discard_it ; do_time_wait : if ( ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto discard_it ; } tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_checksum_complete ( skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto csum_error ; } switch ( tcp_timewait_state_process ( inet_twsk ( sk ) , skb , th ) ) { case TCP_TW_SYN : { struct sock * sk2 ; sk2 = inet6_lookup_listener ( dev_net ( skb -> dev ) , & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , & ipv6_hdr ( skb ) -> saddr , th -> source , & ipv6_hdr ( skb ) -> daddr , ntohs ( th -> dest ) , tcp_v6_iif ( skb ) ) ; if ( sk2 ) { struct inet_timewait_sock * tw = inet_twsk ( sk ) ; inet_twsk_deschedule_put ( tw ) ; sk = sk2 ; tcp_v6_restore_cb ( skb ) ; refcounted = false ; goto process ; } } case TCP_TW_ACK : tcp_v6_timewait_ack ( sk , skb ) ; break ; case TCP_TW_RST : tcp_v6_restore_cb ( skb ) ; tcp_v6_send_reset ( sk , skb ) ; inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; goto discard_it ; case TCP_TW_SUCCESS : ; } goto discard_it ; }","th = ( const struct tcphdr * ) skb -> data ;hdr = ipv6_hdr ( skb ) ;if ( sk_filter ( sk , skb ) ) goto discard_and_relse ;skb -> dev = NULL ;",2662
704,"buggy line: if ( keyring ) {cwe id:CWE-000context: int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; if ( keyring ) { if ( keyring -> restrict_link ) return - EPERM ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { atomic_inc ( & key -> user -> nikeys ) ; key -> reject_error = - error ; smp_wmb ( ) ; set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ;  if ( keyring )  __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret == 0 ? link_ret : ret ; }",if ( keyring && link_ret == 0 ) {,2663
705,"buggy line: if ( keyring )  __key_link_end ( keyring , & key -> index_key , edit ) ;cwe id:CWE-000context: int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; if ( keyring ) { if ( keyring -> restrict_link ) return - EPERM ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { atomic_inc ( & key -> user -> nikeys ) ; key -> reject_error = - error ; smp_wmb ( ) ; set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ;  if ( keyring )  __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret == 0 ? link_ret : ret ; }","if ( keyring ) __key_link_end ( keyring , & key -> index_key , edit ) ;",2663
706,"buggy line: av_cold void ff_mpv_idct_init ( MpegEncContext * s )  {ff_idctdsp_init ( & s -> idsp , s -> avctx ) ;cwe id:CWE-476context: av_cold void ff_mpv_idct_init ( MpegEncContext * s )  {  ff_idctdsp_init ( & s -> idsp , s -> avctx ) ; if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; } ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; }","av_cold void ff_mpv_idct_init ( MpegEncContext * s ) {if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;ff_idctdsp_init ( & s -> idsp , s -> avctx ) ;",2664
707,"buggy line: numSamples = pWTIntFrame -> numSamples ;pOutputBuffer = pWTIntFrame -> pAudioBuffer ;cwe id:CWE-119context: void WT_InterpolateNoLoop ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ;  numSamples = pWTIntFrame -> numSamples ;  pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = ( EAS_I32 ) pWTVoice -> phaseFrac ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }","numSamples = pWTIntFrame -> numSamples ;if ( numSamples <= 0 ) {ALOGE ( ""b/26366256"" ) ;return ;}pOutputBuffer = pWTIntFrame -> pAudioBuffer ;",2665
708,"buggy line: split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?  EXT4_EXT_MAY_ZEROOUT : 0 ;err = ext4_split_extent_at ( handle , inode , path ,  map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ;split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?  EXT4_EXT_MAY_ZEROOUT : 0 ;cwe id:CWE-362context: static int ext4_split_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_map_blocks * map , int split_flag , int flags ) { ext4_lblk_t ee_block ; struct ext4_extent * ex ; unsigned int ee_len , depth ; int err = 0 ; int uninitialized ; int split_flag1 , flags1 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; uninitialized = ext4_ext_is_uninitialized ( ex ) ; if ( map -> m_lblk + map -> m_len < ee_block + ee_len ) {  split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?  EXT4_EXT_MAY_ZEROOUT : 0 ; flags1 = flags | EXT4_GET_BLOCKS_PRE_IO ; if ( uninitialized ) split_flag1 |= EXT4_EXT_MARK_UNINIT1 | EXT4_EXT_MARK_UNINIT2 ;  err = ext4_split_extent_at ( handle , inode , path ,  map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ; if ( err ) goto out ; } ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) return PTR_ERR ( path ) ; if ( map -> m_lblk >= ee_block ) {  split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?  EXT4_EXT_MAY_ZEROOUT : 0 ; if ( uninitialized ) split_flag1 |= EXT4_EXT_MARK_UNINIT1 ; if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) split_flag1 |= EXT4_EXT_MARK_UNINIT2 ; err = ext4_split_extent_at ( handle , inode , path , map -> m_lblk , split_flag1 , flags ) ; if ( err ) goto out ; } ext4_ext_show_leaf ( inode , path ) ; out : return err ? err : map -> m_len ; }","split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ;if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ;err = ext4_split_extent_at ( handle , inode , path , map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ;split_flag1 = split_flag & ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) ;",2666
709,"buggy line: user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user ) return ERR_PTR ( - ENOMEM ) ;cwe id:CWE-20context: static struct key * construct_key_and_link ( struct keyring_search_context * ctx , const char * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct key_user * user ; struct key * key ; int ret ; kenter ( """" ) ;  user = key_user_lookup ( current_fsuid ( ) ) ;  if ( ! user ) return ERR_PTR ( - ENOMEM ) ; construct_get_dest_keyring ( & dest_keyring ) ; ret = construct_alloc_key ( ctx , dest_keyring , flags , user , & key ) ; key_user_put ( user ) ; if ( ret == 0 ) { ret = construct_key ( key , callout_info , callout_len , aux , dest_keyring ) ; if ( ret < 0 ) { kdebug ( ""cons<S2SV_blank>failed"" ) ; goto construction_failed ; } } else if ( ret == - EINPROGRESS ) { ret = 0 ; } else { goto couldnt_alloc_key ; } key_put ( dest_keyring ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>key<S2SV_blank>%d"" , key_serial ( key ) ) ; return key ; construction_failed : key_negate_and_link ( key , key_negative_timeout , NULL , NULL ) ; key_put ( key ) ; couldnt_alloc_key : key_put ( dest_keyring ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ERR_PTR ( ret ) ; }",if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ;user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user ) return ERR_PTR ( - ENOMEM ) ;,2667
710,"buggy line: BIO * cmsbio = NULL , * tmpin = NULL ;if ( ! dcont && ! check_content ( cms ) ) return 0 ;cwe id:CWE-399context: int CMS_verify ( CMS_ContentInfo * cms , STACK_OF ( X509 ) * certs , X509_STORE * store , BIO * dcont , BIO * out , unsigned int flags ) { CMS_SignerInfo * si ; STACK_OF ( CMS_SignerInfo ) * sinfos ; STACK_OF ( X509 ) * cms_certs = NULL ; STACK_OF ( X509_CRL ) * crls = NULL ; X509 * signer ; int i , scount = 0 , ret = 0 ;  BIO * cmsbio = NULL , * tmpin = NULL ;  if ( ! dcont && ! check_content ( cms ) ) return 0 ; sinfos = CMS_get0_SignerInfos ( cms ) ; if ( sk_CMS_SignerInfo_num ( sinfos ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_NO_SIGNERS ) ; goto err ; } for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; CMS_SignerInfo_get0_algs ( si , NULL , & signer , NULL , NULL ) ; if ( signer ) scount ++ ; } if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) scount += CMS_set1_signers_certs ( cms , certs , flags ) ; if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SIGNER_CERTIFICATE_NOT_FOUND ) ; goto err ; } if ( ! ( flags & CMS_NO_SIGNER_CERT_VERIFY ) ) { cms_certs = CMS_get1_certs ( cms ) ; if ( ! ( flags & CMS_NOCRL ) ) crls = CMS_get1_crls ( cms ) ; for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( ! cms_signerinfo_verify_cert ( si , store , cms_certs , crls , flags ) ) goto err ; } } if ( ! ( flags & CMS_NO_ATTR_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_signed_get_attr_count ( si ) < 0 ) continue ; if ( CMS_SignerInfo_verify ( si ) <= 0 ) goto err ; } } if ( dcont && ( BIO_method_type ( dcont ) == BIO_TYPE_MEM ) ) { char * ptr ; long len ; len = BIO_get_mem_data ( dcont , & ptr ) ; tmpin = BIO_new_mem_buf ( ptr , len ) ; if ( tmpin == NULL ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; return 0 ; } } else tmpin = dcont ;  cmsbio = CMS_dataInit ( cms , tmpin ) ;  if ( ! cmsbio ) goto err ; if ( ! cms_copy_content ( out , cmsbio , flags ) )  goto err ;  if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_SignerInfo_verify_content ( si , cmsbio ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_CONTENT_VERIFY_ERROR ) ; goto err ; } } } ret = 1 ; err :  if ( dcont && ( tmpin == dcont ) )  do_free_upto ( cmsbio , dcont ) ; else BIO_free_all ( cmsbio ) ;  if ( cms_certs )  sk_X509_pop_free ( cms_certs , X509_free ) ; if ( crls ) sk_X509_CRL_pop_free ( crls , X509_CRL_free ) ; return ret ; }","BIO * cmsbio = NULL , * tmpin = NULL , * tmpout = NULL ;if ( ! dcont && ! check_content ( cms ) ) return 0 ;",2668
711,"buggy line: cmsbio = CMS_dataInit ( cms , tmpin ) ;if ( ! cmsbio ) goto err ;if ( ! cms_copy_content ( out , cmsbio , flags ) )  goto err ;if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) {cwe id:CWE-399context: int CMS_verify ( CMS_ContentInfo * cms , STACK_OF ( X509 ) * certs , X509_STORE * store , BIO * dcont , BIO * out , unsigned int flags ) { CMS_SignerInfo * si ; STACK_OF ( CMS_SignerInfo ) * sinfos ; STACK_OF ( X509 ) * cms_certs = NULL ; STACK_OF ( X509_CRL ) * crls = NULL ; X509 * signer ; int i , scount = 0 , ret = 0 ;  BIO * cmsbio = NULL , * tmpin = NULL ;  if ( ! dcont && ! check_content ( cms ) ) return 0 ; sinfos = CMS_get0_SignerInfos ( cms ) ; if ( sk_CMS_SignerInfo_num ( sinfos ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_NO_SIGNERS ) ; goto err ; } for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; CMS_SignerInfo_get0_algs ( si , NULL , & signer , NULL , NULL ) ; if ( signer ) scount ++ ; } if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) scount += CMS_set1_signers_certs ( cms , certs , flags ) ; if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SIGNER_CERTIFICATE_NOT_FOUND ) ; goto err ; } if ( ! ( flags & CMS_NO_SIGNER_CERT_VERIFY ) ) { cms_certs = CMS_get1_certs ( cms ) ; if ( ! ( flags & CMS_NOCRL ) ) crls = CMS_get1_crls ( cms ) ; for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( ! cms_signerinfo_verify_cert ( si , store , cms_certs , crls , flags ) ) goto err ; } } if ( ! ( flags & CMS_NO_ATTR_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_signed_get_attr_count ( si ) < 0 ) continue ; if ( CMS_SignerInfo_verify ( si ) <= 0 ) goto err ; } } if ( dcont && ( BIO_method_type ( dcont ) == BIO_TYPE_MEM ) ) { char * ptr ; long len ; len = BIO_get_mem_data ( dcont , & ptr ) ; tmpin = BIO_new_mem_buf ( ptr , len ) ; if ( tmpin == NULL ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; return 0 ; } } else tmpin = dcont ;  cmsbio = CMS_dataInit ( cms , tmpin ) ;  if ( ! cmsbio ) goto err ; if ( ! cms_copy_content ( out , cmsbio , flags ) )  goto err ;  if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_SignerInfo_verify_content ( si , cmsbio ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_CONTENT_VERIFY_ERROR ) ; goto err ; } } } ret = 1 ; err :  if ( dcont && ( tmpin == dcont ) )  do_free_upto ( cmsbio , dcont ) ; else BIO_free_all ( cmsbio ) ;  if ( cms_certs )  sk_X509_pop_free ( cms_certs , X509_free ) ; if ( crls ) sk_X509_CRL_pop_free ( crls , X509_CRL_free ) ; return ret ; }","if ( ! ( flags & SMIME_BINARY ) && dcont ) {tmpout = cms_get_text_bio ( out , flags ) ;if ( ! tmpout ) {CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ;goto err ;}cmsbio = CMS_dataInit ( cms , tmpout ) ;if ( ! cmsbio ) goto err ;}SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ;if ( flags & CMS_TEXT ) {if ( ! SMIME_text ( tmpout , out ) ) {CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ;goto err ;}}}else {cmsbio = CMS_dataInit ( cms , tmpin ) ;if ( ! cmsbio ) goto err ;if ( ! cms_copy_content ( out , cmsbio , flags ) ) goto err ;if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) {",2668
712,"buggy line: err :  if ( dcont && ( tmpin == dcont ) )  do_free_upto ( cmsbio , dcont ) ;if ( cms_certs )  sk_X509_pop_free ( cms_certs , X509_free ) ;cwe id:CWE-399context: int CMS_verify ( CMS_ContentInfo * cms , STACK_OF ( X509 ) * certs , X509_STORE * store , BIO * dcont , BIO * out , unsigned int flags ) { CMS_SignerInfo * si ; STACK_OF ( CMS_SignerInfo ) * sinfos ; STACK_OF ( X509 ) * cms_certs = NULL ; STACK_OF ( X509_CRL ) * crls = NULL ; X509 * signer ; int i , scount = 0 , ret = 0 ;  BIO * cmsbio = NULL , * tmpin = NULL ;  if ( ! dcont && ! check_content ( cms ) ) return 0 ; sinfos = CMS_get0_SignerInfos ( cms ) ; if ( sk_CMS_SignerInfo_num ( sinfos ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_NO_SIGNERS ) ; goto err ; } for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; CMS_SignerInfo_get0_algs ( si , NULL , & signer , NULL , NULL ) ; if ( signer ) scount ++ ; } if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) scount += CMS_set1_signers_certs ( cms , certs , flags ) ; if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SIGNER_CERTIFICATE_NOT_FOUND ) ; goto err ; } if ( ! ( flags & CMS_NO_SIGNER_CERT_VERIFY ) ) { cms_certs = CMS_get1_certs ( cms ) ; if ( ! ( flags & CMS_NOCRL ) ) crls = CMS_get1_crls ( cms ) ; for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( ! cms_signerinfo_verify_cert ( si , store , cms_certs , crls , flags ) ) goto err ; } } if ( ! ( flags & CMS_NO_ATTR_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_signed_get_attr_count ( si ) < 0 ) continue ; if ( CMS_SignerInfo_verify ( si ) <= 0 ) goto err ; } } if ( dcont && ( BIO_method_type ( dcont ) == BIO_TYPE_MEM ) ) { char * ptr ; long len ; len = BIO_get_mem_data ( dcont , & ptr ) ; tmpin = BIO_new_mem_buf ( ptr , len ) ; if ( tmpin == NULL ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; return 0 ; } } else tmpin = dcont ;  cmsbio = CMS_dataInit ( cms , tmpin ) ;  if ( ! cmsbio ) goto err ; if ( ! cms_copy_content ( out , cmsbio , flags ) )  goto err ;  if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_SignerInfo_verify_content ( si , cmsbio ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_CONTENT_VERIFY_ERROR ) ; goto err ; } } } ret = 1 ; err :  if ( dcont && ( tmpin == dcont ) )  do_free_upto ( cmsbio , dcont ) ; else BIO_free_all ( cmsbio ) ;  if ( cms_certs )  sk_X509_pop_free ( cms_certs , X509_free ) ; if ( crls ) sk_X509_CRL_pop_free ( crls , X509_CRL_free ) ; return ret ; }","err : if ( ! ( flags & SMIME_BINARY ) && dcont ) {do_free_upto ( cmsbio , tmpout ) ;if ( tmpin != dcont ) BIO_free ( tmpin ) ;}else {if ( dcont && ( tmpin == dcont ) ) do_free_upto ( cmsbio , dcont ) ;}if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ;if ( cms_certs ) sk_X509_pop_free ( cms_certs , X509_free ) ;",2668
713,"buggy line: __ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;cwe id:CWE-200context: static int do_ip_vs_get_ctl ( struct sock * sk , int cmd , void __user * user , int * len ) { unsigned char arg [ 128 ] ; int ret = 0 ; unsigned int copylen ; struct net * net = sock_net ( sk ) ; struct netns_ipvs * ipvs = net_ipvs ( net ) ; BUG_ON ( ! net ) ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL ; if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) { pr_err ( ""get_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u\\n"" , * len , get_arglen [ GET_CMDID ( cmd ) ] ) ; return - EINVAL ; } copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; if ( copy_from_user ( arg , user , copylen ) != 0 ) return - EFAULT ; if ( cmd == IP_VS_SO_GET_DAEMON ) { struct ip_vs_daemon_user d [ 2 ] ; memset ( & d , 0 , sizeof ( d ) ) ; if ( mutex_lock_interruptible ( & ipvs -> sync_mutex ) ) return - ERESTARTSYS ; if ( ipvs -> sync_state & IP_VS_STATE_MASTER ) { d [ 0 ] . state = IP_VS_STATE_MASTER ; strlcpy ( d [ 0 ] . mcast_ifn , ipvs -> master_mcast_ifn , sizeof ( d [ 0 ] . mcast_ifn ) ) ; d [ 0 ] . syncid = ipvs -> master_syncid ; } if ( ipvs -> sync_state & IP_VS_STATE_BACKUP ) { d [ 1 ] . state = IP_VS_STATE_BACKUP ; strlcpy ( d [ 1 ] . mcast_ifn , ipvs -> backup_mcast_ifn , sizeof ( d [ 1 ] . mcast_ifn ) ) ; d [ 1 ] . syncid = ipvs -> backup_syncid ; } if ( copy_to_user ( user , & d , sizeof ( d ) ) != 0 ) ret = - EFAULT ; mutex_unlock ( & ipvs -> sync_mutex ) ; return ret ; } if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) return - ERESTARTSYS ; switch ( cmd ) { case IP_VS_SO_GET_VERSION : { char buf [ 64 ] ; sprintf ( buf , ""IP<S2SV_blank>Virtual<S2SV_blank>Server<S2SV_blank>version<S2SV_blank>%d.%d.%d<S2SV_blank>(size=%d)"" , NVERSION ( IP_VS_VERSION_CODE ) , ip_vs_conn_tab_size ) ; if ( copy_to_user ( user , buf , strlen ( buf ) + 1 ) != 0 ) { ret = - EFAULT ; goto out ; } * len = strlen ( buf ) + 1 ; } break ; case IP_VS_SO_GET_INFO : { struct ip_vs_getinfo info ; info . version = IP_VS_VERSION_CODE ; info . size = ip_vs_conn_tab_size ; info . num_services = ipvs -> num_services ; if ( copy_to_user ( user , & info , sizeof ( info ) ) != 0 ) ret = - EFAULT ; } break ; case IP_VS_SO_GET_SERVICES : { struct ip_vs_get_services * get ; int size ; get = ( struct ip_vs_get_services * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_service_entry ) * get -> num_services ; if ( * len != size ) { pr_err ( ""length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n"" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_service_entries ( net , get , user ) ; } break ; case IP_VS_SO_GET_SERVICE : { struct ip_vs_service_entry * entry ; struct ip_vs_service * svc ; union nf_inet_addr addr ; entry = ( struct ip_vs_service_entry * ) arg ; addr . ip = entry -> addr ; if ( entry -> fwmark ) svc = __ip_vs_svc_fwm_find ( net , AF_INET , entry -> fwmark ) ; else svc = __ip_vs_service_find ( net , AF_INET , entry -> protocol , & addr , entry -> port ) ; if ( svc ) { ip_vs_copy_service ( entry , svc ) ; if ( copy_to_user ( user , entry , sizeof ( * entry ) ) != 0 ) ret = - EFAULT ; } else ret = - ESRCH ; } break ; case IP_VS_SO_GET_DESTS : { struct ip_vs_get_dests * get ; int size ; get = ( struct ip_vs_get_dests * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_dest_entry ) * get -> num_dests ; if ( * len != size ) { pr_err ( ""length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n"" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_dest_entries ( net , get , user ) ; } break ; case IP_VS_SO_GET_TIMEOUT : { struct ip_vs_timeout_user t ;  __ip_vs_get_timeouts ( net , & t ) ;  if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ; } break ; default : ret = - EINVAL ; } out : mutex_unlock ( & __ip_vs_mutex ) ; return ret ; }","memset ( & t , 0 , sizeof ( t ) ) ;__ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;",2669
714,"buggy line: if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h )   ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;}return res ;cwe id:CWE-119context: static vpx_codec_err_t encoder_set_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg ) { vpx_codec_err_t res ;  if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h )   ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;  if ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ; res = validate_config ( ctx , cfg , & ctx -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { ctx -> cfg = * cfg ; set_encoder_config ( & ctx -> oxcf , & ctx -> cfg , & ctx -> extra_cfg ) ;  vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;   }  return res ; }","int force_key = 0 ;if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) {if ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( ! valid_ref_frame_size ( ctx -> cfg . g_w , ctx -> cfg . g_h , cfg -> g_w , cfg -> g_h ) || ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) force_key = 1 ;}if ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;force_key |= ctx -> cpi -> common . profile != ctx -> oxcf . profile ;vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;}if ( force_key ) ctx -> next_frame_flags |= VPX_EFLAG_FORCE_KF ;return res ;",2670
715,"buggy line: fp -> protocol = altsd -> bInterfaceProtocol ;if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ;cwe id:CWE-000context: static int create_fixed_stream_quirk ( struct snd_usb_audio * chip , struct usb_interface * iface , struct usb_driver * driver , const struct snd_usb_audio_quirk * quirk ) { struct audioformat * fp ; struct usb_host_interface * alts ; struct usb_interface_descriptor * altsd ; int stream , err ; unsigned * rate_table = NULL ; fp = kmemdup ( quirk -> data , sizeof ( * fp ) , GFP_KERNEL ) ; if ( ! fp ) { usb_audio_err ( chip , ""cannot<S2SV_blank>memdup\\n"" ) ; return - ENOMEM ; } if ( fp -> nr_rates > MAX_NR_RATES ) { kfree ( fp ) ; return - EINVAL ; } if ( fp -> nr_rates > 0 ) { rate_table = kmemdup ( fp -> rate_table , sizeof ( int ) * fp -> nr_rates , GFP_KERNEL ) ; if ( ! rate_table ) { kfree ( fp ) ; return - ENOMEM ; } fp -> rate_table = rate_table ; } stream = ( fp -> endpoint & USB_DIR_IN ) ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK ; err = snd_usb_add_audio_stream ( chip , stream , fp ) ; if ( err < 0 ) { kfree ( fp ) ; kfree ( rate_table ) ; return err ; } if ( fp -> iface != get_iface_desc ( & iface -> altsetting [ 0 ] ) -> bInterfaceNumber || fp -> altset_idx >= iface -> num_altsetting ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; } alts = & iface -> altsetting [ fp -> altset_idx ] ; altsd = get_iface_desc ( alts ) ;  fp -> protocol = altsd -> bInterfaceProtocol ;  if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ; if ( fp -> maxpacksize == 0 ) fp -> maxpacksize = le16_to_cpu ( get_endpoint ( alts , 0 ) -> wMaxPacketSize ) ; usb_set_interface ( chip -> dev , fp -> iface , 0 ) ; snd_usb_init_pitch ( chip , fp -> iface , alts , fp ) ; snd_usb_init_sample_rate ( chip , fp -> iface , alts , fp , fp -> rate_max ) ; return 0 ; }","if ( altsd -> bNumEndpoints < 1 ) {kfree ( fp ) ;kfree ( rate_table ) ;return - EINVAL ;}fp -> protocol = altsd -> bInterfaceProtocol ;if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ;",2671
716,"buggy line: if ( pkt == NULL )  continue ;cwe id:CWE-476context: static int add_push_report_sideband_pkt ( git_push * push , git_pkt_data * data_pkt , git_buf * data_pkt_buf ) { git_pkt * pkt ; const char * line , * line_end = NULL ; size_t line_len ; int error ; int reading_from_buf = data_pkt_buf -> size > 0 ; if ( reading_from_buf ) { git_buf_put ( data_pkt_buf , data_pkt -> data , data_pkt -> len ) ; line = data_pkt_buf -> ptr ; line_len = data_pkt_buf -> size ; } else { line = data_pkt -> data ; line_len = data_pkt -> len ; } while ( line_len > 0 ) { error = git_pkt_parse_line ( & pkt , line , & line_end , line_len ) ; if ( error == GIT_EBUFS ) { if ( ! reading_from_buf ) git_buf_put ( data_pkt_buf , line , line_len ) ; error = 0 ; goto done ; } else if ( error < 0 ) goto done ; line_len -= ( line_end - line ) ; line = line_end ;  if ( pkt == NULL )  continue ; error = add_push_report_pkt ( push , pkt ) ; git_pkt_free ( pkt ) ; if ( error < 0 && error != GIT_ITEROVER ) goto done ; } error = 0 ; done : if ( reading_from_buf ) git_buf_consume ( data_pkt_buf , line_end ) ; return error ; }","
",2672
717,"buggy line: int err = - EINVAL ;if ( ! kcontrol ) return err ;cwe id:CWE-000context: int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ;  int err = - EINVAL ;  if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ;  up_write ( & card -> controls_rwsem ) ;   for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }",unsigned int count ;int err = - EINVAL ;if ( ! kcontrol ) return err ;,2673
718,"buggy line: up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < kcontrol -> count ;idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;cwe id:CWE-000context: int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ;  int err = - EINVAL ;  if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ;  up_write ( & card -> controls_rwsem ) ;   for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }","count = kcontrol -> count ;up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < count ;idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;",2673
719,buggy line: while ( c ) {++ i ;c = c -> next ;}return i ;cwe id:CWE-119context: int cJSON_GetArraySize ( cJSON * array ) { cJSON * c = array -> child ; int i = 0 ;  while ( c ) {  ++ i ; c = c -> next ;  }  return i ; },"+ i ;while ( c ) i ++ , c = c -> next ;}return i ;",2674
720,"buggy line: time_t then ;then = 0 ;cwe id:CWE-400context: int srs_timestamp_check ( srs_t * srs , const char * stamp ) { const char * sp ; char * bp ; int off ; time_t now ;  time_t then ;  then = 0 ; for ( sp = stamp ; * sp ; sp ++ ) { bp = strchr ( SRS_TIME_BASECHARS , toupper ( * sp ) ) ; if ( bp == NULL ) return SRS_EBADTIMESTAMPCHAR ; off = bp - SRS_TIME_BASECHARS ; then = ( then << SRS_TIME_BASEBITS ) | off ; } time ( & now ) ; now = ( now / SRS_TIME_PRECISION ) % SRS_TIME_SLOTS ; while ( now < then ) now = now + SRS_TIME_SLOTS ; if ( now <= then + srs -> maxage ) return SRS_SUCCESS ; return SRS_ETIMESTAMPOUTOFDATE ; }",time_t then ;if ( strlen ( stamp ) != 2 ) return SRS_ETIMESTAMPOUTOFDATE ;then = 0 ;,2675
721,"buggy line: xmlNode *   crm_recv_remote_msg ( void * session , gboolean encrypted )  {char * reply = NULL ;xmlNode * xml = NULL ;if ( encrypted ) {# ifdef HAVE_GNUTLS_GNUTLS_H reply = cib_recv_tls ( session ) ;# else CRM_ASSERT ( encrypted == FALSE ) ;# endif }reply = cib_recv_plaintext ( GPOINTER_TO_INT ( session ) ) ;if ( reply == NULL || strlen ( reply ) == 0 ) {crm_trace ( ""Empty<S2SV_blank>reply"" ) ;xml = string2xml ( reply ) ;if ( xml == NULL ) {crm_err ( ""Couldn\\\'t<S2SV_blank>parse:<S2SV_blank>\\\'%.120s\\\'"" , reply ) ;free ( reply ) ;return xml ;cwe id:CWE-399context:  xmlNode *   crm_recv_remote_msg ( void * session , gboolean encrypted )  { char * reply = NULL ;  xmlNode * xml = NULL ;   if ( encrypted ) {  # ifdef HAVE_GNUTLS_GNUTLS_H reply = cib_recv_tls ( session ) ; # else CRM_ASSERT ( encrypted == FALSE ) ; # endif } else { reply = cib_recv_plaintext ( GPOINTER_TO_INT ( session ) ) ; } if ( reply == NULL || strlen ( reply ) == 0 ) { crm_trace ( ""Empty<S2SV_blank>reply"" ) ; } else { xml = string2xml ( reply ) ; if ( xml == NULL ) { crm_err ( ""Couldn\'t<S2SV_blank>parse:<S2SV_blank>\'%.120s\'"" , reply ) ; } } free ( reply ) ; return xml ; }","gboolean crm_recv_remote_msg ( void * session , char * * recv_buf , gboolean encrypted , int total_timeout , int * disconnected ) {int ret ;size_t request_len = 0 ;time_t start = time ( NULL ) ;char * raw_request = NULL ;int remaining_timeout = 0 ;if ( ret == 0 ) {crm_err ( ""poll<S2SV_blank>timed<S2SV_blank>out<S2SV_blank>(%d<S2SV_blank>ms)<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>msg"" , remaining_timeout ) ;return FALSE ;}else if ( ret < 0 ) {if ( errno != EINTR ) {crm_debug ( ""poll<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>msg,<S2SV_blank>rc:<S2SV_blank>%d,<S2SV_blank>errno:<S2SV_blank>%d"" , ret , errno ) ;* disconnected = 1 ;return FALSE ;}crm_debug ( ""poll<S2SV_blank>EINTR<S2SV_blank>encountered<S2SV_blank>during<S2SV_blank>poll,<S2SV_blank>retrying"" ) ;}raw_request = crm_recv_remote_raw ( session , encrypted , 0 , & request_len , disconnected ) ;remaining_timeout = remaining_timeout - ( ( time ( NULL ) - start ) * 1000 ) ;if ( ! raw_request ) {crm_debug ( ""Empty<S2SV_blank>msg<S2SV_blank>received<S2SV_blank>after<S2SV_blank>poll"" ) ;continue ;}if ( * recv_buf ) {int old_len = strlen ( * recv_buf ) ;crm_trace ( ""Expanding<S2SV_blank>recv<S2SV_blank>buffer<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d"" , old_len , old_len + request_len ) ;* recv_buf = realloc ( * recv_buf , old_len + request_len + 1 ) ;memcpy ( * recv_buf + old_len , raw_request , request_len ) ;* ( * recv_buf + old_len + request_len ) = \'\\\\0\' ;free ( raw_request ) ;* recv_buf = raw_request ;}if ( strstr ( * recv_buf , REMOTE_MSG_TERMINATOR ) ) {return TRUE ;return FALSE ;",2676
722,"buggy line: int r , len , group = 0 ;Node * qn ;Node * * tp ;* np = NULL ;if ( tok -> type == ( enum TokenSyms ) term )  goto end_of_token ;switch ( tok -> type ) {cwe id:CWE-674context: static int parse_exp ( Node * * np , PToken * tok , int term , UChar * * src , UChar * end , ScanEnv * env , int group_head ) {  int r , len , group = 0 ;  Node * qn ;  Node * * tp ;  * np = NULL ; if ( tok -> type == ( enum TokenSyms ) term )  goto end_of_token ;  switch ( tok -> type ) { case TK_ALT : case TK_EOT : end_of_token : * np = node_new_empty ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; return tok -> type ; break ; case TK_SUBEXP_OPEN : r = parse_bag ( np , tok , TK_SUBEXP_CLOSE , src , end , env ) ; if ( r < 0 ) return r ; if ( r == 1 ) { if ( group_head == 0 ) group = 1 ; else { Node * target = * np ; * np = node_new_group ( target ) ; if ( IS_NULL ( * np ) ) { onig_node_free ( target ) ; return ONIGERR_MEMORY ; } group = 2 ; } } else if ( r == 2 ) { Node * target ; OnigOptionType prev = env -> options ; env -> options = BAG_ ( * np ) -> o . options ; r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; r = parse_subexp ( & target , tok , term , src , end , env , 0 ) ; env -> options = prev ; if ( r < 0 ) { onig_node_free ( target ) ; return r ; } NODE_BODY ( * np ) = target ; return tok -> type ; } break ; case TK_SUBEXP_CLOSE : if ( ! IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP ) ) return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS ; if ( tok -> escaped ) goto tk_raw_byte ; else goto tk_byte ; break ; case TK_STRING : tk_byte : { * np = node_new_str ( tok -> backp , * src ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; while ( 1 ) { r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; if ( r != TK_STRING ) break ; r = onig_node_str_cat ( * np , tok -> backp , * src ) ; if ( r < 0 ) return r ; } string_end : tp = np ; goto repeat ; } break ; case TK_RAW_BYTE : tk_raw_byte : { * np = node_new_str_raw_char ( ( UChar ) tok -> u . c ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; len = 1 ; while ( 1 ) { if ( len >= ONIGENC_MBC_MINLEN ( env -> enc ) ) { if ( len == enclen ( env -> enc , STR_ ( * np ) -> s ) ) { r = fetch_token ( tok , src , end , env ) ; goto tk_raw_byte_end ; } } r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; if ( r != TK_RAW_BYTE ) return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING ; r = node_str_cat_char ( * np , ( UChar ) tok -> u . c ) ; if ( r < 0 ) return r ; len ++ ; } tk_raw_byte_end : if ( ! ONIGENC_IS_VALID_MBC_STRING ( env -> enc , STR_ ( * np ) -> s , STR_ ( * np ) -> end ) ) return ONIGERR_INVALID_WIDE_CHAR_VALUE ; NODE_STRING_CLEAR_RAW ( * np ) ; goto string_end ; } break ; case TK_CODE_POINT : { UChar buf [ ONIGENC_CODE_TO_MBC_MAXLEN ] ; len = ONIGENC_CODE_TO_MBC ( env -> enc , tok -> u . code , buf ) ; if ( len < 0 ) return len ; # ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG * np = node_new_str_raw ( buf , buf + len ) ; # else * np = node_new_str ( buf , buf + len ) ; # endif CHECK_NULL_RETURN_MEMERR ( * np ) ; } break ; case TK_QUOTE_OPEN : { OnigCodePoint end_op [ 2 ] ; UChar * qstart , * qend , * nextp ; end_op [ 0 ] = ( OnigCodePoint ) MC_ESC ( env -> syntax ) ; end_op [ 1 ] = ( OnigCodePoint ) 'E' ; qstart = * src ; qend = find_str_position ( end_op , 2 , qstart , end , & nextp , env -> enc ) ; if ( IS_NULL ( qend ) ) { nextp = qend = end ; } * np = node_new_str ( qstart , qend ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; * src = nextp ; } break ; case TK_CHAR_TYPE : { switch ( tok -> u . prop . ctype ) { case ONIGENC_CTYPE_WORD : * np = node_new_ctype ( tok -> u . prop . ctype , tok -> u . prop . not , env -> options ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; case ONIGENC_CTYPE_SPACE : case ONIGENC_CTYPE_DIGIT : case ONIGENC_CTYPE_XDIGIT : { CClassNode * cc ; * np = node_new_cclass ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; cc = CCLASS_ ( * np ) ; add_ctype_to_cc ( cc , tok -> u . prop . ctype , 0 , env ) ; if ( tok -> u . prop . not != 0 ) NCCLASS_SET_NOT ( cc ) ; } break ; default : return ONIGERR_PARSER_BUG ; break ; } } break ; case TK_CHAR_PROPERTY : r = parse_char_property ( np , tok , src , end , env ) ; if ( r != 0 ) return r ; break ; case TK_CC_OPEN : { CClassNode * cc ; r = parse_char_class ( np , tok , src , end , env ) ; if ( r != 0 ) return r ; cc = CCLASS_ ( * np ) ; if ( IS_IGNORECASE ( env -> options ) ) { IApplyCaseFoldArg iarg ; iarg . env = env ; iarg . cc = cc ; iarg . alt_root = NULL_NODE ; iarg . ptail = & ( iarg . alt_root ) ; r = ONIGENC_APPLY_ALL_CASE_FOLD ( env -> enc , env -> case_fold_flag , i_apply_case_fold , & iarg ) ; if ( r != 0 ) { onig_node_free ( iarg . alt_root ) ; return r ; } if ( IS_NOT_NULL ( iarg . alt_root ) ) { Node * work = onig_node_new_alt ( * np , iarg . alt_root ) ; if ( IS_NULL ( work ) ) { onig_node_free ( iarg . alt_root ) ; return ONIGERR_MEMORY ; } * np = work ; } } } break ; case TK_ANYCHAR : * np = node_new_anychar ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; case TK_ANYCHAR_ANYTIME : * np = node_new_anychar ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; qn = node_new_quantifier ( 0 , INFINITE_REPEAT , 0 ) ; CHECK_NULL_RETURN_MEMERR ( qn ) ; NODE_BODY ( qn ) = * np ; * np = qn ; break ; case TK_BACKREF : len = tok -> u . backref . num ; * np = node_new_backref ( len , ( len > 1 ? tok -> u . backref . refs : & ( tok -> u . backref . ref1 ) ) , tok -> u . backref . by_name , # ifdef USE_BACKREF_WITH_LEVEL tok -> u . backref . exist_level , tok -> u . backref . level , # endif env ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; # ifdef USE_CALL case TK_CALL : { int gnum = tok -> u . call . gnum ; * np = node_new_call ( tok -> u . call . name , tok -> u . call . name_end , gnum , tok -> u . call . by_number ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; env -> num_call ++ ; if ( tok -> u . call . by_number != 0 && gnum == 0 ) { env -> has_call_zero = 1 ; } } break ; # endif case TK_ANCHOR : { int ascii_mode = IS_WORD_ASCII ( env -> options ) && IS_WORD_ANCHOR_TYPE ( tok -> u . anchor ) ? 1 : 0 ; * np = onig_node_new_anchor ( tok -> u . anchor , ascii_mode ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; } break ; case TK_REPEAT : case TK_INTERVAL : if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS ) ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED ; else { * np = node_new_empty ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; } } else { goto tk_byte ; } break ; case TK_KEEP : r = node_new_keep ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_GENERAL_NEWLINE : r = node_new_general_newline ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_NO_NEWLINE : r = node_new_no_newline ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_TRUE_ANYCHAR : r = node_new_true_anychar ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_TEXT_SEGMENT : r = make_text_segment ( np , env ) ; if ( r < 0 ) return r ; break ; default : return ONIGERR_PARSER_BUG ; break ; } { tp = np ; re_entry : r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; repeat : if ( r == TK_REPEAT || r == TK_INTERVAL ) { Node * target ; if ( is_invalid_quantifier_target ( * tp ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ;  qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper ,  r == TK_INTERVAL ) ; CHECK_NULL_RETURN_MEMERR ( qn ) ; QUANT_ ( qn ) -> greedy = tok -> u . repeat . greedy ; if ( group == 2 ) { target = node_drop_group ( * tp ) ; * tp = NULL_NODE ; } else { target = * tp ; } r = set_quantifier ( qn , target , group , env ) ; if ( r < 0 ) { onig_node_free ( qn ) ; return r ; } if ( tok -> u . repeat . possessive != 0 ) { Node * en ; en = node_new_bag ( BAG_STOP_BACKTRACK ) ; if ( IS_NULL ( en ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } NODE_BODY ( en ) = qn ; qn = en ; } if ( r == 0 ) { * tp = qn ; } else if ( r == 1 ) { onig_node_free ( qn ) ; * tp = target ; } else if ( r == 2 ) { Node * tmp ; * tp = node_new_list ( * tp , NULL ) ; if ( IS_NULL ( * tp ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } tmp = NODE_CDR ( * tp ) = node_new_list ( qn , NULL ) ; if ( IS_NULL ( tmp ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } tp = & ( NODE_CAR ( tmp ) ) ; } group = 0 ; goto re_entry ; } } return r ; }","int r , len , group ;Node * qn ;Node * * tp ;unsigned int parse_depth ;group = 0 ;* np = NULL ;if ( tok -> type == ( enum TokenSyms ) term ) goto end_of_token ;parse_depth = env -> parse_depth ;switch ( tok -> type ) {",2677
723,"buggy line: qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper ,  r == TK_INTERVAL ) ;cwe id:CWE-674context: static int parse_exp ( Node * * np , PToken * tok , int term , UChar * * src , UChar * end , ScanEnv * env , int group_head ) {  int r , len , group = 0 ;  Node * qn ;  Node * * tp ;  * np = NULL ; if ( tok -> type == ( enum TokenSyms ) term )  goto end_of_token ;  switch ( tok -> type ) { case TK_ALT : case TK_EOT : end_of_token : * np = node_new_empty ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; return tok -> type ; break ; case TK_SUBEXP_OPEN : r = parse_bag ( np , tok , TK_SUBEXP_CLOSE , src , end , env ) ; if ( r < 0 ) return r ; if ( r == 1 ) { if ( group_head == 0 ) group = 1 ; else { Node * target = * np ; * np = node_new_group ( target ) ; if ( IS_NULL ( * np ) ) { onig_node_free ( target ) ; return ONIGERR_MEMORY ; } group = 2 ; } } else if ( r == 2 ) { Node * target ; OnigOptionType prev = env -> options ; env -> options = BAG_ ( * np ) -> o . options ; r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; r = parse_subexp ( & target , tok , term , src , end , env , 0 ) ; env -> options = prev ; if ( r < 0 ) { onig_node_free ( target ) ; return r ; } NODE_BODY ( * np ) = target ; return tok -> type ; } break ; case TK_SUBEXP_CLOSE : if ( ! IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP ) ) return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS ; if ( tok -> escaped ) goto tk_raw_byte ; else goto tk_byte ; break ; case TK_STRING : tk_byte : { * np = node_new_str ( tok -> backp , * src ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; while ( 1 ) { r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; if ( r != TK_STRING ) break ; r = onig_node_str_cat ( * np , tok -> backp , * src ) ; if ( r < 0 ) return r ; } string_end : tp = np ; goto repeat ; } break ; case TK_RAW_BYTE : tk_raw_byte : { * np = node_new_str_raw_char ( ( UChar ) tok -> u . c ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; len = 1 ; while ( 1 ) { if ( len >= ONIGENC_MBC_MINLEN ( env -> enc ) ) { if ( len == enclen ( env -> enc , STR_ ( * np ) -> s ) ) { r = fetch_token ( tok , src , end , env ) ; goto tk_raw_byte_end ; } } r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; if ( r != TK_RAW_BYTE ) return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING ; r = node_str_cat_char ( * np , ( UChar ) tok -> u . c ) ; if ( r < 0 ) return r ; len ++ ; } tk_raw_byte_end : if ( ! ONIGENC_IS_VALID_MBC_STRING ( env -> enc , STR_ ( * np ) -> s , STR_ ( * np ) -> end ) ) return ONIGERR_INVALID_WIDE_CHAR_VALUE ; NODE_STRING_CLEAR_RAW ( * np ) ; goto string_end ; } break ; case TK_CODE_POINT : { UChar buf [ ONIGENC_CODE_TO_MBC_MAXLEN ] ; len = ONIGENC_CODE_TO_MBC ( env -> enc , tok -> u . code , buf ) ; if ( len < 0 ) return len ; # ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG * np = node_new_str_raw ( buf , buf + len ) ; # else * np = node_new_str ( buf , buf + len ) ; # endif CHECK_NULL_RETURN_MEMERR ( * np ) ; } break ; case TK_QUOTE_OPEN : { OnigCodePoint end_op [ 2 ] ; UChar * qstart , * qend , * nextp ; end_op [ 0 ] = ( OnigCodePoint ) MC_ESC ( env -> syntax ) ; end_op [ 1 ] = ( OnigCodePoint ) 'E' ; qstart = * src ; qend = find_str_position ( end_op , 2 , qstart , end , & nextp , env -> enc ) ; if ( IS_NULL ( qend ) ) { nextp = qend = end ; } * np = node_new_str ( qstart , qend ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; * src = nextp ; } break ; case TK_CHAR_TYPE : { switch ( tok -> u . prop . ctype ) { case ONIGENC_CTYPE_WORD : * np = node_new_ctype ( tok -> u . prop . ctype , tok -> u . prop . not , env -> options ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; case ONIGENC_CTYPE_SPACE : case ONIGENC_CTYPE_DIGIT : case ONIGENC_CTYPE_XDIGIT : { CClassNode * cc ; * np = node_new_cclass ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; cc = CCLASS_ ( * np ) ; add_ctype_to_cc ( cc , tok -> u . prop . ctype , 0 , env ) ; if ( tok -> u . prop . not != 0 ) NCCLASS_SET_NOT ( cc ) ; } break ; default : return ONIGERR_PARSER_BUG ; break ; } } break ; case TK_CHAR_PROPERTY : r = parse_char_property ( np , tok , src , end , env ) ; if ( r != 0 ) return r ; break ; case TK_CC_OPEN : { CClassNode * cc ; r = parse_char_class ( np , tok , src , end , env ) ; if ( r != 0 ) return r ; cc = CCLASS_ ( * np ) ; if ( IS_IGNORECASE ( env -> options ) ) { IApplyCaseFoldArg iarg ; iarg . env = env ; iarg . cc = cc ; iarg . alt_root = NULL_NODE ; iarg . ptail = & ( iarg . alt_root ) ; r = ONIGENC_APPLY_ALL_CASE_FOLD ( env -> enc , env -> case_fold_flag , i_apply_case_fold , & iarg ) ; if ( r != 0 ) { onig_node_free ( iarg . alt_root ) ; return r ; } if ( IS_NOT_NULL ( iarg . alt_root ) ) { Node * work = onig_node_new_alt ( * np , iarg . alt_root ) ; if ( IS_NULL ( work ) ) { onig_node_free ( iarg . alt_root ) ; return ONIGERR_MEMORY ; } * np = work ; } } } break ; case TK_ANYCHAR : * np = node_new_anychar ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; case TK_ANYCHAR_ANYTIME : * np = node_new_anychar ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; qn = node_new_quantifier ( 0 , INFINITE_REPEAT , 0 ) ; CHECK_NULL_RETURN_MEMERR ( qn ) ; NODE_BODY ( qn ) = * np ; * np = qn ; break ; case TK_BACKREF : len = tok -> u . backref . num ; * np = node_new_backref ( len , ( len > 1 ? tok -> u . backref . refs : & ( tok -> u . backref . ref1 ) ) , tok -> u . backref . by_name , # ifdef USE_BACKREF_WITH_LEVEL tok -> u . backref . exist_level , tok -> u . backref . level , # endif env ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; # ifdef USE_CALL case TK_CALL : { int gnum = tok -> u . call . gnum ; * np = node_new_call ( tok -> u . call . name , tok -> u . call . name_end , gnum , tok -> u . call . by_number ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; env -> num_call ++ ; if ( tok -> u . call . by_number != 0 && gnum == 0 ) { env -> has_call_zero = 1 ; } } break ; # endif case TK_ANCHOR : { int ascii_mode = IS_WORD_ASCII ( env -> options ) && IS_WORD_ANCHOR_TYPE ( tok -> u . anchor ) ? 1 : 0 ; * np = onig_node_new_anchor ( tok -> u . anchor , ascii_mode ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; } break ; case TK_REPEAT : case TK_INTERVAL : if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS ) ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED ; else { * np = node_new_empty ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; } } else { goto tk_byte ; } break ; case TK_KEEP : r = node_new_keep ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_GENERAL_NEWLINE : r = node_new_general_newline ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_NO_NEWLINE : r = node_new_no_newline ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_TRUE_ANYCHAR : r = node_new_true_anychar ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_TEXT_SEGMENT : r = make_text_segment ( np , env ) ; if ( r < 0 ) return r ; break ; default : return ONIGERR_PARSER_BUG ; break ; } { tp = np ; re_entry : r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; repeat : if ( r == TK_REPEAT || r == TK_INTERVAL ) { Node * target ; if ( is_invalid_quantifier_target ( * tp ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ;  qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper ,  r == TK_INTERVAL ) ; CHECK_NULL_RETURN_MEMERR ( qn ) ; QUANT_ ( qn ) -> greedy = tok -> u . repeat . greedy ; if ( group == 2 ) { target = node_drop_group ( * tp ) ; * tp = NULL_NODE ; } else { target = * tp ; } r = set_quantifier ( qn , target , group , env ) ; if ( r < 0 ) { onig_node_free ( qn ) ; return r ; } if ( tok -> u . repeat . possessive != 0 ) { Node * en ; en = node_new_bag ( BAG_STOP_BACKTRACK ) ; if ( IS_NULL ( en ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } NODE_BODY ( en ) = qn ; qn = en ; } if ( r == 0 ) { * tp = qn ; } else if ( r == 1 ) { onig_node_free ( qn ) ; * tp = target ; } else if ( r == 2 ) { Node * tmp ; * tp = node_new_list ( * tp , NULL ) ; if ( IS_NULL ( * tp ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } tmp = NODE_CDR ( * tp ) = node_new_list ( qn , NULL ) ; if ( IS_NULL ( tmp ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } tp = & ( NODE_CAR ( tmp ) ) ; } group = 0 ; goto re_entry ; } } return r ; }","parse_depth ++ ;if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , r == TK_INTERVAL ) ;",2677
724,"buggy line: if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ;return ;}if ( ! ndo -> ndo_eflag ) {ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ;}if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || PROTO_LEN ( ap ) != 4 || HRD_LEN ( ap ) == 0 || ndo -> ndo_vflag ) {ND_PRINT ( ( ndo , ""%s<S2SV_blank>(len<S2SV_blank>%u),<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , HRD_LEN ( ap ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , PROTO_LEN ( ap ) ) ) ;case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ;break ;case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" ,  ipaddr_string ( ndo , SPA ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" ,   linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_INVREPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" ,   linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , SPA ( ap ) ) ) ) ;cwe id:CWE-125context: void arp_print ( netdissect_options * ndo , const u_char * bp , u_int length , u_int caplen ) { const struct arp_pkthdr * ap ; u_short pro , hrd , op , linkaddr ; ap = ( const struct arp_pkthdr * ) bp ; ND_TCHECK ( * ap ) ; hrd = HRD ( ap ) ; pro = PRO ( ap ) ; op = OP ( ap ) ; switch ( hrd ) { case ARPHRD_ATM2225 : atmarp_print ( ndo , bp , length , caplen ) ; return ; case ARPHRD_FRELAY : linkaddr = LINKADDR_FRELAY ; break ; default : linkaddr = LINKADDR_ETHER ; break ; }  if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) {  ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; return ; } if ( ! ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ; } if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || PROTO_LEN ( ap ) != 4 || HRD_LEN ( ap ) == 0 || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>(len<S2SV_blank>%u),<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , HRD_LEN ( ap ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , PROTO_LEN ( ap ) ) ) ; if ( ! ndo -> ndo_vflag ) { goto out ; } } ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>"" , ndo -> ndo_vflag ? "",<S2SV_blank>"" : """" , tok2str ( arpop_values , ""Unknown<S2SV_blank>(%u)"" , op ) ) ) ; switch ( op ) { case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;  if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ;  break ; case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" ,  ipaddr_string ( ndo , SPA ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_REVREPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" ,   linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; break ; case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_INVREPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" ,   linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; break ; default : ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; return ; } out : ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","if ( ! ND_TTEST2 ( * TPA ( ap ) , PROTO_LEN ( ap ) ) ) {ND_PRINT ( ( ndo , ""who-has<S2SV_blank>"" ) ) ;tpaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;spaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REPLY : spaddr_print_ip ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>%s"" , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;tpaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REVREPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , linkaddr_string ( ndo , ""%s<S2SV_blank>at<S2SV_blank>"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_INVREPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;spaddr_print_ip ( ndo , ap , pro ) ;",2678
725,"buggy line: cwe id:CWE-617context: static Image * ReadMPCImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char cache_filename [ MagickPathExtent ] , id [ MagickPathExtent ] , keyword [ MagickPathExtent ] , * options ; const unsigned char * p ; GeometryInfo geometry_info ; Image * image ; int c ; LinkedListInfo * profiles ; MagickBooleanType status ; MagickOffsetType offset ; MagickStatusType flags ; register ssize_t i ; size_t depth , length ; ssize_t count ; StringInfo * profile ; unsigned int signature ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( cache_filename , image -> filename , MagickPathExtent ) ; AppendImageFormat ( ""cache"" , cache_filename ) ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } * id = '\\0' ; ( void ) ResetMagickMemory ( keyword , 0 , sizeof ( keyword ) ) ; offset = 0 ; do { profiles = ( LinkedListInfo * ) NULL ; length = MagickPathExtent ; options = AcquireString ( ( char * ) NULL ) ; signature = GetMagickSignature ( ( const StringInfo * ) NULL ) ; image -> depth = 8 ; image -> compression = NoCompression ; while ( ( isgraph ( c ) != MagickFalse ) && ( c != ( int ) ':' ) ) { register char * p ; if ( c == ( int ) '{' ) { char * comment ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '\\\\' ) c = ReadBlobByte ( image ) ; else if ( ( c == EOF ) || ( c == ( int ) '}' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) != MagickFalse ) { length = MagickPathExtent ; p = keyword ; do { if ( c == ( int ) '=' ) break ; if ( ( size_t ) ( p - keyword ) < ( MagickPathExtent - 1 ) ) * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } while ( c != EOF ) ; * p = '\\0' ; p = options ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; if ( c == ( int ) '=' ) { c = ReadBlobByte ( image ) ; while ( ( c != ( int ) '}' ) && ( c != EOF ) ) { if ( ( size_t ) ( p - options + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; options = ( char * ) ResizeQuantumMemory ( options , length + MagickPathExtent , sizeof ( * options ) ) ; if ( options == ( char * ) NULL ) break ; p = options + strlen ( options ) ; } * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; if ( c == '\\\\' ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '}' ) { * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } } if ( * options != '{' ) if ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) break ; } if ( options == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } * p = '\\0' ; if ( * options == '{' ) ( void ) CopyMagickString ( options , options + 1 , strlen ( options ) ) ; switch ( * keyword ) { case 'a' : case 'A' : { if ( LocaleCompare ( keyword , ""alpha-trait"" ) == 0 ) { ssize_t alpha_trait ; alpha_trait = ParseCommandOption ( MagickPixelTraitOptions , MagickFalse , options ) ; if ( alpha_trait < 0 ) break ; image -> alpha_trait = ( PixelTrait ) alpha_trait ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'b' : case 'B' : { if ( LocaleCompare ( keyword , ""background-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> background_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""blue-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . blue_primary . x = geometry_info . rho ; image -> chromaticity . blue_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . blue_primary . y = image -> chromaticity . blue_primary . x ; break ; } if ( LocaleCompare ( keyword , ""border-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> border_color , exception ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'c' : case 'C' : { if ( LocaleCompare ( keyword , ""class"" ) == 0 ) { ssize_t storage_class ; storage_class = ParseCommandOption ( MagickClassOptions , MagickFalse , options ) ; if ( storage_class < 0 ) break ; image -> storage_class = ( ClassType ) storage_class ; break ; } if ( LocaleCompare ( keyword , ""colors"" ) == 0 ) { image -> colors = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""colorspace"" ) == 0 ) { ssize_t colorspace ; colorspace = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , options ) ; if ( colorspace < 0 ) break ; image -> colorspace = ( ColorspaceType ) colorspace ; break ; } if ( LocaleCompare ( keyword , ""compression"" ) == 0 ) { ssize_t compression ; compression = ParseCommandOption ( MagickCompressOptions , MagickFalse , options ) ; if ( compression < 0 ) break ; image -> compression = ( CompressionType ) compression ; break ; } if ( LocaleCompare ( keyword , ""columns"" ) == 0 ) { image -> columns = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'd' : case 'D' : { if ( LocaleCompare ( keyword , ""delay"" ) == 0 ) { image -> delay = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""depth"" ) == 0 ) { image -> depth = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""dispose"" ) == 0 ) { ssize_t dispose ; dispose = ParseCommandOption ( MagickDisposeOptions , MagickFalse , options ) ; if ( dispose < 0 ) break ; image -> dispose = ( DisposeType ) dispose ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'e' : case 'E' : { if ( LocaleCompare ( keyword , ""endian"" ) == 0 ) { ssize_t endian ; endian = ParseCommandOption ( MagickEndianOptions , MagickFalse , options ) ; if ( endian < 0 ) break ; image -> endian = ( EndianType ) endian ; break ; } if ( LocaleCompare ( keyword , ""error"" ) == 0 ) { image -> error . mean_error_per_pixel = StringToDouble ( options , ( char * * ) NULL ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'g' : case 'G' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""green-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . green_primary . x = geometry_info . rho ; image -> chromaticity . green_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . green_primary . y = image -> chromaticity . green_primary . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'i' : case 'I' : { if ( LocaleCompare ( keyword , ""id"" ) == 0 ) { ( void ) CopyMagickString ( id , options , MagickPathExtent ) ; break ; } if ( LocaleCompare ( keyword , ""iterations"" ) == 0 ) { image -> iterations = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'm' : case 'M' : { if ( LocaleCompare ( keyword , ""magick-signature"" ) == 0 ) { signature = ( unsigned int ) StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""mattecolor"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> matte_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""maximum-error"" ) == 0 ) { image -> error . normalized_maximum_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""mean-error"" ) == 0 ) { image -> error . normalized_mean_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""montage"" ) == 0 ) { ( void ) CloneString ( & image -> montage , options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'n' : case 'N' : { if ( LocaleCompare ( keyword , ""number-channels"" ) == 0 ) { image -> number_channels = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""number-meta-channels"" ) == 0 ) { image -> number_meta_channels = StringToUnsignedLong ( options ) ;  break ;  } break ; } case 'o' : case 'O' : { if ( LocaleCompare ( keyword , ""orientation"" ) == 0 ) { ssize_t orientation ; orientation = ParseCommandOption ( MagickOrientationOptions , MagickFalse , options ) ; if ( orientation < 0 ) break ; image -> orientation = ( OrientationType ) orientation ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'p' : case 'P' : { if ( LocaleCompare ( keyword , ""page"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; geometry = DestroyString ( geometry ) ; break ; } if ( LocaleCompare ( keyword , ""pixel-intensity"" ) == 0 ) { ssize_t intensity ; intensity = ParseCommandOption ( MagickPixelIntensityOptions , MagickFalse , options ) ; if ( intensity < 0 ) break ; image -> intensity = ( PixelIntensityMethod ) intensity ; break ; } if ( ( LocaleNCompare ( keyword , ""profile:"" , 8 ) == 0 ) || ( LocaleNCompare ( keyword , ""profile-"" , 8 ) == 0 ) ) { if ( profiles == ( LinkedListInfo * ) NULL ) profiles = NewLinkedList ( 0 ) ; ( void ) AppendValueToLinkedList ( profiles , AcquireString ( keyword + 8 ) ) ; profile = BlobToStringInfo ( ( const void * ) NULL , ( size_t ) StringToLong ( options ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProfile ( image , keyword + 8 , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'q' : case 'Q' : { if ( LocaleCompare ( keyword , ""quality"" ) == 0 ) { image -> quality = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'r' : case 'R' : { if ( LocaleCompare ( keyword , ""red-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . red_primary . x = geometry_info . rho ; if ( ( flags & SigmaValue ) != 0 ) image -> chromaticity . red_primary . y = geometry_info . sigma ; break ; } if ( LocaleCompare ( keyword , ""rendering-intent"" ) == 0 ) { ssize_t rendering_intent ; rendering_intent = ParseCommandOption ( MagickIntentOptions , MagickFalse , options ) ; if ( rendering_intent < 0 ) break ; image -> rendering_intent = ( RenderingIntent ) rendering_intent ; break ; } if ( LocaleCompare ( keyword , ""resolution"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; break ; } if ( LocaleCompare ( keyword , ""rows"" ) == 0 ) { image -> rows = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 's' : case 'S' : { if ( LocaleCompare ( keyword , ""scene"" ) == 0 ) { image -> scene = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 't' : case 'T' : { if ( LocaleCompare ( keyword , ""ticks-per-second"" ) == 0 ) { image -> ticks_per_second = ( ssize_t ) StringToLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""tile-offset"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> tile_offset ) ; geometry = DestroyString ( geometry ) ; } if ( LocaleCompare ( keyword , ""type"" ) == 0 ) { ssize_t type ; type = ParseCommandOption ( MagickTypeOptions , MagickFalse , options ) ; if ( type < 0 ) break ; image -> type = ( ImageType ) type ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'u' : case 'U' : { if ( LocaleCompare ( keyword , ""units"" ) == 0 ) { ssize_t units ; units = ParseCommandOption ( MagickResolutionOptions , MagickFalse , options ) ; if ( units < 0 ) break ; image -> units = ( ResolutionType ) units ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'w' : case 'W' : { if ( LocaleCompare ( keyword , ""white-point"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . white_point . x = geometry_info . rho ; image -> chromaticity . white_point . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . white_point . y = image -> chromaticity . white_point . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } default : { ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } } } else c = ReadBlobByte ( image ) ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } options = DestroyString ( options ) ; ( void ) ReadBlobByte ( image ) ; if ( ( LocaleCompare ( id , ""MagickCache"" ) != 0 ) || ( image -> storage_class == UndefinedClass ) || ( image -> compression == UndefinedCompression ) || ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( signature != GetMagickSignature ( ( const StringInfo * ) NULL ) ) ThrowReaderException ( CacheError , ""IncompatibleAPI"" ) ; if ( image -> montage != ( char * ) NULL ) { register char * p ; length = MagickPathExtent ; image -> directory = AcquireString ( ( char * ) NULL ) ; p = image -> directory ; do { * p = '\\0' ; if ( ( strlen ( image -> directory ) + MagickPathExtent ) >= length ) { length <<= 1 ; image -> directory = ( char * ) ResizeQuantumMemory ( image -> directory , length + MagickPathExtent , sizeof ( * image -> directory ) ) ; if ( image -> directory == ( char * ) NULL ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = image -> directory + strlen ( image -> directory ) ; } c = ReadBlobByte ( image ) ; * p ++ = ( char ) c ; } while ( c != ( int ) '\\0' ) ; } if ( profiles != ( LinkedListInfo * ) NULL ) { const char * name ; const StringInfo * profile ; register unsigned char * p ; ResetLinkedListIterator ( profiles ) ; name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; while ( name != ( const char * ) NULL ) { profile = GetImageProfile ( image , name ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; count = ReadBlob ( image , GetStringInfoLength ( profile ) , p ) ; } name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; } profiles = DestroyLinkedList ( profiles , RelinquishMagickMemory ) ; } depth = GetImageQuantumDepth ( image , MagickFalse ) ; if ( image -> storage_class == PseudoClass ) { image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image -> colors != 0 ) { size_t packet_size ; unsigned char * colormap ; packet_size = ( size_t ) ( 3UL * depth / 8UL ) ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , packet_size * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , packet_size * image -> colors , colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = colormap ; switch ( depth ) { default : colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""ImageDepthNotSupported"" ) ; case 8 : { unsigned char pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( pixel ) ; } break ; } case 16 : { unsigned short pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleShortToQuantum ( pixel ) ; } break ; } case 32 : { unsigned int pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleLongToQuantum ( pixel ) ; } break ; } } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( AcquireMagickResource ( WidthResource , image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource , image -> rows ) == MagickFalse ) ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" ) ; status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( CacheError , ""UnableToPersistPixelCache"" ) ; do { c = ReadBlobByte ( image ) ; } while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ; if ( c != EOF ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( c != EOF ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",2679
726,"buggy line: break ;}cwe id:CWE-617context: static Image * ReadMPCImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char cache_filename [ MagickPathExtent ] , id [ MagickPathExtent ] , keyword [ MagickPathExtent ] , * options ; const unsigned char * p ; GeometryInfo geometry_info ; Image * image ; int c ; LinkedListInfo * profiles ; MagickBooleanType status ; MagickOffsetType offset ; MagickStatusType flags ; register ssize_t i ; size_t depth , length ; ssize_t count ; StringInfo * profile ; unsigned int signature ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( cache_filename , image -> filename , MagickPathExtent ) ; AppendImageFormat ( ""cache"" , cache_filename ) ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } * id = '\\0' ; ( void ) ResetMagickMemory ( keyword , 0 , sizeof ( keyword ) ) ; offset = 0 ; do { profiles = ( LinkedListInfo * ) NULL ; length = MagickPathExtent ; options = AcquireString ( ( char * ) NULL ) ; signature = GetMagickSignature ( ( const StringInfo * ) NULL ) ; image -> depth = 8 ; image -> compression = NoCompression ; while ( ( isgraph ( c ) != MagickFalse ) && ( c != ( int ) ':' ) ) { register char * p ; if ( c == ( int ) '{' ) { char * comment ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '\\\\' ) c = ReadBlobByte ( image ) ; else if ( ( c == EOF ) || ( c == ( int ) '}' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) != MagickFalse ) { length = MagickPathExtent ; p = keyword ; do { if ( c == ( int ) '=' ) break ; if ( ( size_t ) ( p - keyword ) < ( MagickPathExtent - 1 ) ) * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } while ( c != EOF ) ; * p = '\\0' ; p = options ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; if ( c == ( int ) '=' ) { c = ReadBlobByte ( image ) ; while ( ( c != ( int ) '}' ) && ( c != EOF ) ) { if ( ( size_t ) ( p - options + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; options = ( char * ) ResizeQuantumMemory ( options , length + MagickPathExtent , sizeof ( * options ) ) ; if ( options == ( char * ) NULL ) break ; p = options + strlen ( options ) ; } * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; if ( c == '\\\\' ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '}' ) { * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } } if ( * options != '{' ) if ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) break ; } if ( options == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } * p = '\\0' ; if ( * options == '{' ) ( void ) CopyMagickString ( options , options + 1 , strlen ( options ) ) ; switch ( * keyword ) { case 'a' : case 'A' : { if ( LocaleCompare ( keyword , ""alpha-trait"" ) == 0 ) { ssize_t alpha_trait ; alpha_trait = ParseCommandOption ( MagickPixelTraitOptions , MagickFalse , options ) ; if ( alpha_trait < 0 ) break ; image -> alpha_trait = ( PixelTrait ) alpha_trait ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'b' : case 'B' : { if ( LocaleCompare ( keyword , ""background-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> background_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""blue-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . blue_primary . x = geometry_info . rho ; image -> chromaticity . blue_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . blue_primary . y = image -> chromaticity . blue_primary . x ; break ; } if ( LocaleCompare ( keyword , ""border-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> border_color , exception ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'c' : case 'C' : { if ( LocaleCompare ( keyword , ""class"" ) == 0 ) { ssize_t storage_class ; storage_class = ParseCommandOption ( MagickClassOptions , MagickFalse , options ) ; if ( storage_class < 0 ) break ; image -> storage_class = ( ClassType ) storage_class ; break ; } if ( LocaleCompare ( keyword , ""colors"" ) == 0 ) { image -> colors = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""colorspace"" ) == 0 ) { ssize_t colorspace ; colorspace = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , options ) ; if ( colorspace < 0 ) break ; image -> colorspace = ( ColorspaceType ) colorspace ; break ; } if ( LocaleCompare ( keyword , ""compression"" ) == 0 ) { ssize_t compression ; compression = ParseCommandOption ( MagickCompressOptions , MagickFalse , options ) ; if ( compression < 0 ) break ; image -> compression = ( CompressionType ) compression ; break ; } if ( LocaleCompare ( keyword , ""columns"" ) == 0 ) { image -> columns = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'd' : case 'D' : { if ( LocaleCompare ( keyword , ""delay"" ) == 0 ) { image -> delay = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""depth"" ) == 0 ) { image -> depth = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""dispose"" ) == 0 ) { ssize_t dispose ; dispose = ParseCommandOption ( MagickDisposeOptions , MagickFalse , options ) ; if ( dispose < 0 ) break ; image -> dispose = ( DisposeType ) dispose ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'e' : case 'E' : { if ( LocaleCompare ( keyword , ""endian"" ) == 0 ) { ssize_t endian ; endian = ParseCommandOption ( MagickEndianOptions , MagickFalse , options ) ; if ( endian < 0 ) break ; image -> endian = ( EndianType ) endian ; break ; } if ( LocaleCompare ( keyword , ""error"" ) == 0 ) { image -> error . mean_error_per_pixel = StringToDouble ( options , ( char * * ) NULL ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'g' : case 'G' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""green-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . green_primary . x = geometry_info . rho ; image -> chromaticity . green_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . green_primary . y = image -> chromaticity . green_primary . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'i' : case 'I' : { if ( LocaleCompare ( keyword , ""id"" ) == 0 ) { ( void ) CopyMagickString ( id , options , MagickPathExtent ) ; break ; } if ( LocaleCompare ( keyword , ""iterations"" ) == 0 ) { image -> iterations = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'm' : case 'M' : { if ( LocaleCompare ( keyword , ""magick-signature"" ) == 0 ) { signature = ( unsigned int ) StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""mattecolor"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> matte_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""maximum-error"" ) == 0 ) { image -> error . normalized_maximum_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""mean-error"" ) == 0 ) { image -> error . normalized_mean_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""montage"" ) == 0 ) { ( void ) CloneString ( & image -> montage , options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'n' : case 'N' : { if ( LocaleCompare ( keyword , ""number-channels"" ) == 0 ) { image -> number_channels = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""number-meta-channels"" ) == 0 ) { image -> number_meta_channels = StringToUnsignedLong ( options ) ;  break ;  } break ; } case 'o' : case 'O' : { if ( LocaleCompare ( keyword , ""orientation"" ) == 0 ) { ssize_t orientation ; orientation = ParseCommandOption ( MagickOrientationOptions , MagickFalse , options ) ; if ( orientation < 0 ) break ; image -> orientation = ( OrientationType ) orientation ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'p' : case 'P' : { if ( LocaleCompare ( keyword , ""page"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; geometry = DestroyString ( geometry ) ; break ; } if ( LocaleCompare ( keyword , ""pixel-intensity"" ) == 0 ) { ssize_t intensity ; intensity = ParseCommandOption ( MagickPixelIntensityOptions , MagickFalse , options ) ; if ( intensity < 0 ) break ; image -> intensity = ( PixelIntensityMethod ) intensity ; break ; } if ( ( LocaleNCompare ( keyword , ""profile:"" , 8 ) == 0 ) || ( LocaleNCompare ( keyword , ""profile-"" , 8 ) == 0 ) ) { if ( profiles == ( LinkedListInfo * ) NULL ) profiles = NewLinkedList ( 0 ) ; ( void ) AppendValueToLinkedList ( profiles , AcquireString ( keyword + 8 ) ) ; profile = BlobToStringInfo ( ( const void * ) NULL , ( size_t ) StringToLong ( options ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProfile ( image , keyword + 8 , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'q' : case 'Q' : { if ( LocaleCompare ( keyword , ""quality"" ) == 0 ) { image -> quality = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'r' : case 'R' : { if ( LocaleCompare ( keyword , ""red-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . red_primary . x = geometry_info . rho ; if ( ( flags & SigmaValue ) != 0 ) image -> chromaticity . red_primary . y = geometry_info . sigma ; break ; } if ( LocaleCompare ( keyword , ""rendering-intent"" ) == 0 ) { ssize_t rendering_intent ; rendering_intent = ParseCommandOption ( MagickIntentOptions , MagickFalse , options ) ; if ( rendering_intent < 0 ) break ; image -> rendering_intent = ( RenderingIntent ) rendering_intent ; break ; } if ( LocaleCompare ( keyword , ""resolution"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; break ; } if ( LocaleCompare ( keyword , ""rows"" ) == 0 ) { image -> rows = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 's' : case 'S' : { if ( LocaleCompare ( keyword , ""scene"" ) == 0 ) { image -> scene = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 't' : case 'T' : { if ( LocaleCompare ( keyword , ""ticks-per-second"" ) == 0 ) { image -> ticks_per_second = ( ssize_t ) StringToLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""tile-offset"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> tile_offset ) ; geometry = DestroyString ( geometry ) ; } if ( LocaleCompare ( keyword , ""type"" ) == 0 ) { ssize_t type ; type = ParseCommandOption ( MagickTypeOptions , MagickFalse , options ) ; if ( type < 0 ) break ; image -> type = ( ImageType ) type ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'u' : case 'U' : { if ( LocaleCompare ( keyword , ""units"" ) == 0 ) { ssize_t units ; units = ParseCommandOption ( MagickResolutionOptions , MagickFalse , options ) ; if ( units < 0 ) break ; image -> units = ( ResolutionType ) units ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'w' : case 'W' : { if ( LocaleCompare ( keyword , ""white-point"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . white_point . x = geometry_info . rho ; image -> chromaticity . white_point . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . white_point . y = image -> chromaticity . white_point . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } default : { ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } } } else c = ReadBlobByte ( image ) ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } options = DestroyString ( options ) ; ( void ) ReadBlobByte ( image ) ; if ( ( LocaleCompare ( id , ""MagickCache"" ) != 0 ) || ( image -> storage_class == UndefinedClass ) || ( image -> compression == UndefinedCompression ) || ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( signature != GetMagickSignature ( ( const StringInfo * ) NULL ) ) ThrowReaderException ( CacheError , ""IncompatibleAPI"" ) ; if ( image -> montage != ( char * ) NULL ) { register char * p ; length = MagickPathExtent ; image -> directory = AcquireString ( ( char * ) NULL ) ; p = image -> directory ; do { * p = '\\0' ; if ( ( strlen ( image -> directory ) + MagickPathExtent ) >= length ) { length <<= 1 ; image -> directory = ( char * ) ResizeQuantumMemory ( image -> directory , length + MagickPathExtent , sizeof ( * image -> directory ) ) ; if ( image -> directory == ( char * ) NULL ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = image -> directory + strlen ( image -> directory ) ; } c = ReadBlobByte ( image ) ; * p ++ = ( char ) c ; } while ( c != ( int ) '\\0' ) ; } if ( profiles != ( LinkedListInfo * ) NULL ) { const char * name ; const StringInfo * profile ; register unsigned char * p ; ResetLinkedListIterator ( profiles ) ; name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; while ( name != ( const char * ) NULL ) { profile = GetImageProfile ( image , name ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; count = ReadBlob ( image , GetStringInfoLength ( profile ) , p ) ; } name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; } profiles = DestroyLinkedList ( profiles , RelinquishMagickMemory ) ; } depth = GetImageQuantumDepth ( image , MagickFalse ) ; if ( image -> storage_class == PseudoClass ) { image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image -> colors != 0 ) { size_t packet_size ; unsigned char * colormap ; packet_size = ( size_t ) ( 3UL * depth / 8UL ) ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , packet_size * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , packet_size * image -> colors , colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = colormap ; switch ( depth ) { default : colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""ImageDepthNotSupported"" ) ; case 8 : { unsigned char pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( pixel ) ; } break ; } case 16 : { unsigned short pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleShortToQuantum ( pixel ) ; } break ; } case 32 : { unsigned int pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleLongToQuantum ( pixel ) ; } break ; } } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( AcquireMagickResource ( WidthResource , image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource , image -> rows ) == MagickFalse ) ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" ) ; status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( CacheError , ""UnableToPersistPixelCache"" ) ; do { c = ReadBlobByte ( image ) ; } while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ; if ( c != EOF ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( c != EOF ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",break ;},2679
727,"buggy line: if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal )  return 0 ;cwe id:CWE-399context: int ext4_orphan_del ( handle_t * handle , struct inode * inode ) { struct list_head * prev ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; struct ext4_sb_info * sbi ; __u32 ino_next ; struct ext4_iloc iloc ; int err = 0 ;  if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal )  return 0 ; mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; if ( list_empty ( & ei -> i_orphan ) ) goto out ; ino_next = NEXT_ORPHAN ( inode ) ; prev = ei -> i_orphan . prev ; sbi = EXT4_SB ( inode -> i_sb ) ; jbd_debug ( 4 , ""remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\n"" , inode -> i_ino ) ; list_del_init ( & ei -> i_orphan ) ; if ( ! handle ) goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_err ; if ( prev == & sbi -> s_orphan ) { jbd_debug ( 4 , ""superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , ino_next ) ; BUFFER_TRACE ( sbi -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; if ( err ) goto out_brelse ; sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; } else { struct ext4_iloc iloc2 ; struct inode * i_prev = & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; jbd_debug ( 4 , ""orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , i_prev -> i_ino , ino_next ) ; err = ext4_reserve_inode_write ( handle , i_prev , & iloc2 ) ; if ( err ) goto out_brelse ; NEXT_ORPHAN ( i_prev ) = ino_next ; err = ext4_mark_iloc_dirty ( handle , i_prev , & iloc2 ) ; } if ( err ) goto out_brelse ; NEXT_ORPHAN ( inode ) = 0 ; err = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; out_err : ext4_std_error ( inode -> i_sb , err ) ; out : mutex_unlock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; return err ; out_brelse : brelse ( iloc . bh ) ; goto out_err ; }",if ( ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS ) ) return 0 ;,2680
728,"buggy line: char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;cwe id:CWE-787context: int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { int supported = TRUE , format ; chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ;  char * buff = malloc ( bytes_to_copy ) ;  if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;",2681
729,"buggy line: if ( ! proc_parse_options ( options , ns ) ) {deactivate_locked_super ( sb ) ;cwe id:CWE-119context: static struct dentry * proc_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { int err ; struct super_block * sb ; struct pid_namespace * ns ; char * options ; if ( flags & MS_KERNMOUNT ) { ns = ( struct pid_namespace * ) data ; options = NULL ; } else { ns = task_active_pid_ns ( current ) ; options = data ; if ( ! ns_capable ( ns -> user_ns , CAP_SYS_ADMIN ) ) return ERR_PTR ( - EPERM ) ; } sb = sget ( fs_type , proc_test_super , proc_set_super , flags , ns ) ; if ( IS_ERR ( sb ) ) return ERR_CAST ( sb ) ;  if ( ! proc_parse_options ( options , ns ) ) {  deactivate_locked_super ( sb ) ; return ERR_PTR ( - EINVAL ) ; } if ( ! sb -> s_root ) { err = proc_fill_super ( sb ) ; if ( err ) { deactivate_locked_super ( sb ) ; return ERR_PTR ( err ) ; } sb -> s_flags |= MS_ACTIVE ; sb -> s_iflags |= SB_I_NOEXEC ; } return dget ( sb -> s_root ) ; }","sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ;if ( ! proc_parse_options ( options , ns ) ) {deactivate_locked_super ( sb ) ;",2682
730,"buggy line: if ( ! ssl_cipher_get_evp ( s -> session , & c , & hash , & mac_type , & mac_secret_size , & comp ,  SSL_USE_ETM ( s ) ) ) {SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ;cwe id:CWE-20context: int tls1_setup_key_block ( SSL * s ) { unsigned char * p ; const EVP_CIPHER * c ; const EVP_MD * hash ; int num ; SSL_COMP * comp ; int mac_type = NID_undef , mac_secret_size = 0 ; int ret = 0 ; if ( s -> s3 -> tmp . key_block_length != 0 ) return ( 1 ) ; if ( ! ssl_cipher_get_evp ( s -> session , & c , & hash , & mac_type , & mac_secret_size , & comp ,  SSL_USE_ETM ( s ) ) ) {  SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ; return ( 0 ) ; } s -> s3 -> tmp . new_sym_enc = c ; s -> s3 -> tmp . new_hash = hash ; s -> s3 -> tmp . new_mac_pkey_type = mac_type ; s -> s3 -> tmp . new_mac_secret_size = mac_secret_size ; num = EVP_CIPHER_key_length ( c ) + mac_secret_size + EVP_CIPHER_iv_length ( c ) ; num *= 2 ; ssl3_cleanup_key_block ( s ) ; if ( ( p = OPENSSL_malloc ( num ) ) == NULL ) { SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , ERR_R_MALLOC_FAILURE ) ; goto err ; } s -> s3 -> tmp . key_block_length = num ; s -> s3 -> tmp . key_block = p ; # ifdef SSL_DEBUG printf ( ""client<S2SV_blank>random\\n"" ) ; { int z ; for ( z = 0 ; z < SSL3_RANDOM_SIZE ; z ++ ) printf ( ""%02X%c"" , s -> s3 -> client_random [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } printf ( ""server<S2SV_blank>random\\n"" ) ; { int z ; for ( z = 0 ; z < SSL3_RANDOM_SIZE ; z ++ ) printf ( ""%02X%c"" , s -> s3 -> server_random [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } printf ( ""master<S2SV_blank>key\\n"" ) ; { int z ; for ( z = 0 ; z < s -> session -> master_key_length ; z ++ ) printf ( ""%02X%c"" , s -> session -> master_key [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } # endif if ( ! tls1_generate_key_block ( s , p , num ) ) goto err ; # ifdef SSL_DEBUG printf ( ""\\nkey<S2SV_blank>block\\n"" ) ; { int z ; for ( z = 0 ; z < num ; z ++ ) printf ( ""%02X%c"" , p [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } # endif if ( ! ( s -> options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS ) && s -> method -> version <= TLS1_VERSION ) { s -> s3 -> need_empty_fragments = 1 ; if ( s -> session -> cipher != NULL ) { if ( s -> session -> cipher -> algorithm_enc == SSL_eNULL ) s -> s3 -> need_empty_fragments = 0 ; # ifndef OPENSSL_NO_RC4 if ( s -> session -> cipher -> algorithm_enc == SSL_RC4 ) s -> s3 -> need_empty_fragments = 0 ; # endif } } ret = 1 ; err : return ( ret ) ; }","if ( ! ssl_cipher_get_evp ( s -> session , & c , & hash , & mac_type , & mac_secret_size , & comp , s -> tlsext_use_etm ) ) {SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ;",2683
731,"buggy line: ulonglong tmp ;if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ;cwe id:CWE-190context: static int jas_iccgetuint16 ( jas_stream_t * in , jas_iccuint16_t * val ) {  ulonglong tmp ;  if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ;",2684
732,"buggy line: skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;if ( ! skb ) {msg -> msg_namelen = 0 ;copied = skb -> len ;cwe id:CWE-200context: int bt_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; size_t copied ; int err ; BT_DBG ( ""sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p<S2SV_blank>len<S2SV_blank>%zu"" , sock , sk , len ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ;  skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;  if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; }  msg -> msg_namelen = 0 ;  copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err == 0 ) sock_recv_ts_and_drops ( msg , sk , skb ) ; skb_free_datagram ( sk , skb ) ; return err ? : copied ; }","msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;if ( ! skb ) {copied = skb -> len ;",2685
733,"buggy line: static bool tailmatch ( const char * little , const char * bigone )  {size_t littlelen = strlen ( little ) ;size_t biglen = strlen ( bigone ) ;if ( littlelen > biglen )  return FALSE ;return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ;}cwe id:CWE-200context:  static bool tailmatch ( const char * little , const char * bigone )  {  size_t littlelen = strlen ( little ) ;   size_t biglen = strlen ( bigone ) ;   if ( littlelen > biglen )  return FALSE ;  return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ;  }","static bool tailmatch ( const char * cooke_domain , const char * bigone ) {size_t cookie_domain_len = strlen ( little ) ;size_t hostname_len = strlen ( bigone ) ;if ( hostname_len < cookie_domain_len ) return FALSE ;return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ;}",2686
734,buggy line: }cwe id:CWE-119context: void vp9_disable_segmentation ( struct segmentation * seg ) { seg -> enabled = 0 ;  } ,seg -> update_map = 0 ;seg -> update_data = 0 ;},2687
735,"buggy line: for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;cwe id:CWE-119context: static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ;  for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) {  struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ;  if ( unix_sock_count ) {  for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) unix_inflight ( scm -> fp -> fp [ i ] ) ;  }  return max_level ; }",if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ;for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;,2688
736,"buggy line: if ( unix_sock_count ) {for ( i = scm -> fp -> count - 1 ;}return max_level ;cwe id:CWE-119context: static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ;  for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) {  struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ;  if ( unix_sock_count ) {  for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) unix_inflight ( scm -> fp -> fp [ i ] ) ;  }  return max_level ; }",for ( i = scm -> fp -> count - 1 ;return max_level ;,2688
737,"buggy line: cwe id:CWE-369context: static OPJ_BOOL opj_pi_next_rpcl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < pi -> poc . resno1 ; pi -> resno ++ ) { for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; comp = & pi -> comps [ pi -> compno ] ; if ( pi -> resno >= comp -> numresolutions ) { continue ; } res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ;  if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},2689
738,"buggy line: if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {cwe id:CWE-369context: static OPJ_BOOL opj_pi_next_rpcl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < pi -> poc . resno1 ; pi -> resno ++ ) { for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; comp = & pi -> comps [ pi -> compno ] ; if ( pi -> resno >= comp -> numresolutions ) { continue ; } res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ;  if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }",if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,2689
739,buggy line: }return TRUE ;cwe id:CWE-399context: gboolean mainloop_destroy_trigger ( crm_trigger_t * source ) { source -> trigger = FALSE ; if ( source -> id > 0 ) { g_source_remove ( source -> id ) ;  }  return TRUE ; },source -> id = 0 ;}return TRUE ;,2690
740,"buggy line: if ( user -> uid_keyring ) {kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ;cwe id:CWE-362context: int install_user_keyrings ( void ) { struct user_struct * user ; const struct cred * cred ; struct key * uid_keyring , * session_keyring ; key_perm_t user_keyring_perm ; char buf [ 20 ] ; int ret ; uid_t uid ; user_keyring_perm = ( KEY_POS_ALL & ~ KEY_POS_SETATTR ) | KEY_USR_ALL ; cred = current_cred ( ) ; user = cred -> user ; uid = from_kuid ( cred -> user_ns , user -> uid ) ; kenter ( ""%p{%u}"" , user , uid ) ;  if ( user -> uid_keyring ) {  kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ; return 0 ; } mutex_lock ( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user -> uid_keyring ) { sprintf ( buf , ""_uid.%u"" , uid ) ; uid_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( uid_keyring ) ) { uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( uid_keyring ) ) { ret = PTR_ERR ( uid_keyring ) ; goto error ; } } sprintf ( buf , ""_uid_ses.%u"" , uid ) ; session_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( session_keyring ) ) { session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( session_keyring ) ) { ret = PTR_ERR ( session_keyring ) ; goto error_release ; } ret = key_link ( session_keyring , uid_keyring ) ; if ( ret < 0 ) goto error_release_both ; } user -> uid_keyring = uid_keyring ; user -> session_keyring = session_keyring ; } mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>0"" ) ; return 0 ; error_release_both : key_put ( session_keyring ) ; error_release : key_put ( uid_keyring ) ; error : mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ret ; }","if ( user -> uid_keyring && user -> session_keyring ) {kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ;",2691
741,"buggy line: for ( i = 0 ;mechbuf [ i ] ;host = xhash_get ( c2s -> hosts , s -> req_to ) ;cwe id:CWE-287context: static int _c2s_sx_sasl_callback ( int cb , void * arg , void * * res , sx_t s , void * cbarg ) { c2s_t c2s = ( c2s_t ) cbarg ; const char * my_realm , * mech ; sx_sasl_creds_t creds ; static char buf [ 3072 ] ; char mechbuf [ 256 ] ; struct jid_st jid ; jid_static_buf jid_buf ; int i , r ; sess_t sess ; char skey [ 44 ] ; host_t host ; jid_static ( & jid , & jid_buf ) ; assert ( s != NULL ) ; sprintf ( skey , ""%d"" , s -> tag ) ; sess = xhash_get ( c2s -> sessions , skey ) ; switch ( cb ) { case sx_sasl_cb_GET_REALM : if ( s -> req_to == NULL ) my_realm = """" ; else { host = xhash_get ( c2s -> hosts , s -> req_to ) ; if ( host == NULL ) { log_write ( c2s -> log , LOG_ERR , ""SASL<S2SV_blank>callback<S2SV_blank>for<S2SV_blank>non-existing<S2SV_blank>host:<S2SV_blank>%s"" , s -> req_to ) ; * res = ( void * ) NULL ; return sx_sasl_ret_FAIL ; } my_realm = host -> realm ; if ( my_realm == NULL ) my_realm = s -> req_to ; } strncpy ( buf , my_realm , 256 ) ; * res = ( void * ) buf ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>get<S2SV_blank>realm:<S2SV_blank>realm<S2SV_blank>is<S2SV_blank>\'%s\'"" , buf ) ; return sx_sasl_ret_OK ; break ; case sx_sasl_cb_GET_PASS : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>get<S2SV_blank>pass<S2SV_blank>(authnid=%s,<S2SV_blank>realm=%s)"" , creds -> authnid , creds -> realm ) ; if ( sess -> host -> ar -> get_password && ( sess -> host -> ar -> get_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , buf ) == 0 ) { * res = buf ; return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; case sx_sasl_cb_CHECK_PASS : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>pass<S2SV_blank>(authnid=%s,<S2SV_blank>realm=%s)"" , creds -> authnid , creds -> realm ) ; if ( sess -> host -> ar -> check_password != NULL ) { if ( ( sess -> host -> ar -> check_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , ( char * ) creds -> pass ) == 0 ) return sx_sasl_ret_OK ; else return sx_sasl_ret_FAIL ; } if ( sess -> host -> ar -> get_password != NULL ) { if ( ( sess -> host -> ar -> get_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , buf ) != 0 ) return sx_sasl_ret_FAIL ; if ( strcmp ( creds -> pass , buf ) == 0 ) return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; break ; case sx_sasl_cb_CHECK_AUTHZID : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; if ( creds -> authzid == NULL || creds -> authzid [ 0 ] == '\\0' ) return sx_sasl_ret_FAIL ; if ( jid_reset ( & jid , creds -> authzid , - 1 ) == NULL ) return sx_sasl_ret_FAIL ; if ( ! s -> req_to || ( strcmp ( jid . domain , s -> req_to ) != 0 ) ) return sx_sasl_ret_FAIL ; if ( jid . resource [ 0 ] != '\\0' ) return sx_sasl_ret_FAIL ; if ( sess -> host -> ar -> user_authz_allowed ) { if ( sess -> host -> ar -> user_authz_allowed ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( char * ) creds -> realm , ( char * ) creds -> authzid ) ) return sx_sasl_ret_OK ; } else { if ( strcmp ( creds -> authnid , jid . node ) == 0 && ( sess -> host -> ar -> user_exists ) ( sess -> host -> ar , sess , jid . node , jid . domain ) ) return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; case sx_sasl_cb_GEN_AUTHZID : jid_reset ( & jid , s -> req_to , - 1 ) ; jid_random_part ( & jid , jid_NODE ) ; strcpy ( buf , jid . node ) ; * res = ( void * ) buf ; return sx_sasl_ret_OK ; break ; case sx_sasl_cb_CHECK_MECH : mech = ( char * ) arg ; strncpy ( mechbuf , mech , sizeof ( mechbuf ) ) ; mechbuf [ sizeof ( mechbuf ) - 1 ] = '\\0' ;  for ( i = 0 ; mechbuf [ i ] ; i ++ ) mechbuf [ i ] = tolower ( mechbuf [ i ] ) ;  host = xhash_get ( c2s -> hosts , s -> req_to ) ; if ( host == NULL ) { log_write ( c2s -> log , LOG_WARNING , ""SASL<S2SV_blank>callback<S2SV_blank>for<S2SV_blank>non-existing<S2SV_blank>host:<S2SV_blank>%s"" , s -> req_to ) ; return sx_sasl_ret_FAIL ; } if ( strcmp ( mechbuf , ""digest-md5"" ) == 0 ) { if ( host -> ar -> get_password == NULL ) return sx_sasl_ret_FAIL ; } else if ( strcmp ( mechbuf , ""plain"" ) == 0 ) { if ( host -> ar -> get_password == NULL && host -> ar -> check_password == NULL ) return sx_sasl_ret_FAIL ; } if ( s -> ssf > 0 ) { r = snprintf ( buf , sizeof ( buf ) , ""authreg.ssl-mechanisms.sasl.%s"" , mechbuf ) ; if ( r < - 1 || r > sizeof ( buf ) ) return sx_sasl_ret_FAIL ; if ( config_get ( c2s -> config , buf ) != NULL ) return sx_sasl_ret_OK ; } r = snprintf ( buf , sizeof ( buf ) , ""authreg.mechanisms.sasl.%s"" , mechbuf ) ; if ( r < - 1 || r > sizeof ( buf ) ) return sx_sasl_ret_FAIL ; if ( config_get ( c2s -> config , buf ) != NULL ) return sx_sasl_ret_OK ; else return sx_sasl_ret_FAIL ; default : break ; } return sx_sasl_ret_FAIL ; }","for ( i = 0 ;mechbuf [ i ] ) ;log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)"" , mechbuf ;host = xhash_get ( c2s -> hosts , s -> req_to ) ;",2692
742,"buggy line: static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop )  {cwe id:CWE-400context:  static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop )  { struct evtchn_fifo_control_block * control_block ; unsigned long ready ; unsigned q ; control_block = per_cpu ( cpu_control_block , cpu ) ; ready = xchg ( & control_block -> ready , 0 ) ; while ( ready ) { q = find_first_bit ( & ready , EVTCHN_FIFO_MAX_QUEUES ) ;  consume_one_event ( cpu , control_block , q , & ready , drop ) ;  ready |= xchg ( & control_block -> ready , 0 ) ; } }","static void __evtchn_fifo_handle_events ( unsigned cpu , struct evtchn_loop_ctrl * ctrl ) {",2693
743,"buggy line: consume_one_event ( cpu , control_block , q , & ready , drop ) ;ready |= xchg ( & control_block -> ready , 0 ) ;cwe id:CWE-400context:  static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop )  { struct evtchn_fifo_control_block * control_block ; unsigned long ready ; unsigned q ; control_block = per_cpu ( cpu_control_block , cpu ) ; ready = xchg ( & control_block -> ready , 0 ) ; while ( ready ) { q = find_first_bit ( & ready , EVTCHN_FIFO_MAX_QUEUES ) ;  consume_one_event ( cpu , control_block , q , & ready , drop ) ;  ready |= xchg ( & control_block -> ready , 0 ) ; } }","consume_one_event ( cpu , ctrl , control_block , q , & ready ) ;ready |= xchg ( & control_block -> ready , 0 ) ;",2693
744,"buggy line: # endif # endif # if defined ( HAVE_GETSPNAM ) && ! defined ( M_UNIX )  if ( spwd && spwd -> sp_expire > 0 &&   ( request -> timestamp / 86400 ) > spwd -> sp_expire ) {radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ;return RLM_MODULE_REJECT ;cwe id:CWE-255context: static int unix_getpw ( UNUSED void * instance , REQUEST * request , VALUE_PAIR * * vp_list ) { const char * name ; const char * encrypted_pass ; # ifdef HAVE_GETSPNAM struct spwd * spwd = NULL ; # endif # ifdef OSFC2 struct pr_passwd * pr_pw ; # else struct passwd * pwd ; # endif # ifdef HAVE_GETUSERSHELL char * shell ; # endif VALUE_PAIR * vp ; if ( ! request -> username ) { return RLM_MODULE_NOOP ; } name = ( char * ) request -> username -> vp_strvalue ; encrypted_pass = NULL ; # ifdef OSFC2 if ( ( pr_pw = getprpwnam ( name ) ) == NULL ) return RLM_MODULE_NOTFOUND ; encrypted_pass = pr_pw -> ufld . fd_encrypt ; if ( pr_pw -> uflg . fg_lock != 1 ) { radlog ( L_AUTH , ""rlm_unix:<S2SV_blank>[%s]:<S2SV_blank>account<S2SV_blank>locked"" , name ) ; return RLM_MODULE_USERLOCK ; } # else if ( ( pwd = getpwnam ( name ) ) == NULL ) { return RLM_MODULE_NOTFOUND ; } encrypted_pass = pwd -> pw_passwd ; # endif # ifdef HAVE_GETSPNAM if ( ( encrypted_pass == NULL ) || ( strlen ( encrypted_pass ) < 10 ) ) { if ( ( spwd = getspnam ( name ) ) == NULL ) { return RLM_MODULE_NOTFOUND ; } encrypted_pass = spwd -> sp_pwdp ; } # endif # ifndef OSFC2 # ifdef DENY_SHELL if ( strcmp ( pwd -> pw_shell , DENY_SHELL ) == 0 ) { radlog_request ( L_AUTH , 0 , request , ""rlm_unix:<S2SV_blank>[%s]:<S2SV_blank>invalid<S2SV_blank>shell"" , name ) ; return RLM_MODULE_REJECT ; } # endif # ifdef HAVE_GETUSERSHELL while ( ( shell = getusershell ( ) ) != NULL ) { if ( strcmp ( shell , pwd -> pw_shell ) == 0 || strcmp ( shell , ""/RADIUSD/ANY/SHELL"" ) == 0 ) { break ; } } endusershell ( ) ; if ( shell == NULL ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>invalid<S2SV_blank>shell<S2SV_blank>[%s]"" , name , pwd -> pw_shell ) ; return RLM_MODULE_REJECT ; } # endif # endif # if defined ( HAVE_GETSPNAM ) && ! defined ( M_UNIX )  if ( spwd && spwd -> sp_expire > 0 &&   ( request -> timestamp / 86400 ) > spwd -> sp_expire ) {   radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ;  return RLM_MODULE_REJECT ; } # endif # if defined ( __FreeBSD__ ) || defined ( bsdi ) || defined ( _PWF_EXPIRE ) if ( ( pwd -> pw_expire > 0 ) && ( request -> timestamp > pwd -> pw_expire ) ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; return RLM_MODULE_REJECT ; } # endif if ( encrypted_pass [ 0 ] == 0 ) return RLM_MODULE_NOOP ; vp = pairmake ( ""Crypt-Password"" , encrypted_pass , T_OP_SET ) ; if ( ! vp ) return RLM_MODULE_FAIL ; pairmove ( vp_list , & vp ) ; pairfree ( & vp ) ; return RLM_MODULE_UPDATED ; }","# endif # endif # if defined ( HAVE_GETSPNAM ) && ! defined ( M_UNIX ) if ( spwd && spwd -> sp_lstchg > 0 && spwd -> sp_max >= 0 && ( request -> timestamp / 86400 ) > ( spwd -> sp_lstchg + spwd -> sp_max ) ) {radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>account<S2SV_blank>has<S2SV_blank>expired"" , name ) ;return RLM_MODULE_REJECT ;}if ( spwd && spwd -> sp_expire > 0 && ( request -> timestamp / 86400 ) > spwd -> sp_expire ) {radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ;return RLM_MODULE_REJECT ;",2694
745,buggy line: dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;cwe id:CWE-264context: static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ;  dev -> netdev_ops = & ieee80211_dataif_ops ;  dev -> destructor = free_netdev ; },dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;,2695
746,"buggy line: case \'l\' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ;case \'L\' : {cwe id:CWE-119context: static int cmd_info ( void * data , const char * input ) { RCore * core = ( RCore * ) data ; bool newline = r_config_get_i ( core -> config , ""scr.interactive"" ) ; RBinObject * o = r_bin_cur_object ( core -> bin ) ; RCoreFile * cf = core -> file ; int i , va = core -> io -> va || core -> io -> debug ; int mode = 0 ; int is_array = 0 ; Sdb * db ; for ( i = 0 ; input [ i ] && input [ i ] != '<S2SV_blank>' ; i ++ ) ; if ( i > 0 ) { switch ( input [ i - 1 ] ) { case '*' : mode = R_CORE_BIN_RADARE ; break ; case 'j' : mode = R_CORE_BIN_JSON ; break ; case 'q' : mode = R_CORE_BIN_SIMPLE ; break ; } } if ( mode == R_CORE_BIN_JSON ) { if ( strlen ( input + 1 ) > 1 ) { is_array = 1 ; } } if ( is_array ) { r_cons_printf ( ""{"" ) ; } if ( ! * input ) { cmd_info_bin ( core , va , mode ) ; } if ( ! strcmp ( input , ""*"" ) ) { input = ""I*"" ; } RBinObject * obj = r_bin_cur_object ( core -> bin ) ; while ( * input ) { switch ( * input ) { case 'b' : { ut64 baddr = r_config_get_i ( core -> config , ""bin.baddr"" ) ; if ( input [ 1 ] == '<S2SV_blank>' ) { baddr = r_num_math ( core -> num , input + 1 ) ; } r_core_bin_reload ( core , NULL , baddr ) ; r_core_block_read ( core ) ; newline = false ; } break ; case 'k' : db = o ? o -> kv : NULL ; switch ( input [ 1 ] ) { case 'v' : if ( db ) { char * o = sdb_querys ( db , NULL , 0 , input + 3 ) ; if ( o && * o ) { r_cons_print ( o ) ; } free ( o ) ; } break ; case '*' : r_core_bin_export_info_rad ( core ) ; break ; case '.' : case '<S2SV_blank>' : if ( db ) { char * o = sdb_querys ( db , NULL , 0 , input + 2 ) ; if ( o && * o ) { r_cons_print ( o ) ; } free ( o ) ; } break ; case '\\0' : if ( db ) { char * o = sdb_querys ( db , NULL , 0 , ""*"" ) ; if ( o && * o ) { r_cons_print ( o ) ; } free ( o ) ; } break ; case '?' : default : eprintf ( ""Usage:<S2SV_blank>ik<S2SV_blank>[sdb-query]\\n"" ) ; eprintf ( ""Usage:<S2SV_blank>ik*<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#<S2SV_blank>load<S2SV_blank>all<S2SV_blank>header<S2SV_blank>information\\n"" ) ; } goto done ; break ; case 'o' : { if ( ! cf ) { eprintf ( ""Core<S2SV_blank>file<S2SV_blank>not<S2SV_blank>open\\n"" ) ; return 0 ; } const char * fn = input [ 1 ] == '<S2SV_blank>' ? input + 2 : cf -> desc -> name ; ut64 baddr = r_config_get_i ( core -> config , ""bin.baddr"" ) ; r_core_bin_load ( core , fn , baddr ) ; } break ; # define RBININFO ( n , x , y , z ) if ( is_array ) { if ( is_array == 1 ) { is_array ++ ; } else { r_cons_printf ( "","" ) ; } r_cons_printf ( ""\\""%s\\"":"" , n ) ; } if ( z ) { playMsg ( core , n , z ) ; } r_core_bin_info ( core , x , mode , va , NULL , y ) ; case 'A' : newline = false ; if ( input [ 1 ] == 'j' ) { r_cons_printf ( ""{"" ) ; r_bin_list_archs ( core -> bin , 'j' ) ; r_cons_printf ( ""}\\n"" ) ; } else { r_bin_list_archs ( core -> bin , 1 ) ; } break ; case 'E' : RBININFO ( ""exports"" , R_CORE_BIN_ACC_EXPORTS , NULL , 0 ) ; break ; case 'Z' : RBININFO ( ""size"" , R_CORE_BIN_ACC_SIZE , NULL , 0 ) ; break ; case 'S' : if ( ( input [ 1 ] == 'm' && input [ 2 ] == 'z' ) || ! input [ 1 ] ) { RBININFO ( ""sections"" , R_CORE_BIN_ACC_SECTIONS , NULL , 0 ) ; } else { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; if ( mode == R_CORE_BIN_RADARE || mode == R_CORE_BIN_JSON || mode == R_CORE_BIN_SIMPLE ) { RBININFO ( ""sections"" , R_CORE_BIN_ACC_SECTIONS , input + 2 , obj ? r_list_length ( obj -> sections ) : 0 ) ; } else { RBININFO ( ""sections"" , R_CORE_BIN_ACC_SECTIONS , input + 1 , obj ? r_list_length ( obj -> sections ) : 0 ) ; } while ( * ( ++ input ) ) ; input -- ; } break ; case 'H' : if ( input [ 1 ] == 'H' ) { RBININFO ( ""header"" , R_CORE_BIN_ACC_HEADER , NULL , - 1 ) ; break ; } case 'h' : RBININFO ( ""fields"" , R_CORE_BIN_ACC_FIELDS , NULL , 0 ) ; break ;  case 'l' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ; break ;  case 'L' : { char * ptr = strchr ( input , '<S2SV_blank>' ) ; int json = input [ 1 ] == 'j' ? 'j' : 0 ; if ( ptr && ptr [ 1 ] ) { const char * plugin_name = ptr + 1 ; if ( is_array ) { r_cons_printf ( ""\\""plugin\\"":<S2SV_blank>"" ) ; } r_bin_list_plugin ( core -> bin , plugin_name , json ) ; } else { r_bin_list ( core -> bin , json ) ; } newline = false ; goto done ; } break ; case 's' : if ( input [ 1 ] == '.' ) { ut64 addr = core -> offset + ( core -> print -> cur_enabled ? core -> print -> cur : 0 ) ; RFlagItem * f = r_flag_get_at ( core -> flags , addr , false ) ; if ( f ) { if ( f -> offset == addr || ! f -> offset ) { r_cons_printf ( ""%s"" , f -> name ) ; } else { r_cons_printf ( ""%s+%d"" , f -> name , ( int ) ( addr - f -> offset ) ) ; } } input ++ ; break ; } else { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; RBININFO ( ""symbols"" , R_CORE_BIN_ACC_SYMBOLS , NULL , obj ? r_list_length ( obj -> symbols ) : 0 ) ; break ; } case 'R' : if ( input [ 1 ] == '*' ) { mode = R_CORE_BIN_RADARE ; } else if ( input [ 1 ] == 'j' ) { mode = R_CORE_BIN_JSON ; } RBININFO ( ""resources"" , R_CORE_BIN_ACC_RESOURCES , NULL , 0 ) ; break ; case 'r' : RBININFO ( ""relocs"" , R_CORE_BIN_ACC_RELOCS , NULL , 0 ) ; break ; case 'd' : RBININFO ( ""dwarf"" , R_CORE_BIN_ACC_DWARF , NULL , - 1 ) ; break ;  case 'i' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ; break ;  case 'I' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ; break ; case 'e' : RBININFO ( ""entries"" , R_CORE_BIN_ACC_ENTRIES , NULL , 0 ) ; break ; case 'M' : RBININFO ( ""main"" , R_CORE_BIN_ACC_MAIN , NULL , 0 ) ; break ; case 'm' : RBININFO ( ""memory"" , R_CORE_BIN_ACC_MEM , NULL , 0 ) ; break ; case 'V' : RBININFO ( ""versioninfo"" , R_CORE_BIN_ACC_VERSIONINFO , NULL , 0 ) ; break ; case 'C' : RBININFO ( ""signature"" , R_CORE_BIN_ACC_SIGNATURE , NULL , 0 ) ; break ; case 'z' : if ( input [ 1 ] == 'z' ) { switch ( input [ 2 ] ) { case '*' : mode = R_CORE_BIN_RADARE ; break ; case 'j' : mode = R_CORE_BIN_JSON ; break ; case 'q' : if ( input [ 3 ] == 'q' ) { mode = R_CORE_BIN_SIMPLEST ; input ++ ; } else { mode = R_CORE_BIN_SIMPLE ; } break ; default : mode = R_CORE_BIN_PRINT ; break ; } input ++ ; RBININFO ( ""strings"" , R_CORE_BIN_ACC_RAW_STRINGS , NULL , 0 ) ; } else { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; if ( input [ 1 ] == 'q' ) { mode = ( input [ 2 ] == 'q' ) ? R_CORE_BIN_SIMPLEST : R_CORE_BIN_SIMPLE ; input ++ ; } if ( obj ) { RBININFO ( ""strings"" , R_CORE_BIN_ACC_STRINGS , NULL , obj ? r_list_length ( obj -> strings ) : 0 ) ; } } break ; case 'c' : if ( input [ 1 ] == '?' ) { eprintf ( ""Usage:<S2SV_blank>ic[ljq*]<S2SV_blank>[class-index<S2SV_blank>or<S2SV_blank>name]\\n"" ) ; } else if ( input [ 1 ] == '<S2SV_blank>' || input [ 1 ] == 'q' || input [ 1 ] == 'j' || input [ 1 ] == 'l' ) { RBinClass * cls ; RBinSymbol * sym ; RListIter * iter , * iter2 ; RBinObject * obj = r_bin_cur_object ( core -> bin ) ; if ( obj ) { if ( input [ 2 ] ) { int idx = - 1 ; const char * cls_name = NULL ; if ( r_num_is_valid_input ( core -> num , input + 2 ) ) { idx = r_num_math ( core -> num , input + 2 ) ; } else { const char * first_char = input + ( ( input [ 1 ] == '<S2SV_blank>' ) ? 1 : 2 ) ; int not_space = strspn ( first_char , ""<S2SV_blank>"" ) ; if ( first_char [ not_space ] ) { cls_name = first_char + not_space ; } } int count = 0 ; r_list_foreach ( obj -> classes , iter , cls ) { if ( ( idx >= 0 && idx != count ++ ) || ( cls_name && strcmp ( cls_name , cls -> name ) != 0 ) ) { continue ; } switch ( input [ 1 ] ) { case '*' : r_list_foreach ( cls -> methods , iter2 , sym ) { r_cons_printf ( ""f<S2SV_blank>sym.%s<S2SV_blank>@<S2SV_blank>0x%"" PFMT64x ""\\n"" , sym -> name , sym -> vaddr ) ; } input ++ ; break ; case 'l' : r_list_foreach ( cls -> methods , iter2 , sym ) { const char * comma = iter2 -> p ? ""<S2SV_blank>"" : """" ; r_cons_printf ( ""%s0x%"" PFMT64d , comma , sym -> vaddr ) ; } r_cons_newline ( ) ; input ++ ; break ; case 'j' : input ++ ; r_cons_printf ( ""\\""class\\"":\\""%s\\"""" , cls -> name ) ; r_cons_printf ( "",\\""methods\\"":["" ) ; r_list_foreach ( cls -> methods , iter2 , sym ) { const char * comma = iter2 -> p ? "","" : """" ; if ( sym -> method_flags ) { char * flags = r_core_bin_method_flags_str ( sym , R_CORE_BIN_JSON ) ; r_cons_printf ( ""%s{\\""name\\"":\\""%s\\"",\\""flags\\"":%s,\\""vaddr\\"":%"" PFMT64d ""}"" , comma , sym -> name , flags , sym -> vaddr ) ; R_FREE ( flags ) ; } else { r_cons_printf ( ""%s{\\""name\\"":\\""%s\\"",\\""vaddr\\"":%"" PFMT64d ""}"" , comma , sym -> name , sym -> vaddr ) ; } } r_cons_printf ( ""]"" ) ; break ; default : r_cons_printf ( ""class<S2SV_blank>%s\\n"" , cls -> name ) ; r_list_foreach ( cls -> methods , iter2 , sym ) { char * flags = r_core_bin_method_flags_str ( sym , 0 ) ; r_cons_printf ( ""0x%08"" PFMT64x ""<S2SV_blank>method<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n"" , sym -> vaddr , cls -> name , flags , sym -> name ) ; R_FREE ( flags ) ; } break ; } goto done ; } goto done ; } else { playMsg ( core , ""classes"" , r_list_length ( obj -> classes ) ) ; if ( input [ 1 ] == 'l' && obj ) { r_list_foreach ( obj -> classes , iter , cls ) { r_list_foreach ( cls -> methods , iter2 , sym ) { const char * comma = iter2 -> p ? ""<S2SV_blank>"" : """" ; r_cons_printf ( ""%s0x%"" PFMT64d , comma , sym -> vaddr ) ; } if ( ! r_list_empty ( cls -> methods ) ) { r_cons_newline ( ) ; } } } else { RBININFO ( ""classes"" , R_CORE_BIN_ACC_CLASSES , NULL , r_list_length ( obj -> classes ) ) ; } } } } else { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; int len = obj ? r_list_length ( obj -> classes ) : 0 ; RBININFO ( ""classes"" , R_CORE_BIN_ACC_CLASSES , NULL , len ) ; } break ; case 'D' : if ( input [ 1 ] != '<S2SV_blank>' || ! demangle ( core , input + 2 ) ) { eprintf ( ""|Usage:<S2SV_blank>iD<S2SV_blank>lang<S2SV_blank>symbolname\\n"" ) ; } return 0 ; case 'a' : switch ( mode ) { case R_CORE_BIN_RADARE : cmd_info ( core , ""iIiecsSmz*"" ) ; break ; case R_CORE_BIN_JSON : cmd_info ( core , ""iIiecsSmzj"" ) ; break ; case R_CORE_BIN_SIMPLE : cmd_info ( core , ""iIiecsSmzq"" ) ; break ; default : cmd_info ( core , ""IiEecsSmz"" ) ; break ; } break ; case '?' : { const char * help_message [ ] = { ""Usage:<S2SV_blank>i"" , """" , ""Get<S2SV_blank>info<S2SV_blank>from<S2SV_blank>opened<S2SV_blank>file<S2SV_blank>(see<S2SV_blank>rabin2\'s<S2SV_blank>manpage)"" , ""Output<S2SV_blank>mode:"" , """" , """" , ""\'*\'"" , """" , ""Output<S2SV_blank>in<S2SV_blank>radare<S2SV_blank>commands"" , ""\'j\'"" , """" , ""Output<S2SV_blank>in<S2SV_blank>json"" , ""\'q\'"" , """" , ""Simple<S2SV_blank>quiet<S2SV_blank>output"" , ""Actions:"" , """" , """" , ""i|ij"" , """" , ""Show<S2SV_blank>info<S2SV_blank>of<S2SV_blank>current<S2SV_blank>file<S2SV_blank>(in<S2SV_blank>JSON)"" , ""iA"" , """" , ""List<S2SV_blank>archs"" , ""ia"" , """" , ""Show<S2SV_blank>all<S2SV_blank>info<S2SV_blank>(imports,<S2SV_blank>exports,<S2SV_blank>sections..)"" , ""ib"" , """" , ""Reload<S2SV_blank>the<S2SV_blank>current<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>setting<S2SV_blank>of<S2SV_blank>the<S2SV_blank>bin<S2SV_blank>(use<S2SV_blank>once<S2SV_blank>only)"" , ""ic"" , """" , ""List<S2SV_blank>classes,<S2SV_blank>methods<S2SV_blank>and<S2SV_blank>fields"" , ""iC"" , """" , ""Show<S2SV_blank>signature<S2SV_blank>info<S2SV_blank>(entitlements,<S2SV_blank>...)"" , ""id"" , """" , ""Debug<S2SV_blank>information<S2SV_blank>(source<S2SV_blank>lines)"" , ""iD"" , ""<S2SV_blank>lang<S2SV_blank>sym"" , ""demangle<S2SV_blank>symbolname<S2SV_blank>for<S2SV_blank>given<S2SV_blank>language"" , ""ie"" , """" , ""Entrypoint"" , ""iE"" , """" , ""Exports<S2SV_blank>(global<S2SV_blank>symbols)"" , ""ih"" , """" , ""Headers<S2SV_blank>(alias<S2SV_blank>for<S2SV_blank>iH)"" , ""iHH"" , """" , ""Verbose<S2SV_blank>Headers<S2SV_blank>in<S2SV_blank>raw<S2SV_blank>text"" , ""ii"" , """" , ""Imports"" , ""iI"" , """" , ""Binary<S2SV_blank>info"" , ""ik"" , ""<S2SV_blank>[query]"" , ""Key-value<S2SV_blank>database<S2SV_blank>from<S2SV_blank>RBinObject"" , ""il"" , """" , ""Libraries"" , ""iL<S2SV_blank>"" , ""[plugin]"" , ""List<S2SV_blank>all<S2SV_blank>RBin<S2SV_blank>plugins<S2SV_blank>loaded<S2SV_blank>or<S2SV_blank>plugin<S2SV_blank>details"" , ""im"" , """" , ""Show<S2SV_blank>info<S2SV_blank>about<S2SV_blank>predefined<S2SV_blank>memory<S2SV_blank>allocation"" , ""iM"" , """" , ""Show<S2SV_blank>main<S2SV_blank>address"" , ""io"" , ""<S2SV_blank>[file]"" , ""Load<S2SV_blank>info<S2SV_blank>from<S2SV_blank>file<S2SV_blank>(or<S2SV_blank>last<S2SV_blank>opened)<S2SV_blank>use<S2SV_blank>bin.baddr"" , ""ir"" , """" , ""Relocs"" , ""iR"" , """" , ""Resources"" , ""is"" , """" , ""Symbols"" , ""iS<S2SV_blank>"" , ""[entropy,sha1]"" , ""Sections<S2SV_blank>(choose<S2SV_blank>which<S2SV_blank>hash<S2SV_blank>algorithm<S2SV_blank>to<S2SV_blank>use)"" , ""iV"" , """" , ""Display<S2SV_blank>file<S2SV_blank>version<S2SV_blank>info"" , ""iz|izj"" , """" , ""Strings<S2SV_blank>in<S2SV_blank>data<S2SV_blank>sections<S2SV_blank>(in<S2SV_blank>JSON/Base64)"" , ""izz"" , """" , ""Search<S2SV_blank>for<S2SV_blank>Strings<S2SV_blank>in<S2SV_blank>the<S2SV_blank>whole<S2SV_blank>binary"" , ""iZ"" , """" , ""Guess<S2SV_blank>size<S2SV_blank>of<S2SV_blank>binary<S2SV_blank>program"" , NULL } ; r_core_cmd_help ( core , help_message ) ; } goto done ; case '*' : mode = R_CORE_BIN_RADARE ; goto done ; case 'q' : mode = R_CORE_BIN_SIMPLE ; cmd_info_bin ( core , va , mode ) ; goto done ; case 'j' : mode = R_CORE_BIN_JSON ; if ( is_array > 1 ) { mode |= R_CORE_BIN_ARRAY ; } cmd_info_bin ( core , va , mode ) ; goto done ; default : cmd_info_bin ( core , va , mode ) ; break ; } input ++ ; if ( ( * input == 'j' || * input == 'q' ) && ! input [ 1 ] ) { break ; } } done : if ( is_array ) { r_cons_printf ( ""}\\n"" ) ; } if ( newline ) { r_cons_newline ( ) ; } return 0 ; }","case \'l\' : {RBinObject * obj = r_bin_cur_object ( core -> bin ) ;RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ;}case \'L\' : {",2696
747,"buggy line: case \'i\' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ;case \'I\' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ;cwe id:CWE-119context: static int cmd_info ( void * data , const char * input ) { RCore * core = ( RCore * ) data ; bool newline = r_config_get_i ( core -> config , ""scr.interactive"" ) ; RBinObject * o = r_bin_cur_object ( core -> bin ) ; RCoreFile * cf = core -> file ; int i , va = core -> io -> va || core -> io -> debug ; int mode = 0 ; int is_array = 0 ; Sdb * db ; for ( i = 0 ; input [ i ] && input [ i ] != '<S2SV_blank>' ; i ++ ) ; if ( i > 0 ) { switch ( input [ i - 1 ] ) { case '*' : mode = R_CORE_BIN_RADARE ; break ; case 'j' : mode = R_CORE_BIN_JSON ; break ; case 'q' : mode = R_CORE_BIN_SIMPLE ; break ; } } if ( mode == R_CORE_BIN_JSON ) { if ( strlen ( input + 1 ) > 1 ) { is_array = 1 ; } } if ( is_array ) { r_cons_printf ( ""{"" ) ; } if ( ! * input ) { cmd_info_bin ( core , va , mode ) ; } if ( ! strcmp ( input , ""*"" ) ) { input = ""I*"" ; } RBinObject * obj = r_bin_cur_object ( core -> bin ) ; while ( * input ) { switch ( * input ) { case 'b' : { ut64 baddr = r_config_get_i ( core -> config , ""bin.baddr"" ) ; if ( input [ 1 ] == '<S2SV_blank>' ) { baddr = r_num_math ( core -> num , input + 1 ) ; } r_core_bin_reload ( core , NULL , baddr ) ; r_core_block_read ( core ) ; newline = false ; } break ; case 'k' : db = o ? o -> kv : NULL ; switch ( input [ 1 ] ) { case 'v' : if ( db ) { char * o = sdb_querys ( db , NULL , 0 , input + 3 ) ; if ( o && * o ) { r_cons_print ( o ) ; } free ( o ) ; } break ; case '*' : r_core_bin_export_info_rad ( core ) ; break ; case '.' : case '<S2SV_blank>' : if ( db ) { char * o = sdb_querys ( db , NULL , 0 , input + 2 ) ; if ( o && * o ) { r_cons_print ( o ) ; } free ( o ) ; } break ; case '\\0' : if ( db ) { char * o = sdb_querys ( db , NULL , 0 , ""*"" ) ; if ( o && * o ) { r_cons_print ( o ) ; } free ( o ) ; } break ; case '?' : default : eprintf ( ""Usage:<S2SV_blank>ik<S2SV_blank>[sdb-query]\\n"" ) ; eprintf ( ""Usage:<S2SV_blank>ik*<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#<S2SV_blank>load<S2SV_blank>all<S2SV_blank>header<S2SV_blank>information\\n"" ) ; } goto done ; break ; case 'o' : { if ( ! cf ) { eprintf ( ""Core<S2SV_blank>file<S2SV_blank>not<S2SV_blank>open\\n"" ) ; return 0 ; } const char * fn = input [ 1 ] == '<S2SV_blank>' ? input + 2 : cf -> desc -> name ; ut64 baddr = r_config_get_i ( core -> config , ""bin.baddr"" ) ; r_core_bin_load ( core , fn , baddr ) ; } break ; # define RBININFO ( n , x , y , z ) if ( is_array ) { if ( is_array == 1 ) { is_array ++ ; } else { r_cons_printf ( "","" ) ; } r_cons_printf ( ""\\""%s\\"":"" , n ) ; } if ( z ) { playMsg ( core , n , z ) ; } r_core_bin_info ( core , x , mode , va , NULL , y ) ; case 'A' : newline = false ; if ( input [ 1 ] == 'j' ) { r_cons_printf ( ""{"" ) ; r_bin_list_archs ( core -> bin , 'j' ) ; r_cons_printf ( ""}\\n"" ) ; } else { r_bin_list_archs ( core -> bin , 1 ) ; } break ; case 'E' : RBININFO ( ""exports"" , R_CORE_BIN_ACC_EXPORTS , NULL , 0 ) ; break ; case 'Z' : RBININFO ( ""size"" , R_CORE_BIN_ACC_SIZE , NULL , 0 ) ; break ; case 'S' : if ( ( input [ 1 ] == 'm' && input [ 2 ] == 'z' ) || ! input [ 1 ] ) { RBININFO ( ""sections"" , R_CORE_BIN_ACC_SECTIONS , NULL , 0 ) ; } else { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; if ( mode == R_CORE_BIN_RADARE || mode == R_CORE_BIN_JSON || mode == R_CORE_BIN_SIMPLE ) { RBININFO ( ""sections"" , R_CORE_BIN_ACC_SECTIONS , input + 2 , obj ? r_list_length ( obj -> sections ) : 0 ) ; } else { RBININFO ( ""sections"" , R_CORE_BIN_ACC_SECTIONS , input + 1 , obj ? r_list_length ( obj -> sections ) : 0 ) ; } while ( * ( ++ input ) ) ; input -- ; } break ; case 'H' : if ( input [ 1 ] == 'H' ) { RBININFO ( ""header"" , R_CORE_BIN_ACC_HEADER , NULL , - 1 ) ; break ; } case 'h' : RBININFO ( ""fields"" , R_CORE_BIN_ACC_FIELDS , NULL , 0 ) ; break ;  case 'l' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ; break ;  case 'L' : { char * ptr = strchr ( input , '<S2SV_blank>' ) ; int json = input [ 1 ] == 'j' ? 'j' : 0 ; if ( ptr && ptr [ 1 ] ) { const char * plugin_name = ptr + 1 ; if ( is_array ) { r_cons_printf ( ""\\""plugin\\"":<S2SV_blank>"" ) ; } r_bin_list_plugin ( core -> bin , plugin_name , json ) ; } else { r_bin_list ( core -> bin , json ) ; } newline = false ; goto done ; } break ; case 's' : if ( input [ 1 ] == '.' ) { ut64 addr = core -> offset + ( core -> print -> cur_enabled ? core -> print -> cur : 0 ) ; RFlagItem * f = r_flag_get_at ( core -> flags , addr , false ) ; if ( f ) { if ( f -> offset == addr || ! f -> offset ) { r_cons_printf ( ""%s"" , f -> name ) ; } else { r_cons_printf ( ""%s+%d"" , f -> name , ( int ) ( addr - f -> offset ) ) ; } } input ++ ; break ; } else { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; RBININFO ( ""symbols"" , R_CORE_BIN_ACC_SYMBOLS , NULL , obj ? r_list_length ( obj -> symbols ) : 0 ) ; break ; } case 'R' : if ( input [ 1 ] == '*' ) { mode = R_CORE_BIN_RADARE ; } else if ( input [ 1 ] == 'j' ) { mode = R_CORE_BIN_JSON ; } RBININFO ( ""resources"" , R_CORE_BIN_ACC_RESOURCES , NULL , 0 ) ; break ; case 'r' : RBININFO ( ""relocs"" , R_CORE_BIN_ACC_RELOCS , NULL , 0 ) ; break ; case 'd' : RBININFO ( ""dwarf"" , R_CORE_BIN_ACC_DWARF , NULL , - 1 ) ; break ;  case 'i' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ; break ;  case 'I' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ; break ; case 'e' : RBININFO ( ""entries"" , R_CORE_BIN_ACC_ENTRIES , NULL , 0 ) ; break ; case 'M' : RBININFO ( ""main"" , R_CORE_BIN_ACC_MAIN , NULL , 0 ) ; break ; case 'm' : RBININFO ( ""memory"" , R_CORE_BIN_ACC_MEM , NULL , 0 ) ; break ; case 'V' : RBININFO ( ""versioninfo"" , R_CORE_BIN_ACC_VERSIONINFO , NULL , 0 ) ; break ; case 'C' : RBININFO ( ""signature"" , R_CORE_BIN_ACC_SIGNATURE , NULL , 0 ) ; break ; case 'z' : if ( input [ 1 ] == 'z' ) { switch ( input [ 2 ] ) { case '*' : mode = R_CORE_BIN_RADARE ; break ; case 'j' : mode = R_CORE_BIN_JSON ; break ; case 'q' : if ( input [ 3 ] == 'q' ) { mode = R_CORE_BIN_SIMPLEST ; input ++ ; } else { mode = R_CORE_BIN_SIMPLE ; } break ; default : mode = R_CORE_BIN_PRINT ; break ; } input ++ ; RBININFO ( ""strings"" , R_CORE_BIN_ACC_RAW_STRINGS , NULL , 0 ) ; } else { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; if ( input [ 1 ] == 'q' ) { mode = ( input [ 2 ] == 'q' ) ? R_CORE_BIN_SIMPLEST : R_CORE_BIN_SIMPLE ; input ++ ; } if ( obj ) { RBININFO ( ""strings"" , R_CORE_BIN_ACC_STRINGS , NULL , obj ? r_list_length ( obj -> strings ) : 0 ) ; } } break ; case 'c' : if ( input [ 1 ] == '?' ) { eprintf ( ""Usage:<S2SV_blank>ic[ljq*]<S2SV_blank>[class-index<S2SV_blank>or<S2SV_blank>name]\\n"" ) ; } else if ( input [ 1 ] == '<S2SV_blank>' || input [ 1 ] == 'q' || input [ 1 ] == 'j' || input [ 1 ] == 'l' ) { RBinClass * cls ; RBinSymbol * sym ; RListIter * iter , * iter2 ; RBinObject * obj = r_bin_cur_object ( core -> bin ) ; if ( obj ) { if ( input [ 2 ] ) { int idx = - 1 ; const char * cls_name = NULL ; if ( r_num_is_valid_input ( core -> num , input + 2 ) ) { idx = r_num_math ( core -> num , input + 2 ) ; } else { const char * first_char = input + ( ( input [ 1 ] == '<S2SV_blank>' ) ? 1 : 2 ) ; int not_space = strspn ( first_char , ""<S2SV_blank>"" ) ; if ( first_char [ not_space ] ) { cls_name = first_char + not_space ; } } int count = 0 ; r_list_foreach ( obj -> classes , iter , cls ) { if ( ( idx >= 0 && idx != count ++ ) || ( cls_name && strcmp ( cls_name , cls -> name ) != 0 ) ) { continue ; } switch ( input [ 1 ] ) { case '*' : r_list_foreach ( cls -> methods , iter2 , sym ) { r_cons_printf ( ""f<S2SV_blank>sym.%s<S2SV_blank>@<S2SV_blank>0x%"" PFMT64x ""\\n"" , sym -> name , sym -> vaddr ) ; } input ++ ; break ; case 'l' : r_list_foreach ( cls -> methods , iter2 , sym ) { const char * comma = iter2 -> p ? ""<S2SV_blank>"" : """" ; r_cons_printf ( ""%s0x%"" PFMT64d , comma , sym -> vaddr ) ; } r_cons_newline ( ) ; input ++ ; break ; case 'j' : input ++ ; r_cons_printf ( ""\\""class\\"":\\""%s\\"""" , cls -> name ) ; r_cons_printf ( "",\\""methods\\"":["" ) ; r_list_foreach ( cls -> methods , iter2 , sym ) { const char * comma = iter2 -> p ? "","" : """" ; if ( sym -> method_flags ) { char * flags = r_core_bin_method_flags_str ( sym , R_CORE_BIN_JSON ) ; r_cons_printf ( ""%s{\\""name\\"":\\""%s\\"",\\""flags\\"":%s,\\""vaddr\\"":%"" PFMT64d ""}"" , comma , sym -> name , flags , sym -> vaddr ) ; R_FREE ( flags ) ; } else { r_cons_printf ( ""%s{\\""name\\"":\\""%s\\"",\\""vaddr\\"":%"" PFMT64d ""}"" , comma , sym -> name , sym -> vaddr ) ; } } r_cons_printf ( ""]"" ) ; break ; default : r_cons_printf ( ""class<S2SV_blank>%s\\n"" , cls -> name ) ; r_list_foreach ( cls -> methods , iter2 , sym ) { char * flags = r_core_bin_method_flags_str ( sym , 0 ) ; r_cons_printf ( ""0x%08"" PFMT64x ""<S2SV_blank>method<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n"" , sym -> vaddr , cls -> name , flags , sym -> name ) ; R_FREE ( flags ) ; } break ; } goto done ; } goto done ; } else { playMsg ( core , ""classes"" , r_list_length ( obj -> classes ) ) ; if ( input [ 1 ] == 'l' && obj ) { r_list_foreach ( obj -> classes , iter , cls ) { r_list_foreach ( cls -> methods , iter2 , sym ) { const char * comma = iter2 -> p ? ""<S2SV_blank>"" : """" ; r_cons_printf ( ""%s0x%"" PFMT64d , comma , sym -> vaddr ) ; } if ( ! r_list_empty ( cls -> methods ) ) { r_cons_newline ( ) ; } } } else { RBININFO ( ""classes"" , R_CORE_BIN_ACC_CLASSES , NULL , r_list_length ( obj -> classes ) ) ; } } } } else { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; int len = obj ? r_list_length ( obj -> classes ) : 0 ; RBININFO ( ""classes"" , R_CORE_BIN_ACC_CLASSES , NULL , len ) ; } break ; case 'D' : if ( input [ 1 ] != '<S2SV_blank>' || ! demangle ( core , input + 2 ) ) { eprintf ( ""|Usage:<S2SV_blank>iD<S2SV_blank>lang<S2SV_blank>symbolname\\n"" ) ; } return 0 ; case 'a' : switch ( mode ) { case R_CORE_BIN_RADARE : cmd_info ( core , ""iIiecsSmz*"" ) ; break ; case R_CORE_BIN_JSON : cmd_info ( core , ""iIiecsSmzj"" ) ; break ; case R_CORE_BIN_SIMPLE : cmd_info ( core , ""iIiecsSmzq"" ) ; break ; default : cmd_info ( core , ""IiEecsSmz"" ) ; break ; } break ; case '?' : { const char * help_message [ ] = { ""Usage:<S2SV_blank>i"" , """" , ""Get<S2SV_blank>info<S2SV_blank>from<S2SV_blank>opened<S2SV_blank>file<S2SV_blank>(see<S2SV_blank>rabin2\'s<S2SV_blank>manpage)"" , ""Output<S2SV_blank>mode:"" , """" , """" , ""\'*\'"" , """" , ""Output<S2SV_blank>in<S2SV_blank>radare<S2SV_blank>commands"" , ""\'j\'"" , """" , ""Output<S2SV_blank>in<S2SV_blank>json"" , ""\'q\'"" , """" , ""Simple<S2SV_blank>quiet<S2SV_blank>output"" , ""Actions:"" , """" , """" , ""i|ij"" , """" , ""Show<S2SV_blank>info<S2SV_blank>of<S2SV_blank>current<S2SV_blank>file<S2SV_blank>(in<S2SV_blank>JSON)"" , ""iA"" , """" , ""List<S2SV_blank>archs"" , ""ia"" , """" , ""Show<S2SV_blank>all<S2SV_blank>info<S2SV_blank>(imports,<S2SV_blank>exports,<S2SV_blank>sections..)"" , ""ib"" , """" , ""Reload<S2SV_blank>the<S2SV_blank>current<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>setting<S2SV_blank>of<S2SV_blank>the<S2SV_blank>bin<S2SV_blank>(use<S2SV_blank>once<S2SV_blank>only)"" , ""ic"" , """" , ""List<S2SV_blank>classes,<S2SV_blank>methods<S2SV_blank>and<S2SV_blank>fields"" , ""iC"" , """" , ""Show<S2SV_blank>signature<S2SV_blank>info<S2SV_blank>(entitlements,<S2SV_blank>...)"" , ""id"" , """" , ""Debug<S2SV_blank>information<S2SV_blank>(source<S2SV_blank>lines)"" , ""iD"" , ""<S2SV_blank>lang<S2SV_blank>sym"" , ""demangle<S2SV_blank>symbolname<S2SV_blank>for<S2SV_blank>given<S2SV_blank>language"" , ""ie"" , """" , ""Entrypoint"" , ""iE"" , """" , ""Exports<S2SV_blank>(global<S2SV_blank>symbols)"" , ""ih"" , """" , ""Headers<S2SV_blank>(alias<S2SV_blank>for<S2SV_blank>iH)"" , ""iHH"" , """" , ""Verbose<S2SV_blank>Headers<S2SV_blank>in<S2SV_blank>raw<S2SV_blank>text"" , ""ii"" , """" , ""Imports"" , ""iI"" , """" , ""Binary<S2SV_blank>info"" , ""ik"" , ""<S2SV_blank>[query]"" , ""Key-value<S2SV_blank>database<S2SV_blank>from<S2SV_blank>RBinObject"" , ""il"" , """" , ""Libraries"" , ""iL<S2SV_blank>"" , ""[plugin]"" , ""List<S2SV_blank>all<S2SV_blank>RBin<S2SV_blank>plugins<S2SV_blank>loaded<S2SV_blank>or<S2SV_blank>plugin<S2SV_blank>details"" , ""im"" , """" , ""Show<S2SV_blank>info<S2SV_blank>about<S2SV_blank>predefined<S2SV_blank>memory<S2SV_blank>allocation"" , ""iM"" , """" , ""Show<S2SV_blank>main<S2SV_blank>address"" , ""io"" , ""<S2SV_blank>[file]"" , ""Load<S2SV_blank>info<S2SV_blank>from<S2SV_blank>file<S2SV_blank>(or<S2SV_blank>last<S2SV_blank>opened)<S2SV_blank>use<S2SV_blank>bin.baddr"" , ""ir"" , """" , ""Relocs"" , ""iR"" , """" , ""Resources"" , ""is"" , """" , ""Symbols"" , ""iS<S2SV_blank>"" , ""[entropy,sha1]"" , ""Sections<S2SV_blank>(choose<S2SV_blank>which<S2SV_blank>hash<S2SV_blank>algorithm<S2SV_blank>to<S2SV_blank>use)"" , ""iV"" , """" , ""Display<S2SV_blank>file<S2SV_blank>version<S2SV_blank>info"" , ""iz|izj"" , """" , ""Strings<S2SV_blank>in<S2SV_blank>data<S2SV_blank>sections<S2SV_blank>(in<S2SV_blank>JSON/Base64)"" , ""izz"" , """" , ""Search<S2SV_blank>for<S2SV_blank>Strings<S2SV_blank>in<S2SV_blank>the<S2SV_blank>whole<S2SV_blank>binary"" , ""iZ"" , """" , ""Guess<S2SV_blank>size<S2SV_blank>of<S2SV_blank>binary<S2SV_blank>program"" , NULL } ; r_core_cmd_help ( core , help_message ) ; } goto done ; case '*' : mode = R_CORE_BIN_RADARE ; goto done ; case 'q' : mode = R_CORE_BIN_SIMPLE ; cmd_info_bin ( core , va , mode ) ; goto done ; case 'j' : mode = R_CORE_BIN_JSON ; if ( is_array > 1 ) { mode |= R_CORE_BIN_ARRAY ; } cmd_info_bin ( core , va , mode ) ; goto done ; default : cmd_info_bin ( core , va , mode ) ; break ; } input ++ ; if ( ( * input == 'j' || * input == 'q' ) && ! input [ 1 ] ) { break ; } } done : if ( is_array ) { r_cons_printf ( ""}\\n"" ) ; } if ( newline ) { r_cons_newline ( ) ; } return 0 ; }","case \'i\' : {RBinObject * obj = r_bin_cur_object ( core -> bin ) ;RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ;}case \'I\' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ;",2696
748,"buggy line: uint8_t i ;if ( tlv_len < 4 ) {ND_PRINT ( ( ndo , ""\\\switch ( subtype ) {case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID : if ( tlv_len < 7 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_len < 7 ) {return hexdump ;}sublen = * ( tptr + 6 ) ;if ( tlv_len < 7 + sublen ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\safeputs ( ndo , tptr + 7 , sublen ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY : if ( tlv_len < 5 ) {return hexdump ;}sublen = * ( tptr + 4 ) ;if ( tlv_len < 5 + sublen ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\safeputs ( ndo , tptr + 5 , sublen ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH ) {return hexdump ;}tval = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\for ( i = 0 ;i < NO_OF_BITS ;i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ;tval = * ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\for ( i = 0 ;i < NO_OF_BITS ;i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH ) {return hexdump ;}tval = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\cwe id:CWE-835context: static int lldp_private_8021_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; u_int sublen ; u_int tval ;  uint8_t i ;  if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Subtype<S2SV_blank>(%u)"" , tok2str ( lldp_8021_subtype_values , ""unknown"" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID : if ( tlv_len < 6 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>port<S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(PVID):<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>port<S2SV_blank>and<S2SV_blank>protocol<S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(PPVID):<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>(0x%02x)"" , EXTRACT_16BITS ( tptr + 5 ) , bittok2str ( lldp_8021_port_protocol_id_values , ""none"" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME : if ( tlv_len < 6 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(VID):<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; if ( tlv_len < 7 ) { return hexdump ; } sublen = * ( tptr + 6 ) ; if ( tlv_len < 7 + sublen ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>vlan<S2SV_blank>name:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 7 , sublen ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY : if ( tlv_len < 5 ) { return hexdump ; } sublen = * ( tptr + 4 ) ; if ( tlv_len < 5 + sublen ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>protocol<S2SV_blank>identity:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , sublen ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Pre-Priority<S2SV_blank>CNPV<S2SV_blank>Indicator"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Pre-Priority<S2SV_blank>Ready<S2SV_blank>Indicator"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Willing:%d,<S2SV_blank>CBS:%d,<S2SV_blank>RES:%d,<S2SV_blank>Max<S2SV_blank>TCs:%d"" , tval >> 7 , ( tval >> 6 ) & 0x02 , ( tval >> 3 ) & 0x07 , tval & 0x07 ) ) ; print_ets_priority_assignment_table ( ndo , tptr + 5 ) ; print_tc_bandwidth_table ( ndo , tptr + 9 ) ; print_tsa_assignment_table ( ndo , tptr + 17 ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , * ( tptr + 4 ) ) ) ; print_ets_priority_assignment_table ( ndo , tptr + 5 ) ; print_tc_bandwidth_table ( ndo , tptr + 9 ) ; print_tsa_assignment_table ( ndo , tptr + 17 ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Willing:<S2SV_blank>%d,<S2SV_blank>MBC:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>PFC<S2SV_blank>cap:%d<S2SV_blank>"" , tval >> 7 , ( tval >> 6 ) & 0x01 , ( tval >> 4 ) & 0x03 , ( tval & 0x0f ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>PFC<S2SV_blank>Enable"" ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , * ( tptr + 4 ) ) ) ; if ( tlv_len <= LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH ) { return hexdump ; } sublen = tlv_len - 5 ; if ( sublen % 3 != 0 ) { return hexdump ; } i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Application<S2SV_blank>Priority<S2SV_blank>Table"" ) ) ; while ( i < sublen ) { tval = * ( tptr + i + 5 ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Sel:<S2SV_blank>%d"" ,   tval >> 5 , ( tval >> 3 ) & 0x03 , ( tval & 0x07 ) ) ) ;  ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ; i = i + 3 ; } break ; case LLDP_PRIVATE_8021_SUBTYPE_EVB : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>EVB<S2SV_blank>Bridge<S2SV_blank>Status"" ) ) ; tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>BGID:<S2SV_blank>%d,<S2SV_blank>RRCAP:<S2SV_blank>%d,<S2SV_blank>RRCTR:<S2SV_blank>%d"" , tval >> 3 , ( tval >> 2 ) & 0x01 , ( tval >> 1 ) & 0x01 , tval & 0x01 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>EVB<S2SV_blank>Station<S2SV_blank>Status"" ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>SGID:<S2SV_blank>%d,<S2SV_blank>RRREQ:<S2SV_blank>%d,RRSTAT:<S2SV_blank>%d"" , tval >> 4 , ( tval >> 3 ) & 0x01 , ( tval >> 2 ) & 0x01 , tval & 0x03 ) ) ; tval = * ( tptr + 6 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>R:<S2SV_blank>%d,<S2SV_blank>RTE:<S2SV_blank>%d,<S2SV_blank>"" , tval >> 5 , tval & 0x1f ) ) ; tval = * ( tptr + 7 ) ; ND_PRINT ( ( ndo , ""EVB<S2SV_blank>Mode:<S2SV_blank>%s<S2SV_blank>[%d]"" , tok2str ( lldp_evb_mode_values , ""unknown"" , tval >> 6 ) , tval >> 6 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ROL:<S2SV_blank>%d,<S2SV_blank>RWD:<S2SV_blank>%d,<S2SV_blank>"" , ( tval >> 5 ) & 0x01 , tval & 0x1f ) ) ; tval = * ( tptr + 8 ) ; ND_PRINT ( ( ndo , ""RES:<S2SV_blank>%d,<S2SV_blank>ROL:<S2SV_blank>%d,<S2SV_blank>RKA:<S2SV_blank>%d"" , tval >> 6 , ( tval >> 5 ) & 0x01 , tval & 0x1f ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_CDCP : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Role:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Scomp:<S2SV_blank>%d<S2SV_blank>"" , tval >> 7 , ( tval >> 4 ) & 0x07 , ( tval >> 3 ) & 0x01 ) ) ; ND_PRINT ( ( ndo , ""ChnCap:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + 6 ) & 0x0fff ) ) ; sublen = tlv_len - 8 ; if ( sublen % 3 != 0 ) { return hexdump ; } i = 0 ; while ( i < sublen ) { tval = EXTRACT_24BITS ( tptr + i + 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SCID:<S2SV_blank>%d,<S2SV_blank>SVID:<S2SV_blank>%d"" , tval >> 12 , tval & 0x000fff ) ) ; i = i + 3 ; } break ; default : hexdump = TRUE ; break ; } return hexdump ; }","u_int i ;if ( tlv_len < 4 ) {ND_PRINT ( ( ndo , ""\\\",2697
749,"buggy line: ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ;cwe id:CWE-835context: static int lldp_private_8021_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; u_int sublen ; u_int tval ;  uint8_t i ;  if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Subtype<S2SV_blank>(%u)"" , tok2str ( lldp_8021_subtype_values , ""unknown"" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID : if ( tlv_len < 6 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>port<S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(PVID):<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>port<S2SV_blank>and<S2SV_blank>protocol<S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(PPVID):<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>(0x%02x)"" , EXTRACT_16BITS ( tptr + 5 ) , bittok2str ( lldp_8021_port_protocol_id_values , ""none"" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME : if ( tlv_len < 6 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(VID):<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; if ( tlv_len < 7 ) { return hexdump ; } sublen = * ( tptr + 6 ) ; if ( tlv_len < 7 + sublen ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>vlan<S2SV_blank>name:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 7 , sublen ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY : if ( tlv_len < 5 ) { return hexdump ; } sublen = * ( tptr + 4 ) ; if ( tlv_len < 5 + sublen ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>protocol<S2SV_blank>identity:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , sublen ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Pre-Priority<S2SV_blank>CNPV<S2SV_blank>Indicator"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Pre-Priority<S2SV_blank>Ready<S2SV_blank>Indicator"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Willing:%d,<S2SV_blank>CBS:%d,<S2SV_blank>RES:%d,<S2SV_blank>Max<S2SV_blank>TCs:%d"" , tval >> 7 , ( tval >> 6 ) & 0x02 , ( tval >> 3 ) & 0x07 , tval & 0x07 ) ) ; print_ets_priority_assignment_table ( ndo , tptr + 5 ) ; print_tc_bandwidth_table ( ndo , tptr + 9 ) ; print_tsa_assignment_table ( ndo , tptr + 17 ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , * ( tptr + 4 ) ) ) ; print_ets_priority_assignment_table ( ndo , tptr + 5 ) ; print_tc_bandwidth_table ( ndo , tptr + 9 ) ; print_tsa_assignment_table ( ndo , tptr + 17 ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Willing:<S2SV_blank>%d,<S2SV_blank>MBC:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>PFC<S2SV_blank>cap:%d<S2SV_blank>"" , tval >> 7 , ( tval >> 6 ) & 0x01 , ( tval >> 4 ) & 0x03 , ( tval & 0x0f ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>PFC<S2SV_blank>Enable"" ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , * ( tptr + 4 ) ) ) ; if ( tlv_len <= LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH ) { return hexdump ; } sublen = tlv_len - 5 ; if ( sublen % 3 != 0 ) { return hexdump ; } i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Application<S2SV_blank>Priority<S2SV_blank>Table"" ) ) ; while ( i < sublen ) { tval = * ( tptr + i + 5 ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Sel:<S2SV_blank>%d"" ,   tval >> 5 , ( tval >> 3 ) & 0x03 , ( tval & 0x07 ) ) ) ;  ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ; i = i + 3 ; } break ; case LLDP_PRIVATE_8021_SUBTYPE_EVB : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>EVB<S2SV_blank>Bridge<S2SV_blank>Status"" ) ) ; tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>BGID:<S2SV_blank>%d,<S2SV_blank>RRCAP:<S2SV_blank>%d,<S2SV_blank>RRCTR:<S2SV_blank>%d"" , tval >> 3 , ( tval >> 2 ) & 0x01 , ( tval >> 1 ) & 0x01 , tval & 0x01 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>EVB<S2SV_blank>Station<S2SV_blank>Status"" ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>SGID:<S2SV_blank>%d,<S2SV_blank>RRREQ:<S2SV_blank>%d,RRSTAT:<S2SV_blank>%d"" , tval >> 4 , ( tval >> 3 ) & 0x01 , ( tval >> 2 ) & 0x01 , tval & 0x03 ) ) ; tval = * ( tptr + 6 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>R:<S2SV_blank>%d,<S2SV_blank>RTE:<S2SV_blank>%d,<S2SV_blank>"" , tval >> 5 , tval & 0x1f ) ) ; tval = * ( tptr + 7 ) ; ND_PRINT ( ( ndo , ""EVB<S2SV_blank>Mode:<S2SV_blank>%s<S2SV_blank>[%d]"" , tok2str ( lldp_evb_mode_values , ""unknown"" , tval >> 6 ) , tval >> 6 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ROL:<S2SV_blank>%d,<S2SV_blank>RWD:<S2SV_blank>%d,<S2SV_blank>"" , ( tval >> 5 ) & 0x01 , tval & 0x1f ) ) ; tval = * ( tptr + 8 ) ; ND_PRINT ( ( ndo , ""RES:<S2SV_blank>%d,<S2SV_blank>ROL:<S2SV_blank>%d,<S2SV_blank>RKA:<S2SV_blank>%d"" , tval >> 6 , ( tval >> 5 ) & 0x01 , tval & 0x1f ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_CDCP : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Role:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Scomp:<S2SV_blank>%d<S2SV_blank>"" , tval >> 7 , ( tval >> 4 ) & 0x07 , ( tval >> 3 ) & 0x01 ) ) ; ND_PRINT ( ( ndo , ""ChnCap:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + 6 ) & 0x0fff ) ) ; sublen = tlv_len - 8 ; if ( sublen % 3 != 0 ) { return hexdump ; } i = 0 ; while ( i < sublen ) { tval = EXTRACT_24BITS ( tptr + i + 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SCID:<S2SV_blank>%d,<S2SV_blank>SVID:<S2SV_blank>%d"" , tval >> 12 , tval & 0x000fff ) ) ; i = i + 3 ; } break ; default : hexdump = TRUE ; break ; } return hexdump ; }","ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ;",2697
750,"buggy line: futex_wait_queue_me ( hb , & q , to ) ;spin_lock ( & hb -> lock ) ;cwe id:CWE-269context: static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; int res , ret ; if ( uaddr == uaddr2 ) return - EINVAL ; if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; RB_CLEAR_NODE ( & rt_waiter . pi_tree_entry ) ; RB_CLEAR_NODE ( & rt_waiter . tree_entry ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ;  futex_wait_queue_me ( hb , & q , to ) ;  spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }","if ( match_futex ( & q . key , & key2 ) ) {ret = - EINVAL ;goto out_put_keys ;}futex_wait_queue_me ( hb , & q , to ) ;spin_lock ( & hb -> lock ) ;",2698
751,"buggy line: if ( ( e -> target_offset == sizeof ( struct ipt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> ip ) ) ||  visited ) {cwe id:CWE-119context: static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ipt_entry * e = ( struct ipt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ipt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ;  if ( ( e -> target_offset == sizeof ( struct ipt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> ip ) ) ||  visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ipt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ipt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ipt_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ipt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",2699
752,"buggy line: struct {struct ip_options opt ;char data [ 40 ] ;}replyopts ;if ( ip_options_echo ( & replyopts . opt , skb ) )  return ;daddr = ipc . addr = rt -> rt_src ;ipc . opt = NULL ;ipc . tx_flags = 0 ;if ( replyopts . opt . optlen ) {ipc . opt = & replyopts . opt ;if ( ipc . opt -> srr )   daddr = replyopts . opt . faddr ;}cwe id:CWE-362context: void ip_send_reply ( struct sock * sk , struct sk_buff * skb , struct ip_reply_arg * arg , unsigned int len ) { struct inet_sock * inet = inet_sk ( sk ) ;  struct {  struct ip_options opt ; char data [ 40 ] ; } replyopts ; struct ipcm_cookie ipc ; __be32 daddr ; struct rtable * rt = skb_rtable ( skb ) ;  if ( ip_options_echo ( & replyopts . opt , skb ) )  return ; daddr = ipc . addr = rt -> rt_src ; ipc . opt = NULL ; ipc . tx_flags = 0 ;  if ( replyopts . opt . optlen ) {  ipc . opt = & replyopts . opt ;  if ( ipc . opt -> srr )   daddr = replyopts . opt . faddr ;  } { struct flowi4 fl4 ; flowi4_init_output ( & fl4 , arg -> bound_dev_if , 0 , RT_TOS ( ip_hdr ( skb ) -> tos ) , RT_SCOPE_UNIVERSE , sk -> sk_protocol , ip_reply_arg_flowi_flags ( arg ) , daddr , rt -> rt_spec_dst , tcp_hdr ( skb ) -> source , tcp_hdr ( skb ) -> dest ) ; security_skb_classify_flow ( skb , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_key ( sock_net ( sk ) , & fl4 ) ; if ( IS_ERR ( rt ) ) return ; } bh_lock_sock ( sk ) ; inet -> tos = ip_hdr ( skb ) -> tos ; sk -> sk_priority = skb -> priority ; sk -> sk_protocol = ip_hdr ( skb ) -> protocol ; sk -> sk_bound_dev_if = arg -> bound_dev_if ; ip_append_data ( sk , ip_reply_glue_bits , arg -> iov -> iov_base , len , 0 , & ipc , & rt , MSG_DONTWAIT ) ; if ( ( skb = skb_peek ( & sk -> sk_write_queue ) ) != NULL ) { if ( arg -> csumoffset >= 0 ) * ( ( __sum16 * ) skb_transport_header ( skb ) + arg -> csumoffset ) = csum_fold ( csum_add ( skb -> csum , arg -> csum ) ) ; skb -> ip_summed = CHECKSUM_NONE ; ip_push_pending_frames ( sk ) ; } bh_unlock_sock ( sk ) ; ip_rt_put ( rt ) ; }",struct ip_options_data replyopts ;if ( replyopts . opt . opt . srr ) daddr = replyopts . opt . opt . faddr ;},2700
753,"buggy line: struct svc_rqst * rqstp = vrqstp ;set_freezable ( ) ;cwe id:CWE-404context: static int lockd ( void * vrqstp ) { int err = 0 ;  struct svc_rqst * rqstp = vrqstp ;  set_freezable ( ) ; allow_signal ( SIGKILL ) ; dprintk ( ""NFS<S2SV_blank>locking<S2SV_blank>service<S2SV_blank>started<S2SV_blank>(ver<S2SV_blank>"" LOCKD_VERSION "").\\n"" ) ; while ( ! kthread_should_stop ( ) ) { long timeout = MAX_SCHEDULE_TIMEOUT ; RPC_IFDEBUG ( char buf [ RPC_MAX_ADDRBUFLEN ] ) ; rqstp -> rq_server -> sv_maxconn = nlm_max_connections ; if ( signalled ( ) ) { flush_signals ( current ) ; restart_grace ( ) ; continue ; } timeout = nlmsvc_retry_blocked ( ) ; err = svc_recv ( rqstp , timeout ) ; if ( err == - EAGAIN || err == - EINTR ) continue ; dprintk ( ""lockd:<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s\\n"" , svc_print_addr ( rqstp , buf , sizeof ( buf ) ) ) ; svc_process ( rqstp ) ; } flush_signals ( current ) ; if ( nlmsvc_ops ) nlmsvc_invalidate_all ( ) ; nlm_shutdown_hosts ( ) ;  return 0 ;  }","struct svc_rqst * rqstp = vrqstp ;struct net * net = & init_net ;struct lockd_net * ln = net_generic ( net , lockd_net_id ) ;set_freezable ( ) ;cancel_delayed_work_sync ( & ln -> grace_period_end ) ;locks_end_grace ( & ln -> lockd_manager ) ;",2701
754,"buggy line: return 0 ;}cwe id:CWE-404context: static int lockd ( void * vrqstp ) { int err = 0 ;  struct svc_rqst * rqstp = vrqstp ;  set_freezable ( ) ; allow_signal ( SIGKILL ) ; dprintk ( ""NFS<S2SV_blank>locking<S2SV_blank>service<S2SV_blank>started<S2SV_blank>(ver<S2SV_blank>"" LOCKD_VERSION "").\\n"" ) ; while ( ! kthread_should_stop ( ) ) { long timeout = MAX_SCHEDULE_TIMEOUT ; RPC_IFDEBUG ( char buf [ RPC_MAX_ADDRBUFLEN ] ) ; rqstp -> rq_server -> sv_maxconn = nlm_max_connections ; if ( signalled ( ) ) { flush_signals ( current ) ; restart_grace ( ) ; continue ; } timeout = nlmsvc_retry_blocked ( ) ; err = svc_recv ( rqstp , timeout ) ; if ( err == - EAGAIN || err == - EINTR ) continue ; dprintk ( ""lockd:<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s\\n"" , svc_print_addr ( rqstp , buf , sizeof ( buf ) ) ) ; svc_process ( rqstp ) ; } flush_signals ( current ) ; if ( nlmsvc_ops ) nlmsvc_invalidate_all ( ) ; nlm_shutdown_hosts ( ) ;  return 0 ;  }",return 0 ;},2701
755,"buggy line: cp = ikev1_attrmap_print ( ndo , cp ,  ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;}cwe id:CWE-125context: static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) { const struct ikev1_pl_n * p ; struct ikev1_pl_n n ; const u_char * cp ; const u_char * ep2 ; uint32_t doi ; uint32_t proto ; static const char * notify_error_str [ ] = { NULL , ""INVALID-PAYLOAD-TYPE"" , ""DOI-NOT-SUPPORTED"" , ""SITUATION-NOT-SUPPORTED"" , ""INVALID-COOKIE"" , ""INVALID-MAJOR-VERSION"" , ""INVALID-MINOR-VERSION"" , ""INVALID-EXCHANGE-TYPE"" , ""INVALID-FLAGS"" , ""INVALID-MESSAGE-ID"" , ""INVALID-PROTOCOL-ID"" , ""INVALID-SPI"" , ""INVALID-TRANSFORM-ID"" , ""ATTRIBUTES-NOT-SUPPORTED"" , ""NO-PROPOSAL-CHOSEN"" , ""BAD-PROPOSAL-SYNTAX"" , ""PAYLOAD-MALFORMED"" , ""INVALID-KEY-INFORMATION"" , ""INVALID-ID-INFORMATION"" , ""INVALID-CERT-ENCODING"" , ""INVALID-CERTIFICATE"" , ""CERT-TYPE-UNSUPPORTED"" , ""INVALID-CERT-AUTHORITY"" , ""INVALID-HASH-INFORMATION"" , ""AUTHENTICATION-FAILED"" , ""INVALID-SIGNATURE"" , ""ADDRESS-NOTIFICATION"" , ""NOTIFY-SA-LIFETIME"" , ""CERTIFICATE-UNAVAILABLE"" , ""UNSUPPORTED-EXCHANGE-TYPE"" , ""UNEQUAL-PAYLOAD-LENGTHS"" , } ; static const char * ipsec_notify_error_str [ ] = { ""RESERVED"" , } ; static const char * notify_status_str [ ] = { ""CONNECTED"" , } ; static const char * ipsec_notify_status_str [ ] = { ""RESPONDER-LIFETIME"" , ""REPLAY-STATUS"" , ""INITIAL-CONTACT"" , } ; # define NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( x ) , notify_error_str ) # define IPSEC_NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 8192 ) , ipsec_notify_error_str ) # define NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 16384 ) , notify_status_str ) # define IPSEC_NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 24576 ) , ipsec_notify_status_str ) ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; p = ( const struct ikev1_pl_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; doi = ntohl ( n . doi ) ; proto = n . prot_id ; if ( doi != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>doi=%d"" , doi ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>proto=%d"" , proto ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , ""<S2SV_blank>spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } return ( const u_char * ) ( p + 1 ) + n . spi_size ; } ND_PRINT ( ( ndo , ""<S2SV_blank>doi=ipsec"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>proto=%s"" , PROTOIDSTR ( proto ) ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , IPSEC_NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 32768 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , IPSEC_NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , ""<S2SV_blank>spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ; ep2 = ( const u_char * ) p + item_len ; if ( cp < ep ) { switch ( ntohs ( n . type ) ) { case IPSECDOI_NTYPE_RESPONDER_LIFETIME : { const struct attrmap * map = oakley_t_map ; size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) ) ; while ( cp < ep && cp < ep2 ) { cp = ikev1_attrmap_print ( ndo , cp ,  ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;  } ND_PRINT ( ( ndo , "")"" ) ) ; break ; } case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ; ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }","cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ;if ( cp == NULL ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}",2702
756,"buggy line: case 16 :  # line 94 ""hex_grammar.y""  {# line 1023 ""hex_grammar.c"" break ;case 17 :  # line 95 ""hex_grammar.y""  {# line 1029 ""hex_grammar.c"" break ;case 18 :  # line 96 ""hex_grammar.y""  {# line 1035 ""hex_grammar.c"" break ;case 19 :  # line 97 ""hex_grammar.y""  {# line 1041 ""hex_grammar.c"" break ;case 21 :  # line 100 ""hex_grammar.y""  {# line 1047 ""hex_grammar.c"" break ;case 22 :  # line 99 ""hex_grammar.y""  {# line 1053 ""hex_grammar.c"" break ;case 23 :  # line 98 ""hex_grammar.y""  {# line 1059 ""hex_grammar.c"" break ;cwe id:CWE-674context: static void yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = ""Deleting"" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 16 :  # line 94 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1023 ""hex_grammar.c"" break ; case 17 :  # line 95 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1029 ""hex_grammar.c"" break ; case 18 :  # line 96 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1035 ""hex_grammar.c"" break ; case 19 :  # line 97 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1041 ""hex_grammar.c"" break ; case 21 :  # line 100 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1047 ""hex_grammar.c"" break ; case 22 :  # line 99 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1053 ""hex_grammar.c"" break ; case 23 :  # line 98 ""hex_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 ""hex_grammar.c"" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }","case 16 : # line 101 ""hex_grammar.y"" {# line 1030 ""hex_grammar.c"" break ;case 17 : # line 102 ""hex_grammar.y"" {# line 1036 ""hex_grammar.c"" break ;case 18 : # line 103 ""hex_grammar.y"" {# line 1042 ""hex_grammar.c"" break ;case 19 : # line 104 ""hex_grammar.y"" {# line 1048 ""hex_grammar.c"" break ;case 21 : # line 107 ""hex_grammar.y"" {# line 1054 ""hex_grammar.c"" break ;case 22 : # line 106 ""hex_grammar.y"" {# line 1060 ""hex_grammar.c"" break ;case 23 : # line 105 ""hex_grammar.y"" {# line 1066 ""hex_grammar.c"" break ;",2703
757,"buggy line: pch -> chan_net = net ;chan -> ppp = pch ;cwe id:CWE-416context: int ppp_register_net_channel ( struct net * net , struct ppp_channel * chan ) { struct channel * pch ; struct ppp_net * pn ; pch = kzalloc ( sizeof ( struct channel ) , GFP_KERNEL ) ; if ( ! pch ) return - ENOMEM ; pn = ppp_pernet ( net ) ; pch -> ppp = NULL ; pch -> chan = chan ;  pch -> chan_net = net ;  chan -> ppp = pch ; init_ppp_file ( & pch -> file , CHANNEL ) ; pch -> file . hdrlen = chan -> hdrlen ; # ifdef CONFIG_PPP_MULTILINK pch -> lastseq = - 1 ; # endif init_rwsem ( & pch -> chan_sem ) ; spin_lock_init ( & pch -> downl ) ; rwlock_init ( & pch -> upl ) ; spin_lock_bh ( & pn -> all_channels_lock ) ; pch -> file . index = ++ pn -> last_channel_index ; list_add ( & pch -> list , & pn -> new_channels ) ; atomic_inc ( & channel_count ) ; spin_unlock_bh ( & pn -> all_channels_lock ) ; return 0 ; }",pch -> chan_net = get_net ( net ) ;chan -> ppp = pch ;,2704
758,"buggy line: image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;cwe id:CWE-120context: static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char geometry [ MagickPathExtent ] , * property ; const char * label ; DrawInfo * draw_info ; Image * image ; MagickBooleanType status ; TypeMetric metrics ; size_t height , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; ( void ) ResetImagePage ( image , ""0x0+0+0"" ) ; property = InterpretImageProperties ( ( ImageInfo * ) image_info , image , image_info -> filename , exception ) ; ( void ) SetImageProperty ( image , ""label"" , property , exception ) ; property = DestroyString ( property ) ; label = GetImageProperty ( image , ""label"" , exception ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; draw_info -> text = ConstantString ( label ) ; metrics . width = 0 ; metrics . ascent = 0.0 ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) {  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;  image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; } else if ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ; } status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( image -> columns == 0 )  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;  if ( image -> columns == 0 )  image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;  if ( image -> rows == 0 )  image -> rows = ( size_t ) ( metrics . ascent - metrics . descent +  draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 )  image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;  status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image , exception ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : 0.0 , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; draw_info -> geometry = AcquireString ( geometry ) ; status = AnnotateImage ( image , draw_info , exception ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MagickPathExtent ] ; ( void ) FormatLocaleString ( pointsize , MagickPathExtent , ""%.20g"" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , ""label:pointsize"" , pointsize , exception ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } return ( GetFirstImageInList ( image ) ) ; }",image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;image -> rows = ( size_t ) floor floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,2705
759,"buggy line: width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;cwe id:CWE-120context: static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char geometry [ MagickPathExtent ] , * property ; const char * label ; DrawInfo * draw_info ; Image * image ; MagickBooleanType status ; TypeMetric metrics ; size_t height , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; ( void ) ResetImagePage ( image , ""0x0+0+0"" ) ; property = InterpretImageProperties ( ( ImageInfo * ) image_info , image , image_info -> filename , exception ) ; ( void ) SetImageProperty ( image , ""label"" , property , exception ) ; property = DestroyString ( property ) ; label = GetImageProperty ( image , ""label"" , exception ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; draw_info -> text = ConstantString ( label ) ; metrics . width = 0 ; metrics . ascent = 0.0 ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) {  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;  image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; } else if ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ; } status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( image -> columns == 0 )  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;  if ( image -> columns == 0 )  image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;  if ( image -> rows == 0 )  image -> rows = ( size_t ) ( metrics . ascent - metrics . descent +  draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 )  image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;  status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image , exception ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : 0.0 , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; draw_info -> geometry = AcquireString ( geometry ) ; status = AnnotateImage ( image , draw_info , exception ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MagickPathExtent ] ; ( void ) FormatLocaleString ( pointsize , MagickPathExtent , ""%.20g"" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , ""label:pointsize"" , pointsize , exception ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } return ( GetFirstImageInList ( image ) ) ; }",width = ( size_t ) floor floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;height = ( size_t ) floor floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,2705
760,"buggy line: width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;cwe id:CWE-120context: static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char geometry [ MagickPathExtent ] , * property ; const char * label ; DrawInfo * draw_info ; Image * image ; MagickBooleanType status ; TypeMetric metrics ; size_t height , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; ( void ) ResetImagePage ( image , ""0x0+0+0"" ) ; property = InterpretImageProperties ( ( ImageInfo * ) image_info , image , image_info -> filename , exception ) ; ( void ) SetImageProperty ( image , ""label"" , property , exception ) ; property = DestroyString ( property ) ; label = GetImageProperty ( image , ""label"" , exception ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; draw_info -> text = ConstantString ( label ) ; metrics . width = 0 ; metrics . ascent = 0.0 ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) {  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;  image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; } else if ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ; } status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( image -> columns == 0 )  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;  if ( image -> columns == 0 )  image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;  if ( image -> rows == 0 )  image -> rows = ( size_t ) ( metrics . ascent - metrics . descent +  draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 )  image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;  status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image , exception ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : 0.0 , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; draw_info -> geometry = AcquireString ( geometry ) ; status = AnnotateImage ( image , draw_info , exception ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MagickPathExtent ] ; ( void ) FormatLocaleString ( pointsize , MagickPathExtent , ""%.20g"" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , ""label:pointsize"" , pointsize , exception ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } return ( GetFirstImageInList ( image ) ) ; }",width = ( size_t ) floor floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;,2705
761,"buggy line: if ( image -> columns == 0 )  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;if ( image -> columns == 0 )  image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 )  image -> rows = ( size_t ) ( metrics . ascent - metrics . descent +  draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 )  image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;cwe id:CWE-120context: static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char geometry [ MagickPathExtent ] , * property ; const char * label ; DrawInfo * draw_info ; Image * image ; MagickBooleanType status ; TypeMetric metrics ; size_t height , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; ( void ) ResetImagePage ( image , ""0x0+0+0"" ) ; property = InterpretImageProperties ( ( ImageInfo * ) image_info , image , image_info -> filename , exception ) ; ( void ) SetImageProperty ( image , ""label"" , property , exception ) ; property = DestroyString ( property ) ; label = GetImageProperty ( image , ""label"" , exception ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; draw_info -> text = ConstantString ( label ) ; metrics . width = 0 ; metrics . ascent = 0.0 ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) {  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;  image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; } else if ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ; } status = GetMultilineTypeMetrics ( image , draw_info , & metrics , exception ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( image -> columns == 0 )  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;  if ( image -> columns == 0 )  image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;  if ( image -> rows == 0 )  image -> rows = ( size_t ) ( metrics . ascent - metrics . descent +  draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 )  image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;  status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image , exception ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%+g%+g"" , draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : 0.0 , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; draw_info -> geometry = AcquireString ( geometry ) ; status = AnnotateImage ( image , draw_info , exception ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MagickPathExtent ] ; ( void ) FormatLocaleString ( pointsize , MagickPathExtent , ""%.20g"" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , ""label:pointsize"" , pointsize , exception ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } return ( GetFirstImageInList ( image ) ) ; }","if ( image -> columns == 0 ) image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;if ( image -> columns == 0 ) image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 ) image -> rows = ( size_t ) ( metrics . ascent - metrics . descent + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 ) image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;",2705
762,"buggy line: cwe id:CWE-476context: GF_Err MergeTrack ( GF_TrackBox * trak , GF_TrackFragmentBox * traf , GF_MovieFragmentBox * moof_box , u64 moof_offset , s32 compressed_diff , u64 * cumulated_offset , Bool is_first_merge ) { u32 i , j , chunk_size , track_num ; u64 base_offset , data_offset , traf_duration ; u32 def_duration , DescIndex , def_size , def_flags ; u32 duration , size , flags , prev_trun_data_offset , sample_index ; u8 pad , sync ; u16 degr ; Bool first_samp_in_traf = GF_TRUE ; Bool store_traf_map = GF_FALSE ; u8 * moof_template = NULL ; u32 moof_template_size = 0 ; Bool is_seg_start = GF_FALSE ; u64 seg_start = 0 , sidx_start = 0 , sidx_end = 0 , frag_start = 0 , last_dts = 0 ; GF_TrackFragmentRunBox * trun ; GF_TrunEntry * ent ; # ifdef GF_ENABLE_CTRN GF_TrackFragmentBox * traf_ref = NULL ; # endif GF_Err stbl_AppendTime ( GF_SampleTableBox * stbl , u32 duration , u32 nb_pack ) ; GF_Err stbl_AppendSize ( GF_SampleTableBox * stbl , u32 size , u32 nb_pack ) ; GF_Err stbl_AppendChunk ( GF_SampleTableBox * stbl , u64 offset ) ; GF_Err stbl_AppendSampleToChunk ( GF_SampleTableBox * stbl , u32 DescIndex , u32 samplesInChunk ) ; GF_Err stbl_AppendCTSOffset ( GF_SampleTableBox * stbl , s32 CTSOffset ) ; GF_Err stbl_AppendRAP ( GF_SampleTableBox * stbl , u8 isRap ) ; GF_Err stbl_AppendPadding ( GF_SampleTableBox * stbl , u8 padding ) ; GF_Err stbl_AppendDegradation ( GF_SampleTableBox * stbl , u16 DegradationPriority ) ; if ( trak -> Header -> trackID != traf -> tfhd -> trackID ) return GF_OK ; if ( ! trak -> Media -> information -> sampleTable || ! trak -> Media -> information -> sampleTable -> SampleSize || ! trak -> Media -> information -> sampleTable -> TimeToSample || ! trak -> Media -> information -> sampleTable -> SampleToChunk || ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { return GF_ISOM_INVALID_FILE ; } if ( ! traf -> trex -> track ) traf -> trex -> track = trak ; DescIndex = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DESC ) ? traf -> tfhd -> sample_desc_index : traf -> trex -> def_sample_desc_index ; if ( ! DescIndex ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>0,<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" ) ) ; DescIndex = 1 ; } else if ( DescIndex > gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>sample<S2SV_blank>description(s),<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" , DescIndex , gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) ) ; DescIndex = 1 ; } # ifdef GF_ENABLE_CTRN if ( traf -> trex -> inherit_from_traf_id ) { u32 traf_count = gf_list_count ( moof_box -> TrackList ) ; for ( i = 0 ; i < traf_count ; i ++ ) { GF_TrackFragmentBox * atraf = gf_list_get ( moof_box -> TrackList , i ) ; if ( atraf -> tfhd && atraf -> tfhd -> trackID == traf -> trex -> inherit_from_traf_id ) { traf_ref = atraf ; break ; } } } # endif def_duration = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DUR ) ? traf -> tfhd -> def_sample_duration : traf -> trex -> def_sample_duration ; def_size = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_SIZE ) ? traf -> tfhd -> def_sample_size : traf -> trex -> def_sample_size ; def_flags = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_FLAGS ) ? traf -> tfhd -> def_sample_flags : traf -> trex -> def_sample_flags ; base_offset = moof_offset ; if ( traf -> tfhd -> flags & GF_ISOM_TRAF_BASE_OFFSET ) base_offset = traf -> tfhd -> base_data_offset ; else if ( ! ( traf -> tfhd -> flags & GF_ISOM_MOOF_BASE_OFFSET ) ) base_offset = * cumulated_offset ; chunk_size = 0 ; prev_trun_data_offset = 0 ; data_offset = 0 ; traf_duration = 0 ; if ( traf -> tfdt && is_first_merge ) { # ifndef GPAC_DISABLE_LOG if ( trak -> moov -> mov -> NextMoofNumber && trak -> present_in_scalable_segment && trak -> sample_count_at_seg_start && ( trak -> dts_at_seg_start != traf -> tfdt -> baseMediaDecodeTime ) ) { s32 drift = ( s32 ) ( ( s64 ) traf -> tfdt -> baseMediaDecodeTime - ( s64 ) trak -> dts_at_seg_start ) ; if ( drift < 0 ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Warning:<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>less<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>-<S2SV_blank>using<S2SV_blank>tfdt\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } else { GF_LOG ( GF_LOG_INFO , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>(last<S2SV_blank>sample<S2SV_blank>got<S2SV_blank>extended<S2SV_blank>in<S2SV_blank>duration)\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } } # endif trak -> dts_at_seg_start = traf -> tfdt -> baseMediaDecodeTime ; } else if ( traf -> tfxd ) { trak -> dts_at_seg_start = traf -> tfxd -> absolute_time_in_track_timescale ; } if ( traf -> tfxd ) { trak -> last_tfxd_value = traf -> tfxd -> absolute_time_in_track_timescale ; trak -> last_tfxd_value += traf -> tfxd -> fragment_duration_in_track_timescale ; } if ( traf -> tfrf ) { if ( trak -> tfrf ) gf_isom_box_del_parent ( & trak -> child_boxes , ( GF_Box * ) trak -> tfrf ) ; trak -> tfrf = traf -> tfrf ; gf_list_del_item ( traf -> child_boxes , traf -> tfrf ) ; gf_list_add ( trak -> child_boxes , trak -> tfrf ) ; } if ( trak -> moov -> mov -> signal_frag_bounds ) { store_traf_map = GF_TRUE ; if ( is_first_merge ) { GF_MovieFragmentBox * moof_clone = NULL ; gf_isom_box_freeze_order ( ( GF_Box * ) moof_box ) ; gf_isom_clone_box ( ( GF_Box * ) moof_box , ( GF_Box * * ) & moof_clone ) ; if ( moof_clone ) { GF_BitStream * bs ; for ( i = 0 ; i < gf_list_count ( moof_clone -> TrackList ) ; i ++ ) { GF_TrackFragmentBox * traf_clone = gf_list_get ( moof_clone -> TrackList , i ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> TrackRuns ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroups ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroupsDescription ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sub_samples ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_offsets ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_sizes ) ; if ( traf_clone -> sample_encryption ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sample_encryption ) ; traf_clone -> sample_encryption = NULL ; } if ( traf_clone -> sdtp ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sdtp ) ; traf_clone -> sdtp = NULL ; } } gf_isom_box_size ( ( GF_Box * ) moof_clone ) ; bs = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; if ( trak -> moov -> mov -> seg_styp ) { gf_isom_box_size ( trak -> moov -> mov -> seg_styp ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_styp , bs ) ; } if ( trak -> moov -> mov -> root_sidx ) { gf_isom_box_size ( ( GF_Box * ) trak -> moov -> mov -> root_sidx ) ; gf_isom_box_write ( ( GF_Box * ) trak -> moov -> mov -> root_sidx , bs ) ; } if ( trak -> moov -> mov -> seg_ssix ) { gf_isom_box_size ( trak -> moov -> mov -> seg_ssix ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_ssix , bs ) ; } gf_isom_box_write ( ( GF_Box * ) moof_clone , bs ) ; gf_isom_box_del ( ( GF_Box * ) moof_clone ) ; gf_bs_get_content ( bs , & moof_template , & moof_template_size ) ; gf_bs_del ( bs ) ; } } if ( trak -> moov -> mov -> seg_styp ) { is_seg_start = GF_TRUE ; seg_start = trak -> moov -> mov -> styp_start_offset ; } if ( trak -> moov -> mov -> root_sidx ) { is_seg_start = GF_TRUE ; sidx_start = trak -> moov -> mov -> sidx_start_offset ; sidx_end = trak -> moov -> mov -> sidx_end_offset ; if ( ! seg_start || ( sidx_start < seg_start ) ) seg_start = sidx_start ; } frag_start = trak -> moov -> mov -> current_top_box_start ; } else if ( trak -> moov -> mov -> store_traf_map ) { store_traf_map = GF_TRUE ; } sample_index = 0 ; i = 0 ; while ( ( trun = ( GF_TrackFragmentRunBox * ) gf_list_enum ( traf -> TrackRuns , & i ) ) ) { for ( j = 0 ; j < trun -> sample_count ; j ++ ) { GF_Err e ; s32 cts_offset = 0 ; if ( j < trun -> nb_samples ) { ent = & trun -> samples [ j ] ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>enough<S2SV_blank>trun<S2SV_blank>entries<S2SV_blank>(%d)<S2SV_blank>compared<S2SV_blank>to<S2SV_blank>sample<S2SV_blank>count<S2SV_blank>(%d)<S2SV_blank>in<S2SV_blank>run\\n"" , traf -> trex -> trackID , trun -> nb_samples , trun -> sample_count ) ) ; break ; } size = def_size ; duration = def_duration ; flags = def_flags ; cts_offset = ent -> CTS_Offset ; # ifdef GF_ENABLE_CTRN if ( trun -> use_ctrn ) { if ( ! j && ( trun -> ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE ) ) { if ( trun -> ctrn_first_dur ) duration = ent -> Duration ; if ( trun -> ctrn_first_size ) size = ent -> size ; if ( trun -> ctrn_first_ctts ) flags = ent -> flags ; } else { if ( trun -> ctrn_dur ) duration = ent -> Duration ; if ( trun -> ctrn_size ) size = ent -> size ; if ( trun -> ctrn_sample_flags ) flags = ent -> flags ; } if ( trun -> ctrn_flags & 0xF0 ) { GF_TrunEntry * ref_entry ; if ( ! traf_ref ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>to<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>reference<S2SV_blank>traf<S2SV_blank>not<S2SV_blank>found\\n"" , traf -> trex -> trackID , traf -> trex -> inherit_from_traf_id ) ) ; break ; } ref_entry = traf_get_sample_entry ( traf_ref , sample_index ) ; if ( ! ref_entry ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>but<S2SV_blank>sample<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>reference<S2SV_blank>traf\\n"" , traf -> trex -> trackID , sample_index + 1 ) ) ; break ; } if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR ) duration = ref_entry -> Duration ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE ) size = ref_entry -> size ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS ) flags = ref_entry -> flags ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO ) cts_offset = ref_entry -> CTS_Offset ; } } else # endif { if ( trun -> flags & GF_ISOM_TRUN_DURATION ) duration = ent -> Duration ; if ( trun -> flags & GF_ISOM_TRUN_SIZE ) size = ent -> size ; if ( trun -> flags & GF_ISOM_TRUN_FLAGS ) { flags = ent -> flags ; } else if ( ! j && ( trun -> flags & GF_ISOM_TRUN_FIRST_FLAG ) ) { flags = trun -> first_sample_flags ; } } sample_index ++ ; ent -> size = size ; ent -> Duration = duration ; ent -> flags = flags ; ent -> CTS_Offset = cts_offset ; last_dts += duration ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) { trak -> Media -> information -> sampleTable -> SampleSize = ( GF_SampleSizeBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSZ ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) return GF_OUT_OF_MEM ; } e = stbl_AppendSize ( trak -> Media -> information -> sampleTable , size , ent -> nb_pack ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) { trak -> Media -> information -> sampleTable -> TimeToSample = ( GF_TimeToSampleBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STTS ) ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) return GF_OUT_OF_MEM ; } e = stbl_AppendTime ( trak -> Media -> information -> sampleTable , duration , ent -> nb_pack ) ; if ( e ) return e ; if ( ! j ) { u64 final_offset ; data_offset = base_offset ; if ( trun -> flags & GF_ISOM_TRUN_DATA_OFFSET ) { data_offset += trun -> data_offset ; chunk_size = 0 ; prev_trun_data_offset = trun -> data_offset ; if ( trun -> data_offset >= 0 ) { data_offset -= compressed_diff ; prev_trun_data_offset -= compressed_diff ; } } else if ( prev_trun_data_offset ) { data_offset += prev_trun_data_offset + chunk_size ; } else { data_offset += chunk_size ; if ( ( i == 1 ) && ( trun -> data_offset >= 0 ) ) { data_offset -= compressed_diff ; } } final_offset = data_offset ; if ( trak -> moov -> compressed_diff ) { final_offset += trak -> moov -> compressed_diff ; } if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { trak -> Media -> information -> sampleTable -> ChunkOffset = gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STCO ) ; if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) return GF_OUT_OF_MEM ; } e = stbl_AppendChunk ( trak -> Media -> information -> sampleTable , final_offset ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) { trak -> Media -> information -> sampleTable -> SampleToChunk = ( GF_SampleToChunkBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSC ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) return GF_OUT_OF_MEM ; } e = stbl_AppendSampleToChunk ( trak -> Media -> information -> sampleTable , DescIndex , trun -> sample_count ) ; if ( e ) return e ; } chunk_size += size ; if ( store_traf_map && first_samp_in_traf ) { first_samp_in_traf = GF_FALSE ; e = stbl_AppendTrafMap ( trak -> Media -> information -> sampleTable , is_seg_start , seg_start , frag_start , moof_template , moof_template_size , sidx_start , sidx_end ) ; if ( e ) return e ; moof_template = NULL ; moof_template_size = 0 ; } if ( ent -> nb_pack > 1 ) { j += ent -> nb_pack - 1 ; traf_duration += ent -> nb_pack * duration ; continue ; } traf_duration += duration ; e = stbl_AppendCTSOffset ( trak -> Media -> information -> sampleTable , cts_offset ) ; if ( e ) return e ; sync = GF_ISOM_GET_FRAG_SYNC ( flags ) ; if ( trak -> Media -> information -> sampleTable -> no_sync_found && sync ) { trak -> Media -> information -> sampleTable -> no_sync_found = 0 ; } e = stbl_AppendRAP ( trak -> Media -> information -> sampleTable , sync ) ; if ( e ) return e ; pad = GF_ISOM_GET_FRAG_PAD ( flags ) ; if ( pad ) { e = stbl_AppendPadding ( trak -> Media -> information -> sampleTable , pad ) ; if ( e ) return e ; } degr = GF_ISOM_GET_FRAG_DEG ( flags ) ; if ( degr ) { e = stbl_AppendDegradation ( trak -> Media -> information -> sampleTable , degr ) ; if ( e ) return e ; } e = stbl_AppendDependencyType ( trak -> Media -> information -> sampleTable , GF_ISOM_GET_FRAG_LEAD ( flags ) , GF_ISOM_GET_FRAG_DEPENDS ( flags ) , GF_ISOM_GET_FRAG_DEPENDED ( flags ) , GF_ISOM_GET_FRAG_REDUNDANT ( flags ) ) ; if ( e ) return e ; } } if ( trak -> moov -> mov -> is_smooth && ! traf -> tfdt && ! traf -> tfxd ) { if ( is_first_merge ) trak -> dts_at_seg_start = trak -> dts_at_next_seg_start ; trak -> dts_at_next_seg_start += last_dts ; } if ( traf_duration && trak -> editBox && trak -> editBox -> editList ) { for ( i = 0 ; i < gf_list_count ( trak -> editBox -> editList -> entryList ) ; i ++ ) { GF_EdtsEntry * edts_e = gf_list_get ( trak -> editBox -> editList -> entryList , i ) ; if ( edts_e -> was_empty_dur ) { u64 extend_dur = traf_duration ; extend_dur *= trak -> moov -> mvhd -> timeScale ; extend_dur /= trak -> Media -> mediaHeader -> timeScale ; edts_e -> segmentDuration += extend_dur ; } else if ( ! edts_e -> segmentDuration ) { edts_e -> was_empty_dur = GF_TRUE ; if ( ( s64 ) traf_duration > edts_e -> mediaTime ) traf_duration -= edts_e -> mediaTime ; else traf_duration = 0 ; edts_e -> segmentDuration = traf_duration ; edts_e -> segmentDuration *= trak -> moov -> mvhd -> timeScale ; edts_e -> segmentDuration /= trak -> Media -> mediaHeader -> timeScale ; } } } * cumulated_offset = data_offset + chunk_size ; if ( traf -> sampleGroups ) { GF_List * groups ; GF_List * groupDescs ; Bool is_identical_sgpd = GF_TRUE ; u32 * new_idx = NULL , new_idx_count = 0 ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroups ) trak -> Media -> information -> sampleTable -> sampleGroups = gf_list_new ( ) ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) trak -> Media -> information -> sampleTable -> sampleGroupsDescription = gf_list_new ( ) ; groupDescs = trak -> Media -> information -> sampleTable -> sampleGroupsDescription ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroupsDescription ) ; i ++ ) { GF_SampleGroupDescriptionBox * new_sgdesc = NULL ; GF_SampleGroupDescriptionBox * sgdesc = gf_list_get ( traf -> sampleGroupsDescription , i ) ; for ( j = 0 ; j < gf_list_count ( groupDescs ) ; j ++ ) { new_sgdesc = gf_list_get ( groupDescs , j ) ; if ( new_sgdesc -> grouping_type == sgdesc -> grouping_type ) break ; new_sgdesc = NULL ; } if ( ! new_sgdesc ) { gf_list_add ( groupDescs , sgdesc ) ; gf_list_add ( trak -> Media -> information -> sampleTable -> child_boxes , sgdesc ) ; gf_list_rem ( traf -> sampleGroupsDescription , i ) ; gf_list_del_item ( traf -> child_boxes , sgdesc ) ; i -- ; } else { u32 count ; is_identical_sgpd = gf_isom_is_identical_sgpd ( new_sgdesc , sgdesc , 0 ) ; if ( is_identical_sgpd ) continue ; new_idx_count = gf_list_count ( sgdesc -> group_descriptions ) ; new_idx = ( u32 * ) gf_malloc ( new_idx_count * sizeof ( u32 ) ) ; if ( ! new_idx ) return GF_OUT_OF_MEM ; count = 0 ; while ( gf_list_count ( sgdesc -> group_descriptions ) ) { void * sgpd_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; Bool new_entry = GF_TRUE ; for ( j = 0 ; j < gf_list_count ( new_sgdesc -> group_descriptions ) ; j ++ ) { void * ptr = gf_list_get ( new_sgdesc -> group_descriptions , j ) ; if ( gf_isom_is_identical_sgpd ( sgpd_entry , ptr , new_sgdesc -> grouping_type ) ) { new_idx [ count ] = j + 1 ; count ++ ; new_entry = GF_FALSE ; gf_free ( sgpd_entry ) ; break ; } } if ( new_entry ) { gf_list_add ( new_sgdesc -> group_descriptions , sgpd_entry ) ; new_idx [ count ] = gf_list_count ( new_sgdesc -> group_descriptions ) ; count ++ ; } gf_list_rem ( sgdesc -> group_descriptions , 0 ) ; } } } groups = trak -> Media -> information -> sampleTable -> sampleGroups ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroups ) ; i ++ ) { GF_SampleGroupBox * stbl_group = NULL ; GF_SampleGroupBox * frag_group = gf_list_get ( traf -> sampleGroups , i ) ; for ( j = 0 ; j < gf_list_count ( groups ) ; j ++ ) { stbl_group = gf_list_get ( groups , j ) ; if ( ( frag_group -> grouping_type == stbl_group -> grouping_type ) && ( frag_group -> grouping_type_parameter == stbl_group -> grouping_type_parameter ) ) break ; stbl_group = NULL ; } if ( ! stbl_group ) { stbl_group = ( GF_SampleGroupBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_SBGP ) ; if ( ! stbl_group ) return GF_OUT_OF_MEM ; stbl_group -> grouping_type = frag_group -> grouping_type ; stbl_group -> grouping_type_parameter = frag_group -> grouping_type_parameter ; stbl_group -> version = frag_group -> version ; gf_list_add ( groups , stbl_group ) ; } if ( is_identical_sgpd ) { for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) frag_group -> sample_entries [ j ] . group_description_index &= 0x0FFFF ; if ( frag_group -> entry_count && stbl_group -> entry_count && ( frag_group -> sample_entries [ 0 ] . group_description_index == stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . group_description_index ) ) { stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . sample_count += frag_group -> sample_entries [ 0 ] . sample_count ; if ( frag_group -> entry_count > 1 ) { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count - 1 ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 1 ] , sizeof ( GF_SampleGroupEntry ) * ( frag_group -> entry_count - 1 ) ) ; stbl_group -> entry_count += frag_group -> entry_count - 1 ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) { u32 sgidx = frag_group -> sample_entries [ j ] . group_description_index ; if ( sgidx > 0x10000 ) { sgidx -= 0x10001 ; if ( sgidx >= new_idx_count ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>corrupted<S2SV_blank>sample<S2SV_blank>group<S2SV_blank>index<S2SV_blank>in<S2SV_blank>fragment<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>fragment\\n"" , sgidx , new_idx_count ) ) ; } else { frag_group -> sample_entries [ j ] . group_description_index = new_idx [ sgidx ] ; } } } memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } if ( new_idx ) gf_free ( new_idx ) ; } track_num = gf_isom_get_tracknum_from_id ( trak -> moov , trak -> Header -> trackID ) ; if ( gf_isom_is_cenc_media ( trak -> moov -> mov , track_num , DescIndex ) || traf -> sample_encryption ) { GF_SampleEncryptionBox * senc = NULL ; u32 scheme_type ; gf_isom_get_cenc_info ( trak -> moov -> mov , track_num , DescIndex , NULL , & scheme_type , NULL ) ; if ( traf -> sample_encryption ) { for ( i = 0 ; i < gf_list_count ( trak -> Media -> information -> sampleTable -> child_boxes ) ; i ++ ) { GF_Box * a = ( GF_Box * ) gf_list_get ( trak -> Media -> information -> sampleTable -> child_boxes , i ) ; if ( a -> type != traf -> sample_encryption -> type ) continue ; if ( ( a -> type == GF_ISOM_BOX_TYPE_UUID ) && ( ( ( GF_UUIDBox * ) a ) -> internal_4cc == GF_ISOM_BOX_UUID_PSEC ) ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } else if ( a -> type == GF_ISOM_BOX_TYPE_SENC ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } } if ( ! senc && trak -> sample_encryption ) senc = trak -> sample_encryption ; if ( ! senc ) { if ( traf -> sample_encryption -> piff_type == 1 ) { senc = ( GF_SampleEncryptionBox * ) gf_isom_create_piff_psec_box ( 1 , 0x2 , 0 , 0 , NULL ) ; } else { senc = gf_isom_create_samp_enc_box ( 1 , 0x2 ) ; } if ( ! trak -> Media -> information -> sampleTable -> child_boxes ) trak -> Media -> information -> sampleTable -> child_boxes = gf_list_new ( ) ; trak -> sample_encryption = senc ; if ( ! trak -> child_boxes ) trak -> child_boxes = gf_list_new ( ) ; gf_list_add ( trak -> child_boxes , senc ) ; } } if ( gf_isom_cenc_has_saiz_saio_traf ( traf , scheme_type ) ) { u32 nb_saio ; u32 aux_info_type ; u64 offset ; GF_Err e ; Bool is_encrypted ; GF_SampleAuxiliaryInfoOffsetBox * saio = NULL ; GF_SampleAuxiliaryInfoSizeBox * saiz = NULL ; offset = nb_saio = 0 ; for ( i = 0 ; i < gf_list_count ( traf -> sai_offsets ) ; i ++ ) { saio = ( GF_SampleAuxiliaryInfoOffsetBox * ) gf_list_get ( traf -> sai_offsets , i ) ; aux_info_type = saio -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_offsets ) == 1 ) ) {  offset = saio -> offsets [ 0 ] + moof_offset ;  nb_saio = saio -> entry_count ; break ; } }  for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) {  saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ; aux_info_type = saiz -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_sizes ) == 1 ) ) { break ;  }  } if ( saiz && saio && senc ) { for ( i = 0 ; i < saiz -> sample_count ; i ++ ) { GF_CENCSampleAuxInfo * sai ; const u8 * key_info = NULL ; u32 key_info_size ; u64 cur_position ; if ( nb_saio != 1 ) offset = saio -> offsets [ i ] + moof_offset ; size = saiz -> default_sample_info_size ? saiz -> default_sample_info_size : saiz -> sample_info_size [ i ] ; cur_position = gf_bs_get_position ( trak -> moov -> mov -> movieFileMap -> bs ) ; gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , offset ) ; GF_SAFEALLOC ( sai , GF_CENCSampleAuxInfo ) ; if ( ! sai ) return GF_OUT_OF_MEM ; e = gf_isom_get_sample_cenc_info_internal ( trak , traf , senc , i + 1 , & is_encrypted , NULL , NULL , & key_info , & key_info_size ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>cenc<S2SV_blank>info<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d:<S2SV_blank>%s\\n"" , i + 1 , gf_error_to_string ( e ) ) ) ; return e ; } if ( is_encrypted ) { sai -> cenc_data_size = size ; sai -> cenc_data = gf_malloc ( sizeof ( u8 ) * size ) ; if ( ! sai -> cenc_data ) return GF_OUT_OF_MEM ; gf_bs_read_data ( trak -> moov -> mov -> movieFileMap -> bs , sai -> cenc_data , sai -> cenc_data_size ) ; } else { sai -> isNotProtected = 1 ; } if ( key_info ) { if ( ! key_info [ 0 ] ) { if ( size > key_info [ 3 ] ) senc -> flags = 0x00000002 ; } else { senc -> flags = 0x00000002 ; } } gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , cur_position ) ; gf_list_add ( senc -> samp_aux_info , sai ) ; e = gf_isom_cenc_merge_saiz_saio ( senc , trak -> Media -> information -> sampleTable , offset , size ) ; if ( e ) return e ; if ( nb_saio == 1 ) offset += size ; } } } else if ( traf -> sample_encryption ) { senc_Parse ( trak -> moov -> mov -> movieFileMap -> bs , trak , traf , traf -> sample_encryption ) ; trak -> sample_encryption -> AlgorithmID = traf -> sample_encryption -> AlgorithmID ; if ( ! trak -> sample_encryption -> IV_size ) trak -> sample_encryption -> IV_size = traf -> sample_encryption -> IV_size ; if ( ! trak -> sample_encryption -> samp_aux_info ) trak -> sample_encryption -> samp_aux_info = gf_list_new ( ) ; gf_list_transfer ( trak -> sample_encryption -> samp_aux_info , traf -> sample_encryption -> samp_aux_info ) ; if ( traf -> sample_encryption -> flags & 0x00000002 ) trak -> sample_encryption -> flags |= 0x00000002 ; } } return GF_OK ; }",if ( saio -> offsets && saio -> entry_count ) {,2706
763,"buggy line: cwe id:CWE-476context: GF_Err MergeTrack ( GF_TrackBox * trak , GF_TrackFragmentBox * traf , GF_MovieFragmentBox * moof_box , u64 moof_offset , s32 compressed_diff , u64 * cumulated_offset , Bool is_first_merge ) { u32 i , j , chunk_size , track_num ; u64 base_offset , data_offset , traf_duration ; u32 def_duration , DescIndex , def_size , def_flags ; u32 duration , size , flags , prev_trun_data_offset , sample_index ; u8 pad , sync ; u16 degr ; Bool first_samp_in_traf = GF_TRUE ; Bool store_traf_map = GF_FALSE ; u8 * moof_template = NULL ; u32 moof_template_size = 0 ; Bool is_seg_start = GF_FALSE ; u64 seg_start = 0 , sidx_start = 0 , sidx_end = 0 , frag_start = 0 , last_dts = 0 ; GF_TrackFragmentRunBox * trun ; GF_TrunEntry * ent ; # ifdef GF_ENABLE_CTRN GF_TrackFragmentBox * traf_ref = NULL ; # endif GF_Err stbl_AppendTime ( GF_SampleTableBox * stbl , u32 duration , u32 nb_pack ) ; GF_Err stbl_AppendSize ( GF_SampleTableBox * stbl , u32 size , u32 nb_pack ) ; GF_Err stbl_AppendChunk ( GF_SampleTableBox * stbl , u64 offset ) ; GF_Err stbl_AppendSampleToChunk ( GF_SampleTableBox * stbl , u32 DescIndex , u32 samplesInChunk ) ; GF_Err stbl_AppendCTSOffset ( GF_SampleTableBox * stbl , s32 CTSOffset ) ; GF_Err stbl_AppendRAP ( GF_SampleTableBox * stbl , u8 isRap ) ; GF_Err stbl_AppendPadding ( GF_SampleTableBox * stbl , u8 padding ) ; GF_Err stbl_AppendDegradation ( GF_SampleTableBox * stbl , u16 DegradationPriority ) ; if ( trak -> Header -> trackID != traf -> tfhd -> trackID ) return GF_OK ; if ( ! trak -> Media -> information -> sampleTable || ! trak -> Media -> information -> sampleTable -> SampleSize || ! trak -> Media -> information -> sampleTable -> TimeToSample || ! trak -> Media -> information -> sampleTable -> SampleToChunk || ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { return GF_ISOM_INVALID_FILE ; } if ( ! traf -> trex -> track ) traf -> trex -> track = trak ; DescIndex = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DESC ) ? traf -> tfhd -> sample_desc_index : traf -> trex -> def_sample_desc_index ; if ( ! DescIndex ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>0,<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" ) ) ; DescIndex = 1 ; } else if ( DescIndex > gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>sample<S2SV_blank>description(s),<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" , DescIndex , gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) ) ; DescIndex = 1 ; } # ifdef GF_ENABLE_CTRN if ( traf -> trex -> inherit_from_traf_id ) { u32 traf_count = gf_list_count ( moof_box -> TrackList ) ; for ( i = 0 ; i < traf_count ; i ++ ) { GF_TrackFragmentBox * atraf = gf_list_get ( moof_box -> TrackList , i ) ; if ( atraf -> tfhd && atraf -> tfhd -> trackID == traf -> trex -> inherit_from_traf_id ) { traf_ref = atraf ; break ; } } } # endif def_duration = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DUR ) ? traf -> tfhd -> def_sample_duration : traf -> trex -> def_sample_duration ; def_size = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_SIZE ) ? traf -> tfhd -> def_sample_size : traf -> trex -> def_sample_size ; def_flags = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_FLAGS ) ? traf -> tfhd -> def_sample_flags : traf -> trex -> def_sample_flags ; base_offset = moof_offset ; if ( traf -> tfhd -> flags & GF_ISOM_TRAF_BASE_OFFSET ) base_offset = traf -> tfhd -> base_data_offset ; else if ( ! ( traf -> tfhd -> flags & GF_ISOM_MOOF_BASE_OFFSET ) ) base_offset = * cumulated_offset ; chunk_size = 0 ; prev_trun_data_offset = 0 ; data_offset = 0 ; traf_duration = 0 ; if ( traf -> tfdt && is_first_merge ) { # ifndef GPAC_DISABLE_LOG if ( trak -> moov -> mov -> NextMoofNumber && trak -> present_in_scalable_segment && trak -> sample_count_at_seg_start && ( trak -> dts_at_seg_start != traf -> tfdt -> baseMediaDecodeTime ) ) { s32 drift = ( s32 ) ( ( s64 ) traf -> tfdt -> baseMediaDecodeTime - ( s64 ) trak -> dts_at_seg_start ) ; if ( drift < 0 ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Warning:<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>less<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>-<S2SV_blank>using<S2SV_blank>tfdt\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } else { GF_LOG ( GF_LOG_INFO , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>(last<S2SV_blank>sample<S2SV_blank>got<S2SV_blank>extended<S2SV_blank>in<S2SV_blank>duration)\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } } # endif trak -> dts_at_seg_start = traf -> tfdt -> baseMediaDecodeTime ; } else if ( traf -> tfxd ) { trak -> dts_at_seg_start = traf -> tfxd -> absolute_time_in_track_timescale ; } if ( traf -> tfxd ) { trak -> last_tfxd_value = traf -> tfxd -> absolute_time_in_track_timescale ; trak -> last_tfxd_value += traf -> tfxd -> fragment_duration_in_track_timescale ; } if ( traf -> tfrf ) { if ( trak -> tfrf ) gf_isom_box_del_parent ( & trak -> child_boxes , ( GF_Box * ) trak -> tfrf ) ; trak -> tfrf = traf -> tfrf ; gf_list_del_item ( traf -> child_boxes , traf -> tfrf ) ; gf_list_add ( trak -> child_boxes , trak -> tfrf ) ; } if ( trak -> moov -> mov -> signal_frag_bounds ) { store_traf_map = GF_TRUE ; if ( is_first_merge ) { GF_MovieFragmentBox * moof_clone = NULL ; gf_isom_box_freeze_order ( ( GF_Box * ) moof_box ) ; gf_isom_clone_box ( ( GF_Box * ) moof_box , ( GF_Box * * ) & moof_clone ) ; if ( moof_clone ) { GF_BitStream * bs ; for ( i = 0 ; i < gf_list_count ( moof_clone -> TrackList ) ; i ++ ) { GF_TrackFragmentBox * traf_clone = gf_list_get ( moof_clone -> TrackList , i ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> TrackRuns ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroups ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroupsDescription ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sub_samples ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_offsets ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_sizes ) ; if ( traf_clone -> sample_encryption ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sample_encryption ) ; traf_clone -> sample_encryption = NULL ; } if ( traf_clone -> sdtp ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sdtp ) ; traf_clone -> sdtp = NULL ; } } gf_isom_box_size ( ( GF_Box * ) moof_clone ) ; bs = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; if ( trak -> moov -> mov -> seg_styp ) { gf_isom_box_size ( trak -> moov -> mov -> seg_styp ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_styp , bs ) ; } if ( trak -> moov -> mov -> root_sidx ) { gf_isom_box_size ( ( GF_Box * ) trak -> moov -> mov -> root_sidx ) ; gf_isom_box_write ( ( GF_Box * ) trak -> moov -> mov -> root_sidx , bs ) ; } if ( trak -> moov -> mov -> seg_ssix ) { gf_isom_box_size ( trak -> moov -> mov -> seg_ssix ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_ssix , bs ) ; } gf_isom_box_write ( ( GF_Box * ) moof_clone , bs ) ; gf_isom_box_del ( ( GF_Box * ) moof_clone ) ; gf_bs_get_content ( bs , & moof_template , & moof_template_size ) ; gf_bs_del ( bs ) ; } } if ( trak -> moov -> mov -> seg_styp ) { is_seg_start = GF_TRUE ; seg_start = trak -> moov -> mov -> styp_start_offset ; } if ( trak -> moov -> mov -> root_sidx ) { is_seg_start = GF_TRUE ; sidx_start = trak -> moov -> mov -> sidx_start_offset ; sidx_end = trak -> moov -> mov -> sidx_end_offset ; if ( ! seg_start || ( sidx_start < seg_start ) ) seg_start = sidx_start ; } frag_start = trak -> moov -> mov -> current_top_box_start ; } else if ( trak -> moov -> mov -> store_traf_map ) { store_traf_map = GF_TRUE ; } sample_index = 0 ; i = 0 ; while ( ( trun = ( GF_TrackFragmentRunBox * ) gf_list_enum ( traf -> TrackRuns , & i ) ) ) { for ( j = 0 ; j < trun -> sample_count ; j ++ ) { GF_Err e ; s32 cts_offset = 0 ; if ( j < trun -> nb_samples ) { ent = & trun -> samples [ j ] ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>enough<S2SV_blank>trun<S2SV_blank>entries<S2SV_blank>(%d)<S2SV_blank>compared<S2SV_blank>to<S2SV_blank>sample<S2SV_blank>count<S2SV_blank>(%d)<S2SV_blank>in<S2SV_blank>run\\n"" , traf -> trex -> trackID , trun -> nb_samples , trun -> sample_count ) ) ; break ; } size = def_size ; duration = def_duration ; flags = def_flags ; cts_offset = ent -> CTS_Offset ; # ifdef GF_ENABLE_CTRN if ( trun -> use_ctrn ) { if ( ! j && ( trun -> ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE ) ) { if ( trun -> ctrn_first_dur ) duration = ent -> Duration ; if ( trun -> ctrn_first_size ) size = ent -> size ; if ( trun -> ctrn_first_ctts ) flags = ent -> flags ; } else { if ( trun -> ctrn_dur ) duration = ent -> Duration ; if ( trun -> ctrn_size ) size = ent -> size ; if ( trun -> ctrn_sample_flags ) flags = ent -> flags ; } if ( trun -> ctrn_flags & 0xF0 ) { GF_TrunEntry * ref_entry ; if ( ! traf_ref ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>to<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>reference<S2SV_blank>traf<S2SV_blank>not<S2SV_blank>found\\n"" , traf -> trex -> trackID , traf -> trex -> inherit_from_traf_id ) ) ; break ; } ref_entry = traf_get_sample_entry ( traf_ref , sample_index ) ; if ( ! ref_entry ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>but<S2SV_blank>sample<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>reference<S2SV_blank>traf\\n"" , traf -> trex -> trackID , sample_index + 1 ) ) ; break ; } if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR ) duration = ref_entry -> Duration ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE ) size = ref_entry -> size ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS ) flags = ref_entry -> flags ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO ) cts_offset = ref_entry -> CTS_Offset ; } } else # endif { if ( trun -> flags & GF_ISOM_TRUN_DURATION ) duration = ent -> Duration ; if ( trun -> flags & GF_ISOM_TRUN_SIZE ) size = ent -> size ; if ( trun -> flags & GF_ISOM_TRUN_FLAGS ) { flags = ent -> flags ; } else if ( ! j && ( trun -> flags & GF_ISOM_TRUN_FIRST_FLAG ) ) { flags = trun -> first_sample_flags ; } } sample_index ++ ; ent -> size = size ; ent -> Duration = duration ; ent -> flags = flags ; ent -> CTS_Offset = cts_offset ; last_dts += duration ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) { trak -> Media -> information -> sampleTable -> SampleSize = ( GF_SampleSizeBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSZ ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) return GF_OUT_OF_MEM ; } e = stbl_AppendSize ( trak -> Media -> information -> sampleTable , size , ent -> nb_pack ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) { trak -> Media -> information -> sampleTable -> TimeToSample = ( GF_TimeToSampleBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STTS ) ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) return GF_OUT_OF_MEM ; } e = stbl_AppendTime ( trak -> Media -> information -> sampleTable , duration , ent -> nb_pack ) ; if ( e ) return e ; if ( ! j ) { u64 final_offset ; data_offset = base_offset ; if ( trun -> flags & GF_ISOM_TRUN_DATA_OFFSET ) { data_offset += trun -> data_offset ; chunk_size = 0 ; prev_trun_data_offset = trun -> data_offset ; if ( trun -> data_offset >= 0 ) { data_offset -= compressed_diff ; prev_trun_data_offset -= compressed_diff ; } } else if ( prev_trun_data_offset ) { data_offset += prev_trun_data_offset + chunk_size ; } else { data_offset += chunk_size ; if ( ( i == 1 ) && ( trun -> data_offset >= 0 ) ) { data_offset -= compressed_diff ; } } final_offset = data_offset ; if ( trak -> moov -> compressed_diff ) { final_offset += trak -> moov -> compressed_diff ; } if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { trak -> Media -> information -> sampleTable -> ChunkOffset = gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STCO ) ; if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) return GF_OUT_OF_MEM ; } e = stbl_AppendChunk ( trak -> Media -> information -> sampleTable , final_offset ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) { trak -> Media -> information -> sampleTable -> SampleToChunk = ( GF_SampleToChunkBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSC ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) return GF_OUT_OF_MEM ; } e = stbl_AppendSampleToChunk ( trak -> Media -> information -> sampleTable , DescIndex , trun -> sample_count ) ; if ( e ) return e ; } chunk_size += size ; if ( store_traf_map && first_samp_in_traf ) { first_samp_in_traf = GF_FALSE ; e = stbl_AppendTrafMap ( trak -> Media -> information -> sampleTable , is_seg_start , seg_start , frag_start , moof_template , moof_template_size , sidx_start , sidx_end ) ; if ( e ) return e ; moof_template = NULL ; moof_template_size = 0 ; } if ( ent -> nb_pack > 1 ) { j += ent -> nb_pack - 1 ; traf_duration += ent -> nb_pack * duration ; continue ; } traf_duration += duration ; e = stbl_AppendCTSOffset ( trak -> Media -> information -> sampleTable , cts_offset ) ; if ( e ) return e ; sync = GF_ISOM_GET_FRAG_SYNC ( flags ) ; if ( trak -> Media -> information -> sampleTable -> no_sync_found && sync ) { trak -> Media -> information -> sampleTable -> no_sync_found = 0 ; } e = stbl_AppendRAP ( trak -> Media -> information -> sampleTable , sync ) ; if ( e ) return e ; pad = GF_ISOM_GET_FRAG_PAD ( flags ) ; if ( pad ) { e = stbl_AppendPadding ( trak -> Media -> information -> sampleTable , pad ) ; if ( e ) return e ; } degr = GF_ISOM_GET_FRAG_DEG ( flags ) ; if ( degr ) { e = stbl_AppendDegradation ( trak -> Media -> information -> sampleTable , degr ) ; if ( e ) return e ; } e = stbl_AppendDependencyType ( trak -> Media -> information -> sampleTable , GF_ISOM_GET_FRAG_LEAD ( flags ) , GF_ISOM_GET_FRAG_DEPENDS ( flags ) , GF_ISOM_GET_FRAG_DEPENDED ( flags ) , GF_ISOM_GET_FRAG_REDUNDANT ( flags ) ) ; if ( e ) return e ; } } if ( trak -> moov -> mov -> is_smooth && ! traf -> tfdt && ! traf -> tfxd ) { if ( is_first_merge ) trak -> dts_at_seg_start = trak -> dts_at_next_seg_start ; trak -> dts_at_next_seg_start += last_dts ; } if ( traf_duration && trak -> editBox && trak -> editBox -> editList ) { for ( i = 0 ; i < gf_list_count ( trak -> editBox -> editList -> entryList ) ; i ++ ) { GF_EdtsEntry * edts_e = gf_list_get ( trak -> editBox -> editList -> entryList , i ) ; if ( edts_e -> was_empty_dur ) { u64 extend_dur = traf_duration ; extend_dur *= trak -> moov -> mvhd -> timeScale ; extend_dur /= trak -> Media -> mediaHeader -> timeScale ; edts_e -> segmentDuration += extend_dur ; } else if ( ! edts_e -> segmentDuration ) { edts_e -> was_empty_dur = GF_TRUE ; if ( ( s64 ) traf_duration > edts_e -> mediaTime ) traf_duration -= edts_e -> mediaTime ; else traf_duration = 0 ; edts_e -> segmentDuration = traf_duration ; edts_e -> segmentDuration *= trak -> moov -> mvhd -> timeScale ; edts_e -> segmentDuration /= trak -> Media -> mediaHeader -> timeScale ; } } } * cumulated_offset = data_offset + chunk_size ; if ( traf -> sampleGroups ) { GF_List * groups ; GF_List * groupDescs ; Bool is_identical_sgpd = GF_TRUE ; u32 * new_idx = NULL , new_idx_count = 0 ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroups ) trak -> Media -> information -> sampleTable -> sampleGroups = gf_list_new ( ) ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) trak -> Media -> information -> sampleTable -> sampleGroupsDescription = gf_list_new ( ) ; groupDescs = trak -> Media -> information -> sampleTable -> sampleGroupsDescription ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroupsDescription ) ; i ++ ) { GF_SampleGroupDescriptionBox * new_sgdesc = NULL ; GF_SampleGroupDescriptionBox * sgdesc = gf_list_get ( traf -> sampleGroupsDescription , i ) ; for ( j = 0 ; j < gf_list_count ( groupDescs ) ; j ++ ) { new_sgdesc = gf_list_get ( groupDescs , j ) ; if ( new_sgdesc -> grouping_type == sgdesc -> grouping_type ) break ; new_sgdesc = NULL ; } if ( ! new_sgdesc ) { gf_list_add ( groupDescs , sgdesc ) ; gf_list_add ( trak -> Media -> information -> sampleTable -> child_boxes , sgdesc ) ; gf_list_rem ( traf -> sampleGroupsDescription , i ) ; gf_list_del_item ( traf -> child_boxes , sgdesc ) ; i -- ; } else { u32 count ; is_identical_sgpd = gf_isom_is_identical_sgpd ( new_sgdesc , sgdesc , 0 ) ; if ( is_identical_sgpd ) continue ; new_idx_count = gf_list_count ( sgdesc -> group_descriptions ) ; new_idx = ( u32 * ) gf_malloc ( new_idx_count * sizeof ( u32 ) ) ; if ( ! new_idx ) return GF_OUT_OF_MEM ; count = 0 ; while ( gf_list_count ( sgdesc -> group_descriptions ) ) { void * sgpd_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; Bool new_entry = GF_TRUE ; for ( j = 0 ; j < gf_list_count ( new_sgdesc -> group_descriptions ) ; j ++ ) { void * ptr = gf_list_get ( new_sgdesc -> group_descriptions , j ) ; if ( gf_isom_is_identical_sgpd ( sgpd_entry , ptr , new_sgdesc -> grouping_type ) ) { new_idx [ count ] = j + 1 ; count ++ ; new_entry = GF_FALSE ; gf_free ( sgpd_entry ) ; break ; } } if ( new_entry ) { gf_list_add ( new_sgdesc -> group_descriptions , sgpd_entry ) ; new_idx [ count ] = gf_list_count ( new_sgdesc -> group_descriptions ) ; count ++ ; } gf_list_rem ( sgdesc -> group_descriptions , 0 ) ; } } } groups = trak -> Media -> information -> sampleTable -> sampleGroups ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroups ) ; i ++ ) { GF_SampleGroupBox * stbl_group = NULL ; GF_SampleGroupBox * frag_group = gf_list_get ( traf -> sampleGroups , i ) ; for ( j = 0 ; j < gf_list_count ( groups ) ; j ++ ) { stbl_group = gf_list_get ( groups , j ) ; if ( ( frag_group -> grouping_type == stbl_group -> grouping_type ) && ( frag_group -> grouping_type_parameter == stbl_group -> grouping_type_parameter ) ) break ; stbl_group = NULL ; } if ( ! stbl_group ) { stbl_group = ( GF_SampleGroupBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_SBGP ) ; if ( ! stbl_group ) return GF_OUT_OF_MEM ; stbl_group -> grouping_type = frag_group -> grouping_type ; stbl_group -> grouping_type_parameter = frag_group -> grouping_type_parameter ; stbl_group -> version = frag_group -> version ; gf_list_add ( groups , stbl_group ) ; } if ( is_identical_sgpd ) { for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) frag_group -> sample_entries [ j ] . group_description_index &= 0x0FFFF ; if ( frag_group -> entry_count && stbl_group -> entry_count && ( frag_group -> sample_entries [ 0 ] . group_description_index == stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . group_description_index ) ) { stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . sample_count += frag_group -> sample_entries [ 0 ] . sample_count ; if ( frag_group -> entry_count > 1 ) { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count - 1 ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 1 ] , sizeof ( GF_SampleGroupEntry ) * ( frag_group -> entry_count - 1 ) ) ; stbl_group -> entry_count += frag_group -> entry_count - 1 ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) { u32 sgidx = frag_group -> sample_entries [ j ] . group_description_index ; if ( sgidx > 0x10000 ) { sgidx -= 0x10001 ; if ( sgidx >= new_idx_count ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>corrupted<S2SV_blank>sample<S2SV_blank>group<S2SV_blank>index<S2SV_blank>in<S2SV_blank>fragment<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>fragment\\n"" , sgidx , new_idx_count ) ) ; } else { frag_group -> sample_entries [ j ] . group_description_index = new_idx [ sgidx ] ; } } } memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } if ( new_idx ) gf_free ( new_idx ) ; } track_num = gf_isom_get_tracknum_from_id ( trak -> moov , trak -> Header -> trackID ) ; if ( gf_isom_is_cenc_media ( trak -> moov -> mov , track_num , DescIndex ) || traf -> sample_encryption ) { GF_SampleEncryptionBox * senc = NULL ; u32 scheme_type ; gf_isom_get_cenc_info ( trak -> moov -> mov , track_num , DescIndex , NULL , & scheme_type , NULL ) ; if ( traf -> sample_encryption ) { for ( i = 0 ; i < gf_list_count ( trak -> Media -> information -> sampleTable -> child_boxes ) ; i ++ ) { GF_Box * a = ( GF_Box * ) gf_list_get ( trak -> Media -> information -> sampleTable -> child_boxes , i ) ; if ( a -> type != traf -> sample_encryption -> type ) continue ; if ( ( a -> type == GF_ISOM_BOX_TYPE_UUID ) && ( ( ( GF_UUIDBox * ) a ) -> internal_4cc == GF_ISOM_BOX_UUID_PSEC ) ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } else if ( a -> type == GF_ISOM_BOX_TYPE_SENC ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } } if ( ! senc && trak -> sample_encryption ) senc = trak -> sample_encryption ; if ( ! senc ) { if ( traf -> sample_encryption -> piff_type == 1 ) { senc = ( GF_SampleEncryptionBox * ) gf_isom_create_piff_psec_box ( 1 , 0x2 , 0 , 0 , NULL ) ; } else { senc = gf_isom_create_samp_enc_box ( 1 , 0x2 ) ; } if ( ! trak -> Media -> information -> sampleTable -> child_boxes ) trak -> Media -> information -> sampleTable -> child_boxes = gf_list_new ( ) ; trak -> sample_encryption = senc ; if ( ! trak -> child_boxes ) trak -> child_boxes = gf_list_new ( ) ; gf_list_add ( trak -> child_boxes , senc ) ; } } if ( gf_isom_cenc_has_saiz_saio_traf ( traf , scheme_type ) ) { u32 nb_saio ; u32 aux_info_type ; u64 offset ; GF_Err e ; Bool is_encrypted ; GF_SampleAuxiliaryInfoOffsetBox * saio = NULL ; GF_SampleAuxiliaryInfoSizeBox * saiz = NULL ; offset = nb_saio = 0 ; for ( i = 0 ; i < gf_list_count ( traf -> sai_offsets ) ; i ++ ) { saio = ( GF_SampleAuxiliaryInfoOffsetBox * ) gf_list_get ( traf -> sai_offsets , i ) ; aux_info_type = saio -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_offsets ) == 1 ) ) {  offset = saio -> offsets [ 0 ] + moof_offset ;  nb_saio = saio -> entry_count ; break ; } }  for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) {  saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ; aux_info_type = saiz -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_sizes ) == 1 ) ) { break ;  }  } if ( saiz && saio && senc ) { for ( i = 0 ; i < saiz -> sample_count ; i ++ ) { GF_CENCSampleAuxInfo * sai ; const u8 * key_info = NULL ; u32 key_info_size ; u64 cur_position ; if ( nb_saio != 1 ) offset = saio -> offsets [ i ] + moof_offset ; size = saiz -> default_sample_info_size ? saiz -> default_sample_info_size : saiz -> sample_info_size [ i ] ; cur_position = gf_bs_get_position ( trak -> moov -> mov -> movieFileMap -> bs ) ; gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , offset ) ; GF_SAFEALLOC ( sai , GF_CENCSampleAuxInfo ) ; if ( ! sai ) return GF_OUT_OF_MEM ; e = gf_isom_get_sample_cenc_info_internal ( trak , traf , senc , i + 1 , & is_encrypted , NULL , NULL , & key_info , & key_info_size ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>cenc<S2SV_blank>info<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d:<S2SV_blank>%s\\n"" , i + 1 , gf_error_to_string ( e ) ) ) ; return e ; } if ( is_encrypted ) { sai -> cenc_data_size = size ; sai -> cenc_data = gf_malloc ( sizeof ( u8 ) * size ) ; if ( ! sai -> cenc_data ) return GF_OUT_OF_MEM ; gf_bs_read_data ( trak -> moov -> mov -> movieFileMap -> bs , sai -> cenc_data , sai -> cenc_data_size ) ; } else { sai -> isNotProtected = 1 ; } if ( key_info ) { if ( ! key_info [ 0 ] ) { if ( size > key_info [ 3 ] ) senc -> flags = 0x00000002 ; } else { senc -> flags = 0x00000002 ; } } gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , cur_position ) ; gf_list_add ( senc -> samp_aux_info , sai ) ; e = gf_isom_cenc_merge_saiz_saio ( senc , trak -> Media -> information -> sampleTable , offset , size ) ; if ( e ) return e ; if ( nb_saio == 1 ) offset += size ; } } } else if ( traf -> sample_encryption ) { senc_Parse ( trak -> moov -> mov -> movieFileMap -> bs , trak , traf , traf -> sample_encryption ) ; trak -> sample_encryption -> AlgorithmID = traf -> sample_encryption -> AlgorithmID ; if ( ! trak -> sample_encryption -> IV_size ) trak -> sample_encryption -> IV_size = traf -> sample_encryption -> IV_size ; if ( ! trak -> sample_encryption -> samp_aux_info ) trak -> sample_encryption -> samp_aux_info = gf_list_new ( ) ; gf_list_transfer ( trak -> sample_encryption -> samp_aux_info , traf -> sample_encryption -> samp_aux_info ) ; if ( traf -> sample_encryption -> flags & 0x00000002 ) trak -> sample_encryption -> flags |= 0x00000002 ; } } return GF_OK ; }",saio = NULL ;},2706
764,"buggy line: cwe id:CWE-476context: GF_Err MergeTrack ( GF_TrackBox * trak , GF_TrackFragmentBox * traf , GF_MovieFragmentBox * moof_box , u64 moof_offset , s32 compressed_diff , u64 * cumulated_offset , Bool is_first_merge ) { u32 i , j , chunk_size , track_num ; u64 base_offset , data_offset , traf_duration ; u32 def_duration , DescIndex , def_size , def_flags ; u32 duration , size , flags , prev_trun_data_offset , sample_index ; u8 pad , sync ; u16 degr ; Bool first_samp_in_traf = GF_TRUE ; Bool store_traf_map = GF_FALSE ; u8 * moof_template = NULL ; u32 moof_template_size = 0 ; Bool is_seg_start = GF_FALSE ; u64 seg_start = 0 , sidx_start = 0 , sidx_end = 0 , frag_start = 0 , last_dts = 0 ; GF_TrackFragmentRunBox * trun ; GF_TrunEntry * ent ; # ifdef GF_ENABLE_CTRN GF_TrackFragmentBox * traf_ref = NULL ; # endif GF_Err stbl_AppendTime ( GF_SampleTableBox * stbl , u32 duration , u32 nb_pack ) ; GF_Err stbl_AppendSize ( GF_SampleTableBox * stbl , u32 size , u32 nb_pack ) ; GF_Err stbl_AppendChunk ( GF_SampleTableBox * stbl , u64 offset ) ; GF_Err stbl_AppendSampleToChunk ( GF_SampleTableBox * stbl , u32 DescIndex , u32 samplesInChunk ) ; GF_Err stbl_AppendCTSOffset ( GF_SampleTableBox * stbl , s32 CTSOffset ) ; GF_Err stbl_AppendRAP ( GF_SampleTableBox * stbl , u8 isRap ) ; GF_Err stbl_AppendPadding ( GF_SampleTableBox * stbl , u8 padding ) ; GF_Err stbl_AppendDegradation ( GF_SampleTableBox * stbl , u16 DegradationPriority ) ; if ( trak -> Header -> trackID != traf -> tfhd -> trackID ) return GF_OK ; if ( ! trak -> Media -> information -> sampleTable || ! trak -> Media -> information -> sampleTable -> SampleSize || ! trak -> Media -> information -> sampleTable -> TimeToSample || ! trak -> Media -> information -> sampleTable -> SampleToChunk || ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { return GF_ISOM_INVALID_FILE ; } if ( ! traf -> trex -> track ) traf -> trex -> track = trak ; DescIndex = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DESC ) ? traf -> tfhd -> sample_desc_index : traf -> trex -> def_sample_desc_index ; if ( ! DescIndex ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>0,<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" ) ) ; DescIndex = 1 ; } else if ( DescIndex > gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>sample<S2SV_blank>description(s),<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" , DescIndex , gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) ) ; DescIndex = 1 ; } # ifdef GF_ENABLE_CTRN if ( traf -> trex -> inherit_from_traf_id ) { u32 traf_count = gf_list_count ( moof_box -> TrackList ) ; for ( i = 0 ; i < traf_count ; i ++ ) { GF_TrackFragmentBox * atraf = gf_list_get ( moof_box -> TrackList , i ) ; if ( atraf -> tfhd && atraf -> tfhd -> trackID == traf -> trex -> inherit_from_traf_id ) { traf_ref = atraf ; break ; } } } # endif def_duration = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DUR ) ? traf -> tfhd -> def_sample_duration : traf -> trex -> def_sample_duration ; def_size = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_SIZE ) ? traf -> tfhd -> def_sample_size : traf -> trex -> def_sample_size ; def_flags = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_FLAGS ) ? traf -> tfhd -> def_sample_flags : traf -> trex -> def_sample_flags ; base_offset = moof_offset ; if ( traf -> tfhd -> flags & GF_ISOM_TRAF_BASE_OFFSET ) base_offset = traf -> tfhd -> base_data_offset ; else if ( ! ( traf -> tfhd -> flags & GF_ISOM_MOOF_BASE_OFFSET ) ) base_offset = * cumulated_offset ; chunk_size = 0 ; prev_trun_data_offset = 0 ; data_offset = 0 ; traf_duration = 0 ; if ( traf -> tfdt && is_first_merge ) { # ifndef GPAC_DISABLE_LOG if ( trak -> moov -> mov -> NextMoofNumber && trak -> present_in_scalable_segment && trak -> sample_count_at_seg_start && ( trak -> dts_at_seg_start != traf -> tfdt -> baseMediaDecodeTime ) ) { s32 drift = ( s32 ) ( ( s64 ) traf -> tfdt -> baseMediaDecodeTime - ( s64 ) trak -> dts_at_seg_start ) ; if ( drift < 0 ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Warning:<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>less<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>-<S2SV_blank>using<S2SV_blank>tfdt\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } else { GF_LOG ( GF_LOG_INFO , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>(last<S2SV_blank>sample<S2SV_blank>got<S2SV_blank>extended<S2SV_blank>in<S2SV_blank>duration)\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } } # endif trak -> dts_at_seg_start = traf -> tfdt -> baseMediaDecodeTime ; } else if ( traf -> tfxd ) { trak -> dts_at_seg_start = traf -> tfxd -> absolute_time_in_track_timescale ; } if ( traf -> tfxd ) { trak -> last_tfxd_value = traf -> tfxd -> absolute_time_in_track_timescale ; trak -> last_tfxd_value += traf -> tfxd -> fragment_duration_in_track_timescale ; } if ( traf -> tfrf ) { if ( trak -> tfrf ) gf_isom_box_del_parent ( & trak -> child_boxes , ( GF_Box * ) trak -> tfrf ) ; trak -> tfrf = traf -> tfrf ; gf_list_del_item ( traf -> child_boxes , traf -> tfrf ) ; gf_list_add ( trak -> child_boxes , trak -> tfrf ) ; } if ( trak -> moov -> mov -> signal_frag_bounds ) { store_traf_map = GF_TRUE ; if ( is_first_merge ) { GF_MovieFragmentBox * moof_clone = NULL ; gf_isom_box_freeze_order ( ( GF_Box * ) moof_box ) ; gf_isom_clone_box ( ( GF_Box * ) moof_box , ( GF_Box * * ) & moof_clone ) ; if ( moof_clone ) { GF_BitStream * bs ; for ( i = 0 ; i < gf_list_count ( moof_clone -> TrackList ) ; i ++ ) { GF_TrackFragmentBox * traf_clone = gf_list_get ( moof_clone -> TrackList , i ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> TrackRuns ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroups ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroupsDescription ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sub_samples ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_offsets ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_sizes ) ; if ( traf_clone -> sample_encryption ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sample_encryption ) ; traf_clone -> sample_encryption = NULL ; } if ( traf_clone -> sdtp ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sdtp ) ; traf_clone -> sdtp = NULL ; } } gf_isom_box_size ( ( GF_Box * ) moof_clone ) ; bs = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; if ( trak -> moov -> mov -> seg_styp ) { gf_isom_box_size ( trak -> moov -> mov -> seg_styp ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_styp , bs ) ; } if ( trak -> moov -> mov -> root_sidx ) { gf_isom_box_size ( ( GF_Box * ) trak -> moov -> mov -> root_sidx ) ; gf_isom_box_write ( ( GF_Box * ) trak -> moov -> mov -> root_sidx , bs ) ; } if ( trak -> moov -> mov -> seg_ssix ) { gf_isom_box_size ( trak -> moov -> mov -> seg_ssix ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_ssix , bs ) ; } gf_isom_box_write ( ( GF_Box * ) moof_clone , bs ) ; gf_isom_box_del ( ( GF_Box * ) moof_clone ) ; gf_bs_get_content ( bs , & moof_template , & moof_template_size ) ; gf_bs_del ( bs ) ; } } if ( trak -> moov -> mov -> seg_styp ) { is_seg_start = GF_TRUE ; seg_start = trak -> moov -> mov -> styp_start_offset ; } if ( trak -> moov -> mov -> root_sidx ) { is_seg_start = GF_TRUE ; sidx_start = trak -> moov -> mov -> sidx_start_offset ; sidx_end = trak -> moov -> mov -> sidx_end_offset ; if ( ! seg_start || ( sidx_start < seg_start ) ) seg_start = sidx_start ; } frag_start = trak -> moov -> mov -> current_top_box_start ; } else if ( trak -> moov -> mov -> store_traf_map ) { store_traf_map = GF_TRUE ; } sample_index = 0 ; i = 0 ; while ( ( trun = ( GF_TrackFragmentRunBox * ) gf_list_enum ( traf -> TrackRuns , & i ) ) ) { for ( j = 0 ; j < trun -> sample_count ; j ++ ) { GF_Err e ; s32 cts_offset = 0 ; if ( j < trun -> nb_samples ) { ent = & trun -> samples [ j ] ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>enough<S2SV_blank>trun<S2SV_blank>entries<S2SV_blank>(%d)<S2SV_blank>compared<S2SV_blank>to<S2SV_blank>sample<S2SV_blank>count<S2SV_blank>(%d)<S2SV_blank>in<S2SV_blank>run\\n"" , traf -> trex -> trackID , trun -> nb_samples , trun -> sample_count ) ) ; break ; } size = def_size ; duration = def_duration ; flags = def_flags ; cts_offset = ent -> CTS_Offset ; # ifdef GF_ENABLE_CTRN if ( trun -> use_ctrn ) { if ( ! j && ( trun -> ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE ) ) { if ( trun -> ctrn_first_dur ) duration = ent -> Duration ; if ( trun -> ctrn_first_size ) size = ent -> size ; if ( trun -> ctrn_first_ctts ) flags = ent -> flags ; } else { if ( trun -> ctrn_dur ) duration = ent -> Duration ; if ( trun -> ctrn_size ) size = ent -> size ; if ( trun -> ctrn_sample_flags ) flags = ent -> flags ; } if ( trun -> ctrn_flags & 0xF0 ) { GF_TrunEntry * ref_entry ; if ( ! traf_ref ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>to<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>reference<S2SV_blank>traf<S2SV_blank>not<S2SV_blank>found\\n"" , traf -> trex -> trackID , traf -> trex -> inherit_from_traf_id ) ) ; break ; } ref_entry = traf_get_sample_entry ( traf_ref , sample_index ) ; if ( ! ref_entry ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>but<S2SV_blank>sample<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>reference<S2SV_blank>traf\\n"" , traf -> trex -> trackID , sample_index + 1 ) ) ; break ; } if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR ) duration = ref_entry -> Duration ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE ) size = ref_entry -> size ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS ) flags = ref_entry -> flags ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO ) cts_offset = ref_entry -> CTS_Offset ; } } else # endif { if ( trun -> flags & GF_ISOM_TRUN_DURATION ) duration = ent -> Duration ; if ( trun -> flags & GF_ISOM_TRUN_SIZE ) size = ent -> size ; if ( trun -> flags & GF_ISOM_TRUN_FLAGS ) { flags = ent -> flags ; } else if ( ! j && ( trun -> flags & GF_ISOM_TRUN_FIRST_FLAG ) ) { flags = trun -> first_sample_flags ; } } sample_index ++ ; ent -> size = size ; ent -> Duration = duration ; ent -> flags = flags ; ent -> CTS_Offset = cts_offset ; last_dts += duration ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) { trak -> Media -> information -> sampleTable -> SampleSize = ( GF_SampleSizeBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSZ ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) return GF_OUT_OF_MEM ; } e = stbl_AppendSize ( trak -> Media -> information -> sampleTable , size , ent -> nb_pack ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) { trak -> Media -> information -> sampleTable -> TimeToSample = ( GF_TimeToSampleBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STTS ) ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) return GF_OUT_OF_MEM ; } e = stbl_AppendTime ( trak -> Media -> information -> sampleTable , duration , ent -> nb_pack ) ; if ( e ) return e ; if ( ! j ) { u64 final_offset ; data_offset = base_offset ; if ( trun -> flags & GF_ISOM_TRUN_DATA_OFFSET ) { data_offset += trun -> data_offset ; chunk_size = 0 ; prev_trun_data_offset = trun -> data_offset ; if ( trun -> data_offset >= 0 ) { data_offset -= compressed_diff ; prev_trun_data_offset -= compressed_diff ; } } else if ( prev_trun_data_offset ) { data_offset += prev_trun_data_offset + chunk_size ; } else { data_offset += chunk_size ; if ( ( i == 1 ) && ( trun -> data_offset >= 0 ) ) { data_offset -= compressed_diff ; } } final_offset = data_offset ; if ( trak -> moov -> compressed_diff ) { final_offset += trak -> moov -> compressed_diff ; } if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { trak -> Media -> information -> sampleTable -> ChunkOffset = gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STCO ) ; if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) return GF_OUT_OF_MEM ; } e = stbl_AppendChunk ( trak -> Media -> information -> sampleTable , final_offset ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) { trak -> Media -> information -> sampleTable -> SampleToChunk = ( GF_SampleToChunkBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSC ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) return GF_OUT_OF_MEM ; } e = stbl_AppendSampleToChunk ( trak -> Media -> information -> sampleTable , DescIndex , trun -> sample_count ) ; if ( e ) return e ; } chunk_size += size ; if ( store_traf_map && first_samp_in_traf ) { first_samp_in_traf = GF_FALSE ; e = stbl_AppendTrafMap ( trak -> Media -> information -> sampleTable , is_seg_start , seg_start , frag_start , moof_template , moof_template_size , sidx_start , sidx_end ) ; if ( e ) return e ; moof_template = NULL ; moof_template_size = 0 ; } if ( ent -> nb_pack > 1 ) { j += ent -> nb_pack - 1 ; traf_duration += ent -> nb_pack * duration ; continue ; } traf_duration += duration ; e = stbl_AppendCTSOffset ( trak -> Media -> information -> sampleTable , cts_offset ) ; if ( e ) return e ; sync = GF_ISOM_GET_FRAG_SYNC ( flags ) ; if ( trak -> Media -> information -> sampleTable -> no_sync_found && sync ) { trak -> Media -> information -> sampleTable -> no_sync_found = 0 ; } e = stbl_AppendRAP ( trak -> Media -> information -> sampleTable , sync ) ; if ( e ) return e ; pad = GF_ISOM_GET_FRAG_PAD ( flags ) ; if ( pad ) { e = stbl_AppendPadding ( trak -> Media -> information -> sampleTable , pad ) ; if ( e ) return e ; } degr = GF_ISOM_GET_FRAG_DEG ( flags ) ; if ( degr ) { e = stbl_AppendDegradation ( trak -> Media -> information -> sampleTable , degr ) ; if ( e ) return e ; } e = stbl_AppendDependencyType ( trak -> Media -> information -> sampleTable , GF_ISOM_GET_FRAG_LEAD ( flags ) , GF_ISOM_GET_FRAG_DEPENDS ( flags ) , GF_ISOM_GET_FRAG_DEPENDED ( flags ) , GF_ISOM_GET_FRAG_REDUNDANT ( flags ) ) ; if ( e ) return e ; } } if ( trak -> moov -> mov -> is_smooth && ! traf -> tfdt && ! traf -> tfxd ) { if ( is_first_merge ) trak -> dts_at_seg_start = trak -> dts_at_next_seg_start ; trak -> dts_at_next_seg_start += last_dts ; } if ( traf_duration && trak -> editBox && trak -> editBox -> editList ) { for ( i = 0 ; i < gf_list_count ( trak -> editBox -> editList -> entryList ) ; i ++ ) { GF_EdtsEntry * edts_e = gf_list_get ( trak -> editBox -> editList -> entryList , i ) ; if ( edts_e -> was_empty_dur ) { u64 extend_dur = traf_duration ; extend_dur *= trak -> moov -> mvhd -> timeScale ; extend_dur /= trak -> Media -> mediaHeader -> timeScale ; edts_e -> segmentDuration += extend_dur ; } else if ( ! edts_e -> segmentDuration ) { edts_e -> was_empty_dur = GF_TRUE ; if ( ( s64 ) traf_duration > edts_e -> mediaTime ) traf_duration -= edts_e -> mediaTime ; else traf_duration = 0 ; edts_e -> segmentDuration = traf_duration ; edts_e -> segmentDuration *= trak -> moov -> mvhd -> timeScale ; edts_e -> segmentDuration /= trak -> Media -> mediaHeader -> timeScale ; } } } * cumulated_offset = data_offset + chunk_size ; if ( traf -> sampleGroups ) { GF_List * groups ; GF_List * groupDescs ; Bool is_identical_sgpd = GF_TRUE ; u32 * new_idx = NULL , new_idx_count = 0 ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroups ) trak -> Media -> information -> sampleTable -> sampleGroups = gf_list_new ( ) ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) trak -> Media -> information -> sampleTable -> sampleGroupsDescription = gf_list_new ( ) ; groupDescs = trak -> Media -> information -> sampleTable -> sampleGroupsDescription ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroupsDescription ) ; i ++ ) { GF_SampleGroupDescriptionBox * new_sgdesc = NULL ; GF_SampleGroupDescriptionBox * sgdesc = gf_list_get ( traf -> sampleGroupsDescription , i ) ; for ( j = 0 ; j < gf_list_count ( groupDescs ) ; j ++ ) { new_sgdesc = gf_list_get ( groupDescs , j ) ; if ( new_sgdesc -> grouping_type == sgdesc -> grouping_type ) break ; new_sgdesc = NULL ; } if ( ! new_sgdesc ) { gf_list_add ( groupDescs , sgdesc ) ; gf_list_add ( trak -> Media -> information -> sampleTable -> child_boxes , sgdesc ) ; gf_list_rem ( traf -> sampleGroupsDescription , i ) ; gf_list_del_item ( traf -> child_boxes , sgdesc ) ; i -- ; } else { u32 count ; is_identical_sgpd = gf_isom_is_identical_sgpd ( new_sgdesc , sgdesc , 0 ) ; if ( is_identical_sgpd ) continue ; new_idx_count = gf_list_count ( sgdesc -> group_descriptions ) ; new_idx = ( u32 * ) gf_malloc ( new_idx_count * sizeof ( u32 ) ) ; if ( ! new_idx ) return GF_OUT_OF_MEM ; count = 0 ; while ( gf_list_count ( sgdesc -> group_descriptions ) ) { void * sgpd_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; Bool new_entry = GF_TRUE ; for ( j = 0 ; j < gf_list_count ( new_sgdesc -> group_descriptions ) ; j ++ ) { void * ptr = gf_list_get ( new_sgdesc -> group_descriptions , j ) ; if ( gf_isom_is_identical_sgpd ( sgpd_entry , ptr , new_sgdesc -> grouping_type ) ) { new_idx [ count ] = j + 1 ; count ++ ; new_entry = GF_FALSE ; gf_free ( sgpd_entry ) ; break ; } } if ( new_entry ) { gf_list_add ( new_sgdesc -> group_descriptions , sgpd_entry ) ; new_idx [ count ] = gf_list_count ( new_sgdesc -> group_descriptions ) ; count ++ ; } gf_list_rem ( sgdesc -> group_descriptions , 0 ) ; } } } groups = trak -> Media -> information -> sampleTable -> sampleGroups ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroups ) ; i ++ ) { GF_SampleGroupBox * stbl_group = NULL ; GF_SampleGroupBox * frag_group = gf_list_get ( traf -> sampleGroups , i ) ; for ( j = 0 ; j < gf_list_count ( groups ) ; j ++ ) { stbl_group = gf_list_get ( groups , j ) ; if ( ( frag_group -> grouping_type == stbl_group -> grouping_type ) && ( frag_group -> grouping_type_parameter == stbl_group -> grouping_type_parameter ) ) break ; stbl_group = NULL ; } if ( ! stbl_group ) { stbl_group = ( GF_SampleGroupBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_SBGP ) ; if ( ! stbl_group ) return GF_OUT_OF_MEM ; stbl_group -> grouping_type = frag_group -> grouping_type ; stbl_group -> grouping_type_parameter = frag_group -> grouping_type_parameter ; stbl_group -> version = frag_group -> version ; gf_list_add ( groups , stbl_group ) ; } if ( is_identical_sgpd ) { for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) frag_group -> sample_entries [ j ] . group_description_index &= 0x0FFFF ; if ( frag_group -> entry_count && stbl_group -> entry_count && ( frag_group -> sample_entries [ 0 ] . group_description_index == stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . group_description_index ) ) { stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . sample_count += frag_group -> sample_entries [ 0 ] . sample_count ; if ( frag_group -> entry_count > 1 ) { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count - 1 ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 1 ] , sizeof ( GF_SampleGroupEntry ) * ( frag_group -> entry_count - 1 ) ) ; stbl_group -> entry_count += frag_group -> entry_count - 1 ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) { u32 sgidx = frag_group -> sample_entries [ j ] . group_description_index ; if ( sgidx > 0x10000 ) { sgidx -= 0x10001 ; if ( sgidx >= new_idx_count ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>corrupted<S2SV_blank>sample<S2SV_blank>group<S2SV_blank>index<S2SV_blank>in<S2SV_blank>fragment<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>fragment\\n"" , sgidx , new_idx_count ) ) ; } else { frag_group -> sample_entries [ j ] . group_description_index = new_idx [ sgidx ] ; } } } memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } if ( new_idx ) gf_free ( new_idx ) ; } track_num = gf_isom_get_tracknum_from_id ( trak -> moov , trak -> Header -> trackID ) ; if ( gf_isom_is_cenc_media ( trak -> moov -> mov , track_num , DescIndex ) || traf -> sample_encryption ) { GF_SampleEncryptionBox * senc = NULL ; u32 scheme_type ; gf_isom_get_cenc_info ( trak -> moov -> mov , track_num , DescIndex , NULL , & scheme_type , NULL ) ; if ( traf -> sample_encryption ) { for ( i = 0 ; i < gf_list_count ( trak -> Media -> information -> sampleTable -> child_boxes ) ; i ++ ) { GF_Box * a = ( GF_Box * ) gf_list_get ( trak -> Media -> information -> sampleTable -> child_boxes , i ) ; if ( a -> type != traf -> sample_encryption -> type ) continue ; if ( ( a -> type == GF_ISOM_BOX_TYPE_UUID ) && ( ( ( GF_UUIDBox * ) a ) -> internal_4cc == GF_ISOM_BOX_UUID_PSEC ) ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } else if ( a -> type == GF_ISOM_BOX_TYPE_SENC ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } } if ( ! senc && trak -> sample_encryption ) senc = trak -> sample_encryption ; if ( ! senc ) { if ( traf -> sample_encryption -> piff_type == 1 ) { senc = ( GF_SampleEncryptionBox * ) gf_isom_create_piff_psec_box ( 1 , 0x2 , 0 , 0 , NULL ) ; } else { senc = gf_isom_create_samp_enc_box ( 1 , 0x2 ) ; } if ( ! trak -> Media -> information -> sampleTable -> child_boxes ) trak -> Media -> information -> sampleTable -> child_boxes = gf_list_new ( ) ; trak -> sample_encryption = senc ; if ( ! trak -> child_boxes ) trak -> child_boxes = gf_list_new ( ) ; gf_list_add ( trak -> child_boxes , senc ) ; } } if ( gf_isom_cenc_has_saiz_saio_traf ( traf , scheme_type ) ) { u32 nb_saio ; u32 aux_info_type ; u64 offset ; GF_Err e ; Bool is_encrypted ; GF_SampleAuxiliaryInfoOffsetBox * saio = NULL ; GF_SampleAuxiliaryInfoSizeBox * saiz = NULL ; offset = nb_saio = 0 ; for ( i = 0 ; i < gf_list_count ( traf -> sai_offsets ) ; i ++ ) { saio = ( GF_SampleAuxiliaryInfoOffsetBox * ) gf_list_get ( traf -> sai_offsets , i ) ; aux_info_type = saio -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_offsets ) == 1 ) ) {  offset = saio -> offsets [ 0 ] + moof_offset ;  nb_saio = saio -> entry_count ; break ; } }  for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) {  saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ; aux_info_type = saiz -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_sizes ) == 1 ) ) { break ;  }  } if ( saiz && saio && senc ) { for ( i = 0 ; i < saiz -> sample_count ; i ++ ) { GF_CENCSampleAuxInfo * sai ; const u8 * key_info = NULL ; u32 key_info_size ; u64 cur_position ; if ( nb_saio != 1 ) offset = saio -> offsets [ i ] + moof_offset ; size = saiz -> default_sample_info_size ? saiz -> default_sample_info_size : saiz -> sample_info_size [ i ] ; cur_position = gf_bs_get_position ( trak -> moov -> mov -> movieFileMap -> bs ) ; gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , offset ) ; GF_SAFEALLOC ( sai , GF_CENCSampleAuxInfo ) ; if ( ! sai ) return GF_OUT_OF_MEM ; e = gf_isom_get_sample_cenc_info_internal ( trak , traf , senc , i + 1 , & is_encrypted , NULL , NULL , & key_info , & key_info_size ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>cenc<S2SV_blank>info<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d:<S2SV_blank>%s\\n"" , i + 1 , gf_error_to_string ( e ) ) ) ; return e ; } if ( is_encrypted ) { sai -> cenc_data_size = size ; sai -> cenc_data = gf_malloc ( sizeof ( u8 ) * size ) ; if ( ! sai -> cenc_data ) return GF_OUT_OF_MEM ; gf_bs_read_data ( trak -> moov -> mov -> movieFileMap -> bs , sai -> cenc_data , sai -> cenc_data_size ) ; } else { sai -> isNotProtected = 1 ; } if ( key_info ) { if ( ! key_info [ 0 ] ) { if ( size > key_info [ 3 ] ) senc -> flags = 0x00000002 ; } else { senc -> flags = 0x00000002 ; } } gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , cur_position ) ; gf_list_add ( senc -> samp_aux_info , sai ) ; e = gf_isom_cenc_merge_saiz_saio ( senc , trak -> Media -> information -> sampleTable , offset , size ) ; if ( e ) return e ; if ( nb_saio == 1 ) offset += size ; } } } else if ( traf -> sample_encryption ) { senc_Parse ( trak -> moov -> mov -> movieFileMap -> bs , trak , traf , traf -> sample_encryption ) ; trak -> sample_encryption -> AlgorithmID = traf -> sample_encryption -> AlgorithmID ; if ( ! trak -> sample_encryption -> IV_size ) trak -> sample_encryption -> IV_size = traf -> sample_encryption -> IV_size ; if ( ! trak -> sample_encryption -> samp_aux_info ) trak -> sample_encryption -> samp_aux_info = gf_list_new ( ) ; gf_list_transfer ( trak -> sample_encryption -> samp_aux_info , traf -> sample_encryption -> samp_aux_info ) ; if ( traf -> sample_encryption -> flags & 0x00000002 ) trak -> sample_encryption -> flags |= 0x00000002 ; } } return GF_OK ; }",saiz = NULL ;,2706
765,"buggy line: offset = saio -> offsets [ 0 ] + moof_offset ;nb_saio = saio -> entry_count ;for ( i = 0 ;saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ;}}cwe id:CWE-476context: GF_Err MergeTrack ( GF_TrackBox * trak , GF_TrackFragmentBox * traf , GF_MovieFragmentBox * moof_box , u64 moof_offset , s32 compressed_diff , u64 * cumulated_offset , Bool is_first_merge ) { u32 i , j , chunk_size , track_num ; u64 base_offset , data_offset , traf_duration ; u32 def_duration , DescIndex , def_size , def_flags ; u32 duration , size , flags , prev_trun_data_offset , sample_index ; u8 pad , sync ; u16 degr ; Bool first_samp_in_traf = GF_TRUE ; Bool store_traf_map = GF_FALSE ; u8 * moof_template = NULL ; u32 moof_template_size = 0 ; Bool is_seg_start = GF_FALSE ; u64 seg_start = 0 , sidx_start = 0 , sidx_end = 0 , frag_start = 0 , last_dts = 0 ; GF_TrackFragmentRunBox * trun ; GF_TrunEntry * ent ; # ifdef GF_ENABLE_CTRN GF_TrackFragmentBox * traf_ref = NULL ; # endif GF_Err stbl_AppendTime ( GF_SampleTableBox * stbl , u32 duration , u32 nb_pack ) ; GF_Err stbl_AppendSize ( GF_SampleTableBox * stbl , u32 size , u32 nb_pack ) ; GF_Err stbl_AppendChunk ( GF_SampleTableBox * stbl , u64 offset ) ; GF_Err stbl_AppendSampleToChunk ( GF_SampleTableBox * stbl , u32 DescIndex , u32 samplesInChunk ) ; GF_Err stbl_AppendCTSOffset ( GF_SampleTableBox * stbl , s32 CTSOffset ) ; GF_Err stbl_AppendRAP ( GF_SampleTableBox * stbl , u8 isRap ) ; GF_Err stbl_AppendPadding ( GF_SampleTableBox * stbl , u8 padding ) ; GF_Err stbl_AppendDegradation ( GF_SampleTableBox * stbl , u16 DegradationPriority ) ; if ( trak -> Header -> trackID != traf -> tfhd -> trackID ) return GF_OK ; if ( ! trak -> Media -> information -> sampleTable || ! trak -> Media -> information -> sampleTable -> SampleSize || ! trak -> Media -> information -> sampleTable -> TimeToSample || ! trak -> Media -> information -> sampleTable -> SampleToChunk || ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { return GF_ISOM_INVALID_FILE ; } if ( ! traf -> trex -> track ) traf -> trex -> track = trak ; DescIndex = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DESC ) ? traf -> tfhd -> sample_desc_index : traf -> trex -> def_sample_desc_index ; if ( ! DescIndex ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>0,<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" ) ) ; DescIndex = 1 ; } else if ( DescIndex > gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>sample<S2SV_blank>description(s),<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" , DescIndex , gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) ) ; DescIndex = 1 ; } # ifdef GF_ENABLE_CTRN if ( traf -> trex -> inherit_from_traf_id ) { u32 traf_count = gf_list_count ( moof_box -> TrackList ) ; for ( i = 0 ; i < traf_count ; i ++ ) { GF_TrackFragmentBox * atraf = gf_list_get ( moof_box -> TrackList , i ) ; if ( atraf -> tfhd && atraf -> tfhd -> trackID == traf -> trex -> inherit_from_traf_id ) { traf_ref = atraf ; break ; } } } # endif def_duration = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DUR ) ? traf -> tfhd -> def_sample_duration : traf -> trex -> def_sample_duration ; def_size = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_SIZE ) ? traf -> tfhd -> def_sample_size : traf -> trex -> def_sample_size ; def_flags = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_FLAGS ) ? traf -> tfhd -> def_sample_flags : traf -> trex -> def_sample_flags ; base_offset = moof_offset ; if ( traf -> tfhd -> flags & GF_ISOM_TRAF_BASE_OFFSET ) base_offset = traf -> tfhd -> base_data_offset ; else if ( ! ( traf -> tfhd -> flags & GF_ISOM_MOOF_BASE_OFFSET ) ) base_offset = * cumulated_offset ; chunk_size = 0 ; prev_trun_data_offset = 0 ; data_offset = 0 ; traf_duration = 0 ; if ( traf -> tfdt && is_first_merge ) { # ifndef GPAC_DISABLE_LOG if ( trak -> moov -> mov -> NextMoofNumber && trak -> present_in_scalable_segment && trak -> sample_count_at_seg_start && ( trak -> dts_at_seg_start != traf -> tfdt -> baseMediaDecodeTime ) ) { s32 drift = ( s32 ) ( ( s64 ) traf -> tfdt -> baseMediaDecodeTime - ( s64 ) trak -> dts_at_seg_start ) ; if ( drift < 0 ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Warning:<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>less<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>-<S2SV_blank>using<S2SV_blank>tfdt\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } else { GF_LOG ( GF_LOG_INFO , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>(last<S2SV_blank>sample<S2SV_blank>got<S2SV_blank>extended<S2SV_blank>in<S2SV_blank>duration)\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } } # endif trak -> dts_at_seg_start = traf -> tfdt -> baseMediaDecodeTime ; } else if ( traf -> tfxd ) { trak -> dts_at_seg_start = traf -> tfxd -> absolute_time_in_track_timescale ; } if ( traf -> tfxd ) { trak -> last_tfxd_value = traf -> tfxd -> absolute_time_in_track_timescale ; trak -> last_tfxd_value += traf -> tfxd -> fragment_duration_in_track_timescale ; } if ( traf -> tfrf ) { if ( trak -> tfrf ) gf_isom_box_del_parent ( & trak -> child_boxes , ( GF_Box * ) trak -> tfrf ) ; trak -> tfrf = traf -> tfrf ; gf_list_del_item ( traf -> child_boxes , traf -> tfrf ) ; gf_list_add ( trak -> child_boxes , trak -> tfrf ) ; } if ( trak -> moov -> mov -> signal_frag_bounds ) { store_traf_map = GF_TRUE ; if ( is_first_merge ) { GF_MovieFragmentBox * moof_clone = NULL ; gf_isom_box_freeze_order ( ( GF_Box * ) moof_box ) ; gf_isom_clone_box ( ( GF_Box * ) moof_box , ( GF_Box * * ) & moof_clone ) ; if ( moof_clone ) { GF_BitStream * bs ; for ( i = 0 ; i < gf_list_count ( moof_clone -> TrackList ) ; i ++ ) { GF_TrackFragmentBox * traf_clone = gf_list_get ( moof_clone -> TrackList , i ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> TrackRuns ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroups ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroupsDescription ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sub_samples ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_offsets ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_sizes ) ; if ( traf_clone -> sample_encryption ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sample_encryption ) ; traf_clone -> sample_encryption = NULL ; } if ( traf_clone -> sdtp ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sdtp ) ; traf_clone -> sdtp = NULL ; } } gf_isom_box_size ( ( GF_Box * ) moof_clone ) ; bs = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; if ( trak -> moov -> mov -> seg_styp ) { gf_isom_box_size ( trak -> moov -> mov -> seg_styp ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_styp , bs ) ; } if ( trak -> moov -> mov -> root_sidx ) { gf_isom_box_size ( ( GF_Box * ) trak -> moov -> mov -> root_sidx ) ; gf_isom_box_write ( ( GF_Box * ) trak -> moov -> mov -> root_sidx , bs ) ; } if ( trak -> moov -> mov -> seg_ssix ) { gf_isom_box_size ( trak -> moov -> mov -> seg_ssix ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_ssix , bs ) ; } gf_isom_box_write ( ( GF_Box * ) moof_clone , bs ) ; gf_isom_box_del ( ( GF_Box * ) moof_clone ) ; gf_bs_get_content ( bs , & moof_template , & moof_template_size ) ; gf_bs_del ( bs ) ; } } if ( trak -> moov -> mov -> seg_styp ) { is_seg_start = GF_TRUE ; seg_start = trak -> moov -> mov -> styp_start_offset ; } if ( trak -> moov -> mov -> root_sidx ) { is_seg_start = GF_TRUE ; sidx_start = trak -> moov -> mov -> sidx_start_offset ; sidx_end = trak -> moov -> mov -> sidx_end_offset ; if ( ! seg_start || ( sidx_start < seg_start ) ) seg_start = sidx_start ; } frag_start = trak -> moov -> mov -> current_top_box_start ; } else if ( trak -> moov -> mov -> store_traf_map ) { store_traf_map = GF_TRUE ; } sample_index = 0 ; i = 0 ; while ( ( trun = ( GF_TrackFragmentRunBox * ) gf_list_enum ( traf -> TrackRuns , & i ) ) ) { for ( j = 0 ; j < trun -> sample_count ; j ++ ) { GF_Err e ; s32 cts_offset = 0 ; if ( j < trun -> nb_samples ) { ent = & trun -> samples [ j ] ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>enough<S2SV_blank>trun<S2SV_blank>entries<S2SV_blank>(%d)<S2SV_blank>compared<S2SV_blank>to<S2SV_blank>sample<S2SV_blank>count<S2SV_blank>(%d)<S2SV_blank>in<S2SV_blank>run\\n"" , traf -> trex -> trackID , trun -> nb_samples , trun -> sample_count ) ) ; break ; } size = def_size ; duration = def_duration ; flags = def_flags ; cts_offset = ent -> CTS_Offset ; # ifdef GF_ENABLE_CTRN if ( trun -> use_ctrn ) { if ( ! j && ( trun -> ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE ) ) { if ( trun -> ctrn_first_dur ) duration = ent -> Duration ; if ( trun -> ctrn_first_size ) size = ent -> size ; if ( trun -> ctrn_first_ctts ) flags = ent -> flags ; } else { if ( trun -> ctrn_dur ) duration = ent -> Duration ; if ( trun -> ctrn_size ) size = ent -> size ; if ( trun -> ctrn_sample_flags ) flags = ent -> flags ; } if ( trun -> ctrn_flags & 0xF0 ) { GF_TrunEntry * ref_entry ; if ( ! traf_ref ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>to<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>reference<S2SV_blank>traf<S2SV_blank>not<S2SV_blank>found\\n"" , traf -> trex -> trackID , traf -> trex -> inherit_from_traf_id ) ) ; break ; } ref_entry = traf_get_sample_entry ( traf_ref , sample_index ) ; if ( ! ref_entry ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>but<S2SV_blank>sample<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>reference<S2SV_blank>traf\\n"" , traf -> trex -> trackID , sample_index + 1 ) ) ; break ; } if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR ) duration = ref_entry -> Duration ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE ) size = ref_entry -> size ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS ) flags = ref_entry -> flags ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO ) cts_offset = ref_entry -> CTS_Offset ; } } else # endif { if ( trun -> flags & GF_ISOM_TRUN_DURATION ) duration = ent -> Duration ; if ( trun -> flags & GF_ISOM_TRUN_SIZE ) size = ent -> size ; if ( trun -> flags & GF_ISOM_TRUN_FLAGS ) { flags = ent -> flags ; } else if ( ! j && ( trun -> flags & GF_ISOM_TRUN_FIRST_FLAG ) ) { flags = trun -> first_sample_flags ; } } sample_index ++ ; ent -> size = size ; ent -> Duration = duration ; ent -> flags = flags ; ent -> CTS_Offset = cts_offset ; last_dts += duration ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) { trak -> Media -> information -> sampleTable -> SampleSize = ( GF_SampleSizeBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSZ ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) return GF_OUT_OF_MEM ; } e = stbl_AppendSize ( trak -> Media -> information -> sampleTable , size , ent -> nb_pack ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) { trak -> Media -> information -> sampleTable -> TimeToSample = ( GF_TimeToSampleBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STTS ) ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) return GF_OUT_OF_MEM ; } e = stbl_AppendTime ( trak -> Media -> information -> sampleTable , duration , ent -> nb_pack ) ; if ( e ) return e ; if ( ! j ) { u64 final_offset ; data_offset = base_offset ; if ( trun -> flags & GF_ISOM_TRUN_DATA_OFFSET ) { data_offset += trun -> data_offset ; chunk_size = 0 ; prev_trun_data_offset = trun -> data_offset ; if ( trun -> data_offset >= 0 ) { data_offset -= compressed_diff ; prev_trun_data_offset -= compressed_diff ; } } else if ( prev_trun_data_offset ) { data_offset += prev_trun_data_offset + chunk_size ; } else { data_offset += chunk_size ; if ( ( i == 1 ) && ( trun -> data_offset >= 0 ) ) { data_offset -= compressed_diff ; } } final_offset = data_offset ; if ( trak -> moov -> compressed_diff ) { final_offset += trak -> moov -> compressed_diff ; } if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { trak -> Media -> information -> sampleTable -> ChunkOffset = gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STCO ) ; if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) return GF_OUT_OF_MEM ; } e = stbl_AppendChunk ( trak -> Media -> information -> sampleTable , final_offset ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) { trak -> Media -> information -> sampleTable -> SampleToChunk = ( GF_SampleToChunkBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSC ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) return GF_OUT_OF_MEM ; } e = stbl_AppendSampleToChunk ( trak -> Media -> information -> sampleTable , DescIndex , trun -> sample_count ) ; if ( e ) return e ; } chunk_size += size ; if ( store_traf_map && first_samp_in_traf ) { first_samp_in_traf = GF_FALSE ; e = stbl_AppendTrafMap ( trak -> Media -> information -> sampleTable , is_seg_start , seg_start , frag_start , moof_template , moof_template_size , sidx_start , sidx_end ) ; if ( e ) return e ; moof_template = NULL ; moof_template_size = 0 ; } if ( ent -> nb_pack > 1 ) { j += ent -> nb_pack - 1 ; traf_duration += ent -> nb_pack * duration ; continue ; } traf_duration += duration ; e = stbl_AppendCTSOffset ( trak -> Media -> information -> sampleTable , cts_offset ) ; if ( e ) return e ; sync = GF_ISOM_GET_FRAG_SYNC ( flags ) ; if ( trak -> Media -> information -> sampleTable -> no_sync_found && sync ) { trak -> Media -> information -> sampleTable -> no_sync_found = 0 ; } e = stbl_AppendRAP ( trak -> Media -> information -> sampleTable , sync ) ; if ( e ) return e ; pad = GF_ISOM_GET_FRAG_PAD ( flags ) ; if ( pad ) { e = stbl_AppendPadding ( trak -> Media -> information -> sampleTable , pad ) ; if ( e ) return e ; } degr = GF_ISOM_GET_FRAG_DEG ( flags ) ; if ( degr ) { e = stbl_AppendDegradation ( trak -> Media -> information -> sampleTable , degr ) ; if ( e ) return e ; } e = stbl_AppendDependencyType ( trak -> Media -> information -> sampleTable , GF_ISOM_GET_FRAG_LEAD ( flags ) , GF_ISOM_GET_FRAG_DEPENDS ( flags ) , GF_ISOM_GET_FRAG_DEPENDED ( flags ) , GF_ISOM_GET_FRAG_REDUNDANT ( flags ) ) ; if ( e ) return e ; } } if ( trak -> moov -> mov -> is_smooth && ! traf -> tfdt && ! traf -> tfxd ) { if ( is_first_merge ) trak -> dts_at_seg_start = trak -> dts_at_next_seg_start ; trak -> dts_at_next_seg_start += last_dts ; } if ( traf_duration && trak -> editBox && trak -> editBox -> editList ) { for ( i = 0 ; i < gf_list_count ( trak -> editBox -> editList -> entryList ) ; i ++ ) { GF_EdtsEntry * edts_e = gf_list_get ( trak -> editBox -> editList -> entryList , i ) ; if ( edts_e -> was_empty_dur ) { u64 extend_dur = traf_duration ; extend_dur *= trak -> moov -> mvhd -> timeScale ; extend_dur /= trak -> Media -> mediaHeader -> timeScale ; edts_e -> segmentDuration += extend_dur ; } else if ( ! edts_e -> segmentDuration ) { edts_e -> was_empty_dur = GF_TRUE ; if ( ( s64 ) traf_duration > edts_e -> mediaTime ) traf_duration -= edts_e -> mediaTime ; else traf_duration = 0 ; edts_e -> segmentDuration = traf_duration ; edts_e -> segmentDuration *= trak -> moov -> mvhd -> timeScale ; edts_e -> segmentDuration /= trak -> Media -> mediaHeader -> timeScale ; } } } * cumulated_offset = data_offset + chunk_size ; if ( traf -> sampleGroups ) { GF_List * groups ; GF_List * groupDescs ; Bool is_identical_sgpd = GF_TRUE ; u32 * new_idx = NULL , new_idx_count = 0 ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroups ) trak -> Media -> information -> sampleTable -> sampleGroups = gf_list_new ( ) ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) trak -> Media -> information -> sampleTable -> sampleGroupsDescription = gf_list_new ( ) ; groupDescs = trak -> Media -> information -> sampleTable -> sampleGroupsDescription ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroupsDescription ) ; i ++ ) { GF_SampleGroupDescriptionBox * new_sgdesc = NULL ; GF_SampleGroupDescriptionBox * sgdesc = gf_list_get ( traf -> sampleGroupsDescription , i ) ; for ( j = 0 ; j < gf_list_count ( groupDescs ) ; j ++ ) { new_sgdesc = gf_list_get ( groupDescs , j ) ; if ( new_sgdesc -> grouping_type == sgdesc -> grouping_type ) break ; new_sgdesc = NULL ; } if ( ! new_sgdesc ) { gf_list_add ( groupDescs , sgdesc ) ; gf_list_add ( trak -> Media -> information -> sampleTable -> child_boxes , sgdesc ) ; gf_list_rem ( traf -> sampleGroupsDescription , i ) ; gf_list_del_item ( traf -> child_boxes , sgdesc ) ; i -- ; } else { u32 count ; is_identical_sgpd = gf_isom_is_identical_sgpd ( new_sgdesc , sgdesc , 0 ) ; if ( is_identical_sgpd ) continue ; new_idx_count = gf_list_count ( sgdesc -> group_descriptions ) ; new_idx = ( u32 * ) gf_malloc ( new_idx_count * sizeof ( u32 ) ) ; if ( ! new_idx ) return GF_OUT_OF_MEM ; count = 0 ; while ( gf_list_count ( sgdesc -> group_descriptions ) ) { void * sgpd_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; Bool new_entry = GF_TRUE ; for ( j = 0 ; j < gf_list_count ( new_sgdesc -> group_descriptions ) ; j ++ ) { void * ptr = gf_list_get ( new_sgdesc -> group_descriptions , j ) ; if ( gf_isom_is_identical_sgpd ( sgpd_entry , ptr , new_sgdesc -> grouping_type ) ) { new_idx [ count ] = j + 1 ; count ++ ; new_entry = GF_FALSE ; gf_free ( sgpd_entry ) ; break ; } } if ( new_entry ) { gf_list_add ( new_sgdesc -> group_descriptions , sgpd_entry ) ; new_idx [ count ] = gf_list_count ( new_sgdesc -> group_descriptions ) ; count ++ ; } gf_list_rem ( sgdesc -> group_descriptions , 0 ) ; } } } groups = trak -> Media -> information -> sampleTable -> sampleGroups ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroups ) ; i ++ ) { GF_SampleGroupBox * stbl_group = NULL ; GF_SampleGroupBox * frag_group = gf_list_get ( traf -> sampleGroups , i ) ; for ( j = 0 ; j < gf_list_count ( groups ) ; j ++ ) { stbl_group = gf_list_get ( groups , j ) ; if ( ( frag_group -> grouping_type == stbl_group -> grouping_type ) && ( frag_group -> grouping_type_parameter == stbl_group -> grouping_type_parameter ) ) break ; stbl_group = NULL ; } if ( ! stbl_group ) { stbl_group = ( GF_SampleGroupBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_SBGP ) ; if ( ! stbl_group ) return GF_OUT_OF_MEM ; stbl_group -> grouping_type = frag_group -> grouping_type ; stbl_group -> grouping_type_parameter = frag_group -> grouping_type_parameter ; stbl_group -> version = frag_group -> version ; gf_list_add ( groups , stbl_group ) ; } if ( is_identical_sgpd ) { for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) frag_group -> sample_entries [ j ] . group_description_index &= 0x0FFFF ; if ( frag_group -> entry_count && stbl_group -> entry_count && ( frag_group -> sample_entries [ 0 ] . group_description_index == stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . group_description_index ) ) { stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . sample_count += frag_group -> sample_entries [ 0 ] . sample_count ; if ( frag_group -> entry_count > 1 ) { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count - 1 ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 1 ] , sizeof ( GF_SampleGroupEntry ) * ( frag_group -> entry_count - 1 ) ) ; stbl_group -> entry_count += frag_group -> entry_count - 1 ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) { u32 sgidx = frag_group -> sample_entries [ j ] . group_description_index ; if ( sgidx > 0x10000 ) { sgidx -= 0x10001 ; if ( sgidx >= new_idx_count ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>corrupted<S2SV_blank>sample<S2SV_blank>group<S2SV_blank>index<S2SV_blank>in<S2SV_blank>fragment<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>fragment\\n"" , sgidx , new_idx_count ) ) ; } else { frag_group -> sample_entries [ j ] . group_description_index = new_idx [ sgidx ] ; } } } memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } if ( new_idx ) gf_free ( new_idx ) ; } track_num = gf_isom_get_tracknum_from_id ( trak -> moov , trak -> Header -> trackID ) ; if ( gf_isom_is_cenc_media ( trak -> moov -> mov , track_num , DescIndex ) || traf -> sample_encryption ) { GF_SampleEncryptionBox * senc = NULL ; u32 scheme_type ; gf_isom_get_cenc_info ( trak -> moov -> mov , track_num , DescIndex , NULL , & scheme_type , NULL ) ; if ( traf -> sample_encryption ) { for ( i = 0 ; i < gf_list_count ( trak -> Media -> information -> sampleTable -> child_boxes ) ; i ++ ) { GF_Box * a = ( GF_Box * ) gf_list_get ( trak -> Media -> information -> sampleTable -> child_boxes , i ) ; if ( a -> type != traf -> sample_encryption -> type ) continue ; if ( ( a -> type == GF_ISOM_BOX_TYPE_UUID ) && ( ( ( GF_UUIDBox * ) a ) -> internal_4cc == GF_ISOM_BOX_UUID_PSEC ) ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } else if ( a -> type == GF_ISOM_BOX_TYPE_SENC ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } } if ( ! senc && trak -> sample_encryption ) senc = trak -> sample_encryption ; if ( ! senc ) { if ( traf -> sample_encryption -> piff_type == 1 ) { senc = ( GF_SampleEncryptionBox * ) gf_isom_create_piff_psec_box ( 1 , 0x2 , 0 , 0 , NULL ) ; } else { senc = gf_isom_create_samp_enc_box ( 1 , 0x2 ) ; } if ( ! trak -> Media -> information -> sampleTable -> child_boxes ) trak -> Media -> information -> sampleTable -> child_boxes = gf_list_new ( ) ; trak -> sample_encryption = senc ; if ( ! trak -> child_boxes ) trak -> child_boxes = gf_list_new ( ) ; gf_list_add ( trak -> child_boxes , senc ) ; } } if ( gf_isom_cenc_has_saiz_saio_traf ( traf , scheme_type ) ) { u32 nb_saio ; u32 aux_info_type ; u64 offset ; GF_Err e ; Bool is_encrypted ; GF_SampleAuxiliaryInfoOffsetBox * saio = NULL ; GF_SampleAuxiliaryInfoSizeBox * saiz = NULL ; offset = nb_saio = 0 ; for ( i = 0 ; i < gf_list_count ( traf -> sai_offsets ) ; i ++ ) { saio = ( GF_SampleAuxiliaryInfoOffsetBox * ) gf_list_get ( traf -> sai_offsets , i ) ; aux_info_type = saio -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_offsets ) == 1 ) ) {  offset = saio -> offsets [ 0 ] + moof_offset ;  nb_saio = saio -> entry_count ; break ; } }  for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) {  saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ; aux_info_type = saiz -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_sizes ) == 1 ) ) { break ;  }  } if ( saiz && saio && senc ) { for ( i = 0 ; i < saiz -> sample_count ; i ++ ) { GF_CENCSampleAuxInfo * sai ; const u8 * key_info = NULL ; u32 key_info_size ; u64 cur_position ; if ( nb_saio != 1 ) offset = saio -> offsets [ i ] + moof_offset ; size = saiz -> default_sample_info_size ? saiz -> default_sample_info_size : saiz -> sample_info_size [ i ] ; cur_position = gf_bs_get_position ( trak -> moov -> mov -> movieFileMap -> bs ) ; gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , offset ) ; GF_SAFEALLOC ( sai , GF_CENCSampleAuxInfo ) ; if ( ! sai ) return GF_OUT_OF_MEM ; e = gf_isom_get_sample_cenc_info_internal ( trak , traf , senc , i + 1 , & is_encrypted , NULL , NULL , & key_info , & key_info_size ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>cenc<S2SV_blank>info<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d:<S2SV_blank>%s\\n"" , i + 1 , gf_error_to_string ( e ) ) ) ; return e ; } if ( is_encrypted ) { sai -> cenc_data_size = size ; sai -> cenc_data = gf_malloc ( sizeof ( u8 ) * size ) ; if ( ! sai -> cenc_data ) return GF_OUT_OF_MEM ; gf_bs_read_data ( trak -> moov -> mov -> movieFileMap -> bs , sai -> cenc_data , sai -> cenc_data_size ) ; } else { sai -> isNotProtected = 1 ; } if ( key_info ) { if ( ! key_info [ 0 ] ) { if ( size > key_info [ 3 ] ) senc -> flags = 0x00000002 ; } else { senc -> flags = 0x00000002 ; } } gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , cur_position ) ; gf_list_add ( senc -> samp_aux_info , sai ) ; e = gf_isom_cenc_merge_saiz_saio ( senc , trak -> Media -> information -> sampleTable , offset , size ) ; if ( e ) return e ; if ( nb_saio == 1 ) offset += size ; } } } else if ( traf -> sample_encryption ) { senc_Parse ( trak -> moov -> mov -> movieFileMap -> bs , trak , traf , traf -> sample_encryption ) ; trak -> sample_encryption -> AlgorithmID = traf -> sample_encryption -> AlgorithmID ; if ( ! trak -> sample_encryption -> IV_size ) trak -> sample_encryption -> IV_size = traf -> sample_encryption -> IV_size ; if ( ! trak -> sample_encryption -> samp_aux_info ) trak -> sample_encryption -> samp_aux_info = gf_list_new ( ) ; gf_list_transfer ( trak -> sample_encryption -> samp_aux_info , traf -> sample_encryption -> samp_aux_info ) ; if ( traf -> sample_encryption -> flags & 0x00000002 ) trak -> sample_encryption -> flags |= 0x00000002 ; } } return GF_OK ; }","offset = saio -> offsets [ 0 ] + moof_offset ;nb_saio = saio -> entry_count ;for ( i = 0 ;saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ;}}",2706
766,"buggy line: int target = rc -> av_per_frame_bandwidth ;if ( ( cm -> current_video_frame == 0 ) ||  ( cm -> frame_flags & FRAMEFLAGS_KEY ) ||  ( cpi -> oxcf . auto_key && ( rc -> frames_since_key %  cpi -> key_frame_frequency == 0 ) ) ) {cm -> frame_type = KEY_FRAME ;if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) {target = calc_iframe_target_size_one_pass_cbr ( cpi ) ;if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) {cwe id:CWE-119context: void vp9_rc_get_svc_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ;  int target = rc -> av_per_frame_bandwidth ;  if ( ( cm -> current_video_frame == 0 ) ||  ( cm -> frame_flags & FRAMEFLAGS_KEY ) ||  ( cpi -> oxcf . auto_key && ( rc -> frames_since_key %  cpi -> key_frame_frequency == 0 ) ) ) {  cm -> frame_type = KEY_FRAME ; rc -> source_alt_ref_active = 0 ;  if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) {  target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } } else { cm -> frame_type = INTER_FRAME ; if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; } } vp9_rc_set_frame_target ( cpi , target ) ; rc -> frames_till_gf_update_due = INT_MAX ; rc -> baseline_gf_interval = INT_MAX ; }","int target = rc -> avg_frame_bandwidth ;const int layer = LAYER_IDS_TO_IDX ( cpi -> svc . spatial_layer_id , cpi -> svc . temporal_layer_id , cpi -> svc . number_temporal_layers ) ;if ( ( cm -> current_video_frame == 0 ) || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) || ( cpi -> oxcf . auto_key && ( rc -> frames_since_key % cpi -> oxcf . key_freq == 0 ) ) ) {cm -> frame_type = KEY_FRAME ;if ( is_two_pass_svc ( cpi ) ) {cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ;cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ;}else if ( is_one_pass_cbr_svc ( cpi ) ) {cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ;reset_temporal_layer_to_zero ( cpi ) ;cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ;target = calc_iframe_target_size_one_pass_cbr ( cpi ) ;if ( is_two_pass_svc ( cpi ) ) {LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ;if ( cpi -> svc . spatial_layer_id == 0 ) {lc -> is_key_frame = 0 ;}else {lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ;if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ;}cpi -> ref_frame_flags &= ( ~ VP9_ALT_FLAG ) ;}else if ( is_one_pass_cbr_svc ( cpi ) ) {LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ;if ( cpi -> svc . spatial_layer_id == 0 ) {lc -> is_key_frame = 0 ;}else {lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ;}if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ;",2707
767,"buggy line: if ( used_address && used_address -> name_len == msg_sys -> msg_namelen &&   ! memcmp ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ) {memcpy ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ;cwe id:CWE-000context: static int __sys_sendmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned flags , struct used_address * used_address ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct sockaddr_storage address ; struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; unsigned char ctl [ sizeof ( struct cmsghdr ) + 20 ] __attribute__ ( ( aligned ( sizeof ( __kernel_size_t ) ) ) ) ; unsigned char * ctl_buf = ctl ; int err , ctl_len , iov_size , total_len ; err = - EFAULT ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) ) return - EFAULT ; err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ) ; if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ) ; if ( ! iov ) goto out ; } if ( MSG_CMSG_COMPAT & flags ) { err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; } else err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; err = - ENOBUFS ; if ( msg_sys -> msg_controllen > INT_MAX ) goto out_freeiov ; ctl_len = msg_sys -> msg_controllen ; if ( ( MSG_CMSG_COMPAT & flags ) && ctl_len ) { err = cmsghdr_from_user_compat_to_kern ( msg_sys , sock -> sk , ctl , sizeof ( ctl ) ) ; if ( err ) goto out_freeiov ; ctl_buf = msg_sys -> msg_control ; ctl_len = msg_sys -> msg_controllen ; } else if ( ctl_len ) { if ( ctl_len > sizeof ( ctl ) ) { ctl_buf = sock_kmalloc ( sock -> sk , ctl_len , GFP_KERNEL ) ; if ( ctl_buf == NULL ) goto out_freeiov ; } err = - EFAULT ; if ( copy_from_user ( ctl_buf , ( void __user __force * ) msg_sys -> msg_control , ctl_len ) ) goto out_freectl ; msg_sys -> msg_control = ctl_buf ; } msg_sys -> msg_flags = flags ; if ( sock -> file -> f_flags & O_NONBLOCK ) msg_sys -> msg_flags |= MSG_DONTWAIT ;  if ( used_address && used_address -> name_len == msg_sys -> msg_namelen &&   ! memcmp ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ) { err = sock_sendmsg_nosec ( sock , msg_sys , total_len ) ; goto out_freectl ; } err = sock_sendmsg ( sock , msg_sys , total_len ) ; if ( used_address && err >= 0 ) { used_address -> name_len = msg_sys -> msg_namelen ;  memcpy ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ; } out_freectl : if ( ctl_buf != ctl ) sock_kfree_s ( sock -> sk , ctl_buf , ctl_len ) ; out_freeiov : if ( iov != iovstack ) sock_kfree_s ( sock -> sk , iov , iov_size ) ; out : return err ; }","if ( used_address && msg_sys -> msg_name && used_address -> name_len == msg_sys -> msg_namelen && ! memcmp ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) ) {if ( msg_sys -> msg_name ) memcpy ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) ;",2708
768,"buggy line: static void read_mv_probs ( nmv_context * ctx , int allow_hp , vp9_reader * r ) {int i , j ;cwe id:CWE-119context:  static void read_mv_probs ( nmv_context * ctx , int allow_hp , vp9_reader * r ) {  int i , j ; update_mv_probs ( ctx -> joints , MV_JOINTS - 1 , r ) ; for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * const comp_ctx = & ctx -> comps [ i ] ; update_mv_probs ( & comp_ctx -> sign , 1 , r ) ; update_mv_probs ( comp_ctx -> classes , MV_CLASSES - 1 , r ) ; update_mv_probs ( comp_ctx -> class0 , CLASS0_SIZE - 1 , r ) ; update_mv_probs ( comp_ctx -> bits , MV_OFFSET_BITS , r ) ; } for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * const comp_ctx = & ctx -> comps [ i ] ; for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) update_mv_probs ( comp_ctx -> class0_fp [ j ] , MV_FP_SIZE - 1 , r ) ; update_mv_probs ( comp_ctx -> fp , 3 , r ) ; } if ( allow_hp ) { for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * const comp_ctx = & ctx -> comps [ i ] ; update_mv_probs ( & comp_ctx -> class0_hp , 1 , r ) ; update_mv_probs ( & comp_ctx -> hp , 1 , r ) ; } } }","static void read_mv_probs ( nmv_context * ctx , int allow_hp , vpx_reader * r ) {int i , j ;",2709
769,"buggy line: commonlen = COMPUTESIZE ( state . num , state . sumlen ) ;query = ( ltxtquery * ) palloc ( commonlen ) ;cwe id:CWE-189context: static ltxtquery * queryin ( char * buf ) { QPRS_STATE state ; int32 i ; ltxtquery * query ; int32 commonlen ; ITEM * ptr ; NODE * tmp ; int32 pos = 0 ; # ifdef BS_DEBUG char pbuf [ 16384 ] , * cur ; # endif state . buf = buf ; state . state = WAITOPERAND ; state . count = 0 ; state . num = 0 ; state . str = NULL ; state . sumlen = 0 ; state . lenop = 64 ; state . curop = state . op = ( char * ) palloc ( state . lenop ) ; * ( state . curop ) = '\\0' ; makepol ( & state ) ; if ( ! state . num ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Empty<S2SV_blank>query."" ) ) ) ;  commonlen = COMPUTESIZE ( state . num , state . sumlen ) ;  query = ( ltxtquery * ) palloc ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = state . num ; ptr = GETQUERY ( query ) ; for ( i = 0 ; i < state . num ; i ++ ) { ptr [ i ] . type = state . str -> type ; ptr [ i ] . val = state . str -> val ; ptr [ i ] . distance = state . str -> distance ; ptr [ i ] . length = state . str -> length ; ptr [ i ] . flag = state . str -> flag ; tmp = state . str -> next ; pfree ( state . str ) ; state . str = tmp ; } memcpy ( ( void * ) GETOPERAND ( query ) , ( void * ) state . op , state . sumlen ) ; pfree ( state . op ) ; pos = 0 ; findoprnd ( ptr , & pos ) ; return query ; }","if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;commonlen = COMPUTESIZE ( state . num , state . sumlen ) ;query = ( ltxtquery * ) palloc ( commonlen ) ;",2710
770,"buggy line: send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ;}cwe id:CWE-284context: static inline void uipc_wakeup_locked ( void ) { char sig_on = 1 ; BTIF_TRACE_EVENT ( ""UIPC<S2SV_blank>SEND<S2SV_blank>WAKE<S2SV_blank>UP"" ) ;  send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ;  }","TEMP_FAILURE_RETRY ( send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ;}",2711
771,"buggy line: case 'n' : * ( buf + insertpos ) = '\\\editpos ++ ;break ;case 't' : * ( buf + insertpos ) = '\\\\t' ;editpos ++ ;break ;case 'r' : * ( buf + insertpos ) = '\\\\r' ;editpos ++ ;break ;case '<S2SV_blank>' : * ( buf + insertpos ) = '<S2SV_blank>' ;editpos ++ ;break ;case '0' : if ( * ( buf + editpos + 2 ) == 'x' ) {if ( ( * ( buf + editpos + 3 ) == '0' && * ( buf + editpos + 4 ) == '0' ) ) {* ( buf + insertpos ) = * ( buf + editpos ) ;}else {* ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ;editpos += 4 ;cwe id:CWE-125context: void Util_handleEscapes ( char * buf ) { int editpos ; int insertpos ; ASSERT ( buf ) ; for ( editpos = insertpos = 0 ; * ( buf + editpos ) != '\\0' ; editpos ++ , insertpos ++ ) { if ( * ( buf + editpos ) == '\\\\' ) { switch ( * ( buf + editpos + 1 ) ) { case 'n' : * ( buf + insertpos ) = '\\n' ; editpos ++ ; break ; case 't' : * ( buf + insertpos ) = '\\t' ; editpos ++ ; break ; case 'r' : * ( buf + insertpos ) = '\\r' ; editpos ++ ; break ; case '<S2SV_blank>' : * ( buf + insertpos ) = '<S2SV_blank>' ; editpos ++ ; break ; case '0' : if ( * ( buf + editpos + 2 ) == 'x' ) { if ( ( * ( buf + editpos + 3 ) == '0' && * ( buf + editpos + 4 ) == '0' ) ) { * ( buf + insertpos ) = * ( buf + editpos ) ; } else {  * ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ;  editpos += 4 ; } } break ; case '\\\\' : * ( buf + insertpos ) = '\\\\' ; editpos ++ ; break ; default : * ( buf + insertpos ) = * ( buf + editpos ) ; } } else { * ( buf + insertpos ) = * ( buf + editpos ) ; } } * ( buf + insertpos ) = '\\0' ; }",case 'n' : * ( buf + insertpos ) = _x2c ( & buf [ editpos + 3 ] ) ;editpos += 4 ;,2712
772,"buggy line: switch ( sun_info . maptype )  {case RMT_EQUAL_RGB : {cwe id:CWE-119context: static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype )  {  case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {,2713
773,"buggy line: static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row ,  int mi_col , BLOCK_SIZE bsize , int * rate ,   int64_t * dist , int do_recon , int64_t best_rd ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;int i ;BLOCK_SIZE subsize ;int this_rate , sum_rate = 0 , best_rate = INT_MAX ;cwe id:CWE-119context:  static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row ,  int mi_col , BLOCK_SIZE bsize , int * rate ,   int64_t * dist , int do_recon , int64_t best_rd ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; const int ms = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; TOKENEXTRA * tp_orig = * tp ;  PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;  int i ;  BLOCK_SIZE subsize ;  int this_rate , sum_rate = 0 , best_rate = INT_MAX ; int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; int64_t sum_rd = 0 ; int do_split = bsize >= BLOCK_8X8 ; int do_rect = 1 ; const int force_horz_split = ( mi_row + ms >= cm -> mi_rows ) ; const int force_vert_split = ( mi_col + ms >= cm -> mi_cols ) ; const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; int partition_none_allowed = ! force_horz_split && ! force_vert_split ; int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ; int partition_vert_allowed = ! force_horz_split && xss <= yss && bsize >= BLOCK_8X8 ; ( void ) * tp_orig ;  if ( bsize < BLOCK_8X8 ) {  if ( x -> ab_index != 0 ) { * rate = 0 ; * dist = 0 ; return ; } } assert ( num_8x8_blocks_wide_lookup [ bsize ] == num_8x8_blocks_high_lookup [ bsize ] ) ;  x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;  if ( cpi -> sf . auto_min_max_partition_size ) {  partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size &&   bsize >= cpi -> sf . min_partition_size ) ;   partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_horz_split ) ;  partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_vert_split ) ;  do_split &= bsize > cpi -> sf . min_partition_size ;  } if ( cpi -> sf . use_square_partition_only ) { partition_horz_allowed &= force_horz_split ; partition_vert_allowed &= force_vert_split ; }  if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) )  do_split = 0 ; if ( partition_none_allowed ) {  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col ,   & this_rate , & this_dist , bsize ) ;  ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate != INT_MAX ) {  int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;   sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;  if ( sum_rd < best_rd ) {  int64_t stop_thresh = 4096 ;  int64_t stop_thresh_rd ; best_rate = this_rate ; best_dist = this_dist ; best_rd = sum_rd ; if ( bsize >= BLOCK_8X8 ) * ( get_sb_partitioning ( x , bsize ) ) = bsize ; stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;  stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;   if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) {  do_split = 0 ; do_rect = 0 ; } } }  if ( ! x -> in_active_map ) {  do_split = 0 ; do_rect = 0 ; } } store_pred_mv ( x , ctx ) ; sum_rd = 0 ; if ( do_split ) { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;  subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;  for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) {  const int x_idx = ( i & 1 ) * ms ; const int y_idx = ( i >> 1 ) * ms ; if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) continue ;  * get_sb_index ( x , subsize ) = i ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx ,   subsize , & this_rate , & this_dist , 0 ,  best_rd - sum_rd ) ; if ( this_rate == INT_MAX ) {  sum_rd = INT64_MAX ;  } else {  sum_rate += this_rate ;  sum_dist += this_dist ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; } } if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } else {  if ( cpi -> sf . less_rectangular_check )  do_rect &= ! partition_none_allowed ; } } if ( partition_horz_allowed && do_rect ) { subsize = get_subsize ( bsize , PARTITION_HORZ ) ;  * get_sb_index ( x , subsize ) = 0 ;  if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {  * get_sb_index ( x , subsize ) = 1 ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col ,   & this_rate , & this_dist , subsize ) ;  get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate == INT_MAX ) {   sum_rd = INT64_MAX ;  } else { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ;   sum_rate += this_rate ;  sum_dist += this_dist ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  } } if ( sum_rd < best_rd ) { best_rd = sum_rd ; best_rate = sum_rate ; best_dist = sum_dist ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } if ( partition_vert_allowed && do_rect ) { subsize = get_subsize ( bsize , PARTITION_VERT ) ;  * get_sb_index ( x , subsize ) = 0 ;  if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  if ( sum_rd < best_rd && mi_col + ms < cm -> mi_cols ) {  * get_sb_index ( x , subsize ) = 1 ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms ,   & this_rate , & this_dist , subsize ) ;  get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate == INT_MAX ) {   sum_rd = INT64_MAX ;  } else { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ;   sum_rate += this_rate ;  sum_dist += this_dist ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  } } if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } * rate = best_rate ; * dist = best_dist ;  if ( best_rate == INT_MAX )  return ; fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize ,  * ( get_sb_partitioning ( x , bsize ) ) ) ;   if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) {  int output_enabled = ( bsize == BLOCK_64X64 ) ;  if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {  vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled ,  best_rate ) ;  } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ; encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; }  if ( bsize == BLOCK_64X64 ) {  assert ( tp_orig < * tp ) ;  assert ( best_rate < INT_MAX ) ;   assert ( best_dist < INT64_MAX ) ;  } else { assert ( tp_orig == * tp ) ; } }","static void nonrd_pick_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , RD_COST * rd_cost , int do_recon , int64_t best_rd ) {VP9_COMMON * const cm = & cpi -> common ;TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = & pc_tree -> none ;int i ;BLOCK_SIZE subsize ;int this_rate , sum_rate = 0 , best_rate = INT_MAX ;",2714
774,"buggy line: if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index != 0 ) {* rate = 0 ;* dist = 0 ;return ;}}x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;if ( cpi -> sf . auto_min_max_partition_size ) {partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size &&   bsize >= cpi -> sf . min_partition_size ) ;partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_horz_split ) ;partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_vert_split ) ;do_split &= bsize > cpi -> sf . min_partition_size ;}if ( cpi -> sf . use_square_partition_only ) {if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) )  do_split = 0 ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col ,   & this_rate , & this_dist , bsize ) ;ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate != INT_MAX ) {int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;if ( sum_rd < best_rd ) {int64_t stop_thresh = 4096 ;int64_t stop_thresh_rd ;best_rate = this_rate ;best_dist = this_dist ;best_rd = sum_rd ;if ( bsize >= BLOCK_8X8 ) * ( get_sb_partitioning ( x , bsize ) ) = bsize ;stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) {do_split = 0 ;}if ( ! x -> in_active_map ) {do_split = 0 ;do_rect = 0 ;sum_rd = 0 ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;for ( i = 0 ;const int x_idx = ( i & 1 ) * ms ;* get_sb_index ( x , subsize ) = i ;load_pred_mv ( x , ctx ) ;nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx ,   subsize , & this_rate , & this_dist , 0 ,  best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;cwe id:CWE-119context:  static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row ,  int mi_col , BLOCK_SIZE bsize , int * rate ,   int64_t * dist , int do_recon , int64_t best_rd ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; const int ms = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; TOKENEXTRA * tp_orig = * tp ;  PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;  int i ;  BLOCK_SIZE subsize ;  int this_rate , sum_rate = 0 , best_rate = INT_MAX ; int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; int64_t sum_rd = 0 ; int do_split = bsize >= BLOCK_8X8 ; int do_rect = 1 ; const int force_horz_split = ( mi_row + ms >= cm -> mi_rows ) ; const int force_vert_split = ( mi_col + ms >= cm -> mi_cols ) ; const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; int partition_none_allowed = ! force_horz_split && ! force_vert_split ; int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ; int partition_vert_allowed = ! force_horz_split && xss <= yss && bsize >= BLOCK_8X8 ; ( void ) * tp_orig ;  if ( bsize < BLOCK_8X8 ) {  if ( x -> ab_index != 0 ) { * rate = 0 ; * dist = 0 ; return ; } } assert ( num_8x8_blocks_wide_lookup [ bsize ] == num_8x8_blocks_high_lookup [ bsize ] ) ;  x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;  if ( cpi -> sf . auto_min_max_partition_size ) {  partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size &&   bsize >= cpi -> sf . min_partition_size ) ;   partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_horz_split ) ;  partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_vert_split ) ;  do_split &= bsize > cpi -> sf . min_partition_size ;  } if ( cpi -> sf . use_square_partition_only ) { partition_horz_allowed &= force_horz_split ; partition_vert_allowed &= force_vert_split ; }  if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) )  do_split = 0 ; if ( partition_none_allowed ) {  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col ,   & this_rate , & this_dist , bsize ) ;  ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate != INT_MAX ) {  int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;   sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;  if ( sum_rd < best_rd ) {  int64_t stop_thresh = 4096 ;  int64_t stop_thresh_rd ; best_rate = this_rate ; best_dist = this_dist ; best_rd = sum_rd ; if ( bsize >= BLOCK_8X8 ) * ( get_sb_partitioning ( x , bsize ) ) = bsize ; stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;  stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;   if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) {  do_split = 0 ; do_rect = 0 ; } } }  if ( ! x -> in_active_map ) {  do_split = 0 ; do_rect = 0 ; } } store_pred_mv ( x , ctx ) ; sum_rd = 0 ; if ( do_split ) { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;  subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;  for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) {  const int x_idx = ( i & 1 ) * ms ; const int y_idx = ( i >> 1 ) * ms ; if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) continue ;  * get_sb_index ( x , subsize ) = i ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx ,   subsize , & this_rate , & this_dist , 0 ,  best_rd - sum_rd ) ; if ( this_rate == INT_MAX ) {  sum_rd = INT64_MAX ;  } else {  sum_rate += this_rate ;  sum_dist += this_dist ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; } } if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } else {  if ( cpi -> sf . less_rectangular_check )  do_rect &= ! partition_none_allowed ; } } if ( partition_horz_allowed && do_rect ) { subsize = get_subsize ( bsize , PARTITION_HORZ ) ;  * get_sb_index ( x , subsize ) = 0 ;  if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {  * get_sb_index ( x , subsize ) = 1 ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col ,   & this_rate , & this_dist , subsize ) ;  get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate == INT_MAX ) {   sum_rd = INT64_MAX ;  } else { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ;   sum_rate += this_rate ;  sum_dist += this_dist ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  } } if ( sum_rd < best_rd ) { best_rd = sum_rd ; best_rate = sum_rate ; best_dist = sum_dist ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } if ( partition_vert_allowed && do_rect ) { subsize = get_subsize ( bsize , PARTITION_VERT ) ;  * get_sb_index ( x , subsize ) = 0 ;  if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  if ( sum_rd < best_rd && mi_col + ms < cm -> mi_cols ) {  * get_sb_index ( x , subsize ) = 1 ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms ,   & this_rate , & this_dist , subsize ) ;  get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate == INT_MAX ) {   sum_rd = INT64_MAX ;  } else { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ;   sum_rate += this_rate ;  sum_dist += this_dist ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  } } if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } * rate = best_rate ; * dist = best_dist ;  if ( best_rate == INT_MAX )  return ; fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize ,  * ( get_sb_partitioning ( x , bsize ) ) ) ;   if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) {  int output_enabled = ( bsize == BLOCK_64X64 ) ;  if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {  vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled ,  best_rate ) ;  } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ; encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; }  if ( bsize == BLOCK_64X64 ) {  assert ( tp_orig < * tp ) ;  assert ( best_rate < INT_MAX ) ;   assert ( best_dist < INT64_MAX ) ;  } else { assert ( tp_orig == * tp ) ; } }","x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;if ( cpi -> sf . auto_min_max_partition_size ) {partition_none_allowed &= ( bsize <= x -> max_partition_size && bsize >= cpi -> sf . min_partition_size ) ;partition_horz_allowed &= ( ( bsize <= x -> max_partition_size && bsize > cpi -> sf . min_partition_size ) || force_horz_split ) ;partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && bsize > x -> min_partition_size ) || force_vert_split ) ;do_split &= bsize > x -> min_partition_size ;}if ( sf -> use_square_partition_only ) {ctx -> pred_pixel_ready = ! ( partition_vert_allowed || partition_horz_allowed || do_split ) ;nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx ) ;ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;ctx -> mbmi_ext = * x -> mbmi_ext ;ctx -> skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;ctx -> skip = x -> skip ;if ( this_rdc . rate != INT_MAX ) {int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_NONE ] ;this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ;if ( this_rdc . rdcost < best_rdc . rdcost ) {int64_t dist_breakout_thr = sf -> partition_search_breakout_dist_thr ;int64_t rate_breakout_thr = sf -> partition_search_breakout_rate_thr ;dist_breakout_thr >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;if ( ! x -> e_mbd . lossless && this_rdc . rate < rate_breakout_thr && this_rdc . dist < dist_breakout_thr ) {do_split = 0 ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;for ( i = 0 ;const int x_idx = ( i & 1 ) * ms ;* get_sb_index ( x , subsize ) = i ;load_pred_mv ( x , ctx ) ;nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , & this_rate , & this_dist , 0 , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;",2714
775,"buggy line: if ( cpi -> sf . less_rectangular_check )  do_rect &= ! partition_none_allowed ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col ,   & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ;sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}cwe id:CWE-119context:  static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row ,  int mi_col , BLOCK_SIZE bsize , int * rate ,   int64_t * dist , int do_recon , int64_t best_rd ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; const int ms = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; TOKENEXTRA * tp_orig = * tp ;  PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;  int i ;  BLOCK_SIZE subsize ;  int this_rate , sum_rate = 0 , best_rate = INT_MAX ; int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; int64_t sum_rd = 0 ; int do_split = bsize >= BLOCK_8X8 ; int do_rect = 1 ; const int force_horz_split = ( mi_row + ms >= cm -> mi_rows ) ; const int force_vert_split = ( mi_col + ms >= cm -> mi_cols ) ; const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; int partition_none_allowed = ! force_horz_split && ! force_vert_split ; int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ; int partition_vert_allowed = ! force_horz_split && xss <= yss && bsize >= BLOCK_8X8 ; ( void ) * tp_orig ;  if ( bsize < BLOCK_8X8 ) {  if ( x -> ab_index != 0 ) { * rate = 0 ; * dist = 0 ; return ; } } assert ( num_8x8_blocks_wide_lookup [ bsize ] == num_8x8_blocks_high_lookup [ bsize ] ) ;  x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;  if ( cpi -> sf . auto_min_max_partition_size ) {  partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size &&   bsize >= cpi -> sf . min_partition_size ) ;   partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_horz_split ) ;  partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_vert_split ) ;  do_split &= bsize > cpi -> sf . min_partition_size ;  } if ( cpi -> sf . use_square_partition_only ) { partition_horz_allowed &= force_horz_split ; partition_vert_allowed &= force_vert_split ; }  if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) )  do_split = 0 ; if ( partition_none_allowed ) {  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col ,   & this_rate , & this_dist , bsize ) ;  ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate != INT_MAX ) {  int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;   sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;  if ( sum_rd < best_rd ) {  int64_t stop_thresh = 4096 ;  int64_t stop_thresh_rd ; best_rate = this_rate ; best_dist = this_dist ; best_rd = sum_rd ; if ( bsize >= BLOCK_8X8 ) * ( get_sb_partitioning ( x , bsize ) ) = bsize ; stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;  stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;   if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) {  do_split = 0 ; do_rect = 0 ; } } }  if ( ! x -> in_active_map ) {  do_split = 0 ; do_rect = 0 ; } } store_pred_mv ( x , ctx ) ; sum_rd = 0 ; if ( do_split ) { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;  subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;  for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) {  const int x_idx = ( i & 1 ) * ms ; const int y_idx = ( i >> 1 ) * ms ; if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) continue ;  * get_sb_index ( x , subsize ) = i ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx ,   subsize , & this_rate , & this_dist , 0 ,  best_rd - sum_rd ) ; if ( this_rate == INT_MAX ) {  sum_rd = INT64_MAX ;  } else {  sum_rate += this_rate ;  sum_dist += this_dist ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; } } if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } else {  if ( cpi -> sf . less_rectangular_check )  do_rect &= ! partition_none_allowed ; } } if ( partition_horz_allowed && do_rect ) { subsize = get_subsize ( bsize , PARTITION_HORZ ) ;  * get_sb_index ( x , subsize ) = 0 ;  if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {  * get_sb_index ( x , subsize ) = 1 ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col ,   & this_rate , & this_dist , subsize ) ;  get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate == INT_MAX ) {   sum_rd = INT64_MAX ;  } else { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ;   sum_rate += this_rate ;  sum_dist += this_dist ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  } } if ( sum_rd < best_rd ) { best_rd = sum_rd ; best_rate = sum_rate ; best_dist = sum_dist ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } if ( partition_vert_allowed && do_rect ) { subsize = get_subsize ( bsize , PARTITION_VERT ) ;  * get_sb_index ( x , subsize ) = 0 ;  if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  if ( sum_rd < best_rd && mi_col + ms < cm -> mi_cols ) {  * get_sb_index ( x , subsize ) = 1 ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms ,   & this_rate , & this_dist , subsize ) ;  get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate == INT_MAX ) {   sum_rd = INT64_MAX ;  } else { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ;   sum_rate += this_rate ;  sum_dist += this_dist ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  } } if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } * rate = best_rate ; * dist = best_dist ;  if ( best_rate == INT_MAX )  return ; fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize ,  * ( get_sb_partitioning ( x , bsize ) ) ) ;   if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) {  int output_enabled = ( bsize == BLOCK_64X64 ) ;  if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {  vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled ,  best_rate ) ;  } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ; encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; }  if ( bsize == BLOCK_64X64 ) {  assert ( tp_orig < * tp ) ;  assert ( best_rate < INT_MAX ) ;   assert ( best_dist < INT64_MAX ) ;  } else { assert ( tp_orig == * tp ) ; } }","if ( cpi -> sf . less_rectangular_check ) do_rect &= ! partition_none_allowed ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col , & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ;sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}",2714
776,"buggy line: * get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd && mi_col + ms < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms ,   & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}else {int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ;sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}}if ( sum_rd < best_rd ) {best_rate = sum_rate ;best_dist = sum_dist ;best_rd = sum_rd ;* ( get_sb_partitioning ( x , bsize ) ) = subsize ;* rate = best_rate ;* dist = best_dist ;if ( best_rate == INT_MAX )  return ;fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize ,  * ( get_sb_partitioning ( x , bsize ) ) ) ;if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) {int output_enabled = ( bsize == BLOCK_64X64 ) ;if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled ,  best_rate ) ;}if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ;encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ;}if ( bsize == BLOCK_64X64 ) {assert ( tp_orig < * tp ) ;assert ( best_rate < INT_MAX ) ;assert ( best_dist < INT64_MAX ) ;}cwe id:CWE-119context:  static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row ,  int mi_col , BLOCK_SIZE bsize , int * rate ,   int64_t * dist , int do_recon , int64_t best_rd ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; const int ms = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; TOKENEXTRA * tp_orig = * tp ;  PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;  int i ;  BLOCK_SIZE subsize ;  int this_rate , sum_rate = 0 , best_rate = INT_MAX ; int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; int64_t sum_rd = 0 ; int do_split = bsize >= BLOCK_8X8 ; int do_rect = 1 ; const int force_horz_split = ( mi_row + ms >= cm -> mi_rows ) ; const int force_vert_split = ( mi_col + ms >= cm -> mi_cols ) ; const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; int partition_none_allowed = ! force_horz_split && ! force_vert_split ; int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ; int partition_vert_allowed = ! force_horz_split && xss <= yss && bsize >= BLOCK_8X8 ; ( void ) * tp_orig ;  if ( bsize < BLOCK_8X8 ) {  if ( x -> ab_index != 0 ) { * rate = 0 ; * dist = 0 ; return ; } } assert ( num_8x8_blocks_wide_lookup [ bsize ] == num_8x8_blocks_high_lookup [ bsize ] ) ;  x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;  if ( cpi -> sf . auto_min_max_partition_size ) {  partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size &&   bsize >= cpi -> sf . min_partition_size ) ;   partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_horz_split ) ;  partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_vert_split ) ;  do_split &= bsize > cpi -> sf . min_partition_size ;  } if ( cpi -> sf . use_square_partition_only ) { partition_horz_allowed &= force_horz_split ; partition_vert_allowed &= force_vert_split ; }  if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) )  do_split = 0 ; if ( partition_none_allowed ) {  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col ,   & this_rate , & this_dist , bsize ) ;  ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate != INT_MAX ) {  int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;   sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;  if ( sum_rd < best_rd ) {  int64_t stop_thresh = 4096 ;  int64_t stop_thresh_rd ; best_rate = this_rate ; best_dist = this_dist ; best_rd = sum_rd ; if ( bsize >= BLOCK_8X8 ) * ( get_sb_partitioning ( x , bsize ) ) = bsize ; stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;  stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;   if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) {  do_split = 0 ; do_rect = 0 ; } } }  if ( ! x -> in_active_map ) {  do_split = 0 ; do_rect = 0 ; } } store_pred_mv ( x , ctx ) ; sum_rd = 0 ; if ( do_split ) { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;  subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;  for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) {  const int x_idx = ( i & 1 ) * ms ; const int y_idx = ( i >> 1 ) * ms ; if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) continue ;  * get_sb_index ( x , subsize ) = i ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx ,   subsize , & this_rate , & this_dist , 0 ,  best_rd - sum_rd ) ; if ( this_rate == INT_MAX ) {  sum_rd = INT64_MAX ;  } else {  sum_rate += this_rate ;  sum_dist += this_dist ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; } } if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } else {  if ( cpi -> sf . less_rectangular_check )  do_rect &= ! partition_none_allowed ; } } if ( partition_horz_allowed && do_rect ) { subsize = get_subsize ( bsize , PARTITION_HORZ ) ;  * get_sb_index ( x , subsize ) = 0 ;  if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {  * get_sb_index ( x , subsize ) = 1 ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col ,   & this_rate , & this_dist , subsize ) ;  get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate == INT_MAX ) {   sum_rd = INT64_MAX ;  } else { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ;   sum_rate += this_rate ;  sum_dist += this_dist ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  } } if ( sum_rd < best_rd ) { best_rd = sum_rd ; best_rate = sum_rate ; best_dist = sum_dist ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } if ( partition_vert_allowed && do_rect ) { subsize = get_subsize ( bsize , PARTITION_VERT ) ;  * get_sb_index ( x , subsize ) = 0 ;  if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  if ( sum_rd < best_rd && mi_col + ms < cm -> mi_cols ) {  * get_sb_index ( x , subsize ) = 1 ;  load_pred_mv ( x , ctx ) ;  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms ,   & this_rate , & this_dist , subsize ) ;  get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( this_rate == INT_MAX ) {   sum_rd = INT64_MAX ;  } else { int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ;   sum_rate += this_rate ;  sum_dist += this_dist ;  sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;  } } if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } * rate = best_rate ; * dist = best_dist ;  if ( best_rate == INT_MAX )  return ; fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize ,  * ( get_sb_partitioning ( x , bsize ) ) ) ;   if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) {  int output_enabled = ( bsize == BLOCK_64X64 ) ;  if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {  vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled ,  best_rate ) ;  } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ; encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; }  if ( bsize == BLOCK_64X64 ) {  assert ( tp_orig < * tp ) ;  assert ( best_rate < INT_MAX ) ;   assert ( best_dist < INT64_MAX ) ;  } else { assert ( tp_orig == * tp ) ; } }","* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , td , tile_data , tp , mi_row , mi_col , output_enabled , bsize ) ;if ( bsize == BLOCK_64X64 && do_recon ) {assert ( tp_orig < * tp ) ;assert ( best_rate < INT_MAX ) ;assert ( best_dist < INT64_MAX ) ;",2714
777,"buggy line: static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , const char * ident , uint16_t afi ) {char ident_buffer [ 20 ] ;uint8_t prefix [ sizeof ( struct in6_addr ) ] ;u_int metric , status_byte , bit_length , byte_length , sublen , processed , subtlvtype , subtlvlen ;if ( ! ND_TTEST2 ( * tptr , 4 ) ) return ( 0 ) ;cwe id:CWE-125context: static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , const char * ident , uint16_t afi ) { char ident_buffer [ 20 ] ; uint8_t prefix [ sizeof ( struct in6_addr ) ] ; u_int metric , status_byte , bit_length , byte_length , sublen , processed , subtlvtype , subtlvlen ; if ( ! ND_TTEST2 ( * tptr , 4 ) ) return ( 0 ) ; metric = EXTRACT_32BITS ( tptr ) ; processed = 4 ; tptr += 4 ; if ( afi == AF_INET ) { if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ; status_byte = * ( tptr ++ ) ; bit_length = status_byte & 0x3f ; if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>prefix:<S2SV_blank>bad<S2SV_blank>bit<S2SV_blank>length<S2SV_blank>%u"" , ident , bit_length ) ) ; return ( 0 ) ; } processed ++ ; } else if ( afi == AF_INET6 ) {  if ( ! ND_TTEST2 ( * tptr , 1 ) )  return ( 0 ) ; status_byte = * ( tptr ++ ) ; bit_length = * ( tptr ++ ) ; if ( bit_length > 128 ) { ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>prefix:<S2SV_blank>bad<S2SV_blank>bit<S2SV_blank>length<S2SV_blank>%u"" , ident , bit_length ) ) ; return ( 0 ) ; } processed += 2 ; } else return ( 0 ) ; byte_length = ( bit_length + 7 ) / 8 ; if ( ! ND_TTEST2 ( * tptr , byte_length ) ) return ( 0 ) ; memset ( prefix , 0 , sizeof prefix ) ; memcpy ( prefix , tptr , byte_length ) ; tptr += byte_length ; processed += byte_length ; if ( afi == AF_INET ) ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u"" , ident , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; else if ( afi == AF_INET6 ) ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>prefix:<S2SV_blank>%s/%u"" , ident , ip6addr_string ( ndo , prefix ) , bit_length ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Distribution:<S2SV_blank>%s,<S2SV_blank>Metric:<S2SV_blank>%u"" , ISIS_MASK_TLV_EXTD_IP_UPDOWN ( status_byte ) ? ""down"" : ""up"" , metric ) ) ; if ( afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV ( status_byte ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>sub-TLVs<S2SV_blank>present"" ) ) ; else if ( afi == AF_INET6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>%s%s"" , ISIS_MASK_TLV_EXTD_IP6_IE ( status_byte ) ? ""External"" : ""Internal"" , ISIS_MASK_TLV_EXTD_IP6_SUBTLV ( status_byte ) ? "",<S2SV_blank>sub-TLVs<S2SV_blank>present"" : """" ) ) ; if ( ( afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV ( status_byte ) ) || ( afi == AF_INET6 && ISIS_MASK_TLV_EXTD_IP6_SUBTLV ( status_byte ) ) ) { if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ; sublen = * ( tptr ++ ) ; processed += sublen + 1 ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , sublen ) ) ; while ( sublen > 0 ) { if ( ! ND_TTEST2 ( * tptr , 2 ) ) return ( 0 ) ; subtlvtype = * ( tptr ++ ) ; subtlvlen = * ( tptr ++ ) ; snprintf ( ident_buffer , sizeof ( ident_buffer ) , ""%s<S2SV_blank><S2SV_blank>"" , ident ) ; if ( ! isis_print_ip_reach_subtlv ( ndo , tptr , subtlvtype , subtlvlen , ident_buffer ) ) return ( 0 ) ; tptr += subtlvlen ; sublen -= ( subtlvlen + 2 ) ; } } return ( processed ) ; }","static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , 2 ) ) return ( 0 ) ;",2715
778,"buggy line: if ( ! ND_TTEST2 ( * tptr , 1 ) )  return ( 0 ) ;cwe id:CWE-125context: static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , const char * ident , uint16_t afi ) { char ident_buffer [ 20 ] ; uint8_t prefix [ sizeof ( struct in6_addr ) ] ; u_int metric , status_byte , bit_length , byte_length , sublen , processed , subtlvtype , subtlvlen ; if ( ! ND_TTEST2 ( * tptr , 4 ) ) return ( 0 ) ; metric = EXTRACT_32BITS ( tptr ) ; processed = 4 ; tptr += 4 ; if ( afi == AF_INET ) { if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ; status_byte = * ( tptr ++ ) ; bit_length = status_byte & 0x3f ; if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>prefix:<S2SV_blank>bad<S2SV_blank>bit<S2SV_blank>length<S2SV_blank>%u"" , ident , bit_length ) ) ; return ( 0 ) ; } processed ++ ; } else if ( afi == AF_INET6 ) {  if ( ! ND_TTEST2 ( * tptr , 1 ) )  return ( 0 ) ; status_byte = * ( tptr ++ ) ; bit_length = * ( tptr ++ ) ; if ( bit_length > 128 ) { ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>prefix:<S2SV_blank>bad<S2SV_blank>bit<S2SV_blank>length<S2SV_blank>%u"" , ident , bit_length ) ) ; return ( 0 ) ; } processed += 2 ; } else return ( 0 ) ; byte_length = ( bit_length + 7 ) / 8 ; if ( ! ND_TTEST2 ( * tptr , byte_length ) ) return ( 0 ) ; memset ( prefix , 0 , sizeof prefix ) ; memcpy ( prefix , tptr , byte_length ) ; tptr += byte_length ; processed += byte_length ; if ( afi == AF_INET ) ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u"" , ident , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; else if ( afi == AF_INET6 ) ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>prefix:<S2SV_blank>%s/%u"" , ident , ip6addr_string ( ndo , prefix ) , bit_length ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Distribution:<S2SV_blank>%s,<S2SV_blank>Metric:<S2SV_blank>%u"" , ISIS_MASK_TLV_EXTD_IP_UPDOWN ( status_byte ) ? ""down"" : ""up"" , metric ) ) ; if ( afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV ( status_byte ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>sub-TLVs<S2SV_blank>present"" ) ) ; else if ( afi == AF_INET6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>%s%s"" , ISIS_MASK_TLV_EXTD_IP6_IE ( status_byte ) ? ""External"" : ""Internal"" , ISIS_MASK_TLV_EXTD_IP6_SUBTLV ( status_byte ) ? "",<S2SV_blank>sub-TLVs<S2SV_blank>present"" : """" ) ) ; if ( ( afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV ( status_byte ) ) || ( afi == AF_INET6 && ISIS_MASK_TLV_EXTD_IP6_SUBTLV ( status_byte ) ) ) { if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ; sublen = * ( tptr ++ ) ; processed += sublen + 1 ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , sublen ) ) ; while ( sublen > 0 ) { if ( ! ND_TTEST2 ( * tptr , 2 ) ) return ( 0 ) ; subtlvtype = * ( tptr ++ ) ; subtlvlen = * ( tptr ++ ) ; snprintf ( ident_buffer , sizeof ( ident_buffer ) , ""%s<S2SV_blank><S2SV_blank>"" , ident ) ; if ( ! isis_print_ip_reach_subtlv ( ndo , tptr , subtlvtype , subtlvlen , ident_buffer ) ) return ( 0 ) ; tptr += subtlvlen ; sublen -= ( subtlvlen + 2 ) ; } } return ( processed ) ; }","if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ;",2715
779,"buggy line: static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf )  {cwe id:CWE-119context:  static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf )  { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; int buflen = 0 ; switch ( req -> cmd . buf [ 0 ] ) { case TEST_UNIT_READY : if ( s -> tray_open || ! bdrv_is_inserted ( s -> bs ) ) goto not_ready ; break ; case INQUIRY : buflen = scsi_disk_emulate_inquiry ( req , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case MODE_SENSE : case MODE_SENSE_10 : buflen = scsi_disk_emulate_mode_sense ( r , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case READ_TOC : buflen = scsi_disk_emulate_read_toc ( req , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case RESERVE : if ( req -> cmd . buf [ 1 ] & 1 ) goto illegal_request ; break ; case RESERVE_10 : if ( req -> cmd . buf [ 1 ] & 3 ) goto illegal_request ; break ; case RELEASE : if ( req -> cmd . buf [ 1 ] & 1 ) goto illegal_request ; break ; case RELEASE_10 : if ( req -> cmd . buf [ 1 ] & 3 ) goto illegal_request ; break ; case START_STOP : if ( scsi_disk_emulate_start_stop ( r ) < 0 ) { return - 1 ; } break ; case ALLOW_MEDIUM_REMOVAL : s -> tray_locked = req -> cmd . buf [ 4 ] & 1 ; bdrv_lock_medium ( s -> bs , req -> cmd . buf [ 4 ] & 1 ) ; break ; case READ_CAPACITY_10 : memset ( outbuf , 0 , 8 ) ; bdrv_get_geometry ( s -> bs , & nb_sectors ) ; if ( ! nb_sectors ) goto not_ready ; nb_sectors /= s -> cluster_size ; nb_sectors -- ; s -> max_lba = nb_sectors ; if ( nb_sectors > UINT32_MAX ) nb_sectors = UINT32_MAX ; outbuf [ 0 ] = ( nb_sectors >> 24 ) & 0xff ; outbuf [ 1 ] = ( nb_sectors >> 16 ) & 0xff ; outbuf [ 2 ] = ( nb_sectors >> 8 ) & 0xff ; outbuf [ 3 ] = nb_sectors & 0xff ; outbuf [ 4 ] = 0 ; outbuf [ 5 ] = 0 ; outbuf [ 6 ] = s -> cluster_size * 2 ; outbuf [ 7 ] = 0 ; buflen = 8 ; break ; case GET_CONFIGURATION : memset ( outbuf , 0 , 8 ) ; outbuf [ 7 ] = 8 ; buflen = 8 ; break ; case SERVICE_ACTION_IN_16 : if ( ( req -> cmd . buf [ 1 ] & 31 ) == SAI_READ_CAPACITY_16 ) { DPRINTF ( ""SAI<S2SV_blank>READ<S2SV_blank>CAPACITY(16)\\n"" ) ; memset ( outbuf , 0 , req -> cmd . xfer ) ; bdrv_get_geometry ( s -> bs , & nb_sectors ) ; if ( ! nb_sectors ) goto not_ready ; nb_sectors /= s -> cluster_size ; nb_sectors -- ; s -> max_lba = nb_sectors ; outbuf [ 0 ] = ( nb_sectors >> 56 ) & 0xff ; outbuf [ 1 ] = ( nb_sectors >> 48 ) & 0xff ; outbuf [ 2 ] = ( nb_sectors >> 40 ) & 0xff ; outbuf [ 3 ] = ( nb_sectors >> 32 ) & 0xff ; outbuf [ 4 ] = ( nb_sectors >> 24 ) & 0xff ; outbuf [ 5 ] = ( nb_sectors >> 16 ) & 0xff ; outbuf [ 6 ] = ( nb_sectors >> 8 ) & 0xff ; outbuf [ 7 ] = nb_sectors & 0xff ; outbuf [ 8 ] = 0 ; outbuf [ 9 ] = 0 ; outbuf [ 10 ] = s -> cluster_size * 2 ; outbuf [ 11 ] = 0 ; outbuf [ 12 ] = 0 ; outbuf [ 13 ] = get_physical_block_exp ( & s -> qdev . conf ) ; if ( s -> qdev . conf . discard_granularity ) { outbuf [ 14 ] = 0x80 ; } buflen = req -> cmd . xfer ; break ; } DPRINTF ( ""Unsupported<S2SV_blank>Service<S2SV_blank>Action<S2SV_blank>In\\n"" ) ; goto illegal_request ; case VERIFY_10 : break ; default : scsi_check_condition ( r , SENSE_CODE ( INVALID_OPCODE ) ) ; return - 1 ; } return buflen ; not_ready : if ( s -> tray_open || ! bdrv_is_inserted ( s -> bs ) ) { scsi_check_condition ( r , SENSE_CODE ( NO_MEDIUM ) ) ; } else { scsi_check_condition ( r , SENSE_CODE ( LUN_NOT_READY ) ) ; } return - 1 ; illegal_request : if ( r -> req . status == - 1 ) { scsi_check_condition ( r , SENSE_CODE ( INVALID_FIELD ) ) ; } return - 1 ; }","static int scsi_disk_emulate_command ( SCSIDiskReq * r ) {uint8_t * outbuf ;if ( ! r -> iov . iov_base ) {if ( req -> cmd . xfer > 65536 ) {goto illegal_request ;}r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ;r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ;}outbuf = r -> iov . iov_base ;",2716
780,buggy line: while ( FLASH -> SR & ( 1 << 16 ) ) ;flash_unlock ( ) ;if ( FLASH -> CR & ( 1 << 30 ) ) {FLASH -> OPTKEYR = 0x08192A3B ;FLASH -> OPTKEYR = 0x4C5D6E7F ;FLASH -> OPTR = val ;FLASH -> CR |= ( 1 << 17 ) ;while ( FLASH -> SR & ( 1 << 16 ) ) ;flash_lock ( ) ;__enable_irq ( ) ;}cwe id:CWE-326context: void flash_option_bytes_init ( int boot_from_dfu ) { uint32_t val = 0xfffff8aa ; if ( boot_from_dfu ) { val &= ~ ( 1 << 27 ) ; } else { if ( solo_is_locked ( ) ) { val = 0xfffff8cc ; } } val &= ~ ( 1 << 26 ) ; val &= ~ ( 1 << 25 ) ; val &= ~ ( 1 << 24 ) ; if ( FLASH -> OPTR == val ) { return ; } __disable_irq ( ) ; while ( FLASH -> SR & ( 1 << 16 ) ) ; flash_unlock ( ) ; if ( FLASH -> CR & ( 1 << 30 ) ) { FLASH -> OPTKEYR = 0x08192A3B ; FLASH -> OPTKEYR = 0x4C5D6E7F ; } FLASH -> OPTR = val ; FLASH -> CR |= ( 1 << 17 ) ; while ( FLASH -> SR & ( 1 << 16 ) ) ; flash_lock ( ) ;  __enable_irq ( ) ;  },FLASH -> CR |= FLASH_CR_OBL_LAUNCH ;while ( true ) ;,2717
781,"buggy line: size_t val_len ;size_t len , cert_len ;cwe id:CWE-119context: static int cac_read_binary ( sc_card_t * card , unsigned int idx , unsigned char * buf , size_t count , unsigned long flags ) { cac_private_data_t * priv = CAC_DATA ( card ) ; int r = 0 ; u8 * val = NULL ; u8 * cert_ptr ;  size_t val_len ;  size_t len , cert_len ; u8 cert_type ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -> cached ) { sc_log ( card -> ctx , ""returning<S2SV_blank>cached<S2SV_blank>value<S2SV_blank>idx=%d<S2SV_blank>count=%"" SC_FORMAT_LEN_SIZE_T ""u"" , idx , count ) ; if ( idx > priv -> cache_buf_len ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_FILE_END_REACHED ) ; } len = MIN ( count , priv -> cache_buf_len - idx ) ; memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; LOG_FUNC_RETURN ( card -> ctx , len ) ; } sc_log ( card -> ctx , ""clearing<S2SV_blank>cache<S2SV_blank>idx=%d<S2SV_blank>count=%"" SC_FORMAT_LEN_SIZE_T ""u"" , idx , count ) ; free ( priv -> cache_buf ) ; priv -> cache_buf = NULL ; priv -> cache_buf_len = 0 ; r = cac_cac1_get_certificate ( card , & val , & val_len ) ; if ( r < 0 ) goto done ; if ( val_len < 1 ) { r = SC_ERROR_INVALID_DATA ; goto done ; } cert_type = val [ 0 ] ; cert_ptr = val + 1 ; cert_len = val_len - 1 ; if ( ( cert_type & 0x3 ) == 1 ) { # ifdef ENABLE_ZLIB r = sc_decompress_alloc ( & priv -> cache_buf , & priv -> cache_buf_len , cert_ptr , cert_len , COMPRESSION_AUTO ) ; # else sc_log ( card -> ctx , ""CAC<S2SV_blank>compression<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>no<S2SV_blank>zlib"" ) ; r = SC_ERROR_NOT_SUPPORTED ; # endif if ( r ) goto done ; } else if ( cert_len > 0 ) { priv -> cache_buf = malloc ( cert_len ) ; if ( priv -> cache_buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; goto done ; } priv -> cache_buf_len = cert_len ; memcpy ( priv -> cache_buf , cert_ptr , cert_len ) ; } priv -> cached = 1 ; len = MIN ( count , priv -> cache_buf_len - idx ) ; if ( len && priv -> cache_buf ) memcpy ( buf , & priv -> cache_buf [ idx ] , len ) ; r = len ; done : if ( val ) free ( val ) ; LOG_FUNC_RETURN ( card -> ctx , r ) ; }","size_t val_len = 0 ;size_t len , cert_len ;",2718
782,"buggy line: pipe_buf_get ( ipipe , ibuf ) ;obuf = opipe -> bufs + nbuf ;cwe id:CWE-416context: static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ;  pipe_buf_get ( ipipe , ibuf ) ;  obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}obuf = opipe -> bufs + nbuf ;",2719
783,"buggy line: addr -> sap_family = AF_ATMPVC ;addr -> sap_addr . itf = vcc -> dev -> number ;cwe id:CWE-200context: static int pvc_getname ( struct socket * sock , struct sockaddr * sockaddr , int * sockaddr_len , int peer ) { struct sockaddr_atmpvc * addr ; struct atm_vcc * vcc = ATM_SD ( sock ) ; if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) return - ENOTCONN ; * sockaddr_len = sizeof ( struct sockaddr_atmpvc ) ; addr = ( struct sockaddr_atmpvc * ) sockaddr ;  addr -> sap_family = AF_ATMPVC ;  addr -> sap_addr . itf = vcc -> dev -> number ; addr -> sap_addr . vpi = vcc -> vpi ; addr -> sap_addr . vci = vcc -> vci ; return 0 ; }","memset ( addr , 0 , sizeof ( * addr ) ) ;addr -> sap_family = AF_ATMPVC ;addr -> sap_addr . itf = vcc -> dev -> number ;",2720
784,"buggy line: else  rsprintf ( ""Content-Type:<S2SV_blank>%s\\\\r\\\cwe id:CWE-79context: void send_file_direct ( char * file_name ) { int fh , i , length , delta ; char str [ MAX_PATH_LENGTH ] , dir [ MAX_PATH_LENGTH ] , charset [ 80 ] ; getcwd ( dir , sizeof ( dir ) ) ; fh = open ( file_name , O_RDONLY | O_BINARY ) ; if ( fh > 0 ) { lseek ( fh , 0 , SEEK_END ) ; length = TELL ( fh ) ; lseek ( fh , 0 , SEEK_SET ) ; rsprintf ( ""HTTP/1.1<S2SV_blank>200<S2SV_blank>Document<S2SV_blank>follows\\r\\n"" ) ; rsprintf ( ""Server:<S2SV_blank>ELOG<S2SV_blank>HTTP<S2SV_blank>%s-%s\\r\\n"" , VERSION , git_revision ( ) ) ; rsprintf ( ""Accept-Ranges:<S2SV_blank>bytes\\r\\n"" ) ; if ( isparam ( ""thumb"" ) ) { rsprintf ( ""Pragma:<S2SV_blank>no-cache\\r\\n"" ) ; rsprintf ( ""Cache-control:<S2SV_blank>private,<S2SV_blank>max-age=0,<S2SV_blank>no-cache,<S2SV_blank>no-store\\r\\n"" ) ; } else { rsprintf ( ""Cache-control:<S2SV_blank>public,<S2SV_blank>max-age=86400\\r\\n"" ) ; } if ( keep_alive ) { rsprintf ( ""Connection:<S2SV_blank>Keep-Alive\\r\\n"" ) ; rsprintf ( ""Keep-Alive:<S2SV_blank>timeout=60,<S2SV_blank>max=10\\r\\n"" ) ; } for ( i = 0 ; i < ( int ) strlen ( file_name ) ; i ++ ) str [ i ] = toupper ( file_name [ i ] ) ; str [ i ] = 0 ; for ( i = 0 ; filetype [ i ] . ext [ 0 ] ; i ++ ) if ( chkext ( str , filetype [ i ] . ext ) ) break ; if ( ! getcfg ( ""global"" , ""charset"" , charset , sizeof ( charset ) ) ) strcpy ( charset , DEFAULT_HTTP_CHARSET ) ; if ( filetype [ i ] . ext [ 0 ] ) { if ( strncmp ( filetype [ i ] . type , ""text"" , 4 ) == 0 ) rsprintf ( ""Content-Type:<S2SV_blank>%s;charset=%s\\r\\n"" , filetype [ i ] . type , charset ) ;  else  rsprintf ( ""Content-Type:<S2SV_blank>%s\\r\\n"" , filetype [ i ] . type ) ; } else if ( is_ascii ( file_name ) ) rsprintf ( ""Content-Type:<S2SV_blank>text/plain;charset=%s\\r\\n"" , charset ) ; else rsprintf ( ""Content-Type:<S2SV_blank>application/octet-stream;charset=%s\\r\\n"" , charset ) ; rsprintf ( ""Content-Length:<S2SV_blank>%d\\r\\n\\r\\n"" , length ) ; if ( length > return_buffer_size - ( int ) strlen ( return_buffer ) ) { delta = length - ( return_buffer_size - strlen ( return_buffer ) ) + 1000 ; return_buffer = xrealloc ( return_buffer , return_buffer_size + delta ) ; memset ( return_buffer + return_buffer_size , 0 , delta ) ; return_buffer_size += delta ; } return_length = strlen ( return_buffer ) + length ; read ( fh , return_buffer + strlen ( return_buffer ) , length ) ; close ( fh ) ; } else { char encodedname [ 256 ] ; show_html_header ( NULL , FALSE , ""404<S2SV_blank>Not<S2SV_blank>Found"" , TRUE , FALSE , NULL , FALSE , 0 ) ; rsprintf ( ""<body><h1>Not<S2SV_blank>Found</h1>\\r\\n"" ) ; rsprintf ( ""The<S2SV_blank>requested<S2SV_blank>file<S2SV_blank><b>"" ) ; strencode2 ( encodedname , file_name , sizeof ( encodedname ) ) ; if ( strchr ( file_name , DIR_SEPARATOR ) ) rsprintf ( ""%s"" , encodedname ) ; else rsprintf ( ""%s%c%s"" , dir , DIR_SEPARATOR , encodedname ) ; rsprintf ( ""</b><S2SV_blank>was<S2SV_blank>not<S2SV_blank>found<S2SV_blank>on<S2SV_blank>this<S2SV_blank>server<p>\\r\\n"" ) ; rsprintf ( ""<hr><address>ELOG<S2SV_blank>version<S2SV_blank>%s</address></body></html>\\r\\n\\r\\n"" , VERSION ) ; return_length = strlen_retbuf ; keep_alive = FALSE ; } }","else if ( strcmp ( filetype [ i ] . ext , "".SVG"" ) == 0 ) {rsprintf ( ""Content-Type:<S2SV_blank>%s\\\\r\\\if ( strrchr ( file_name , \'/\' ) ) strlcpy ( str , strrchr ( file_name , \'/\' ) + 1 , sizeof ( str ) ) ;else strlcpy ( str , file_name , sizeof ( str ) ) ;if ( str [ 6 ] == \'_\' && str [ 13 ] == \'_\' ) rsprintf ( ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\\\""%s\\\\""\\\\r\\\else rsprintf ( ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\\\""%s\\\\""\\\\r\\\}else rsprintf ( ""Content-Type:<S2SV_blank>%s\\\\r\\\",2721
785,"buggy line: return ret ;}cwe id:CWE-119context: static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ;  return ret ;  }","if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;return ret ;}",2722
786,"buggy line: long elements ;elements = parse_iv2 ( ( * p ) + 2 , p ) ;( * p ) += 2 ;if ( ce -> serialize == NULL ) {object_init_ex ( * rval , ce ) ;else {zend_error ( E_WARNING , ""Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\\\'%s\\\'"" , ce -> name ) ;return 0 ;}cwe id:CWE-125context: static inline long object_common1 ( UNSERIALIZE_PARAMETER , zend_class_entry * ce ) {  long elements ;  elements = parse_iv2 ( ( * p ) + 2 , p ) ; ( * p ) += 2 ; if ( ce -> serialize == NULL ) { object_init_ex ( * rval , ce ) ; } else { zend_error ( E_WARNING , ""Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\'%s\'"" , ce -> name ) ;  return 0 ;  } return elements ; }","long elements ;if ( * p >= max - 2 ) {zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ;return - 1 ;",2723
787,"buggy line: token ++ ;}cwe id:CWE-119context: static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) {  token ++ ;  } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }","token ++ ;}if ( operand >= MAX_OPERANDS ) {eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\\return false ;}",2724
788,"buggy line: void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec )  {cwe id:CWE-119context:  void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec )  { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ; UWORD16 u2_total_len ; UWORD16 u2_len ; UWORD16 u2_mb_type ; UWORD32 u4_next_word ; const dec_mb_params_t * ps_dec_mb_params ; if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 1 ) ; } else { u2_mb_addr_incr = impeg2d_get_mb_addr_incr ( ps_stream ) ; if ( 0 == ps_dec -> u2_first_mb ) { if ( ps_dec -> u2_is_mpeg2 && ( ( ps_dec -> u2_mb_x + u2_mb_addr_incr ) > ps_dec -> u2_num_horiz_mb ) ) { u2_mb_addr_incr = ps_dec -> u2_num_horiz_mb - ps_dec -> u2_mb_x ; } impeg2d_dec_skip_mbs ( ps_dec , ( UWORD16 ) ( u2_mb_addr_incr - 1 ) ) ; } } u4_next_word = ( UWORD16 ) impeg2d_bit_stream_nxt ( ps_stream , 16 ) ; { u2_mb_type = ps_dec -> pu2_mb_type [ BITS ( ( UWORD16 ) u4_next_word , 15 , 10 ) ] ; u2_len = BITS ( u2_mb_type , 15 , 8 ) ; u2_total_len = u2_len ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << u2_len ) ; } { if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ps_dec -> u2_read_motion_type ) { WORD32 i4_motion_type ; ps_dec -> u2_motion_type = BITS ( ( UWORD16 ) u4_next_word , 15 , 14 ) ; u2_total_len += MB_MOTION_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_MOTION_TYPE_LEN ) ; i4_motion_type = ps_dec -> u2_motion_type ; if ( ( i4_motion_type == 0 ) || ( i4_motion_type == 4 ) || ( i4_motion_type > 7 ) ) { i4_motion_type = 1 ; } } } { if ( ( u2_mb_type & MB_CODED ) && ps_dec -> u2_read_dct_type ) { ps_dec -> u2_field_dct = BIT ( ( UWORD16 ) u4_next_word , 15 ) ; u2_total_len += MB_DCT_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_DCT_TYPE_LEN ) ; } } if ( u2_mb_type & MB_QUANT ) { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = BITS ( ( UWORD16 ) u4_next_word , 15 , 11 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; u2_total_len += MB_QUANT_SCALE_CODE_LEN ; } impeg2d_bit_stream_flush ( ps_stream , u2_total_len ) ; ps_dec -> u2_coded_mb = ( UWORD16 ) ( u2_mb_type & MB_CODED ) ; if ( u2_mb_type & MB_FORW_OR_BACK ) { UWORD16 refPic = ! ( u2_mb_type & MB_MV_FORW ) ; UWORD16 index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = ( e_pred_direction_t ) refPic ; ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ;  ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;  } else if ( u2_mb_type & MB_TYPE_INTRA ) { ps_dec -> u2_prev_intra_mb = 1 ; impeg2d_dec_intra_mb ( ps_dec ) ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = FORW ; ps_dec -> u2_motion_type = 0 ; impeg2d_dec_0mv_coded_mb ( ps_dec ) ; } if ( ( u2_mb_type & MB_TYPE_INTRA ) ) { ps_dec -> u2_cbp = 0x3f ; ps_dec -> u2_prev_intra_mb = 1 ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; if ( ( ps_dec -> u2_coded_mb ) ) { UWORD16 cbpValue ; cbpValue = gau2_impeg2d_cbp_code [ impeg2d_bit_stream_nxt ( ps_stream , MB_CBP_LEN ) ] ; ps_dec -> u2_cbp = cbpValue & 0xFF ; impeg2d_bit_stream_flush ( ps_stream , ( cbpValue >> 8 ) & 0x0FF ) ; } else { ps_dec -> u2_cbp = 0 ; } }  } ",WORD32 impeg2d_dec_p_mb_params ( dec_state_t * ps_dec ) {,2725
789,"buggy line: ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;}cwe id:CWE-119context:  void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec )  { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ; UWORD16 u2_total_len ; UWORD16 u2_len ; UWORD16 u2_mb_type ; UWORD32 u4_next_word ; const dec_mb_params_t * ps_dec_mb_params ; if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 1 ) ; } else { u2_mb_addr_incr = impeg2d_get_mb_addr_incr ( ps_stream ) ; if ( 0 == ps_dec -> u2_first_mb ) { if ( ps_dec -> u2_is_mpeg2 && ( ( ps_dec -> u2_mb_x + u2_mb_addr_incr ) > ps_dec -> u2_num_horiz_mb ) ) { u2_mb_addr_incr = ps_dec -> u2_num_horiz_mb - ps_dec -> u2_mb_x ; } impeg2d_dec_skip_mbs ( ps_dec , ( UWORD16 ) ( u2_mb_addr_incr - 1 ) ) ; } } u4_next_word = ( UWORD16 ) impeg2d_bit_stream_nxt ( ps_stream , 16 ) ; { u2_mb_type = ps_dec -> pu2_mb_type [ BITS ( ( UWORD16 ) u4_next_word , 15 , 10 ) ] ; u2_len = BITS ( u2_mb_type , 15 , 8 ) ; u2_total_len = u2_len ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << u2_len ) ; } { if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ps_dec -> u2_read_motion_type ) { WORD32 i4_motion_type ; ps_dec -> u2_motion_type = BITS ( ( UWORD16 ) u4_next_word , 15 , 14 ) ; u2_total_len += MB_MOTION_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_MOTION_TYPE_LEN ) ; i4_motion_type = ps_dec -> u2_motion_type ; if ( ( i4_motion_type == 0 ) || ( i4_motion_type == 4 ) || ( i4_motion_type > 7 ) ) { i4_motion_type = 1 ; } } } { if ( ( u2_mb_type & MB_CODED ) && ps_dec -> u2_read_dct_type ) { ps_dec -> u2_field_dct = BIT ( ( UWORD16 ) u4_next_word , 15 ) ; u2_total_len += MB_DCT_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_DCT_TYPE_LEN ) ; } } if ( u2_mb_type & MB_QUANT ) { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = BITS ( ( UWORD16 ) u4_next_word , 15 , 11 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; u2_total_len += MB_QUANT_SCALE_CODE_LEN ; } impeg2d_bit_stream_flush ( ps_stream , u2_total_len ) ; ps_dec -> u2_coded_mb = ( UWORD16 ) ( u2_mb_type & MB_CODED ) ; if ( u2_mb_type & MB_FORW_OR_BACK ) { UWORD16 refPic = ! ( u2_mb_type & MB_MV_FORW ) ; UWORD16 index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = ( e_pred_direction_t ) refPic ; ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ;  ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;  } else if ( u2_mb_type & MB_TYPE_INTRA ) { ps_dec -> u2_prev_intra_mb = 1 ; impeg2d_dec_intra_mb ( ps_dec ) ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = FORW ; ps_dec -> u2_motion_type = 0 ; impeg2d_dec_0mv_coded_mb ( ps_dec ) ; } if ( ( u2_mb_type & MB_TYPE_INTRA ) ) { ps_dec -> u2_cbp = 0x3f ; ps_dec -> u2_prev_intra_mb = 1 ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; if ( ( ps_dec -> u2_coded_mb ) ) { UWORD16 cbpValue ; cbpValue = gau2_impeg2d_cbp_code [ impeg2d_bit_stream_nxt ( ps_stream , MB_CBP_LEN ) ] ; ps_dec -> u2_cbp = cbpValue & 0xFF ; impeg2d_bit_stream_flush ( ps_stream , ( cbpValue >> 8 ) & 0x0FF ) ; } else { ps_dec -> u2_cbp = 0 ; } }  } ",if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ;ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},2725
790,"buggy line: }cwe id:CWE-119context:  void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec )  { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ; UWORD16 u2_total_len ; UWORD16 u2_len ; UWORD16 u2_mb_type ; UWORD32 u4_next_word ; const dec_mb_params_t * ps_dec_mb_params ; if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 1 ) ; } else { u2_mb_addr_incr = impeg2d_get_mb_addr_incr ( ps_stream ) ; if ( 0 == ps_dec -> u2_first_mb ) { if ( ps_dec -> u2_is_mpeg2 && ( ( ps_dec -> u2_mb_x + u2_mb_addr_incr ) > ps_dec -> u2_num_horiz_mb ) ) { u2_mb_addr_incr = ps_dec -> u2_num_horiz_mb - ps_dec -> u2_mb_x ; } impeg2d_dec_skip_mbs ( ps_dec , ( UWORD16 ) ( u2_mb_addr_incr - 1 ) ) ; } } u4_next_word = ( UWORD16 ) impeg2d_bit_stream_nxt ( ps_stream , 16 ) ; { u2_mb_type = ps_dec -> pu2_mb_type [ BITS ( ( UWORD16 ) u4_next_word , 15 , 10 ) ] ; u2_len = BITS ( u2_mb_type , 15 , 8 ) ; u2_total_len = u2_len ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << u2_len ) ; } { if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ps_dec -> u2_read_motion_type ) { WORD32 i4_motion_type ; ps_dec -> u2_motion_type = BITS ( ( UWORD16 ) u4_next_word , 15 , 14 ) ; u2_total_len += MB_MOTION_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_MOTION_TYPE_LEN ) ; i4_motion_type = ps_dec -> u2_motion_type ; if ( ( i4_motion_type == 0 ) || ( i4_motion_type == 4 ) || ( i4_motion_type > 7 ) ) { i4_motion_type = 1 ; } } } { if ( ( u2_mb_type & MB_CODED ) && ps_dec -> u2_read_dct_type ) { ps_dec -> u2_field_dct = BIT ( ( UWORD16 ) u4_next_word , 15 ) ; u2_total_len += MB_DCT_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_DCT_TYPE_LEN ) ; } } if ( u2_mb_type & MB_QUANT ) { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = BITS ( ( UWORD16 ) u4_next_word , 15 , 11 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; u2_total_len += MB_QUANT_SCALE_CODE_LEN ; } impeg2d_bit_stream_flush ( ps_stream , u2_total_len ) ; ps_dec -> u2_coded_mb = ( UWORD16 ) ( u2_mb_type & MB_CODED ) ; if ( u2_mb_type & MB_FORW_OR_BACK ) { UWORD16 refPic = ! ( u2_mb_type & MB_MV_FORW ) ; UWORD16 index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = ( e_pred_direction_t ) refPic ; ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ;  ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;  } else if ( u2_mb_type & MB_TYPE_INTRA ) { ps_dec -> u2_prev_intra_mb = 1 ; impeg2d_dec_intra_mb ( ps_dec ) ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = FORW ; ps_dec -> u2_motion_type = 0 ; impeg2d_dec_0mv_coded_mb ( ps_dec ) ; } if ( ( u2_mb_type & MB_TYPE_INTRA ) ) { ps_dec -> u2_cbp = 0x3f ; ps_dec -> u2_prev_intra_mb = 1 ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; if ( ( ps_dec -> u2_coded_mb ) ) { UWORD16 cbpValue ; cbpValue = gau2_impeg2d_cbp_code [ impeg2d_bit_stream_nxt ( ps_stream , MB_CBP_LEN ) ] ; ps_dec -> u2_cbp = cbpValue & 0xFF ; impeg2d_bit_stream_flush ( ps_stream , ( cbpValue >> 8 ) & 0x0FF ) ; } else { ps_dec -> u2_cbp = 0 ; } }  } ",return 0 ;},2725
791,"buggy line: int row8x8_remaining = tile -> mi_row_end - mi_row ;int col8x8_remaining = tile -> mi_col_end - mi_col ;int block_row , block_col ;cwe id:CWE-119context: static void set_fixed_partitioning ( VP9_COMP * cpi , const TileInfo * const tile , MODE_INFO * * mi_8x8 , int mi_row , int mi_col , BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; const int mis = cm -> mi_stride ;  int row8x8_remaining = tile -> mi_row_end - mi_row ;   int col8x8_remaining = tile -> mi_col_end - mi_col ;  int block_row , block_col ; MODE_INFO * mi_upper_left = cm -> mi + mi_row * mis + mi_col ; int bh = num_8x8_blocks_high_lookup [ bsize ] ; int bw = num_8x8_blocks_wide_lookup [ bsize ] ; assert ( ( row8x8_remaining > 0 ) && ( col8x8_remaining > 0 ) ) ; if ( ( col8x8_remaining >= MI_BLOCK_SIZE ) && ( row8x8_remaining >= MI_BLOCK_SIZE ) ) { for ( block_row = 0 ; block_row < MI_BLOCK_SIZE ; block_row += bh ) { for ( block_col = 0 ; block_col < MI_BLOCK_SIZE ; block_col += bw ) { int index = block_row * mis + block_col ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = bsize ; } } } else {  for ( block_row = 0 ; block_row < MI_BLOCK_SIZE ; block_row += bh ) {  for ( block_col = 0 ; block_col < MI_BLOCK_SIZE ; block_col += bw ) { int index = block_row * mis + block_col ; bsize = find_partition_size ( bsize , ( row8x8_remaining - block_row ) , ( col8x8_remaining - block_col ) , & bh , & bw ) ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = bsize ; } } } }","const int row8x8_remaining = tile -> mi_row_end - mi_row ;const int col8x8_remaining = tile -> mi_col_end - mi_col ;int block_row , block_col ;",2726
792,"buggy line: for ( block_row = 0 ;block_row < MI_BLOCK_SIZE ;block_row += bh ) {for ( block_col = 0 ;block_col < MI_BLOCK_SIZE ;block_col += bw ) {int index = block_row * mis + block_col ;bsize = find_partition_size ( bsize , ( row8x8_remaining - block_row ) , ( col8x8_remaining - block_col ) , & bh , & bw ) ;mi_8x8 [ index ] = mi_upper_left + index ;mi_8x8 [ index ] -> mbmi . sb_type = bsize ;}}cwe id:CWE-119context: static void set_fixed_partitioning ( VP9_COMP * cpi , const TileInfo * const tile , MODE_INFO * * mi_8x8 , int mi_row , int mi_col , BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; const int mis = cm -> mi_stride ;  int row8x8_remaining = tile -> mi_row_end - mi_row ;   int col8x8_remaining = tile -> mi_col_end - mi_col ;  int block_row , block_col ; MODE_INFO * mi_upper_left = cm -> mi + mi_row * mis + mi_col ; int bh = num_8x8_blocks_high_lookup [ bsize ] ; int bw = num_8x8_blocks_wide_lookup [ bsize ] ; assert ( ( row8x8_remaining > 0 ) && ( col8x8_remaining > 0 ) ) ; if ( ( col8x8_remaining >= MI_BLOCK_SIZE ) && ( row8x8_remaining >= MI_BLOCK_SIZE ) ) { for ( block_row = 0 ; block_row < MI_BLOCK_SIZE ; block_row += bh ) { for ( block_col = 0 ; block_col < MI_BLOCK_SIZE ; block_col += bw ) { int index = block_row * mis + block_col ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = bsize ; } } } else {  for ( block_row = 0 ; block_row < MI_BLOCK_SIZE ; block_row += bh ) {  for ( block_col = 0 ; block_col < MI_BLOCK_SIZE ; block_col += bw ) { int index = block_row * mis + block_col ; bsize = find_partition_size ( bsize , ( row8x8_remaining - block_row ) , ( col8x8_remaining - block_col ) , & bh , & bw ) ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = bsize ; } } } }","set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , bsize , mi_8x8 ) ;",2726
793,"buggy line: if ( info . si_code >= 0 )   return - EPERM ;info . si_signo = sig ;cwe id:CWE-000context: SYSCALL_DEFINE3 ( rt_sigqueueinfo , pid_t , pid , int , sig , siginfo_t __user * , uinfo ) { siginfo_t info ; if ( copy_from_user ( & info , uinfo , sizeof ( siginfo_t ) ) ) return - EFAULT ;  if ( info . si_code >= 0 )   return - EPERM ;  info . si_signo = sig ; return kill_proc_info ( sig , & info , pid ) ; }",if ( info . si_code != SI_QUEUE ) {WARN_ON_ONCE ( info . si_code < 0 ) ;return - EPERM ;}info . si_signo = sig ;,2727
794,"buggy line: if ( error == NULL ) {issuer_known = TRUE ;if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) {if ( ret != GNUTLS_E_SUCCESS ) inf_gnutls_set_error ( & error , ret ) ;else if ( verify & GNUTLS_CERT_INVALID )  inf_gnutls_certificate_verification_set_error ( & error , verify ) ;}}cwe id:CWE-295context: static void inf_gtk_certificate_manager_certificate_func ( InfXmppConnection * connection , gnutls_session_t session , InfCertificateChain * chain , gpointer user_data ) { InfGtkCertificateManager * manager ; InfGtkCertificateManagerPrivate * priv ; InfGtkCertificateDialogFlags flags ; gnutls_x509_crt_t presented_cert ; gnutls_x509_crt_t known_cert ; gchar * hostname ; gboolean match_hostname ; gboolean issuer_known ; gnutls_x509_crt_t root_cert ; int ret ; unsigned int verify ; GHashTable * table ; gboolean cert_equal ; time_t expiration_time ; InfGtkCertificateManagerQuery * query ; gchar * text ; GtkWidget * vbox ; GtkWidget * label ; GError * error ; manager = INF_GTK_CERTIFICATE_MANAGER ( user_data ) ; priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE ( manager ) ; g_object_get ( G_OBJECT ( connection ) , ""remote-hostname"" , & hostname , NULL ) ; presented_cert = inf_certificate_chain_get_own_certificate ( chain ) ; match_hostname = gnutls_x509_crt_check_hostname ( presented_cert , hostname ) ; ret = gnutls_certificate_verify_peers2 ( session , & verify ) ; error = NULL ; if ( ret != GNUTLS_E_SUCCESS ) inf_gnutls_set_error ( & error , ret ) ; if ( error == NULL ) { issuer_known = TRUE ; if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) { issuer_known = FALSE ; root_cert = inf_certificate_chain_get_root_certificate ( chain ) ; ret = gnutls_x509_crt_list_verify ( inf_certificate_chain_get_raw ( chain ) , inf_certificate_chain_get_n_certificates ( chain ) , & root_cert , 1 , NULL , 0 , GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT , & verify ) ; if ( ret != GNUTLS_E_SUCCESS ) inf_gnutls_set_error ( & error , ret ) ;  else if ( verify & GNUTLS_CERT_INVALID )  inf_gnutls_certificate_verification_set_error ( & error , verify ) ;  }  } table = NULL ; if ( error == NULL ) { known_cert = NULL ; if ( ! match_hostname || ! issuer_known ) { table = inf_gtk_certificate_manager_ref_known_hosts ( manager , & error ) ; if ( table != NULL ) known_cert = g_hash_table_lookup ( table , hostname ) ; } } flags = 0 ; if ( error == NULL ) { if ( known_cert != NULL ) { cert_equal = inf_gtk_certificate_manager_compare_fingerprint ( known_cert , presented_cert , & error ) ; if ( error == NULL && cert_equal == FALSE ) { if ( ! match_hostname ) flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH ; if ( ! issuer_known ) flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN ; flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED ; expiration_time = gnutls_x509_crt_get_expiration_time ( known_cert ) ; if ( expiration_time != ( time_t ) ( - 1 ) ) { expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE ; if ( time ( NULL ) > expiration_time ) { flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED ; } } } } else { if ( ! match_hostname ) flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH ; if ( ! issuer_known ) flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN ; } } if ( error == NULL ) { if ( flags == 0 ) { if ( match_hostname && issuer_known ) { if ( table != NULL && g_hash_table_remove ( table , hostname ) == TRUE ) { inf_gtk_certificate_manager_write_known_hosts_with_warning ( manager , table ) ; } } inf_xmpp_connection_certificate_verify_continue ( connection ) ; } else { query = g_slice_new ( InfGtkCertificateManagerQuery ) ; query -> manager = manager ; query -> known_hosts = table ; query -> connection = connection ; query -> dialog = inf_gtk_certificate_dialog_new ( priv -> parent_window , 0 , flags , hostname , chain ) ; query -> certificate_chain = chain ; table = NULL ; g_object_ref ( query -> connection ) ; inf_certificate_chain_ref ( chain ) ; g_signal_connect ( G_OBJECT ( connection ) , ""notify::status"" , G_CALLBACK ( inf_gtk_certificate_manager_notify_status_cb ) , query ) ; g_signal_connect ( G_OBJECT ( query -> dialog ) , ""response"" , G_CALLBACK ( inf_gtk_certificate_manager_response_cb ) , query ) ; gtk_dialog_add_button ( GTK_DIALOG ( query -> dialog ) , _ ( ""_Cancel<S2SV_blank>connection"" ) , GTK_RESPONSE_REJECT ) ; gtk_dialog_add_button ( GTK_DIALOG ( query -> dialog ) , _ ( ""C_ontinue<S2SV_blank>connection"" ) , GTK_RESPONSE_ACCEPT ) ; text = g_strdup_printf ( _ ( ""Do<S2SV_blank>you<S2SV_blank>want<S2SV_blank>to<S2SV_blank>continue<S2SV_blank>the<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>host<S2SV_blank>\\""%s\\""?<S2SV_blank>If<S2SV_blank>you<S2SV_blank>"" ""choose<S2SV_blank>to<S2SV_blank>continue,<S2SV_blank>this<S2SV_blank>certificate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>trusted<S2SV_blank>in<S2SV_blank>the<S2SV_blank>"" ""future<S2SV_blank>when<S2SV_blank>connecting<S2SV_blank>to<S2SV_blank>this<S2SV_blank>host."" ) , hostname ) ; label = gtk_label_new ( text ) ; gtk_label_set_line_wrap ( GTK_LABEL ( label ) , TRUE ) ; gtk_label_set_line_wrap_mode ( GTK_LABEL ( label ) , PANGO_WRAP_WORD_CHAR ) ; gtk_label_set_max_width_chars ( GTK_LABEL ( label ) , 60 ) ; gtk_misc_set_alignment ( GTK_MISC ( label ) , 0.0 , 0.0 ) ; gtk_widget_show ( label ) ; g_free ( text ) ; vbox = gtk_dialog_get_content_area ( GTK_DIALOG ( query -> dialog ) ) ; gtk_box_pack_start ( GTK_BOX ( vbox ) , label , FALSE , FALSE , 0 ) ; priv -> queries = g_slist_prepend ( priv -> queries , query ) ; gtk_window_present ( GTK_WINDOW ( query -> dialog ) ) ; } } else { inf_xmpp_connection_certificate_verify_cancel ( connection , error ) ; g_error_free ( error ) ; } if ( table != NULL ) g_hash_table_unref ( table ) ; g_free ( hostname ) ; }",}if ( error == NULL ) if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) {},2728
795,"buggy line: return ! inode_capable ( inode , CAP_FOWNER ) ;}cwe id:CWE-264context: static inline int check_sticky ( struct inode * dir , struct inode * inode ) { kuid_t fsuid = current_fsuid ( ) ; if ( ! ( dir -> i_mode & S_ISVTX ) ) return 0 ; if ( uid_eq ( inode -> i_uid , fsuid ) ) return 0 ; if ( uid_eq ( dir -> i_uid , fsuid ) ) return 0 ;  return ! inode_capable ( inode , CAP_FOWNER ) ;  }","return ! capable_wrt_inode_uidgid ( inode , CAP_FOWNER ) ;}",2729
796,"buggy line: if ( ( opt_len != mp_dss_len ( mdss , 1 ) &&  opt_len != mp_dss_len ( mdss , 0 ) ) || flags & TH_SYN ) return 0 ;if ( mdss -> flags & MP_DSS_A ) {ND_PRINT ( ( ndo , ""<S2SV_blank>ack<S2SV_blank>"" ) ) ;if ( mdss -> flags & MP_DSS_a ) {ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}}if ( mdss -> flags & MP_DSS_m ) {ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}ND_PRINT ( ( ndo , ""<S2SV_blank>subseq<S2SV_blank>%u"" , EXTRACT_32BITS ( opt ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ;opt += 2 ;if ( opt_len == mp_dss_len ( mdss , 1 ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ;cwe id:CWE-125context: static int mp_dss_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_dss * mdss = ( const struct mp_dss * ) opt ;  if ( ( opt_len != mp_dss_len ( mdss , 1 ) &&  opt_len != mp_dss_len ( mdss , 0 ) ) || flags & TH_SYN ) return 0 ; if ( mdss -> flags & MP_DSS_F ) ND_PRINT ( ( ndo , ""<S2SV_blank>fin"" ) ) ; opt += 4 ;  if ( mdss -> flags & MP_DSS_A ) {  ND_PRINT ( ( ndo , ""<S2SV_blank>ack<S2SV_blank>"" ) ) ;  if ( mdss -> flags & MP_DSS_a ) {  ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ; opt += 8 ;  } else {   ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;  opt += 4 ;  }  } if ( mdss -> flags & MP_DSS_M ) { ND_PRINT ( ( ndo , ""<S2SV_blank>seq<S2SV_blank>"" ) ) ;  if ( mdss -> flags & MP_DSS_m ) {  ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ; opt += 8 ;  } else {   ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;  opt += 4 ;  }  ND_PRINT ( ( ndo , ""<S2SV_blank>subseq<S2SV_blank>%u"" , EXTRACT_32BITS ( opt ) ) ) ; opt += 4 ;  ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ;  opt += 2 ;  if ( opt_len == mp_dss_len ( mdss , 1 ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ; } return 1 ; }","if ( opt_len < 4 ) return 0 ;if ( flags & TH_SYN ) return 0 ;opt_len -= 4 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""<S2SV_blank>ack<S2SV_blank>"" ) ) ;if ( mdss -> flags & MP_DSS_a ) {if ( opt_len < 8 ) return 0 ;ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;opt_len -= 8 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;opt_len -= 4 ;if ( opt_len < 2 ) return 0 ;opt_len -= 4 ;}}if ( mdss -> flags & MP_DSS_m ) {if ( opt_len < 8 ) return 0 ;ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;opt_len -= 8 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}ND_PRINT ( ( ndo , ""<S2SV_blank>subseq<S2SV_blank>%u"" , EXTRACT_32BITS ( opt ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ;opt += 2 ;opt_len -= 2 ;if ( opt_len >= 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ;opt_len -= 2 ;}if ( opt_len != 0 ) return 0 ;",2730
797,"buggy line: fprintf ( fpfile , ""%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.4f""  ""%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f"" ""%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f\\\cwe id:CWE-119context: static void output_stats ( FIRSTPASS_STATS * stats , struct vpx_codec_pkt_list * pktlist ) { struct vpx_codec_cx_pkt pkt ; pkt . kind = VPX_CODEC_STATS_PKT ; pkt . data . twopass_stats . buf = stats ; pkt . data . twopass_stats . sz = sizeof ( FIRSTPASS_STATS ) ; vpx_codec_pkt_list_add ( pktlist , & pkt ) ; # if OUTPUT_FPF { FILE * fpfile ; fpfile = fopen ( ""firstpass.stt"" , ""a"" ) ;  fprintf ( fpfile , ""%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.4f""  ""%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f"" ""%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f\\n"" , stats -> frame ,  stats -> intra_error ,  stats -> coded_error , stats -> sr_coded_error ,  stats -> ssim_weighted_pred_err ,  stats -> pcnt_inter , stats -> pcnt_motion , stats -> pcnt_second_ref ,  stats -> pcnt_neutral ,  stats -> MVr , stats -> mvr_abs , stats -> MVc , stats -> mvc_abs , stats -> MVrv , stats -> MVcv , stats -> mv_in_out_count , stats -> new_mv_count , stats -> count , stats -> duration ) ; fclose ( fpfile ) ; } # endif }","fprintf ( fpfile , ""%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf"" ""%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf"" ""%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf\\\",2731
798,"buggy line: int_fb -> in_use = 0 ;return 0 ;cwe id:CWE-119context: int vp9_release_frame_buffer ( void * cb_priv , vpx_codec_frame_buffer_t * fb ) { InternalFrameBuffer * const int_fb = ( InternalFrameBuffer * ) fb -> priv ; ( void ) cb_priv ;  int_fb -> in_use = 0 ;  return 0 ; }",if ( int_fb ) int_fb -> in_use = 0 ;return 0 ;,2732
799,"buggy line: inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;cwe id:CWE-119context: DECLAREcpFunc ( cpSeparate2ContigByRow ) { tsize_t scanlinesizein = TIFFScanlineSize ( in ) ; tsize_t scanlinesizeout = TIFFScanlineSize ( out ) ; tdata_t inbuf ; tdata_t outbuf ; register uint8 * inp , * outp ; register uint32 n ; uint32 row ; tsample_t s ;  inbuf = _TIFFmalloc ( scanlinesizein ) ;  outbuf = _TIFFmalloc ( scanlinesizeout ) ; if ( ! inbuf || ! outbuf ) goto bad ; _TIFFmemset ( inbuf , 0 , scanlinesizein ) ; _TIFFmemset ( outbuf , 0 , scanlinesizeout ) ; for ( row = 0 ; row < imagelength ; row ++ ) { for ( s = 0 ; s < spp ; s ++ ) { if ( TIFFReadScanline ( in , inbuf , row , s ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>scanline<S2SV_blank>%lu"" , ( unsigned long ) row ) ; goto bad ; } inp = ( uint8 * ) inbuf ; outp = ( ( uint8 * ) outbuf ) + s ; for ( n = imagewidth ; n -- > 0 ; ) { * outp = * inp ++ ; outp += spp ; } } if ( TIFFWriteScanline ( out , outbuf , row , 0 ) < 0 ) { TIFFError ( TIFFFileName ( out ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>write<S2SV_blank>scanline<S2SV_blank>%lu"" , ( unsigned long ) row ) ; goto bad ; } } if ( inbuf ) _TIFFfree ( inbuf ) ; if ( outbuf ) _TIFFfree ( outbuf ) ; return 1 ; bad : if ( inbuf ) _TIFFfree ( inbuf ) ; if ( outbuf ) _TIFFfree ( outbuf ) ; return 0 ; }","uint16 bps = 0 ;( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ;if ( bps != 8 ) {TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpSeparate2ContigByRow"" ) ;return 0 ;}inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;",2733
800,"buggy line: if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) {sctp_chunk_free ( chunk ) ;chunk = queue -> in_progress = NULL ;}cwe id:CWE-399context: struct sctp_chunk * sctp_inq_pop ( struct sctp_inq * queue ) { struct sctp_chunk * chunk ; sctp_chunkhdr_t * ch = NULL ; if ( ( chunk = queue -> in_progress ) ) { if ( chunk -> singleton || chunk -> end_of_packet || chunk -> pdiscard ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } else { ch = ( sctp_chunkhdr_t * ) chunk -> chunk_end ; skb_pull ( chunk -> skb , chunk -> chunk_end - chunk -> skb -> data ) ;  if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) {  sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } } } if ( ! chunk ) { struct list_head * entry ; if ( list_empty ( & queue -> in_chunk_list ) ) return NULL ; entry = queue -> in_chunk_list . next ; chunk = queue -> in_progress = list_entry ( entry , struct sctp_chunk , list ) ; list_del_init ( entry ) ; chunk -> singleton = 1 ; ch = ( sctp_chunkhdr_t * ) chunk -> skb -> data ; chunk -> data_accepted = 0 ; } chunk -> chunk_hdr = ch ; chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ; if ( unlikely ( skb_is_nonlinear ( chunk -> skb ) ) ) { if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ; chunk -> subh . v = NULL ;  if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) {  chunk -> singleton = 0 ; } else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) {  sctp_chunk_free ( chunk ) ;  chunk = queue -> in_progress = NULL ; return NULL ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return chunk ; }","
",2734
801,"buggy line: chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ;if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ;}skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ;chunk -> subh . v = NULL ;if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) {chunk -> singleton = 0 ;}else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) {sctp_chunk_free ( chunk ) ;chunk = queue -> in_progress = NULL ;return NULL ;cwe id:CWE-399context: struct sctp_chunk * sctp_inq_pop ( struct sctp_inq * queue ) { struct sctp_chunk * chunk ; sctp_chunkhdr_t * ch = NULL ; if ( ( chunk = queue -> in_progress ) ) { if ( chunk -> singleton || chunk -> end_of_packet || chunk -> pdiscard ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } else { ch = ( sctp_chunkhdr_t * ) chunk -> chunk_end ; skb_pull ( chunk -> skb , chunk -> chunk_end - chunk -> skb -> data ) ;  if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) {  sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } } } if ( ! chunk ) { struct list_head * entry ; if ( list_empty ( & queue -> in_chunk_list ) ) return NULL ; entry = queue -> in_chunk_list . next ; chunk = queue -> in_progress = list_entry ( entry , struct sctp_chunk , list ) ; list_del_init ( entry ) ; chunk -> singleton = 1 ; ch = ( sctp_chunkhdr_t * ) chunk -> skb -> data ; chunk -> data_accepted = 0 ; } chunk -> chunk_hdr = ch ; chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ; if ( unlikely ( skb_is_nonlinear ( chunk -> skb ) ) ) { if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ; chunk -> subh . v = NULL ;  if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) {  chunk -> singleton = 0 ; } else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) {  sctp_chunk_free ( chunk ) ;  chunk = queue -> in_progress = NULL ; return NULL ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return chunk ; }",chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ;chunk -> pdiscard = 1 ;chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ;,2734
802,"buggy line: err = - EINVAL ;ds = salg -> digestsize ;ss = salg -> statesize ;alg = & salg -> base ;cwe id:CWE-787context: static int hmac_create ( struct crypto_template * tmpl , struct rtattr * * tb ) { struct shash_instance * inst ; struct crypto_alg * alg ; struct shash_alg * salg ; int err ; int ds ; int ss ; err = crypto_check_attr_type ( tb , CRYPTO_ALG_TYPE_SHASH ) ; if ( err ) return err ; salg = shash_attr_alg ( tb [ 1 ] , 0 , 0 ) ; if ( IS_ERR ( salg ) ) return PTR_ERR ( salg ) ;  err = - EINVAL ;   ds = salg -> digestsize ;   ss = salg -> statesize ;  alg = & salg -> base ; if ( ds > alg -> cra_blocksize || ss < alg -> cra_blocksize ) goto out_put_alg ; inst = shash_alloc_instance ( ""hmac"" , alg ) ; err = PTR_ERR ( inst ) ; if ( IS_ERR ( inst ) ) goto out_put_alg ; err = crypto_init_shash_spawn ( shash_instance_ctx ( inst ) , salg , shash_crypto_instance ( inst ) ) ; if ( err ) goto out_free_inst ; inst -> alg . base . cra_priority = alg -> cra_priority ; inst -> alg . base . cra_blocksize = alg -> cra_blocksize ; inst -> alg . base . cra_alignmask = alg -> cra_alignmask ; ss = ALIGN ( ss , alg -> cra_alignmask + 1 ) ; inst -> alg . digestsize = ds ; inst -> alg . statesize = ss ; inst -> alg . base . cra_ctxsize = sizeof ( struct hmac_ctx ) + ALIGN ( ss * 2 , crypto_tfm_ctx_alignment ( ) ) ; inst -> alg . base . cra_init = hmac_init_tfm ; inst -> alg . base . cra_exit = hmac_exit_tfm ; inst -> alg . init = hmac_init ; inst -> alg . update = hmac_update ; inst -> alg . final = hmac_final ; inst -> alg . finup = hmac_finup ; inst -> alg . export = hmac_export ; inst -> alg . import = hmac_import ; inst -> alg . setkey = hmac_setkey ; err = shash_register_instance ( tmpl , inst ) ; if ( err ) { out_free_inst : shash_free_instance ( shash_crypto_instance ( inst ) ) ; } out_put_alg : crypto_mod_put ( alg ) ; return err ; }",alg = & salg -> base ;err = - EINVAL ;if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ;ds = salg -> digestsize ;ss = salg -> statesize ;,2735
803,"buggy line: static void  swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horAcc32 ( tif , cp0 , cc ) ;}cwe id:CWE-119context:  static void  swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; TIFFSwabArrayOfLong ( wp , wc ) ;  horAcc32 ( tif , cp0 , cc ) ;  }","static int swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {return horAcc32 ( tif , cp0 , cc ) ;}",2736
804,"buggy line: if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) {r = - EINVAL ;cwe id:CWE-399context: static int kvm_vm_ioctl_create_vcpu ( struct kvm * kvm , u32 id ) { int r ; struct kvm_vcpu * vcpu , * v ; vcpu = kvm_arch_vcpu_create ( kvm , id ) ; if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ; preempt_notifier_init ( & vcpu -> preempt_notifier , & kvm_preempt_ops ) ; r = kvm_arch_vcpu_setup ( vcpu ) ; if ( r ) goto vcpu_destroy ; mutex_lock ( & kvm -> lock ) ;  if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) {  r = - EINVAL ; goto unlock_vcpu_destroy ; } kvm_for_each_vcpu ( r , v , kvm ) if ( v -> vcpu_id == id ) { r = - EEXIST ; goto unlock_vcpu_destroy ; } BUG_ON ( kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] ) ; kvm_get_kvm ( kvm ) ; r = create_vcpu_fd ( vcpu ) ; if ( r < 0 ) { kvm_put_kvm ( kvm ) ; goto unlock_vcpu_destroy ; } kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] = vcpu ; smp_wmb ( ) ; atomic_inc ( & kvm -> online_vcpus ) ; mutex_unlock ( & kvm -> lock ) ; return r ; unlock_vcpu_destroy : mutex_unlock ( & kvm -> lock ) ; vcpu_destroy : kvm_arch_vcpu_destroy ( vcpu ) ; return r ; }",if ( ! kvm_vcpu_compatible ( vcpu ) ) {r = - EINVAL ;goto unlock_vcpu_destroy ;}if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) {r = - EINVAL ;,2737
805,"buggy line: struct cred * cred ;if ( ! ( unshare_flags & CLONE_NEWUSER ) ) return 0 ;cred = prepare_creds ( ) ;if ( ! cred )  return - ENOMEM ;* new_cred = cred ;return create_user_ns ( cred ) ;}cwe id:CWE-399context: int unshare_userns ( unsigned long unshare_flags , struct cred * * new_cred ) {  struct cred * cred ;  if ( ! ( unshare_flags & CLONE_NEWUSER ) ) return 0 ; cred = prepare_creds ( ) ;  if ( ! cred )  return - ENOMEM ; * new_cred = cred ;  return create_user_ns ( cred ) ;  }",struct cred * cred ;int err = - ENOMEM ;if ( cred ) {err = create_user_ns ( cred ) ;if ( err ) put_cred ( cred ) ;else * new_cred = cred ;}return err ;},2738
806,"buggy line: if ( peer ) {if ( ! lsk -> peer_conn_id ) return - ENOTCONN ;cwe id:CWE-200context: static int l2tp_ip6_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) { struct sockaddr_l2tpip6 * lsa = ( struct sockaddr_l2tpip6 * ) uaddr ; struct sock * sk = sock -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct l2tp_ip6_sock * lsk = l2tp_ip6_sk ( sk ) ; lsa -> l2tp_family = AF_INET6 ; lsa -> l2tp_flowinfo = 0 ; lsa -> l2tp_scope_id = 0 ;  if ( peer ) {  if ( ! lsk -> peer_conn_id ) return - ENOTCONN ; lsa -> l2tp_conn_id = lsk -> peer_conn_id ; lsa -> l2tp_addr = np -> daddr ; if ( np -> sndflow ) lsa -> l2tp_flowinfo = np -> flow_label ; } else { if ( ipv6_addr_any ( & np -> rcv_saddr ) ) lsa -> l2tp_addr = np -> saddr ; else lsa -> l2tp_addr = np -> rcv_saddr ; lsa -> l2tp_conn_id = lsk -> conn_id ; } if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) lsa -> l2tp_scope_id = sk -> sk_bound_dev_if ; * uaddr_len = sizeof ( * lsa ) ; return 0 ; }",lsa -> l2tp_unused = 0 ;if ( peer ) {if ( ! lsk -> peer_conn_id ) return - ENOTCONN ;,2739
807,"buggy line: if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 &&  rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) {cwe id:CWE-119context: static __u8 * pl_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) {  if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 &&  rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Petalynx<S2SV_blank>Maxter<S2SV_blank>Remote<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 60 ] = 0xfa ; rdesc [ 40 ] = 0xfa ; } return rdesc ; }",if ( * rsize >= 62 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) {,2740
808,"buggy line: int err ;if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ;if ( inet -> opt && inet -> opt -> srr ) {if ( ! daddr ) return - EINVAL ;nexthop = inet -> opt -> faddr ;}cwe id:CWE-362context: int tcp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ;  int err ;  if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) return - EAFNOSUPPORT ; nexthop = daddr = usin -> sin_addr . s_addr ;  if ( inet -> opt && inet -> opt -> srr ) {  if ( ! daddr ) return - EINVAL ;  nexthop = inet -> opt -> faddr ;  } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , IPPROTO_TCP , orig_sport , orig_dport , sk , true ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; if ( err == - ENETUNREACH ) IP_INC_STATS_BH ( sock_net ( sk ) , IPSTATS_MIB_OUTNOROUTES ) ; return err ; } if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { ip_rt_put ( rt ) ; return - ENETUNREACH ; }  if ( ! inet -> opt || ! inet -> opt -> srr )  daddr = rt -> rt_dst ; if ( ! inet -> inet_saddr ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; if ( tp -> rx_opt . ts_recent_stamp && inet -> inet_daddr != daddr ) { tp -> rx_opt . ts_recent = 0 ; tp -> rx_opt . ts_recent_stamp = 0 ; tp -> write_seq = 0 ; } if ( tcp_death_row . sysctl_tw_recycle && ! tp -> rx_opt . ts_recent_stamp && rt -> rt_dst == daddr ) { struct inet_peer * peer = rt_get_peer ( rt ) ; if ( peer ) { inet_peer_refcheck ( peer ) ; if ( ( u32 ) get_seconds ( ) - peer -> tcp_ts_stamp <= TCP_PAWS_MSL ) { tp -> rx_opt . ts_recent_stamp = peer -> tcp_ts_stamp ; tp -> rx_opt . ts_recent = peer -> tcp_ts ; } } } inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;  if ( inet -> opt )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; tp -> rx_opt . mss_clamp = TCP_MSS_DEFAULT ; tcp_set_state ( sk , TCP_SYN_SENT ) ; err = inet_hash_connect ( & tcp_death_row , sk ) ; if ( err ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto failure ; } sk -> sk_gso_type = SKB_GSO_TCPV4 ; sk_setup_caps ( sk , & rt -> dst ) ; if ( ! tp -> write_seq ) tp -> write_seq = secure_tcp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , usin -> sin_port ) ; inet -> inet_id = tp -> write_seq ^ jiffies ; err = tcp_connect ( sk ) ; rt = NULL ; if ( err ) goto failure ; return 0 ; failure : tcp_set_state ( sk , TCP_CLOSE ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; return err ; }","int err ;struct ip_options_rcu * inet_opt ;if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt && inet_opt -> opt . srr ) {if ( ! daddr ) return - EINVAL ;nexthop = inet_opt -> opt . faddr ;}",2741
809,"buggy line: if ( ! inet -> opt || ! inet -> opt -> srr )  daddr = rt -> rt_dst ;if ( ! inet -> inet_saddr ) inet -> inet_saddr = rt -> rt_src ;inet -> inet_rcv_saddr = inet -> inet_saddr ;if ( tp -> rx_opt . ts_recent_stamp && inet -> inet_daddr != daddr ) {tp -> rx_opt . ts_recent = 0 ;tp -> rx_opt . ts_recent_stamp = 0 ;tp -> write_seq = 0 ;}if ( tcp_death_row . sysctl_tw_recycle && ! tp -> rx_opt . ts_recent_stamp && rt -> rt_dst == daddr ) {struct inet_peer * peer = rt_get_peer ( rt ) ;if ( peer ) {inet_peer_refcheck ( peer ) ;if ( ( u32 ) get_seconds ( ) - peer -> tcp_ts_stamp <= TCP_PAWS_MSL ) {tp -> rx_opt . ts_recent_stamp = peer -> tcp_ts_stamp ;tp -> rx_opt . ts_recent = peer -> tcp_ts ;}}}inet -> inet_dport = usin -> sin_port ;inet -> inet_daddr = daddr ;inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;if ( inet -> opt )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ;cwe id:CWE-362context: int tcp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ;  int err ;  if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) return - EAFNOSUPPORT ; nexthop = daddr = usin -> sin_addr . s_addr ;  if ( inet -> opt && inet -> opt -> srr ) {  if ( ! daddr ) return - EINVAL ;  nexthop = inet -> opt -> faddr ;  } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , IPPROTO_TCP , orig_sport , orig_dport , sk , true ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; if ( err == - ENETUNREACH ) IP_INC_STATS_BH ( sock_net ( sk ) , IPSTATS_MIB_OUTNOROUTES ) ; return err ; } if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { ip_rt_put ( rt ) ; return - ENETUNREACH ; }  if ( ! inet -> opt || ! inet -> opt -> srr )  daddr = rt -> rt_dst ; if ( ! inet -> inet_saddr ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; if ( tp -> rx_opt . ts_recent_stamp && inet -> inet_daddr != daddr ) { tp -> rx_opt . ts_recent = 0 ; tp -> rx_opt . ts_recent_stamp = 0 ; tp -> write_seq = 0 ; } if ( tcp_death_row . sysctl_tw_recycle && ! tp -> rx_opt . ts_recent_stamp && rt -> rt_dst == daddr ) { struct inet_peer * peer = rt_get_peer ( rt ) ; if ( peer ) { inet_peer_refcheck ( peer ) ; if ( ( u32 ) get_seconds ( ) - peer -> tcp_ts_stamp <= TCP_PAWS_MSL ) { tp -> rx_opt . ts_recent_stamp = peer -> tcp_ts_stamp ; tp -> rx_opt . ts_recent = peer -> tcp_ts ; } } } inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;  if ( inet -> opt )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; tp -> rx_opt . mss_clamp = TCP_MSS_DEFAULT ; tcp_set_state ( sk , TCP_SYN_SENT ) ; err = inet_hash_connect ( & tcp_death_row , sk ) ; if ( err ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto failure ; } sk -> sk_gso_type = SKB_GSO_TCPV4 ; sk_setup_caps ( sk , & rt -> dst ) ; if ( ! tp -> write_seq ) tp -> write_seq = secure_tcp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , usin -> sin_port ) ; inet -> inet_id = tp -> write_seq ^ jiffies ; err = tcp_connect ( sk ) ; rt = NULL ; if ( err ) goto failure ; return 0 ; failure : tcp_set_state ( sk , TCP_CLOSE ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; return err ; }",if ( ! inet_opt || ! inet_opt -> opt . srr ) daddr = rt -> rt_dst ;if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . optlen ;,2741
810,"buggy line: drop_futex_key_refs ( & q -> key ) ;}cwe id:CWE-119context: static void unqueue_me_pi ( struct futex_q * q ) { WARN_ON ( plist_node_empty ( & q -> list ) ) ; plist_del ( & q -> list , & q -> list . plist ) ; BUG_ON ( ! q -> pi_state ) ; free_pi_state ( q -> pi_state ) ; q -> pi_state = NULL ; spin_unlock ( q -> lock_ptr ) ;  drop_futex_key_refs ( & q -> key ) ;  }",},2742
811,"buggy line: if ( test_tsk_need_resched ( rq -> curr ) )  rq -> skip_clock_update = 1 ;cwe id:CWE-835context: static void check_preempt_curr ( struct rq * rq , struct task_struct * p , int flags ) { const struct sched_class * class ; if ( p -> sched_class == rq -> curr -> sched_class ) { rq -> curr -> sched_class -> check_preempt_curr ( rq , p , flags ) ; } else { for_each_class ( class ) { if ( class == rq -> curr -> sched_class ) break ; if ( class == p -> sched_class ) { resched_task ( rq -> curr ) ; break ; } } }  if ( test_tsk_need_resched ( rq -> curr ) )  rq -> skip_clock_update = 1 ; }",if ( rq -> curr -> se . on_rq && test_tsk_need_resched ( rq -> curr ) ) rq -> skip_clock_update = 1 ;,2743
812,"buggy line: dh_clnt = EVP_PKEY_get0_DH ( ckey ) ;if ( dh_clnt == NULL || ssl_derive ( s , ckey , skey ) == 0 ) {cwe id:CWE-476context: static int tls_construct_cke_dhe ( SSL * s , unsigned char * * p , int * len , int * al ) { # ifndef OPENSSL_NO_DH DH * dh_clnt = NULL ; const BIGNUM * pub_key ; EVP_PKEY * ckey = NULL , * skey = NULL ; skey = s -> s3 -> peer_tmp ; if ( skey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; } ckey = ssl_generate_pkey ( skey ) ;  dh_clnt = EVP_PKEY_get0_DH ( ckey ) ;  if ( dh_clnt == NULL || ssl_derive ( s , ckey , skey ) == 0 ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; EVP_PKEY_free ( ckey ) ; return 0 ; } DH_get0_key ( dh_clnt , & pub_key , NULL ) ; * len = BN_num_bytes ( pub_key ) ; s2n ( * len , * p ) ; BN_bn2bin ( pub_key , * p ) ; * len += 2 ; EVP_PKEY_free ( ckey ) ; return 1 ; # else SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; # endif }","if ( ckey == NULL ) {SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ;return 0 ;}dh_clnt = EVP_PKEY_get0_DH ( ckey ) ;if ( dh_clnt == NULL || ssl_derive ( s , ckey , skey ) == 0 ) {",2744
813,"buggy line: static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ;cwe id:CWE-119context: static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {  vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ; if ( frame != NULL ) { YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp9_copy_reference_enc ( ctx -> cpi , ref_frame_to_vp9_reframe ( frame -> frame_type ) , & sd ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }","static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ;",2745
814,"buggy line: if ( ! in_group_p ( inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  mode &= ~ S_ISGID ;cwe id:CWE-264context: void setattr_copy ( struct inode * inode , const struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; if ( ia_valid & ATTR_ATIME ) inode -> i_atime = timespec_trunc ( attr -> ia_atime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MTIME ) inode -> i_mtime = timespec_trunc ( attr -> ia_mtime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_CTIME ) inode -> i_ctime = timespec_trunc ( attr -> ia_ctime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MODE ) { umode_t mode = attr -> ia_mode ; if ( ! in_group_p ( inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  mode &= ~ S_ISGID ; inode -> i_mode = mode ; } }","if ( ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) mode &= ~ S_ISGID ;",2746
815,"buggy line: int midi_synth_load_patch ( int dev , int format , const char __user * addr ,  int offs , int count , int pmgr_flag )  {cwe id:CWE-189context: int midi_synth_load_patch ( int dev , int format , const char __user * addr ,  int offs , int count , int pmgr_flag )  { int orig_dev = synth_devs [ dev ] -> midi_dev ; struct sysex_info sysex ; int i ; unsigned long left , src_offs , eox_seen = 0 ; int first_byte = 1 ; int hdr_size = ( unsigned long ) & sysex . data [ 0 ] - ( unsigned long ) & sysex ; leave_sysex ( dev ) ; if ( ! prefix_cmd ( orig_dev , 0xf0 ) ) return 0 ; if ( format != SYSEX_PATCH )  {  return - EINVAL ;  }  if ( count < hdr_size )  {  return - EINVAL ;  }  count -= hdr_size ;  if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) )  return - EFAULT ;  if ( count < sysex . len )   {  sysex . len = count ;  }  left = sysex . len ; src_offs = 0 ; for ( i = 0 ; i < left && ! signal_pending ( current ) ; i ++ ) { unsigned char data ; if ( get_user ( data , ( unsigned char __user * ) ( addr + hdr_size + i ) ) ) return - EFAULT ; eox_seen = ( i > 0 && data & 0x80 ) ; if ( eox_seen && data != 0xf7 ) data = 0xf7 ; if ( i == 0 ) { if ( data != 0xf0 ) { printk ( KERN_WARNING ""midi_synth:<S2SV_blank>Sysex<S2SV_blank>start<S2SV_blank>missing\\n"" ) ; return - EINVAL ; } } while ( ! midi_devs [ orig_dev ] -> outputc ( orig_dev , ( unsigned char ) ( data & 0xff ) ) && ! signal_pending ( current ) ) schedule ( ) ; if ( ! first_byte && data & 0x80 ) return 0 ; first_byte = 0 ; } if ( ! eox_seen ) midi_outc ( orig_dev , 0xf7 ) ; return 0 ; }","int midi_synth_load_patch ( int dev , int format , const char __user * addr , int count , int pmgr_flag ) {",2747
816,"buggy line: if ( format != SYSEX_PATCH )  {return - EINVAL ;}if ( count < hdr_size )  {return - EINVAL ;}count -= hdr_size ;if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) )  return - EFAULT ;if ( count < sysex . len )   {sysex . len = count ;}left = sysex . len ;cwe id:CWE-189context: int midi_synth_load_patch ( int dev , int format , const char __user * addr ,  int offs , int count , int pmgr_flag )  { int orig_dev = synth_devs [ dev ] -> midi_dev ; struct sysex_info sysex ; int i ; unsigned long left , src_offs , eox_seen = 0 ; int first_byte = 1 ; int hdr_size = ( unsigned long ) & sysex . data [ 0 ] - ( unsigned long ) & sysex ; leave_sysex ( dev ) ; if ( ! prefix_cmd ( orig_dev , 0xf0 ) ) return 0 ; if ( format != SYSEX_PATCH )  {  return - EINVAL ;  }  if ( count < hdr_size )  {  return - EINVAL ;  }  count -= hdr_size ;  if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) )  return - EFAULT ;  if ( count < sysex . len )   {  sysex . len = count ;  }  left = sysex . len ; src_offs = 0 ; for ( i = 0 ; i < left && ! signal_pending ( current ) ; i ++ ) { unsigned char data ; if ( get_user ( data , ( unsigned char __user * ) ( addr + hdr_size + i ) ) ) return - EFAULT ; eox_seen = ( i > 0 && data & 0x80 ) ; if ( eox_seen && data != 0xf7 ) data = 0xf7 ; if ( i == 0 ) { if ( data != 0xf0 ) { printk ( KERN_WARNING ""midi_synth:<S2SV_blank>Sysex<S2SV_blank>start<S2SV_blank>missing\\n"" ) ; return - EINVAL ; } } while ( ! midi_devs [ orig_dev ] -> outputc ( orig_dev , ( unsigned char ) ( data & 0xff ) ) && ! signal_pending ( current ) ) schedule ( ) ; if ( ! first_byte && data & 0x80 ) return 0 ; first_byte = 0 ; } if ( ! eox_seen ) midi_outc ( orig_dev , 0xf7 ) ; return 0 ; }",if ( format != SYSEX_PATCH ) return - EINVAL ;}if ( count < hdr_size ) {return - EINVAL ;if ( count < sysex . len ) {sysex . len = count ;}left = sysex . len ;,2747
817,buggy line: mk_vhost_close ( sr ) ;}cwe id:CWE-20context: void mk_request_free ( struct session_request * sr ) { if ( sr -> fd_file > 0 ) {  mk_vhost_close ( sr ) ;  } if ( sr -> headers . location ) { mk_mem_free ( sr -> headers . location ) ; } if ( sr -> uri_processed . data != sr -> uri . data ) { mk_ptr_free ( & sr -> uri_processed ) ; } if ( sr -> real_path . data != sr -> real_path_static ) { mk_ptr_free ( & sr -> real_path ) ; } },if ( sr -> fd_is_fdt == MK_TRUE ) {mk_vhost_close ( sr ) ;}else {close ( sr -> fd_file ) ;}},2748
818,"buggy line: }pin -> request_count -- ;cwe id:CWE-416context: static void regulator_ena_gpio_free ( struct regulator_dev * rdev ) { struct regulator_enable_gpio * pin , * n ; if ( ! rdev -> ena_pin ) return ; list_for_each_entry_safe ( pin , n , & regulator_ena_gpio_list , list ) { if ( pin -> gpiod == rdev -> ena_pin -> gpiod ) { if ( pin -> request_count <= 1 ) { pin -> request_count = 0 ; gpiod_put ( pin -> gpiod ) ; list_del ( & pin -> list ) ; kfree ( pin ) ;  } else {  pin -> request_count -- ; } } } }",rdev -> ena_pin = NULL ;return ;}pin -> request_count -- ;,2749
819,"buggy line: int chars_processed ;int elt ;int data_size = ndo -> ndo_snapend - bp ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;chars_processed = 1 ;if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) {cwe id:CWE-835context: const u_char * ns_nprint ( netdissect_options * ndo , register const u_char * cp , register const u_char * bp ) { register u_int i , l ; register const u_char * rp = NULL ; register int compress = 0 ;  int chars_processed ;  int elt ;  int data_size = ndo -> ndo_snapend - bp ;  if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;  chars_processed = 1 ;  if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < ndo -> ndo_snapend ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;  cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;  if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; i = * cp ++ ;  chars_processed ++ ;  if ( chars_processed >= data_size ) { ND_PRINT ( ( ndo , ""<LOOP>"" ) ) ; return ( NULL ) ; } continue ; } if ( ( i & INDIR_MASK ) == EDNS0_MASK ) { elt = ( i & ~ INDIR_MASK ) ; switch ( elt ) { case EDNS0_ELT_BITLABEL : if ( blabel_print ( ndo , cp ) == NULL ) return ( NULL ) ; break ; default : ND_PRINT ( ( ndo , ""<ELT<S2SV_blank>%d>"" , elt ) ) ; return ( NULL ) ; } } else { if ( fn_printn ( ndo , cp , l , ndo -> ndo_snapend ) ) return ( NULL ) ; } cp += l ;  chars_processed += l ;  ND_PRINT ( ( ndo , ""."" ) ) ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; i = * cp ++ ;  chars_processed ++ ;  if ( ! compress ) rp += l + 1 ; } else ND_PRINT ( ( ndo , ""."" ) ) ; return ( rp ) ; }","int elt ;u_int offset , max_offset ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;max_offset = ( u_int ) ( cp - bp ) ;if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) {",2750
820,"buggy line: cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;chars_processed ++ ;if ( chars_processed >= data_size ) {cwe id:CWE-835context: const u_char * ns_nprint ( netdissect_options * ndo , register const u_char * cp , register const u_char * bp ) { register u_int i , l ; register const u_char * rp = NULL ; register int compress = 0 ;  int chars_processed ;  int elt ;  int data_size = ndo -> ndo_snapend - bp ;  if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;  chars_processed = 1 ;  if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < ndo -> ndo_snapend ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;  cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;  if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; i = * cp ++ ;  chars_processed ++ ;  if ( chars_processed >= data_size ) { ND_PRINT ( ( ndo , ""<LOOP>"" ) ) ; return ( NULL ) ; } continue ; } if ( ( i & INDIR_MASK ) == EDNS0_MASK ) { elt = ( i & ~ INDIR_MASK ) ; switch ( elt ) { case EDNS0_ELT_BITLABEL : if ( blabel_print ( ndo , cp ) == NULL ) return ( NULL ) ; break ; default : ND_PRINT ( ( ndo , ""<ELT<S2SV_blank>%d>"" , elt ) ) ; return ( NULL ) ; } } else { if ( fn_printn ( ndo , cp , l , ndo -> ndo_snapend ) ) return ( NULL ) ; } cp += l ;  chars_processed += l ;  ND_PRINT ( ( ndo , ""."" ) ) ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; i = * cp ++ ;  chars_processed ++ ;  if ( ! compress ) rp += l + 1 ; } else ND_PRINT ( ( ndo , ""."" ) ) ; return ( rp ) ; }","offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;if ( offset >= max_offset ) {ND_PRINT ( ( ndo , ""<BAD<S2SV_blank>PTR>"" ) ) ;return ( NULL ) ;}max_offset = offset ;cp = bp + offset ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;chars_processed ++ ;if ( chars_processed >= data_size ) {",2750
821,"buggy line: chars_processed += l ;ND_PRINT ( ( ndo , ""."" ) ) ;chars_processed ++ ;if ( ! compress ) rp += l + 1 ;cwe id:CWE-835context: const u_char * ns_nprint ( netdissect_options * ndo , register const u_char * cp , register const u_char * bp ) { register u_int i , l ; register const u_char * rp = NULL ; register int compress = 0 ;  int chars_processed ;  int elt ;  int data_size = ndo -> ndo_snapend - bp ;  if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;  chars_processed = 1 ;  if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < ndo -> ndo_snapend ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;  cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;  if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; i = * cp ++ ;  chars_processed ++ ;  if ( chars_processed >= data_size ) { ND_PRINT ( ( ndo , ""<LOOP>"" ) ) ; return ( NULL ) ; } continue ; } if ( ( i & INDIR_MASK ) == EDNS0_MASK ) { elt = ( i & ~ INDIR_MASK ) ; switch ( elt ) { case EDNS0_ELT_BITLABEL : if ( blabel_print ( ndo , cp ) == NULL ) return ( NULL ) ; break ; default : ND_PRINT ( ( ndo , ""<ELT<S2SV_blank>%d>"" , elt ) ) ; return ( NULL ) ; } } else { if ( fn_printn ( ndo , cp , l , ndo -> ndo_snapend ) ) return ( NULL ) ; } cp += l ;  chars_processed += l ;  ND_PRINT ( ( ndo , ""."" ) ) ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; i = * cp ++ ;  chars_processed ++ ;  if ( ! compress ) rp += l + 1 ; } else ND_PRINT ( ( ndo , ""."" ) ) ; return ( rp ) ; }","ND_PRINT ( ( ndo , ""."" ) ) ;if ( ! compress ) rp += l + 1 ;",2750
822,"buggy line: if ( ! valid_localpart ( maddr -> user ) ||   ! valid_domainpart ( maddr -> domain ) ) {if ( mailfrom && maddr -> user [ 0 ] == '\\\\0' && maddr -> domain [ 0 ] == '\\\\0' ) return ( 1 ) ;cwe id:CWE-252context: static int smtp_mailaddr ( struct mailaddr * maddr , char * line , int mailfrom , char * * args , const char * domain ) { char * p , * e ; if ( line == NULL ) return ( 0 ) ; if ( * line != '<' ) return ( 0 ) ; e = strchr ( line , '>' ) ; if ( e == NULL ) return ( 0 ) ; * e ++ = '\\0' ; while ( * e == '<S2SV_blank>' ) e ++ ; * args = e ; if ( ! text_to_mailaddr ( maddr , line + 1 ) ) return ( 0 ) ; p = strchr ( maddr -> user , ':' ) ; if ( p != NULL ) { p ++ ; memmove ( maddr -> user , p , strlen ( p ) + 1 ) ; }  if ( ! valid_localpart ( maddr -> user ) ||   ! valid_domainpart ( maddr -> domain ) ) {  if ( mailfrom && maddr -> user [ 0 ] == '\\0' && maddr -> domain [ 0 ] == '\\0' ) return ( 1 ) ; if ( maddr -> user [ 0 ] == '\\0' ) return ( 0 ) ; if ( maddr -> domain [ 0 ] == '\\0' ) { ( void ) strlcpy ( maddr -> domain , domain , sizeof ( maddr -> domain ) ) ; return ( 1 ) ; } return ( 0 ) ; } return ( 1 ) ; }","if ( mailfrom && maddr -> user [ 0 ] == '\\\\0' && maddr -> domain [ 0 ] == '\\\\0' ) return ( 1 ) ;if ( maddr -> user [ 0 ] == '\\\\0' || ! valid_localpart ( maddr -> user ) ) return ( 0 ) ;if ( maddr -> domain [ 0 ] == '\\\\0' ) {( void ) strlcpy ( maddr -> domain , domain , sizeof ( maddr -> domain ) ) return ( 0 ) ;return ( 1 ) ;",2751
823,"buggy line: return send ( socket -> fd , buf , count , MSG_DONTWAIT ) ;}cwe id:CWE-284context: ssize_t socket_write ( const socket_t * socket , const void * buf , size_t count ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ;  return send ( socket -> fd , buf , count , MSG_DONTWAIT ) ;  }","return TEMP_FAILURE_RETRY ( send ( socket -> fd , buf , count , MSG_DONTWAIT ) ) ;}",2752
824,"buggy line: static int input_stats ( struct twopass_rc * p , FIRSTPASS_STATS * fps ) {if ( p -> stats_in >= p -> stats_in_end ) return EOF ;cwe id:CWE-119context:  static int input_stats ( struct twopass_rc * p , FIRSTPASS_STATS * fps ) {  if ( p -> stats_in >= p -> stats_in_end ) return EOF ; * fps = * p -> stats_in ; ++ p -> stats_in ; return 1 ; }","static int input_stats ( TWO_PASS * p , FIRSTPASS_STATS * fps ) {if ( p -> stats_in >= p -> stats_in_end ) return EOF ;",2753
825,"buggy line: # ifdef CONFIG_SWAP  if ( ! file ) {* prev = vma ;force_swapin_readahead ( vma , start , end ) ;* prev = vma ;force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ;# else if ( ! file ) return - EBADF ;# endif if ( IS_DAX ( file_inode ( file ) ) ) {return 0 ;}* prev = vma ;start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;cwe id:CWE-835context: static long madvise_willneed ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { struct file * file = vma -> vm_file ;  # ifdef CONFIG_SWAP  if ( ! file ) {  * prev = vma ;  force_swapin_readahead ( vma , start , end ) ; return 0 ; } if ( shmem_mapping ( file -> f_mapping ) ) {  * prev = vma ;  force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ; return 0 ; } # else if ( ! file ) return - EBADF ; # endif if ( IS_DAX ( file_inode ( file ) ) ) { return 0 ; }  * prev = vma ;  start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; if ( end > vma -> vm_end ) end = vma -> vm_end ; end = ( ( end - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; force_page_cache_readahead ( file -> f_mapping , file , start , end - start ) ; return 0 ; }","* prev = vma ;# ifdef CONFIG_SWAP if ( ! file ) {force_swapin_readahead ( vma , start , end ) ;force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ;start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;",2754
826,"buggy line: cwe id:CWE-834context: static MagickBooleanType ReadPSDLayersInternal ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , const MagickBooleanType skip_layers , ExceptionInfo * exception ) { char type [ 4 ] ; LayerInfo * layer_info ; MagickSizeType size ; MagickBooleanType status ; register ssize_t i ; ssize_t count , j , number_layers ; size = GetPSDSize ( psd_info , image ) ; if ( size == 0 ) { ( void ) ReadBlobLong ( image ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; status = MagickFalse ; if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) return ( MagickTrue ) ; else { count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count != 0 ) && ( LocaleNCompare ( type , ""Lr16"" , 4 ) == 0 ) ) size = GetPSDSize ( psd_info , image ) ; else return ( MagickTrue ) ; } } status = MagickTrue ; if ( size != 0 ) { layer_info = ( LayerInfo * ) NULL ; number_layers = ( short ) ReadBlobShort ( image ) ; if ( number_layers < 0 ) { number_layers = MagickAbsoluteValue ( number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>negative<S2SV_blank>layer<S2SV_blank>count<S2SV_blank>corrected<S2SV_blank>for"" ) ; image -> matte = MagickTrue ; } if ( skip_layers != MagickFalse ) return ( MagickTrue ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>image<S2SV_blank>contains<S2SV_blank>%.20g<S2SV_blank>layers"" , ( double ) number_layers ) ; if ( number_layers == 0 ) ThrowBinaryException ( CorruptImageError , ""InvalidNumberOfLayers"" , image -> filename ) ; layer_info = ( LayerInfo * ) AcquireQuantumMemory ( ( size_t ) number_layers , sizeof ( * layer_info ) ) ; if ( layer_info == ( LayerInfo * ) NULL ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>LayerInfo<S2SV_blank>failed"" ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } ( void ) ResetMagickMemory ( layer_info , 0 , ( size_t ) number_layers * sizeof ( * layer_info ) ) ; for ( i = 0 ; i < number_layers ; i ++ ) { ssize_t x , y ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>layer<S2SV_blank>#%.20g"" , ( double ) i + 1 ) ; layer_info [ i ] . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . x = ReadBlobSignedLong ( image ) ; y = ReadBlobSignedLong ( image ) ; x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . width = ( size_t ) ( x - layer_info [ i ] . page . x ) ; layer_info [ i ] . page . height = ( size_t ) ( y - layer_info [ i ] . page . y ) ; layer_info [ i ] . channels = ReadBlobShort ( image ) ; if ( layer_info [ i ] . channels > MaxPSDChannels ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""MaximumChannelsExceeded"" , image -> filename ) ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>channels=%.20g"" , ( double ) layer_info [ i ] . page . x , ( double ) layer_info [ i ] . page . y , ( double ) layer_info [ i ] . page . height , ( double ) layer_info [ i ] . page . width , ( double ) layer_info [ i ] . channels ) ; for ( j = 0 ; j < ( ssize_t ) layer_info [ i ] . channels ; j ++ ) { layer_info [ i ] . channel_info [ j ] . type = ( short ) ReadBlobShort ( image ) ; layer_info [ i ] . channel_info [ j ] . size = ( size_t ) GetPSDSize ( psd_info , image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>channel[%.20g]:<S2SV_blank>type=%.20g,<S2SV_blank>size=%.20g"" , ( double ) j , ( double ) layer_info [ i ] . channel_info [ j ] . type , ( double ) layer_info [ i ] . channel_info [ j ] . size ) ; } count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>layer<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%.4s<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>8BIM"" , type ) ; layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""ImproperImageHeader"" , image -> filename ) ; } ( void ) ReadBlob ( image , 4 , ( unsigned char * ) layer_info [ i ] . blendkey ) ; ReversePSDString ( image , layer_info [ i ] . blendkey , 4 ) ; layer_info [ i ] . opacity = ( Quantum ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; layer_info [ i ] . clipping = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . flags = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . visible = ! ( layer_info [ i ] . flags & 0x02 ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>blend=%.4s,<S2SV_blank>opacity=%.20g,<S2SV_blank>clipping=%s,<S2SV_blank>flags=%d,<S2SV_blank>visible=%s"" , layer_info [ i ] . blendkey , ( double ) layer_info [ i ] . opacity , layer_info [ i ] . clipping ? ""true"" : ""false"" , layer_info [ i ] . flags , layer_info [ i ] . visible ? ""true"" : ""false"" ) ; ( void ) ReadBlobByte ( image ) ; size = ReadBlobLong ( image ) ; if ( size != 0 ) { MagickSizeType combined_length , length ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>contains<S2SV_blank>additional<S2SV_blank>info"" ) ; length = ReadBlobLong ( image ) ; combined_length = length + 4 ; if ( length != 0 ) { layer_info [ i ] . mask . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . height = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . y ) ; layer_info [ i ] . mask . page . width = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . x ) ; layer_info [ i ] . mask . background = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . mask . flags = ( unsigned char ) ReadBlobByte ( image ) ; if ( ! ( layer_info [ i ] . mask . flags & 0x01 ) ) { layer_info [ i ] . mask . page . y = layer_info [ i ] . mask . page . y - layer_info [ i ] . page . y ; layer_info [ i ] . mask . page . x = layer_info [ i ] . mask . page . x - layer_info [ i ] . page . x ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>mask:<S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>length=%.20g"" , ( double ) layer_info [ i ] . mask . page . x , ( double ) layer_info [ i ] . mask . page . y , ( double ) layer_info [ i ] . mask . page . width , ( double ) layer_info [ i ] . mask . page . height , ( double ) ( ( MagickOffsetType ) length ) - 18 ) ; if ( DiscardBlobBytes ( image , ( MagickSizeType ) ( length - 18 ) ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } length = ReadBlobLong ( image ) ; combined_length += length + 4 ; if ( length != 0 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>blending<S2SV_blank>ranges:<S2SV_blank>length=%.20g"" , ( double ) ( ( MagickOffsetType ) length ) ) ; for ( j = 0 ; j < ( ssize_t ) length ; j += 8 ) { size_t blend_source = ReadBlobLong ( image ) ; size_t blend_dest = ReadBlobLong ( image ) ;  if ( image -> debug != MagickFalse )  ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ; } } length = ( MagickSizeType ) ( unsigned char ) ReadBlobByte ( image ) ; combined_length += length + 1 ; if ( length > 0 ) ( void ) ReadBlob ( image , ( size_t ) length ++ , layer_info [ i ] . name ) ; layer_info [ i ] . name [ length ] = '\\0' ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>name:<S2SV_blank>%s"" , layer_info [ i ] . name ) ; if ( ( length % 4 ) != 0 ) { length = 4 - ( length % 4 ) ; combined_length += length ; if ( DiscardBlobBytes ( image , length ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } length = ( MagickSizeType ) size - combined_length ; if ( length > 0 ) { unsigned char * info ; if ( length > GetBlobSize ( image ) ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ; } layer_info [ i ] . info = AcquireStringInfo ( ( const size_t ) length ) ; info = GetStringInfoDatum ( layer_info [ i ] . info ) ; ( void ) ReadBlob ( image , ( const size_t ) length , info ) ; } } } for ( i = 0 ; i < number_layers ; i ++ ) { if ( ( layer_info [ i ] . page . width == 0 ) || ( layer_info [ i ] . page . height == 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>data<S2SV_blank>is<S2SV_blank>empty"" ) ; if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; continue ; } layer_info [ i ] . image = CloneImage ( image , layer_info [ i ] . page . width , layer_info [ i ] . page . height , MagickFalse , exception ) ; if ( layer_info [ i ] . image == ( Image * ) NULL ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>image<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g<S2SV_blank>failed"" , ( double ) i ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) { ( void ) SetImageProfile ( layer_info [ i ] . image , ""psd:additional-info"" , layer_info [ i ] . info ) ; layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; } } if ( image_info -> ping == MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = 0 ; j < layer_info [ i ] . channels ; j ++ ) { if ( DiscardBlobBytes ( image , ( MagickSizeType ) layer_info [ i ] . channel_info [ j ] . size ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } continue ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>data<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g"" , ( double ) i ) ; status = ReadPSDLayer ( image , image_info , psd_info , & layer_info [ i ] , exception ) ; if ( status == MagickFalse ) break ; status = SetImageProgress ( image , LoadImagesTag , i , ( MagickSizeType ) number_layers ) ; if ( status == MagickFalse ) break ; } } if ( status != MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = i ; j < number_layers - 1 ; j ++ ) layer_info [ j ] = layer_info [ j + 1 ] ; number_layers -- ; i -- ; } } if ( number_layers > 0 ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( i > 0 ) layer_info [ i ] . image -> previous = layer_info [ i - 1 ] . image ; if ( i < ( number_layers - 1 ) ) layer_info [ i ] . image -> next = layer_info [ i + 1 ] . image ; layer_info [ i ] . image -> page = layer_info [ i ] . page ; } image -> next = layer_info [ 0 ] . image ; layer_info [ 0 ] . image -> previous = image ; } layer_info = ( LayerInfo * ) RelinquishMagickMemory ( layer_info ) ; } else layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; } return ( status ) ; }","if ( EOFBlob ( image ) != MagickFalse ) {layer_info = DestroyLayerInfo ( layer_info , number_layers ) ;ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ;}",2755
827,"buggy line: if ( image -> debug != MagickFalse )  ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ;cwe id:CWE-834context: static MagickBooleanType ReadPSDLayersInternal ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , const MagickBooleanType skip_layers , ExceptionInfo * exception ) { char type [ 4 ] ; LayerInfo * layer_info ; MagickSizeType size ; MagickBooleanType status ; register ssize_t i ; ssize_t count , j , number_layers ; size = GetPSDSize ( psd_info , image ) ; if ( size == 0 ) { ( void ) ReadBlobLong ( image ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; status = MagickFalse ; if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) return ( MagickTrue ) ; else { count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count != 0 ) && ( LocaleNCompare ( type , ""Lr16"" , 4 ) == 0 ) ) size = GetPSDSize ( psd_info , image ) ; else return ( MagickTrue ) ; } } status = MagickTrue ; if ( size != 0 ) { layer_info = ( LayerInfo * ) NULL ; number_layers = ( short ) ReadBlobShort ( image ) ; if ( number_layers < 0 ) { number_layers = MagickAbsoluteValue ( number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>negative<S2SV_blank>layer<S2SV_blank>count<S2SV_blank>corrected<S2SV_blank>for"" ) ; image -> matte = MagickTrue ; } if ( skip_layers != MagickFalse ) return ( MagickTrue ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>image<S2SV_blank>contains<S2SV_blank>%.20g<S2SV_blank>layers"" , ( double ) number_layers ) ; if ( number_layers == 0 ) ThrowBinaryException ( CorruptImageError , ""InvalidNumberOfLayers"" , image -> filename ) ; layer_info = ( LayerInfo * ) AcquireQuantumMemory ( ( size_t ) number_layers , sizeof ( * layer_info ) ) ; if ( layer_info == ( LayerInfo * ) NULL ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>LayerInfo<S2SV_blank>failed"" ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } ( void ) ResetMagickMemory ( layer_info , 0 , ( size_t ) number_layers * sizeof ( * layer_info ) ) ; for ( i = 0 ; i < number_layers ; i ++ ) { ssize_t x , y ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>layer<S2SV_blank>#%.20g"" , ( double ) i + 1 ) ; layer_info [ i ] . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . x = ReadBlobSignedLong ( image ) ; y = ReadBlobSignedLong ( image ) ; x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . width = ( size_t ) ( x - layer_info [ i ] . page . x ) ; layer_info [ i ] . page . height = ( size_t ) ( y - layer_info [ i ] . page . y ) ; layer_info [ i ] . channels = ReadBlobShort ( image ) ; if ( layer_info [ i ] . channels > MaxPSDChannels ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""MaximumChannelsExceeded"" , image -> filename ) ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>channels=%.20g"" , ( double ) layer_info [ i ] . page . x , ( double ) layer_info [ i ] . page . y , ( double ) layer_info [ i ] . page . height , ( double ) layer_info [ i ] . page . width , ( double ) layer_info [ i ] . channels ) ; for ( j = 0 ; j < ( ssize_t ) layer_info [ i ] . channels ; j ++ ) { layer_info [ i ] . channel_info [ j ] . type = ( short ) ReadBlobShort ( image ) ; layer_info [ i ] . channel_info [ j ] . size = ( size_t ) GetPSDSize ( psd_info , image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>channel[%.20g]:<S2SV_blank>type=%.20g,<S2SV_blank>size=%.20g"" , ( double ) j , ( double ) layer_info [ i ] . channel_info [ j ] . type , ( double ) layer_info [ i ] . channel_info [ j ] . size ) ; } count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>layer<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%.4s<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>8BIM"" , type ) ; layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""ImproperImageHeader"" , image -> filename ) ; } ( void ) ReadBlob ( image , 4 , ( unsigned char * ) layer_info [ i ] . blendkey ) ; ReversePSDString ( image , layer_info [ i ] . blendkey , 4 ) ; layer_info [ i ] . opacity = ( Quantum ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; layer_info [ i ] . clipping = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . flags = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . visible = ! ( layer_info [ i ] . flags & 0x02 ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>blend=%.4s,<S2SV_blank>opacity=%.20g,<S2SV_blank>clipping=%s,<S2SV_blank>flags=%d,<S2SV_blank>visible=%s"" , layer_info [ i ] . blendkey , ( double ) layer_info [ i ] . opacity , layer_info [ i ] . clipping ? ""true"" : ""false"" , layer_info [ i ] . flags , layer_info [ i ] . visible ? ""true"" : ""false"" ) ; ( void ) ReadBlobByte ( image ) ; size = ReadBlobLong ( image ) ; if ( size != 0 ) { MagickSizeType combined_length , length ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>contains<S2SV_blank>additional<S2SV_blank>info"" ) ; length = ReadBlobLong ( image ) ; combined_length = length + 4 ; if ( length != 0 ) { layer_info [ i ] . mask . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . height = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . y ) ; layer_info [ i ] . mask . page . width = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . x ) ; layer_info [ i ] . mask . background = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . mask . flags = ( unsigned char ) ReadBlobByte ( image ) ; if ( ! ( layer_info [ i ] . mask . flags & 0x01 ) ) { layer_info [ i ] . mask . page . y = layer_info [ i ] . mask . page . y - layer_info [ i ] . page . y ; layer_info [ i ] . mask . page . x = layer_info [ i ] . mask . page . x - layer_info [ i ] . page . x ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>mask:<S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>length=%.20g"" , ( double ) layer_info [ i ] . mask . page . x , ( double ) layer_info [ i ] . mask . page . y , ( double ) layer_info [ i ] . mask . page . width , ( double ) layer_info [ i ] . mask . page . height , ( double ) ( ( MagickOffsetType ) length ) - 18 ) ; if ( DiscardBlobBytes ( image , ( MagickSizeType ) ( length - 18 ) ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } length = ReadBlobLong ( image ) ; combined_length += length + 4 ; if ( length != 0 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>blending<S2SV_blank>ranges:<S2SV_blank>length=%.20g"" , ( double ) ( ( MagickOffsetType ) length ) ) ; for ( j = 0 ; j < ( ssize_t ) length ; j += 8 ) { size_t blend_source = ReadBlobLong ( image ) ; size_t blend_dest = ReadBlobLong ( image ) ;  if ( image -> debug != MagickFalse )  ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ; } } length = ( MagickSizeType ) ( unsigned char ) ReadBlobByte ( image ) ; combined_length += length + 1 ; if ( length > 0 ) ( void ) ReadBlob ( image , ( size_t ) length ++ , layer_info [ i ] . name ) ; layer_info [ i ] . name [ length ] = '\\0' ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>name:<S2SV_blank>%s"" , layer_info [ i ] . name ) ; if ( ( length % 4 ) != 0 ) { length = 4 - ( length % 4 ) ; combined_length += length ; if ( DiscardBlobBytes ( image , length ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } length = ( MagickSizeType ) size - combined_length ; if ( length > 0 ) { unsigned char * info ; if ( length > GetBlobSize ( image ) ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ; } layer_info [ i ] . info = AcquireStringInfo ( ( const size_t ) length ) ; info = GetStringInfoDatum ( layer_info [ i ] . info ) ; ( void ) ReadBlob ( image , ( const size_t ) length , info ) ; } } } for ( i = 0 ; i < number_layers ; i ++ ) { if ( ( layer_info [ i ] . page . width == 0 ) || ( layer_info [ i ] . page . height == 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>data<S2SV_blank>is<S2SV_blank>empty"" ) ; if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; continue ; } layer_info [ i ] . image = CloneImage ( image , layer_info [ i ] . page . width , layer_info [ i ] . page . height , MagickFalse , exception ) ; if ( layer_info [ i ] . image == ( Image * ) NULL ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>image<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g<S2SV_blank>failed"" , ( double ) i ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) { ( void ) SetImageProfile ( layer_info [ i ] . image , ""psd:additional-info"" , layer_info [ i ] . info ) ; layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; } } if ( image_info -> ping == MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = 0 ; j < layer_info [ i ] . channels ; j ++ ) { if ( DiscardBlobBytes ( image , ( MagickSizeType ) layer_info [ i ] . channel_info [ j ] . size ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } continue ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>data<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g"" , ( double ) i ) ; status = ReadPSDLayer ( image , image_info , psd_info , & layer_info [ i ] , exception ) ; if ( status == MagickFalse ) break ; status = SetImageProgress ( image , LoadImagesTag , i , ( MagickSizeType ) number_layers ) ; if ( status == MagickFalse ) break ; } } if ( status != MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = i ; j < number_layers - 1 ; j ++ ) layer_info [ j ] = layer_info [ j + 1 ] ; number_layers -- ; i -- ; } } if ( number_layers > 0 ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( i > 0 ) layer_info [ i ] . image -> previous = layer_info [ i - 1 ] . image ; if ( i < ( number_layers - 1 ) ) layer_info [ i ] . image -> next = layer_info [ i + 1 ] . image ; layer_info [ i ] . image -> page = layer_info [ i ] . page ; } image -> next = layer_info [ 0 ] . image ; layer_info [ 0 ] . image -> previous = image ; } layer_info = ( LayerInfo * ) RelinquishMagickMemory ( layer_info ) ; } else layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; } return ( status ) ; }","if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ;",2755
828,"buggy line: bool __net_get_random_once ( void * buf , int nbytes , bool * done ,  struct static_key * done_key )  {cwe id:CWE-200context: bool __net_get_random_once ( void * buf , int nbytes , bool * done ,  struct static_key * done_key )  { static DEFINE_SPINLOCK ( lock ) ; unsigned long flags ; spin_lock_irqsave ( & lock , flags ) ; if ( * done ) { spin_unlock_irqrestore ( & lock , flags ) ; return false ; } get_random_bytes ( buf , nbytes ) ; * done = true ; spin_unlock_irqrestore ( & lock , flags ) ;  __net_random_once_disable_jump ( done_key ) ;  return true ; }","bool __net_get_random_once ( void * buf , int nbytes , bool * done , struct static_key * once_key ) {",2756
829,"buggy line: __net_random_once_disable_jump ( done_key ) ;return true ;cwe id:CWE-200context: bool __net_get_random_once ( void * buf , int nbytes , bool * done ,  struct static_key * done_key )  { static DEFINE_SPINLOCK ( lock ) ; unsigned long flags ; spin_lock_irqsave ( & lock , flags ) ; if ( * done ) { spin_unlock_irqrestore ( & lock , flags ) ; return false ; } get_random_bytes ( buf , nbytes ) ; * done = true ; spin_unlock_irqrestore ( & lock , flags ) ;  __net_random_once_disable_jump ( done_key ) ;  return true ; }",__net_random_once_disable_jump ( once_key ) ;return true ;,2756
830,"buggy line: unsigned int var = block_variance ( cpi , x , bs ) ;vp9_clear_system_state ( ) ;energy = 0.9 * ( log ( var + 1.0 ) - 10.0 ) ;cwe id:CWE-119context: int vp9_block_energy ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bs ) { double energy ;  unsigned int var = block_variance ( cpi , x , bs ) ;  vp9_clear_system_state ( ) ; energy = 0.9 * ( log ( var + 1.0 ) - 10.0 ) ; return clamp ( ( int ) round ( energy ) , ENERGY_MIN , ENERGY_MAX ) ; }","double energy_midpoint ;vpx_clear_system_state ( ) ;energy_midpoint = ( cpi -> oxcf . pass == 2 ) ? cpi -> twopass . mb_av_energy : DEFAULT_E_MIDPOINT ;energy = vp9_log_block_var ( cpi , x , bs ) - energy_midpoint ;",2757
831,"buggy line: static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {cwe id:CWE-119context:  static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) { vpx_svc_layer_id_t * const data = va_arg ( args , vpx_svc_layer_id_t * ) ; VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ; SVC * const svc = & cpi -> svc ; svc -> spatial_layer_id = data -> spatial_layer_id ; svc -> temporal_layer_id = data -> temporal_layer_id ; if ( svc -> temporal_layer_id < 0 || svc -> temporal_layer_id >= ( int ) ctx -> cfg . ts_number_layers ) { return VPX_CODEC_INVALID_PARAM ; } if ( svc -> spatial_layer_id < 0 || svc -> spatial_layer_id >= ( int ) ctx -> cfg . ss_number_layers ) { return VPX_CODEC_INVALID_PARAM ; } return VPX_CODEC_OK ; }","static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2758
832,"buggy line: srose -> srose_family = AF_ROSE ;srose -> srose_addr = rose -> dest_addr ;cwe id:CWE-200context: static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rose_sock * rose = rose_sk ( sk ) ; struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( srose != NULL ) {  srose -> srose_family = AF_ROSE ;  srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }","memset ( srose , 0 , msg -> msg_namelen ) ;srose -> srose_family = AF_ROSE ;srose -> srose_addr = rose -> dest_addr ;",2759
833,"buggy line: static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options )  {cwe id:CWE-264context:  static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options )  { char * p ; int rc = 0 ; int sig_set = 0 ; int cipher_name_set = 0 ; int fn_cipher_name_set = 0 ; int cipher_key_bytes ; int cipher_key_bytes_set = 0 ; int fn_cipher_key_bytes ; int fn_cipher_key_bytes_set = 0 ; struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; substring_t args [ MAX_OPT_ARGS ] ; int token ; char * sig_src ; char * cipher_name_dst ; char * cipher_name_src ; char * fn_cipher_name_dst ; char * fn_cipher_name_src ; char * fnek_dst ; char * fnek_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ;  if ( ! options ) {  rc = - EINVAL ; goto out ; } ecryptfs_init_mount_crypt_stat ( mount_crypt_stat ) ; while ( ( p = strsep ( & options , "","" ) ) != NULL ) { if ( ! * p ) continue ; token = match_token ( p , tokens , args ) ; switch ( token ) { case ecryptfs_opt_sig : case ecryptfs_opt_ecryptfs_sig : sig_src = args [ 0 ] . from ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>"" ""global<S2SV_blank>sig;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , rc ) ; goto out ; } sig_set = 1 ; break ; case ecryptfs_opt_cipher : case ecryptfs_opt_ecryptfs_cipher : cipher_name_src = args [ 0 ] . from ; cipher_name_dst = mount_crypt_stat -> global_default_cipher_name ; strncpy ( cipher_name_dst , cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; cipher_name_set = 1 ; break ; case ecryptfs_opt_ecryptfs_key_bytes : cipher_key_bytes_src = args [ 0 ] . from ; cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes ; cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_passthrough : mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED ; break ; case ecryptfs_opt_xattr_metadata : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; break ; case ecryptfs_opt_encrypted_view : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED ; break ; case ecryptfs_opt_fnek_sig : fnek_src = args [ 0 ] . from ; fnek_dst = mount_crypt_stat -> global_default_fnek_sig ; strncpy ( fnek_dst , fnek_src , ECRYPTFS_SIG_SIZE_HEX ) ; mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\\0' ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>"" ""global<S2SV_blank>fnek<S2SV_blank>sig<S2SV_blank>[%s];<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fnek_sig , rc ) ; goto out ; } mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ) ; break ; case ecryptfs_opt_fn_cipher : fn_cipher_name_src = args [ 0 ] . from ; fn_cipher_name_dst = mount_crypt_stat -> global_default_fn_cipher_name ; strncpy ( fn_cipher_name_dst , fn_cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; fn_cipher_name_set = 1 ; break ; case ecryptfs_opt_fn_cipher_key_bytes : fn_cipher_key_bytes_src = args [ 0 ] . from ; fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes ; fn_cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_unlink_sigs : mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS ; break ; case ecryptfs_opt_mount_auth_tok_only : mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY ; break ;  case ecryptfs_opt_err :  default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\n"" , __func__ , p ) ; } } if ( ! sig_set ) { rc = - EINVAL ; ecryptfs_printk ( KERN_ERR , ""You<S2SV_blank>must<S2SV_blank>supply<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>valid<S2SV_blank>"" ""auth<S2SV_blank>tok<S2SV_blank>signature<S2SV_blank>as<S2SV_blank>a<S2SV_blank>mount<S2SV_blank>"" ""parameter;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>eCryptfs<S2SV_blank>README\\n"" ) ; goto out ; } if ( ! cipher_name_set ) { int cipher_name_len = strlen ( ECRYPTFS_DEFAULT_CIPHER ) ; BUG_ON ( cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ) ; } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set ) strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ) ; if ( ! cipher_key_bytes_set ) mount_crypt_stat -> global_default_cipher_key_size = 0 ; if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set ) mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size ; mutex_lock ( & key_tfm_list_mutex ) ; if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>"" ""rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>"" ""rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } mutex_unlock ( & key_tfm_list_mutex ) ; rc = ecryptfs_init_global_auth_toks ( mount_crypt_stat ) ; if ( rc ) printk ( KERN_WARNING ""One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>global<S2SV_blank>auth<S2SV_blank>toks<S2SV_blank>could<S2SV_blank>not<S2SV_blank>"" ""properly<S2SV_blank>register;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , rc ) ; out : return rc ; }","static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options , uid_t * check_ruid ) {",2760
834,"buggy line: if ( ! options ) {rc = - EINVAL ;cwe id:CWE-264context:  static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options )  { char * p ; int rc = 0 ; int sig_set = 0 ; int cipher_name_set = 0 ; int fn_cipher_name_set = 0 ; int cipher_key_bytes ; int cipher_key_bytes_set = 0 ; int fn_cipher_key_bytes ; int fn_cipher_key_bytes_set = 0 ; struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; substring_t args [ MAX_OPT_ARGS ] ; int token ; char * sig_src ; char * cipher_name_dst ; char * cipher_name_src ; char * fn_cipher_name_dst ; char * fn_cipher_name_src ; char * fnek_dst ; char * fnek_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ;  if ( ! options ) {  rc = - EINVAL ; goto out ; } ecryptfs_init_mount_crypt_stat ( mount_crypt_stat ) ; while ( ( p = strsep ( & options , "","" ) ) != NULL ) { if ( ! * p ) continue ; token = match_token ( p , tokens , args ) ; switch ( token ) { case ecryptfs_opt_sig : case ecryptfs_opt_ecryptfs_sig : sig_src = args [ 0 ] . from ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>"" ""global<S2SV_blank>sig;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , rc ) ; goto out ; } sig_set = 1 ; break ; case ecryptfs_opt_cipher : case ecryptfs_opt_ecryptfs_cipher : cipher_name_src = args [ 0 ] . from ; cipher_name_dst = mount_crypt_stat -> global_default_cipher_name ; strncpy ( cipher_name_dst , cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; cipher_name_set = 1 ; break ; case ecryptfs_opt_ecryptfs_key_bytes : cipher_key_bytes_src = args [ 0 ] . from ; cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes ; cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_passthrough : mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED ; break ; case ecryptfs_opt_xattr_metadata : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; break ; case ecryptfs_opt_encrypted_view : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED ; break ; case ecryptfs_opt_fnek_sig : fnek_src = args [ 0 ] . from ; fnek_dst = mount_crypt_stat -> global_default_fnek_sig ; strncpy ( fnek_dst , fnek_src , ECRYPTFS_SIG_SIZE_HEX ) ; mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\\0' ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>"" ""global<S2SV_blank>fnek<S2SV_blank>sig<S2SV_blank>[%s];<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fnek_sig , rc ) ; goto out ; } mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ) ; break ; case ecryptfs_opt_fn_cipher : fn_cipher_name_src = args [ 0 ] . from ; fn_cipher_name_dst = mount_crypt_stat -> global_default_fn_cipher_name ; strncpy ( fn_cipher_name_dst , fn_cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; fn_cipher_name_set = 1 ; break ; case ecryptfs_opt_fn_cipher_key_bytes : fn_cipher_key_bytes_src = args [ 0 ] . from ; fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes ; fn_cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_unlink_sigs : mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS ; break ; case ecryptfs_opt_mount_auth_tok_only : mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY ; break ;  case ecryptfs_opt_err :  default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\n"" , __func__ , p ) ; } } if ( ! sig_set ) { rc = - EINVAL ; ecryptfs_printk ( KERN_ERR , ""You<S2SV_blank>must<S2SV_blank>supply<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>valid<S2SV_blank>"" ""auth<S2SV_blank>tok<S2SV_blank>signature<S2SV_blank>as<S2SV_blank>a<S2SV_blank>mount<S2SV_blank>"" ""parameter;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>eCryptfs<S2SV_blank>README\\n"" ) ; goto out ; } if ( ! cipher_name_set ) { int cipher_name_len = strlen ( ECRYPTFS_DEFAULT_CIPHER ) ; BUG_ON ( cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ) ; } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set ) strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ) ; if ( ! cipher_key_bytes_set ) mount_crypt_stat -> global_default_cipher_key_size = 0 ; if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set ) mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size ; mutex_lock ( & key_tfm_list_mutex ) ; if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>"" ""rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>"" ""rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } mutex_unlock ( & key_tfm_list_mutex ) ; rc = ecryptfs_init_global_auth_toks ( mount_crypt_stat ) ; if ( rc ) printk ( KERN_WARNING ""One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>global<S2SV_blank>auth<S2SV_blank>toks<S2SV_blank>could<S2SV_blank>not<S2SV_blank>"" ""properly<S2SV_blank>register;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , rc ) ; out : return rc ; }",* check_ruid = 0 ;if ( ! options ) {rc = - EINVAL ;,2760
835,"buggy line: cwe id:CWE-264context:  static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options )  { char * p ; int rc = 0 ; int sig_set = 0 ; int cipher_name_set = 0 ; int fn_cipher_name_set = 0 ; int cipher_key_bytes ; int cipher_key_bytes_set = 0 ; int fn_cipher_key_bytes ; int fn_cipher_key_bytes_set = 0 ; struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; substring_t args [ MAX_OPT_ARGS ] ; int token ; char * sig_src ; char * cipher_name_dst ; char * cipher_name_src ; char * fn_cipher_name_dst ; char * fn_cipher_name_src ; char * fnek_dst ; char * fnek_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ;  if ( ! options ) {  rc = - EINVAL ; goto out ; } ecryptfs_init_mount_crypt_stat ( mount_crypt_stat ) ; while ( ( p = strsep ( & options , "","" ) ) != NULL ) { if ( ! * p ) continue ; token = match_token ( p , tokens , args ) ; switch ( token ) { case ecryptfs_opt_sig : case ecryptfs_opt_ecryptfs_sig : sig_src = args [ 0 ] . from ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>"" ""global<S2SV_blank>sig;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , rc ) ; goto out ; } sig_set = 1 ; break ; case ecryptfs_opt_cipher : case ecryptfs_opt_ecryptfs_cipher : cipher_name_src = args [ 0 ] . from ; cipher_name_dst = mount_crypt_stat -> global_default_cipher_name ; strncpy ( cipher_name_dst , cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; cipher_name_set = 1 ; break ; case ecryptfs_opt_ecryptfs_key_bytes : cipher_key_bytes_src = args [ 0 ] . from ; cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes ; cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_passthrough : mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED ; break ; case ecryptfs_opt_xattr_metadata : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; break ; case ecryptfs_opt_encrypted_view : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED ; break ; case ecryptfs_opt_fnek_sig : fnek_src = args [ 0 ] . from ; fnek_dst = mount_crypt_stat -> global_default_fnek_sig ; strncpy ( fnek_dst , fnek_src , ECRYPTFS_SIG_SIZE_HEX ) ; mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\\0' ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>"" ""global<S2SV_blank>fnek<S2SV_blank>sig<S2SV_blank>[%s];<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fnek_sig , rc ) ; goto out ; } mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ) ; break ; case ecryptfs_opt_fn_cipher : fn_cipher_name_src = args [ 0 ] . from ; fn_cipher_name_dst = mount_crypt_stat -> global_default_fn_cipher_name ; strncpy ( fn_cipher_name_dst , fn_cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; fn_cipher_name_set = 1 ; break ; case ecryptfs_opt_fn_cipher_key_bytes : fn_cipher_key_bytes_src = args [ 0 ] . from ; fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes ; fn_cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_unlink_sigs : mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS ; break ; case ecryptfs_opt_mount_auth_tok_only : mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY ; break ;  case ecryptfs_opt_err :  default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\n"" , __func__ , p ) ; } } if ( ! sig_set ) { rc = - EINVAL ; ecryptfs_printk ( KERN_ERR , ""You<S2SV_blank>must<S2SV_blank>supply<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>valid<S2SV_blank>"" ""auth<S2SV_blank>tok<S2SV_blank>signature<S2SV_blank>as<S2SV_blank>a<S2SV_blank>mount<S2SV_blank>"" ""parameter;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>eCryptfs<S2SV_blank>README\\n"" ) ; goto out ; } if ( ! cipher_name_set ) { int cipher_name_len = strlen ( ECRYPTFS_DEFAULT_CIPHER ) ; BUG_ON ( cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ) ; } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set ) strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ) ; if ( ! cipher_key_bytes_set ) mount_crypt_stat -> global_default_cipher_key_size = 0 ; if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set ) mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size ; mutex_lock ( & key_tfm_list_mutex ) ; if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>"" ""rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>"" ""rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } mutex_unlock ( & key_tfm_list_mutex ) ; rc = ecryptfs_init_global_auth_toks ( mount_crypt_stat ) ; if ( rc ) printk ( KERN_WARNING ""One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>global<S2SV_blank>auth<S2SV_blank>toks<S2SV_blank>could<S2SV_blank>not<S2SV_blank>"" ""properly<S2SV_blank>register;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , rc ) ; out : return rc ; }",case ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ;break ;,2760
836,"buggy line: case ecryptfs_opt_err :  default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\\cwe id:CWE-264context:  static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options )  { char * p ; int rc = 0 ; int sig_set = 0 ; int cipher_name_set = 0 ; int fn_cipher_name_set = 0 ; int cipher_key_bytes ; int cipher_key_bytes_set = 0 ; int fn_cipher_key_bytes ; int fn_cipher_key_bytes_set = 0 ; struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; substring_t args [ MAX_OPT_ARGS ] ; int token ; char * sig_src ; char * cipher_name_dst ; char * cipher_name_src ; char * fn_cipher_name_dst ; char * fn_cipher_name_src ; char * fnek_dst ; char * fnek_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ;  if ( ! options ) {  rc = - EINVAL ; goto out ; } ecryptfs_init_mount_crypt_stat ( mount_crypt_stat ) ; while ( ( p = strsep ( & options , "","" ) ) != NULL ) { if ( ! * p ) continue ; token = match_token ( p , tokens , args ) ; switch ( token ) { case ecryptfs_opt_sig : case ecryptfs_opt_ecryptfs_sig : sig_src = args [ 0 ] . from ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>"" ""global<S2SV_blank>sig;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , rc ) ; goto out ; } sig_set = 1 ; break ; case ecryptfs_opt_cipher : case ecryptfs_opt_ecryptfs_cipher : cipher_name_src = args [ 0 ] . from ; cipher_name_dst = mount_crypt_stat -> global_default_cipher_name ; strncpy ( cipher_name_dst , cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; cipher_name_set = 1 ; break ; case ecryptfs_opt_ecryptfs_key_bytes : cipher_key_bytes_src = args [ 0 ] . from ; cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes ; cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_passthrough : mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED ; break ; case ecryptfs_opt_xattr_metadata : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; break ; case ecryptfs_opt_encrypted_view : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED ; break ; case ecryptfs_opt_fnek_sig : fnek_src = args [ 0 ] . from ; fnek_dst = mount_crypt_stat -> global_default_fnek_sig ; strncpy ( fnek_dst , fnek_src , ECRYPTFS_SIG_SIZE_HEX ) ; mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\\0' ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>"" ""global<S2SV_blank>fnek<S2SV_blank>sig<S2SV_blank>[%s];<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fnek_sig , rc ) ; goto out ; } mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ) ; break ; case ecryptfs_opt_fn_cipher : fn_cipher_name_src = args [ 0 ] . from ; fn_cipher_name_dst = mount_crypt_stat -> global_default_fn_cipher_name ; strncpy ( fn_cipher_name_dst , fn_cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; fn_cipher_name_set = 1 ; break ; case ecryptfs_opt_fn_cipher_key_bytes : fn_cipher_key_bytes_src = args [ 0 ] . from ; fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes ; fn_cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_unlink_sigs : mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS ; break ; case ecryptfs_opt_mount_auth_tok_only : mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY ; break ;  case ecryptfs_opt_err :  default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\n"" , __func__ , p ) ; } } if ( ! sig_set ) { rc = - EINVAL ; ecryptfs_printk ( KERN_ERR , ""You<S2SV_blank>must<S2SV_blank>supply<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>valid<S2SV_blank>"" ""auth<S2SV_blank>tok<S2SV_blank>signature<S2SV_blank>as<S2SV_blank>a<S2SV_blank>mount<S2SV_blank>"" ""parameter;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>eCryptfs<S2SV_blank>README\\n"" ) ; goto out ; } if ( ! cipher_name_set ) { int cipher_name_len = strlen ( ECRYPTFS_DEFAULT_CIPHER ) ; BUG_ON ( cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ) ; } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set ) strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ) ; if ( ! cipher_key_bytes_set ) mount_crypt_stat -> global_default_cipher_key_size = 0 ; if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set ) mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size ; mutex_lock ( & key_tfm_list_mutex ) ; if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>"" ""rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>"" ""rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } mutex_unlock ( & key_tfm_list_mutex ) ; rc = ecryptfs_init_global_auth_toks ( mount_crypt_stat ) ; if ( rc ) printk ( KERN_WARNING ""One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>global<S2SV_blank>auth<S2SV_blank>toks<S2SV_blank>could<S2SV_blank>not<S2SV_blank>"" ""properly<S2SV_blank>register;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , rc ) ; out : return rc ; }","case ecryptfs_opt_err : default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\\",2760
837,"buggy line: cJSON_AddFloatToObject ( j , ""cpu_util_total"" , test -> cpu_util [ 0 ] ) ;cJSON_AddFloatToObject ( j , ""cpu_util_user"" , test -> cpu_util [ 1 ] ) ;cJSON_AddFloatToObject ( j , ""cpu_util_system"" , test -> cpu_util [ 2 ] ) ;if ( ! test -> sender ) sender_has_retransmits = - 1 ;cJSON_AddIntToObject ( j , ""sender_has_retransmits"" , sender_has_retransmits ) ;if ( test -> role == \'s\' && test -> get_server_output ) {cwe id:CWE-119context: static int send_results ( struct iperf_test * test ) { int r = 0 ; cJSON * j ; cJSON * j_streams ; struct iperf_stream * sp ; cJSON * j_stream ; int sender_has_retransmits ; iperf_size_t bytes_transferred ; int retransmits ; j = cJSON_CreateObject ( ) ; if ( j == NULL ) { i_errno = IEPACKAGERESULTS ; r = - 1 ; } else {  cJSON_AddFloatToObject ( j , ""cpu_util_total"" , test -> cpu_util [ 0 ] ) ;   cJSON_AddFloatToObject ( j , ""cpu_util_user"" , test -> cpu_util [ 1 ] ) ;   cJSON_AddFloatToObject ( j , ""cpu_util_system"" , test -> cpu_util [ 2 ] ) ;  if ( ! test -> sender ) sender_has_retransmits = - 1 ; else sender_has_retransmits = test -> sender_has_retransmits ;  cJSON_AddIntToObject ( j , ""sender_has_retransmits"" , sender_has_retransmits ) ;  if ( test -> role == 's' && test -> get_server_output ) { if ( test -> json_output ) { cJSON_AddItemReferenceToObject ( j , ""server_output_json"" , test -> json_top ) ; } else { size_t buflen = 0 ; struct iperf_textline * t ; TAILQ_FOREACH ( t , & ( test -> server_output_list ) , textlineentries ) { buflen += strlen ( t -> line ) ; } char * output = calloc ( buflen + 1 , 1 ) ; TAILQ_FOREACH ( t , & ( test -> server_output_list ) , textlineentries ) { strncat ( output , t -> line , buflen ) ; buflen -= strlen ( t -> line ) ; } cJSON_AddStringToObject ( j , ""server_output_text"" , output ) ; } } j_streams = cJSON_CreateArray ( ) ; if ( j_streams == NULL ) { i_errno = IEPACKAGERESULTS ; r = - 1 ; } else { cJSON_AddItemToObject ( j , ""streams"" , j_streams ) ; SLIST_FOREACH ( sp , & test -> streams , streams ) { j_stream = cJSON_CreateObject ( ) ; if ( j_stream == NULL ) { i_errno = IEPACKAGERESULTS ; r = - 1 ; } else { cJSON_AddItemToArray ( j_streams , j_stream ) ; bytes_transferred = test -> sender ? sp -> result -> bytes_sent : sp -> result -> bytes_received ; retransmits = ( test -> sender && test -> sender_has_retransmits ) ? sp -> result -> stream_retrans : - 1 ;  cJSON_AddIntToObject ( j_stream , ""id"" , sp -> id ) ;   cJSON_AddIntToObject ( j_stream , ""bytes"" , bytes_transferred ) ;   cJSON_AddIntToObject ( j_stream , ""retransmits"" , retransmits ) ;   cJSON_AddFloatToObject ( j_stream , ""jitter"" , sp -> jitter ) ;   cJSON_AddIntToObject ( j_stream , ""errors"" , sp -> cnt_error ) ;   cJSON_AddIntToObject ( j_stream , ""packets"" , sp -> packet_count ) ;  } } if ( r == 0 && test -> debug ) { printf ( ""send_results\\n%s\\n"" , cJSON_Print ( j ) ) ; } if ( r == 0 && JSON_write ( test -> ctrl_sck , j ) < 0 ) { i_errno = IESENDRESULTS ; r = - 1 ; } } cJSON_Delete ( j ) ; } return r ; }","cJSON_AddNumberToObject ( j , ""cpu_util_total"" , test -> cpu_util [ 0 ] ) ;cJSON_AddNumberToObject ( j , ""cpu_util_user"" , test -> cpu_util [ 1 ] ) ;cJSON_AddNumberToObject ( j , ""cpu_util_system"" , test -> cpu_util [ 2 ] ) ;if ( ! test -> sender ) sender_has_retransmits = - 1 ;cJSON_AddNumberToObject ( j , ""sender_has_retransmits"" , sender_has_retransmits ) ;if ( test -> role == \'s\' && test -> get_server_output ) {",2761
838,"buggy line: else {cJSON_AddItemToObject ( j , ""streams"" , j_streams ) ;SLIST_FOREACH ( sp , & test -> streams , streams ) {j_stream = cJSON_CreateObject ( ) ;if ( j_stream == NULL ) {i_errno = IEPACKAGERESULTS ;r = - 1 ;}else {cJSON_AddItemToArray ( j_streams , j_stream ) ;bytes_transferred = test -> sender ? sp -> result -> bytes_sent : sp -> result -> bytes_received ;retransmits = ( test -> sender && test -> sender_has_retransmits ) ? sp -> result -> stream_retrans : - 1 ;cJSON_AddIntToObject ( j_stream , ""id"" , sp -> id ) ;cJSON_AddIntToObject ( j_stream , ""bytes"" , bytes_transferred ) ;cJSON_AddIntToObject ( j_stream , ""retransmits"" , retransmits ) ;cJSON_AddFloatToObject ( j_stream , ""jitter"" , sp -> jitter ) ;cJSON_AddIntToObject ( j_stream , ""errors"" , sp -> cnt_error ) ;cJSON_AddIntToObject ( j_stream , ""packets"" , sp -> packet_count ) ;}cwe id:CWE-119context: static int send_results ( struct iperf_test * test ) { int r = 0 ; cJSON * j ; cJSON * j_streams ; struct iperf_stream * sp ; cJSON * j_stream ; int sender_has_retransmits ; iperf_size_t bytes_transferred ; int retransmits ; j = cJSON_CreateObject ( ) ; if ( j == NULL ) { i_errno = IEPACKAGERESULTS ; r = - 1 ; } else {  cJSON_AddFloatToObject ( j , ""cpu_util_total"" , test -> cpu_util [ 0 ] ) ;   cJSON_AddFloatToObject ( j , ""cpu_util_user"" , test -> cpu_util [ 1 ] ) ;   cJSON_AddFloatToObject ( j , ""cpu_util_system"" , test -> cpu_util [ 2 ] ) ;  if ( ! test -> sender ) sender_has_retransmits = - 1 ; else sender_has_retransmits = test -> sender_has_retransmits ;  cJSON_AddIntToObject ( j , ""sender_has_retransmits"" , sender_has_retransmits ) ;  if ( test -> role == 's' && test -> get_server_output ) { if ( test -> json_output ) { cJSON_AddItemReferenceToObject ( j , ""server_output_json"" , test -> json_top ) ; } else { size_t buflen = 0 ; struct iperf_textline * t ; TAILQ_FOREACH ( t , & ( test -> server_output_list ) , textlineentries ) { buflen += strlen ( t -> line ) ; } char * output = calloc ( buflen + 1 , 1 ) ; TAILQ_FOREACH ( t , & ( test -> server_output_list ) , textlineentries ) { strncat ( output , t -> line , buflen ) ; buflen -= strlen ( t -> line ) ; } cJSON_AddStringToObject ( j , ""server_output_text"" , output ) ; } } j_streams = cJSON_CreateArray ( ) ; if ( j_streams == NULL ) { i_errno = IEPACKAGERESULTS ; r = - 1 ; } else { cJSON_AddItemToObject ( j , ""streams"" , j_streams ) ; SLIST_FOREACH ( sp , & test -> streams , streams ) { j_stream = cJSON_CreateObject ( ) ; if ( j_stream == NULL ) { i_errno = IEPACKAGERESULTS ; r = - 1 ; } else { cJSON_AddItemToArray ( j_streams , j_stream ) ; bytes_transferred = test -> sender ? sp -> result -> bytes_sent : sp -> result -> bytes_received ; retransmits = ( test -> sender && test -> sender_has_retransmits ) ? sp -> result -> stream_retrans : - 1 ;  cJSON_AddIntToObject ( j_stream , ""id"" , sp -> id ) ;   cJSON_AddIntToObject ( j_stream , ""bytes"" , bytes_transferred ) ;   cJSON_AddIntToObject ( j_stream , ""retransmits"" , retransmits ) ;   cJSON_AddFloatToObject ( j_stream , ""jitter"" , sp -> jitter ) ;   cJSON_AddIntToObject ( j_stream , ""errors"" , sp -> cnt_error ) ;   cJSON_AddIntToObject ( j_stream , ""packets"" , sp -> packet_count ) ;  } } if ( r == 0 && test -> debug ) { printf ( ""send_results\\n%s\\n"" , cJSON_Print ( j ) ) ; } if ( r == 0 && JSON_write ( test -> ctrl_sck , j ) < 0 ) { i_errno = IESENDRESULTS ; r = - 1 ; } } cJSON_Delete ( j ) ; } return r ; }","cJSON_AddNumberToObject ( j_stream , ""id"" , sp -> id ) ;cJSON_AddIntToObject ( j_stream , ""bytes"" , bytes_transferred ) ;cJSON_AddIntToObject ( j_stream , ""retransmits"" , retransmits ) ;cJSON_AddFloatToObject ( j_stream , ""jitter"" , sp -> jitter ) ;cJSON_AddIntToObject ( j_stream , ""errors"" , sp -> cnt_error ) ;cJSON_AddIntToObject ( j_stream , ""packets"" , sp -> packet_count ) ;",2761
839,"buggy line: memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;rinfo [ val ] . req_state = srp -> done + 1 ;cwe id:CWE-200context: static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ;  memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;  rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }","rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;rinfo [ val ] . req_state = srp -> done + 1 ;",2762
840,"buggy line: err = - EFAULT ;goto out ;}if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) {u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR :  case PSR_AA32_MODE_FIQ :  case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND :  case PSR_MODE_EL0t :  case PSR_MODE_EL1t :  case PSR_MODE_EL1h :  break ;cwe id:CWE-20context: static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) {  u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;  switch ( mode ) { case PSR_AA32_MODE_USR :  case PSR_AA32_MODE_FIQ :  case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND :  case PSR_MODE_EL0t :  case PSR_MODE_EL1t :  case PSR_MODE_EL1h :  break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }",u64 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ;break ;case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;,2763
841,"buggy line: static int64_t rd_pick_intra_sby_mode ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ,  int64_t tx_cache [ TX_MODES ] ,  int64_t best_rd ) {MB_PREDICTION_MODE mode ;MB_PREDICTION_MODE mode_selected = DC_PRED ;int i ;int * bmode_costs = x -> mbmode_cost ;if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) for ( i = 0 ;i < TX_MODES ;i ++ ) tx_cache [ i ] = INT64_MAX ;int64_t local_tx_cache [ TX_MODES ] ;MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ;MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ;if ( ! ( cpi -> sf . intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] & ( 1 << mode ) ) ) continue ;if ( cpi -> common . frame_type == KEY_FRAME ) {const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ;const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ;bmode_costs = x -> y_mode_costs [ A ] [ L ] ;}mic -> mbmi . mode = mode ;intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion ,   & s , NULL , bsize , local_tx_cache , best_rd ) ;if ( this_rate_tokenonly == INT_MAX ) continue ;cwe id:CWE-119context: static int64_t rd_pick_intra_sby_mode ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ,  int64_t tx_cache [ TX_MODES ] ,  int64_t best_rd ) {  MB_PREDICTION_MODE mode ;  MB_PREDICTION_MODE mode_selected = DC_PRED ; MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * const mic = xd -> mi [ 0 ] ; int this_rate , this_rate_tokenonly , s ; int64_t this_distortion , this_rd ; TX_SIZE best_tx = TX_4X4 ;  int i ;  int * bmode_costs = x -> mbmode_cost ; if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) for ( i = 0 ; i < TX_MODES ; i ++ ) tx_cache [ i ] = INT64_MAX ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { int64_t local_tx_cache [ TX_MODES ] ; MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ; MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; if ( ! ( cpi -> sf . intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] & ( 1 << mode ) ) ) continue ; if ( cpi -> common . frame_type == KEY_FRAME ) { const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ; const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ; bmode_costs = x -> y_mode_costs [ A ] [ L ] ;  }  mic -> mbmi . mode = mode ;  intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion ,   & s , NULL , bsize , local_tx_cache , best_rd ) ;  if ( this_rate_tokenonly == INT_MAX ) continue ; this_rate = this_rate_tokenonly + bmode_costs [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ; if ( this_rd < best_rd ) { mode_selected = mode ; best_rd = this_rd ; best_tx = mic -> mbmi . tx_size ; * rate = this_rate ; * rate_tokenonly = this_rate_tokenonly ; * distortion = this_distortion ; * skippable = s ; }  if ( cpi -> sf . tx_size_search_method == USE_FULL_RD && this_rd < INT64_MAX ) {  for ( i = 0 ; i < TX_MODES && local_tx_cache [ i ] < INT64_MAX ; i ++ ) { const int64_t adj_rd = this_rd + local_tx_cache [ i ] - local_tx_cache [ cpi -> common . tx_mode ] ; if ( adj_rd < tx_cache [ i ] ) { tx_cache [ i ] = adj_rd ; } } } } mic -> mbmi . mode = mode_selected ; mic -> mbmi . tx_size = best_tx ; return best_rd ; }","static int64_t rd_pick_intra_sby_mode ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , int64_t best_rd ) {MB_PREDICTION_MODE mode ;MB_PREDICTION_MODE mode_selected = DC_PRED ;int * bmode_costs ;const MODE_INFO * above_mi = xd -> above_mi ;const MODE_INFO * left_mi = xd -> left_mi ;const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ;const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ;bmode_costs = cpi -> y_mode_costs [ A ] [ L ] ;memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ;if ( cpi -> sf . use_nonrd_pick_mode ) {if ( conditional_skipintra ( mode , mode_selected ) ) continue ;if ( * skippable ) break ;}mic -> mbmi . mode = mode ;intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion , & s , NULL , bsize , local_tx_cache , best_rd ) ;if ( this_rate_tokenonly == INT_MAX ) continue ;",2764
842,"buggy line: }if ( cpi -> sf . tx_size_search_method == USE_FULL_RD && this_rd < INT64_MAX ) {for ( i = 0 ;i < TX_MODES && local_tx_cache [ i ] < INT64_MAX ;i ++ ) {const int64_t adj_rd = this_rd + local_tx_cache [ i ] - local_tx_cache [ cpi -> common . tx_mode ] ;if ( adj_rd < tx_cache [ i ] ) {tx_cache [ i ] = adj_rd ;}}cwe id:CWE-119context: static int64_t rd_pick_intra_sby_mode ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ,  int64_t tx_cache [ TX_MODES ] ,  int64_t best_rd ) {  MB_PREDICTION_MODE mode ;  MB_PREDICTION_MODE mode_selected = DC_PRED ; MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * const mic = xd -> mi [ 0 ] ; int this_rate , this_rate_tokenonly , s ; int64_t this_distortion , this_rd ; TX_SIZE best_tx = TX_4X4 ;  int i ;  int * bmode_costs = x -> mbmode_cost ; if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) for ( i = 0 ; i < TX_MODES ; i ++ ) tx_cache [ i ] = INT64_MAX ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { int64_t local_tx_cache [ TX_MODES ] ; MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ; MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; if ( ! ( cpi -> sf . intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] & ( 1 << mode ) ) ) continue ; if ( cpi -> common . frame_type == KEY_FRAME ) { const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ; const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ; bmode_costs = x -> y_mode_costs [ A ] [ L ] ;  }  mic -> mbmi . mode = mode ;  intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion ,   & s , NULL , bsize , local_tx_cache , best_rd ) ;  if ( this_rate_tokenonly == INT_MAX ) continue ; this_rate = this_rate_tokenonly + bmode_costs [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ; if ( this_rd < best_rd ) { mode_selected = mode ; best_rd = this_rd ; best_tx = mic -> mbmi . tx_size ; * rate = this_rate ; * rate_tokenonly = this_rate_tokenonly ; * distortion = this_distortion ; * skippable = s ; }  if ( cpi -> sf . tx_size_search_method == USE_FULL_RD && this_rd < INT64_MAX ) {  for ( i = 0 ; i < TX_MODES && local_tx_cache [ i ] < INT64_MAX ; i ++ ) { const int64_t adj_rd = this_rd + local_tx_cache [ i ] - local_tx_cache [ cpi -> common . tx_mode ] ; if ( adj_rd < tx_cache [ i ] ) { tx_cache [ i ] = adj_rd ; } } } } mic -> mbmi . mode = mode_selected ; mic -> mbmi . tx_size = best_tx ; return best_rd ; }","
",2764
843,"buggy line: CurrentColorSpace = ColorSpaceOut ;}Error :  cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;cwe id:CWE-000context: static cmsPipeline * DefaultICCintents ( cmsContext ContextID , cmsUInt32Number nProfiles , cmsUInt32Number TheIntents [ ] , cmsHPROFILE hProfiles [ ] , cmsBool BPC [ ] , cmsFloat64Number AdaptationStates [ ] , cmsUInt32Number dwFlags ) { cmsPipeline * Lut = NULL ; cmsPipeline * Result ; cmsHPROFILE hProfile ; cmsMAT3 m ; cmsVEC3 off ; cmsColorSpaceSignature ColorSpaceIn , ColorSpaceOut , CurrentColorSpace ; cmsProfileClassSignature ClassSig ; cmsUInt32Number i , Intent ; if ( nProfiles == 0 ) return NULL ; Result = cmsPipelineAlloc ( ContextID , 0 , 0 ) ; if ( Result == NULL ) return NULL ; CurrentColorSpace = cmsGetColorSpace ( hProfiles [ 0 ] ) ; for ( i = 0 ; i < nProfiles ; i ++ ) { cmsBool lIsDeviceLink , lIsInput ; hProfile = hProfiles [ i ] ; ClassSig = cmsGetDeviceClass ( hProfile ) ; lIsDeviceLink = ( ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass ) ; if ( ( i == 0 ) && ! lIsDeviceLink ) { lIsInput = TRUE ; } else { lIsInput = ( CurrentColorSpace != cmsSigXYZData ) && ( CurrentColorSpace != cmsSigLabData ) ; } Intent = TheIntents [ i ] ; if ( lIsInput || lIsDeviceLink ) { ColorSpaceIn = cmsGetColorSpace ( hProfile ) ; ColorSpaceOut = cmsGetPCS ( hProfile ) ; } else { ColorSpaceIn = cmsGetPCS ( hProfile ) ; ColorSpaceOut = cmsGetColorSpace ( hProfile ) ; } if ( ! ColorSpaceIsCompatible ( ColorSpaceIn , CurrentColorSpace ) ) { cmsSignalError ( ContextID , cmsERROR_COLORSPACE_CHECK , ""ColorSpace<S2SV_blank>mismatch"" ) ; goto Error ; } if ( lIsDeviceLink || ( ( ClassSig == cmsSigNamedColorClass ) && ( nProfiles == 1 ) ) ) { Lut = _cmsReadDevicelinkLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; if ( ClassSig == cmsSigAbstractClass && i > 0 ) { if ( ! ComputeConversion ( i , hProfiles , Intent , BPC [ i ] , AdaptationStates [ i ] , & m , & off ) ) goto Error ; } else { _cmsMAT3identity ( & m ) ; _cmsVEC3init ( & off , 0 , 0 , 0 ) ; } if ( ! AddConversion ( Result , CurrentColorSpace , ColorSpaceIn , & m , & off ) ) goto Error ; } else { if ( lIsInput ) { Lut = _cmsReadInputLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; } else { Lut = _cmsReadOutputLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; if ( ! ComputeConversion ( i , hProfiles , Intent , BPC [ i ] , AdaptationStates [ i ] , & m , & off ) ) goto Error ; if ( ! AddConversion ( Result , CurrentColorSpace , ColorSpaceIn , & m , & off ) ) goto Error ; } } if ( ! cmsPipelineCat ( Result , Lut ) ) goto Error ; cmsPipelineFree ( Lut ) ;  CurrentColorSpace = ColorSpaceOut ;  } return Result ; Error :  cmsPipelineFree ( Lut ) ;  if ( Result != NULL ) cmsPipelineFree ( Result ) ; return NULL ; cmsUNUSED_PARAMETER ( dwFlags ) ; }",Lut = NULL ;CurrentColorSpace = ColorSpaceOut ;}Error : if ( Lut != NULL ) cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;,2765
844,"buggy line: cwe id:CWE-119context: static int dprintf_formatf ( void * data , int ( * stream ) ( int , FILE * ) , const char * format , va_list ap_save ) { const char * digits = lower_digits ; char * f ; int done = 0 ; long param ; long param_num = 0 ; va_stack_t vto [ MAX_PARAMETERS ] ; char * endpos [ MAX_PARAMETERS ] ; char * * end ; char work [ BUFFSIZE ] ; va_stack_t * p ; char * workend = & work [ sizeof ( work ) - 2 ] ; if ( dprintf_Pass1 ( format , vto , endpos , ap_save ) ) return - 1 ; end = & endpos [ 0 ] ; f = ( char * ) format ; while ( * f != '\\0' ) { int is_alt ; long width ; long prec ; int is_neg ; long base ; mp_uintmax_t num ; mp_intmax_t signed_num ; char * w ; if ( * f != '%' ) { do { OUTCHAR ( * f ) ; } while ( * ++ f && ( '%' != * f ) ) ; continue ; } ++ f ; if ( * f == '%' ) { ++ f ; OUTCHAR ( '%' ) ; continue ; } param = dprintf_DollarString ( f , & f ) ; if ( ! param ) param = param_num ; else -- param ; param_num ++ ; p = & vto [ param ] ; if ( p -> flags & FLAGS_WIDTHPARAM ) { width = ( long ) vto [ p -> width ] . data . num . as_signed ; param_num ++ ; if ( width < 0 ) { width = - width ; p -> flags |= FLAGS_LEFT ; p -> flags &= ~ FLAGS_PAD_NIL ; } } else width = p -> width ; if ( p -> flags & FLAGS_PRECPARAM ) { prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; param_num ++ ; if ( prec < 0 ) prec = - 1 ; } else if ( p -> flags & FLAGS_PREC ) prec = p -> precision ; else prec = - 1 ; is_alt = ( p -> flags & FLAGS_ALT ) ? 1 : 0 ; switch ( p -> type ) { case FORMAT_INT : num = p -> data . num . as_unsigned ; if ( p -> flags & FLAGS_CHAR ) { if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( -- width > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; OUTCHAR ( ( char ) num ) ; if ( p -> flags & FLAGS_LEFT ) while ( -- width > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; break ; } if ( p -> flags & FLAGS_OCTAL ) { base = 8 ; goto unsigned_number ; } else if ( p -> flags & FLAGS_HEX ) { digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; base = 16 ; goto unsigned_number ; } else if ( p -> flags & FLAGS_UNSIGNED ) { base = 10 ; goto unsigned_number ; } base = 10 ; is_neg = ( p -> data . num . as_signed < ( mp_intmax_t ) 0 ) ? 1 : 0 ; if ( is_neg ) { signed_num = p -> data . num . as_signed + ( mp_intmax_t ) 1 ; signed_num = - signed_num ; num = ( mp_uintmax_t ) signed_num ; num += ( mp_uintmax_t ) 1 ; } goto number ; unsigned_number : is_neg = 0 ; number : if ( prec == - 1 ) prec = 1 ; w = workend ; while ( num > 0 ) { * w -- = digits [ num % base ] ; num /= base ; } width -= ( long ) ( workend - w ) ; prec -= ( long ) ( workend - w ) ; if ( is_alt && base == 8 && prec <= 0 ) { * w -- = '0' ; -- width ; } if ( prec > 0 ) { width -= prec ; while ( prec -- > 0 ) * w -- = '0' ; } if ( is_alt && base == 16 ) width -= 2 ; if ( is_neg || ( p -> flags & FLAGS_SHOWSIGN ) || ( p -> flags & FLAGS_SPACE ) ) -- width ; if ( ! ( p -> flags & FLAGS_LEFT ) && ! ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; if ( is_neg ) OUTCHAR ( '-' ) ; else if ( p -> flags & FLAGS_SHOWSIGN ) OUTCHAR ( '+' ) ; else if ( p -> flags & FLAGS_SPACE ) OUTCHAR ( '<S2SV_blank>' ) ; if ( is_alt && base == 16 ) { OUTCHAR ( '0' ) ; if ( p -> flags & FLAGS_UPPER ) OUTCHAR ( 'X' ) ; else OUTCHAR ( 'x' ) ; } if ( ! ( p -> flags & FLAGS_LEFT ) && ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '0' ) ; while ( ++ w <= workend ) { OUTCHAR ( * w ) ; } if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; break ; case FORMAT_STRING : { static const char null [ ] = ""(nil)"" ; const char * str ; size_t len ; str = ( char * ) p -> data . str ; if ( str == NULL ) { if ( prec == - 1 || prec >= ( long ) sizeof ( null ) - 1 ) { str = null ; len = sizeof ( null ) - 1 ; p -> flags &= ( ~ FLAGS_ALT ) ; } else { str = """" ; len = 0 ; } } else if ( prec != - 1 ) len = ( size_t ) prec ; else len = strlen ( str ) ; width -= ( len > LONG_MAX ) ? LONG_MAX : ( long ) len ; if ( p -> flags & FLAGS_ALT ) OUTCHAR ( \'""\' ) ; if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; while ( ( len -- > 0 ) && * str ) OUTCHAR ( * str ++ ) ; if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; if ( p -> flags & FLAGS_ALT ) OUTCHAR ( \'""\' ) ; } break ; case FORMAT_PTR : { void * ptr ; ptr = ( void * ) p -> data . ptr ; if ( ptr != NULL ) { base = 16 ; digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; is_alt = 1 ; num = ( size_t ) ptr ; is_neg = 0 ; goto number ; } else { static const char strnil [ ] = ""(nil)"" ; const char * point ; width -= ( long ) ( sizeof ( strnil ) - 1 ) ; if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; for ( point = strnil ; * point != '\\0' ; ++ point ) OUTCHAR ( * point ) ; if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; } } break ; case FORMAT_DOUBLE : { char formatbuf [ 32 ] = ""%"" ; char * fptr = & formatbuf [ 1 ] ; size_t left = sizeof ( formatbuf ) - strlen ( formatbuf ) ; int len ; width = - 1 ; if ( p -> flags & FLAGS_WIDTH ) width = p -> width ; else if ( p -> flags & FLAGS_WIDTHPARAM ) width = ( long ) vto [ p -> width ] . data . num . as_signed ; prec = - 1 ; if ( p -> flags & FLAGS_PREC ) prec = p -> precision ; else if ( p -> flags & FLAGS_PRECPARAM ) prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; if ( p -> flags & FLAGS_LEFT ) * fptr ++ = '-' ; if ( p -> flags & FLAGS_SHOWSIGN ) * fptr ++ = '+' ; if ( p -> flags & FLAGS_SPACE ) * fptr ++ = '<S2SV_blank>' ; if ( p -> flags & FLAGS_ALT ) * fptr ++ = '#' ; * fptr = 0 ; if ( width >= 0 ) {  len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ;  fptr += len ; left -= len ; } if ( prec >= 0 ) {  len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ;  fptr += len ; } if ( p -> flags & FLAGS_LONG ) * fptr ++ = 'l' ; if ( p -> flags & FLAGS_FLOATE ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'E' : 'e' ) ; else if ( p -> flags & FLAGS_FLOATG ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'G' : 'g' ) ; else * fptr ++ = 'f' ; * fptr = 0 ; ( sprintf ) ( work , formatbuf , p -> data . dnum ) ;  for ( fptr = work ; * fptr ; fptr ++ )  OUTCHAR ( * fptr ) ; } break ; case FORMAT_INTPTR : # ifdef HAVE_LONG_LONG_TYPE if ( p -> flags & FLAGS_LONGLONG ) * ( LONG_LONG_TYPE * ) p -> data . ptr = ( LONG_LONG_TYPE ) done ; else # endif if ( p -> flags & FLAGS_LONG ) * ( long * ) p -> data . ptr = ( long ) done ; else if ( ! ( p -> flags & FLAGS_SHORT ) ) * ( int * ) p -> data . ptr = ( int ) done ; else * ( short * ) p -> data . ptr = ( short ) done ; break ; default : break ; } f = * end ++ ; } return done ; }",if ( width >= ( long ) sizeof ( work ) ) width = sizeof ( work ) - 1 ;,2766
845,"buggy line: cwe id:CWE-119context: static int dprintf_formatf ( void * data , int ( * stream ) ( int , FILE * ) , const char * format , va_list ap_save ) { const char * digits = lower_digits ; char * f ; int done = 0 ; long param ; long param_num = 0 ; va_stack_t vto [ MAX_PARAMETERS ] ; char * endpos [ MAX_PARAMETERS ] ; char * * end ; char work [ BUFFSIZE ] ; va_stack_t * p ; char * workend = & work [ sizeof ( work ) - 2 ] ; if ( dprintf_Pass1 ( format , vto , endpos , ap_save ) ) return - 1 ; end = & endpos [ 0 ] ; f = ( char * ) format ; while ( * f != '\\0' ) { int is_alt ; long width ; long prec ; int is_neg ; long base ; mp_uintmax_t num ; mp_intmax_t signed_num ; char * w ; if ( * f != '%' ) { do { OUTCHAR ( * f ) ; } while ( * ++ f && ( '%' != * f ) ) ; continue ; } ++ f ; if ( * f == '%' ) { ++ f ; OUTCHAR ( '%' ) ; continue ; } param = dprintf_DollarString ( f , & f ) ; if ( ! param ) param = param_num ; else -- param ; param_num ++ ; p = & vto [ param ] ; if ( p -> flags & FLAGS_WIDTHPARAM ) { width = ( long ) vto [ p -> width ] . data . num . as_signed ; param_num ++ ; if ( width < 0 ) { width = - width ; p -> flags |= FLAGS_LEFT ; p -> flags &= ~ FLAGS_PAD_NIL ; } } else width = p -> width ; if ( p -> flags & FLAGS_PRECPARAM ) { prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; param_num ++ ; if ( prec < 0 ) prec = - 1 ; } else if ( p -> flags & FLAGS_PREC ) prec = p -> precision ; else prec = - 1 ; is_alt = ( p -> flags & FLAGS_ALT ) ? 1 : 0 ; switch ( p -> type ) { case FORMAT_INT : num = p -> data . num . as_unsigned ; if ( p -> flags & FLAGS_CHAR ) { if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( -- width > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; OUTCHAR ( ( char ) num ) ; if ( p -> flags & FLAGS_LEFT ) while ( -- width > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; break ; } if ( p -> flags & FLAGS_OCTAL ) { base = 8 ; goto unsigned_number ; } else if ( p -> flags & FLAGS_HEX ) { digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; base = 16 ; goto unsigned_number ; } else if ( p -> flags & FLAGS_UNSIGNED ) { base = 10 ; goto unsigned_number ; } base = 10 ; is_neg = ( p -> data . num . as_signed < ( mp_intmax_t ) 0 ) ? 1 : 0 ; if ( is_neg ) { signed_num = p -> data . num . as_signed + ( mp_intmax_t ) 1 ; signed_num = - signed_num ; num = ( mp_uintmax_t ) signed_num ; num += ( mp_uintmax_t ) 1 ; } goto number ; unsigned_number : is_neg = 0 ; number : if ( prec == - 1 ) prec = 1 ; w = workend ; while ( num > 0 ) { * w -- = digits [ num % base ] ; num /= base ; } width -= ( long ) ( workend - w ) ; prec -= ( long ) ( workend - w ) ; if ( is_alt && base == 8 && prec <= 0 ) { * w -- = '0' ; -- width ; } if ( prec > 0 ) { width -= prec ; while ( prec -- > 0 ) * w -- = '0' ; } if ( is_alt && base == 16 ) width -= 2 ; if ( is_neg || ( p -> flags & FLAGS_SHOWSIGN ) || ( p -> flags & FLAGS_SPACE ) ) -- width ; if ( ! ( p -> flags & FLAGS_LEFT ) && ! ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; if ( is_neg ) OUTCHAR ( '-' ) ; else if ( p -> flags & FLAGS_SHOWSIGN ) OUTCHAR ( '+' ) ; else if ( p -> flags & FLAGS_SPACE ) OUTCHAR ( '<S2SV_blank>' ) ; if ( is_alt && base == 16 ) { OUTCHAR ( '0' ) ; if ( p -> flags & FLAGS_UPPER ) OUTCHAR ( 'X' ) ; else OUTCHAR ( 'x' ) ; } if ( ! ( p -> flags & FLAGS_LEFT ) && ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '0' ) ; while ( ++ w <= workend ) { OUTCHAR ( * w ) ; } if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; break ; case FORMAT_STRING : { static const char null [ ] = ""(nil)"" ; const char * str ; size_t len ; str = ( char * ) p -> data . str ; if ( str == NULL ) { if ( prec == - 1 || prec >= ( long ) sizeof ( null ) - 1 ) { str = null ; len = sizeof ( null ) - 1 ; p -> flags &= ( ~ FLAGS_ALT ) ; } else { str = """" ; len = 0 ; } } else if ( prec != - 1 ) len = ( size_t ) prec ; else len = strlen ( str ) ; width -= ( len > LONG_MAX ) ? LONG_MAX : ( long ) len ; if ( p -> flags & FLAGS_ALT ) OUTCHAR ( \'""\' ) ; if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; while ( ( len -- > 0 ) && * str ) OUTCHAR ( * str ++ ) ; if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; if ( p -> flags & FLAGS_ALT ) OUTCHAR ( \'""\' ) ; } break ; case FORMAT_PTR : { void * ptr ; ptr = ( void * ) p -> data . ptr ; if ( ptr != NULL ) { base = 16 ; digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; is_alt = 1 ; num = ( size_t ) ptr ; is_neg = 0 ; goto number ; } else { static const char strnil [ ] = ""(nil)"" ; const char * point ; width -= ( long ) ( sizeof ( strnil ) - 1 ) ; if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; for ( point = strnil ; * point != '\\0' ; ++ point ) OUTCHAR ( * point ) ; if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; } } break ; case FORMAT_DOUBLE : { char formatbuf [ 32 ] = ""%"" ; char * fptr = & formatbuf [ 1 ] ; size_t left = sizeof ( formatbuf ) - strlen ( formatbuf ) ; int len ; width = - 1 ; if ( p -> flags & FLAGS_WIDTH ) width = p -> width ; else if ( p -> flags & FLAGS_WIDTHPARAM ) width = ( long ) vto [ p -> width ] . data . num . as_signed ; prec = - 1 ; if ( p -> flags & FLAGS_PREC ) prec = p -> precision ; else if ( p -> flags & FLAGS_PRECPARAM ) prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; if ( p -> flags & FLAGS_LEFT ) * fptr ++ = '-' ; if ( p -> flags & FLAGS_SHOWSIGN ) * fptr ++ = '+' ; if ( p -> flags & FLAGS_SPACE ) * fptr ++ = '<S2SV_blank>' ; if ( p -> flags & FLAGS_ALT ) * fptr ++ = '#' ; * fptr = 0 ; if ( width >= 0 ) {  len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ;  fptr += len ; left -= len ; } if ( prec >= 0 ) {  len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ;  fptr += len ; } if ( p -> flags & FLAGS_LONG ) * fptr ++ = 'l' ; if ( p -> flags & FLAGS_FLOATE ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'E' : 'e' ) ; else if ( p -> flags & FLAGS_FLOATG ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'G' : 'g' ) ; else * fptr ++ = 'f' ; * fptr = 0 ; ( sprintf ) ( work , formatbuf , p -> data . dnum ) ;  for ( fptr = work ; * fptr ; fptr ++ )  OUTCHAR ( * fptr ) ; } break ; case FORMAT_INTPTR : # ifdef HAVE_LONG_LONG_TYPE if ( p -> flags & FLAGS_LONGLONG ) * ( LONG_LONG_TYPE * ) p -> data . ptr = ( LONG_LONG_TYPE ) done ; else # endif if ( p -> flags & FLAGS_LONG ) * ( long * ) p -> data . ptr = ( long ) done ; else if ( ! ( p -> flags & FLAGS_SHORT ) ) * ( int * ) p -> data . ptr = ( int ) done ; else * ( short * ) p -> data . ptr = ( short ) done ; break ; default : break ; } f = * end ++ ; } return done ; }",size_t maxprec = sizeof ( work ) - 2 ;double val = p -> data . dnum ;while ( val >= 10.0 ) {val /= 10 ;maxprec -- ;}if ( prec > ( long ) maxprec ) prec = maxprec - 1 ;,2766
846,"buggy line: len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ;fptr += len ;len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ;fptr += len ;cwe id:CWE-119context: static int dprintf_formatf ( void * data , int ( * stream ) ( int , FILE * ) , const char * format , va_list ap_save ) { const char * digits = lower_digits ; char * f ; int done = 0 ; long param ; long param_num = 0 ; va_stack_t vto [ MAX_PARAMETERS ] ; char * endpos [ MAX_PARAMETERS ] ; char * * end ; char work [ BUFFSIZE ] ; va_stack_t * p ; char * workend = & work [ sizeof ( work ) - 2 ] ; if ( dprintf_Pass1 ( format , vto , endpos , ap_save ) ) return - 1 ; end = & endpos [ 0 ] ; f = ( char * ) format ; while ( * f != '\\0' ) { int is_alt ; long width ; long prec ; int is_neg ; long base ; mp_uintmax_t num ; mp_intmax_t signed_num ; char * w ; if ( * f != '%' ) { do { OUTCHAR ( * f ) ; } while ( * ++ f && ( '%' != * f ) ) ; continue ; } ++ f ; if ( * f == '%' ) { ++ f ; OUTCHAR ( '%' ) ; continue ; } param = dprintf_DollarString ( f , & f ) ; if ( ! param ) param = param_num ; else -- param ; param_num ++ ; p = & vto [ param ] ; if ( p -> flags & FLAGS_WIDTHPARAM ) { width = ( long ) vto [ p -> width ] . data . num . as_signed ; param_num ++ ; if ( width < 0 ) { width = - width ; p -> flags |= FLAGS_LEFT ; p -> flags &= ~ FLAGS_PAD_NIL ; } } else width = p -> width ; if ( p -> flags & FLAGS_PRECPARAM ) { prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; param_num ++ ; if ( prec < 0 ) prec = - 1 ; } else if ( p -> flags & FLAGS_PREC ) prec = p -> precision ; else prec = - 1 ; is_alt = ( p -> flags & FLAGS_ALT ) ? 1 : 0 ; switch ( p -> type ) { case FORMAT_INT : num = p -> data . num . as_unsigned ; if ( p -> flags & FLAGS_CHAR ) { if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( -- width > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; OUTCHAR ( ( char ) num ) ; if ( p -> flags & FLAGS_LEFT ) while ( -- width > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; break ; } if ( p -> flags & FLAGS_OCTAL ) { base = 8 ; goto unsigned_number ; } else if ( p -> flags & FLAGS_HEX ) { digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; base = 16 ; goto unsigned_number ; } else if ( p -> flags & FLAGS_UNSIGNED ) { base = 10 ; goto unsigned_number ; } base = 10 ; is_neg = ( p -> data . num . as_signed < ( mp_intmax_t ) 0 ) ? 1 : 0 ; if ( is_neg ) { signed_num = p -> data . num . as_signed + ( mp_intmax_t ) 1 ; signed_num = - signed_num ; num = ( mp_uintmax_t ) signed_num ; num += ( mp_uintmax_t ) 1 ; } goto number ; unsigned_number : is_neg = 0 ; number : if ( prec == - 1 ) prec = 1 ; w = workend ; while ( num > 0 ) { * w -- = digits [ num % base ] ; num /= base ; } width -= ( long ) ( workend - w ) ; prec -= ( long ) ( workend - w ) ; if ( is_alt && base == 8 && prec <= 0 ) { * w -- = '0' ; -- width ; } if ( prec > 0 ) { width -= prec ; while ( prec -- > 0 ) * w -- = '0' ; } if ( is_alt && base == 16 ) width -= 2 ; if ( is_neg || ( p -> flags & FLAGS_SHOWSIGN ) || ( p -> flags & FLAGS_SPACE ) ) -- width ; if ( ! ( p -> flags & FLAGS_LEFT ) && ! ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; if ( is_neg ) OUTCHAR ( '-' ) ; else if ( p -> flags & FLAGS_SHOWSIGN ) OUTCHAR ( '+' ) ; else if ( p -> flags & FLAGS_SPACE ) OUTCHAR ( '<S2SV_blank>' ) ; if ( is_alt && base == 16 ) { OUTCHAR ( '0' ) ; if ( p -> flags & FLAGS_UPPER ) OUTCHAR ( 'X' ) ; else OUTCHAR ( 'x' ) ; } if ( ! ( p -> flags & FLAGS_LEFT ) && ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '0' ) ; while ( ++ w <= workend ) { OUTCHAR ( * w ) ; } if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; break ; case FORMAT_STRING : { static const char null [ ] = ""(nil)"" ; const char * str ; size_t len ; str = ( char * ) p -> data . str ; if ( str == NULL ) { if ( prec == - 1 || prec >= ( long ) sizeof ( null ) - 1 ) { str = null ; len = sizeof ( null ) - 1 ; p -> flags &= ( ~ FLAGS_ALT ) ; } else { str = """" ; len = 0 ; } } else if ( prec != - 1 ) len = ( size_t ) prec ; else len = strlen ( str ) ; width -= ( len > LONG_MAX ) ? LONG_MAX : ( long ) len ; if ( p -> flags & FLAGS_ALT ) OUTCHAR ( \'""\' ) ; if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; while ( ( len -- > 0 ) && * str ) OUTCHAR ( * str ++ ) ; if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; if ( p -> flags & FLAGS_ALT ) OUTCHAR ( \'""\' ) ; } break ; case FORMAT_PTR : { void * ptr ; ptr = ( void * ) p -> data . ptr ; if ( ptr != NULL ) { base = 16 ; digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; is_alt = 1 ; num = ( size_t ) ptr ; is_neg = 0 ; goto number ; } else { static const char strnil [ ] = ""(nil)"" ; const char * point ; width -= ( long ) ( sizeof ( strnil ) - 1 ) ; if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; for ( point = strnil ; * point != '\\0' ; ++ point ) OUTCHAR ( * point ) ; if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; } } break ; case FORMAT_DOUBLE : { char formatbuf [ 32 ] = ""%"" ; char * fptr = & formatbuf [ 1 ] ; size_t left = sizeof ( formatbuf ) - strlen ( formatbuf ) ; int len ; width = - 1 ; if ( p -> flags & FLAGS_WIDTH ) width = p -> width ; else if ( p -> flags & FLAGS_WIDTHPARAM ) width = ( long ) vto [ p -> width ] . data . num . as_signed ; prec = - 1 ; if ( p -> flags & FLAGS_PREC ) prec = p -> precision ; else if ( p -> flags & FLAGS_PRECPARAM ) prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; if ( p -> flags & FLAGS_LEFT ) * fptr ++ = '-' ; if ( p -> flags & FLAGS_SHOWSIGN ) * fptr ++ = '+' ; if ( p -> flags & FLAGS_SPACE ) * fptr ++ = '<S2SV_blank>' ; if ( p -> flags & FLAGS_ALT ) * fptr ++ = '#' ; * fptr = 0 ; if ( width >= 0 ) {  len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ;  fptr += len ; left -= len ; } if ( prec >= 0 ) {  len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ;  fptr += len ; } if ( p -> flags & FLAGS_LONG ) * fptr ++ = 'l' ; if ( p -> flags & FLAGS_FLOATE ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'E' : 'e' ) ; else if ( p -> flags & FLAGS_FLOATG ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'G' : 'g' ) ; else * fptr ++ = 'f' ; * fptr = 0 ; ( sprintf ) ( work , formatbuf , p -> data . dnum ) ;  for ( fptr = work ; * fptr ; fptr ++ )  OUTCHAR ( * fptr ) ; } break ; case FORMAT_INTPTR : # ifdef HAVE_LONG_LONG_TYPE if ( p -> flags & FLAGS_LONGLONG ) * ( LONG_LONG_TYPE * ) p -> data . ptr = ( LONG_LONG_TYPE ) done ; else # endif if ( p -> flags & FLAGS_LONG ) * ( long * ) p -> data . ptr = ( long ) done ; else if ( ! ( p -> flags & FLAGS_SHORT ) ) * ( int * ) p -> data . ptr = ( int ) done ; else * ( short * ) p -> data . ptr = ( short ) done ; break ; default : break ; } f = * end ++ ; } return done ; }","len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ;fptr += len ;len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ;fptr += len ;",2766
847,"buggy line: for ( fptr = work ;fptr ++ )  OUTCHAR ( * fptr ) ;cwe id:CWE-119context: static int dprintf_formatf ( void * data , int ( * stream ) ( int , FILE * ) , const char * format , va_list ap_save ) { const char * digits = lower_digits ; char * f ; int done = 0 ; long param ; long param_num = 0 ; va_stack_t vto [ MAX_PARAMETERS ] ; char * endpos [ MAX_PARAMETERS ] ; char * * end ; char work [ BUFFSIZE ] ; va_stack_t * p ; char * workend = & work [ sizeof ( work ) - 2 ] ; if ( dprintf_Pass1 ( format , vto , endpos , ap_save ) ) return - 1 ; end = & endpos [ 0 ] ; f = ( char * ) format ; while ( * f != '\\0' ) { int is_alt ; long width ; long prec ; int is_neg ; long base ; mp_uintmax_t num ; mp_intmax_t signed_num ; char * w ; if ( * f != '%' ) { do { OUTCHAR ( * f ) ; } while ( * ++ f && ( '%' != * f ) ) ; continue ; } ++ f ; if ( * f == '%' ) { ++ f ; OUTCHAR ( '%' ) ; continue ; } param = dprintf_DollarString ( f , & f ) ; if ( ! param ) param = param_num ; else -- param ; param_num ++ ; p = & vto [ param ] ; if ( p -> flags & FLAGS_WIDTHPARAM ) { width = ( long ) vto [ p -> width ] . data . num . as_signed ; param_num ++ ; if ( width < 0 ) { width = - width ; p -> flags |= FLAGS_LEFT ; p -> flags &= ~ FLAGS_PAD_NIL ; } } else width = p -> width ; if ( p -> flags & FLAGS_PRECPARAM ) { prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; param_num ++ ; if ( prec < 0 ) prec = - 1 ; } else if ( p -> flags & FLAGS_PREC ) prec = p -> precision ; else prec = - 1 ; is_alt = ( p -> flags & FLAGS_ALT ) ? 1 : 0 ; switch ( p -> type ) { case FORMAT_INT : num = p -> data . num . as_unsigned ; if ( p -> flags & FLAGS_CHAR ) { if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( -- width > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; OUTCHAR ( ( char ) num ) ; if ( p -> flags & FLAGS_LEFT ) while ( -- width > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; break ; } if ( p -> flags & FLAGS_OCTAL ) { base = 8 ; goto unsigned_number ; } else if ( p -> flags & FLAGS_HEX ) { digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; base = 16 ; goto unsigned_number ; } else if ( p -> flags & FLAGS_UNSIGNED ) { base = 10 ; goto unsigned_number ; } base = 10 ; is_neg = ( p -> data . num . as_signed < ( mp_intmax_t ) 0 ) ? 1 : 0 ; if ( is_neg ) { signed_num = p -> data . num . as_signed + ( mp_intmax_t ) 1 ; signed_num = - signed_num ; num = ( mp_uintmax_t ) signed_num ; num += ( mp_uintmax_t ) 1 ; } goto number ; unsigned_number : is_neg = 0 ; number : if ( prec == - 1 ) prec = 1 ; w = workend ; while ( num > 0 ) { * w -- = digits [ num % base ] ; num /= base ; } width -= ( long ) ( workend - w ) ; prec -= ( long ) ( workend - w ) ; if ( is_alt && base == 8 && prec <= 0 ) { * w -- = '0' ; -- width ; } if ( prec > 0 ) { width -= prec ; while ( prec -- > 0 ) * w -- = '0' ; } if ( is_alt && base == 16 ) width -= 2 ; if ( is_neg || ( p -> flags & FLAGS_SHOWSIGN ) || ( p -> flags & FLAGS_SPACE ) ) -- width ; if ( ! ( p -> flags & FLAGS_LEFT ) && ! ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; if ( is_neg ) OUTCHAR ( '-' ) ; else if ( p -> flags & FLAGS_SHOWSIGN ) OUTCHAR ( '+' ) ; else if ( p -> flags & FLAGS_SPACE ) OUTCHAR ( '<S2SV_blank>' ) ; if ( is_alt && base == 16 ) { OUTCHAR ( '0' ) ; if ( p -> flags & FLAGS_UPPER ) OUTCHAR ( 'X' ) ; else OUTCHAR ( 'x' ) ; } if ( ! ( p -> flags & FLAGS_LEFT ) && ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '0' ) ; while ( ++ w <= workend ) { OUTCHAR ( * w ) ; } if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; break ; case FORMAT_STRING : { static const char null [ ] = ""(nil)"" ; const char * str ; size_t len ; str = ( char * ) p -> data . str ; if ( str == NULL ) { if ( prec == - 1 || prec >= ( long ) sizeof ( null ) - 1 ) { str = null ; len = sizeof ( null ) - 1 ; p -> flags &= ( ~ FLAGS_ALT ) ; } else { str = """" ; len = 0 ; } } else if ( prec != - 1 ) len = ( size_t ) prec ; else len = strlen ( str ) ; width -= ( len > LONG_MAX ) ? LONG_MAX : ( long ) len ; if ( p -> flags & FLAGS_ALT ) OUTCHAR ( \'""\' ) ; if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; while ( ( len -- > 0 ) && * str ) OUTCHAR ( * str ++ ) ; if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; if ( p -> flags & FLAGS_ALT ) OUTCHAR ( \'""\' ) ; } break ; case FORMAT_PTR : { void * ptr ; ptr = ( void * ) p -> data . ptr ; if ( ptr != NULL ) { base = 16 ; digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; is_alt = 1 ; num = ( size_t ) ptr ; is_neg = 0 ; goto number ; } else { static const char strnil [ ] = ""(nil)"" ; const char * point ; width -= ( long ) ( sizeof ( strnil ) - 1 ) ; if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; for ( point = strnil ; * point != '\\0' ; ++ point ) OUTCHAR ( * point ) ; if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; } } break ; case FORMAT_DOUBLE : { char formatbuf [ 32 ] = ""%"" ; char * fptr = & formatbuf [ 1 ] ; size_t left = sizeof ( formatbuf ) - strlen ( formatbuf ) ; int len ; width = - 1 ; if ( p -> flags & FLAGS_WIDTH ) width = p -> width ; else if ( p -> flags & FLAGS_WIDTHPARAM ) width = ( long ) vto [ p -> width ] . data . num . as_signed ; prec = - 1 ; if ( p -> flags & FLAGS_PREC ) prec = p -> precision ; else if ( p -> flags & FLAGS_PRECPARAM ) prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; if ( p -> flags & FLAGS_LEFT ) * fptr ++ = '-' ; if ( p -> flags & FLAGS_SHOWSIGN ) * fptr ++ = '+' ; if ( p -> flags & FLAGS_SPACE ) * fptr ++ = '<S2SV_blank>' ; if ( p -> flags & FLAGS_ALT ) * fptr ++ = '#' ; * fptr = 0 ; if ( width >= 0 ) {  len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ;  fptr += len ; left -= len ; } if ( prec >= 0 ) {  len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ;  fptr += len ; } if ( p -> flags & FLAGS_LONG ) * fptr ++ = 'l' ; if ( p -> flags & FLAGS_FLOATE ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'E' : 'e' ) ; else if ( p -> flags & FLAGS_FLOATG ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'G' : 'g' ) ; else * fptr ++ = 'f' ; * fptr = 0 ; ( sprintf ) ( work , formatbuf , p -> data . dnum ) ;  for ( fptr = work ; * fptr ; fptr ++ )  OUTCHAR ( * fptr ) ; } break ; case FORMAT_INTPTR : # ifdef HAVE_LONG_LONG_TYPE if ( p -> flags & FLAGS_LONGLONG ) * ( LONG_LONG_TYPE * ) p -> data . ptr = ( LONG_LONG_TYPE ) done ; else # endif if ( p -> flags & FLAGS_LONG ) * ( long * ) p -> data . ptr = ( long ) done ; else if ( ! ( p -> flags & FLAGS_SHORT ) ) * ( int * ) p -> data . ptr = ( int ) done ; else * ( short * ) p -> data . ptr = ( short ) done ; break ; default : break ; } f = * end ++ ; } return done ; }",# ifdef CURLDEBUG assert ( strlen ( work ) <= sizeof ( work ) ) ;# endif for ( fptr = work ;fptr ++ ) OUTCHAR ( * fptr ) ;,2766
