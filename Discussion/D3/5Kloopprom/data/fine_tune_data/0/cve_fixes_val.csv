,source,target,group
0,"buggy line: if ( iov_iter_rw ( iter ) == READ )  get_block = ocfs2_get_block ;else  get_block = ocfs2_dio_get_block ;return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ;cwe id:CWE-362context: static ssize_t ocfs2_direct_IO ( struct kiocb * iocb , struct iov_iter * iter ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ; get_block_t * get_block ; if ( OCFS2_I ( inode ) -> ip_dyn_features & OCFS2_INLINE_DATA_FL ) return 0 ; if ( iocb -> ki_pos + iter -> count > i_size_read ( inode ) && ! ocfs2_supports_append_dio ( osb ) ) return 0 ; if ( iov_iter_rw ( iter ) == READ )  get_block = ocfs2_get_block ;  else  get_block = ocfs2_dio_get_block ;  return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ; }","if ( iov_iter_rw ( iter ) == READ ) get_block = ocfs2_lock_get_block ;else get_block = ocfs2_dio_get_block ;return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ;",1206
1,"buggy line: _sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) ;if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) {_sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\\\'t<S2SV_blank>offer"" , mech ) ;cwe id:CWE-287context: static void _sx_sasl_client_process ( sx_t s , sx_plugin_t p , Gsasl_session * sd , const char * mech , const char * in , int inlen ) { _sx_sasl_t ctx = ( _sx_sasl_t ) p -> private ; _sx_sasl_sess_t sctx = NULL ; char * buf = NULL , * out = NULL , * realm = NULL , * * ext_id ; char hostname [ 256 ] ; int ret ; # ifdef HAVE_SSL int i ; # endif size_t buflen , outlen ; assert ( ctx ) ; assert ( ctx -> cb ) ; if ( mech != NULL ) { _sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) ;  if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) {  _sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\'t<S2SV_blank>offer"" , mech ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INVALID_MECHANISM , NULL ) , 0 ) ; return ; } ret = gsasl_server_start ( ctx -> gsasl_ctx , mech , & sd ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_server_start<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_TEMPORARY_FAILURE , gsasl_strerror ( ret ) ) , 0 ) ; return ; } ( ctx -> cb ) ( sx_sasl_cb_GET_REALM , NULL , ( void * * ) & realm , s , ctx -> cbarg ) ; sctx = gsasl_session_hook_get ( sd ) ; if ( sctx != NULL ) free ( sctx ) ; sctx = ( _sx_sasl_sess_t ) calloc ( 1 , sizeof ( struct _sx_sasl_sess_st ) ) ; sctx -> s = s ; sctx -> ctx = ctx ; gsasl_session_hook_set ( sd , ( void * ) sctx ) ; gsasl_property_set ( sd , GSASL_SERVICE , ctx -> appname ) ; gsasl_property_set ( sd , GSASL_REALM , realm ) ; hostname [ 0 ] = '\\0' ; gethostname ( hostname , 256 ) ; hostname [ 255 ] = '\\0' ; gsasl_property_set ( sd , GSASL_HOSTNAME , hostname ) ; ext_id = NULL ; # ifdef HAVE_SSL for ( i = 0 ; i < s -> env -> nplugins ; i ++ ) if ( s -> env -> plugins [ i ] -> magic == SX_SSL_MAGIC && s -> plugin_data [ s -> env -> plugins [ i ] -> index ] != NULL ) ext_id = ( ( _sx_ssl_conn_t ) s -> plugin_data [ s -> env -> plugins [ i ] -> index ] ) -> external_id ; if ( ext_id != NULL ) { for ( i = 0 ; i < SX_CONN_EXTERNAL_ID_MAX_COUNT ; i ++ ) if ( ext_id [ i ] != NULL ) { ctx -> ext_id [ i ] = strdup ( ext_id [ i ] ) ; } else { ctx -> ext_id [ i ] = NULL ; break ; } } # endif _sx_debug ( ZONE , ""sasl<S2SV_blank>context<S2SV_blank>initialised<S2SV_blank>for<S2SV_blank>%d"" , s -> tag ) ; s -> plugin_data [ p -> index ] = ( void * ) sd ; if ( strcmp ( mech , ""ANONYMOUS"" ) == 0 ) { ( ctx -> cb ) ( sx_sasl_cb_GEN_AUTHZID , NULL , ( void * * ) & out , s , ctx -> cbarg ) ; buf = strdup ( out ) ; buflen = strlen ( buf ) ; } else if ( strstr ( in , ""<"" ) != NULL && strncmp ( in , ""="" , strstr ( in , ""<"" ) - in ) == 0 ) { _sx_debug ( ZONE , ""gsasl<S2SV_blank>auth<S2SV_blank>string<S2SV_blank>is<S2SV_blank>empty"" ) ; buf = strdup ( """" ) ; buflen = strlen ( buf ) ; } else { ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_base64_from<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; return ; } } ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; } else { ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_base64_from<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; return ; } if ( ! sd ) { _sx_debug ( ZONE , ""response<S2SV_blank>send<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>request<S2SV_blank>enabling<S2SV_blank>mechanism<S2SV_blank>(decoded:<S2SV_blank>%.*s)"" , buflen , buf ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_MECH_TOO_WEAK , ""response<S2SV_blank>send<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>request<S2SV_blank>enabling<S2SV_blank>mechanism"" ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; return ; } _sx_debug ( ZONE , ""response<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(decoded:<S2SV_blank>%.*s)"" , buflen , buf ) ; ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; } if ( buf != NULL ) free ( buf ) ; if ( ret == GSASL_OK ) { _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>completed"" ) ; ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; if ( ret == GSASL_OK ) { _sx_nad_write ( s , _sx_sasl_success ( s , buf , buflen ) , 0 ) ; free ( buf ) ; ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify = _sx_sasl_notify_success ; ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify_arg = ( void * ) p ; } else { _sx_debug ( ZONE , ""gsasl_base64_to<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; } if ( out != NULL ) free ( out ) ; return ; } if ( ret == GSASL_NEEDS_MORE ) { _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>in<S2SV_blank>progress<S2SV_blank>(challenge:<S2SV_blank>%.*s)"" , outlen , out ) ; ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; if ( ret == GSASL_OK ) { _sx_nad_write ( s , _sx_sasl_challenge ( s , buf , buflen ) , 0 ) ; free ( buf ) ; } else { _sx_debug ( ZONE , ""gsasl_base64_to<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; } if ( out != NULL ) free ( out ) ; return ; } if ( out != NULL ) free ( out ) ; _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>failed;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; switch ( ret ) { case GSASL_AUTHENTICATION_ERROR : case GSASL_NO_ANONYMOUS_TOKEN : case GSASL_NO_AUTHID : case GSASL_NO_AUTHZID : case GSASL_NO_PASSWORD : case GSASL_NO_PASSCODE : case GSASL_NO_PIN : case GSASL_NO_SERVICE : case GSASL_NO_HOSTNAME : out = _sasl_err_NOT_AUTHORIZED ; break ; case GSASL_UNKNOWN_MECHANISM : case GSASL_MECHANISM_PARSE_ERROR : out = _sasl_err_INVALID_MECHANISM ; break ; case GSASL_BASE64_ERROR : out = _sasl_err_INCORRECT_ENCODING ; break ; default : out = _sasl_err_MALFORMED_REQUEST ; } _sx_nad_write ( s , _sx_sasl_failure ( s , out , gsasl_strerror ( ret ) ) , 0 ) ; }","_sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK ;if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) {_sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\\\'t<S2SV_blank>offer"" , mech ) ;",1207
2,"buggy line: }off = regs [ regno ] . off + regs [ regno ] . var_off . value ;cwe id:CWE-119context: static int check_stack_boundary ( struct bpf_verifier_env * env , int regno , int access_size , bool zero_size_allowed , struct bpf_call_arg_meta * meta ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = state -> regs ; int off , i , slot , spi ; if ( regs [ regno ] . type != PTR_TO_STACK ) { if ( zero_size_allowed && access_size == 0 && register_is_null ( regs [ regno ] ) ) return 0 ; verbose ( env , ""R%d<S2SV_blank>type=%s<S2SV_blank>expected=%s\\n"" , regno , reg_type_str [ regs [ regno ] . type ] , reg_type_str [ PTR_TO_STACK ] ) ; return - EACCES ; } if ( ! tnum_is_const ( regs [ regno ] . var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , regs [ regno ] . var_off ) ; verbose ( env , ""invalid<S2SV_blank>variable<S2SV_blank>stack<S2SV_blank>read<S2SV_blank>R%d<S2SV_blank>var_off=%s\\n"" , regno , tn_buf ) ;  }  off = regs [ regno ] . off + regs [ regno ] . var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK || off + access_size > 0 || access_size < 0 || ( access_size == 0 && ! zero_size_allowed ) ) { verbose ( env , ""invalid<S2SV_blank>stack<S2SV_blank>type<S2SV_blank>R%d<S2SV_blank>off=%d<S2SV_blank>access_size=%d\\n"" , regno , off , access_size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ; if ( meta && meta -> raw_mode ) { meta -> access_size = access_size ; meta -> regno = regno ; return 0 ; } for ( i = 0 ; i < access_size ; i ++ ) { slot = - ( off + i ) - 1 ; spi = slot / BPF_REG_SIZE ; if ( state -> allocated_stack <= slot || state -> stack [ spi ] . slot_type [ slot % BPF_REG_SIZE ] != STACK_MISC ) { verbose ( env , ""invalid<S2SV_blank>indirect<S2SV_blank>read<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>off<S2SV_blank>%d+%d<S2SV_blank>size<S2SV_blank>%d\\n"" , off , i , access_size ) ; return - EACCES ; } } return 0 ; }",return - EACCES ;}off = regs [ regno ] . off + regs [ regno ] . var_off . value ;,1208
3,"buggy line: if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;cwe id:CWE-416context: static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ;  if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ; continue ; } s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }","memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteFujiEntry ) ) ;if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;",1209
4,"buggy line: sb -> s_op = & ext2_sops ;sb -> s_export_op = & ext2_export_ops ;cwe id:CWE-19context: static int ext2_fill_super ( struct super_block * sb , void * data , int silent ) { struct buffer_head * bh ; struct ext2_sb_info * sbi ; struct ext2_super_block * es ; struct inode * root ; unsigned long block ; unsigned long sb_block = get_sb_block ( & data ) ; unsigned long logic_sb_block ; unsigned long offset = 0 ; unsigned long def_mount_opts ; long ret = - EINVAL ; int blocksize = BLOCK_SIZE ; int db_count ; int i , j ; __le32 features ; int err ; err = - ENOMEM ; sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; if ( ! sbi ) goto failed ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) { kfree ( sbi ) ; goto failed ; } sb -> s_fs_info = sbi ; sbi -> s_sb_block = sb_block ; spin_lock_init ( & sbi -> s_lock ) ; blocksize = sb_min_blocksize ( sb , BLOCK_SIZE ) ; if ( ! blocksize ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>blocksize"" ) ; goto failed_sbi ; } if ( blocksize != BLOCK_SIZE ) { logic_sb_block = ( sb_block * BLOCK_SIZE ) / blocksize ; offset = ( sb_block * BLOCK_SIZE ) % blocksize ; } else { logic_sb_block = sb_block ; } if ( ! ( bh = sb_bread ( sb , logic_sb_block ) ) ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>superblock"" ) ; goto failed_sbi ; } es = ( struct ext2_super_block * ) ( ( ( char * ) bh -> b_data ) + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; if ( sb -> s_magic != EXT2_SUPER_MAGIC ) goto cantfind_ext2 ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; if ( def_mount_opts & EXT2_DEFM_DEBUG ) set_opt ( sbi -> s_mount_opt , DEBUG ) ; if ( def_mount_opts & EXT2_DEFM_BSDGROUPS ) set_opt ( sbi -> s_mount_opt , GRPID ) ; if ( def_mount_opts & EXT2_DEFM_UID16 ) set_opt ( sbi -> s_mount_opt , NO_UID32 ) ; # ifdef CONFIG_EXT2_FS_XATTR if ( def_mount_opts & EXT2_DEFM_XATTR_USER ) set_opt ( sbi -> s_mount_opt , XATTR_USER ) ; # endif # ifdef CONFIG_EXT2_FS_POSIX_ACL if ( def_mount_opts & EXT2_DEFM_ACL ) set_opt ( sbi -> s_mount_opt , POSIX_ACL ) ; # endif if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT2_ERRORS_PANIC ) set_opt ( sbi -> s_mount_opt , ERRORS_PANIC ) ; else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT2_ERRORS_CONTINUE ) set_opt ( sbi -> s_mount_opt , ERRORS_CONT ) ; else set_opt ( sbi -> s_mount_opt , ERRORS_RO ) ; sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; set_opt ( sbi -> s_mount_opt , RESERVATION ) ; if ( ! parse_options ( ( char * ) data , sb ) ) goto failed_mount ; sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | ( ( EXT2_SB ( sb ) -> s_mount_opt & EXT2_MOUNT_POSIX_ACL ) ? MS_POSIXACL : 0 ) ; sb -> s_iflags |= SB_I_CGROUPWB ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT2_GOOD_OLD_REV && ( EXT2_HAS_COMPAT_FEATURE ( sb , ~ 0U ) || EXT2_HAS_RO_COMPAT_FEATURE ( sb , ~ 0U ) || EXT2_HAS_INCOMPAT_FEATURE ( sb , ~ 0U ) ) ) ext2_msg ( sb , KERN_WARNING , ""warning:<S2SV_blank>feature<S2SV_blank>flags<S2SV_blank>set<S2SV_blank>on<S2SV_blank>rev<S2SV_blank>0<S2SV_blank>fs,<S2SV_blank>"" ""running<S2SV_blank>e2fsck<S2SV_blank>is<S2SV_blank>recommended"" ) ; features = EXT2_HAS_INCOMPAT_FEATURE ( sb , ~ EXT2_FEATURE_INCOMPAT_SUPP ) ; if ( features ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>couldn\'t<S2SV_blank>mount<S2SV_blank>because<S2SV_blank>of<S2SV_blank>"" ""unsupported<S2SV_blank>optional<S2SV_blank>features<S2SV_blank>(%x)"" , le32_to_cpu ( features ) ) ; goto failed_mount ; } if ( ! ( sb -> s_flags & MS_RDONLY ) && ( features = EXT2_HAS_RO_COMPAT_FEATURE ( sb , ~ EXT2_FEATURE_RO_COMPAT_SUPP ) ) ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>couldn\'t<S2SV_blank>mount<S2SV_blank>RDWR<S2SV_blank>because<S2SV_blank>of<S2SV_blank>"" ""unsupported<S2SV_blank>optional<S2SV_blank>features<S2SV_blank>(%x)"" , le32_to_cpu ( features ) ) ; goto failed_mount ; } blocksize = BLOCK_SIZE << le32_to_cpu ( sbi -> s_es -> s_log_block_size ) ; if ( sbi -> s_mount_opt & EXT2_MOUNT_DAX ) { if ( blocksize != PAGE_SIZE ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>dax"" ) ; goto failed_mount ; } if ( ! sb -> s_bdev -> bd_disk -> fops -> direct_access ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>dax"" ) ; goto failed_mount ; } } if ( sb -> s_blocksize != blocksize ) { brelse ( bh ) ; if ( ! sb_set_blocksize ( sb , blocksize ) ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>bad<S2SV_blank>blocksize<S2SV_blank>%d"" , blocksize ) ; goto failed_sbi ; } logic_sb_block = ( sb_block * BLOCK_SIZE ) / blocksize ; offset = ( sb_block * BLOCK_SIZE ) % blocksize ; bh = sb_bread ( sb , logic_sb_block ) ; if ( ! bh ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>couldn\'t<S2SV_blank>read"" ""superblock<S2SV_blank>on<S2SV_blank>2nd<S2SV_blank>try"" ) ; goto failed_sbi ; } es = ( struct ext2_super_block * ) ( ( ( char * ) bh -> b_data ) + offset ) ; sbi -> s_es = es ; if ( es -> s_magic != cpu_to_le16 ( EXT2_SUPER_MAGIC ) ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>magic<S2SV_blank>mismatch"" ) ; goto failed_mount ; } } sb -> s_maxbytes = ext2_max_size ( sb -> s_blocksize_bits ) ; sb -> s_max_links = EXT2_LINK_MAX ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT2_GOOD_OLD_REV ) { sbi -> s_inode_size = EXT2_GOOD_OLD_INODE_SIZE ; sbi -> s_first_ino = EXT2_GOOD_OLD_FIRST_INO ; } else { sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; if ( ( sbi -> s_inode_size < EXT2_GOOD_OLD_INODE_SIZE ) || ! is_power_of_2 ( sbi -> s_inode_size ) || ( sbi -> s_inode_size > blocksize ) ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unsupported<S2SV_blank>inode<S2SV_blank>size:<S2SV_blank>%d"" , sbi -> s_inode_size ) ; goto failed_mount ; } } sbi -> s_frag_size = EXT2_MIN_FRAG_SIZE << le32_to_cpu ( es -> s_log_frag_size ) ; if ( sbi -> s_frag_size == 0 ) goto cantfind_ext2 ; sbi -> s_frags_per_block = sb -> s_blocksize / sbi -> s_frag_size ; sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; sbi -> s_frags_per_group = le32_to_cpu ( es -> s_frags_per_group ) ; sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; if ( EXT2_INODE_SIZE ( sb ) == 0 ) goto cantfind_ext2 ; sbi -> s_inodes_per_block = sb -> s_blocksize / EXT2_INODE_SIZE ( sb ) ; if ( sbi -> s_inodes_per_block == 0 || sbi -> s_inodes_per_group == 0 ) goto cantfind_ext2 ; sbi -> s_itb_per_group = sbi -> s_inodes_per_group / sbi -> s_inodes_per_block ; sbi -> s_desc_per_block = sb -> s_blocksize / sizeof ( struct ext2_group_desc ) ; sbi -> s_sbh = bh ; sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; sbi -> s_addr_per_block_bits = ilog2 ( EXT2_ADDR_PER_BLOCK ( sb ) ) ; sbi -> s_desc_per_block_bits = ilog2 ( EXT2_DESC_PER_BLOCK ( sb ) ) ; if ( sb -> s_magic != EXT2_SUPER_MAGIC ) goto cantfind_ext2 ; if ( sb -> s_blocksize != bh -> b_size ) { if ( ! silent ) ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unsupported<S2SV_blank>blocksize"" ) ; goto failed_mount ; } if ( sb -> s_blocksize != sbi -> s_frag_size ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>fragsize<S2SV_blank>%lu<S2SV_blank>!=<S2SV_blank>blocksize<S2SV_blank>%lu"" ""(not<S2SV_blank>supported<S2SV_blank>yet)"" , sbi -> s_frag_size , sb -> s_blocksize ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group > sb -> s_blocksize * 8 ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>#blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu"" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } if ( sbi -> s_frags_per_group > sb -> s_blocksize * 8 ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>#fragments<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu"" , sbi -> s_frags_per_group ) ; goto failed_mount ; } if ( sbi -> s_inodes_per_group > sb -> s_blocksize * 8 ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>#inodes<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu"" , sbi -> s_inodes_per_group ) ; goto failed_mount ; } if ( EXT2_BLOCKS_PER_GROUP ( sb ) == 0 ) goto cantfind_ext2 ; sbi -> s_groups_count = ( ( le32_to_cpu ( es -> s_blocks_count ) - le32_to_cpu ( es -> s_first_data_block ) - 1 ) / EXT2_BLOCKS_PER_GROUP ( sb ) ) + 1 ; db_count = ( sbi -> s_groups_count + EXT2_DESC_PER_BLOCK ( sb ) - 1 ) / EXT2_DESC_PER_BLOCK ( sb ) ; sbi -> s_group_desc = kmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; if ( sbi -> s_group_desc == NULL ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>memory"" ) ; goto failed_mount ; } bgl_lock_init ( sbi -> s_blockgroup_lock ) ; sbi -> s_debts = kcalloc ( sbi -> s_groups_count , sizeof ( * sbi -> s_debts ) , GFP_KERNEL ) ; if ( ! sbi -> s_debts ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>memory"" ) ; goto failed_mount_group_desc ; } for ( i = 0 ; i < db_count ; i ++ ) { block = descriptor_loc ( sb , logic_sb_block , i ) ; sbi -> s_group_desc [ i ] = sb_bread ( sb , block ) ; if ( ! sbi -> s_group_desc [ i ] ) { for ( j = 0 ; j < i ; j ++ ) brelse ( sbi -> s_group_desc [ j ] ) ; ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>group<S2SV_blank>descriptors"" ) ; goto failed_mount_group_desc ; } } if ( ! ext2_check_descriptors ( sb ) ) { ext2_msg ( sb , KERN_ERR , ""group<S2SV_blank>descriptors<S2SV_blank>corrupted"" ) ; goto failed_mount2 ; } sbi -> s_gdb_count = db_count ; get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; spin_lock_init ( & sbi -> s_next_gen_lock ) ; spin_lock_init ( & sbi -> s_rsv_window_lock ) ; sbi -> s_rsv_window_root = RB_ROOT ; sbi -> s_rsv_window_head . rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED ; sbi -> s_rsv_window_head . rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED ; sbi -> s_rsv_window_head . rsv_alloc_hit = 0 ; sbi -> s_rsv_window_head . rsv_goal_size = 0 ; ext2_rsv_window_add ( sb , & sbi -> s_rsv_window_head ) ; err = percpu_counter_init ( & sbi -> s_freeblocks_counter , ext2_count_free_blocks ( sb ) , GFP_KERNEL ) ; if ( ! err ) { err = percpu_counter_init ( & sbi -> s_freeinodes_counter , ext2_count_free_inodes ( sb ) , GFP_KERNEL ) ; } if ( ! err ) { err = percpu_counter_init ( & sbi -> s_dirs_counter , ext2_count_dirs ( sb ) , GFP_KERNEL ) ; } if ( err ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>insufficient<S2SV_blank>memory"" ) ; goto failed_mount3 ; }  sb -> s_op = & ext2_sops ;  sb -> s_export_op = & ext2_export_ops ; sb -> s_xattr = ext2_xattr_handlers ; # ifdef CONFIG_QUOTA sb -> dq_op = & dquot_operations ; sb -> s_qcop = & dquot_quotactl_ops ; sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP ; # endif root = ext2_iget ( sb , EXT2_ROOT_INO ) ; if ( IS_ERR ( root ) ) { ret = PTR_ERR ( root ) ; goto failed_mount3 ; } if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { iput ( root ) ; ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>corrupt<S2SV_blank>root<S2SV_blank>inode,<S2SV_blank>run<S2SV_blank>e2fsck"" ) ; goto failed_mount3 ; } sb -> s_root = d_make_root ( root ) ; if ( ! sb -> s_root ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>get<S2SV_blank>root<S2SV_blank>inode<S2SV_blank>failed"" ) ; ret = - ENOMEM ; goto failed_mount3 ; } if ( EXT2_HAS_COMPAT_FEATURE ( sb , EXT3_FEATURE_COMPAT_HAS_JOURNAL ) ) ext2_msg ( sb , KERN_WARNING , ""warning:<S2SV_blank>mounting<S2SV_blank>ext3<S2SV_blank>filesystem<S2SV_blank>as<S2SV_blank>ext2"" ) ; if ( ext2_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) sb -> s_flags |= MS_RDONLY ; ext2_write_super ( sb ) ; return 0 ; cantfind_ext2 : if ( ! silent ) ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>can\'t<S2SV_blank>find<S2SV_blank>an<S2SV_blank>ext2<S2SV_blank>filesystem<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>%s."" , sb -> s_id ) ; goto failed_mount ; failed_mount3 :  percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ;  percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; failed_mount2 : for ( i = 0 ; i < db_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; failed_mount_group_desc : kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; failed_mount : brelse ( bh ) ; failed_sbi : sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; failed : return ret ; }","# ifdef CONFIG_EXT2_FS_XATTR sbi -> s_mb_cache = ext2_xattr_create_cache ( ) ;if ( ! sbi -> s_mb_cache ) {ext2_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache"" ) ;goto failed_mount3 ;}# endif sb -> s_op = & ext2_sops ;sb -> s_export_op = & ext2_export_ops ;",1210
5,"buggy line: failed_mount3 :  percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ;percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ;cwe id:CWE-19context: static int ext2_fill_super ( struct super_block * sb , void * data , int silent ) { struct buffer_head * bh ; struct ext2_sb_info * sbi ; struct ext2_super_block * es ; struct inode * root ; unsigned long block ; unsigned long sb_block = get_sb_block ( & data ) ; unsigned long logic_sb_block ; unsigned long offset = 0 ; unsigned long def_mount_opts ; long ret = - EINVAL ; int blocksize = BLOCK_SIZE ; int db_count ; int i , j ; __le32 features ; int err ; err = - ENOMEM ; sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; if ( ! sbi ) goto failed ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) { kfree ( sbi ) ; goto failed ; } sb -> s_fs_info = sbi ; sbi -> s_sb_block = sb_block ; spin_lock_init ( & sbi -> s_lock ) ; blocksize = sb_min_blocksize ( sb , BLOCK_SIZE ) ; if ( ! blocksize ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>blocksize"" ) ; goto failed_sbi ; } if ( blocksize != BLOCK_SIZE ) { logic_sb_block = ( sb_block * BLOCK_SIZE ) / blocksize ; offset = ( sb_block * BLOCK_SIZE ) % blocksize ; } else { logic_sb_block = sb_block ; } if ( ! ( bh = sb_bread ( sb , logic_sb_block ) ) ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>superblock"" ) ; goto failed_sbi ; } es = ( struct ext2_super_block * ) ( ( ( char * ) bh -> b_data ) + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; if ( sb -> s_magic != EXT2_SUPER_MAGIC ) goto cantfind_ext2 ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; if ( def_mount_opts & EXT2_DEFM_DEBUG ) set_opt ( sbi -> s_mount_opt , DEBUG ) ; if ( def_mount_opts & EXT2_DEFM_BSDGROUPS ) set_opt ( sbi -> s_mount_opt , GRPID ) ; if ( def_mount_opts & EXT2_DEFM_UID16 ) set_opt ( sbi -> s_mount_opt , NO_UID32 ) ; # ifdef CONFIG_EXT2_FS_XATTR if ( def_mount_opts & EXT2_DEFM_XATTR_USER ) set_opt ( sbi -> s_mount_opt , XATTR_USER ) ; # endif # ifdef CONFIG_EXT2_FS_POSIX_ACL if ( def_mount_opts & EXT2_DEFM_ACL ) set_opt ( sbi -> s_mount_opt , POSIX_ACL ) ; # endif if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT2_ERRORS_PANIC ) set_opt ( sbi -> s_mount_opt , ERRORS_PANIC ) ; else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT2_ERRORS_CONTINUE ) set_opt ( sbi -> s_mount_opt , ERRORS_CONT ) ; else set_opt ( sbi -> s_mount_opt , ERRORS_RO ) ; sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; set_opt ( sbi -> s_mount_opt , RESERVATION ) ; if ( ! parse_options ( ( char * ) data , sb ) ) goto failed_mount ; sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | ( ( EXT2_SB ( sb ) -> s_mount_opt & EXT2_MOUNT_POSIX_ACL ) ? MS_POSIXACL : 0 ) ; sb -> s_iflags |= SB_I_CGROUPWB ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT2_GOOD_OLD_REV && ( EXT2_HAS_COMPAT_FEATURE ( sb , ~ 0U ) || EXT2_HAS_RO_COMPAT_FEATURE ( sb , ~ 0U ) || EXT2_HAS_INCOMPAT_FEATURE ( sb , ~ 0U ) ) ) ext2_msg ( sb , KERN_WARNING , ""warning:<S2SV_blank>feature<S2SV_blank>flags<S2SV_blank>set<S2SV_blank>on<S2SV_blank>rev<S2SV_blank>0<S2SV_blank>fs,<S2SV_blank>"" ""running<S2SV_blank>e2fsck<S2SV_blank>is<S2SV_blank>recommended"" ) ; features = EXT2_HAS_INCOMPAT_FEATURE ( sb , ~ EXT2_FEATURE_INCOMPAT_SUPP ) ; if ( features ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>couldn\'t<S2SV_blank>mount<S2SV_blank>because<S2SV_blank>of<S2SV_blank>"" ""unsupported<S2SV_blank>optional<S2SV_blank>features<S2SV_blank>(%x)"" , le32_to_cpu ( features ) ) ; goto failed_mount ; } if ( ! ( sb -> s_flags & MS_RDONLY ) && ( features = EXT2_HAS_RO_COMPAT_FEATURE ( sb , ~ EXT2_FEATURE_RO_COMPAT_SUPP ) ) ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>couldn\'t<S2SV_blank>mount<S2SV_blank>RDWR<S2SV_blank>because<S2SV_blank>of<S2SV_blank>"" ""unsupported<S2SV_blank>optional<S2SV_blank>features<S2SV_blank>(%x)"" , le32_to_cpu ( features ) ) ; goto failed_mount ; } blocksize = BLOCK_SIZE << le32_to_cpu ( sbi -> s_es -> s_log_block_size ) ; if ( sbi -> s_mount_opt & EXT2_MOUNT_DAX ) { if ( blocksize != PAGE_SIZE ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>dax"" ) ; goto failed_mount ; } if ( ! sb -> s_bdev -> bd_disk -> fops -> direct_access ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>dax"" ) ; goto failed_mount ; } } if ( sb -> s_blocksize != blocksize ) { brelse ( bh ) ; if ( ! sb_set_blocksize ( sb , blocksize ) ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>bad<S2SV_blank>blocksize<S2SV_blank>%d"" , blocksize ) ; goto failed_sbi ; } logic_sb_block = ( sb_block * BLOCK_SIZE ) / blocksize ; offset = ( sb_block * BLOCK_SIZE ) % blocksize ; bh = sb_bread ( sb , logic_sb_block ) ; if ( ! bh ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>couldn\'t<S2SV_blank>read"" ""superblock<S2SV_blank>on<S2SV_blank>2nd<S2SV_blank>try"" ) ; goto failed_sbi ; } es = ( struct ext2_super_block * ) ( ( ( char * ) bh -> b_data ) + offset ) ; sbi -> s_es = es ; if ( es -> s_magic != cpu_to_le16 ( EXT2_SUPER_MAGIC ) ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>magic<S2SV_blank>mismatch"" ) ; goto failed_mount ; } } sb -> s_maxbytes = ext2_max_size ( sb -> s_blocksize_bits ) ; sb -> s_max_links = EXT2_LINK_MAX ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT2_GOOD_OLD_REV ) { sbi -> s_inode_size = EXT2_GOOD_OLD_INODE_SIZE ; sbi -> s_first_ino = EXT2_GOOD_OLD_FIRST_INO ; } else { sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; if ( ( sbi -> s_inode_size < EXT2_GOOD_OLD_INODE_SIZE ) || ! is_power_of_2 ( sbi -> s_inode_size ) || ( sbi -> s_inode_size > blocksize ) ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unsupported<S2SV_blank>inode<S2SV_blank>size:<S2SV_blank>%d"" , sbi -> s_inode_size ) ; goto failed_mount ; } } sbi -> s_frag_size = EXT2_MIN_FRAG_SIZE << le32_to_cpu ( es -> s_log_frag_size ) ; if ( sbi -> s_frag_size == 0 ) goto cantfind_ext2 ; sbi -> s_frags_per_block = sb -> s_blocksize / sbi -> s_frag_size ; sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; sbi -> s_frags_per_group = le32_to_cpu ( es -> s_frags_per_group ) ; sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; if ( EXT2_INODE_SIZE ( sb ) == 0 ) goto cantfind_ext2 ; sbi -> s_inodes_per_block = sb -> s_blocksize / EXT2_INODE_SIZE ( sb ) ; if ( sbi -> s_inodes_per_block == 0 || sbi -> s_inodes_per_group == 0 ) goto cantfind_ext2 ; sbi -> s_itb_per_group = sbi -> s_inodes_per_group / sbi -> s_inodes_per_block ; sbi -> s_desc_per_block = sb -> s_blocksize / sizeof ( struct ext2_group_desc ) ; sbi -> s_sbh = bh ; sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; sbi -> s_addr_per_block_bits = ilog2 ( EXT2_ADDR_PER_BLOCK ( sb ) ) ; sbi -> s_desc_per_block_bits = ilog2 ( EXT2_DESC_PER_BLOCK ( sb ) ) ; if ( sb -> s_magic != EXT2_SUPER_MAGIC ) goto cantfind_ext2 ; if ( sb -> s_blocksize != bh -> b_size ) { if ( ! silent ) ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unsupported<S2SV_blank>blocksize"" ) ; goto failed_mount ; } if ( sb -> s_blocksize != sbi -> s_frag_size ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>fragsize<S2SV_blank>%lu<S2SV_blank>!=<S2SV_blank>blocksize<S2SV_blank>%lu"" ""(not<S2SV_blank>supported<S2SV_blank>yet)"" , sbi -> s_frag_size , sb -> s_blocksize ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group > sb -> s_blocksize * 8 ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>#blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu"" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } if ( sbi -> s_frags_per_group > sb -> s_blocksize * 8 ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>#fragments<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu"" , sbi -> s_frags_per_group ) ; goto failed_mount ; } if ( sbi -> s_inodes_per_group > sb -> s_blocksize * 8 ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>#inodes<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu"" , sbi -> s_inodes_per_group ) ; goto failed_mount ; } if ( EXT2_BLOCKS_PER_GROUP ( sb ) == 0 ) goto cantfind_ext2 ; sbi -> s_groups_count = ( ( le32_to_cpu ( es -> s_blocks_count ) - le32_to_cpu ( es -> s_first_data_block ) - 1 ) / EXT2_BLOCKS_PER_GROUP ( sb ) ) + 1 ; db_count = ( sbi -> s_groups_count + EXT2_DESC_PER_BLOCK ( sb ) - 1 ) / EXT2_DESC_PER_BLOCK ( sb ) ; sbi -> s_group_desc = kmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; if ( sbi -> s_group_desc == NULL ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>memory"" ) ; goto failed_mount ; } bgl_lock_init ( sbi -> s_blockgroup_lock ) ; sbi -> s_debts = kcalloc ( sbi -> s_groups_count , sizeof ( * sbi -> s_debts ) , GFP_KERNEL ) ; if ( ! sbi -> s_debts ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>memory"" ) ; goto failed_mount_group_desc ; } for ( i = 0 ; i < db_count ; i ++ ) { block = descriptor_loc ( sb , logic_sb_block , i ) ; sbi -> s_group_desc [ i ] = sb_bread ( sb , block ) ; if ( ! sbi -> s_group_desc [ i ] ) { for ( j = 0 ; j < i ; j ++ ) brelse ( sbi -> s_group_desc [ j ] ) ; ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>group<S2SV_blank>descriptors"" ) ; goto failed_mount_group_desc ; } } if ( ! ext2_check_descriptors ( sb ) ) { ext2_msg ( sb , KERN_ERR , ""group<S2SV_blank>descriptors<S2SV_blank>corrupted"" ) ; goto failed_mount2 ; } sbi -> s_gdb_count = db_count ; get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; spin_lock_init ( & sbi -> s_next_gen_lock ) ; spin_lock_init ( & sbi -> s_rsv_window_lock ) ; sbi -> s_rsv_window_root = RB_ROOT ; sbi -> s_rsv_window_head . rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED ; sbi -> s_rsv_window_head . rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED ; sbi -> s_rsv_window_head . rsv_alloc_hit = 0 ; sbi -> s_rsv_window_head . rsv_goal_size = 0 ; ext2_rsv_window_add ( sb , & sbi -> s_rsv_window_head ) ; err = percpu_counter_init ( & sbi -> s_freeblocks_counter , ext2_count_free_blocks ( sb ) , GFP_KERNEL ) ; if ( ! err ) { err = percpu_counter_init ( & sbi -> s_freeinodes_counter , ext2_count_free_inodes ( sb ) , GFP_KERNEL ) ; } if ( ! err ) { err = percpu_counter_init ( & sbi -> s_dirs_counter , ext2_count_dirs ( sb ) , GFP_KERNEL ) ; } if ( err ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>insufficient<S2SV_blank>memory"" ) ; goto failed_mount3 ; }  sb -> s_op = & ext2_sops ;  sb -> s_export_op = & ext2_export_ops ; sb -> s_xattr = ext2_xattr_handlers ; # ifdef CONFIG_QUOTA sb -> dq_op = & dquot_operations ; sb -> s_qcop = & dquot_quotactl_ops ; sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP ; # endif root = ext2_iget ( sb , EXT2_ROOT_INO ) ; if ( IS_ERR ( root ) ) { ret = PTR_ERR ( root ) ; goto failed_mount3 ; } if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { iput ( root ) ; ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>corrupt<S2SV_blank>root<S2SV_blank>inode,<S2SV_blank>run<S2SV_blank>e2fsck"" ) ; goto failed_mount3 ; } sb -> s_root = d_make_root ( root ) ; if ( ! sb -> s_root ) { ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>get<S2SV_blank>root<S2SV_blank>inode<S2SV_blank>failed"" ) ; ret = - ENOMEM ; goto failed_mount3 ; } if ( EXT2_HAS_COMPAT_FEATURE ( sb , EXT3_FEATURE_COMPAT_HAS_JOURNAL ) ) ext2_msg ( sb , KERN_WARNING , ""warning:<S2SV_blank>mounting<S2SV_blank>ext3<S2SV_blank>filesystem<S2SV_blank>as<S2SV_blank>ext2"" ) ; if ( ext2_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) sb -> s_flags |= MS_RDONLY ; ext2_write_super ( sb ) ; return 0 ; cantfind_ext2 : if ( ! silent ) ext2_msg ( sb , KERN_ERR , ""error:<S2SV_blank>can\'t<S2SV_blank>find<S2SV_blank>an<S2SV_blank>ext2<S2SV_blank>filesystem<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>%s."" , sb -> s_id ) ; goto failed_mount ; failed_mount3 :  percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ;  percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; failed_mount2 : for ( i = 0 ; i < db_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; failed_mount_group_desc : kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; failed_mount : brelse ( bh ) ; failed_sbi : sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; failed : return ret ; }",failed_mount3 : if ( sbi -> s_mb_cache ) ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ;percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ;,1210
6,buggy line: static int remove_bond ( const bt_bdaddr_t * bd_addr )  {if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ;cwe id:CWE-20context: static int remove_bond ( const bt_bdaddr_t * bd_addr )  {  if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; },static int remove_bond ( const bt_bdaddr_t * bd_addr ) {if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ;if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ;,1211
7,"buggy line: if ( len < tcp_hdrlen )  return - 1 ;cwe id:CWE-416context: static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ;  if ( len < tcp_hdrlen )  return - 1 ; if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( ""unknown<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>path-MTU<S2SV_blank>(%u)\\n"" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt , i ) ) { if ( opt [ i ] == TCPOPT_MSS && opt [ i + 1 ] == TCPOLEN_MSS ) { u_int16_t oldmss ; oldmss = ( opt [ i + 2 ] << 8 ) | opt [ i + 3 ] ; if ( oldmss <= newmss ) return 0 ; opt [ i + 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ i + 3 ] = newmss & 0x00ff ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( oldmss ) , htons ( newmss ) , false ) ; return 0 ; } } if ( len > tcp_hdrlen ) return 0 ;  if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) {  if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; } skb_put ( skb , TCPOLEN_MSS ) ; if ( xt_family ( par ) == NFPROTO_IPV4 ) newmss = min ( newmss , ( u16 ) 536 ) ; else newmss = min ( newmss , ( u16 ) 1220 ) ; opt = ( u_int8_t * ) tcph + sizeof ( struct tcphdr ) ; memmove ( opt + TCPOLEN_MSS , opt , len - sizeof ( struct tcphdr ) ) ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( len ) , htons ( len + TCPOLEN_MSS ) , true ) ; opt [ 0 ] = TCPOPT_MSS ; opt [ 1 ] = TCPOLEN_MSS ; opt [ 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ 3 ] = newmss & 0x00ff ; inet_proto_csum_replace4 ( & tcph -> check , skb , 0 , * ( ( __be32 * ) opt ) , false ) ; oldval = ( ( __be16 * ) tcph ) [ 6 ] ; tcph -> doff += TCPOLEN_MSS / 4 ; inet_proto_csum_replace2 ( & tcph -> check , skb , oldval , ( ( __be16 * ) tcph ) [ 6 ] , false ) ; return TCPOLEN_MSS ; }",if ( len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) ) return - 1 ;if ( tcp_hdrlen >= 15 * 4 ) return 0 ;,1212
8,"buggy line: if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) {if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ;cwe id:CWE-416context: static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ;  if ( len < tcp_hdrlen )  return - 1 ; if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( ""unknown<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>path-MTU<S2SV_blank>(%u)\\n"" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt , i ) ) { if ( opt [ i ] == TCPOPT_MSS && opt [ i + 1 ] == TCPOLEN_MSS ) { u_int16_t oldmss ; oldmss = ( opt [ i + 2 ] << 8 ) | opt [ i + 3 ] ; if ( oldmss <= newmss ) return 0 ; opt [ i + 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ i + 3 ] = newmss & 0x00ff ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( oldmss ) , htons ( newmss ) , false ) ; return 0 ; } } if ( len > tcp_hdrlen ) return 0 ;  if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) {  if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; } skb_put ( skb , TCPOLEN_MSS ) ; if ( xt_family ( par ) == NFPROTO_IPV4 ) newmss = min ( newmss , ( u16 ) 536 ) ; else newmss = min ( newmss , ( u16 ) 1220 ) ; opt = ( u_int8_t * ) tcph + sizeof ( struct tcphdr ) ; memmove ( opt + TCPOLEN_MSS , opt , len - sizeof ( struct tcphdr ) ) ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( len ) , htons ( len + TCPOLEN_MSS ) , true ) ; opt [ 0 ] = TCPOPT_MSS ; opt [ 1 ] = TCPOLEN_MSS ; opt [ 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ 3 ] = newmss & 0x00ff ; inet_proto_csum_replace4 ( & tcph -> check , skb , 0 , * ( ( __be32 * ) opt ) , false ) ; oldval = ( ( __be16 * ) tcph ) [ 6 ] ; tcph -> doff += TCPOLEN_MSS / 4 ; inet_proto_csum_replace2 ( & tcph -> check , skb , oldval , ( ( __be16 * ) tcph ) [ 6 ] , false ) ; return TCPOLEN_MSS ; }","if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) {if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ;",1212
9,"buggy line: if ( numrows < 0 || numcols < 0 ) {return 0 ;}return 0 ;}matrix -> datasize_ = numrows * numcols ;if ( matrix -> maxrows_ > 0 ) {if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) {jas_matrix_destroy ( matrix ) ;return 0 ;jas_matrix_destroy ( matrix ) ;return 0 ;cwe id:CWE-190context: jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ;  if ( numrows < 0 || numcols < 0 ) {   return 0 ;  } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {  return 0 ;  } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ;  matrix -> datasize_ = numrows * numcols ;  if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) {  jas_matrix_destroy ( matrix ) ;  return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) {  jas_matrix_destroy ( matrix ) ;  return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ;  } ","size_t size ;matrix = 0 ;if ( numrows < 0 || numcols < 0 ) {goto error ;}goto error ;}matrix -> datasize_ = 0 ;if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) {goto error ;jas_matrix_destroy ( matrix ) ;return 0 ;",1213
10,"buggy line: }cwe id:CWE-190context: jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ;  if ( numrows < 0 || numcols < 0 ) {   return 0 ;  } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {  return 0 ;  } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ;  matrix -> datasize_ = numrows * numcols ;  if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) {  jas_matrix_destroy ( matrix ) ;  return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) {  jas_matrix_destroy ( matrix ) ;  return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ;  } ",error : if ( matrix ) {jas_matrix_destroy ( matrix ) ;}return 0 ;},1213
11,"buggy line: ipv6_select_ident ( fh ) ;fh -> nexthdr = nexthdr ;cwe id:CWE-000context: int ip6_fragment ( struct sk_buff * skb , int ( * output ) ( struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; __be32 frag_id = 0 ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( ! skb -> local_df && skb -> len > mtu ) { skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return - EMSGSIZE ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } mtu -= hlen + sizeof ( struct frag_hdr ) ; if ( skb_has_frag_list ( skb ) ) { int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < hlen ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; return - ENOMEM ; } __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ;  ipv6_select_ident ( fh ) ;  fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; frag_id = fh -> identification ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next != NULL ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; dst_release ( & rt -> dst ) ; return 0 ; } while ( frag ) { skb = frag -> next ; kfree_skb ( frag ) ; frag = skb ; } IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; dst_release ( & rt -> dst ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; * prevhdr = NEXTHDR_FRAGMENT ; while ( left > 0 ) { len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } if ( ( frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + LL_ALLOCATED_SPACE ( rt -> dst . dev ) , GFP_ATOMIC ) ) == NULL ) { NETDEBUG ( KERN_INFO ""IPv6:<S2SV_blank>frag:<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>new<S2SV_blank>fragment!\\n"" ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , LL_RESERVED_SPACE ( rt -> dst . dev ) ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; if ( ! frag_id ) {  ipv6_select_ident ( fh ) ;  frag_id = fh -> identification ; } else fh -> identification = frag_id ; if ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) BUG ( ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; kfree_skb ( skb ) ; return err ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }","ipv6_select_ident ( fh , rt ) ;fh -> nexthdr = nexthdr ;",1214
12,"buggy line: ipv6_select_ident ( fh ) ;frag_id = fh -> identification ;cwe id:CWE-000context: int ip6_fragment ( struct sk_buff * skb , int ( * output ) ( struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; __be32 frag_id = 0 ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( ! skb -> local_df && skb -> len > mtu ) { skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return - EMSGSIZE ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } mtu -= hlen + sizeof ( struct frag_hdr ) ; if ( skb_has_frag_list ( skb ) ) { int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < hlen ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; return - ENOMEM ; } __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ;  ipv6_select_ident ( fh ) ;  fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; frag_id = fh -> identification ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next != NULL ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; dst_release ( & rt -> dst ) ; return 0 ; } while ( frag ) { skb = frag -> next ; kfree_skb ( frag ) ; frag = skb ; } IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; dst_release ( & rt -> dst ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; * prevhdr = NEXTHDR_FRAGMENT ; while ( left > 0 ) { len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } if ( ( frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + LL_ALLOCATED_SPACE ( rt -> dst . dev ) , GFP_ATOMIC ) ) == NULL ) { NETDEBUG ( KERN_INFO ""IPv6:<S2SV_blank>frag:<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>new<S2SV_blank>fragment!\\n"" ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , LL_RESERVED_SPACE ( rt -> dst . dev ) ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; if ( ! frag_id ) {  ipv6_select_ident ( fh ) ;  frag_id = fh -> identification ; } else fh -> identification = frag_id ; if ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) BUG ( ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; kfree_skb ( skb ) ; return err ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }","ipv6_select_ident ( fh , rt ) ;frag_id = fh -> identification ;",1214
13,"buggy line: static void  ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh )  {struct mb_cache_entry * ce ;int error ;ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;if ( ! ce ) {error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) {ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;error = 0 ;}else {ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;mb_cache_entry_release ( ce ) ;}cwe id:CWE-19context: static void  ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh )  { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ;  struct mb_cache_entry * ce ;  int error ;  ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;  if ( ! ce ) { ea_bdebug ( bh , ""out<S2SV_blank>of<S2SV_blank>memory"" ) ; return ; }  error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ;  if ( error ) {  mb_cache_entry_free ( ce ) ;   if ( error == - EBUSY ) {  ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;  error = 0 ;  } } else { ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;  mb_cache_entry_release ( ce ) ;  } }","static void ext4_xattr_cache_insert ( struct mb2_cache * ext4_mb_cache , struct buffer_head * bh ) {int error ;ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;if ( ! ce ) {error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;else ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;",1215
14,"buggy line: SCSIDiskReq * r ;req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ;r = DO_UPCAST ( SCSIDiskReq , req , req ) ;r -> iov . iov_base = qemu_blockalign ( s -> bs , SCSI_DMA_BUF_SIZE ) ;cwe id:CWE-119context: static SCSIRequest * scsi_new_request ( SCSIDevice * d , uint32_t tag , uint32_t lun , void * hba_private ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; SCSIRequest * req ;  SCSIDiskReq * r ;  req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ;  r = DO_UPCAST ( SCSIDiskReq , req , req ) ;  r -> iov . iov_base = qemu_blockalign ( s -> bs , SCSI_DMA_BUF_SIZE ) ; return req ; }","req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ;",1216
15,"buggy line: int avail ;int expect ;avail = buf -> len - buf -> cursor ;expect = 8 + 8 + nxip * 8 ;if ( nxip < 0 || nxip > avail || expect > avail )  goto bad_format ;cwe id:CWE-189context: Datum txid_snapshot_recv ( PG_FUNCTION_ARGS ) { StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; TxidSnapshot * snap ; txid last = 0 ; int nxip ; int i ;  int avail ;  int expect ; txid xmin , xmax ; nxip = pq_getmsgint ( buf , 4 ) ;  avail = buf -> len - buf -> cursor ;  expect = 8 + 8 + nxip * 8 ;  if ( nxip < 0 || nxip > avail || expect > avail )  goto bad_format ; xmin = pq_getmsgint64 ( buf ) ; xmax = pq_getmsgint64 ( buf ) ; if ( xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID ) goto bad_format ; snap = palloc ( TXID_SNAPSHOT_SIZE ( nxip ) ) ; snap -> xmin = xmin ; snap -> xmax = xmax ; snap -> nxip = nxip ; SET_VARSIZE ( snap , TXID_SNAPSHOT_SIZE ( nxip ) ) ; for ( i = 0 ; i < nxip ; i ++ ) { txid cur = pq_getmsgint64 ( buf ) ; if ( cur <= last || cur < xmin || cur >= xmax ) goto bad_format ; snap -> xip [ i ] = cur ; last = cur ; } PG_RETURN_POINTER ( snap ) ; bad_format : elog ( ERROR , ""invalid<S2SV_blank>snapshot<S2SV_blank>data"" ) ; return ( Datum ) NULL ; }",if ( nxip < 0 || nxip > avail || expect > avail ) goto bad_format ;,1217
16,"buggy line: static inline void header_put_le_3byte ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 )   {psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ;};}cwe id:CWE-119context: static inline void header_put_le_3byte ( SF_PRIVATE * psf , int x )  { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 )   { psf -> header [ psf -> headindex ++ ] = x ;   psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;   psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ;   } ;  }","static inline void header_put_le_3byte ( SF_PRIVATE * psf , int x ) {psf -> header ) - 3 ) {psf -> header . ptr [ psf -> header . ptr [ psf -> headindex ++ ] = ( x >> 16 ) ;}",1218
17,"buggy line: if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA )  ret = - EADDRNOTAVAIL ;cwe id:CWE-399context: static int rds_ib_laddr_check ( __be32 addr ) { int ret ; struct rdma_cm_id * cm_id ; struct sockaddr_in sin ; cm_id = rdma_create_id ( NULL , NULL , RDMA_PS_TCP , IB_QPT_RC ) ; if ( IS_ERR ( cm_id ) ) return PTR_ERR ( cm_id ) ; memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; sin . sin_addr . s_addr = addr ; ret = rdma_bind_addr ( cm_id , ( struct sockaddr * ) & sin ) ;  if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA )  ret = - EADDRNOTAVAIL ; rdsdebug ( ""addr<S2SV_blank>%pI4<S2SV_blank>ret<S2SV_blank>%d<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d\\n"" , & addr , ret , cm_id -> device ? cm_id -> device -> node_type : - 1 ) ; rdma_destroy_id ( cm_id ) ; return ret ; }",if ( ret || ! cm_id -> device || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) ret = - EADDRNOTAVAIL ;,1219
18,"buggy line: struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ;struct xfrm_dump_info info ;BUILD_BUG_ON ( sizeof ( struct xfrm_policy_walk ) > sizeof ( cb -> args ) - sizeof ( cb -> args [ 0 ] ) ) ;if ( ! cb -> args [ 0 ] ) {cb -> args [ 0 ] = 1 ;cwe id:CWE-416context: static int xfrm_dump_policy ( struct sk_buff * skb , struct netlink_callback * cb ) { struct net * net = sock_net ( skb -> sk ) ;  struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ;   struct xfrm_dump_info info ;  BUILD_BUG_ON ( sizeof ( struct xfrm_policy_walk ) > sizeof ( cb -> args ) - sizeof ( cb -> args [ 0 ] ) ) ; info . in_skb = cb -> skb ; info . out_skb = skb ; info . nlmsg_seq = cb -> nlh -> nlmsg_seq ; info . nlmsg_flags = NLM_F_MULTI ;  if ( ! cb -> args [ 0 ] ) {  cb -> args [ 0 ] = 1 ; xfrm_policy_walk_init ( walk , XFRM_POLICY_TYPE_ANY ) ; } ( void ) xfrm_policy_walk ( net , walk , dump_one_policy , & info ) ; return skb -> len ; }",struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ;struct xfrm_dump_info info ;if ( ! cb -> args [ 0 ] ) {cb -> args [ 0 ] = 1 ;,1220
19,"buggy line: epoll_t * epoll = _cast_epoll ( epoll_ ) ;oe_errno = 0 ;if ( oe_syscall_write_ocall ( & ret , epoll -> host_fd , buf , count ) != OE_OK )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;cwe id:CWE-552context: static ssize_t _epoll_write ( oe_fd_t * epoll_ , const void * buf , size_t count ) { ssize_t ret = - 1 ;  epoll_t * epoll = _cast_epoll ( epoll_ ) ;  oe_errno = 0 ;  if ( oe_syscall_write_ocall ( & ret , epoll -> host_fd , buf , count ) != OE_OK )  OE_RAISE_ERRNO ( OE_EINVAL ) ;  done :  return ret ; }","epoll_t * file = _cast_epoll ( epoll_ ) ;oe_errno = 0 ;if ( ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_write_ocall ( & ret , file -> host_fd , buf , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;",1221
20,"buggy line: struct dentry * upper = ovl_dentry_upper ( dentry ) ;int err ;err = - ESTALE ;if ( upper -> d_parent == upperdir ) {dget ( upper ) ;dput ( upper ) ;ovl_dentry_version_inc ( dentry -> d_parent ) ;}if ( ! err ) d_drop ( dentry ) ;inode_unlock ( dir ) ;return err ;cwe id:CWE-20context: static int ovl_remove_upper ( struct dentry * dentry , bool is_dir ) { struct dentry * upperdir = ovl_dentry_upper ( dentry -> d_parent ) ; struct inode * dir = upperdir -> d_inode ;  struct dentry * upper = ovl_dentry_upper ( dentry ) ;  int err ; inode_lock_nested ( dir , I_MUTEX_PARENT ) ;  err = - ESTALE ;   if ( upper -> d_parent == upperdir ) {  dget ( upper ) ; if ( is_dir ) err = vfs_rmdir ( dir , upper ) ; else err = vfs_unlink ( dir , upper , NULL ) ;  dput ( upper ) ;  ovl_dentry_version_inc ( dentry -> d_parent ) ;  }  if ( ! err ) d_drop ( dentry ) ;  inode_unlock ( dir ) ;  return err ; }","struct dentry * upper ;int err ;upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ;err = PTR_ERR ( upper ) ;if ( IS_ERR ( upper ) ) goto out_unlock ;err = - ESTALE ;if ( upper == ovl_dentry_upper ( dentry ) ) {ovl_dentry_version_inc ( dentry -> d_parent ) ;}dput ( upper ) ;if ( ! err ) d_drop ( dentry ) ;out_unlock : inode_unlock ( dir ) ;return err ;",1222
21,"buggy line: errstr = parse_global_option ( CMD_INITIALIZE , NULL , NULL ) ;if ( errstr ) {if ( * section_ptr == & new_service_options )  s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ;else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , ( * section_ptr ) -> servname ) ;cwe id:CWE-295context: NOEXPORT int init_section ( int eof , SERVICE_OPTIONS * * section_ptr ) { char * errstr ; # ifndef USE_WIN32 ( * section_ptr ) -> option . log_stderr = new_global_options . option . log_stderr ; # endif if ( * section_ptr == & new_service_options ) {  errstr = parse_global_option ( CMD_INITIALIZE , NULL , NULL ) ;  if ( errstr ) { s_log ( LOG_ERR , ""Global<S2SV_blank>options:<S2SV_blank>%s"" , errstr ) ; return 1 ; } } if ( * section_ptr != & new_service_options || eof ) {  if ( * section_ptr == & new_service_options )  s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ; else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , ( * section_ptr ) -> servname ) ; errstr = parse_service_option ( CMD_INITIALIZE , section_ptr , NULL , NULL ) ; if ( errstr ) { if ( * section_ptr == & new_service_options ) s_log ( LOG_ERR , ""Inetd<S2SV_blank>mode:<S2SV_blank>%s"" , errstr ) ; else s_log ( LOG_ERR , ""Service<S2SV_blank>[%s]:<S2SV_blank>%s"" , ( * section_ptr ) -> servname , errstr ) ; return 1 ; } } return 0 ; }","errstr = parse_global_option ( CMD_INITIALIZE , & new_global_options , NULL , NULL ) ;if ( errstr ) {",1223
22,"buggy line: if ( ! * ptrptr && ! ( nmemb && size ) )  return AVERROR ( ENOMEM ) ;cwe id:CWE-000context: int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) { void * * ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ;  if ( ! * ptrptr && ! ( nmemb && size ) )  return AVERROR ( ENOMEM ) ; return 0 ; }",if ( ! * ptrptr && nmemb && size ) ) return AVERROR ( ENOMEM ) ;,1224
23,"buggy line: if ( a -> name == MAPI_BODY_HTML )  {else if ( a -> name == MAPI_RTF_COMPRESSED )  {cwe id:CWE-125context: int parse_file ( FILE * input_file , char * directory , char * body_filename , char * body_pref , int flags ) { uint32 d ; uint16 key ; Attr * attr = NULL ; File * file = NULL ; int rtf_size = 0 , html_size = 0 ; MessageBody body ; memset ( & body , '\\0' , sizeof ( MessageBody ) ) ; g_flags = flags ; d = geti32 ( input_file ) ; if ( d != TNEF_SIGNATURE ) { fprintf ( stdout , ""Seems<S2SV_blank>not<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>TNEF<S2SV_blank>file\\n"" ) ; return 1 ; } key = geti16 ( input_file ) ; debug_print ( ""TNEF<S2SV_blank>Key:<S2SV_blank>%hx\\n"" , key ) ; while ( data_left ( input_file ) ) { attr = read_object ( input_file ) ; if ( attr == NULL ) break ; if ( attr -> name == attATTACHRENDDATA ) { if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; } else { file = CHECKED_XCALLOC ( File , 1 ) ; } } switch ( attr -> lvl_type ) { case LVL_MESSAGE : if ( attr -> name == attBODY ) { body . text_body = get_text_data ( attr ) ; } else if ( attr -> name == attMAPIPROPS ) { MAPI_Attr * * mapi_attrs = mapi_attr_read ( attr -> len , attr -> buf ) ; if ( mapi_attrs ) { int i ; for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) { MAPI_Attr * a = mapi_attrs [ i ] ;  if ( a -> name == MAPI_BODY_HTML )  { body . html_bodies = get_html_data ( a ) ; html_size = a -> num_values ; }  else if ( a -> name == MAPI_RTF_COMPRESSED )  { body . rtf_bodies = get_rtf_data ( a ) ; rtf_size = a -> num_values ; } } mapi_attr_free_list ( mapi_attrs ) ; XFREE ( mapi_attrs ) ; } } break ; case LVL_ATTACHMENT : file_add_attr ( file , attr ) ; break ; default : fprintf ( stderr , ""Invalid<S2SV_blank>lvl<S2SV_blank>type<S2SV_blank>on<S2SV_blank>attribute:<S2SV_blank>%d\\n"" , attr -> lvl_type ) ; return 1 ; break ; } attr_free ( attr ) ; XFREE ( attr ) ; } if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; XFREE ( file ) ; } if ( flags & SAVEBODY ) { int i = 0 ; int all_flag = 0 ; if ( strcmp ( body_pref , ""all"" ) == 0 ) { all_flag = 1 ; body_pref = ""rht"" ; } for ( ; i < 3 ; i ++ ) { File * * files = get_body_files ( body_filename , body_pref [ i ] , & body ) ; if ( files ) { int j = 0 ; for ( ; files [ j ] ; j ++ ) { file_write ( files [ j ] , directory ) ; file_free ( files [ j ] ) ; XFREE ( files [ j ] ) ; } XFREE ( files ) ; if ( ! all_flag ) break ; } } } if ( body . text_body ) { free_bodies ( body . text_body , 1 ) ; XFREE ( body . text_body ) ; } if ( rtf_size > 0 ) { free_bodies ( body . rtf_bodies , rtf_size ) ; XFREE ( body . rtf_bodies ) ; } if ( html_size > 0 ) { free_bodies ( body . html_bodies , html_size ) ; XFREE ( body . html_bodies ) ; } return 0 ; }",if ( a -> type == szMAPI_BINARY && a -> name == MAPI_BODY_HTML ) {else if ( a -> type == szMAPI_BINARY && a -> name == MAPI_RTF_COMPRESSED ) {,1225
24,"buggy line: WritePixel ( i , & context , casspecial ) ;}act_code = old_code ;}while ( act_code > clr ) {* ( -- stackp ) = ab_suffx [ act_code ] ;act_code = ab_prfx [ act_code ] ;}casspecial = ( u8 ) act_code ;* ( -- stackp ) = casspecial ;WritePixels ( i , & context , stackp , stack_top - stackp ) ;npix -= ( stack_top - stackp ) ;cwe id:CWE-787context: static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } context . Xtogo = i -> width ; context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Local<S2SV_blank>palette\\n"" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , ""interlaced<S2SV_blank>"" ) ; fprintf ( i -> parent -> log , ""img<S2SV_blank>pos(%hu,%hu)<S2SV_blank>size<S2SV_blank>%hux%hu<S2SV_blank>palbits=%hhu<S2SV_blank>imgbits=%hhu<S2SV_blank>ncolors=%hu\\n"" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""End<S2SV_blank>of<S2SV_blank>image<S2SV_blank>code\\n"" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""assez<S2SV_blank>de<S2SV_blank>pixels,<S2SV_blank>On<S2SV_blank>se<S2SV_blank>casse<S2SV_blank>!\\n"" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Code<S2SV_blank>clear<S2SV_blank>(free=%hu)<S2SV_blank>npix=%ld\\n"" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ;  WritePixel ( i , & context , casspecial ) ; npix -- ;  } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ;  WritePixels ( i , & context , stackp , stack_top - stackp ) ;  npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }","if ( npix > 0 ) WritePixel ( i , & context , casspecial ) ;}if ( npix >= ( stack_top - stackp ) ;npix -= ( stack_top - stackp ) ;",1226
25,"buggy line: default :  errno = EINVAL ;cwe id:CWE-399context: public int magic_getparam ( struct magic_set * ms , int param , void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : * ( size_t * ) val = ms -> indir_max ; return 0 ; case MAGIC_PARAM_NAME_MAX : * ( size_t * ) val = ms -> name_max ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : * ( size_t * ) val = ms -> elf_phnum_max ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : * ( size_t * ) val = ms -> elf_shnum_max ; return 0 ;  default :  errno = EINVAL ; return - 1 ; } }",case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ;return 0 ;default : errno = EINVAL ;,1227
26,"buggy line: jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\\goto error ;}if ( box -> type != JP2_BOX_JP ) {jas_eprintf ( ""error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\\goto error ;}if ( box -> data . jp . magic != JP2_JP_MAGIC ) {jas_eprintf ( ""incorrect<S2SV_blank>magic<S2SV_blank>number\\\goto error ;}jp2_box_destroy ( box ) ;box = 0 ;if ( ! ( box = jp2_box_get ( in ) ) ) {goto error ;if ( box -> type != JP2_BOX_FTYP ) {jas_eprintf ( ""expecting<S2SV_blank>file<S2SV_blank>type<S2SV_blank>box\\\goto error ;}jp2_box_destroy ( box ) ;box = 0 ;found = 0 ;while ( ( box = jp2_box_get ( in ) ) ) {if ( jas_getdbglevel ( ) >= 1 ) {jas_eprintf ( ""box<S2SV_blank>type<S2SV_blank>%s\\\}cwe id:CWE-476context: jas_image_t * jp2_decode ( jas_stream_t * in , char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\n"" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( ""error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\n"" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( ""incorrect<S2SV_blank>magic<S2SV_blank>number\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( ""expecting<S2SV_blank>file<S2SV_blank>type<S2SV_blank>box\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) {  jas_eprintf ( ""box<S2SV_blank>type<S2SV_blank>%s\\n"" , box -> info -> name ) ;  } switch ( box -> type ) { case JP2_BOX_JP2C : found = 1 ; break ; case JP2_BOX_IHDR : if ( ! dec -> ihdr ) { dec -> ihdr = box ; box = 0 ; } break ; case JP2_BOX_BPCC : if ( ! dec -> bpcc ) { dec -> bpcc = box ; box = 0 ; } break ; case JP2_BOX_CDEF : if ( ! dec -> cdef ) { dec -> cdef = box ; box = 0 ; } break ; case JP2_BOX_PCLR : if ( ! dec -> pclr ) { dec -> pclr = box ; box = 0 ; } break ; case JP2_BOX_CMAP : if ( ! dec -> cmap ) { dec -> cmap = box ; box = 0 ; } break ; case JP2_BOX_COLR : if ( ! dec -> colr ) { dec -> colr = box ; box = 0 ; } break ; } if ( box ) { jp2_box_destroy ( box ) ; box = 0 ; } if ( found ) { break ; } } if ( ! found ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>code<S2SV_blank>stream<S2SV_blank>found\\n"" ) ; goto error ; } if ( ! ( dec -> image = jpc_decode ( in , optstr ) ) ) { jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; goto error ; } if ( ! dec -> ihdr ) { jas_eprintf ( ""error:<S2SV_blank>missing<S2SV_blank>IHDR<S2SV_blank>box\\n"" ) ; goto error ; } if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>components\\n"" ) ; goto error ; } samedtype = true ; dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; for ( i = 1 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { samedtype = false ; break ; } } if ( ( samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_DTYPETOBPC ( dtype ) ) || ( ! samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_IHDR_BPCNULL ) ) { jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\n"" ) ; } if ( dec -> ihdr -> data . ihdr . comptype != JP2_IHDR_COMPTYPE ) { jas_eprintf ( ""error:<S2SV_blank>unsupported<S2SV_blank>compression<S2SV_blank>type\\n"" ) ; goto error ; } if ( dec -> bpcc ) { if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; } if ( ! samedtype ) { for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != JP2_BPCTODTYPE ( dec -> bpcc -> data . bpcc . bpcs [ i ] ) ) { jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\n"" ) ; } } } else { jas_eprintf ( ""warning:<S2SV_blank>superfluous<S2SV_blank>BPCC<S2SV_blank>box\\n"" ) ; } } if ( ! dec -> colr ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>COLR<S2SV_blank>box\\n"" ) ; goto error ; } switch ( dec -> colr -> data . colr . method ) { case JP2_COLR_ENUM : jas_image_setclrspc ( dec -> image , jp2_getcs ( & dec -> colr -> data . colr ) ) ; break ; case JP2_COLR_ICC : iccprof = jas_iccprof_createfrombuf ( dec -> colr -> data . colr . iccp , dec -> colr -> data . colr . iccplen ) ; if ( ! iccprof ) { jas_eprintf ( ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>ICC<S2SV_blank>profile\\n"" ) ; goto error ; } jas_iccprof_gethdr ( iccprof , & icchdr ) ; jas_eprintf ( ""ICC<S2SV_blank>Profile<S2SV_blank>CS<S2SV_blank>%08x\\n"" , icchdr . colorspc ) ; jas_image_setclrspc ( dec -> image , fromiccpcs ( icchdr . colorspc ) ) ; dec -> image -> cmprof_ = jas_cmprof_createfromiccprof ( iccprof ) ; assert ( dec -> image -> cmprof_ ) ; jas_iccprof_destroy ( iccprof ) ; break ; } if ( dec -> cmap && ! dec -> pclr ) { jas_eprintf ( ""warning:<S2SV_blank>missing<S2SV_blank>PCLR<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>CMAP<S2SV_blank>box\\n"" ) ; jp2_box_destroy ( dec -> cmap ) ; dec -> cmap = 0 ; } if ( ! dec -> cmap && dec -> pclr ) { jas_eprintf ( ""warning:<S2SV_blank>missing<S2SV_blank>CMAP<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>PCLR<S2SV_blank>box\\n"" ) ; jp2_box_destroy ( dec -> pclr ) ; dec -> pclr = 0 ; } dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; if ( dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>component<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CMAP<S2SV_blank>box\\n"" ) ; goto error ; } if ( dec -> cmap -> data . cmap . ents [ i ] . pcol >= dec -> pclr -> data . pclr . numchans ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>CMAP<S2SV_blank>LUT<S2SV_blank>index\\n"" ) ; goto error ; } } } if ( ! ( dec -> chantocmptlut = jas_alloc2 ( dec -> numchans , sizeof ( uint_fast16_t ) ) ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>memory\\n"" ) ; goto error ; } if ( ! dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { dec -> chantocmptlut [ i ] = i ; } } else { cmapd = & dec -> cmap -> data . cmap ; pclrd = & dec -> pclr -> data . pclr ; cdefd = & dec -> cdef -> data . cdef ; for ( channo = 0 ; channo < cmapd -> numchans ; ++ channo ) { cmapent = & cmapd -> ents [ channo ] ; if ( cmapent -> map == JP2_CMAP_DIRECT ) { dec -> chantocmptlut [ channo ] = channo ; } else if ( cmapent -> map == JP2_CMAP_PALETTE ) { lutents = jas_alloc2 ( pclrd -> numlutents , sizeof ( int_fast32_t ) ) ; for ( i = 0 ; i < pclrd -> numlutents ; ++ i ) { lutents [ i ] = pclrd -> lutdata [ cmapent -> pcol + i * pclrd -> numchans ] ; } newcmptno = jas_image_numcmpts ( dec -> image ) ; jas_image_depalettize ( dec -> image , cmapent -> cmptno , pclrd -> numlutents , lutents , JP2_BPCTODTYPE ( pclrd -> bpc [ cmapent -> pcol ] ) , newcmptno ) ; dec -> chantocmptlut [ channo ] = newcmptno ; jas_free ( lutents ) ; # if 0 if ( dec -> cdef ) { cdefent = jp2_cdef_lookup ( cdefd , channo ) ; if ( ! cdefent ) { abort ( ) ; } jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , cdefent -> type , cdefent -> assoc ) ) ; } else { jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , channo + 1 ) ) ; } # endif } } } for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ; } if ( dec -> cdef ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cdef -> data . cdef . ents [ i ] . channo >= dec -> numchans ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>channel<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CDEF<S2SV_blank>box\\n"" ) ; goto error ; } jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ dec -> cdef -> data . cdef . ents [ i ] . channo ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , dec -> cdef -> data . cdef . ents [ i ] . type , dec -> cdef -> data . cdef . ents [ i ] . assoc ) ) ; } } else { for ( i = 0 ; i < dec -> numchans ; ++ i ) { jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ i ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , i + 1 ) ) ; } } for ( i = jas_image_numcmpts ( dec -> image ) ; i > 0 ; -- i ) { if ( jas_image_cmpttype ( dec -> image , i - 1 ) == JAS_IMAGE_CT_UNKNOWN ) { jas_image_delcmpt ( dec -> image , i - 1 ) ; } } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>components\\n"" ) ; goto error ; } # if 0 jas_eprintf ( ""no<S2SV_blank>of<S2SV_blank>components<S2SV_blank>is<S2SV_blank>%d\\n"" , jas_image_numcmpts ( dec -> image ) ) ; # endif image = dec -> image ; dec -> image = 0 ; jp2_dec_destroy ( dec ) ; return image ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( dec ) { jp2_dec_destroy ( dec ) ; } return 0 ; }","jas_eprintf ( ""got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\\",1228
27,"buggy line: err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ;if ( err < 0 ) return err ;cwe id:CWE-189context: int sequencer_write ( int dev , struct file * file , const char __user * buf , int count ) { unsigned char event_rec [ EV_SZ ] , ev_code ; int p = 0 , c , ev_size ; int mode = translate_mode ( file ) ; dev = dev >> 4 ; DEB ( printk ( ""sequencer_write(dev=%d,<S2SV_blank>count=%d)\\n"" , dev , count ) ) ; if ( mode == OPEN_READ ) return - EIO ; c = count ; while ( c >= 4 ) { if ( copy_from_user ( ( char * ) event_rec , & ( buf ) [ p ] , 4 ) ) goto out ; ev_code = event_rec [ 0 ] ; if ( ev_code == SEQ_FULLSIZE ) { int err , fmt ; dev = * ( unsigned short * ) & event_rec [ 2 ] ; if ( dev < 0 || dev >= max_synthdev || synth_devs [ dev ] == NULL ) return - ENXIO ; if ( ! ( synth_open_mask & ( 1 << dev ) ) ) return - ENXIO ; fmt = ( * ( short * ) & event_rec [ 0 ] ) & 0xffff ;  err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ;  if ( err < 0 ) return err ; return err ; } if ( ev_code >= 128 ) { if ( seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED ) { printk ( KERN_WARNING ""Sequencer:<S2SV_blank>Invalid<S2SV_blank>level<S2SV_blank>2<S2SV_blank>event<S2SV_blank>%x\\n"" , ev_code ) ; return - EINVAL ; } ev_size = 8 ; if ( c < ev_size ) { if ( ! seq_playing ) seq_startplay ( ) ; return count - c ; } if ( copy_from_user ( ( char * ) & event_rec [ 4 ] , & ( buf ) [ p + 4 ] , 4 ) ) goto out ; } else { if ( seq_mode == SEQ_2 ) { printk ( KERN_WARNING ""Sequencer:<S2SV_blank>4<S2SV_blank>byte<S2SV_blank>event<S2SV_blank>in<S2SV_blank>level<S2SV_blank>2<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } ev_size = 4 ; if ( event_rec [ 0 ] != SEQ_MIDIPUTC ) obsolete_api_used = 1 ; } if ( event_rec [ 0 ] == SEQ_MIDIPUTC ) { if ( ! midi_opened [ event_rec [ 2 ] ] ) { int err , mode ; int dev = event_rec [ 2 ] ; if ( dev >= max_mididev || midi_devs [ dev ] == NULL ) { return - ENXIO ; } mode = translate_mode ( file ) ; if ( ( err = midi_devs [ dev ] -> open ( dev , mode , sequencer_midi_input , sequencer_midi_output ) ) < 0 ) { seq_reset ( ) ; printk ( KERN_WARNING ""Sequencer<S2SV_blank>Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Midi<S2SV_blank>#%d\\n"" , dev ) ; return err ; } midi_opened [ dev ] = 1 ; } } if ( ! seq_queue ( event_rec , ( file -> f_flags & ( O_NONBLOCK ) ? 1 : 0 ) ) ) { int processed = count - c ; if ( ! seq_playing ) seq_startplay ( ) ; if ( ! processed && ( file -> f_flags & O_NONBLOCK ) ) return - EAGAIN ; else return processed ; } p += ev_size ; c -= ev_size ; } if ( ! seq_playing ) seq_startplay ( ) ; out : return count ; }","err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf + p , c , 0 ) ;if ( err < 0 ) return err ;",1229
28,"buggy line: journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ;if ( offset == 0 ) ClearPageChecked ( page ) ;cwe id:CWE-000context: static void ext4_invalidatepage ( struct page * page , unsigned long offset ) {  journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ;  if ( offset == 0 ) ClearPageChecked ( page ) ; if ( journal ) jbd2_journal_invalidatepage ( journal , page , offset ) ; else block_invalidatepage ( page , offset ) ; }","journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ;if ( ext4_should_dioread_nolock ( page -> mapping -> host ) ) ext4_invalidatepage_free_endio ( page , offset ) ;if ( offset == 0 ) ClearPageChecked ( page ) ;",1230
29,"buggy line: trak = gf_isom_get_track ( movie -> moov , i + 1 ) ;GF_SAFEALLOC ( writer , TrackWriter ) ;if ( ! writer ) goto exit ;cwe id:CWE-476context: GF_Err SetupWriters ( MovieWriter * mw , GF_List * writers , u8 interleaving ) { u32 i , trackCount ; TrackWriter * writer ; GF_TrackBox * trak ; GF_ISOFile * movie = mw -> movie ; mw -> total_samples = mw -> nb_done = 0 ; if ( ! movie -> moov ) return GF_OK ; trackCount = gf_list_count ( movie -> moov -> trackList ) ; for ( i = 0 ; i < trackCount ; i ++ ) {  trak = gf_isom_get_track ( movie -> moov , i + 1 ) ;   GF_SAFEALLOC ( writer , TrackWriter ) ;  if ( ! writer ) goto exit ; writer -> sampleNumber = 1 ; writer -> mdia = trak -> Media ; writer -> stbl = trak -> Media -> information -> sampleTable ; writer -> timeScale = trak -> Media -> mediaHeader -> timeScale ; writer -> all_dref_mode = Media_SelfContainedType ( writer -> mdia ) ; if ( trak -> sample_encryption ) writer -> prevent_dispatch = GF_TRUE ; writer -> isDone = 0 ; writer -> DTSprev = 0 ; writer -> chunkDur = 0 ; writer -> chunkSize = 0 ; writer -> constant_size = writer -> constant_dur = 0 ; if ( writer -> stbl -> SampleSize -> sampleSize ) writer -> constant_size = writer -> stbl -> SampleSize -> sampleSize ; if ( writer -> stbl -> TimeToSample -> nb_entries == 1 ) { writer -> constant_dur = writer -> stbl -> TimeToSample -> entries [ 0 ] . sampleDelta ; if ( writer -> constant_dur > 1 ) writer -> constant_dur = 0 ; } if ( ! writer -> constant_dur || ! writer -> constant_size || ( writer -> constant_size >= 10 ) ) writer -> constant_size = writer -> constant_dur = 0 ; writer -> stsc = ( GF_SampleToChunkBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_STSC ) ; if ( ! writer -> stsc ) return GF_OUT_OF_MEM ; if ( writer -> stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { writer -> stco = gf_isom_box_new ( GF_ISOM_BOX_TYPE_STCO ) ; } else { writer -> stco = gf_isom_box_new ( GF_ISOM_BOX_TYPE_CO64 ) ; } if ( ! writer -> stco ) return GF_OUT_OF_MEM ; if ( interleaving ) writer -> stbl -> MaxSamplePerChunk = 0 ; if ( Media_IsSelfContained ( writer -> mdia , 1 ) ) mw -> total_samples += writer -> stbl -> SampleSize -> sampleCount ; if ( movie -> storageMode != GF_ISOM_STORE_INTERLEAVED ) { gf_list_add ( writers , writer ) ; } else { if ( writer -> mdia -> information -> InfoHeader && writer -> mdia -> information -> InfoHeader -> type == GF_ISOM_BOX_TYPE_SMHD ) { gf_list_add ( writers , writer ) ; } else { gf_list_insert ( writers , writer , 0 ) ; } } if ( movie -> sample_groups_in_traf && trak -> Media -> information -> sampleTable ) { gf_isom_box_array_del_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) ; trak -> Media -> information -> sampleTable -> sampleGroupsDescription = NULL ; } } return GF_OK ; exit : CleanWriters ( writers ) ; return GF_OUT_OF_MEM ; }","GF_SampleTableBox * stbl ;trak = gf_isom_get_track ( movie -> moov , i + 1 ) ;stbl = ( trak -> Media && trak -> Media -> information ) ? trak -> Media -> information -> sampleTable : NULL ;if ( ! stbl || ! stbl -> SampleSize || ! stbl -> ChunkOffset || ! stbl -> SampleToChunk ) {return GF_ISOM_INVALID_FILE ;}GF_SAFEALLOC ( writer , TrackWriter ) ;if ( ! writer ) goto exit ;",1231
30,"buggy line: static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize )  {cwe id:CWE-787context:  static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize )  { UINT32 left ; UINT32 runlength = 1 ; UINT32 planeSize = 0 ; left = originalSize ; while ( left > 4 && planeSize < originalSize - 4 ) { if ( left > 5 && * in == * ( in + 1 ) ) { runlength ++ ; } else if ( runlength == 1 ) { * out ++ = * in ; planeSize ++ ; } else if ( runlength < 256 ) { * out ++ = * in ; * out ++ = * in ; * out ++ = runlength - 2 ; runlength = 1 ; planeSize += 3 ; } else { * out ++ = * in ; * out ++ = * in ; * out ++ = 0xFF ; * out ++ = ( runlength & 0x000000FF ) ; * out ++ = ( runlength & 0x0000FF00 ) >> 8 ; * out ++ = ( runlength & 0x00FF0000 ) >> 16 ; * out ++ = ( runlength & 0xFF000000 ) >> 24 ; runlength = 1 ; planeSize += 7 ; } in ++ ; left -- ; } if ( planeSize < originalSize - 4 ) CopyMemory ( out , in , 4 ) ; planeSize += 4 ; return planeSize ; }","static UINT32 nsc_rle_encode ( const BYTE * in , BYTE * out , UINT32 originalSize ) {",1232
31,"buggy line: unsigned short height = 0 ;char * terminal = getenv ( ""TERM"" ) ;char md5data [ 100 ] ;unsigned char md5sum [ 17 ] ;int plen ;md5_state_t state ;# if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( md5data , sizeof ( md5data ) ) ;mlock ( md5sum , sizeof ( md5data ) ) ;# endif  md5data [ 0 ] = 0 ;strncpy ( md5data + 1 , password , 82 ) ;md5data [ 83 ] = \'\\\\0\' ;memcpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ;md5_init ( & state ) ;md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ;md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ;cwe id:CWE-119context: static void send_auth ( char * username , char * password ) { struct mt_packet data ; unsigned short width = 0 ; unsigned short height = 0 ; char * terminal = getenv ( ""TERM"" ) ; char md5data [ 100 ] ; unsigned char md5sum [ 17 ] ;  int plen ;  md5_state_t state ; # if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( md5data , sizeof ( md5data ) ) ; mlock ( md5sum , sizeof ( md5data ) ) ; # endif  md5data [ 0 ] = 0 ;   strncpy ( md5data + 1 , password , 82 ) ;  md5data [ 83 ] = '\\0' ;  memcpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ;  md5_init ( & state ) ;  md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ;  md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ; md5sum [ 0 ] = 0 ; init_packet ( & data , MT_PTYPE_DATA , srcmac , dstmac , sessionkey , outcounter ) ; plen = add_control_packet ( & data , MT_CPTYPE_PASSWORD , md5sum , 17 ) ; plen += add_control_packet ( & data , MT_CPTYPE_USERNAME , username , strlen ( username ) ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_TYPE , terminal , strlen ( terminal ) ) ; if ( is_a_tty && get_terminal_size ( & width , & height ) != - 1 ) { width = htole16 ( width ) ; height = htole16 ( height ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_WIDTH , & width , 2 ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_HEIGHT , & height , 2 ) ; } outcounter += plen ; send_udp ( & data , 1 ) ; }","memcpy ( md5data + 1 , password , 82 ) ;md5data [ 83 ] = \'\\\\0\' ;memcpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ;md5_init ( & state ) ;md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ;md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ;",1233
32,"buggy line: void * dllhandle ;if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\cwe id:CWE-000context: void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) {  void * dllhandle ;  if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""...\\n"" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = ""."" ; Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""<S2SV_blank>from<S2SV_blank>\\""%s\\""...\\n"" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( ""fs_basepath"" ) ; if ( ! basePath || ! * basePath ) basePath = ""."" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""<S2SV_blank>from<S2SV_blank>\\""%s\\""...\\n"" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( ""Loading<S2SV_blank>\\""%s\\""<S2SV_blank>failed\\n"" , name ) ; } } return dllhandle ; }","void * dllhandle ;if ( COM_CompareExtension ( name , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , name ) ;return NULL ;}if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\",1234
33,buggy line: if ( tree_top ) {if ( tree_top -> label ) SNMP_FREE ( tree_top -> label ) ;SNMP_FREE ( tree_top ) ;}tree_head = NULL ;Mib = NULL ;if ( _mibindexes ) {int i ;for ( i = 0 ;i < _mibindex ;++ i ) SNMP_FREE ( _mibindexes [ i ] ) ;free ( _mibindexes ) ;_mibindex = 0 ;_mibindex_max = 0 ;_mibindexes = NULL ;}cwe id:CWE-59context: void shutdown_mib ( void ) { unload_all_mibs ( ) ; if ( tree_top ) { if ( tree_top -> label ) SNMP_FREE ( tree_top -> label ) ; SNMP_FREE ( tree_top ) ; } tree_head = NULL ; Mib = NULL ;  if ( _mibindexes ) {  int i ; for ( i = 0 ; i < _mibindex ; ++ i ) SNMP_FREE ( _mibindexes [ i ] ) ; free ( _mibindexes ) ; _mibindex = 0 ; _mibindex_max = 0 ; _mibindexes = NULL ; } if ( Prefix != NULL && Prefix != & Standard_Prefix [ 0 ] ) SNMP_FREE ( Prefix ) ; if ( Prefix ) Prefix = NULL ; SNMP_FREE ( confmibs ) ; SNMP_FREE ( confmibdir ) ; },+ i ) SNMP_FREE ( _mibindexes [ i ] ) ;,1235
34,"buggy line: # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL )  # define PCDGetBits ( n ) {cwe id:CWE-401context: static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL )  # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } }  typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) { PCDGetBits ( 8 ) ; length = ( sum & 0xff ) + 1 ; pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , sizeof ( * pcd_table [ i ] ) ) ; if ( pcd_table [ i ] == ( PCDTable * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;  ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" ,  image -> filename ) ; } r = pcd_table [ i ] ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { PCDGetBits ( 8 ) ; r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; if ( r -> length > 16 ) {  buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;  return ( MagickFalse ) ; } PCDGetBits ( 16 ) ; r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; PCDGetBits ( 8 ) ; r -> key = ( unsigned char ) ( sum & 0xff ) ; r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; r ++ ; } pcd_length [ i ] = ( size_t ) length ; } for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; count = 0 ; length = 0 ; plane = 0 ; row = 0 ; q = luma ; for ( ; ; ) { if ( IsSync ( sum ) != 0 ) { PCDGetBits ( 16 ) ; row = ( ( sum >> 9 ) & 0x1fff ) ; if ( row == image -> rows ) break ; PCDGetBits ( 8 ) ; plane = sum >> 30 ; PCDGetBits ( 16 ) ; switch ( plane ) { case 0 : { q = luma + row * image -> columns ; count = ( ssize_t ) image -> columns ; break ; } case 2 : { q = chroma1 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } case 3 : { q = chroma2 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } default : { for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowBinaryException ( CorruptImageError , ""CorruptImage"" , image -> filename ) ; } } length = pcd_length [ plane ] ; continue ; } r = pcd_table [ plane ] ; for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) r ++ ; if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""SkipToSyncByte"" , ""`%s\'"" , image -> filename ) ; while ( ( sum & 0x00fff000 ) != 0x00fff000 ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; continue ; } if ( r -> key < 128 ) quantum = ( ssize_t ) ( * q ) + r -> key ; else quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; q ++ ; PCDGetBits ( r -> length ) ; count -- ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; return ( MagickTrue ) ; }",# define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) # define PCDGetBits ( n ) \\\\\,1236
35,"buggy line: }typedef struct PCDTable {cwe id:CWE-401context: static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL )  # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } }  typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) { PCDGetBits ( 8 ) ; length = ( sum & 0xff ) + 1 ; pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , sizeof ( * pcd_table [ i ] ) ) ; if ( pcd_table [ i ] == ( PCDTable * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;  ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" ,  image -> filename ) ; } r = pcd_table [ i ] ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { PCDGetBits ( 8 ) ; r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; if ( r -> length > 16 ) {  buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;  return ( MagickFalse ) ; } PCDGetBits ( 16 ) ; r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; PCDGetBits ( 8 ) ; r -> key = ( unsigned char ) ( sum & 0xff ) ; r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; r ++ ; } pcd_length [ i ] = ( size_t ) length ; } for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; count = 0 ; length = 0 ; plane = 0 ; row = 0 ; q = luma ; for ( ; ; ) { if ( IsSync ( sum ) != 0 ) { PCDGetBits ( 16 ) ; row = ( ( sum >> 9 ) & 0x1fff ) ; if ( row == image -> rows ) break ; PCDGetBits ( 8 ) ; plane = sum >> 30 ; PCDGetBits ( 16 ) ; switch ( plane ) { case 0 : { q = luma + row * image -> columns ; count = ( ssize_t ) image -> columns ; break ; } case 2 : { q = chroma1 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } case 3 : { q = chroma2 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } default : { for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowBinaryException ( CorruptImageError , ""CorruptImage"" , image -> filename ) ; } } length = pcd_length [ plane ] ; continue ; } r = pcd_table [ plane ] ; for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) r ++ ; if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""SkipToSyncByte"" , ""`%s\'"" , image -> filename ) ; while ( ( sum & 0x00fff000 ) != 0x00fff000 ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; continue ; } if ( r -> key < 128 ) quantum = ( ssize_t ) ( * q ) + r -> key ; else quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; q ++ ; PCDGetBits ( r -> length ) ; count -- ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; return ( MagickTrue ) ; }",\\\\\typedef struct PCDTable {,1236
36,"buggy line: ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" ,  image -> filename ) ;cwe id:CWE-401context: static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL )  # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } }  typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) { PCDGetBits ( 8 ) ; length = ( sum & 0xff ) + 1 ; pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , sizeof ( * pcd_table [ i ] ) ) ; if ( pcd_table [ i ] == ( PCDTable * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;  ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" ,  image -> filename ) ; } r = pcd_table [ i ] ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { PCDGetBits ( 8 ) ; r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; if ( r -> length > 16 ) {  buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;  return ( MagickFalse ) ; } PCDGetBits ( 16 ) ; r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; PCDGetBits ( 8 ) ; r -> key = ( unsigned char ) ( sum & 0xff ) ; r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; r ++ ; } pcd_length [ i ] = ( size_t ) length ; } for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; count = 0 ; length = 0 ; plane = 0 ; row = 0 ; q = luma ; for ( ; ; ) { if ( IsSync ( sum ) != 0 ) { PCDGetBits ( 16 ) ; row = ( ( sum >> 9 ) & 0x1fff ) ; if ( row == image -> rows ) break ; PCDGetBits ( 8 ) ; plane = sum >> 30 ; PCDGetBits ( 16 ) ; switch ( plane ) { case 0 : { q = luma + row * image -> columns ; count = ( ssize_t ) image -> columns ; break ; } case 2 : { q = chroma1 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } case 3 : { q = chroma2 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } default : { for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowBinaryException ( CorruptImageError , ""CorruptImage"" , image -> filename ) ; } } length = pcd_length [ plane ] ; continue ; } r = pcd_table [ plane ] ; for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) r ++ ; if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""SkipToSyncByte"" , ""`%s\'"" , image -> filename ) ; while ( ( sum & 0x00fff000 ) != 0x00fff000 ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; continue ; } if ( r -> key < 128 ) quantum = ( ssize_t ) ( * q ) + r -> key ; else quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; q ++ ; PCDGetBits ( r -> length ) ; count -- ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; return ( MagickTrue ) ; }","for ( j = 0 ;j < i ;j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ;ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;",1236
37,"buggy line: buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;return ( MagickFalse ) ;cwe id:CWE-401context: static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL )  # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } }  typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) { PCDGetBits ( 8 ) ; length = ( sum & 0xff ) + 1 ; pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , sizeof ( * pcd_table [ i ] ) ) ; if ( pcd_table [ i ] == ( PCDTable * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;  ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" ,  image -> filename ) ; } r = pcd_table [ i ] ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { PCDGetBits ( 8 ) ; r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; if ( r -> length > 16 ) {  buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;  return ( MagickFalse ) ; } PCDGetBits ( 16 ) ; r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; PCDGetBits ( 8 ) ; r -> key = ( unsigned char ) ( sum & 0xff ) ; r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; r ++ ; } pcd_length [ i ] = ( size_t ) length ; } for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; count = 0 ; length = 0 ; plane = 0 ; row = 0 ; q = luma ; for ( ; ; ) { if ( IsSync ( sum ) != 0 ) { PCDGetBits ( 16 ) ; row = ( ( sum >> 9 ) & 0x1fff ) ; if ( row == image -> rows ) break ; PCDGetBits ( 8 ) ; plane = sum >> 30 ; PCDGetBits ( 16 ) ; switch ( plane ) { case 0 : { q = luma + row * image -> columns ; count = ( ssize_t ) image -> columns ; break ; } case 2 : { q = chroma1 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } case 3 : { q = chroma2 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } default : { for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowBinaryException ( CorruptImageError , ""CorruptImage"" , image -> filename ) ; } } length = pcd_length [ plane ] ; continue ; } r = pcd_table [ plane ] ; for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) r ++ ; if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""SkipToSyncByte"" , ""`%s\'"" , image -> filename ) ; while ( ( sum & 0x00fff000 ) != 0x00fff000 ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; continue ; } if ( r -> key < 128 ) quantum = ( ssize_t ) ( * q ) + r -> key ; else quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; q ++ ; PCDGetBits ( r -> length ) ; count -- ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; return ( MagickTrue ) ; }",buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;for ( j = 0 ;j <= i ;j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ;return ( MagickFalse ) ;,1236
38,"buggy line: if ( kwonlyargs == NULL ) {cwe id:CWE-125context: static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ;  if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }",if ( i < NCH ( n ) && kwonlyargs == NULL ) {,1237
39,"buggy line: if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;cwe id:CWE-125context: static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ;  if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }","if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;",1237
40,"buggy line: cwe id:CWE-20context: static void test_headers_bad ( Test * test , gconstpointer data ) { GHashTable * headers ; headers = web_socket_util_new_headers ( ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=1;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=2;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ;  g_hash_table_destroy ( headers ) ;  }","g_hash_table_remove_all ( headers ) ;g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""cockpit=d"" ) ) ;if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ;",1238
41,"buggy line: g_hash_table_destroy ( headers ) ;}cwe id:CWE-20context: static void test_headers_bad ( Test * test , gconstpointer data ) { GHashTable * headers ; headers = web_socket_util_new_headers ( ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=1;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=2;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ;  g_hash_table_destroy ( headers ) ;  }",g_hash_table_destroy ( headers ) ;},1238
42,"buggy line: # ifdef HAVE_IPV6  char * p ;if ( * ( str ) == \'[\' && str_len > 1 ) {p = memchr ( str + 1 , \']\' , str_len - 2 ) ;if ( ! p || * ( p + 1 ) != \':\' ) {* portno = atoi ( p + 2 ) ;return estrndup ( str + 1 , p - str - 1 ) ;cwe id:CWE-918context: static inline char * parse_ip_address_ex ( const char * str , size_t str_len , int * portno , int get_err , zend_string * * err ) { char * colon ; char * host = NULL ; # ifdef HAVE_IPV6  char * p ;  if ( * ( str ) == '[' && str_len > 1 ) {  p = memchr ( str + 1 , ']' , str_len - 2 ) ;  if ( ! p || * ( p + 1 ) != ':' ) { if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; }  * portno = atoi ( p + 2 ) ;  return estrndup ( str + 1 , p - str - 1 ) ; } # endif if ( str_len ) { colon = memchr ( str , ':' , str_len - 1 ) ; } else { colon = NULL ; } if ( colon ) {  * portno = atoi ( colon + 1 ) ;  host = estrndup ( str , colon - str ) ;  } else {  if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; }  return host ;  }","# ifdef HAVE_IPV6 if ( * ( str ) == \'[\' && str_len > 1 ) {char * p = memchr ( str + 1 , \']\' , str_len - 2 ) , * e = NULL ;if ( ! p || * ( p + 1 ) != \':\' ) {* portno = strtol ( p + 2 ) ;return estrndup ( str + 1 , p - str - 1 ) ;",1239
43,"buggy line: * portno = atoi ( colon + 1 ) ;host = estrndup ( str , colon - str ) ;}else {if ( get_err ) {return host ;}cwe id:CWE-918context: static inline char * parse_ip_address_ex ( const char * str , size_t str_len , int * portno , int get_err , zend_string * * err ) { char * colon ; char * host = NULL ; # ifdef HAVE_IPV6  char * p ;  if ( * ( str ) == '[' && str_len > 1 ) {  p = memchr ( str + 1 , ']' , str_len - 2 ) ;  if ( ! p || * ( p + 1 ) != ':' ) { if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; }  * portno = atoi ( p + 2 ) ;  return estrndup ( str + 1 , p - str - 1 ) ; } # endif if ( str_len ) { colon = memchr ( str , ':' , str_len - 1 ) ; } else { colon = NULL ; } if ( colon ) {  * portno = atoi ( colon + 1 ) ;  host = estrndup ( str , colon - str ) ;  } else {  if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; }  return host ;  }","char * e = NULL ;* portno = strtol ( colon + 1 , & e , 10 ) ;if ( ! e || ! * e ) {return estrndup ( str , colon - str ) ;}}if ( get_err ) {",1239
44,"buggy line: \\\}cwe id:CWE-000context: static int jpc_qcd_dumpparms ( jpc_ms_t * ms , FILE * out ) { jpc_qcd_t * qcd = & ms -> parms . qcd ; int i ; fprintf ( out , ""qntsty<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numguard<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numstepsizes<S2SV_blank>=<S2SV_blank>%d\\n"" , ( int ) qcd -> compparms . qntsty , qcd -> compparms . numguard , qcd -> compparms . numstepsizes ) ; for ( i = 0 ; i < qcd -> compparms . numstepsizes ; ++ i ) { fprintf ( out , ""expn[%d]<S2SV_blank>=<S2SV_blank>0x%04x;<S2SV_blank>mant[%d]<S2SV_blank>=<S2SV_blank>0x%04x;\\n"" ,  i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) ,   i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ;  } return 0 ; }",\\\},1240
45,"buggy line: for ( row = 0 ;vpx_memcpy ( dst , src , src_ybc -> y_width ) ;src += src_ybc -> y_stride ;cwe id:CWE-119context: void vpx_yv12_copy_y_c ( const YV12_BUFFER_CONFIG * src_ybc , YV12_BUFFER_CONFIG * dst_ybc ) { int row ; const uint8_t * src = src_ybc -> y_buffer ; uint8_t * dst = dst_ybc -> y_buffer ;  for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) {   vpx_memcpy ( dst , src , src_ybc -> y_width ) ;  src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } }","# if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) {const uint16_t * src16 = CONVERT_TO_SHORTPTR ( src ) ;uint16_t * dst16 = CONVERT_TO_SHORTPTR ( dst ) ;for ( row = 0 ;memcpy ( dst16 , src16 , src_ybc -> y_width * sizeof ( uint16_t ) ) ;src16 += src_ybc -> y_stride ;dst16 += dst_ybc -> y_stride ;}return ;}# endif for ( row = 0 ;row < src_ybc -> y_height ;++ row ) {memcpy ( dst , src , src_ybc -> y_width ) ;src += src_ybc -> y_stride ;",1241
46,"buggy line: cwe id:CWE-119context: static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } if ( c -> nreslevels < s -> reduction_factor ) c -> nreslevels2decode = 1 ; else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblk<S2SV_blank>size<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; }  c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ;  if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extra<S2SV_blank>cblk<S2SV_blank>styles<S2SV_blank>%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }","if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) {avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ;return AVERROR_PATCHWELCOME ;}",1242
47,"buggy line: c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ;if ( c -> cblk_style != 0 ) {cwe id:CWE-119context: static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } if ( c -> nreslevels < s -> reduction_factor ) c -> nreslevels2decode = 1 ; else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblk<S2SV_blank>size<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; }  c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ;  if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extra<S2SV_blank>cblk<S2SV_blank>styles<S2SV_blank>%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }",c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ;if ( c -> cblk_style != 0 ) {,1242
48,"buggy line: if ( '%' == * ptr ) {if ( '%' == ptr [ 1 ] ) {cwe id:CWE-119context: void ourWriteOut ( CURL * curl , struct OutStruct * outs , const char * writeinfo ) { FILE * stream = stdout ; const char * ptr = writeinfo ; char * stringp = NULL ; long longinfo ; double doubleinfo ; while ( ptr && * ptr ) {  if ( '%' == * ptr ) {  if ( '%' == ptr [ 1 ] ) { fputc ( '%' , stream ) ; ptr += 2 ; } else { char * end ; char keepit ; int i ; if ( '{' == ptr [ 1 ] ) { bool match = FALSE ; end = strchr ( ptr , '}' ) ; ptr += 2 ; if ( ! end ) { fputs ( ""%{"" , stream ) ; continue ; } keepit = * end ; * end = 0 ; for ( i = 0 ; replacements [ i ] . name ; i ++ ) { if ( curl_strequal ( ptr , replacements [ i ] . name ) ) { match = TRUE ; switch ( replacements [ i ] . id ) { case VAR_EFFECTIVE_URL : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_EFFECTIVE_URL , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_HTTP_CODE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_RESPONSE_CODE , & longinfo ) ) fprintf ( stream , ""%03ld"" , longinfo ) ; break ; case VAR_HTTP_CODE_PROXY : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_HTTP_CONNECTCODE , & longinfo ) ) fprintf ( stream , ""%03ld"" , longinfo ) ; break ; case VAR_HEADER_SIZE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_HEADER_SIZE , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_REQUEST_SIZE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_REQUEST_SIZE , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_NUM_CONNECTS : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_NUM_CONNECTS , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_REDIRECT_COUNT : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_REDIRECT_COUNT , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_REDIRECT_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_REDIRECT_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_TOTAL_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_TOTAL_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_NAMELOOKUP_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_NAMELOOKUP_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_CONNECT_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_CONNECT_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_APPCONNECT_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_APPCONNECT_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_PRETRANSFER_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_PRETRANSFER_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_STARTTRANSFER_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_STARTTRANSFER_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_SIZE_UPLOAD : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SIZE_UPLOAD , & doubleinfo ) ) fprintf ( stream , ""%.0f"" , doubleinfo ) ; break ; case VAR_SIZE_DOWNLOAD : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SIZE_DOWNLOAD , & doubleinfo ) ) fprintf ( stream , ""%.0f"" , doubleinfo ) ; break ; case VAR_SPEED_DOWNLOAD : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SPEED_DOWNLOAD , & doubleinfo ) ) fprintf ( stream , ""%.3f"" , doubleinfo ) ; break ; case VAR_SPEED_UPLOAD : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SPEED_UPLOAD , & doubleinfo ) ) fprintf ( stream , ""%.3f"" , doubleinfo ) ; break ; case VAR_CONTENT_TYPE : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_CONTENT_TYPE , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_FTP_ENTRY_PATH : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_FTP_ENTRY_PATH , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_REDIRECT_URL : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_REDIRECT_URL , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_SSL_VERIFY_RESULT : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SSL_VERIFYRESULT , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_PROXY_SSL_VERIFY_RESULT : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_PROXY_SSL_VERIFYRESULT , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_EFFECTIVE_FILENAME : if ( outs -> filename ) fprintf ( stream , ""%s"" , outs -> filename ) ; break ; case VAR_PRIMARY_IP : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_PRIMARY_IP , & stringp ) ) fprintf ( stream , ""%s"" , stringp ) ; break ; case VAR_PRIMARY_PORT : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_PRIMARY_PORT , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_LOCAL_IP : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_LOCAL_IP , & stringp ) ) fprintf ( stream , ""%s"" , stringp ) ; break ; case VAR_LOCAL_PORT : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_LOCAL_PORT , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_HTTP_VERSION : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_HTTP_VERSION , & longinfo ) ) { const char * version = ""0"" ; switch ( longinfo ) { case CURL_HTTP_VERSION_1_0 : version = ""1.0"" ; break ; case CURL_HTTP_VERSION_1_1 : version = ""1.1"" ; break ; case CURL_HTTP_VERSION_2_0 : version = ""2"" ; break ; } fprintf ( stream , version ) ; } break ; case VAR_SCHEME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SCHEME , & stringp ) ) fprintf ( stream , ""%s"" , stringp ) ; break ; default : break ; } break ; } } if ( ! match ) { fprintf ( stderr , ""curl:<S2SV_blank>unknown<S2SV_blank>--write-out<S2SV_blank>variable:<S2SV_blank>\'%s\'\\n"" , ptr ) ; } ptr = end + 1 ; * end = keepit ; } else { fputc ( '%' , stream ) ; fputc ( ptr [ 1 ] , stream ) ; ptr += 2 ; } } } else if ( '\\\\' == * ptr ) { switch ( ptr [ 1 ] ) { case 'r' : fputc ( '\\r' , stream ) ; break ; case 'n' : fputc ( '\\n' , stream ) ; break ; case 't' : fputc ( '\\t' , stream ) ; break ; default : fputc ( * ptr , stream ) ; fputc ( ptr [ 1 ] , stream ) ; break ; } ptr += 2 ; } else { fputc ( * ptr , stream ) ; ptr ++ ; } } }",if ( '%' == * ptr && ptr [ 1 ] ) {if ( '%' == ptr [ 1 ] ) {,1243
49,"buggy line: static void encode_rd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , TOKENEXTRA * * tp ) {MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ;vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;for ( mi_col = tile -> mi_col_start ;mi_col += MI_BLOCK_SIZE ) {int dummy_rate ;int64_t dummy_dist ;BLOCK_SIZE i ;MACROBLOCK * x = & cpi -> mb ;for ( i = BLOCK_4X4 ;const int num_4x4_w = num_4x4_blocks_wide_lookup [ i ] ;const int num_4x4_h = num_4x4_blocks_high_lookup [ i ] ;const int num_4x4_blk = MAX ( 4 , num_4x4_w * num_4x4_h ) ;for ( x -> sb_index = 0 ;x -> sb_index < 4 ;++ x -> sb_index ) for ( x -> mb_index = 0 ;x -> mb_index < 4 ;++ x -> mb_index ) for ( x -> b_index = 0 ;x -> b_index < 16 / num_4x4_blk ;++ x -> b_index ) get_block_context ( x , i ) -> pred_interp_filter = SWITCHABLE ;}}vp9_zero ( cpi -> mb . pred_mv ) ;if ( ( sf -> partition_search_type == SEARCH_PARTITION &&  sf -> use_lastframe_partitioning ) || sf -> partition_search_type == FIXED_PARTITION ||  sf -> partition_search_type == VAR_BASED_PARTITION ||  sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) {const int idx_str = cm -> mi_stride * mi_row + mi_col ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ;MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ;cpi -> mb . source_variance = UINT_MAX ;if ( sf -> partition_search_type == FIXED_PARTITION ) {set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , sf -> always_this_block_size ) ;rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,  & dummy_rate , & dummy_dist , 1 ) ;}cwe id:CWE-119context:  static void encode_rd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; int mi_col ;  vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ;  vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;  for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ;  mi_col += MI_BLOCK_SIZE ) {  int dummy_rate ;  int64_t dummy_dist ;  BLOCK_SIZE i ;  MACROBLOCK * x = & cpi -> mb ; if ( sf -> adaptive_pred_interp_filter ) {  for ( i = BLOCK_4X4 ; i < BLOCK_8X8 ; ++ i ) {  const int num_4x4_w = num_4x4_blocks_wide_lookup [ i ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ i ] ; const int num_4x4_blk = MAX ( 4 , num_4x4_w * num_4x4_h ) ; for ( x -> sb_index = 0 ; x -> sb_index < 4 ; ++ x -> sb_index ) for ( x -> mb_index = 0 ; x -> mb_index < 4 ; ++ x -> mb_index ) for ( x -> b_index = 0 ; x -> b_index < 16 / num_4x4_blk ; ++ x -> b_index ) get_block_context ( x , i ) -> pred_interp_filter = SWITCHABLE ; } } vp9_zero ( cpi -> mb . pred_mv ) ;  if ( ( sf -> partition_search_type == SEARCH_PARTITION &&  sf -> use_lastframe_partitioning ) || sf -> partition_search_type == FIXED_PARTITION ||  sf -> partition_search_type == VAR_BASED_PARTITION ||  sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) { const int idx_str = cm -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ; cpi -> mb . source_variance = UINT_MAX ; if ( sf -> partition_search_type == FIXED_PARTITION ) {  set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;  set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , sf -> always_this_block_size ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,  & dummy_rate , & dummy_dist , 1 ) ;  } else if ( sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) { BLOCK_SIZE bsize ; set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; bsize = get_rd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ; set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 ) ; } else if ( sf -> partition_search_type == VAR_BASED_PARTITION ) { choose_partitioning ( cpi , tile , mi_row , mi_col ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 ) ; } else { if ( ( cm -> current_video_frame % sf -> last_partitioning_redo_frequency ) == 0 || cm -> prev_mi == 0 || cm -> show_frame == 0 || cm -> frame_type == KEY_FRAME || cpi -> rc . is_src_frame_alt_ref || ( ( sf -> use_lastframe_partitioning == LAST_FRAME_PARTITION_LOW_MOTION ) && sb_has_motion ( cm , prev_mi_8x8 ) ) ) { if ( sf -> auto_min_max_partition_size ) { set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile , mi_row , mi_col , & sf -> min_partition_size , & sf -> max_partition_size ) ; } rd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; } else { if ( sf -> constrain_copy_partition && sb_has_motion ( cm , prev_mi_8x8 ) ) constrain_copy_partitioning ( cpi , tile , mi_8x8 , prev_mi_8x8 , mi_row , mi_col , BLOCK_16X16 ) ; else copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 ) ; } } } else { if ( sf -> auto_min_max_partition_size ) { set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile , mi_row , mi_col , & sf -> min_partition_size , & sf -> max_partition_size ) ; } rd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; } } }","static void encode_rd_sb_row ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) {TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;memset ( & xd -> left_context ) ) ;memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;for ( mi_col = tile_info -> mi_col_start ;mi_col += MI_BLOCK_SIZE ) {const struct segmentation * const seg = & cm -> seg ;int dummy_rate ;int64_t dummy_dist ;RD_COST dummy_rdc ;int i ;int seg_skip = 0 ;const int idx_str = cm -> mi_stride * mi_row + mi_col ;MODE_INFO * * mi = cm -> mi_grid_visible + idx_str ;for ( i = 0 ;++ i ) td -> leaf_tree [ i ] . pred_interp_filter = SWITCHABLE ;for ( i = 0 ;i < 64 ;+ x -> sb_index ) for ( x -> mb_index = 0 ;+ x -> mb_index ) for ( x -> b_index = 0 ;+ x -> b_index ) get_block_context ( x , i ) -> pred_interp_filter = SWITCHABLE ;td -> pc_tree [ i ] . vertical [ 0 ] . pred_interp_filter = SWITCHABLE ;td -> pc_tree [ i ] . vertical [ 1 ] . pred_interp_filter = SWITCHABLE ;td -> pc_tree [ i ] . horizontal [ 0 ] . pred_interp_filter = SWITCHABLE ;td -> pc_tree [ i ] . horizontal [ 1 ] . pred_interp_filter = SWITCHABLE ;}}vp9_zero ( x -> pred_mv ) ;td -> pc_root -> index = 0 ;if ( seg -> enabled ) {const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ;int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ;seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ;}x -> source_variance = UINT_MAX ;if ( sf -> partition_search_type == SEARCH_PARTITION && sf -> use_lastframe_partitioning ) || sf -> partition_search_type == FIXED_PARTITION || seg_skip ) {const BLOCK_SIZE bsize = seg_skip ? BLOCK_64X64 : sf -> always_this_block_size ;set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ;set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ;rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ;}else if ( cpi -> partition_search_skippable_frame ) {BLOCK_SIZE bsize ;set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ;bsize = get_rd_var_based_fixed_partition ( cpi , x , mi_row , mi_col ) ;set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ;rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ;}else if ( sf -> partition_search_type == VAR_BASED_PARTITION && cm -> frame_type != KEY_FRAME ) {choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ;rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ;}else {if ( sf -> auto_min_max_partition_size ) {set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ;rd_auto_partition_range ( cpi , tile_info , xd , mi_row , mi_col , & x -> min_partition_size , & x -> max_partition_size ) ;}rd_pick_partition ( cpi , td , tile_data , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rdc , INT64_MAX , td -> pc_root ) ;}",1244
50,"buggy line: int hexdump ;u_int offset ;cwe id:CWE-125context: void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ;  int hexdump ;  u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( lmp_obj_values , ""Unknown"" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , ""Unknown"" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? """" : ""non-"" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) )  hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s"" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)"" : """" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_sp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }","int hexdump , ret ;u_int offset ;",1245
51,"buggy line: return ;}if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ;return ;}tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ;ND_PRINT ( ( ndo , ""\\\if ( tlen < sizeof ( const struct lmp_common_header ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ;return ;}if ( tlen > len ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ;tlen = len ;}tptr += sizeof ( const struct lmp_common_header ) ;tlen -= sizeof ( const struct lmp_common_header ) ;while ( tlen > 0 ) {ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ;lmp_obj_header = ( const struct lmp_object_header * ) tptr ;lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ;lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ;ND_PRINT ( ( ndo , ""\\\if ( lmp_obj_len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ;return ;}if ( ( lmp_obj_len % 4 ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ;return ;}obj_tptr = tptr + sizeof ( struct lmp_object_header ) ;obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ;ND_TCHECK2 ( * tptr , lmp_obj_len ) ;hexdump = FALSE ;switch ( lmp_obj_header -> class_num ) {case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) {case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) {case LMP_CTYPE_1 : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_2 : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) {case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) {case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) {case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ;cwe id:CWE-125context: void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ;  int hexdump ;  u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( lmp_obj_values , ""Unknown"" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , ""Unknown"" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? """" : ""non-"" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) )  hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s"" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)"" : """" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_sp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }","ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ;if ( ret == - 1 ) goto trunc ;if ( ret == TRUE ) hexdump = TRUE ;",1245
52,"buggy line: if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) )  hexdump = TRUE ;cwe id:CWE-125context: void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ;  int hexdump ;  u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( lmp_obj_values , ""Unknown"" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , ""Unknown"" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? """" : ""non-"" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) )  hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s"" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)"" : """" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_sp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }","if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) hexdump = TRUE ;",1245
53,"buggy line: if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ;cwe id:CWE-125context: void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ;  int hexdump ;  u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( lmp_obj_values , ""Unknown"" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , ""Unknown"" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? """" : ""non-"" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) )  hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ;  if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s"" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)"" : """" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_sp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }","if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ;",1245
54,"buggy line: static void inc_mvs ( const MB_MODE_INFO * mbmi , const int_mv mvs [ 2 ] ,  nmv_context_counts * counts ) {const MV * ref = & mbmi -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ;const MV diff = {cwe id:CWE-119context:  static void inc_mvs ( const MB_MODE_INFO * mbmi , const int_mv mvs [ 2 ] ,  nmv_context_counts * counts ) { int i ; for ( i = 0 ; i < 1 + has_second_ref ( mbmi ) ; ++ i ) {  const MV * ref = & mbmi -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ;  const MV diff = { mvs [ i ] . as_mv . row - ref -> row , mvs [ i ] . as_mv . col - ref -> col } ; vp9_inc_mv ( & diff , counts ) ; } }","static void inc_mvs ( const MB_MODE_INFO * mbmi , const MB_MODE_INFO_EXT * mbmi_ext , const int_mv mvs [ 2 ] , nmv_context_counts * counts ) {const MV * ref = & mbmi_ext -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ;const MV diff = {",1246
55,"buggy line: printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ;if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ;cwe id:CWE-119context: int main ( int argc , char * * argv ) { FILE * infile = NULL ; vpx_codec_ctx_t codec = { 0 } ; vpx_codec_enc_cfg_t cfg = { 0 } ; int frame_count = 0 ; vpx_image_t raw ; vpx_codec_err_t res ; VpxVideoInfo info = { 0 } ; VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; int update_frame_num = 0 ; const int fps = 30 ; const int bitrate = 200 ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; encoder = get_vpx_encoder_by_name ( ""vp8"" ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ; update_frame_num = atoi ( argv [ 5 ] ) ; if ( ! update_frame_num ) die ( ""Couldn\'t<S2SV_blank>parse<S2SV_blank>frame<S2SV_blank>number<S2SV_blank>\'%s\'\\n"" , argv [ 5 ] ) ; info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( argv [ 1 ] , NULL , 0 ) ; info . frame_height = strtol ( argv [ 2 ] , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image."" ) ; }  printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ;   res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ;  if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; writer = vpx_video_writer_open ( argv [ 4 ] , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 4 ] ) ; if ( ! ( infile = fopen ( argv [ 3 ] , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 3 ] ) ;  if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) )  die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; while ( vpx_img_read ( & raw , infile ) ) { if ( frame_count + 1 == update_frame_num ) { vpx_ref_frame_t ref ; ref . frame_type = VP8_LAST_FRAME ; ref . img = raw ; if ( vpx_codec_control ( & codec , VP8_SET_REFERENCE , & ref ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>reference<S2SV_blank>frame"" ) ; } encode_frame ( & codec , & raw , frame_count ++ , writer ) ; }  encode_frame ( & codec , NULL , - 1 , writer ) ;  printf ( ""\\n"" ) ; fclose ( infile ) ; printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }","printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ;if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ;",1247
56,"buggy line: if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) )  die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;cwe id:CWE-119context: int main ( int argc , char * * argv ) { FILE * infile = NULL ; vpx_codec_ctx_t codec = { 0 } ; vpx_codec_enc_cfg_t cfg = { 0 } ; int frame_count = 0 ; vpx_image_t raw ; vpx_codec_err_t res ; VpxVideoInfo info = { 0 } ; VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; int update_frame_num = 0 ; const int fps = 30 ; const int bitrate = 200 ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; encoder = get_vpx_encoder_by_name ( ""vp8"" ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ; update_frame_num = atoi ( argv [ 5 ] ) ; if ( ! update_frame_num ) die ( ""Couldn\'t<S2SV_blank>parse<S2SV_blank>frame<S2SV_blank>number<S2SV_blank>\'%s\'\\n"" , argv [ 5 ] ) ; info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( argv [ 1 ] , NULL , 0 ) ; info . frame_height = strtol ( argv [ 2 ] , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image."" ) ; }  printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ;   res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ;  if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; writer = vpx_video_writer_open ( argv [ 4 ] , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 4 ] ) ; if ( ! ( infile = fopen ( argv [ 3 ] , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 3 ] ) ;  if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) )  die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; while ( vpx_img_read ( & raw , infile ) ) { if ( frame_count + 1 == update_frame_num ) { vpx_ref_frame_t ref ; ref . frame_type = VP8_LAST_FRAME ; ref . img = raw ; if ( vpx_codec_control ( & codec , VP8_SET_REFERENCE , & ref ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>reference<S2SV_blank>frame"" ) ; } encode_frame ( & codec , & raw , frame_count ++ , writer ) ; }  encode_frame ( & codec , NULL , - 1 , writer ) ;  printf ( ""\\n"" ) ; fclose ( infile ) ; printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }","if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , & cfg , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;",1247
57,"buggy line: encode_frame ( & codec , & raw , frame_count ++ , writer ) ;encode_frame ( & codec , NULL , - 1 , writer ) ;printf ( ""\\\cwe id:CWE-119context: int main ( int argc , char * * argv ) { FILE * infile = NULL ; vpx_codec_ctx_t codec = { 0 } ; vpx_codec_enc_cfg_t cfg = { 0 } ; int frame_count = 0 ; vpx_image_t raw ; vpx_codec_err_t res ; VpxVideoInfo info = { 0 } ; VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; int update_frame_num = 0 ; const int fps = 30 ; const int bitrate = 200 ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; encoder = get_vpx_encoder_by_name ( ""vp8"" ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ; update_frame_num = atoi ( argv [ 5 ] ) ; if ( ! update_frame_num ) die ( ""Couldn\'t<S2SV_blank>parse<S2SV_blank>frame<S2SV_blank>number<S2SV_blank>\'%s\'\\n"" , argv [ 5 ] ) ; info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( argv [ 1 ] , NULL , 0 ) ; info . frame_height = strtol ( argv [ 2 ] , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image."" ) ; }  printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ;   res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ;  if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; writer = vpx_video_writer_open ( argv [ 4 ] , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 4 ] ) ; if ( ! ( infile = fopen ( argv [ 3 ] , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 3 ] ) ;  if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) )  die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; while ( vpx_img_read ( & raw , infile ) ) { if ( frame_count + 1 == update_frame_num ) { vpx_ref_frame_t ref ; ref . frame_type = VP8_LAST_FRAME ; ref . img = raw ; if ( vpx_codec_control ( & codec , VP8_SET_REFERENCE , & ref ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>reference<S2SV_blank>frame"" ) ; } encode_frame ( & codec , & raw , frame_count ++ , writer ) ; }  encode_frame ( & codec , NULL , - 1 , writer ) ;  printf ( ""\\n"" ) ; fclose ( infile ) ; printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }","while ( encode_frame ( & codec , & raw , frame_count ++ , writer ) ) {printf ( ""\\\",1247
58,"buggy line: if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) {kfree_skb ( skb_out ) ;cwe id:CWE-399context: static struct sk_buff * batadv_frag_merge_packets ( struct hlist_head * chain , struct sk_buff * skb ) { struct batadv_frag_packet * packet ; struct batadv_frag_list_entry * entry ; struct sk_buff * skb_out = NULL ; int size , hdr_size = sizeof ( struct batadv_frag_packet ) ; packet = ( struct batadv_frag_packet * ) skb -> data ; size = ntohs ( packet -> total_size ) ; if ( size > batadv_frag_size_limit ( ) ) goto free ; entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) ; hlist_del ( & entry -> list ) ; skb_out = entry -> skb ; kfree ( entry ) ;  if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) {  kfree_skb ( skb_out ) ; skb_out = NULL ; goto free ; } skb_pull_rcsum ( skb_out , hdr_size ) ; memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ) ; skb_set_mac_header ( skb_out , - ETH_HLEN ) ; skb_reset_network_header ( skb_out ) ; skb_reset_transport_header ( skb_out ) ; hlist_for_each_entry ( entry , chain , list ) { size = entry -> skb -> len - hdr_size ; memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , size ) ; } free : batadv_frag_clear_chain ( chain ) ; return skb_out ; }","if ( pskb_expand_head ( skb_out , 0 , size - skb_out -> len , GFP_ATOMIC ) < 0 ) {kfree_skb ( skb_out ) ;",1248
59,"buggy line: spin_lock_init ( & sta -> lock ) ;INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ;cwe id:CWE-362context: struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return NULL ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * sizeof ( struct ieee80211_tx_latency_stat ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ;  spin_lock_init ( & sta -> lock ) ;  INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ; # ifdef CONFIG_MAC80211_MESH if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! sdata -> u . mesh . user_mpm ) init_timer ( & sta -> plink_timer ) ; sta -> nonpeer_pm = NL80211_MESH_POWER_ACTIVE ; # endif memcpy ( sta -> sta . addr , addr , ETH_ALEN ) ; sta -> local = local ; sta -> sdata = sdata ; sta -> last_rx = jiffies ; sta -> sta_state = IEEE80211_STA_NONE ; do_posix_clock_monotonic_gettime ( & uptime ) ; sta -> last_connected = uptime . tv_sec ; ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; for ( i = 0 ; i < ARRAY_SIZE ( sta -> chain_signal_avg ) ; i ++ ) ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; if ( sta_prepare_rate_control ( local , sta , gfp ) ) goto free ; for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> timer_to_tid [ i ] = i ; } for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; } for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( USHRT_MAX ) ; sta -> sta . smps_mode = IEEE80211_SMPS_OFF ; if ( sdata -> vif . type == NL80211_IFTYPE_AP || sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) { struct ieee80211_supported_band * sband = local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; u8 smps = ( sband -> ht_cap . cap & IEEE80211_HT_CAP_SM_PS ) >> IEEE80211_HT_CAP_SM_PS_SHIFT ; switch ( smps ) { case WLAN_HT_SMPS_CONTROL_DISABLED : sta -> known_smps_mode = IEEE80211_SMPS_OFF ; break ; case WLAN_HT_SMPS_CONTROL_STATIC : sta -> known_smps_mode = IEEE80211_SMPS_STATIC ; break ; case WLAN_HT_SMPS_CONTROL_DYNAMIC : sta -> known_smps_mode = IEEE80211_SMPS_DYNAMIC ; break ; default : WARN_ON ( 1 ) ; } } sta_dbg ( sdata , ""Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n"" , sta -> sta . addr ) ; return sta ; free : if ( sta -> tx_lat ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) kfree ( sta -> tx_lat [ i ] . bins ) ; kfree ( sta -> tx_lat ) ; } kfree ( sta ) ; return NULL ; }","spin_lock_init ( & sta -> lock ) ;spin_lock_init ( & sta -> ps_lock ) ;INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ;",1249
60,"buggy line: if ( ftrace_event_is_function ( tp_event ) &&  perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) )  return - EPERM ;cwe id:CWE-264context: static int perf_trace_event_perm ( struct ftrace_event_call * tp_event , struct perf_event * p_event ) { if ( ftrace_event_is_function ( tp_event ) &&  perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) )  return - EPERM ; if ( ! ( p_event -> attr . sample_type & PERF_SAMPLE_RAW ) ) return 0 ; if ( p_event -> attach_state == PERF_ATTACH_TASK ) { if ( tp_event -> flags & TRACE_EVENT_FL_CAP_ANY ) return 0 ; } if ( perf_paranoid_tracepoint_raw ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; return 0 ; }",if ( ftrace_event_is_function ( tp_event ) && perf_paranoid_tracepoint_raw ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ;,1250
61,"buggy line: unregister_pernet_subsys ( & sctp_net_ops ) ;sctp_v6_protosw_exit ( ) ;sctp_v4_protosw_exit ( ) ;sctp_v6_pf_exit ( ) ;cwe id:CWE-119context: static __exit void sctp_exit ( void ) { sctp_v6_del_protocol ( ) ; sctp_v4_del_protocol ( ) ;  unregister_pernet_subsys ( & sctp_net_ops ) ;  sctp_v6_protosw_exit ( ) ;  sctp_v4_protosw_exit ( ) ;  sctp_v6_pf_exit ( ) ; sctp_v4_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; kfree ( sctp_ep_hashtable ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; percpu_counter_destroy ( & sctp_sockets_allocated ) ; rcu_barrier ( ) ; kmem_cache_destroy ( sctp_chunk_cachep ) ; kmem_cache_destroy ( sctp_bucket_cachep ) ; }",unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ;sctp_v6_protosw_exit ( ) ;sctp_v4_protosw_exit ( ) ;unregister_pernet_subsys ( & sctp_defaults_ops ) ;sctp_v6_pf_exit ( ) ;,1251
62,"buggy line: control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ;goto skip_normal_probe ;cwe id:CWE-000context: static int acm_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_country_functional_desc * cfd = NULL ; unsigned char * buffer = intf -> altsetting -> extra ; int buflen = intf -> altsetting -> extralen ; struct usb_interface * control_interface ; struct usb_interface * data_interface ; struct usb_endpoint_descriptor * epctrl = NULL ; struct usb_endpoint_descriptor * epread = NULL ; struct usb_endpoint_descriptor * epwrite = NULL ; struct usb_device * usb_dev = interface_to_usbdev ( intf ) ; struct acm * acm ; int minor ; int ctrlsize , readsize ; u8 * buf ; u8 ac_management_function = 0 ; u8 call_management_function = 0 ; int call_interface_num = - 1 ; int data_interface_num = - 1 ; unsigned long quirks ; int num_rx_buf ; int i ; unsigned int elength = 0 ; int combined_interfaces = 0 ; struct device * tty_dev ; int rv = - ENOMEM ; quirks = ( unsigned long ) id -> driver_info ; if ( quirks == IGNORE_DEVICE ) return - ENODEV ; num_rx_buf = ( quirks == SINGLE_RX_URB ) ? 1 : ACM_NR ; if ( quirks == NO_UNION_NORMAL ) { data_interface = usb_ifnum_to_if ( usb_dev , 1 ) ;  control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ;  goto skip_normal_probe ; } if ( ! buffer ) { dev_err ( & intf -> dev , ""Weird<S2SV_blank>descriptor<S2SV_blank>references\\n"" ) ; return - EINVAL ; } if ( ! buflen ) { if ( intf -> cur_altsetting -> endpoint && intf -> cur_altsetting -> endpoint -> extralen && intf -> cur_altsetting -> endpoint -> extra ) { dev_dbg ( & intf -> dev , ""Seeking<S2SV_blank>extra<S2SV_blank>descriptors<S2SV_blank>on<S2SV_blank>endpoint\\n"" ) ; buflen = intf -> cur_altsetting -> endpoint -> extralen ; buffer = intf -> cur_altsetting -> endpoint -> extra ; } else { dev_err ( & intf -> dev , ""Zero<S2SV_blank>length<S2SV_blank>descriptor<S2SV_blank>references\\n"" ) ; return - EINVAL ; } } while ( buflen > 0 ) { elength = buffer [ 0 ] ; if ( ! elength ) { dev_err ( & intf -> dev , ""skipping<S2SV_blank>garbage<S2SV_blank>byte\\n"" ) ; elength = 1 ; goto next_desc ; } if ( buffer [ 1 ] != USB_DT_CS_INTERFACE ) { dev_err ( & intf -> dev , ""skipping<S2SV_blank>garbage\\n"" ) ; goto next_desc ; } switch ( buffer [ 2 ] ) { case USB_CDC_UNION_TYPE : if ( elength < sizeof ( struct usb_cdc_union_desc ) ) goto next_desc ; if ( union_header ) { dev_err ( & intf -> dev , ""More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>"" ""union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\n"" ) ; goto next_desc ; } union_header = ( struct usb_cdc_union_desc * ) buffer ; break ; case USB_CDC_COUNTRY_TYPE : if ( elength < sizeof ( struct usb_cdc_country_functional_desc ) ) goto next_desc ; cfd = ( struct usb_cdc_country_functional_desc * ) buffer ; break ; case USB_CDC_HEADER_TYPE : break ; case USB_CDC_ACM_TYPE : if ( elength < 4 ) goto next_desc ; ac_management_function = buffer [ 3 ] ; break ; case USB_CDC_CALL_MANAGEMENT_TYPE : if ( elength < 5 ) goto next_desc ; call_management_function = buffer [ 3 ] ; call_interface_num = buffer [ 4 ] ; break ; default : dev_dbg ( & intf -> dev , ""Ignoring<S2SV_blank>descriptor:<S2SV_blank>"" ""type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\n"" , buffer [ 2 ] , elength ) ; break ; } next_desc : buflen -= elength ; buffer += elength ; } if ( ! union_header ) { if ( call_interface_num > 0 ) { dev_dbg ( & intf -> dev , ""No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>using<S2SV_blank>call<S2SV_blank>management<S2SV_blank>descriptor\\n"" ) ; if ( quirks & NO_DATA_INTERFACE ) data_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; else data_interface = usb_ifnum_to_if ( usb_dev , ( data_interface_num = call_interface_num ) ) ; control_interface = intf ; } else { if ( intf -> cur_altsetting -> desc . bNumEndpoints != 3 ) { dev_dbg ( & intf -> dev , ""No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>giving<S2SV_blank>up\\n"" ) ; return - ENODEV ; } else { dev_warn ( & intf -> dev , ""No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>testing<S2SV_blank>for<S2SV_blank>castrated<S2SV_blank>device\\n"" ) ; combined_interfaces = 1 ; control_interface = data_interface = intf ; goto look_for_collapsed_interface ; } } } else { control_interface = usb_ifnum_to_if ( usb_dev , union_header -> bMasterInterface0 ) ; data_interface = usb_ifnum_to_if ( usb_dev , ( data_interface_num = union_header -> bSlaveInterface0 ) ) ; } if ( ! control_interface || ! data_interface ) { dev_dbg ( & intf -> dev , ""no<S2SV_blank>interfaces\\n"" ) ; return - ENODEV ; } if ( data_interface_num != call_interface_num ) dev_dbg ( & intf -> dev , ""Separate<S2SV_blank>call<S2SV_blank>control<S2SV_blank>interface.<S2SV_blank>That<S2SV_blank>is<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>supported.\\n"" ) ; if ( control_interface == data_interface ) { dev_warn ( & intf -> dev , ""Control<S2SV_blank>and<S2SV_blank>data<S2SV_blank>interfaces<S2SV_blank>are<S2SV_blank>not<S2SV_blank>separated!\\n"" ) ; combined_interfaces = 1 ; quirks |= NO_CAP_LINE ; if ( data_interface -> cur_altsetting -> desc . bNumEndpoints != 3 ) { dev_err ( & intf -> dev , ""This<S2SV_blank>needs<S2SV_blank>exactly<S2SV_blank>3<S2SV_blank>endpoints\\n"" ) ; return - EINVAL ; } look_for_collapsed_interface : for ( i = 0 ; i < 3 ; i ++ ) { struct usb_endpoint_descriptor * ep ; ep = & data_interface -> cur_altsetting -> endpoint [ i ] . desc ; if ( usb_endpoint_is_int_in ( ep ) ) epctrl = ep ; else if ( usb_endpoint_is_bulk_out ( ep ) ) epwrite = ep ; else if ( usb_endpoint_is_bulk_in ( ep ) ) epread = ep ; else return - EINVAL ; } if ( ! epctrl || ! epread || ! epwrite ) return - ENODEV ; else goto made_compressed_probe ; } skip_normal_probe : if ( data_interface -> cur_altsetting -> desc . bInterfaceClass != CDC_DATA_INTERFACE_TYPE ) { if ( control_interface -> cur_altsetting -> desc . bInterfaceClass == CDC_DATA_INTERFACE_TYPE ) { dev_dbg ( & intf -> dev , ""Your<S2SV_blank>device<S2SV_blank>has<S2SV_blank>switched<S2SV_blank>interfaces.\\n"" ) ; swap ( control_interface , data_interface ) ; } else { return - EINVAL ; } } if ( ! combined_interfaces && intf != control_interface ) return - ENODEV ; if ( ! combined_interfaces && usb_interface_claimed ( data_interface ) ) { dev_dbg ( & intf -> dev , ""The<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>isn\'t<S2SV_blank>available\\n"" ) ; return - EBUSY ; } if ( data_interface -> cur_altsetting -> desc . bNumEndpoints < 2 || control_interface -> cur_altsetting -> desc . bNumEndpoints == 0 ) return - EINVAL ; epctrl = & control_interface -> cur_altsetting -> endpoint [ 0 ] . desc ; epread = & data_interface -> cur_altsetting -> endpoint [ 0 ] . desc ; epwrite = & data_interface -> cur_altsetting -> endpoint [ 1 ] . desc ; if ( ! usb_endpoint_dir_in ( epread ) ) { dev_dbg ( & intf -> dev , ""The<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>has<S2SV_blank>switched<S2SV_blank>endpoints\\n"" ) ; swap ( epread , epwrite ) ; } made_compressed_probe : dev_dbg ( & intf -> dev , ""interfaces<S2SV_blank>are<S2SV_blank>valid\\n"" ) ; acm = kzalloc ( sizeof ( struct acm ) , GFP_KERNEL ) ; if ( acm == NULL ) goto alloc_fail ; minor = acm_alloc_minor ( acm ) ; if ( minor < 0 ) { dev_err ( & intf -> dev , ""no<S2SV_blank>more<S2SV_blank>free<S2SV_blank>acm<S2SV_blank>devices\\n"" ) ; kfree ( acm ) ; return - ENODEV ; } ctrlsize = usb_endpoint_maxp ( epctrl ) ; readsize = usb_endpoint_maxp ( epread ) * ( quirks == SINGLE_RX_URB ? 1 : 2 ) ; acm -> combined_interfaces = combined_interfaces ; acm -> writesize = usb_endpoint_maxp ( epwrite ) * 20 ; acm -> control = control_interface ; acm -> data = data_interface ; acm -> minor = minor ; acm -> dev = usb_dev ; acm -> ctrl_caps = ac_management_function ; if ( quirks & NO_CAP_LINE ) acm -> ctrl_caps &= ~ USB_CDC_CAP_LINE ; acm -> ctrlsize = ctrlsize ; acm -> readsize = readsize ; acm -> rx_buflimit = num_rx_buf ; INIT_WORK ( & acm -> work , acm_softint ) ; init_waitqueue_head ( & acm -> wioctl ) ; spin_lock_init ( & acm -> write_lock ) ; spin_lock_init ( & acm -> read_lock ) ; mutex_init ( & acm -> mutex ) ; acm -> rx_endpoint = usb_rcvbulkpipe ( usb_dev , epread -> bEndpointAddress ) ; acm -> is_int_ep = usb_endpoint_xfer_int ( epread ) ; if ( acm -> is_int_ep ) acm -> bInterval = epread -> bInterval ; tty_port_init ( & acm -> port ) ; acm -> port . ops = & acm_port_ops ; init_usb_anchor ( & acm -> delayed ) ; acm -> quirks = quirks ; buf = usb_alloc_coherent ( usb_dev , ctrlsize , GFP_KERNEL , & acm -> ctrl_dma ) ; if ( ! buf ) goto alloc_fail2 ; acm -> ctrl_buffer = buf ; if ( acm_write_buffers_alloc ( acm ) < 0 ) goto alloc_fail4 ; acm -> ctrlurb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! acm -> ctrlurb ) goto alloc_fail5 ; for ( i = 0 ; i < num_rx_buf ; i ++ ) { struct acm_rb * rb = & ( acm -> read_buffers [ i ] ) ; struct urb * urb ; rb -> base = usb_alloc_coherent ( acm -> dev , readsize , GFP_KERNEL , & rb -> dma ) ; if ( ! rb -> base ) goto alloc_fail6 ; rb -> index = i ; rb -> instance = acm ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) goto alloc_fail6 ; urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; urb -> transfer_dma = rb -> dma ; if ( acm -> is_int_ep ) { usb_fill_int_urb ( urb , acm -> dev , acm -> rx_endpoint , rb -> base , acm -> readsize , acm_read_bulk_callback , rb , acm -> bInterval ) ; } else { usb_fill_bulk_urb ( urb , acm -> dev , acm -> rx_endpoint , rb -> base , acm -> readsize , acm_read_bulk_callback , rb ) ; } acm -> read_urbs [ i ] = urb ; __set_bit ( i , & acm -> read_urbs_free ) ; } for ( i = 0 ; i < ACM_NW ; i ++ ) { struct acm_wb * snd = & ( acm -> wb [ i ] ) ; snd -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( snd -> urb == NULL ) goto alloc_fail7 ; if ( usb_endpoint_xfer_int ( epwrite ) ) usb_fill_int_urb ( snd -> urb , usb_dev , usb_sndintpipe ( usb_dev , epwrite -> bEndpointAddress ) , NULL , acm -> writesize , acm_write_bulk , snd , epwrite -> bInterval ) ; else usb_fill_bulk_urb ( snd -> urb , usb_dev , usb_sndbulkpipe ( usb_dev , epwrite -> bEndpointAddress ) , NULL , acm -> writesize , acm_write_bulk , snd ) ; snd -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; if ( quirks & SEND_ZERO_PACKET ) snd -> urb -> transfer_flags |= URB_ZERO_PACKET ; snd -> instance = acm ; } usb_set_intfdata ( intf , acm ) ; i = device_create_file ( & intf -> dev , & dev_attr_bmCapabilities ) ; if ( i < 0 ) goto alloc_fail7 ; if ( cfd ) { acm -> country_codes = kmalloc ( cfd -> bLength - 4 , GFP_KERNEL ) ; if ( ! acm -> country_codes ) goto skip_countries ; acm -> country_code_size = cfd -> bLength - 4 ; memcpy ( acm -> country_codes , ( u8 * ) & cfd -> wCountyCode0 , cfd -> bLength - 4 ) ; acm -> country_rel_date = cfd -> iCountryCodeRelDate ; i = device_create_file ( & intf -> dev , & dev_attr_wCountryCodes ) ; if ( i < 0 ) { kfree ( acm -> country_codes ) ; acm -> country_codes = NULL ; acm -> country_code_size = 0 ; goto skip_countries ; } i = device_create_file ( & intf -> dev , & dev_attr_iCountryCodeRelDate ) ; if ( i < 0 ) { device_remove_file ( & intf -> dev , & dev_attr_wCountryCodes ) ; kfree ( acm -> country_codes ) ; acm -> country_codes = NULL ; acm -> country_code_size = 0 ; goto skip_countries ; } } skip_countries : usb_fill_int_urb ( acm -> ctrlurb , usb_dev , usb_rcvintpipe ( usb_dev , epctrl -> bEndpointAddress ) , acm -> ctrl_buffer , ctrlsize , acm_ctrl_irq , acm , epctrl -> bInterval ? epctrl -> bInterval : 16 ) ; acm -> ctrlurb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; acm -> ctrlurb -> transfer_dma = acm -> ctrl_dma ; dev_info ( & intf -> dev , ""ttyACM%d:<S2SV_blank>USB<S2SV_blank>ACM<S2SV_blank>device\\n"" , minor ) ; acm -> line . dwDTERate = cpu_to_le32 ( 9600 ) ; acm -> line . bDataBits = 8 ; acm_set_line ( acm , & acm -> line ) ; usb_driver_claim_interface ( & acm_driver , data_interface , acm ) ; usb_set_intfdata ( data_interface , acm ) ; usb_get_intf ( control_interface ) ; tty_dev = tty_port_register_device ( & acm -> port , acm_tty_driver , minor , & control_interface -> dev ) ; if ( IS_ERR ( tty_dev ) ) { rv = PTR_ERR ( tty_dev ) ; goto alloc_fail8 ; } if ( quirks & CLEAR_HALT_CONDITIONS ) { usb_clear_halt ( usb_dev , usb_rcvbulkpipe ( usb_dev , epread -> bEndpointAddress ) ) ; usb_clear_halt ( usb_dev , usb_sndbulkpipe ( usb_dev , epwrite -> bEndpointAddress ) ) ; } return 0 ; alloc_fail8 : if ( acm -> country_codes ) { device_remove_file ( & acm -> control -> dev , & dev_attr_wCountryCodes ) ; device_remove_file ( & acm -> control -> dev , & dev_attr_iCountryCodeRelDate ) ; kfree ( acm -> country_codes ) ; } device_remove_file ( & acm -> control -> dev , & dev_attr_bmCapabilities ) ; alloc_fail7 : usb_set_intfdata ( intf , NULL ) ; for ( i = 0 ; i < ACM_NW ; i ++ ) usb_free_urb ( acm -> wb [ i ] . urb ) ; alloc_fail6 : for ( i = 0 ; i < num_rx_buf ; i ++ ) usb_free_urb ( acm -> read_urbs [ i ] ) ; acm_read_buffers_free ( acm ) ; usb_free_urb ( acm -> ctrlurb ) ; alloc_fail5 : acm_write_buffers_free ( acm ) ; alloc_fail4 : usb_free_coherent ( usb_dev , ctrlsize , acm -> ctrl_buffer , acm -> ctrl_dma ) ; alloc_fail2 : acm_release_minor ( acm ) ; kfree ( acm ) ; alloc_fail : return rv ; }","control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ;if ( ! data_interface || ! control_interface ) return - ENODEV ;goto skip_normal_probe ;",1252
63,"buggy line: perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;cwe id:CWE-399context: static int misaligned_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_sign_extend ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; }  perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;  destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } switch ( width_shift ) { case 1 : if ( do_sign_extend ) { regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s16 * ) & buffer ; } else { regs -> regs [ destreg ] = ( __u64 ) * ( __u16 * ) & buffer ; } break ; case 2 : regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s32 * ) & buffer ; break ; case 3 : regs -> regs [ destreg ] = buffer ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } else { __u64 lo , hi ; switch ( width_shift ) { case 1 : misaligned_kernel_word_load ( address , do_sign_extend , & regs -> regs [ destreg ] ) ; break ; case 2 : asm ( ""ldlo.l<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.l<S2SV_blank>%1,<S2SV_blank>3,<S2SV_blank>%0"" : ""=r"" ( hi ) : ""r"" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; case 3 : asm ( ""ldlo.q<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.q<S2SV_blank>%1,<S2SV_blank>7,<S2SV_blank>%0"" : ""=r"" ( hi ) : ""r"" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;",1253
64,"buggy line: netsnmp_init_mib_internals ( ) ;netsnmp_fixup_mib_directory ( ) ;env_var = strdup ( netsnmp_get_mib_directory ( ) ) ;if ( ! env_var ) return ;netsnmp_mibindex_load ( ) ;DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBDIRS:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\\\'%s\\\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>dirs<S2SV_blank>...\\\cwe id:CWE-59context: void netsnmp_init_mib ( void ) { const char * prefix ; char * env_var , * entry ; PrefixListPtr pp = & mib_prefixes [ 0 ] ; char * st = NULL ; if ( Mib ) return ; netsnmp_init_mib_internals ( ) ; netsnmp_fixup_mib_directory ( ) ; env_var = strdup ( netsnmp_get_mib_directory ( ) ) ; if ( ! env_var ) return ;  netsnmp_mibindex_load ( ) ;  DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBDIRS:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>dirs<S2SV_blank>...\\n"" , env_var ) ) ; entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { add_mibdir ( entry ) ; entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } SNMP_FREE ( env_var ) ; env_var = netsnmp_getenv ( ""MIBFILES"" ) ; if ( env_var != NULL ) { if ( * env_var == '+' ) entry = strtok_r ( env_var + 1 , ENV_SEPARATOR , & st ) ; else entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) {  add_mibfile ( entry , NULL , NULL ) ;  entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } } netsnmp_init_mib_internals ( ) ; env_var = netsnmp_getenv ( ""MIBS"" ) ; if ( env_var == NULL ) { if ( confmibs != NULL ) env_var = strdup ( confmibs ) ; else env_var = strdup ( NETSNMP_DEFAULT_MIBS ) ; } else { env_var = strdup ( env_var ) ; } if ( env_var && ( ( * env_var == '+' ) || ( * env_var == '-' ) ) ) { entry = ( char * ) malloc ( strlen ( NETSNMP_DEFAULT_MIBS ) + strlen ( env_var ) + 2 ) ; if ( ! entry ) { DEBUGMSGTL ( ( ""init_mib"" , ""env<S2SV_blank>mibs<S2SV_blank>malloc<S2SV_blank>failed"" ) ) ; SNMP_FREE ( env_var ) ; return ; } else { if ( * env_var == '+' ) sprintf ( entry , ""%s%c%s"" , NETSNMP_DEFAULT_MIBS , ENV_SEPARATOR_CHAR , env_var + 1 ) ; else sprintf ( entry , ""%s%c%s"" , env_var + 1 , ENV_SEPARATOR_CHAR , NETSNMP_DEFAULT_MIBS ) ; } SNMP_FREE ( env_var ) ; env_var = entry ; } DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBS:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>files<S2SV_blank>...\\n"" , env_var ) ) ; entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { if ( strcasecmp ( entry , DEBUG_ALWAYS_TOKEN ) == 0 ) { read_all_mibs ( ) ; } else if ( strstr ( entry , ""/"" ) != NULL ) { read_mib ( entry ) ; } else { netsnmp_read_module ( entry ) ; } entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } adopt_orphans ( ) ; SNMP_FREE ( env_var ) ; env_var = netsnmp_getenv ( ""MIBFILES"" ) ; if ( env_var != NULL ) { if ( ( * env_var == '+' ) || ( * env_var == '-' ) ) { # ifdef NETSNMP_DEFAULT_MIBFILES entry = ( char * ) malloc ( strlen ( NETSNMP_DEFAULT_MIBFILES ) + strlen ( env_var ) + 2 ) ; if ( ! entry ) { DEBUGMSGTL ( ( ""init_mib"" , ""env<S2SV_blank>mibfiles<S2SV_blank>malloc<S2SV_blank>failed"" ) ) ; } else { if ( * env_var ++ == '+' ) sprintf ( entry , ""%s%c%s"" , NETSNMP_DEFAULT_MIBFILES , ENV_SEPARATOR_CHAR , env_var ) ; else sprintf ( entry , ""%s%c%s"" , env_var , ENV_SEPARATOR_CHAR , NETSNMP_DEFAULT_MIBFILES ) ; } SNMP_FREE ( env_var ) ; env_var = entry ; # else env_var = strdup ( env_var + 1 ) ; # endif } else { env_var = strdup ( env_var ) ; } } else { # ifdef NETSNMP_DEFAULT_MIBFILES env_var = strdup ( NETSNMP_DEFAULT_MIBFILES ) ; # endif } if ( env_var != NULL ) { DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBFILES:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>files<S2SV_blank>...\\n"" , env_var ) ) ; entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { read_mib ( entry ) ; entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } SNMP_FREE ( env_var ) ; } prefix = netsnmp_getenv ( ""PREFIX"" ) ; if ( ! prefix ) prefix = Standard_Prefix ; Prefix = ( char * ) malloc ( strlen ( prefix ) + 2 ) ; if ( ! Prefix ) DEBUGMSGTL ( ( ""init_mib"" , ""Prefix<S2SV_blank>malloc<S2SV_blank>failed"" ) ) ; else strcpy ( Prefix , prefix ) ; DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>PREFIX:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>prefix<S2SV_blank>...\\n"" , Prefix ) ) ; if ( Prefix ) { env_var = & Prefix [ strlen ( Prefix ) - 1 ] ; if ( * env_var == '.' ) * env_var = '\\0' ; } pp -> str = Prefix ; while ( pp -> str ) { pp -> len = strlen ( pp -> str ) ; pp ++ ; } Mib = tree_head ; tree_top = ( struct tree * ) calloc ( 1 , sizeof ( struct tree ) ) ; if ( tree_top ) { tree_top -> label = strdup ( ""(top)"" ) ; tree_top -> child_list = tree_head ; } }","DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBDIRS:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\\\'%s\\\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>dirs<S2SV_blank>...\\\",1254
65,"buggy line: add_mibfile ( entry , NULL , NULL ) ;entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ;cwe id:CWE-59context: void netsnmp_init_mib ( void ) { const char * prefix ; char * env_var , * entry ; PrefixListPtr pp = & mib_prefixes [ 0 ] ; char * st = NULL ; if ( Mib ) return ; netsnmp_init_mib_internals ( ) ; netsnmp_fixup_mib_directory ( ) ; env_var = strdup ( netsnmp_get_mib_directory ( ) ) ; if ( ! env_var ) return ;  netsnmp_mibindex_load ( ) ;  DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBDIRS:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>dirs<S2SV_blank>...\\n"" , env_var ) ) ; entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { add_mibdir ( entry ) ; entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } SNMP_FREE ( env_var ) ; env_var = netsnmp_getenv ( ""MIBFILES"" ) ; if ( env_var != NULL ) { if ( * env_var == '+' ) entry = strtok_r ( env_var + 1 , ENV_SEPARATOR , & st ) ; else entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) {  add_mibfile ( entry , NULL , NULL ) ;  entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } } netsnmp_init_mib_internals ( ) ; env_var = netsnmp_getenv ( ""MIBS"" ) ; if ( env_var == NULL ) { if ( confmibs != NULL ) env_var = strdup ( confmibs ) ; else env_var = strdup ( NETSNMP_DEFAULT_MIBS ) ; } else { env_var = strdup ( env_var ) ; } if ( env_var && ( ( * env_var == '+' ) || ( * env_var == '-' ) ) ) { entry = ( char * ) malloc ( strlen ( NETSNMP_DEFAULT_MIBS ) + strlen ( env_var ) + 2 ) ; if ( ! entry ) { DEBUGMSGTL ( ( ""init_mib"" , ""env<S2SV_blank>mibs<S2SV_blank>malloc<S2SV_blank>failed"" ) ) ; SNMP_FREE ( env_var ) ; return ; } else { if ( * env_var == '+' ) sprintf ( entry , ""%s%c%s"" , NETSNMP_DEFAULT_MIBS , ENV_SEPARATOR_CHAR , env_var + 1 ) ; else sprintf ( entry , ""%s%c%s"" , env_var + 1 , ENV_SEPARATOR_CHAR , NETSNMP_DEFAULT_MIBS ) ; } SNMP_FREE ( env_var ) ; env_var = entry ; } DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBS:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>files<S2SV_blank>...\\n"" , env_var ) ) ; entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { if ( strcasecmp ( entry , DEBUG_ALWAYS_TOKEN ) == 0 ) { read_all_mibs ( ) ; } else if ( strstr ( entry , ""/"" ) != NULL ) { read_mib ( entry ) ; } else { netsnmp_read_module ( entry ) ; } entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } adopt_orphans ( ) ; SNMP_FREE ( env_var ) ; env_var = netsnmp_getenv ( ""MIBFILES"" ) ; if ( env_var != NULL ) { if ( ( * env_var == '+' ) || ( * env_var == '-' ) ) { # ifdef NETSNMP_DEFAULT_MIBFILES entry = ( char * ) malloc ( strlen ( NETSNMP_DEFAULT_MIBFILES ) + strlen ( env_var ) + 2 ) ; if ( ! entry ) { DEBUGMSGTL ( ( ""init_mib"" , ""env<S2SV_blank>mibfiles<S2SV_blank>malloc<S2SV_blank>failed"" ) ) ; } else { if ( * env_var ++ == '+' ) sprintf ( entry , ""%s%c%s"" , NETSNMP_DEFAULT_MIBFILES , ENV_SEPARATOR_CHAR , env_var ) ; else sprintf ( entry , ""%s%c%s"" , env_var , ENV_SEPARATOR_CHAR , NETSNMP_DEFAULT_MIBFILES ) ; } SNMP_FREE ( env_var ) ; env_var = entry ; # else env_var = strdup ( env_var + 1 ) ; # endif } else { env_var = strdup ( env_var ) ; } } else { # ifdef NETSNMP_DEFAULT_MIBFILES env_var = strdup ( NETSNMP_DEFAULT_MIBFILES ) ; # endif } if ( env_var != NULL ) { DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBFILES:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>files<S2SV_blank>...\\n"" , env_var ) ) ; entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { read_mib ( entry ) ; entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } SNMP_FREE ( env_var ) ; } prefix = netsnmp_getenv ( ""PREFIX"" ) ; if ( ! prefix ) prefix = Standard_Prefix ; Prefix = ( char * ) malloc ( strlen ( prefix ) + 2 ) ; if ( ! Prefix ) DEBUGMSGTL ( ( ""init_mib"" , ""Prefix<S2SV_blank>malloc<S2SV_blank>failed"" ) ) ; else strcpy ( Prefix , prefix ) ; DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>PREFIX:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>prefix<S2SV_blank>...\\n"" , Prefix ) ) ; if ( Prefix ) { env_var = & Prefix [ strlen ( Prefix ) - 1 ] ; if ( * env_var == '.' ) * env_var = '\\0' ; } pp -> str = Prefix ; while ( pp -> str ) { pp -> len = strlen ( pp -> str ) ; pp ++ ; } Mib = tree_head ; tree_top = ( struct tree * ) calloc ( 1 , sizeof ( struct tree ) ) ; if ( tree_top ) { tree_top -> label = strdup ( ""(top)"" ) ; tree_top -> child_list = tree_head ; } }","add_mibfile ( entry , NULL ) ;entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ;",1254
66,"buggy line: struct list_head tmplist ;newsk -> sk_sndbuf = oldsk -> sk_sndbuf ;if ( oldsp -> do_auto_asconf ) {memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ;inet_sk_copy_descendant ( newsk , oldsk ) ;cwe id:CWE-362context: static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; struct sctp_bind_hashbucket * head ;  struct list_head tmplist ;  newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ;  if ( oldsp -> do_auto_asconf ) {  memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ; inet_sk_copy_descendant ( newsk , oldsk ) ; memcpy ( & newsp -> auto_asconf_list , & tmplist , sizeof ( tmplist ) ) ; } else inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = NULL ; head = & sctp_port_hashtable [ sctp_phashfn ( sock_net ( oldsk ) , inet_sk ( oldsk ) -> inet_num ) ] ; local_bh_disable ( ) ; spin_lock ( & head -> lock ) ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> inet_num = inet_sk ( oldsk ) -> inet_num ; spin_unlock ( & head -> lock ) ; local_bh_enable ( ) ; sctp_bind_addr_dup ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , GFP_KERNEL ) ; sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } } skb_queue_head_init ( & newsp -> pd_lobby ) ; atomic_set ( & sctp_sk ( newsk ) -> pd_mode , assoc -> ulpq . pd_mode ) ; if ( atomic_read ( & sctp_sk ( oldsk ) -> pd_mode ) ) { struct sk_buff_head * queue ; if ( assoc -> ulpq . pd_mode ) { queue = & newsp -> pd_lobby ; } else queue = & newsk -> sk_receive_queue ; sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { __skb_unlink ( skb , & oldsp -> pd_lobby ) ; __skb_queue_tail ( queue , skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } } if ( assoc -> ulpq . pd_mode ) sctp_clear_pd ( oldsk , NULL ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) sctp_skb_set_owner_r_frag ( skb , newsk ) ; sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) sctp_skb_set_owner_r_frag ( skb , newsk ) ; newsp -> type = type ; lock_sock_nested ( newsk , SINGLE_DEPTH_NESTING ) ; sctp_assoc_migrate ( assoc , newsk ) ; if ( sctp_state ( assoc , CLOSED ) && sctp_style ( newsk , TCP ) ) newsk -> sk_shutdown |= RCV_SHUTDOWN ; newsk -> sk_state = SCTP_SS_ESTABLISHED ; release_sock ( newsk ) ; }","newsk -> sk_sndbuf = oldsk -> sk_sndbuf ;sctp_copy_descendant ( newsk , oldsk ) ;",1255
67,"buggy line: fd = open ( uinput_dev_path [ x ] , O_RDWR ) ;if ( fd < 0 ) continue ;memset ( & dev , 0 , sizeof ( dev ) ) ;if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) {BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>device<S2SV_blank>information"" , __FUNCTION__ ) ;ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ;ioctl ( fd , UI_SET_EVBIT , EV_REL ) ;ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ;for ( x = 0 ;x ++ )  ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ;if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) {BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>uinput<S2SV_blank>device"" , __FUNCTION__ ) ;cwe id:CWE-284context: int uinput_create ( char * name ) { struct uinput_dev dev ; int fd , x = 0 ; for ( x = 0 ; x < MAX_UINPUT_PATHS ; x ++ ) {  fd = open ( uinput_dev_path [ x ] , O_RDWR ) ;  if ( fd < 0 ) continue ; break ; } if ( x == MAX_UINPUT_PATHS ) { BTIF_TRACE_ERROR ( ""%s<S2SV_blank>ERROR:<S2SV_blank>uinput<S2SV_blank>device<S2SV_blank>open<S2SV_blank>failed"" , __FUNCTION__ ) ; return - 1 ; } memset ( & dev , 0 , sizeof ( dev ) ) ; if ( name ) strncpy ( dev . name , name , UINPUT_MAX_NAME_SIZE - 1 ) ; dev . id . bustype = BUS_BLUETOOTH ; dev . id . vendor = 0x0000 ; dev . id . product = 0x0000 ; dev . id . version = 0x0000 ;  if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) {  BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>device<S2SV_blank>information"" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; }  ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ;   ioctl ( fd , UI_SET_EVBIT , EV_REL ) ;   ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ;  for ( x = 0 ; key_map [ x ] . name != NULL ; x ++ )  ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ;   if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) {  BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>uinput<S2SV_blank>device"" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } return fd ; }","fd = TEMP_FAILURE_RETRY ( open ( uinput_dev_path [ x ] , O_RDWR ) ) ;if ( TEMP_FAILURE_RETRY ( fd < 0 ) continue ;memset ( & dev , 0 , sizeof ( dev ) ) ) ;if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) {BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>device<S2SV_blank>information"" , __FUNCTION__ ) ;TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ) ;TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_EVBIT , EV_REL ) ) ;TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ) ;for ( x = 0 ;x ++ ) TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ) ;if ( TEMP_FAILURE_RETRY ( ioctl ( fd , UI_DEV_CREATE , NULL ) ) < 0 ) {BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>uinput<S2SV_blank>device"" , __FUNCTION__ ) ;",1256
68,"buggy line: struct desc_struct * desc ;short sel ;desc = get_desc ( sel ) ;if ( ! desc )  return - EINVAL ;if ( ! ( desc -> type & BIT ( 3 ) ) )  return - EINVAL ;switch ( ( desc -> l << 1 ) | desc -> d ) {case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ;cwe id:CWE-362context: int insn_get_code_seg_params ( struct pt_regs * regs ) {  struct desc_struct * desc ;  short sel ; if ( v8086_mode ( regs ) ) return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; sel = get_segment_selector ( regs , INAT_SEG_REG_CS ) ; if ( sel < 0 ) return sel ;  desc = get_desc ( sel ) ;   if ( ! desc )  return - EINVAL ;  if ( ! ( desc -> type & BIT ( 3 ) ) )  return - EINVAL ;  switch ( ( desc -> l << 1 ) | desc -> d ) {  case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; case 1 : return INSN_CODE_SEG_PARAMS ( 4 , 4 ) ; case 2 : return INSN_CODE_SEG_PARAMS ( 4 , 8 ) ; case 3 : default : return - EINVAL ; } }","struct desc_struct desc ;short sel ;if ( ! desc ) return - EINVAL ;if ( ! ( desc . type & BIT ( 3 ) ) ) return - EINVAL ;switch ( ( desc . l << 1 ) | desc . d ) {case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ;",1257
69,buggy line: i ++ )  vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ;free ( ctx -> buf ) ;cwe id:CWE-119context: void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ )  vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ;  free ( ctx -> buf ) ; } free ( ctx ) ; } },i ++ ) vpx_free_frame_buffer ( & ctx -> buf [ i ] . img ) ;free ( ctx -> buf ) ;,1258
70,"buggy line: const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ;if ( mask & 1 ) {if ( mask_16x16 & 1 ) {vp9_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ;}vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;}vp9_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;}cwe id:CWE-119context: static void filter_selectively_vert ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= 1 ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) {  vp9_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ;  } else if ( mask_8x8 & 1 ) {  vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;  } else if ( mask_4x4 & 1 ) {  vp9_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;  } } if ( mask_4x4_int & 1 ) vp9_lpf_vertical_4 ( s + 4 , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; s += 8 ; lfl += 1 ; mask_16x16 >>= 1 ; mask_8x8 >>= 1 ; mask_4x4 >>= 1 ; mask_4x4_int >>= 1 ; } }","vpx_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ;}vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;}vpx_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;}",1259
71,"buggy line: atomic_dec ( & user -> inotify_devs ) ;out_free_uid : free_uid ( user ) ;cwe id:CWE-399context: SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { struct fsnotify_group * group ; struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; user = get_current_user ( ) ; if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } group = inotify_new_group ( user , inotify_max_queued_events ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( ""inotify"" , & inotify_fops , group , O_RDONLY | flags ) ; if ( ret >= 0 ) return ret ;  atomic_dec ( & user -> inotify_devs ) ;  out_free_uid : free_uid ( user ) ; return ret ; }",fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;out_free_uid : free_uid ( user ) ;,1260
72,"buggy line: static krb5_error_code  iakerb_alloc_context ( iakerb_ctx_id_t * pctx )  {cwe id:CWE-18context: static krb5_error_code  iakerb_alloc_context ( iakerb_ctx_id_t * pctx )  { iakerb_ctx_id_t ctx ; krb5_error_code code ; * pctx = NULL ; ctx = k5alloc ( sizeof ( * ctx ) , & code ) ; if ( ctx == NULL ) goto cleanup ; ctx -> defcred = GSS_C_NO_CREDENTIAL ; ctx -> magic = KG_IAKERB_CONTEXT ; ctx -> state = IAKERB_AS_REQ ; ctx -> count = 0 ;  code = krb5_gss_init_context ( & ctx -> k5c ) ;  if ( code != 0 ) goto cleanup ; * pctx = ctx ; cleanup : if ( code != 0 ) iakerb_release_context ( ctx ) ; return code ; }","static krb5_error_code iakerb_alloc_context ( iakerb_ctx_id_t * pctx , int initiate ) {",1261
73,"buggy line: code = krb5_gss_init_context ( & ctx -> k5c ) ;if ( code != 0 ) goto cleanup ;cwe id:CWE-18context: static krb5_error_code  iakerb_alloc_context ( iakerb_ctx_id_t * pctx )  { iakerb_ctx_id_t ctx ; krb5_error_code code ; * pctx = NULL ; ctx = k5alloc ( sizeof ( * ctx ) , & code ) ; if ( ctx == NULL ) goto cleanup ; ctx -> defcred = GSS_C_NO_CREDENTIAL ; ctx -> magic = KG_IAKERB_CONTEXT ; ctx -> state = IAKERB_AS_REQ ; ctx -> count = 0 ;  code = krb5_gss_init_context ( & ctx -> k5c ) ;  if ( code != 0 ) goto cleanup ; * pctx = ctx ; cleanup : if ( code != 0 ) iakerb_release_context ( ctx ) ; return code ; }",ctx -> initiate = initiate ;ctx -> established = 0 ;code = krb5_gss_init_context ( & ctx -> k5c ) ;if ( code != 0 ) goto cleanup ;,1261
74,"buggy line: dst_known = tnum_is_const ( dst_reg -> var_off ) ;switch ( opcode ) {cwe id:CWE-190context: static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ;  dst_known = tnum_is_const ( dst_reg -> var_off ) ;  switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }",if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}dst_known = tnum_is_const ( dst_reg -> var_off ) ;switch ( opcode ) {,1262
75,"buggy line: status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ;if ( status == MagickFalse ) {if ( image == ( Image * ) NULL )  image = screen ;else AppendImageToList ( & image , screen ) ;cwe id:CWE-772context: static Image * ReadSCREENSHOTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = ( Image * ) NULL ; # if defined ( MAGICKCORE_WINGDI32_DELEGATE ) { BITMAPINFO bmi ; DISPLAY_DEVICE device ; HBITMAP bitmap , bitmapOld ; HDC bitmapDC , hDC ; Image * screen ; int i ; MagickBooleanType status ; register PixelPacket * q ; register ssize_t x ; RGBTRIPLE * p ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; i = 0 ; device . cb = sizeof ( device ) ; image = ( Image * ) NULL ; while ( EnumDisplayDevices ( NULL , i , & device , 0 ) && ++ i ) { if ( ( device . StateFlags & DISPLAY_DEVICE_ACTIVE ) != DISPLAY_DEVICE_ACTIVE ) continue ; hDC = CreateDC ( device . DeviceName , device . DeviceName , NULL , NULL ) ; if ( hDC == ( HDC ) NULL ) ThrowReaderException ( CoderError , ""UnableToCreateDC"" ) ; screen = AcquireImage ( image_info ) ; screen -> columns = ( size_t ) GetDeviceCaps ( hDC , HORZRES ) ; screen -> rows = ( size_t ) GetDeviceCaps ( hDC , VERTRES ) ; screen -> storage_class = DirectClass ;  status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ;  if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }  if ( image == ( Image * ) NULL )  image = screen ; else AppendImageToList ( & image , screen ) ; bitmapDC = CreateCompatibleDC ( hDC ) ; if ( bitmapDC == ( HDC ) NULL ) { DeleteDC ( hDC ) ; ThrowReaderException ( CoderError , ""UnableToCreateDC"" ) ; } ( void ) ResetMagickMemory ( & bmi , 0 , sizeof ( BITMAPINFO ) ) ; bmi . bmiHeader . biSize = sizeof ( BITMAPINFOHEADER ) ; bmi . bmiHeader . biWidth = ( LONG ) screen -> columns ; bmi . bmiHeader . biHeight = ( - 1 ) * ( LONG ) screen -> rows ; bmi . bmiHeader . biPlanes = 1 ; bmi . bmiHeader . biBitCount = 24 ; bmi . bmiHeader . biCompression = BI_RGB ; bitmap = CreateDIBSection ( hDC , & bmi , DIB_RGB_COLORS , ( void * * ) & p , NULL , 0 ) ; if ( bitmap == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; ThrowReaderException ( CoderError , ""UnableToCreateBitmap"" ) ; } bitmapOld = ( HBITMAP ) SelectObject ( bitmapDC , bitmap ) ; if ( bitmapOld == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; ThrowReaderException ( CoderError , ""UnableToCreateBitmap"" ) ; } BitBlt ( bitmapDC , 0 , 0 , ( int ) screen -> columns , ( int ) screen -> rows , hDC , 0 , 0 , SRCCOPY ) ; ( void ) SelectObject ( bitmapDC , bitmapOld ) ; for ( y = 0 ; y < ( ssize_t ) screen -> rows ; y ++ ) { q = QueueAuthenticPixels ( screen , 0 , y , screen -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) screen -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( p -> rgbtRed ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( p -> rgbtGreen ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( p -> rgbtBlue ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( screen , exception ) == MagickFalse ) break ; } DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; } } # elif defined ( MAGICKCORE_X11_DELEGATE ) { const char * option ; XImportInfo ximage_info ; ( void ) exception ; XGetImportInfo ( & ximage_info ) ; option = GetImageOption ( image_info , ""x:screen"" ) ; if ( option != ( const char * ) NULL ) ximage_info . screen = IsMagickTrue ( option ) ; option = GetImageOption ( image_info , ""x:silent"" ) ; if ( option != ( const char * ) NULL ) ximage_info . silent = IsMagickTrue ( option ) ; image = XImportImage ( image_info , & ximage_info ) ; } # endif return ( image ) ; }","if ( image == ( Image * ) NULL ) image = screen ;else AppendImageToList ( & image , screen ) ;status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ;if ( status == MagickFalse ) {",1263
76,"buggy line: while ( u4_start_code == USER_DATA_START_CODE ) {while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX )  {cwe id:CWE-254context: void impeg2d_dec_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ;  while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX )  { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }","while ( ( u4_start_code == USER_DATA_START_CODE ) {while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) {",1264
77,"buggy line: if ( strcmp ( dentry -> d_name . name , ""ipc_flood_count"" ) && strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) )  return - EINVAL ;if ( ! strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) flood_duration_test = true ;cwe id:CWE-401context: static ssize_t sof_dfsentry_write ( struct file * file , const char __user * buffer , size_t count , loff_t * ppos ) { # if IS_ENABLED ( CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST ) struct snd_sof_dfsentry * dfse = file -> private_data ; struct snd_sof_dev * sdev = dfse -> sdev ; unsigned long ipc_duration_ms = 0 ; bool flood_duration_test = false ; unsigned long ipc_count = 0 ; struct dentry * dentry ; int err ; # endif size_t size ; char * string ; int ret ; string = kzalloc ( count , GFP_KERNEL ) ; if ( ! string ) return - ENOMEM ; size = simple_write_to_buffer ( string , count , ppos , buffer , count ) ; ret = size ; # if IS_ENABLED ( CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST ) dentry = file -> f_path . dentry ; if ( strcmp ( dentry -> d_name . name , ""ipc_flood_count"" ) && strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) )  return - EINVAL ;  if ( ! strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) flood_duration_test = true ; if ( flood_duration_test ) ret = kstrtoul ( string , 0 , & ipc_duration_ms ) ; else ret = kstrtoul ( string , 0 , & ipc_count ) ; if ( ret < 0 ) goto out ; if ( flood_duration_test ) { if ( ! ipc_duration_ms ) { ret = size ; goto out ; } if ( ipc_duration_ms > MAX_IPC_FLOOD_DURATION_MS ) ipc_duration_ms = MAX_IPC_FLOOD_DURATION_MS ; } else { if ( ! ipc_count ) { ret = size ; goto out ; } if ( ipc_count > MAX_IPC_FLOOD_COUNT ) ipc_count = MAX_IPC_FLOOD_COUNT ; } ret = pm_runtime_get_sync ( sdev -> dev ) ; if ( ret < 0 ) { dev_err_ratelimited ( sdev -> dev , ""error:<S2SV_blank>debugfs<S2SV_blank>write<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>%d\\n"" , ret ) ; pm_runtime_put_noidle ( sdev -> dev ) ; goto out ; } ret = sof_debug_ipc_flood_test ( sdev , dfse , flood_duration_test , ipc_duration_ms , ipc_count ) ; pm_runtime_mark_last_busy ( sdev -> dev ) ; err = pm_runtime_put_autosuspend ( sdev -> dev ) ; if ( err < 0 ) dev_err_ratelimited ( sdev -> dev , ""error:<S2SV_blank>debugfs<S2SV_blank>write<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>idle<S2SV_blank>%d\\n"" , err ) ; if ( ret >= 0 ) ret = size ; out : # endif kfree ( string ) ; return ret ; }","if ( strcmp ( dentry -> d_name . name , ""ipc_flood_count"" ) && strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) {ret = - EINVAL ;goto out ;}if ( ! strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) flood_duration_test = true ;",1265
78,"buggy line: cwe id:CWE-20context: MonoReflectionMethod * mono_reflection_bind_generic_method_parameters ( MonoReflectionMethod * rmethod , MonoArray * types ) { MonoClass * klass ; MonoMethod * method , * inflated ; MonoMethodInflated * imethod ; MonoGenericContext tmp_context ; MonoGenericInst * ginst ; MonoType * * type_argv ; int count , i ; MONO_ARCH_SAVE_REGS ; if ( ! strcmp ( rmethod -> object . vtable -> klass -> name , ""MethodBuilder"" ) ) { # ifndef DISABLE_REFLECTION_EMIT MonoReflectionMethodBuilder * mb = NULL ; MonoReflectionTypeBuilder * tb ; MonoClass * klass ; mb = ( MonoReflectionMethodBuilder * ) rmethod ; tb = ( MonoReflectionTypeBuilder * ) mb -> type ; klass = mono_class_from_mono_type ( mono_reflection_type_get_handle ( ( MonoReflectionType * ) tb ) ) ; method = methodbuilder_to_mono_method ( klass , mb ) ; # else g_assert_not_reached ( ) ; method = NULL ; # endif } else { method = rmethod -> method ; } klass = method -> klass ; if ( method -> is_inflated ) method = ( ( MonoMethodInflated * ) method ) -> declaring ; count = mono_method_signature ( method ) -> generic_param_count ; if ( count != mono_array_length ( types ) ) return NULL ; type_argv = g_new0 ( MonoType * , count ) ; for ( i = 0 ; i < count ; i ++ ) { MonoReflectionType * garg = mono_array_get ( types , gpointer , i ) ; type_argv [ i ] = mono_reflection_type_get_handle ( garg ) ; } ginst = mono_metadata_get_generic_inst ( count , type_argv ) ; g_free ( type_argv ) ; tmp_context . class_inst = klass -> generic_class ? klass -> generic_class -> context . class_inst : NULL ; tmp_context . method_inst = ginst ; inflated = mono_class_inflate_generic_method ( method , & tmp_context ) ; imethod = ( MonoMethodInflated * ) inflated ; if ( method -> klass -> image -> dynamic ) { MonoDynamicImage * image = ( MonoDynamicImage * ) method -> klass -> image ; mono_loader_lock ( ) ; mono_g_hash_table_insert ( image -> generic_def_objects , imethod , rmethod ) ; mono_loader_unlock ( ) ; }  return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ;  }","if ( ! mono_verifier_is_method_valid_generic_instantiation ( inflated ) ) mono_raise_exception ( mono_get_exception_argument ( ""typeArguments"" , ""Invalid<S2SV_blank>generic<S2SV_blank>arguments"" ) ) ;",1266
79,"buggy line: return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ;}cwe id:CWE-20context: MonoReflectionMethod * mono_reflection_bind_generic_method_parameters ( MonoReflectionMethod * rmethod , MonoArray * types ) { MonoClass * klass ; MonoMethod * method , * inflated ; MonoMethodInflated * imethod ; MonoGenericContext tmp_context ; MonoGenericInst * ginst ; MonoType * * type_argv ; int count , i ; MONO_ARCH_SAVE_REGS ; if ( ! strcmp ( rmethod -> object . vtable -> klass -> name , ""MethodBuilder"" ) ) { # ifndef DISABLE_REFLECTION_EMIT MonoReflectionMethodBuilder * mb = NULL ; MonoReflectionTypeBuilder * tb ; MonoClass * klass ; mb = ( MonoReflectionMethodBuilder * ) rmethod ; tb = ( MonoReflectionTypeBuilder * ) mb -> type ; klass = mono_class_from_mono_type ( mono_reflection_type_get_handle ( ( MonoReflectionType * ) tb ) ) ; method = methodbuilder_to_mono_method ( klass , mb ) ; # else g_assert_not_reached ( ) ; method = NULL ; # endif } else { method = rmethod -> method ; } klass = method -> klass ; if ( method -> is_inflated ) method = ( ( MonoMethodInflated * ) method ) -> declaring ; count = mono_method_signature ( method ) -> generic_param_count ; if ( count != mono_array_length ( types ) ) return NULL ; type_argv = g_new0 ( MonoType * , count ) ; for ( i = 0 ; i < count ; i ++ ) { MonoReflectionType * garg = mono_array_get ( types , gpointer , i ) ; type_argv [ i ] = mono_reflection_type_get_handle ( garg ) ; } ginst = mono_metadata_get_generic_inst ( count , type_argv ) ; g_free ( type_argv ) ; tmp_context . class_inst = klass -> generic_class ? klass -> generic_class -> context . class_inst : NULL ; tmp_context . method_inst = ginst ; inflated = mono_class_inflate_generic_method ( method , & tmp_context ) ; imethod = ( MonoMethodInflated * ) inflated ; if ( method -> klass -> image -> dynamic ) { MonoDynamicImage * image = ( MonoDynamicImage * ) method -> klass -> image ; mono_loader_lock ( ) ; mono_g_hash_table_insert ( image -> generic_def_objects , imethod , rmethod ) ; mono_loader_unlock ( ) ; }  return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ;  }","return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ;}",1266
80,"buggy line: int tmp ;if ( copy_from_user ( buf , buffer , count ) )  return - EFAULT ;cwe id:CWE-119context: static ssize_t exitcode_proc_write ( struct file * file , const char __user * buffer , size_t count , loff_t * pos ) { char * end , buf [ sizeof ( ""nnnnn\\0"" ) ] ;  int tmp ;   if ( copy_from_user ( buf , buffer , count ) )  return - EFAULT ; tmp = simple_strtol ( buf , & end , 0 ) ; if ( ( * end != '\\0' ) && ! isspace ( * end ) ) return - EINVAL ; uml_exitcode = tmp ; return count ; }","size_t size ;int tmp ;size = min ( count , sizeof ( buf ) ) ;if ( copy_from_user ( buf , buffer , size ) ) return - EFAULT ;",1267
81,"buggy line: xmlGenericError ( xmlGenericErrorContext ,  ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\\}cwe id:CWE-835context: int xmlPushInput ( xmlParserCtxtPtr ctxt , xmlParserInputPtr input ) { int ret ; if ( input == NULL ) return ( - 1 ) ; if ( xmlParserDebugEntities ) { if ( ( ctxt -> input != NULL ) && ( ctxt -> input -> filename ) ) xmlGenericError ( xmlGenericErrorContext , ""%s(%d):<S2SV_blank>"" , ctxt -> input -> filename , ctxt -> input -> line ) ; xmlGenericError ( xmlGenericErrorContext ,  ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\n"" , ctxt -> inputNr + 1 , input -> cur ) ;  } ret = inputPush ( ctxt , input ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( - 1 ) ; GROW ; return ( ret ) ; }","xmlGenericError ( xmlGenericErrorContext , ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\\}if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) {xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ;while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ;return ( - 1 ) ;}",1268
82,"buggy line: cwe id:CWE-000context: static int sanity_check_raw_super ( struct f2fs_sb_info * sbi , struct buffer_head * bh ) { struct f2fs_super_block * raw_super = ( struct f2fs_super_block * ) ( bh -> b_data + F2FS_SUPER_OFFSET ) ; struct super_block * sb = sbi -> sb ; unsigned int blocksize ; if ( F2FS_SUPER_MAGIC != le32_to_cpu ( raw_super -> magic ) ) { f2fs_msg ( sb , KERN_INFO , ""Magic<S2SV_blank>Mismatch,<S2SV_blank>valid(0x%x)<S2SV_blank>-<S2SV_blank>read(0x%x)"" , F2FS_SUPER_MAGIC , le32_to_cpu ( raw_super -> magic ) ) ; return 1 ; } if ( F2FS_BLKSIZE != PAGE_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>page_cache_size<S2SV_blank>(%lu),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n"" , PAGE_SIZE ) ; return 1 ; } blocksize = 1 << le32_to_cpu ( raw_super -> log_blocksize ) ; if ( blocksize != F2FS_BLKSIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>blocksize<S2SV_blank>(%u),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n"" , blocksize ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_blocks_per_seg ) != 9 ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>blocks<S2SV_blank>per<S2SV_blank>segment<S2SV_blank>(%u)\\n"" , le32_to_cpu ( raw_super -> log_blocks_per_seg ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectorsize ) > F2FS_MAX_LOG_SECTOR_SIZE || le32_to_cpu ( raw_super -> log_sectorsize ) < F2FS_MIN_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>sectorsize<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectors_per_block ) + le32_to_cpu ( raw_super -> log_sectorsize ) != F2FS_MAX_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>sectors<S2SV_blank>per<S2SV_blank>block(%u)<S2SV_blank>log<S2SV_blank>sectorsize(%u)"" , le32_to_cpu ( raw_super -> log_sectors_per_block ) , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> node_ino ) != 1 || le32_to_cpu ( raw_super -> meta_ino ) != 2 || le32_to_cpu ( raw_super -> root_ino ) != 3 ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>Fs<S2SV_blank>Meta<S2SV_blank>Ino:<S2SV_blank>node(%u)<S2SV_blank>meta(%u)<S2SV_blank>root(%u)"" , le32_to_cpu ( raw_super -> node_ino ) , le32_to_cpu ( raw_super -> meta_ino ) , le32_to_cpu ( raw_super -> root_ino ) ) ; return 1 ; }  if ( sanity_check_area_boundary ( sbi , bh ) )  return 1 ; return 0 ; }","if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) {f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ;return 1 ;}",1269
83,"buggy line: if ( sanity_check_area_boundary ( sbi , bh ) )  return 1 ;cwe id:CWE-000context: static int sanity_check_raw_super ( struct f2fs_sb_info * sbi , struct buffer_head * bh ) { struct f2fs_super_block * raw_super = ( struct f2fs_super_block * ) ( bh -> b_data + F2FS_SUPER_OFFSET ) ; struct super_block * sb = sbi -> sb ; unsigned int blocksize ; if ( F2FS_SUPER_MAGIC != le32_to_cpu ( raw_super -> magic ) ) { f2fs_msg ( sb , KERN_INFO , ""Magic<S2SV_blank>Mismatch,<S2SV_blank>valid(0x%x)<S2SV_blank>-<S2SV_blank>read(0x%x)"" , F2FS_SUPER_MAGIC , le32_to_cpu ( raw_super -> magic ) ) ; return 1 ; } if ( F2FS_BLKSIZE != PAGE_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>page_cache_size<S2SV_blank>(%lu),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n"" , PAGE_SIZE ) ; return 1 ; } blocksize = 1 << le32_to_cpu ( raw_super -> log_blocksize ) ; if ( blocksize != F2FS_BLKSIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>blocksize<S2SV_blank>(%u),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n"" , blocksize ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_blocks_per_seg ) != 9 ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>blocks<S2SV_blank>per<S2SV_blank>segment<S2SV_blank>(%u)\\n"" , le32_to_cpu ( raw_super -> log_blocks_per_seg ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectorsize ) > F2FS_MAX_LOG_SECTOR_SIZE || le32_to_cpu ( raw_super -> log_sectorsize ) < F2FS_MIN_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>sectorsize<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectors_per_block ) + le32_to_cpu ( raw_super -> log_sectorsize ) != F2FS_MAX_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>sectors<S2SV_blank>per<S2SV_blank>block(%u)<S2SV_blank>log<S2SV_blank>sectorsize(%u)"" , le32_to_cpu ( raw_super -> log_sectors_per_block ) , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> node_ino ) != 1 || le32_to_cpu ( raw_super -> meta_ino ) != 2 || le32_to_cpu ( raw_super -> root_ino ) != 3 ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>Fs<S2SV_blank>Meta<S2SV_blank>Ino:<S2SV_blank>node(%u)<S2SV_blank>meta(%u)<S2SV_blank>root(%u)"" , le32_to_cpu ( raw_super -> node_ino ) , le32_to_cpu ( raw_super -> meta_ino ) , le32_to_cpu ( raw_super -> root_ino ) ) ; return 1 ; }  if ( sanity_check_area_boundary ( sbi , bh ) )  return 1 ; return 0 ; }","if ( sanity_check_area_boundary ( sbi , bh ) ) return 1 ;",1269
84,"buggy line: char * last_elem , * wp ;last_elem = wp = result ;if ( ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 )   || ( strncmp ( & name [ 1 ] , ""PLATFORM"" , 8 ) == 0 && ( len = 9 ) != 0 ) )  && ( name [ len ] == \'\\\\0\' || name [ len ] == \'/\' || ( is_path && name [ len ] == \':\' ) ) ) || ( name [ 1 ] == \'{repl = ( ( len == 7 || name [ 2 ] == \'O\' )  ? ( __libc_enable_secure ? NULL : l -> l_origin )  : _dl_platform ) ;cwe id:CWE-252context: char * _dl_dst_substitute ( struct link_map * l , const char * name , char * result , int is_path ) {  char * last_elem , * wp ;  last_elem = wp = result ; do { if ( * name == '$' ) { const char * repl ; size_t len ;  if ( ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 )   || ( strncmp ( & name [ 1 ] , ""PLATFORM"" , 8 ) == 0 && ( len = 9 ) != 0 ) )  && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 ) || ( strncmp ( & name [ 2 ] , ""PLATFORM}"" , 9 ) == 0 && ( len = 11 ) != 0 ) ) ) ) { repl = ( ( len == 7 || name [ 2 ] == 'O' )  ? ( __libc_enable_secure ? NULL : l -> l_origin )  : _dl_platform ) ; if ( repl != NULL && repl != ( const char * ) - 1 ) { wp = __stpcpy ( wp , repl ) ; name += len ; } else { wp = last_elem ; name += len ; while ( * name != '\\0' && ( ! is_path || * name != ':' ) ) ++ name ; } } else * wp ++ = * name ++ ; } else if ( is_path && * name == ':' ) { * wp ++ = * name ++ ; last_elem = wp ; } else * wp ++ = * name ++ ; } while ( * name != '\\0' ) ; * wp = '\\0' ; return result ; }","const char * const start = name ;char * last_elem , * wp ;last_elem = wp = result ;if ( ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN}"" , 6 ) == 0 && ( len = 7 ) != 0 ) || ( strncmp ( & name [ 1 ] , ""PLATFORM}"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == \'\\\\0\' || name [ len ] == \'/\' || ( is_path && name [ len ] == \':\' ) ) ) || ( name [ 1 ] == \'{repl = ( ( len == 7 || name [ 2 ] == \'O\' ) ? ( __libc_enable_secure && ( ( name [ len ] != \'\\\\0\' && ( ! is_path || name [ len ] != \':\' ) ) || ( name != start && ( ! is_path || name [ - 1 ] != \':\' ) ) ) ? NULL : l -> l_origin ) : _dl_platform ) ;",1270
85,"buggy line: pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) ) ;if ( pDecCont == NULL ) {cwe id:CWE-119context: H264SwDecRet H264SwDecInit ( H264SwDecInst * decInst , u32 noOutputReordering ) { u32 rv = 0 ; decContainer_t * pDecCont ; DEC_API_TRC ( ""H264SwDecInit#"" ) ; if ( ( ( - 1 ) >> 1 ) != ( - 1 ) ) { DEC_API_TRC ( ""H264SwDecInit#<S2SV_blank>ERROR:<S2SV_blank>Right<S2SV_blank>shift<S2SV_blank>is<S2SV_blank>not<S2SV_blank>signed"" ) ; return ( H264SWDEC_INITFAIL ) ; } if ( decInst == NULL ) { DEC_API_TRC ( ""H264SwDecInit#<S2SV_blank>ERROR:<S2SV_blank>decInst<S2SV_blank>==<S2SV_blank>NULL"" ) ; return ( H264SWDEC_PARAM_ERR ) ; }  pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) ) ;  if ( pDecCont == NULL ) { DEC_API_TRC ( ""H264SwDecInit#<S2SV_blank>ERROR:<S2SV_blank>Memory<S2SV_blank>allocation<S2SV_blank>failed"" ) ; return ( H264SWDEC_MEMFAIL ) ; } # ifdef H264DEC_TRACE sprintf ( pDecCont -> str , ""H264SwDecInit#<S2SV_blank>decInst<S2SV_blank>%p<S2SV_blank>noOutputReordering<S2SV_blank>%d"" , ( void * ) decInst , noOutputReordering ) ; DEC_API_TRC ( pDecCont -> str ) ; # endif rv = h264bsdInit ( & pDecCont -> storage , noOutputReordering ) ; if ( rv != HANTRO_OK ) { H264SwDecRelease ( pDecCont ) ; return ( H264SWDEC_MEMFAIL ) ; } pDecCont -> decStat = INITIALIZED ; pDecCont -> picNumber = 0 ; # ifdef H264DEC_TRACE sprintf ( pDecCont -> str , ""H264SwDecInit#<S2SV_blank>OK:<S2SV_blank>return<S2SV_blank>%p"" , ( void * ) pDecCont ) ; DEC_API_TRC ( pDecCont -> str ) ; # endif * decInst = ( decContainer_t * ) pDecCont ; return ( H264SWDEC_OK ) ; }","pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) , 1 ) ;if ( pDecCont == NULL ) {",1271
86,"buggy line: static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len )  {struct ipv6_txoptions opt_space ;cwe id:CWE-416context: static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len )  {  struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct raw6_sock * rp = raw6_sk ( sk ) ; struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct raw6_frag_vec rfv ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; u16 proto ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( sin6 ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( sin6 -> sin6_family && sin6 -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; proto = ntohs ( sin6 -> sin6_port ) ; if ( ! proto ) proto = inet -> inet_num ; else if ( proto != inet -> inet_num ) return - EINVAL ; if ( proto > 255 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; proto = inet -> inet_num ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; } if ( ! opt )  opt = np -> opt ;  if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = proto ; rfv . msg = msg ; rfv . hlen = 0 ; err = rawv6_probe_proto_opt ( & rfv , & fl6 ) ; if ( err ) goto out ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; if ( inet -> hdrincl ) fl6 . flowi6_flags |= FLOWI_FLAG_KNOWN_NH ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = rawv6_send_hdrinc ( sk , msg , len , & fl6 , & dst , msg -> msg_flags ) ; else { lock_sock ( sk ) ; err = ip6_append_data ( sk , raw6_getfrag , & rfv , len , 0 , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = rawv6_push_pending_frames ( sk , & fl6 , rp ) ; release_sock ( sk ) ; } done : dst_release ( dst ) ; out : fl6_sock_release ( flowlabel ) ;  return err < 0 ? err : len ;  do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }","static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) {struct ipv6_txoptions * opt_to_free = NULL ;struct ipv6_txoptions opt_space ;",1272
87,"buggy line: if ( ! opt )  opt = np -> opt ;if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ;cwe id:CWE-416context: static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len )  {  struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct raw6_sock * rp = raw6_sk ( sk ) ; struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct raw6_frag_vec rfv ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; u16 proto ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( sin6 ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( sin6 -> sin6_family && sin6 -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; proto = ntohs ( sin6 -> sin6_port ) ; if ( ! proto ) proto = inet -> inet_num ; else if ( proto != inet -> inet_num ) return - EINVAL ; if ( proto > 255 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; proto = inet -> inet_num ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; } if ( ! opt )  opt = np -> opt ;  if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = proto ; rfv . msg = msg ; rfv . hlen = 0 ; err = rawv6_probe_proto_opt ( & rfv , & fl6 ) ; if ( err ) goto out ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; if ( inet -> hdrincl ) fl6 . flowi6_flags |= FLOWI_FLAG_KNOWN_NH ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = rawv6_send_hdrinc ( sk , msg , len , & fl6 , & dst , msg -> msg_flags ) ; else { lock_sock ( sk ) ; err = ip6_append_data ( sk , raw6_getfrag , & rfv , len , 0 , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = rawv6_push_pending_frames ( sk , & fl6 , rp ) ; release_sock ( sk ) ; } done : dst_release ( dst ) ; out : fl6_sock_release ( flowlabel ) ;  return err < 0 ? err : len ;  do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }","if ( ! opt ) {opt = txopt_get ( np ) ;opt_to_free = opt ;}if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ;",1272
88,"buggy line: return err < 0 ? err : len ;do_confirm : dst_confirm ( dst ) ;cwe id:CWE-416context: static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len )  {  struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct raw6_sock * rp = raw6_sk ( sk ) ; struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct raw6_frag_vec rfv ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; u16 proto ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( sin6 ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( sin6 -> sin6_family && sin6 -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; proto = ntohs ( sin6 -> sin6_port ) ; if ( ! proto ) proto = inet -> inet_num ; else if ( proto != inet -> inet_num ) return - EINVAL ; if ( proto > 255 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; proto = inet -> inet_num ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; } if ( ! opt )  opt = np -> opt ;  if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = proto ; rfv . msg = msg ; rfv . hlen = 0 ; err = rawv6_probe_proto_opt ( & rfv , & fl6 ) ; if ( err ) goto out ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; if ( inet -> hdrincl ) fl6 . flowi6_flags |= FLOWI_FLAG_KNOWN_NH ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = rawv6_send_hdrinc ( sk , msg , len , & fl6 , & dst , msg -> msg_flags ) ; else { lock_sock ( sk ) ; err = ip6_append_data ( sk , raw6_getfrag , & rfv , len , 0 , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = rawv6_push_pending_frames ( sk , & fl6 , rp ) ; release_sock ( sk ) ; } done : dst_release ( dst ) ; out : fl6_sock_release ( flowlabel ) ;  return err < 0 ? err : len ;  do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }",txopt_put ( opt_to_free ) ;return err < 0 ? err : len ;do_confirm : dst_confirm ( dst ) ;,1272
89,"buggy line: if ( iph -> ihl == 5 ) {memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ;return 0 ;}opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ;cwe id:CWE-399context: static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( IPCB ( skb ) -> opt ) ; if ( iph -> ihl < 5 || iph -> version != 4 ) goto inhdr_error ; if ( ! pskb_may_pull ( skb , iph -> ihl * 4 ) ) goto inhdr_error ; iph = ip_hdr ( skb ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INTRUNCATEDPKTS ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INDISCARDS ) ; goto drop ; }  if ( iph -> ihl == 5 ) {  memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ;  }  opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev = __in_dev_get_rcu ( dev ) ; if ( in_dev && ! IN_DEV_SOURCE_ROUTE ( in_dev ) ) goto drop ; if ( ip_options_rcv_srr ( skb ) ) goto drop ; } return 0 ; inhdr_error : IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INHDRERRORS ) ; drop : return - 1 ; }","memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ;if ( iph -> ihl == 5 ) return 0 ;}opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ;",1273
90,"buggy line: error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;cwe id:CWE-285context: static int __reiserfs_set_acl ( struct reiserfs_transaction_handle * th , struct inode * inode , int type , struct posix_acl * acl ) { char * name ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) {  error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;  if ( error < 0 ) return error ; else { if ( error == 0 ) acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = reiserfs_posix_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = reiserfs_xattr_set_handle ( th , inode , name , value , size , 0 ) ; if ( error == - ENODATA ) { error = 0 ; if ( type == ACL_TYPE_ACCESS ) { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; } } kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( error < 0 ) return error ;",1274
91,"buggy line: if ( rtm -> rtm_flags & RTM_F_FIB_MATCH )  err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid ,  nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ;else err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ;rcu_read_unlock ( ) ;err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ;cwe id:CWE-476context: static int inet_rtm_getroute ( struct sk_buff * in_skb , struct nlmsghdr * nlh , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( in_skb -> sk ) ; struct rtmsg * rtm ; struct nlattr * tb [ RTA_MAX + 1 ] ; struct fib_result res = { } ; struct rtable * rt = NULL ; struct flowi4 fl4 ; __be32 dst = 0 ; __be32 src = 0 ; u32 iif ; int err ; int mark ; struct sk_buff * skb ; u32 table_id = RT_TABLE_MAIN ; kuid_t uid ; err = nlmsg_parse ( nlh , sizeof ( * rtm ) , tb , RTA_MAX , rtm_ipv4_policy , extack ) ; if ( err < 0 ) goto errout ; rtm = nlmsg_data ( nlh ) ; skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ) ; if ( ! skb ) { err = - ENOBUFS ; goto errout ; } skb_reset_mac_header ( skb ) ; skb_reset_network_header ( skb ) ; src = tb [ RTA_SRC ] ? nla_get_in_addr ( tb [ RTA_SRC ] ) : 0 ; dst = tb [ RTA_DST ] ? nla_get_in_addr ( tb [ RTA_DST ] ) : 0 ; iif = tb [ RTA_IIF ] ? nla_get_u32 ( tb [ RTA_IIF ] ) : 0 ; mark = tb [ RTA_MARK ] ? nla_get_u32 ( tb [ RTA_MARK ] ) : 0 ; if ( tb [ RTA_UID ] ) uid = make_kuid ( current_user_ns ( ) , nla_get_u32 ( tb [ RTA_UID ] ) ) ; else uid = ( iif ? INVALID_UID : current_uid ( ) ) ; ip_hdr ( skb ) -> protocol = IPPROTO_UDP ; ip_hdr ( skb ) -> saddr = src ; ip_hdr ( skb ) -> daddr = dst ; skb_reserve ( skb , MAX_HEADER + sizeof ( struct iphdr ) ) ; memset ( & fl4 , 0 , sizeof ( fl4 ) ) ; fl4 . daddr = dst ; fl4 . saddr = src ; fl4 . flowi4_tos = rtm -> rtm_tos ; fl4 . flowi4_oif = tb [ RTA_OIF ] ? nla_get_u32 ( tb [ RTA_OIF ] ) : 0 ; fl4 . flowi4_mark = mark ; fl4 . flowi4_uid = uid ; rcu_read_lock ( ) ; if ( iif ) { struct net_device * dev ; dev = dev_get_by_index_rcu ( net , iif ) ; if ( ! dev ) { err = - ENODEV ; goto errout_free ; } skb -> protocol = htons ( ETH_P_IP ) ; skb -> dev = dev ; skb -> mark = mark ; err = ip_route_input_rcu ( skb , dst , src , rtm -> rtm_tos , dev , & res ) ; rt = skb_rtable ( skb ) ; if ( err == 0 && rt -> dst . error ) err = - rt -> dst . error ; } else { rt = ip_route_output_key_hash_rcu ( net , & fl4 , & res , skb ) ; err = 0 ; if ( IS_ERR ( rt ) ) err = PTR_ERR ( rt ) ; else skb_dst_set ( skb , & rt -> dst ) ; } if ( err ) goto errout_free ; if ( rtm -> rtm_flags & RTM_F_NOTIFY ) rt -> rt_flags |= RTCF_NOTIFY ; if ( rtm -> rtm_flags & RTM_F_LOOKUP_TABLE ) table_id = rt -> rt_table_id ; if ( rtm -> rtm_flags & RTM_F_FIB_MATCH )  err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid ,  nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; else err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; if ( err < 0 ) goto errout_free ;  rcu_read_unlock ( ) ;  err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ; errout : return err ; errout_free : rcu_read_unlock ( ) ; kfree_skb ( skb ) ; goto errout ; }","if ( rtm -> rtm_flags & RTM_F_FIB_MATCH ) {if ( ! res . fi ) {err = fib_props [ res . type ] . error ;if ( ! err ) err = - EHOSTUNREACH ;goto errout_free ;}err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ;}else {err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ;}rcu_read_unlock ( ) ;err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ;",1275
92,"buggy line: pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns ,  4 * sizeof ( * pixels ) ) ;cwe id:CWE-119context: static Image * ReadAVSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register PixelPacket * q ; register ssize_t x ; register unsigned char * p ; size_t height , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobMSBLong ( image ) ; height = ReadBlobMSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { ssize_t length ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;  pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns ,  4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobMSBLong ( image ) ; height = ReadBlobMSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ;",1276
93,"buggy line: cwe id:CWE-200context: int res_unpack ( vorbis_info_residue * info , vorbis_info * vi , oggpack_buffer * opb ) { int j , k ; codec_setup_info * ci = ( codec_setup_info * ) vi -> codec_setup ; memset ( info , 0 , sizeof ( * info ) ) ; info -> type = oggpack_read ( opb , 16 ) ; if ( info -> type > 2 || info -> type < 0 ) goto errout ; info -> begin = oggpack_read ( opb , 24 ) ; info -> end = oggpack_read ( opb , 24 ) ; info -> grouping = oggpack_read ( opb , 24 ) + 1 ; info -> partitions = ( char ) ( oggpack_read ( opb , 6 ) + 1 ) ; info -> groupbook = ( unsigned char ) oggpack_read ( opb , 8 ) ; if ( info -> groupbook >= ci -> books ) goto errout ; info -> stagemasks = _ogg_malloc ( info -> partitions * sizeof ( * info -> stagemasks ) ) ; info -> stagebooks = _ogg_malloc ( info -> partitions * 8 * sizeof ( * info -> stagebooks ) ) ; for ( j = 0 ; j < info -> partitions ; j ++ ) { int cascade = oggpack_read ( opb , 3 ) ; if ( oggpack_read ( opb , 1 ) ) cascade |= ( oggpack_read ( opb , 5 ) << 3 ) ; info -> stagemasks [ j ] = cascade ; } for ( j = 0 ; j < info -> partitions ; j ++ ) { for ( k = 0 ; k < 8 ; k ++ ) { if ( ( info -> stagemasks [ j ] >> k ) & 1 ) { unsigned char book = ( unsigned char ) oggpack_read ( opb , 8 ) ; if ( book >= ci -> books ) goto errout ; info -> stagebooks [ j * 8 + k ] = book ; if ( k + 1 > info -> stages ) info -> stages = k + 1 ; } else info -> stagebooks [ j * 8 + k ] = 0xff ; } } if ( oggpack_eop ( opb ) ) goto errout ;  return 0 ;  errout : res_clear_info ( info ) ; return 1 ; }",int limit = ( info -> type == 2 ? vi -> channels : 1 ) * ci -> blocksizes [ 1 ] / 2 ;if ( info -> begin > info -> end || info -> end > limit ) {goto errout ;},1277
94,"buggy line: return 0 ;errout : res_clear_info ( info ) ;cwe id:CWE-200context: int res_unpack ( vorbis_info_residue * info , vorbis_info * vi , oggpack_buffer * opb ) { int j , k ; codec_setup_info * ci = ( codec_setup_info * ) vi -> codec_setup ; memset ( info , 0 , sizeof ( * info ) ) ; info -> type = oggpack_read ( opb , 16 ) ; if ( info -> type > 2 || info -> type < 0 ) goto errout ; info -> begin = oggpack_read ( opb , 24 ) ; info -> end = oggpack_read ( opb , 24 ) ; info -> grouping = oggpack_read ( opb , 24 ) + 1 ; info -> partitions = ( char ) ( oggpack_read ( opb , 6 ) + 1 ) ; info -> groupbook = ( unsigned char ) oggpack_read ( opb , 8 ) ; if ( info -> groupbook >= ci -> books ) goto errout ; info -> stagemasks = _ogg_malloc ( info -> partitions * sizeof ( * info -> stagemasks ) ) ; info -> stagebooks = _ogg_malloc ( info -> partitions * 8 * sizeof ( * info -> stagebooks ) ) ; for ( j = 0 ; j < info -> partitions ; j ++ ) { int cascade = oggpack_read ( opb , 3 ) ; if ( oggpack_read ( opb , 1 ) ) cascade |= ( oggpack_read ( opb , 5 ) << 3 ) ; info -> stagemasks [ j ] = cascade ; } for ( j = 0 ; j < info -> partitions ; j ++ ) { for ( k = 0 ; k < 8 ; k ++ ) { if ( ( info -> stagemasks [ j ] >> k ) & 1 ) { unsigned char book = ( unsigned char ) oggpack_read ( opb , 8 ) ; if ( book >= ci -> books ) goto errout ; info -> stagebooks [ j * 8 + k ] = book ; if ( k + 1 > info -> stages ) info -> stages = k + 1 ; } else info -> stagebooks [ j * 8 + k ] = 0xff ; } } if ( oggpack_eop ( opb ) ) goto errout ;  return 0 ;  errout : res_clear_info ( info ) ; return 1 ; }",return 0 ;errout : res_clear_info ( info ) ;,1277
95,"buggy line: if ( ! js_regexec ( re -> prog , text , & m , 0 ) )  js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ;cwe id:CWE-400context: static void Sp_search ( js_State * J ) { js_Regexp * re ; const char * text ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ;  if ( ! js_regexec ( re -> prog , text , & m , 0 ) )  js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ; }","if ( ! js_doregexec ( J , re -> prog , text , & m , 0 ) ) js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ;",1278
96,"buggy line: used = recv_actor ( desc , skb , offset , len ) ;if ( used < 0 ) {if ( ! copied ) copied = used ;break ;}else if ( used <= len ) {seq += used ;copied += used ;offset += used ;}skb = tcp_recv_skb ( sk , seq - 1 , & offset ) ;if ( ! skb || ( offset + 1 != skb -> len ) ) break ;}if ( tcp_hdr ( skb ) -> fin ) {sk_eat_skb ( sk , skb , 0 ) ;++ seq ;break ;}sk_eat_skb ( sk , skb , 0 ) ;if ( ! desc -> count ) break ;}tp -> copied_seq = seq ;tcp_rcv_space_adjust ( sk ) ;if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ;cwe id:CWE-119context: int tcp_read_sock ( struct sock * sk , read_descriptor_t * desc , sk_read_actor_t recv_actor ) { struct sk_buff * skb ; struct tcp_sock * tp = tcp_sk ( sk ) ; u32 seq = tp -> copied_seq ; u32 offset ; int copied = 0 ; if ( sk -> sk_state == TCP_LISTEN ) return - ENOTCONN ; while ( ( skb = tcp_recv_skb ( sk , seq , & offset ) ) != NULL ) { if ( offset < skb -> len ) { int used ; size_t len ; len = skb -> len - offset ; if ( tp -> urg_data ) { u32 urg_offset = tp -> urg_seq - seq ; if ( urg_offset < len ) len = urg_offset ; if ( ! len ) break ; } used = recv_actor ( desc , skb , offset , len ) ; if ( used < 0 ) { if ( ! copied ) copied = used ; break ; } else if ( used <= len ) { seq += used ; copied += used ; offset += used ; } skb = tcp_recv_skb ( sk , seq - 1 , & offset ) ; if ( ! skb || ( offset + 1 != skb -> len ) ) break ; } if ( tcp_hdr ( skb ) -> fin ) { sk_eat_skb ( sk , skb , 0 ) ; ++ seq ; break ; } sk_eat_skb ( sk , skb , 0 ) ; if ( ! desc -> count ) break ;  }  tp -> copied_seq = seq ;  tcp_rcv_space_adjust ( sk ) ;  if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ; return copied ; }","tp -> copied_seq = seq ;+ seq ;tp -> copied_seq = seq ;tcp_rcv_space_adjust ( sk ) ;if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ;",1279
97,"buggy line: krb5_key_data * key_data ;if ( n_key_data <= 0 ) return NULL ;if ( key_data_in == NULL )  goto cleanup ;i < n_key_data ;i ++ ) {if ( key_data [ i ] . key_data_ver == 1 ) {key_data [ i ] . key_data_ver = 2 ;key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ;key_data [ i ] . key_data_length [ 1 ] = 0 ;key_data [ i ] . key_data_contents [ 1 ] = NULL ;}}for ( i = 0 ;i < n_key_data - 1 ;i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ;ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ;if ( ret == NULL ) {err = ENOMEM ;goto cleanup ;}for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ;i < n_key_data ;i ++ ) {krb5_data * code ;if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) {ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ;if ( ret [ j ] == NULL ) goto cleanup ;err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ;if ( err ) goto cleanup ;ret [ j ] -> bv_len = code -> length ;ret [ j ] -> bv_val = code -> data ;free ( code ) ;j ++ ;last = i + 1 ;if ( i < n_key_data - 1 ) currkvno = key_data [ i + 1 ] . key_data_kvno ;}}ret [ num_versions ] = NULL ;cleanup : free ( key_data ) ;if ( err != 0 ) {if ( ret != NULL ) {for ( i = 0 ;i <= num_versions ;i ++ )   if ( ret [ i ] != NULL )  free ( ret [ i ] ) ;cwe id:CWE-000context: static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ;  krb5_key_data * key_data ;  if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ;  if ( key_data_in == NULL )  goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) { ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ; if ( ret [ j ] == NULL ) goto cleanup ; err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ; if ( err ) goto cleanup ; ret [ j ] -> bv_len = code -> length ; ret [ j ] -> bv_val = code -> data ; free ( code ) ; j ++ ; last = i + 1 ; if ( i < n_key_data - 1 ) currkvno = key_data [ i + 1 ] . key_data_kvno ; } } ret [ num_versions ] = NULL ; cleanup : free ( key_data ) ; if ( err != 0 ) { if ( ret != NULL ) {  for ( i = 0 ; i <= num_versions ; i ++ )   if ( ret [ i ] != NULL )  free ( ret [ i ] ) ; free ( ret ) ; ret = NULL ; } } return ret ; }",krb5_key_data * key_data = NULL ;if ( n_key_data < 0 ) return NULL ;if ( key_data == NULL ) goto cleanup ;ret [ i ] != NULL ;i ++ ) free ( ret [ i ] ) ;,1280
98,"buggy line: static int  _Unpickler_MemoPut ( UnpicklerObject * self , Py_ssize_t idx , PyObject * value )  {cwe id:CWE-190context: static int  _Unpickler_MemoPut ( UnpicklerObject * self , Py_ssize_t idx , PyObject * value )  { PyObject * old_item ; if ( idx >= self -> memo_size ) { if ( _Unpickler_ResizeMemoList ( self , idx * 2 ) < 0 ) return - 1 ; assert ( idx < self -> memo_size ) ; } Py_INCREF ( value ) ; old_item = self -> memo [ idx ] ; self -> memo [ idx ] = value ; if ( old_item != NULL ) { Py_DECREF ( old_item ) ; } else { self -> memo_len ++ ; } return 0 ; }","static int _Unpickler_MemoPut ( UnpicklerObject * self , size_t idx , PyObject * value ) {",1281
99,"buggy line: pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ;if ( pCsr -> zInput == 0 ) {cwe id:CWE-190context: static int fts3tokFilterMethod ( sqlite3_vtab_cursor * pCursor , int idxNum , const char * idxStr , int nVal , sqlite3_value * * apVal ) { int rc = SQLITE_ERROR ; Fts3tokCursor * pCsr = ( Fts3tokCursor * ) pCursor ; Fts3tokTable * pTab = ( Fts3tokTable * ) ( pCursor -> pVtab ) ; UNUSED_PARAMETER ( idxStr ) ; UNUSED_PARAMETER ( nVal ) ; fts3tokResetCursor ( pCsr ) ; if ( idxNum == 1 ) { const char * zByte = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nByte = sqlite3_value_bytes ( apVal [ 0 ] ) ;  pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ;  if ( pCsr -> zInput == 0 ) { rc = SQLITE_NOMEM ; } else { memcpy ( pCsr -> zInput , zByte , nByte ) ; pCsr -> zInput [ nByte ] = 0 ; rc = pTab -> pMod -> xOpen ( pTab -> pTok , pCsr -> zInput , nByte , & pCsr -> pCsr ) ; if ( rc == SQLITE_OK ) { pCsr -> pCsr -> pTokenizer = pTab -> pTok ; } } } if ( rc != SQLITE_OK ) return rc ; return fts3tokNextMethod ( pCursor ) ; }",pCsr -> zInput = sqlite3_malloc64 ( nByte + 1 ) ;if ( pCsr -> zInput == 0 ) {,1282
100,"buggy line: sock_release ( SOCKET_I ( inode ) ) ;return 0 ;cwe id:CWE-362context: static int sock_close ( struct inode * inode , struct file * filp ) {  sock_release ( SOCKET_I ( inode ) ) ;  return 0 ; }","__sock_release ( SOCKET_I ( inode ) , inode ) ;return 0 ;",1283
101,"buggy line: stmt_ty  AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int  lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {cwe id:CWE-125context: stmt_ty  AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int  lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! target ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>target<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } if ( ! iter ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>iter<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFor_kind ; p -> v . AsyncFor . target = target ; p -> v . AsyncFor . iter = iter ; p -> v . AsyncFor . body = body ;  p -> v . AsyncFor . orelse = orelse ;  p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","stmt_ty AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",1284
102,"buggy line: p -> v . AsyncFor . orelse = orelse ;p -> lineno = lineno ;cwe id:CWE-125context: stmt_ty  AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int  lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! target ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>target<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } if ( ! iter ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>iter<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFor_kind ; p -> v . AsyncFor . target = target ; p -> v . AsyncFor . iter = iter ; p -> v . AsyncFor . body = body ;  p -> v . AsyncFor . orelse = orelse ;  p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }",p -> v . AsyncFor . orelse = orelse ;p -> v . AsyncFor . type_comment = type_comment ;p -> lineno = lineno ;,1284
103,"buggy line: int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name )  {cwe id:CWE-362context:  int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name )  { reg2 uint key ; reg1 MI_KEYDEF * keyinfo ; File new_file ; my_off_t index_pos [ HA_MAX_POSSIBLE_KEY ] ; uint r_locks , w_locks ; int old_lock ; MYISAM_SHARE * share = info -> s ; MI_STATE_INFO old_state ; DBUG_ENTER ( ""mi_sort_index"" ) ; for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ; key < share -> base . keys ; key ++ , keyinfo ++ ) if ( keyinfo -> key_alg == HA_KEY_ALG_RTREE ) DBUG_RETURN ( 0 ) ; if ( ! ( param -> testflag & T_SILENT ) ) printf ( ""-<S2SV_blank>Sorting<S2SV_blank>index<S2SV_blank>for<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; fn_format ( param -> temp_filename , name , """" , MI_NAME_IEXT , 2 + 4 + 32 ) ; if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , param -> temp_filename , """" , INDEX_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) <= 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; DBUG_RETURN ( - 1 ) ; } if ( filecopy ( param , new_file , share -> kfile , 0L , ( ulong ) share -> base . keystart , ""headerblock"" ) ) goto err ; param -> new_file_pos = share -> base . keystart ; for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ; key < share -> base . keys ; key ++ , keyinfo ++ ) { if ( ! mi_is_key_active ( info -> s -> state . key_map , key ) ) continue ; if ( share -> state . key_root [ key ] != HA_OFFSET_ERROR ) { index_pos [ key ] = param -> new_file_pos ; if ( sort_one_index ( param , info , keyinfo , share -> state . key_root [ key ] , new_file ) ) goto err ; } else index_pos [ key ] = HA_OFFSET_ERROR ; } flush_key_blocks ( share -> key_cache , share -> kfile , FLUSH_IGNORE_CHANGED ) ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; old_state = share -> state ; r_locks = share -> r_locks ; w_locks = share -> w_locks ; old_lock = info -> lock_type ; share -> r_locks = share -> w_locks = share -> tot_locks = 0 ; ( void ) _mi_writeinfo ( info , WRITEINFO_UPDATE_KEYFILE ) ; ( void ) mysql_file_close ( share -> kfile , MYF ( MY_WME ) ) ; share -> kfile = - 1 ; ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ; if ( change_to_newfile ( share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT ,  MYF ( 0 ) ) ||  mi_open_keyfile ( share ) ) goto err2 ; info -> lock_type = F_UNLCK ; _mi_readinfo ( info , F_WRLCK , 0 ) ; info -> lock_type = old_lock ; share -> r_locks = r_locks ; share -> w_locks = w_locks ; share -> tot_locks = r_locks + w_locks ; share -> state = old_state ; info -> state -> key_file_length = param -> new_file_pos ; info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; for ( key = 0 ; key < info -> s -> base . keys ; key ++ ) info -> s -> state . key_root [ key ] = index_pos [ key ] ; for ( key = 0 ; key < info -> s -> state . header . max_block_size_index ; key ++ ) info -> s -> state . key_del [ key ] = HA_OFFSET_ERROR ; info -> s -> state . changed &= ~ STATE_NOT_SORTED_PAGES ; DBUG_RETURN ( 0 ) ; err : ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ; err2 : ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; DBUG_RETURN ( - 1 ) ; }","int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name , my_bool no_copy_stat ) {",1285
104,"buggy line: if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , param -> temp_filename , """" , INDEX_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) <= 0 ) {cwe id:CWE-362context:  int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name )  { reg2 uint key ; reg1 MI_KEYDEF * keyinfo ; File new_file ; my_off_t index_pos [ HA_MAX_POSSIBLE_KEY ] ; uint r_locks , w_locks ; int old_lock ; MYISAM_SHARE * share = info -> s ; MI_STATE_INFO old_state ; DBUG_ENTER ( ""mi_sort_index"" ) ; for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ; key < share -> base . keys ; key ++ , keyinfo ++ ) if ( keyinfo -> key_alg == HA_KEY_ALG_RTREE ) DBUG_RETURN ( 0 ) ; if ( ! ( param -> testflag & T_SILENT ) ) printf ( ""-<S2SV_blank>Sorting<S2SV_blank>index<S2SV_blank>for<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; fn_format ( param -> temp_filename , name , """" , MI_NAME_IEXT , 2 + 4 + 32 ) ; if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , param -> temp_filename , """" , INDEX_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) <= 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; DBUG_RETURN ( - 1 ) ; } if ( filecopy ( param , new_file , share -> kfile , 0L , ( ulong ) share -> base . keystart , ""headerblock"" ) ) goto err ; param -> new_file_pos = share -> base . keystart ; for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ; key < share -> base . keys ; key ++ , keyinfo ++ ) { if ( ! mi_is_key_active ( info -> s -> state . key_map , key ) ) continue ; if ( share -> state . key_root [ key ] != HA_OFFSET_ERROR ) { index_pos [ key ] = param -> new_file_pos ; if ( sort_one_index ( param , info , keyinfo , share -> state . key_root [ key ] , new_file ) ) goto err ; } else index_pos [ key ] = HA_OFFSET_ERROR ; } flush_key_blocks ( share -> key_cache , share -> kfile , FLUSH_IGNORE_CHANGED ) ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; old_state = share -> state ; r_locks = share -> r_locks ; w_locks = share -> w_locks ; old_lock = info -> lock_type ; share -> r_locks = share -> w_locks = share -> tot_locks = 0 ; ( void ) _mi_writeinfo ( info , WRITEINFO_UPDATE_KEYFILE ) ; ( void ) mysql_file_close ( share -> kfile , MYF ( MY_WME ) ) ; share -> kfile = - 1 ; ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ; if ( change_to_newfile ( share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT ,  MYF ( 0 ) ) ||  mi_open_keyfile ( share ) ) goto err2 ; info -> lock_type = F_UNLCK ; _mi_readinfo ( info , F_WRLCK , 0 ) ; info -> lock_type = old_lock ; share -> r_locks = r_locks ; share -> w_locks = w_locks ; share -> tot_locks = r_locks + w_locks ; share -> state = old_state ; info -> state -> key_file_length = param -> new_file_pos ; info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; for ( key = 0 ; key < info -> s -> base . keys ; key ++ ) info -> s -> state . key_root [ key ] = index_pos [ key ] ; for ( key = 0 ; key < info -> s -> state . header . max_block_size_index ; key ++ ) info -> s -> state . key_del [ key ] = HA_OFFSET_ERROR ; info -> s -> state . changed &= ~ STATE_NOT_SORTED_PAGES ; DBUG_RETURN ( 0 ) ; err : ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ; err2 : ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; DBUG_RETURN ( - 1 ) ; }","if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , param -> temp_filename , """" , INDEX_TMP_EXT , no_copy_stat ? MYF ( MY_REDEL_NO_COPY_STAT ) : 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) <= 0 ) {",1285
105,"buggy line: if ( change_to_newfile ( share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT ,  MYF ( 0 ) ) ||  mi_open_keyfile ( share ) ) goto err2 ;cwe id:CWE-362context:  int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name )  { reg2 uint key ; reg1 MI_KEYDEF * keyinfo ; File new_file ; my_off_t index_pos [ HA_MAX_POSSIBLE_KEY ] ; uint r_locks , w_locks ; int old_lock ; MYISAM_SHARE * share = info -> s ; MI_STATE_INFO old_state ; DBUG_ENTER ( ""mi_sort_index"" ) ; for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ; key < share -> base . keys ; key ++ , keyinfo ++ ) if ( keyinfo -> key_alg == HA_KEY_ALG_RTREE ) DBUG_RETURN ( 0 ) ; if ( ! ( param -> testflag & T_SILENT ) ) printf ( ""-<S2SV_blank>Sorting<S2SV_blank>index<S2SV_blank>for<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; fn_format ( param -> temp_filename , name , """" , MI_NAME_IEXT , 2 + 4 + 32 ) ; if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , param -> temp_filename , """" , INDEX_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) <= 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; DBUG_RETURN ( - 1 ) ; } if ( filecopy ( param , new_file , share -> kfile , 0L , ( ulong ) share -> base . keystart , ""headerblock"" ) ) goto err ; param -> new_file_pos = share -> base . keystart ; for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ; key < share -> base . keys ; key ++ , keyinfo ++ ) { if ( ! mi_is_key_active ( info -> s -> state . key_map , key ) ) continue ; if ( share -> state . key_root [ key ] != HA_OFFSET_ERROR ) { index_pos [ key ] = param -> new_file_pos ; if ( sort_one_index ( param , info , keyinfo , share -> state . key_root [ key ] , new_file ) ) goto err ; } else index_pos [ key ] = HA_OFFSET_ERROR ; } flush_key_blocks ( share -> key_cache , share -> kfile , FLUSH_IGNORE_CHANGED ) ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; old_state = share -> state ; r_locks = share -> r_locks ; w_locks = share -> w_locks ; old_lock = info -> lock_type ; share -> r_locks = share -> w_locks = share -> tot_locks = 0 ; ( void ) _mi_writeinfo ( info , WRITEINFO_UPDATE_KEYFILE ) ; ( void ) mysql_file_close ( share -> kfile , MYF ( MY_WME ) ) ; share -> kfile = - 1 ; ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ; if ( change_to_newfile ( share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT ,  MYF ( 0 ) ) ||  mi_open_keyfile ( share ) ) goto err2 ; info -> lock_type = F_UNLCK ; _mi_readinfo ( info , F_WRLCK , 0 ) ; info -> lock_type = old_lock ; share -> r_locks = r_locks ; share -> w_locks = w_locks ; share -> tot_locks = r_locks + w_locks ; share -> state = old_state ; info -> state -> key_file_length = param -> new_file_pos ; info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; for ( key = 0 ; key < info -> s -> base . keys ; key ++ ) info -> s -> state . key_root [ key ] = index_pos [ key ] ; for ( key = 0 ; key < info -> s -> state . header . max_block_size_index ; key ++ ) info -> s -> state . key_del [ key ] = HA_OFFSET_ERROR ; info -> s -> state . changed &= ~ STATE_NOT_SORTED_PAGES ; DBUG_RETURN ( 0 ) ; err : ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ; err2 : ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; DBUG_RETURN ( - 1 ) ; }","if ( change_to_newfile ( share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT , MYF ( 0 ) ) || mi_open_keyfile ( share ) ) goto err2 ;",1285
106,"buggy line: opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ;sk_dst_reset ( sk ) ;cwe id:CWE-264context: static struct ipv6_txoptions * ipv6_update_options ( struct sock * sk , struct ipv6_txoptions * opt ) { if ( inet_sk ( sk ) -> is_icsk ) { if ( opt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_LISTEN | TCPF_CLOSE ) ) && inet_sk ( sk ) -> inet_daddr != LOOPBACK4_IPV6 ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } }  opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ;  sk_dst_reset ( sk ) ; return opt ; }","opt = xchg ( ( __force struct ipv6_txoptions * * ) & inet6_sk ( sk ) -> opt , opt ) ;sk_dst_reset ( sk ) ;",1286
107,"buggy line: case DB_VECTOR :  dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ;cwe id:CWE-399context: static int handle_exception ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct kvm_run * kvm_run = vcpu -> run ; u32 intr_info , ex_no , error_code ; unsigned long cr2 , rip , dr6 ; u32 vect_info ; enum emulation_result er ; vect_info = vmx -> idt_vectoring_info ; intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ; if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) return 1 ; if ( is_no_device ( intr_info ) ) { vmx_fpu_activate ( vcpu ) ; return 1 ; } if ( is_invalid_opcode ( intr_info ) ) { if ( is_guest_mode ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } er = emulate_instruction ( vcpu , EMULTYPE_TRAP_UD ) ; if ( er != EMULATE_DONE ) kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } error_code = 0 ; if ( intr_info & INTR_INFO_DELIVER_CODE_MASK ) error_code = vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) ; if ( ( vect_info & VECTORING_INFO_VALID_MASK ) && ! ( is_page_fault ( intr_info ) && ! ( error_code & PFERR_RSVD_MASK ) ) ) { vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_SIMUL_EX ; vcpu -> run -> internal . ndata = 3 ; vcpu -> run -> internal . data [ 0 ] = vect_info ; vcpu -> run -> internal . data [ 1 ] = intr_info ; vcpu -> run -> internal . data [ 2 ] = error_code ; return 0 ; } if ( is_page_fault ( intr_info ) ) { BUG_ON ( enable_ept ) ; cr2 = vmcs_readl ( EXIT_QUALIFICATION ) ; trace_kvm_page_fault ( cr2 , error_code ) ; if ( kvm_event_needs_reinjection ( vcpu ) ) kvm_mmu_unprotect_page_virt ( vcpu , cr2 ) ; return kvm_mmu_page_fault ( vcpu , cr2 , error_code , NULL , 0 ) ; } ex_no = intr_info & INTR_INFO_VECTOR_MASK ; if ( vmx -> rmode . vm86_active && rmode_exception ( vcpu , ex_no ) ) return handle_rmode_exception ( vcpu , ex_no , error_code ) ; switch ( ex_no ) {  case DB_VECTOR :  dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ; if ( ! ( vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) ) { vcpu -> arch . dr6 &= ~ 15 ; vcpu -> arch . dr6 |= dr6 | DR6_RTM ; if ( ! ( dr6 & ~ DR6_RESERVED ) ) skip_emulated_instruction ( vcpu ) ; kvm_queue_exception ( vcpu , DB_VECTOR ) ; return 1 ; } kvm_run -> debug . arch . dr6 = dr6 | DR6_FIXED_1 ; kvm_run -> debug . arch . dr7 = vmcs_readl ( GUEST_DR7 ) ; case BP_VECTOR : vmx -> vcpu . arch . event_exit_inst_len = vmcs_read32 ( VM_EXIT_INSTRUCTION_LEN ) ; kvm_run -> exit_reason = KVM_EXIT_DEBUG ; rip = kvm_rip_read ( vcpu ) ; kvm_run -> debug . arch . pc = vmcs_readl ( GUEST_CS_BASE ) + rip ; kvm_run -> debug . arch . exception = ex_no ; break ; default : kvm_run -> exit_reason = KVM_EXIT_EXCEPTION ; kvm_run -> ex . exception = ex_no ; kvm_run -> ex . error_code = error_code ; break ; } return 0 ; }","case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ;return 1 ;case DB_VECTOR : dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ;",1287
108,"buggy line: default :  return ""Unknown<S2SV_blank>error<S2SV_blank>code"" ;cwe id:CWE-400context: const char * nghttp2_strerror ( int error_code ) { switch ( error_code ) { case 0 : return ""Success"" ; case NGHTTP2_ERR_INVALID_ARGUMENT : return ""Invalid<S2SV_blank>argument"" ; case NGHTTP2_ERR_BUFFER_ERROR : return ""Out<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>space"" ; case NGHTTP2_ERR_UNSUPPORTED_VERSION : return ""Unsupported<S2SV_blank>SPDY<S2SV_blank>version"" ; case NGHTTP2_ERR_WOULDBLOCK : return ""Operation<S2SV_blank>would<S2SV_blank>block"" ; case NGHTTP2_ERR_PROTO : return ""Protocol<S2SV_blank>error"" ; case NGHTTP2_ERR_INVALID_FRAME : return ""Invalid<S2SV_blank>frame<S2SV_blank>octets"" ; case NGHTTP2_ERR_EOF : return ""EOF"" ; case NGHTTP2_ERR_DEFERRED : return ""Data<S2SV_blank>transfer<S2SV_blank>deferred"" ; case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE : return ""No<S2SV_blank>more<S2SV_blank>Stream<S2SV_blank>ID<S2SV_blank>available"" ; case NGHTTP2_ERR_STREAM_CLOSED : return ""Stream<S2SV_blank>was<S2SV_blank>already<S2SV_blank>closed<S2SV_blank>or<S2SV_blank>invalid"" ; case NGHTTP2_ERR_STREAM_CLOSING : return ""Stream<S2SV_blank>is<S2SV_blank>closing"" ; case NGHTTP2_ERR_STREAM_SHUT_WR : return ""The<S2SV_blank>transmission<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>this<S2SV_blank>stream"" ; case NGHTTP2_ERR_INVALID_STREAM_ID : return ""Stream<S2SV_blank>ID<S2SV_blank>is<S2SV_blank>invalid"" ; case NGHTTP2_ERR_INVALID_STREAM_STATE : return ""Invalid<S2SV_blank>stream<S2SV_blank>state"" ; case NGHTTP2_ERR_DEFERRED_DATA_EXIST : return ""Another<S2SV_blank>DATA<S2SV_blank>frame<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>deferred"" ; case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED : return ""request<S2SV_blank>HEADERS<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed"" ; case NGHTTP2_ERR_GOAWAY_ALREADY_SENT : return ""GOAWAY<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>sent"" ; case NGHTTP2_ERR_INVALID_HEADER_BLOCK : return ""Invalid<S2SV_blank>header<S2SV_blank>block"" ; case NGHTTP2_ERR_INVALID_STATE : return ""Invalid<S2SV_blank>state"" ; case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE : return ""The<S2SV_blank>user<S2SV_blank>callback<S2SV_blank>function<S2SV_blank>failed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>the<S2SV_blank>temporal<S2SV_blank>error"" ; case NGHTTP2_ERR_FRAME_SIZE_ERROR : return ""The<S2SV_blank>length<S2SV_blank>of<S2SV_blank>the<S2SV_blank>frame<S2SV_blank>is<S2SV_blank>invalid"" ; case NGHTTP2_ERR_HEADER_COMP : return ""Header<S2SV_blank>compression/decompression<S2SV_blank>error"" ; case NGHTTP2_ERR_FLOW_CONTROL : return ""Flow<S2SV_blank>control<S2SV_blank>error"" ; case NGHTTP2_ERR_INSUFF_BUFSIZE : return ""Insufficient<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>given<S2SV_blank>to<S2SV_blank>function"" ; case NGHTTP2_ERR_PAUSE : return ""Callback<S2SV_blank>was<S2SV_blank>paused<S2SV_blank>by<S2SV_blank>the<S2SV_blank>application"" ; case NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS : return ""Too<S2SV_blank>many<S2SV_blank>inflight<S2SV_blank>SETTINGS"" ; case NGHTTP2_ERR_PUSH_DISABLED : return ""Server<S2SV_blank>push<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>peer"" ; case NGHTTP2_ERR_DATA_EXIST : return ""DATA<S2SV_blank>or<S2SV_blank>HEADERS<S2SV_blank>frame<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>submitted<S2SV_blank>for<S2SV_blank>the<S2SV_blank>stream"" ; case NGHTTP2_ERR_SESSION_CLOSING : return ""The<S2SV_blank>current<S2SV_blank>session<S2SV_blank>is<S2SV_blank>closing"" ; case NGHTTP2_ERR_HTTP_HEADER : return ""Invalid<S2SV_blank>HTTP<S2SV_blank>header<S2SV_blank>field<S2SV_blank>was<S2SV_blank>received"" ; case NGHTTP2_ERR_HTTP_MESSAGING : return ""Violation<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>messaging<S2SV_blank>rule"" ; case NGHTTP2_ERR_REFUSED_STREAM : return ""Stream<S2SV_blank>was<S2SV_blank>refused"" ; case NGHTTP2_ERR_INTERNAL : return ""Internal<S2SV_blank>error"" ; case NGHTTP2_ERR_CANCEL : return ""Cancel"" ; case NGHTTP2_ERR_SETTINGS_EXPECTED : return ""When<S2SV_blank>a<S2SV_blank>local<S2SV_blank>endpoint<S2SV_blank>expects<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>SETTINGS<S2SV_blank>frame,<S2SV_blank>it<S2SV_blank>"" ""receives<S2SV_blank>an<S2SV_blank>other<S2SV_blank>type<S2SV_blank>of<S2SV_blank>frame"" ; case NGHTTP2_ERR_NOMEM : return ""Out<S2SV_blank>of<S2SV_blank>memory"" ; case NGHTTP2_ERR_CALLBACK_FAILURE : return ""The<S2SV_blank>user<S2SV_blank>callback<S2SV_blank>function<S2SV_blank>failed"" ; case NGHTTP2_ERR_BAD_CLIENT_MAGIC : return ""Received<S2SV_blank>bad<S2SV_blank>client<S2SV_blank>magic<S2SV_blank>byte<S2SV_blank>string"" ; case NGHTTP2_ERR_FLOODED : return ""Flooding<S2SV_blank>was<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>this<S2SV_blank>HTTP/2<S2SV_blank>session,<S2SV_blank>and<S2SV_blank>it<S2SV_blank>must<S2SV_blank>be<S2SV_blank>"" ""closed"" ;  default :  return ""Unknown<S2SV_blank>error<S2SV_blank>code"" ; } }","case NGHTTP2_ERR_TOO_MANY_SETTINGS : return ""SETTINGS<S2SV_blank>frame<S2SV_blank>contained<S2SV_blank>more<S2SV_blank>than<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>entries"" ;default : return ""Unknown<S2SV_blank>error<S2SV_blank>code"" ;",1288
109,"buggy line: Stream_Read_UINT16 ( s , eventId ) ;Stream_Read_UINT32 ( s , pduLength ) ;cwe id:CWE-125context: static UINT rdpei_recv_pdu ( RDPEI_CHANNEL_CALLBACK * callback , wStream * s ) { UINT16 eventId ; UINT32 pduLength ; UINT error ;  Stream_Read_UINT16 ( s , eventId ) ;  Stream_Read_UINT32 ( s , pduLength ) ; # ifdef WITH_DEBUG_RDPEI WLog_DBG ( TAG , ""rdpei_recv_pdu:<S2SV_blank>eventId:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>(%s)<S2SV_blank>length:<S2SV_blank>%"" PRIu32 """" , eventId , rdpei_eventid_string ( eventId ) , pduLength ) ; # endif switch ( eventId ) { case EVENTID_SC_READY : if ( ( error = rdpei_recv_sc_ready_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_sc_ready_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } if ( ( error = rdpei_send_cs_ready_pdu ( callback ) ) ) { WLog_ERR ( TAG , ""rdpei_send_cs_ready_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; case EVENTID_SUSPEND_TOUCH : if ( ( error = rdpei_recv_suspend_touch_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_suspend_touch_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; case EVENTID_RESUME_TOUCH : if ( ( error = rdpei_recv_resume_touch_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_resume_touch_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; default : break ; } return CHANNEL_RC_OK ; }","if ( Stream_GetRemainingLength ( s ) < 6 ) return ERROR_INVALID_DATA ;Stream_Read_UINT16 ( s , eventId ) ;Stream_Read_UINT32 ( s , pduLength ) ;",1289
110,"buggy line: if ( pData -> identity ) zsocket_set_identity ( pData -> socket , ( char * ) pData -> identity ) ;if ( pData -> sndBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> sndBuf ) ;cwe id:CWE-134context: static rsRetVal initZMQ ( instanceData * pData ) { DEFiRet ; if ( NULL == s_context ) { zsys_handler_set ( NULL ) ; s_context = zctx_new ( ) ; if ( s_workerThreads > 0 ) zctx_set_iothreads ( s_context , s_workerThreads ) ; } pData -> socket = zsocket_new ( s_context , pData -> type ) ; if ( NULL == pData -> socket ) { errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>zsocket_new<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } if ( pData -> identity ) zsocket_set_identity ( pData -> socket , ( char * ) pData -> identity ) ; if ( pData -> sndBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> sndBuf ) ; if ( pData -> rcvBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> rcvBuf ) ; if ( pData -> linger > - 1 ) zsocket_set_linger ( pData -> socket , pData -> linger ) ; if ( pData -> backlog > - 1 ) zsocket_set_backlog ( pData -> socket , pData -> backlog ) ; if ( pData -> sndTimeout > - 1 ) zsocket_set_sndtimeo ( pData -> socket , pData -> sndTimeout ) ; if ( pData -> rcvTimeout > - 1 ) zsocket_set_rcvtimeo ( pData -> socket , pData -> rcvTimeout ) ; if ( pData -> maxMsgSize > - 1 ) zsocket_set_maxmsgsize ( pData -> socket , pData -> maxMsgSize ) ; if ( pData -> rate > - 1 ) zsocket_set_rate ( pData -> socket , pData -> rate ) ; if ( pData -> recoveryIVL > - 1 ) zsocket_set_recovery_ivl ( pData -> socket , pData -> recoveryIVL ) ; if ( pData -> multicastHops > - 1 ) zsocket_set_multicast_hops ( pData -> socket , pData -> multicastHops ) ; if ( pData -> reconnectIVL > - 1 ) zsocket_set_reconnect_ivl ( pData -> socket , pData -> reconnectIVL ) ; if ( pData -> reconnectIVLMax > - 1 ) zsocket_set_reconnect_ivl_max ( pData -> socket , pData -> reconnectIVLMax ) ; if ( pData -> ipv4Only > - 1 ) zsocket_set_ipv4only ( pData -> socket , pData -> ipv4Only ) ; if ( pData -> affinity != 1 ) zsocket_set_affinity ( pData -> socket , pData -> affinity ) ; if ( pData -> rcvHWM > - 1 ) zsocket_set_rcvhwm ( pData -> socket , pData -> rcvHWM ) ; if ( pData -> sndHWM > - 1 ) zsocket_set_sndhwm ( pData -> socket , pData -> sndHWM ) ; if ( pData -> action == ACTION_BIND ) {  if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) {  errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>bind<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } DBGPRINTF ( ""omzmq3:<S2SV_blank>bind<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>successful\\n"" , pData -> description ) ; } else {  if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) {  errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>connect<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } DBGPRINTF ( ""omzmq3:<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>successful"" , pData -> description ) ; } finalize_it : RETiRet ; }","if ( pData -> identity ) zsocket_set_identity ( pData -> socket , ""%s"" , ( char * ) pData -> identity ) ;if ( pData -> sndBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , ""%s"" , pData -> sndBuf ) ;",1290
111,"buggy line: if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) {errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>bind<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ;if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) {errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>connect<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ;cwe id:CWE-134context: static rsRetVal initZMQ ( instanceData * pData ) { DEFiRet ; if ( NULL == s_context ) { zsys_handler_set ( NULL ) ; s_context = zctx_new ( ) ; if ( s_workerThreads > 0 ) zctx_set_iothreads ( s_context , s_workerThreads ) ; } pData -> socket = zsocket_new ( s_context , pData -> type ) ; if ( NULL == pData -> socket ) { errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>zsocket_new<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } if ( pData -> identity ) zsocket_set_identity ( pData -> socket , ( char * ) pData -> identity ) ; if ( pData -> sndBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> sndBuf ) ; if ( pData -> rcvBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> rcvBuf ) ; if ( pData -> linger > - 1 ) zsocket_set_linger ( pData -> socket , pData -> linger ) ; if ( pData -> backlog > - 1 ) zsocket_set_backlog ( pData -> socket , pData -> backlog ) ; if ( pData -> sndTimeout > - 1 ) zsocket_set_sndtimeo ( pData -> socket , pData -> sndTimeout ) ; if ( pData -> rcvTimeout > - 1 ) zsocket_set_rcvtimeo ( pData -> socket , pData -> rcvTimeout ) ; if ( pData -> maxMsgSize > - 1 ) zsocket_set_maxmsgsize ( pData -> socket , pData -> maxMsgSize ) ; if ( pData -> rate > - 1 ) zsocket_set_rate ( pData -> socket , pData -> rate ) ; if ( pData -> recoveryIVL > - 1 ) zsocket_set_recovery_ivl ( pData -> socket , pData -> recoveryIVL ) ; if ( pData -> multicastHops > - 1 ) zsocket_set_multicast_hops ( pData -> socket , pData -> multicastHops ) ; if ( pData -> reconnectIVL > - 1 ) zsocket_set_reconnect_ivl ( pData -> socket , pData -> reconnectIVL ) ; if ( pData -> reconnectIVLMax > - 1 ) zsocket_set_reconnect_ivl_max ( pData -> socket , pData -> reconnectIVLMax ) ; if ( pData -> ipv4Only > - 1 ) zsocket_set_ipv4only ( pData -> socket , pData -> ipv4Only ) ; if ( pData -> affinity != 1 ) zsocket_set_affinity ( pData -> socket , pData -> affinity ) ; if ( pData -> rcvHWM > - 1 ) zsocket_set_rcvhwm ( pData -> socket , pData -> rcvHWM ) ; if ( pData -> sndHWM > - 1 ) zsocket_set_sndhwm ( pData -> socket , pData -> sndHWM ) ; if ( pData -> action == ACTION_BIND ) {  if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) {  errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>bind<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } DBGPRINTF ( ""omzmq3:<S2SV_blank>bind<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>successful\\n"" , pData -> description ) ; } else {  if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) {  errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>connect<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } DBGPRINTF ( ""omzmq3:<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>successful"" , pData -> description ) ; } finalize_it : RETiRet ; }","if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) {errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>bind<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ;if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) {errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>connect<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ;",1290
112,"buggy line: if ( chg < 0 )  return chg ;if ( hugepage_subpool_get_pages ( spool , chg ) )  return - ENOSPC ;ret = hugetlb_acct_memory ( h , chg ) ;if ( ret < 0 ) {hugepage_subpool_put_pages ( spool , chg ) ;return ret ;}}cwe id:CWE-399context: int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; if ( vm_flags & VM_NORESERVE ) return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 )  return chg ;  if ( hugepage_subpool_get_pages ( spool , chg ) )  return - ENOSPC ;   ret = hugetlb_acct_memory ( h , chg ) ;  if ( ret < 0 ) { hugepage_subpool_put_pages ( spool , chg ) ;  return ret ;  } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ;  } ","if ( chg < 0 ) {ret = chg ;goto out_err ;}if ( hugepage_subpool_get_pages ( spool , chg ) ) {ret = - ENOSPC ;goto out_err ;}ret = hugetlb_acct_memory ( h , chg ) ;goto out_err ;}out_err : resv_map_put ( vma ) ;return ret ;}",1291
113,"buggy line: struct flowi6 fl6 ;memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;fl6 . flowi6_proto = sk -> sk_protocol ;fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ;fl6 . saddr = transport -> saddr . v6 . sin6_addr ;fl6 . flowlabel = np -> flow_label ;IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ;if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ;else fl6 . flowi6_oif = sk -> sk_bound_dev_if ;if ( np -> opt && np -> opt -> srcrt ) {struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ;fl6 . daddr = * rt0 -> addr ;pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\\SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ;return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;}cwe id:CWE-310context: static int sctp_v6_xmit ( struct sk_buff * skb , struct sctp_transport * transport ) { struct sock * sk = skb -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ;  struct flowi6 fl6 ;  memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ; fl6 . saddr = transport -> saddr . v6 . sin6_addr ; fl6 . flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ; if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ; else fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( np -> opt && np -> opt -> srcrt ) { struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ; fl6 . daddr = * rt0 -> addr ; } pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\n"" , __func__ , skb ,  skb -> len , & fl6 . saddr , & fl6 . daddr ) ;   SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;  if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ;  return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;  }","struct flowi6 * fl6 = & transport -> fl . u . ip6 ;pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\\SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ;SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;",1292
114,"buggy line: inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ;rc = PTR_ERR ( inode ) ;cwe id:CWE-264context: static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = ""Getting<S2SV_blank>sb<S2SV_blank>failed"" ; struct inode * inode ; struct path path ; uid_t check_ruid ; int rc ; sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid ) ; if ( rc ) { err = ""Error<S2SV_blank>parsing<S2SV_blank>options"" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , flags , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } rc = bdi_setup_and_register ( & sbi -> bdi , ""ecryptfs"" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = ""Reading<S2SV_blank>sb<S2SV_blank>failed"" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , ""kern_path()<S2SV_blank>failed\\n"" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR ""Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>"" ""eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>"" ""known<S2SV_blank>incompatibilities\\n"" ) ; goto out_free ; } if ( check_ruid && ! uid_eq ( path . dentry -> d_inode -> i_uid , current_uid ( ) ) ) { rc = - EPERM ; printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n"" , i_uid_read ( path . dentry -> d_inode ) , from_kuid ( & init_user_ns , current_uid ( ) ) ) ; goto out_free ; } ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; s -> s_flags = flags & ~ MS_POSIXACL ; s -> s_flags |= path . dentry -> d_sb -> s_flags & ( MS_RDONLY | MS_POSIXACL ) ; s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ; s -> s_blocksize = path . dentry -> d_sb -> s_blocksize ; s -> s_magic = ECRYPTFS_SUPER_MAGIC ;  inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ;  rc = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto out_free ; s -> s_root = d_make_root ( inode ) ; if ( ! s -> s_root ) { rc = - ENOMEM ; goto out_free ; } rc = - ENOMEM ; root_info = kmem_cache_zalloc ( ecryptfs_dentry_info_cache , GFP_KERNEL ) ; if ( ! root_info ) goto out_free ; ecryptfs_set_dentry_private ( s -> s_root , root_info ) ; root_info -> lower_path = path ; s -> s_flags |= MS_ACTIVE ; return dget ( s -> s_root ) ; out_free : path_put ( & path ) ; out1 : deactivate_locked_super ( s ) ; out : if ( sbi ) { ecryptfs_destroy_mount_crypt_stat ( & sbi -> mount_crypt_stat ) ; kmem_cache_free ( ecryptfs_sb_info_cache , sbi ) ; } printk ( KERN_ERR ""%s;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , err , rc ) ; return ERR_PTR ( rc ) ; }","s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ;rc = - EINVAL ;if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) {pr_err ( ""eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\\goto out_free ;}inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ;rc = PTR_ERR ( inode ) ;",1293
115,"buggy line: perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;switch ( rd ) {cwe id:CWE-399context: static int simulate_rdhwr ( struct pt_regs * regs , unsigned int opcode ) { struct thread_info * ti = task_thread_info ( current ) ; if ( ( opcode & OPCODE ) == SPEC3 && ( opcode & FUNC ) == RDHWR ) { int rd = ( opcode & RD ) >> 11 ; int rt = ( opcode & RT ) >> 16 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;  switch ( rd ) { case 0 : regs -> regs [ rt ] = smp_processor_id ( ) ; return 0 ; case 1 : regs -> regs [ rt ] = min ( current_cpu_data . dcache . linesz , current_cpu_data . icache . linesz ) ; return 0 ; case 2 : regs -> regs [ rt ] = read_c0_count ( ) ; return 0 ; case 3 : switch ( current_cpu_data . cputype ) { case CPU_20KC : case CPU_25KF : regs -> regs [ rt ] = 1 ; break ; default : regs -> regs [ rt ] = 2 ; } return 0 ; case 29 : regs -> regs [ rt ] = ti -> tp_value ; return 0 ; default : return - 1 ; } } return - 1 ; }","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;switch ( rd ) {",1294
116,"buggy line: cwe id:CWE-20context: static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ;  break ;  default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }","if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",1295
117,"buggy line: break ;default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ;cwe id:CWE-20context: static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ;  break ;  default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }","break ;default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ;",1295
118,"buggy line: void nego_process_negotiation_failure ( rdpNego * nego , wStream * s )  {WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ;Stream_Read_UINT8 ( s , flags ) ;cwe id:CWE-125context:  void nego_process_negotiation_failure ( rdpNego * nego , wStream * s )  { BYTE flags ; UINT16 length ; UINT32 failureCode ;  WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ;  Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , failureCode ) ; switch ( failureCode ) { case SSL_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_REQUIRED_BY_SERVER"" ) ; break ; case SSL_NOT_ALLOWED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_NOT_ALLOWED_BY_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case SSL_CERT_NOT_ON_SERVER : WLog_ERR ( TAG , ""Error:<S2SV_blank>SSL_CERT_NOT_ON_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case INCONSISTENT_FLAGS : WLog_ERR ( TAG , ""Error:<S2SV_blank>INCONSISTENT_FLAGS"" ) ; break ; case HYBRID_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>HYBRID_REQUIRED_BY_SERVER"" ) ; break ; default : WLog_ERR ( TAG , ""Error:<S2SV_blank>Unknown<S2SV_blank>protocol<S2SV_blank>security<S2SV_blank>error<S2SV_blank>%"" PRIu32 """" , failureCode ) ; break ; } nego -> state = NEGO_STATE_FAIL ;  } ","BOOL nego_process_negotiation_failure ( rdpNego * nego , wStream * s ) {WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ;if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE ;Stream_Read_UINT8 ( s , flags ) ;",1296
119,"buggy line: }cwe id:CWE-125context:  void nego_process_negotiation_failure ( rdpNego * nego , wStream * s )  { BYTE flags ; UINT16 length ; UINT32 failureCode ;  WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ;  Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , failureCode ) ; switch ( failureCode ) { case SSL_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_REQUIRED_BY_SERVER"" ) ; break ; case SSL_NOT_ALLOWED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_NOT_ALLOWED_BY_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case SSL_CERT_NOT_ON_SERVER : WLog_ERR ( TAG , ""Error:<S2SV_blank>SSL_CERT_NOT_ON_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case INCONSISTENT_FLAGS : WLog_ERR ( TAG , ""Error:<S2SV_blank>INCONSISTENT_FLAGS"" ) ; break ; case HYBRID_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>HYBRID_REQUIRED_BY_SERVER"" ) ; break ; default : WLog_ERR ( TAG , ""Error:<S2SV_blank>Unknown<S2SV_blank>protocol<S2SV_blank>security<S2SV_blank>error<S2SV_blank>%"" PRIu32 """" , failureCode ) ; break ; } nego -> state = NEGO_STATE_FAIL ;  } ",return TRUE ;},1296
120,"buggy line: int ret , last_pwd ;krb5_boolean have_pol = FALSE ;cwe id:CWE-255context: kadm5_ret_t kadm5_randkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * * keyblocks , int * n_keys ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; krb5_int32 now ; kadm5_policy_ent_rec pol ;  int ret , last_pwd ;  krb5_boolean have_pol = FALSE ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; if ( keyblocks ) * keyblocks = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; if ( principal == NULL ) return EINVAL ; if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ; ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto done ; if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) { if ( keepold ) return KADM5_PROTECT_PRINCIPAL ; new_n_ks_tuple = 1 ; } ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto done ; ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ; if ( ret ) goto done ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto done ; kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ; ret = krb5_timeofday ( handle -> context , & now ) ; if ( ret ) goto done ; if ( ( adb . aux_attributes & KADM5_POLICY ) ) { ret = get_policy ( handle , adb . policy , & pol , & have_pol ) ; if ( ret ) goto done ; } if ( have_pol ) { ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & last_pwd ) ; if ( ret ) goto done ; # if 0 if ( ( now - last_pwd ) < pol . pw_min_life && ! ( kdb -> attributes & KRB5_KDB_REQUIRES_PWCHANGE ) ) { ret = KADM5_PASS_TOOSOON ; goto done ; } # endif if ( pol . pw_max_life ) kdb -> pw_expiration = now + pol . pw_max_life ; else kdb -> pw_expiration = 0 ; } else { kdb -> pw_expiration = 0 ; } ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ; if ( ret ) goto done ; kdb -> fail_auth_count = 0 ; if ( keyblocks ) {  ret = decrypt_key_data ( handle -> context ,   kdb -> n_key_data , kdb -> key_data ,  keyblocks , n_keys ) ; if ( ret ) goto done ; } kdb -> mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT ; ; ret = k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ; if ( ret ) goto done ; if ( ( ret = kdb_put_entry ( handle , kdb , & adb ) ) ) goto done ; ( void ) k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ; ret = KADM5_OK ; done : free ( new_ks_tuple ) ; kdb_free_entry ( handle , kdb , & adb ) ; if ( have_pol ) kadm5_free_policy_ent ( handle -> lhandle , & pol ) ; return ret ; }","int ret , last_pwd , n_new_keys ;krb5_boolean have_pol = FALSE ;",1297
121,"buggy line: if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) {if ( keepold ) return KADM5_PROTECT_PRINCIPAL ;new_n_ks_tuple = 1 ;}ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ;if ( ret ) goto done ;ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ;if ( ret ) goto done ;ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ;if ( ret ) goto done ;kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ;ret = krb5_timeofday ( handle -> context , & now ) ;if ( ret ) goto done ;if ( ( adb . aux_attributes & KADM5_POLICY ) ) {ret = get_policy ( handle , adb . policy , & pol , & have_pol ) ;if ( ret ) goto done ;}if ( have_pol ) {ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & last_pwd ) ;if ( ret ) goto done ;# if 0 if ( ( now - last_pwd ) < pol . pw_min_life && ! ( kdb -> attributes & KRB5_KDB_REQUIRES_PWCHANGE ) ) {ret = KADM5_PASS_TOOSOON ;goto done ;}# endif if ( pol . pw_max_life ) kdb -> pw_expiration = now + pol . pw_max_life ;else kdb -> pw_expiration = 0 ;}else {kdb -> pw_expiration = 0 ;}ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ;if ( ret ) goto done ;kdb -> fail_auth_count = 0 ;if ( keyblocks ) {ret = decrypt_key_data ( handle -> context ,   kdb -> n_key_data , kdb -> key_data ,  keyblocks , n_keys ) ;cwe id:CWE-255context: kadm5_ret_t kadm5_randkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * * keyblocks , int * n_keys ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; krb5_int32 now ; kadm5_policy_ent_rec pol ;  int ret , last_pwd ;  krb5_boolean have_pol = FALSE ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; if ( keyblocks ) * keyblocks = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; if ( principal == NULL ) return EINVAL ; if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ; ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto done ; if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) { if ( keepold ) return KADM5_PROTECT_PRINCIPAL ; new_n_ks_tuple = 1 ; } ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto done ; ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ; if ( ret ) goto done ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto done ; kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ; ret = krb5_timeofday ( handle -> context , & now ) ; if ( ret ) goto done ; if ( ( adb . aux_attributes & KADM5_POLICY ) ) { ret = get_policy ( handle , adb . policy , & pol , & have_pol ) ; if ( ret ) goto done ; } if ( have_pol ) { ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & last_pwd ) ; if ( ret ) goto done ; # if 0 if ( ( now - last_pwd ) < pol . pw_min_life && ! ( kdb -> attributes & KRB5_KDB_REQUIRES_PWCHANGE ) ) { ret = KADM5_PASS_TOOSOON ; goto done ; } # endif if ( pol . pw_max_life ) kdb -> pw_expiration = now + pol . pw_max_life ; else kdb -> pw_expiration = 0 ; } else { kdb -> pw_expiration = 0 ; } ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ; if ( ret ) goto done ; kdb -> fail_auth_count = 0 ; if ( keyblocks ) {  ret = decrypt_key_data ( handle -> context ,   kdb -> n_key_data , kdb -> key_data ,  keyblocks , n_keys ) ; if ( ret ) goto done ; } kdb -> mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT ; ; ret = k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ; if ( ret ) goto done ; if ( ( ret = kdb_put_entry ( handle , kdb , & adb ) ) ) goto done ; ( void ) k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ; ret = KADM5_OK ; done : free ( new_ks_tuple ) ; kdb_free_entry ( handle , kdb , & adb ) ; if ( have_pol ) kadm5_free_policy_ent ( handle -> lhandle , & pol ) ; return ret ; }","if ( krb5_principal_compare ( handle -> context , n_new_keys , kdb -> key_data ) ;ret = decrypt_key_data ( handle -> context , kdb -> n_key_data , kdb -> key_data , keyblocks , n_keys ) ;",1297
122,"buggy line: int len , result = RLC_OK ;bn_t t ;cwe id:CWE-120context: static int pad_pkcs1 ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t * id , pad = 0 ;  int len , result = RLC_OK ;  bn_t t ; bn_null ( t ) ; RLC_TRY { bn_new ( t ) ; switch ( operation ) { case RSA_ENC : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PUB ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; do { rand_bytes ( & pad , 1 ) ; } while ( pad == 0 ) ; bn_add_dig ( m , m , pad ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ;  break ;  case RSA_DEC : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ;  if ( ! bn_is_zero ( t ) ) {   result = RLC_ERR ;  } * p_len = m_len ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  if ( pad != RSA_PUB ) {   result = RLC_ERR ;  } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; * p_len -= ( m_len - 1 ) ; bn_mod_2b ( m , m , ( k_len - * p_len ) * 8 ) ;  break ;  case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len - len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , 8 * len ) ; bn_read_bin ( t , id , len ) ; bn_add ( m , m , t ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_VER : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( ! bn_is_zero ( t ) ) { result = RLC_ERR ; } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad != RSA_PRV ) { result = RLC_ERR ; } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; if ( m_len == 0 ) { result = RLC_ERR ; } id = hash_id ( MD_MAP , & len ) ; m_len -= len ; bn_rsh ( t , m , m_len * 8 ) ; int r = 0 ; for ( int i = 0 ; i < len ; i ++ ) { pad = ( uint8_t ) t -> dp [ 0 ] ; r |= pad - id [ len - i - 1 ] ; bn_rsh ( t , t , 8 ) ; } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; result = ( r == 0 ? RLC_OK : RLC_ERR ) ;  break ;  case RSA_VER_HASH : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ;  if ( ! bn_is_zero ( t ) ) {   result = RLC_ERR ;  } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  if ( pad != RSA_PRV ) {   result = RLC_ERR ;  } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  } while ( pad != 0 && m_len > 0 ) ;   if ( m_len == 0 ) {   result = RLC_ERR ;  } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; break ; } } RLC_CATCH_ANY { result = RLC_ERR ; } RLC_FINALLY { bn_free ( t ) ; } return result ; }","int len , result = RLC_ERR ;bn_t t ;result = RLC_OK ;",1298
123,"buggy line: break ;case RSA_DEC : m_len = k_len - 1 ;if ( ! bn_is_zero ( t ) ) {result = RLC_ERR ;}if ( pad != RSA_PUB ) {result = RLC_ERR ;}cwe id:CWE-120context: static int pad_pkcs1 ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t * id , pad = 0 ;  int len , result = RLC_OK ;  bn_t t ; bn_null ( t ) ; RLC_TRY { bn_new ( t ) ; switch ( operation ) { case RSA_ENC : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PUB ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; do { rand_bytes ( & pad , 1 ) ; } while ( pad == 0 ) ; bn_add_dig ( m , m , pad ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ;  break ;  case RSA_DEC : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ;  if ( ! bn_is_zero ( t ) ) {   result = RLC_ERR ;  } * p_len = m_len ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  if ( pad != RSA_PUB ) {   result = RLC_ERR ;  } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; * p_len -= ( m_len - 1 ) ; bn_mod_2b ( m , m , ( k_len - * p_len ) * 8 ) ;  break ;  case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len - len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , 8 * len ) ; bn_read_bin ( t , id , len ) ; bn_add ( m , m , t ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_VER : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( ! bn_is_zero ( t ) ) { result = RLC_ERR ; } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad != RSA_PRV ) { result = RLC_ERR ; } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; if ( m_len == 0 ) { result = RLC_ERR ; } id = hash_id ( MD_MAP , & len ) ; m_len -= len ; bn_rsh ( t , m , m_len * 8 ) ; int r = 0 ; for ( int i = 0 ; i < len ; i ++ ) { pad = ( uint8_t ) t -> dp [ 0 ] ; r |= pad - id [ len - i - 1 ] ; bn_rsh ( t , t , 8 ) ; } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; result = ( r == 0 ? RLC_OK : RLC_ERR ) ;  break ;  case RSA_VER_HASH : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ;  if ( ! bn_is_zero ( t ) ) {   result = RLC_ERR ;  } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  if ( pad != RSA_PRV ) {   result = RLC_ERR ;  } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  } while ( pad != 0 && m_len > 0 ) ;   if ( m_len == 0 ) {   result = RLC_ERR ;  } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; break ; } } RLC_CATCH_ANY { result = RLC_ERR ; } RLC_FINALLY { bn_free ( t ) ; } return result ; }",break ;case RSA_DEC : m_len = k_len - 1 ;if ( bn_is_zero ( t ) ) {result = RLC_ERR ;}if ( pad != RSA_PUB ) {result = RLC_ERR ;},1298
124,"buggy line: break ;case RSA_SIG : id = hash_id ( MD_MAP , & len ) ;cwe id:CWE-120context: static int pad_pkcs1 ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t * id , pad = 0 ;  int len , result = RLC_OK ;  bn_t t ; bn_null ( t ) ; RLC_TRY { bn_new ( t ) ; switch ( operation ) { case RSA_ENC : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PUB ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; do { rand_bytes ( & pad , 1 ) ; } while ( pad == 0 ) ; bn_add_dig ( m , m , pad ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ;  break ;  case RSA_DEC : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ;  if ( ! bn_is_zero ( t ) ) {   result = RLC_ERR ;  } * p_len = m_len ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  if ( pad != RSA_PUB ) {   result = RLC_ERR ;  } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; * p_len -= ( m_len - 1 ) ; bn_mod_2b ( m , m , ( k_len - * p_len ) * 8 ) ;  break ;  case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len - len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , 8 * len ) ; bn_read_bin ( t , id , len ) ; bn_add ( m , m , t ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_VER : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( ! bn_is_zero ( t ) ) { result = RLC_ERR ; } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad != RSA_PRV ) { result = RLC_ERR ; } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; if ( m_len == 0 ) { result = RLC_ERR ; } id = hash_id ( MD_MAP , & len ) ; m_len -= len ; bn_rsh ( t , m , m_len * 8 ) ; int r = 0 ; for ( int i = 0 ; i < len ; i ++ ) { pad = ( uint8_t ) t -> dp [ 0 ] ; r |= pad - id [ len - i - 1 ] ; bn_rsh ( t , t , 8 ) ; } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; result = ( r == 0 ? RLC_OK : RLC_ERR ) ;  break ;  case RSA_VER_HASH : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ;  if ( ! bn_is_zero ( t ) ) {   result = RLC_ERR ;  } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  if ( pad != RSA_PRV ) {   result = RLC_ERR ;  } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  } while ( pad != 0 && m_len > 0 ) ;   if ( m_len == 0 ) {   result = RLC_ERR ;  } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; break ; } } RLC_CATCH_ANY { result = RLC_ERR ; } RLC_FINALLY { bn_free ( t ) ; } return result ; }","break ;case RSA_SIG : id = hash_id ( MD_MAP , & len ) ;",1298
125,"buggy line: result = RLC_ERR ;if ( pad != RSA_PRV ) {result = RLC_ERR ;}while ( pad != 0 && m_len > 0 ) ;if ( m_len == 0 ) {result = RLC_ERR ;}cwe id:CWE-120context: static int pad_pkcs1 ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t * id , pad = 0 ;  int len , result = RLC_OK ;  bn_t t ; bn_null ( t ) ; RLC_TRY { bn_new ( t ) ; switch ( operation ) { case RSA_ENC : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PUB ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; do { rand_bytes ( & pad , 1 ) ; } while ( pad == 0 ) ; bn_add_dig ( m , m , pad ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ;  break ;  case RSA_DEC : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ;  if ( ! bn_is_zero ( t ) ) {   result = RLC_ERR ;  } * p_len = m_len ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  if ( pad != RSA_PUB ) {   result = RLC_ERR ;  } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; * p_len -= ( m_len - 1 ) ; bn_mod_2b ( m , m , ( k_len - * p_len ) * 8 ) ;  break ;  case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len - len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , 8 * len ) ; bn_read_bin ( t , id , len ) ; bn_add ( m , m , t ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_VER : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( ! bn_is_zero ( t ) ) { result = RLC_ERR ; } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad != RSA_PRV ) { result = RLC_ERR ; } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; if ( m_len == 0 ) { result = RLC_ERR ; } id = hash_id ( MD_MAP , & len ) ; m_len -= len ; bn_rsh ( t , m , m_len * 8 ) ; int r = 0 ; for ( int i = 0 ; i < len ; i ++ ) { pad = ( uint8_t ) t -> dp [ 0 ] ; r |= pad - id [ len - i - 1 ] ; bn_rsh ( t , t , 8 ) ; } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; result = ( r == 0 ? RLC_OK : RLC_ERR ) ;  break ;  case RSA_VER_HASH : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ;  if ( ! bn_is_zero ( t ) ) {   result = RLC_ERR ;  } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  if ( pad != RSA_PRV ) {   result = RLC_ERR ;  } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  } while ( pad != 0 && m_len > 0 ) ;   if ( m_len == 0 ) {   result = RLC_ERR ;  } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; break ; } } RLC_CATCH_ANY { result = RLC_ERR ; } RLC_FINALLY { bn_free ( t ) ; } return result ; }","* p_len = k_len - m_len ;bn_mod_2b ( m , m , m_len * 8 ) ;result = ( r == 0 ? RLC_OK : RLC_ERR ) ;}break ;case RSA_SIG : id = hash_id ( MD_MAP , & len ) ;bn_zero ( m ) ;bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , RSA_PRV ) ;* p_len = k_len - 3 - m_len - len ;for ( int i = 0 ;i < * p_len ;i ++ ) {bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , RSA_PAD ) ;}bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , 0 ) ;bn_lsh ( m , m , 8 * len ) ;bn_read_bin ( t , id , len ) ;bn_add ( m , m , t ) ;bn_lsh ( m , m , m_len * 8 ) ;result = RLC_OK ;break ;case RSA_SIG_HASH : bn_zero ( m ) ;bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , RSA_PRV ) ;* p_len = k_len - 3 - m_len ;for ( int i = 0 ;i < * p_len ;i ++ ) {bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , RSA_PAD ) ;}bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , 0 ) ;bn_lsh ( m , m , m_len * 8 ) ;result = RLC_OK ;break ;case RSA_VER : m_len = k_len - 1 ;bn_rsh ( t , m , 8 * m_len ) ;if ( bn_is_zero ( t ) ) {if ( pad == RSA_PRV ) {int counter = 0 ;counter ++ ;while ( pad == RSA_PAD && m_len > 0 ) ;",1298
126,"buggy line: r |= pad - id [ len - i - 1 ] ;result = ( r == 0 ? RLC_OK : RLC_ERR ) ;break ;case RSA_VER_HASH : m_len = k_len - 1 ;if ( ! bn_is_zero ( t ) ) {result = RLC_ERR ;}if ( pad != RSA_PRV ) {result = RLC_ERR ;}}while ( pad != 0 && m_len > 0 ) ;if ( m_len == 0 ) {result = RLC_ERR ;}cwe id:CWE-120context: static int pad_pkcs1 ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t * id , pad = 0 ;  int len , result = RLC_OK ;  bn_t t ; bn_null ( t ) ; RLC_TRY { bn_new ( t ) ; switch ( operation ) { case RSA_ENC : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PUB ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; do { rand_bytes ( & pad , 1 ) ; } while ( pad == 0 ) ; bn_add_dig ( m , m , pad ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ;  break ;  case RSA_DEC : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ;  if ( ! bn_is_zero ( t ) ) {   result = RLC_ERR ;  } * p_len = m_len ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  if ( pad != RSA_PUB ) {   result = RLC_ERR ;  } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; * p_len -= ( m_len - 1 ) ; bn_mod_2b ( m , m , ( k_len - * p_len ) * 8 ) ;  break ;  case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len - len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , 8 * len ) ; bn_read_bin ( t , id , len ) ; bn_add ( m , m , t ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_VER : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( ! bn_is_zero ( t ) ) { result = RLC_ERR ; } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad != RSA_PRV ) { result = RLC_ERR ; } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; if ( m_len == 0 ) { result = RLC_ERR ; } id = hash_id ( MD_MAP , & len ) ; m_len -= len ; bn_rsh ( t , m , m_len * 8 ) ; int r = 0 ; for ( int i = 0 ; i < len ; i ++ ) { pad = ( uint8_t ) t -> dp [ 0 ] ; r |= pad - id [ len - i - 1 ] ; bn_rsh ( t , t , 8 ) ; } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; result = ( r == 0 ? RLC_OK : RLC_ERR ) ;  break ;  case RSA_VER_HASH : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ;  if ( ! bn_is_zero ( t ) ) {   result = RLC_ERR ;  } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  if ( pad != RSA_PRV ) {   result = RLC_ERR ;  } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ;  } while ( pad != 0 && m_len > 0 ) ;   if ( m_len == 0 ) {   result = RLC_ERR ;  } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; break ; } } RLC_CATCH_ANY { result = RLC_ERR ; } RLC_FINALLY { bn_free ( t ) ; } return result ; }",r |= pad ^ id [ len - i - 1 ] ;if ( r && m_len > 0 && counter >= 8 ) {result = RLC_OK ;}}}break ;case RSA_VER_HASH : m_len = k_len - 1 ;if ( ! bn_is_zero ( t ) ) {result = RLC_ERR ;}if ( pad != RSA_PRV ) {int counter = 0 ;counter ++ ;}while ( pad == RSA_PAD && m_len > 0 ) ;if ( m_len > 0 && counter >= 8 ) {result = RLC_OK ;}}},1298
127,"buggy line: r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ;cwe id:CWE-125context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; char * identifier ; char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ; while ( ! stop ) { switch ( * ip ) { case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif break ; case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS ) { r1 . o = function -> return_obj ; push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length ,  r2 . re -> flags | RE_FLAGS_SCAN ,  NULL , NULL ) >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; } yr_modules_unload_all ( context ) ; yr_free ( stack ) ; return result ; }","r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . ss -> c_string , r2 . ss -> length ) != NULL ;",1299
128,"buggy line: r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length ,  r2 . re -> flags | RE_FLAGS_SCAN ,  NULL , NULL ) >= 0 ;cwe id:CWE-125context: int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; char * identifier ; char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ; while ( ! stop ) { switch ( * ip ) { case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif break ; case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS ) { r1 . o = function -> return_obj ; push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length ,  r2 . re -> flags | RE_FLAGS_SCAN ,  NULL , NULL ) >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; } yr_modules_unload_all ( context ) ; yr_free ( stack ) ; return result ; }","r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL ) >= 0 ;",1299
129,"buggy line: static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {cwe id:CWE-119context:  static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data && ! ctx -> yv12_frame_buffers . use_frame_threads ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; return vp8dx_get_reference ( ctx -> yv12_frame_buffers . pbi [ 0 ] , frame -> frame_type , & sd ) ; } else return VPX_CODEC_INVALID_PARAM ; }","static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",1300
130,"buggy line: rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ;if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ;cwe id:CWE-362context: static void bt_for_each ( struct blk_mq_hw_ctx * hctx , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) {  rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ;  if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }","rq = hctx -> tags , off + bit ) ;if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ;",1301
131,"buggy line: if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL )  {cwe id:CWE-119context: SNDFILE * sf_open ( const char * path , int mode , SF_INFO * sfinfo ) { SF_PRIVATE * psf ; assert ( sizeof ( sf_count_t ) == 8 ) ;  if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL )  { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files ( psf ) ; psf_log_printf ( psf , ""File<S2SV_blank>:<S2SV_blank>%s\\n"" , path ) ; if ( copy_filename ( psf , path ) != 0 ) { sf_errno = psf -> error ; return NULL ; } ; psf -> file . mode = mode ; if ( strcmp ( path , ""-"" ) == 0 ) psf -> error = psf_set_stdio ( psf ) ; else psf -> error = psf_fopen ( psf ) ; return psf_open_file ( psf , sfinfo ) ; }",if ( ( psf = psf_allocate ( ) ) == NULL ) {,1302
132,"buggy line: static void fix_interp_filter ( VP9_COMMON * cm ) {if ( cm -> interp_filter == SWITCHABLE ) {cwe id:CWE-119context:  static void fix_interp_filter ( VP9_COMMON * cm ) {  if ( cm -> interp_filter == SWITCHABLE ) { int count [ SWITCHABLE_FILTERS ] ; int i , j , c = 0 ; for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { count [ i ] = 0 ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j )  count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ;  c += ( count [ i ] > 0 ) ; } if ( c == 1 ) { for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { if ( count [ i ] ) { cm -> interp_filter = i ; break ; } } } } }","static void fix_interp_filter ( VP9_COMMON * cm , FRAME_COUNTS * counts ) {if ( cm -> interp_filter == SWITCHABLE ) {",1303
133,"buggy line: ++ j )  count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ;c += ( count [ i ] > 0 ) ;cwe id:CWE-119context:  static void fix_interp_filter ( VP9_COMMON * cm ) {  if ( cm -> interp_filter == SWITCHABLE ) { int count [ SWITCHABLE_FILTERS ] ; int i , j , c = 0 ; for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { count [ i ] = 0 ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j )  count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ;  c += ( count [ i ] > 0 ) ; } if ( c == 1 ) { for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { if ( count [ i ] ) { cm -> interp_filter = i ; break ; } } } } }",+ j )  count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ;++ j ) count [ i ] += counts -> switchable_interp [ j ] [ i ] ;c += ( count [ i ] > 0 ) ;,1303
134,"buggy line: token ++ ;}cwe id:CWE-787context: static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) {  token ++ ;  } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }","token ++ ;}if ( operand >= MAX_OPERANDS ) {eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\\return false ;}",1304
135,"buggy line: MACROBLOCK * const x = & cpi -> mb ;VP9_COMMON * const cm = & cpi -> common ;x -> act_zbin_adj = 0 ;vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ;vp9_setup_pre_planes ( xd , 0 , get_ref_frame_buffer ( cpi , LAST_FRAME ) , 0 , 0 , NULL ) ;xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ;xd -> mi [ 0 ] -> mbmi . uv_mode = DC_PRED ;vpx_memset ( xd -> above_context [ 0 ] , 0 , sizeof ( * xd -> above_context [ 0 ] ) * 2 * aligned_mi_cols * MAX_MB_PLANE ) ;vpx_memset ( xd -> above_seg_context , 0 ,  sizeof ( * xd -> above_seg_context ) * aligned_mi_cols ) ;cwe id:CWE-119context: static void init_encode_frame_mb_context ( VP9_COMP * cpi ) {  MACROBLOCK * const x = & cpi -> mb ;  VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ;  x -> act_zbin_adj = 0 ;   vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ;  vp9_setup_pre_planes ( xd , 0 , get_ref_frame_buffer ( cpi , LAST_FRAME ) , 0 , 0 , NULL ) ; vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , 0 , 0 ) ; vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ;  xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ;  xd -> mi [ 0 ] -> mbmi . uv_mode = DC_PRED ; vpx_memset ( xd -> above_context [ 0 ] , 0 , sizeof ( * xd -> above_context [ 0 ] ) * 2 * aligned_mi_cols * MAX_MB_PLANE ) ;  vpx_memset ( xd -> above_seg_context , 0 ,  sizeof ( * xd -> above_seg_context ) * aligned_mi_cols ) ; }","MACROBLOCK * const x = & cpi -> td . mb ;VP9_COMMON * const cm = & cpi -> common ;vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ;vp9_setup_pre_planes ( xd , 0 , get_ref_frame_buffer ( cpi , LAST_FRAME ) , 0 , 0 , NULL ) ;memset ( xd -> above_context [ 0 ] , 0 , sizeof ( * xd -> above_context [ 0 ] ) * 2 * aligned_mi_cols * MAX_MB_PLANE ) ;vpx_memset ( xd -> above_seg_context , 0 , sizeof ( * xd -> above_seg_context ) * aligned_mi_cols ) ;",1305
136,"buggy line: dst_name = malloc ( strlen ( name ) * 2 + 16 ) ;sprintf ( dst_name , ""%s/%s"" , name , name ) ;cwe id:CWE-787context: void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) {  dst_name = malloc ( strlen ( name ) * 2 + 16 ) ;  sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , ""<S2SV_blank>Page(%d)\\n"" , page ) ; else fprintf ( out , ""\\n"" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , ""%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n"" ""%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n"" , pdf -> name , pdf -> name ) ; fprintf ( out , ""----------<S2SV_blank>%s<S2SV_blank>----------\\n"" ""Versions:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , ""Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n"" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , ""%s:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }","dst_name = safe_calloc ( strlen ( name ) * 2 + 16 ) ;sprintf ( dst_name , ""%s/%s"" , name , name ) ;",1306
137,"buggy line: retval = http_splitline ( sp -> wrk , sp -> fd , hp , htc , HTTP_HDR_REQ , HTTP_HDR_URL , HTTP_HDR_PROTO ) ;if ( retval != 0 ) {WSPR ( sp , SLT_HttpGarbage , htc -> rxbuf ) ;retval = htc_request_check_host_hdr ( hp ) ;if ( retval != 0 ) {WSP ( sp , SLT_Error , ""Duplicated<S2SV_blank>Host<S2SV_blank>header"" ) ;return ( retval ) ;return ( retval ) ;}cwe id:CWE-000context: uint16_t http_DissectRequest ( struct sess * sp ) { struct http_conn * htc ; struct http * hp ; uint16_t retval ; CHECK_OBJ_NOTNULL ( sp , SESS_MAGIC ) ; htc = sp -> htc ; CHECK_OBJ_NOTNULL ( htc , HTTP_CONN_MAGIC ) ; hp = sp -> http ; CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; hp -> logtag = HTTP_Rx ; retval = http_splitline ( sp -> wrk , sp -> fd , hp , htc , HTTP_HDR_REQ , HTTP_HDR_URL , HTTP_HDR_PROTO ) ; if ( retval != 0 ) { WSPR ( sp , SLT_HttpGarbage , htc -> rxbuf ) ; return ( retval ) ; } http_ProtoVer ( hp ) ;  retval = htc_request_check_host_hdr ( hp ) ;  if ( retval != 0 ) {  WSP ( sp , SLT_Error , ""Duplicated<S2SV_blank>Host<S2SV_blank>header"" ) ;  return ( retval ) ; }  return ( retval ) ;  }","retval = htc_request_check_hdrs ( sp , SLT_HttpGarbage , htc -> rxbuf ) ;retval = htc_request_check_host_hdr ( hp ) ;if ( retval != 0 ) {WSP ( sp , hp ) ;return ( retval ) ;",1307
138,"buggy line: # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","# define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\\\if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( ( exception ) , ( message ) ) ;colormap = ( unsigned char * ) NULL ;pixel_info = ( MemoryInfo * ) NULL ;\\\\\char magick [ 12 ] ;",1308
139,"buggy line: if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;assert ( exception != ( ExceptionInfo * ) NULL ) ;assert ( exception -> signature == MagickSignature ) ;image = AcquireImage ( image_info ) ;status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;if ( ( count != 2 ) || ( memcmp ( magick , ""\\\\122\\\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;do {image -> page . x = ReadBlobLSBShort ( image ) ;image -> page . y = ReadBlobLSBShort ( image ) ;image -> columns = ReadBlobLSBShort ( image ) ;image -> rows = ReadBlobLSBShort ( image ) ;flags = ( MagickStatusType ) ReadBlobByte ( image ) ;image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ;number_planes = ( size_t ) ReadBlobByte ( image ) ;bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ;number_colormaps = ( size_t ) ReadBlobByte ( image ) ;map_length = ( unsigned char ) ReadBlobByte ( image ) ;if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;one = 1 ;map_length = one << map_length ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( image_info -> debug != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;one = 1 ;map_length = one << map_length ;",1308
140,"buggy line: if ( EOFBlob ( image ) != MagickFalse )  {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;",1308
141,"buggy line: x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;}cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ) ;},1308
142,"buggy line: if ( EOFBlob ( image ) != MagickFalse )  {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ;break ;}if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}if ( image -> matte != MagickFalse ) number_planes ++ ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ;if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) {ssize_t j ;p = pixels ;for ( i = 0 ;i < ( ssize_t ) number_pixels ;i ++ ) {if ( image -> matte == MagickFalse ) for ( j = 0 ;j < ( ssize_t ) number_planes ;j ++ ) * p ++ = background_color [ j ] ;else {for ( j = 0 ;j < ( ssize_t ) ( number_planes - 1 ) ;j ++ ) * p ++ = background_color [ j ] ;* p ++ = 0 ;}}}plane = 0 ;x = 0 ;y = 0 ;opcode = ReadBlobByte ( image ) ;do  {switch ( opcode & 0x3f ) {case SkipLinesOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;x = 0 ;y += operand ;break ;}case SetColorOp : {operand = ReadBlobByte ( image ) ;plane = ( unsigned char ) operand ;if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ;x = 0 ;break ;}case SkipPixelsOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;x += operand ;break ;}case ByteDataOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;operand ++ ;if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  {if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ) ;colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;",1308
143,"buggy line: if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;pixel = ( unsigned char ) ReadBlobByte ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  {cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ;pixel = ( unsigned char ) ReadBlobByte ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ;if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {,1308
144,"buggy line: }if ( number_colormaps != 0 ) {cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",}if ( number_colormaps != 0 ) {,1308
145,"buggy line: if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ;",1308
146,"buggy line: if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","{if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ;",1308
147,"buggy line: cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}",1308
148,"buggy line: if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ;if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ;if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ;if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ;if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ;",1308
149,"buggy line: ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;( void ) ReadBlobByte ( image ) ;count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ;  if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}",1308
150,"buggy line: INIT_LIST_HEAD ( & card -> controls ) ;INIT_LIST_HEAD ( & card -> ctl_files ) ;cwe id:CWE-362context: int snd_card_new ( struct device * parent , int idx , const char * xid , struct module * module , int extra_size , struct snd_card * * card_ret ) { struct snd_card * card ; int err ; if ( snd_BUG_ON ( ! card_ret ) ) return - EINVAL ; * card_ret = NULL ; if ( extra_size < 0 ) extra_size = 0 ; card = kzalloc ( sizeof ( * card ) + extra_size , GFP_KERNEL ) ; if ( ! card ) return - ENOMEM ; if ( extra_size > 0 ) card -> private_data = ( char * ) card + sizeof ( struct snd_card ) ; if ( xid ) strlcpy ( card -> id , xid , sizeof ( card -> id ) ) ; err = 0 ; mutex_lock ( & snd_card_mutex ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , module_slot_match , module ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , check_empty_slot , module ) ; if ( idx < 0 ) err = - ENODEV ; else if ( idx < snd_ecards_limit ) { if ( test_bit ( idx , snd_cards_lock ) ) err = - EBUSY ; } else if ( idx >= SNDRV_CARDS ) err = - ENODEV ; if ( err < 0 ) { mutex_unlock ( & snd_card_mutex ) ; dev_err ( parent , ""cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>slot<S2SV_blank>for<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>(range<S2SV_blank>0-%i),<S2SV_blank>error:<S2SV_blank>%d\\n"" , idx , snd_ecards_limit - 1 , err ) ; kfree ( card ) ; return err ; } set_bit ( idx , snd_cards_lock ) ; if ( idx >= snd_ecards_limit ) snd_ecards_limit = idx + 1 ; mutex_unlock ( & snd_card_mutex ) ; card -> dev = parent ; card -> number = idx ; card -> module = module ; INIT_LIST_HEAD ( & card -> devices ) ; init_rwsem ( & card -> controls_rwsem ) ; rwlock_init ( & card -> ctl_files_rwlock ) ;  INIT_LIST_HEAD ( & card -> controls ) ;  INIT_LIST_HEAD ( & card -> ctl_files ) ; spin_lock_init ( & card -> files_lock ) ; INIT_LIST_HEAD ( & card -> files_list ) ; # ifdef CONFIG_PM mutex_init ( & card -> power_lock ) ; init_waitqueue_head ( & card -> power_sleep ) ; # endif device_initialize ( & card -> card_dev ) ; card -> card_dev . parent = parent ; card -> card_dev . class = sound_class ; card -> card_dev . release = release_card_device ; card -> card_dev . groups = card_dev_attr_groups ; err = kobject_set_name ( & card -> card_dev . kobj , ""card%d"" , idx ) ; if ( err < 0 ) goto __error ; err = snd_ctl_create ( card ) ; if ( err < 0 ) { dev_err ( parent , ""unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>control<S2SV_blank>minors\\n"" ) ; goto __error ; } err = snd_info_card_create ( card ) ; if ( err < 0 ) { dev_err ( parent , ""unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>card<S2SV_blank>info\\n"" ) ; goto __error_ctl ; } * card_ret = card ; return 0 ; __error_ctl : snd_device_free_all ( card ) ; __error : put_device ( & card -> card_dev ) ; return err ; }",mutex_init ( & card -> user_ctl_lock ) ;INIT_LIST_HEAD ( & card -> controls ) ;INIT_LIST_HEAD ( & card -> ctl_files ) ;,1309
151,"buggy line: s += padlen + 3 ;( * psig ) = s ;return NULL ;cwe id:CWE-347context: err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return ""2"" ""exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets"" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( ""verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:"" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( ""pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d"" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return ""3"" ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; }  s += padlen + 3 ;   ( * psig ) = s ;  return NULL ; }","( * psig ) = s + padlen + 3 ;{const u_char * p ;size_t cnt_ffs = 0 ;for ( p = s + 2 ;p < s + padlen + 2 ;p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ;if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ;}return NULL ;",1310
152,"buggy line: int ret = write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ;BTIF_TRACE_DEBUG ( ""ret:%d"" , ret ) ;cwe id:CWE-284context: int btpan_tap_send ( int tap_fd , const BD_ADDR src , const BD_ADDR dst , UINT16 proto , const char * buf , UINT16 len , BOOLEAN ext , BOOLEAN forward ) { UNUSED ( ext ) ; UNUSED ( forward ) ; if ( tap_fd != INVALID_FD ) { tETH_HDR eth_hdr ; memcpy ( & eth_hdr . h_dest , dst , ETH_ADDR_LEN ) ; memcpy ( & eth_hdr . h_src , src , ETH_ADDR_LEN ) ; eth_hdr . h_proto = htons ( proto ) ; char packet [ TAP_MAX_PKT_WRITE_LEN + sizeof ( tETH_HDR ) ] ; memcpy ( packet , & eth_hdr , sizeof ( tETH_HDR ) ) ; if ( len > TAP_MAX_PKT_WRITE_LEN ) { LOG_ERROR ( ""btpan_tap_send<S2SV_blank>eth<S2SV_blank>packet<S2SV_blank>size:%d<S2SV_blank>is<S2SV_blank>exceeded<S2SV_blank>limit!"" , len ) ; return - 1 ; } memcpy ( packet + sizeof ( tETH_HDR ) , buf , len ) ;  int ret = write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ;  BTIF_TRACE_DEBUG ( ""ret:%d"" , ret ) ; return ret ; } return - 1 ; }","int ret = TEMP_FAILURE_RETRY ( write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ) ;BTIF_TRACE_DEBUG ( ""ret:%d"" , ret ) ;",1311
153,"buggy line: ps_dec -> i1_next_ctxt_idx = 0 ;ps_dec -> u4_nmb_deblk = 0 ;if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ;if ( ps_seq -> u1_mb_aff_flag == 1 ) {cwe id:CWE-119context: WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_dec -> ps_cur_slice -> u1_bottom_field_flag ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = u2_frame_num ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> i1_next_ctxt_idx = 0 ; ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ; if ( ps_seq -> u1_mb_aff_flag == 1 ) { ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ; } ps_dec -> u4_use_intrapred_line_copy = 0 ; if ( ps_seq -> u1_mb_aff_flag == 0 ) { ps_dec -> u4_use_intrapred_line_copy = 1 ; } ps_dec -> u4_app_disable_deblk_frm = 0 ; if ( ps_dec -> i4_degrade_type && ps_dec -> i4_degrade_pics ) { WORD32 degrade_pic ; ps_dec -> i4_degrade_pic_cnt ++ ; degrade_pic = 0 ; switch ( ps_dec -> i4_degrade_pics ) { case 4 : { degrade_pic = 1 ; break ; } case 3 : { if ( ps_cur_slice -> u1_slice_type != I_SLICE ) degrade_pic = 1 ; break ; } case 2 : { if ( ( ps_cur_slice -> u1_slice_type != I_SLICE ) && ( ps_dec -> i4_degrade_pic_cnt != ps_dec -> i4_nondegrade_interval ) ) degrade_pic = 1 ; break ; } case 1 : { if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { degrade_pic = 1 ; } break ; } } if ( degrade_pic ) { if ( ps_dec -> i4_degrade_type & 0x2 ) ps_dec -> u4_app_disable_deblk_frm = 1 ; if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { if ( ps_dec -> i4_degrade_type & 0x4 ) ps_dec -> i4_mv_frac_mask = 0 ; if ( ps_dec -> i4_degrade_type & 0x8 ) ps_dec -> i4_mv_frac_mask = 0 ; } } else ps_dec -> i4_degrade_pic_cnt = 0 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_dec -> u1_sl_typ_5_9 && ( ( ps_cur_slice -> u1_slice_type == I_SLICE ) || ( ps_cur_slice -> u1_slice_type == SI_SLICE ) ) ) ps_err -> u1_cur_pic_type = PIC_TYPE_I ; else ps_err -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; if ( ps_err -> u1_pic_aud_i == PIC_TYPE_I ) { ps_err -> u1_cur_pic_type = PIC_TYPE_I ; ps_err -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; } if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { if ( ps_err -> u1_err_flag ) ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } if ( ps_dec -> u1_init_dec_flag && ps_dec -> s_prev_seq_params . u1_eoseq_pending ) { WORD32 j ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> u1_second_field = 0 ; ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; } ret = ih264d_init_pic ( ps_dec , u2_frame_num , i4_poc , ps_pps ) ; if ( ret != OK ) return ret ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> ps_nmb_info = ps_dec -> ps_frm_mb_info ; if ( ps_dec -> u1_separate_parse ) { UWORD16 pic_wd = ps_dec -> u4_width_at_init ; UWORD16 pic_ht = ps_dec -> u4_height_at_init ; UWORD32 num_mbs ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { pic_wd = ps_dec -> u2_pic_wd ; pic_ht = ps_dec -> u2_pic_ht ; } num_mbs = ( pic_wd * pic_ht ) >> 8 ; if ( ps_dec -> pu1_dec_mb_map ) { memset ( ( void * ) ps_dec -> pu1_dec_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu1_recon_mb_map ) { memset ( ( void * ) ps_dec -> pu1_recon_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu2_slice_num_map ) { memset ( ( void * ) ps_dec -> pu2_slice_num_map , 0 , ( num_mbs * sizeof ( UWORD16 ) ) ) ; } } ps_dec -> ps_parse_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_decode_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_computebs_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> s_high_profile . u1_scaling_present = 0 ; ps_dec -> s_high_profile . u1_transform8x8_present = 0 ; if ( 1 == ps_dec -> u4_share_disp_buf ) { UWORD32 i ; for ( i = 0 ; i < MAX_DISP_BUFS_NEW ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) continue ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , i , BUF_MGR_IO ) ; ps_dec -> u4_disp_buf_to_be_freed [ i ] = 0 ; ps_dec -> u4_disp_buf_mapping [ i ] = 0 ; } } if ( ! ( u1_field_pic_flag && 0 != ps_dec -> u1_top_bottom_decoded ) ) { pic_buffer_t * ps_cur_pic ; WORD32 cur_pic_buf_id , cur_mv_buf_id ; col_mv_buf_t * ps_col_mv ; while ( 1 ) { ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } if ( 0 == ps_dec -> u4_disp_buf_mapping [ cur_pic_buf_id ] ) { break ; } } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ;  if ( ps_dec -> u1_first_slice_in_stream )  { ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ 0 ] ) = * ps_cur_pic ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ MAX_REF_BUFS ] ) = * ps_cur_pic ; } if ( ! ps_dec -> ps_cur_pic ) { WORD32 j ; H264_DEC_DEBUG_PRINT ( ""-------<S2SV_blank>Display<S2SV_blank>Buffers<S2SV_blank>Reset<S2SV_blank>--------\\n"" ) ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> i4_max_poc = 0 ; ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_dec -> apv_buf_id_pic_buf_map [ cur_pic_buf_id ] = ( void * ) ps_cur_pic ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; } ps_dec -> ps_cur_pic -> u1_picturetype = u1_field_pic_flag ; ps_dec -> ps_cur_pic -> u4_pack_slc_typ = SKIP_NONE ; H264_DEC_DEBUG_PRINT ( ""got<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } else { H264_DEC_DEBUG_PRINT ( ""did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } ps_dec -> u4_pic_buf_got = 1 ; ps_dec -> ps_cur_pic -> i4_poc = i4_poc ; ps_dec -> ps_cur_pic -> i4_frame_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_pic_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = ps_pps -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = ps_pps -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_avg_poc = ps_pps -> i4_avg_poc ; ps_dec -> ps_cur_pic -> u4_time_stamp = ps_dec -> u4_pts ; ps_dec -> s_cur_pic = * ( ps_dec -> ps_cur_pic ) ; if ( u1_field_pic_flag && u1_bottom_field_flag ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; ps_dec -> s_cur_pic . pu1_buf1 += ps_dec -> s_cur_pic . u2_frm_wd_y ; ps_dec -> s_cur_pic . pu1_buf2 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . pu1_buf3 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . ps_mv += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> s_cur_pic . pu1_col_zero_flag += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= BOT_FLD ; i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= ( ps_cur_slice -> u1_mbaff_frame_flag << 2 ) ; ps_dec -> ps_cur_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_cur_mb_row ++ ; ps_dec -> ps_top_mb_row = ps_dec -> ps_nbr_mb_row + ( ( ps_dec -> u2_frm_wd_in_mbs + 1 ) << ( 1 - ps_dec -> ps_cur_sps -> u1_frame_mbs_only_flag ) ) ; ps_dec -> ps_top_mb_row ++ ; ps_dec -> pu1_y = ps_dec -> pu1_y_scratch [ 0 ] ; ps_dec -> pu1_u = ps_dec -> pu1_u_scratch [ 0 ] ; ps_dec -> pu1_v = ps_dec -> pu1_v_scratch [ 0 ] ; ps_dec -> u1_yuv_scratch_idx = 0 ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_top = ps_dec -> ps_mv_top_p [ 0 ] ; ps_dec -> u1_mv_top_p = 0 ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> ps_mv_left = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_yleft = 0 ; ps_dec -> pu1_uleft = 0 ; ps_dec -> pu1_vleft = 0 ; ps_dec -> u1_not_wait_rec = 2 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> i4_submb_ofst = - ( SUB_BLK_SIZE ) ; ps_dec -> u4_pred_info_idx = 0 ; ps_dec -> u4_pred_info_pkd_idx = 0 ; ps_dec -> u4_dma_buf_idx = 0 ; ps_dec -> ps_mv = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_bank_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_col_zero_flag = ps_dec -> s_cur_pic . pu1_col_zero_flag ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> i2_prev_slice_mbx = - 1 ; ps_dec -> i2_prev_slice_mby = 0 ; ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u2_cur_slice_num_dec_thread = 0 ; ps_dec -> u2_cur_slice_num_bs = 0 ; ps_dec -> u4_intra_pred_line_ofst = 0 ; ps_dec -> pu1_cur_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_cur_y_intra_pred_line_base = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line_base = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line_base = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_prev_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line + ( ps_dec -> u2_frm_wd_in_mbs * MB_SIZE ) ; ps_dec -> pu1_prev_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR ; ps_dec -> pu1_prev_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_deblk_mbn_curr = ps_dec -> ps_deblk_mbn ; ps_dec -> ps_deblk_mbn_prev = ps_dec -> ps_deblk_mbn + ps_dec -> u1_recon_mb_grp ; { if ( ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_compute_bs = ih264d_compute_bs_mbaff ; ps_dec -> pf_mvpred = ih264d_mvpred_mbaff ; } else { ps_dec -> pf_compute_bs = ih264d_compute_bs_non_mbaff ; ps_dec -> u1_cur_mb_fld_dec_flag = ps_cur_slice -> u1_field_pic_flag ; } } { UWORD8 u1_field_pic_flag = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; UWORD8 u1_mbaff = ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 uc_lastmbs = ( ( ( ps_dec -> u2_pic_wd ) >> 4 ) % ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) ) ; UWORD16 ui16_lastmbs_widthY = ( uc_lastmbs ? ( uc_lastmbs << 4 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 4 ) ) ; UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? ( uc_lastmbs << 3 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 3 ) ; ps_dec -> s_tran_addrecon . pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_dec -> s_tran_addrecon . pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_dec -> s_tran_addrecon . pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_dec -> s_tran_addrecon . u2_frm_wd_y = ps_dec -> u2_frm_wd_y << u1_field_pic_flag ; ps_dec -> s_tran_addrecon . u2_frm_wd_uv = ps_dec -> u2_frm_wd_uv << u1_field_pic_flag ; if ( u1_field_pic_flag ) { ui16_lastmbs_widthY += ps_dec -> u2_frm_wd_y ; ui16_lastmbs_widthUV += ps_dec -> u2_frm_wd_uv ; } ps_dec -> s_tran_addrecon . u4_inc_y [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_y [ 1 ] = ( ui16_lastmbs_widthY + ( PAD_LEN_Y_H << 1 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_y * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 1 ] = ( ui16_lastmbs_widthUV + ( PAD_LEN_UV_H << 2 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_uv * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ih264d_assign_pic_num ( ps_dec ) ; ps_dec -> s_tran_addrecon . u2_mv_top_left_inc = ( ps_dec -> u1_recon_mb_grp << 2 ) - 1 - ( u1_mbaff << 2 ) ; ps_dec -> s_tran_addrecon . u2_mv_left_inc = ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) - 1 ) << ( 4 + u1_mbaff ) ; } if ( ps_seq -> u1_profile_idc == HIGH_PROFILE_IDC ) { if ( ( ps_seq -> i4_seq_scaling_matrix_present_flag ) || ( ps_pps -> i4_pic_scaling_matrix_present_flag ) ) { ih264d_form_scaling_matrix_picture ( ps_seq , ps_pps , ps_dec ) ; ps_dec -> s_high_profile . u1_scaling_present = 1 ; } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } if ( ps_pps -> i4_transform_8x8_mode_flag ) { ps_dec -> s_high_profile . u1_transform8x8_present = 1 ; } } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } ps_dec -> s_high_profile . u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; ps_dec -> s_high_profile . s_cavlc_ctxt = ps_dec -> s_cavlc_ctxt ; ps_dec -> i1_recon_in_thread3_flag = 1 ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_addrecon ; if ( ps_dec -> u1_separate_parse ) { memcpy ( & ps_dec -> s_tran_addrecon_parse , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; if ( ps_dec -> u4_num_cores >= 3 && ps_dec -> i1_recon_in_thread3_flag ) { memcpy ( & ps_dec -> s_tran_iprecon , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_iprecon ; } } ih264d_init_deblk_tfr_ctxt ( ps_dec , & ( ps_dec -> s_pad_mgr ) , & ( ps_dec -> s_tran_addrecon ) , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; ps_dec -> ps_cur_deblk_mb = ps_dec -> ps_deblk_pic ; ps_dec -> u4_cur_deblk_mb_num = 0 ; ps_dec -> u4_deblk_mb_x = 0 ; ps_dec -> u4_deblk_mb_y = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ; }",{,1312
154,"buggy line: if ( ps_dec -> u1_first_slice_in_stream )  {cwe id:CWE-119context: WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_dec -> ps_cur_slice -> u1_bottom_field_flag ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = u2_frame_num ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> i1_next_ctxt_idx = 0 ; ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ; if ( ps_seq -> u1_mb_aff_flag == 1 ) { ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ; } ps_dec -> u4_use_intrapred_line_copy = 0 ; if ( ps_seq -> u1_mb_aff_flag == 0 ) { ps_dec -> u4_use_intrapred_line_copy = 1 ; } ps_dec -> u4_app_disable_deblk_frm = 0 ; if ( ps_dec -> i4_degrade_type && ps_dec -> i4_degrade_pics ) { WORD32 degrade_pic ; ps_dec -> i4_degrade_pic_cnt ++ ; degrade_pic = 0 ; switch ( ps_dec -> i4_degrade_pics ) { case 4 : { degrade_pic = 1 ; break ; } case 3 : { if ( ps_cur_slice -> u1_slice_type != I_SLICE ) degrade_pic = 1 ; break ; } case 2 : { if ( ( ps_cur_slice -> u1_slice_type != I_SLICE ) && ( ps_dec -> i4_degrade_pic_cnt != ps_dec -> i4_nondegrade_interval ) ) degrade_pic = 1 ; break ; } case 1 : { if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { degrade_pic = 1 ; } break ; } } if ( degrade_pic ) { if ( ps_dec -> i4_degrade_type & 0x2 ) ps_dec -> u4_app_disable_deblk_frm = 1 ; if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { if ( ps_dec -> i4_degrade_type & 0x4 ) ps_dec -> i4_mv_frac_mask = 0 ; if ( ps_dec -> i4_degrade_type & 0x8 ) ps_dec -> i4_mv_frac_mask = 0 ; } } else ps_dec -> i4_degrade_pic_cnt = 0 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_dec -> u1_sl_typ_5_9 && ( ( ps_cur_slice -> u1_slice_type == I_SLICE ) || ( ps_cur_slice -> u1_slice_type == SI_SLICE ) ) ) ps_err -> u1_cur_pic_type = PIC_TYPE_I ; else ps_err -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; if ( ps_err -> u1_pic_aud_i == PIC_TYPE_I ) { ps_err -> u1_cur_pic_type = PIC_TYPE_I ; ps_err -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; } if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { if ( ps_err -> u1_err_flag ) ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } if ( ps_dec -> u1_init_dec_flag && ps_dec -> s_prev_seq_params . u1_eoseq_pending ) { WORD32 j ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> u1_second_field = 0 ; ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; } ret = ih264d_init_pic ( ps_dec , u2_frame_num , i4_poc , ps_pps ) ; if ( ret != OK ) return ret ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> ps_nmb_info = ps_dec -> ps_frm_mb_info ; if ( ps_dec -> u1_separate_parse ) { UWORD16 pic_wd = ps_dec -> u4_width_at_init ; UWORD16 pic_ht = ps_dec -> u4_height_at_init ; UWORD32 num_mbs ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { pic_wd = ps_dec -> u2_pic_wd ; pic_ht = ps_dec -> u2_pic_ht ; } num_mbs = ( pic_wd * pic_ht ) >> 8 ; if ( ps_dec -> pu1_dec_mb_map ) { memset ( ( void * ) ps_dec -> pu1_dec_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu1_recon_mb_map ) { memset ( ( void * ) ps_dec -> pu1_recon_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu2_slice_num_map ) { memset ( ( void * ) ps_dec -> pu2_slice_num_map , 0 , ( num_mbs * sizeof ( UWORD16 ) ) ) ; } } ps_dec -> ps_parse_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_decode_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_computebs_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> s_high_profile . u1_scaling_present = 0 ; ps_dec -> s_high_profile . u1_transform8x8_present = 0 ; if ( 1 == ps_dec -> u4_share_disp_buf ) { UWORD32 i ; for ( i = 0 ; i < MAX_DISP_BUFS_NEW ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) continue ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , i , BUF_MGR_IO ) ; ps_dec -> u4_disp_buf_to_be_freed [ i ] = 0 ; ps_dec -> u4_disp_buf_mapping [ i ] = 0 ; } } if ( ! ( u1_field_pic_flag && 0 != ps_dec -> u1_top_bottom_decoded ) ) { pic_buffer_t * ps_cur_pic ; WORD32 cur_pic_buf_id , cur_mv_buf_id ; col_mv_buf_t * ps_col_mv ; while ( 1 ) { ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } if ( 0 == ps_dec -> u4_disp_buf_mapping [ cur_pic_buf_id ] ) { break ; } } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ;  if ( ps_dec -> u1_first_slice_in_stream )  { ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ 0 ] ) = * ps_cur_pic ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ MAX_REF_BUFS ] ) = * ps_cur_pic ; } if ( ! ps_dec -> ps_cur_pic ) { WORD32 j ; H264_DEC_DEBUG_PRINT ( ""-------<S2SV_blank>Display<S2SV_blank>Buffers<S2SV_blank>Reset<S2SV_blank>--------\\n"" ) ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> i4_max_poc = 0 ; ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_dec -> apv_buf_id_pic_buf_map [ cur_pic_buf_id ] = ( void * ) ps_cur_pic ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; } ps_dec -> ps_cur_pic -> u1_picturetype = u1_field_pic_flag ; ps_dec -> ps_cur_pic -> u4_pack_slc_typ = SKIP_NONE ; H264_DEC_DEBUG_PRINT ( ""got<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } else { H264_DEC_DEBUG_PRINT ( ""did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } ps_dec -> u4_pic_buf_got = 1 ; ps_dec -> ps_cur_pic -> i4_poc = i4_poc ; ps_dec -> ps_cur_pic -> i4_frame_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_pic_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = ps_pps -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = ps_pps -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_avg_poc = ps_pps -> i4_avg_poc ; ps_dec -> ps_cur_pic -> u4_time_stamp = ps_dec -> u4_pts ; ps_dec -> s_cur_pic = * ( ps_dec -> ps_cur_pic ) ; if ( u1_field_pic_flag && u1_bottom_field_flag ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; ps_dec -> s_cur_pic . pu1_buf1 += ps_dec -> s_cur_pic . u2_frm_wd_y ; ps_dec -> s_cur_pic . pu1_buf2 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . pu1_buf3 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . ps_mv += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> s_cur_pic . pu1_col_zero_flag += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= BOT_FLD ; i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= ( ps_cur_slice -> u1_mbaff_frame_flag << 2 ) ; ps_dec -> ps_cur_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_cur_mb_row ++ ; ps_dec -> ps_top_mb_row = ps_dec -> ps_nbr_mb_row + ( ( ps_dec -> u2_frm_wd_in_mbs + 1 ) << ( 1 - ps_dec -> ps_cur_sps -> u1_frame_mbs_only_flag ) ) ; ps_dec -> ps_top_mb_row ++ ; ps_dec -> pu1_y = ps_dec -> pu1_y_scratch [ 0 ] ; ps_dec -> pu1_u = ps_dec -> pu1_u_scratch [ 0 ] ; ps_dec -> pu1_v = ps_dec -> pu1_v_scratch [ 0 ] ; ps_dec -> u1_yuv_scratch_idx = 0 ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_top = ps_dec -> ps_mv_top_p [ 0 ] ; ps_dec -> u1_mv_top_p = 0 ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> ps_mv_left = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_yleft = 0 ; ps_dec -> pu1_uleft = 0 ; ps_dec -> pu1_vleft = 0 ; ps_dec -> u1_not_wait_rec = 2 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> i4_submb_ofst = - ( SUB_BLK_SIZE ) ; ps_dec -> u4_pred_info_idx = 0 ; ps_dec -> u4_pred_info_pkd_idx = 0 ; ps_dec -> u4_dma_buf_idx = 0 ; ps_dec -> ps_mv = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_bank_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_col_zero_flag = ps_dec -> s_cur_pic . pu1_col_zero_flag ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> i2_prev_slice_mbx = - 1 ; ps_dec -> i2_prev_slice_mby = 0 ; ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u2_cur_slice_num_dec_thread = 0 ; ps_dec -> u2_cur_slice_num_bs = 0 ; ps_dec -> u4_intra_pred_line_ofst = 0 ; ps_dec -> pu1_cur_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_cur_y_intra_pred_line_base = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line_base = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line_base = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_prev_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line + ( ps_dec -> u2_frm_wd_in_mbs * MB_SIZE ) ; ps_dec -> pu1_prev_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR ; ps_dec -> pu1_prev_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_deblk_mbn_curr = ps_dec -> ps_deblk_mbn ; ps_dec -> ps_deblk_mbn_prev = ps_dec -> ps_deblk_mbn + ps_dec -> u1_recon_mb_grp ; { if ( ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_compute_bs = ih264d_compute_bs_mbaff ; ps_dec -> pf_mvpred = ih264d_mvpred_mbaff ; } else { ps_dec -> pf_compute_bs = ih264d_compute_bs_non_mbaff ; ps_dec -> u1_cur_mb_fld_dec_flag = ps_cur_slice -> u1_field_pic_flag ; } } { UWORD8 u1_field_pic_flag = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; UWORD8 u1_mbaff = ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 uc_lastmbs = ( ( ( ps_dec -> u2_pic_wd ) >> 4 ) % ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) ) ; UWORD16 ui16_lastmbs_widthY = ( uc_lastmbs ? ( uc_lastmbs << 4 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 4 ) ) ; UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? ( uc_lastmbs << 3 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 3 ) ; ps_dec -> s_tran_addrecon . pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_dec -> s_tran_addrecon . pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_dec -> s_tran_addrecon . pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_dec -> s_tran_addrecon . u2_frm_wd_y = ps_dec -> u2_frm_wd_y << u1_field_pic_flag ; ps_dec -> s_tran_addrecon . u2_frm_wd_uv = ps_dec -> u2_frm_wd_uv << u1_field_pic_flag ; if ( u1_field_pic_flag ) { ui16_lastmbs_widthY += ps_dec -> u2_frm_wd_y ; ui16_lastmbs_widthUV += ps_dec -> u2_frm_wd_uv ; } ps_dec -> s_tran_addrecon . u4_inc_y [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_y [ 1 ] = ( ui16_lastmbs_widthY + ( PAD_LEN_Y_H << 1 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_y * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 1 ] = ( ui16_lastmbs_widthUV + ( PAD_LEN_UV_H << 2 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_uv * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ih264d_assign_pic_num ( ps_dec ) ; ps_dec -> s_tran_addrecon . u2_mv_top_left_inc = ( ps_dec -> u1_recon_mb_grp << 2 ) - 1 - ( u1_mbaff << 2 ) ; ps_dec -> s_tran_addrecon . u2_mv_left_inc = ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) - 1 ) << ( 4 + u1_mbaff ) ; } if ( ps_seq -> u1_profile_idc == HIGH_PROFILE_IDC ) { if ( ( ps_seq -> i4_seq_scaling_matrix_present_flag ) || ( ps_pps -> i4_pic_scaling_matrix_present_flag ) ) { ih264d_form_scaling_matrix_picture ( ps_seq , ps_pps , ps_dec ) ; ps_dec -> s_high_profile . u1_scaling_present = 1 ; } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } if ( ps_pps -> i4_transform_8x8_mode_flag ) { ps_dec -> s_high_profile . u1_transform8x8_present = 1 ; } } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } ps_dec -> s_high_profile . u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; ps_dec -> s_high_profile . s_cavlc_ctxt = ps_dec -> s_cavlc_ctxt ; ps_dec -> i1_recon_in_thread3_flag = 1 ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_addrecon ; if ( ps_dec -> u1_separate_parse ) { memcpy ( & ps_dec -> s_tran_addrecon_parse , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; if ( ps_dec -> u4_num_cores >= 3 && ps_dec -> i1_recon_in_thread3_flag ) { memcpy ( & ps_dec -> s_tran_iprecon , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_iprecon ; } } ih264d_init_deblk_tfr_ctxt ( ps_dec , & ( ps_dec -> s_pad_mgr ) , & ( ps_dec -> s_tran_addrecon ) , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; ps_dec -> ps_cur_deblk_mb = ps_dec -> ps_deblk_pic ; ps_dec -> u4_cur_deblk_mb_num = 0 ; ps_dec -> u4_deblk_mb_x = 0 ; ps_dec -> u4_deblk_mb_y = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ; }",if ( ps_dec -> u1_first_slice_in_stream ) {,1312
155,"buggy line: return ( 0 ) ;cwe id:CWE-119context: static int dtls1_buffer_record ( SSL * s , record_pqueue * queue , unsigned char * priority ) { DTLS1_RECORD_DATA * rdata ; pitem * item ; if ( pqueue_size ( queue -> q ) >= 100 ) return 0 ; rdata = OPENSSL_malloc ( sizeof ( DTLS1_RECORD_DATA ) ) ; item = pitem_new ( priority , rdata ) ; if ( rdata == NULL || item == NULL ) { if ( rdata != NULL ) OPENSSL_free ( rdata ) ; if ( item != NULL ) pitem_free ( item ) ; SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; return ( 0 ) ; } rdata -> packet = s -> packet ; rdata -> packet_length = s -> packet_length ; memcpy ( & ( rdata -> rbuf ) , & ( s -> s3 -> rbuf ) , sizeof ( SSL3_BUFFER ) ) ; memcpy ( & ( rdata -> rrec ) , & ( s -> s3 -> rrec ) , sizeof ( SSL3_RECORD ) ) ; item -> data = rdata ; # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == SSL3_ST_SR_FINISHED_A || s -> state == SSL3_ST_CR_FINISHED_A ) ) { BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_GET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif s -> packet = NULL ; s -> packet_length = 0 ; memset ( & ( s -> s3 -> rbuf ) , 0 , sizeof ( SSL3_BUFFER ) ) ; memset ( & ( s -> s3 -> rrec ) , 0 , sizeof ( SSL3_RECORD ) ) ; if ( ! ssl3_setup_buffers ( s ) ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ;  OPENSSL_free ( rdata ) ;  pitem_free ( item ) ;  return ( 0 ) ;  } if ( pqueue_insert ( queue -> q , item ) == NULL ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ;  OPENSSL_free ( rdata ) ;  pitem_free ( item ) ;  return ( 0 ) ;  } return ( 1 ) ; }",if ( rdata -> rbuf . buf != NULL ) return ( 0 ) ;,1313
156,"buggy line: OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( 0 ) ;}OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( 0 ) ;}cwe id:CWE-119context: static int dtls1_buffer_record ( SSL * s , record_pqueue * queue , unsigned char * priority ) { DTLS1_RECORD_DATA * rdata ; pitem * item ; if ( pqueue_size ( queue -> q ) >= 100 ) return 0 ; rdata = OPENSSL_malloc ( sizeof ( DTLS1_RECORD_DATA ) ) ; item = pitem_new ( priority , rdata ) ; if ( rdata == NULL || item == NULL ) { if ( rdata != NULL ) OPENSSL_free ( rdata ) ; if ( item != NULL ) pitem_free ( item ) ; SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; return ( 0 ) ; } rdata -> packet = s -> packet ; rdata -> packet_length = s -> packet_length ; memcpy ( & ( rdata -> rbuf ) , & ( s -> s3 -> rbuf ) , sizeof ( SSL3_BUFFER ) ) ; memcpy ( & ( rdata -> rrec ) , & ( s -> s3 -> rrec ) , sizeof ( SSL3_RECORD ) ) ; item -> data = rdata ; # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == SSL3_ST_SR_FINISHED_A || s -> state == SSL3_ST_CR_FINISHED_A ) ) { BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_GET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif s -> packet = NULL ; s -> packet_length = 0 ; memset ( & ( s -> s3 -> rbuf ) , 0 , sizeof ( SSL3_BUFFER ) ) ; memset ( & ( s -> s3 -> rrec ) , 0 , sizeof ( SSL3_RECORD ) ) ; if ( ! ssl3_setup_buffers ( s ) ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ;  OPENSSL_free ( rdata ) ;  pitem_free ( item ) ;  return ( 0 ) ;  } if ( pqueue_insert ( queue -> q , item ) == NULL ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ;  OPENSSL_free ( rdata ) ;  pitem_free ( item ) ;  return ( 0 ) ;  } return ( 1 ) ; }",OPENSSL_free ( rdata -> rbuf . buf ) ;OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( - 1 ) ;}if ( rdata -> rbuf . buf != NULL ) OPENSSL_free ( rdata -> rbuf . buf ) ;OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( - 1 ) ;},1313
157,"buggy line: struct flowi6 fl6 ;memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;fl6 . flowi6_proto = sk -> sk_protocol ;fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ;fl6 . saddr = transport -> saddr . v6 . sin6_addr ;fl6 . flowlabel = np -> flow_label ;IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ;if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ;else fl6 . flowi6_oif = sk -> sk_bound_dev_if ;if ( np -> opt && np -> opt -> srcrt ) {struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ;fl6 . daddr = * rt0 -> addr ;pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\\SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ;return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;}cwe id:CWE-310context: static int sctp_v6_xmit ( struct sk_buff * skb , struct sctp_transport * transport ) { struct sock * sk = skb -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ;  struct flowi6 fl6 ;  memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ; fl6 . saddr = transport -> saddr . v6 . sin6_addr ; fl6 . flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ; if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ; else fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( np -> opt && np -> opt -> srcrt ) { struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ; fl6 . daddr = * rt0 -> addr ; } pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\n"" , __func__ , skb ,  skb -> len , & fl6 . saddr , & fl6 . daddr ) ;   SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;  if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ;  return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;  }","struct flowi6 * fl6 = & transport -> fl . u . ip6 ;pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\\SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ;SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;",1314
158,"buggy line: if ( args -> buffer_count < 1 ) {DRM_DEBUG ( ""execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\\cwe id:CWE-189context: int i915_gem_execbuffer2 ( struct drm_device * dev , void * data , struct drm_file * file ) { struct drm_i915_gem_execbuffer2 * args = data ; struct drm_i915_gem_exec_object2 * exec2_list = NULL ; int ret ;  if ( args -> buffer_count < 1 ) {  DRM_DEBUG ( ""execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\n"" , args -> buffer_count ) ; return - EINVAL ; } exec2_list = kmalloc ( sizeof ( * exec2_list ) * args -> buffer_count , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( exec2_list == NULL ) exec2_list = drm_malloc_ab ( sizeof ( * exec2_list ) , args -> buffer_count ) ; if ( exec2_list == NULL ) { DRM_DEBUG ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>exec<S2SV_blank>list<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>buffers\\n"" , args -> buffer_count ) ; return - ENOMEM ; } ret = copy_from_user ( exec2_list , ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret != 0 ) { DRM_DEBUG ( ""copy<S2SV_blank>%d<S2SV_blank>exec<S2SV_blank>entries<S2SV_blank>failed<S2SV_blank>%d\\n"" , args -> buffer_count , ret ) ; drm_free_large ( exec2_list ) ; return - EFAULT ; } ret = i915_gem_do_execbuffer ( dev , data , file , args , exec2_list ) ; if ( ! ret ) { ret = copy_to_user ( ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , exec2_list , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret ) { ret = - EFAULT ; DRM_DEBUG ( ""failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>%d<S2SV_blank>exec<S2SV_blank>entries<S2SV_blank>"" ""back<S2SV_blank>to<S2SV_blank>user<S2SV_blank>(%d)\\n"" , args -> buffer_count , ret ) ; } } drm_free_large ( exec2_list ) ; return ret ; }","if ( args -> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list ) ) {DRM_DEBUG ( ""execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\\",1315
159,"buggy line: static int  mptctl_getiocinfo ( unsigned long arg , unsigned int data_size )  {MPT_ADAPTER * ioc ;struct pci_dev * pdev ;int iocnum ;cwe id:CWE-362context: static int  mptctl_getiocinfo ( unsigned long arg , unsigned int data_size )  { struct mpt_ioctl_iocinfo __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_iocinfo * karg ;  MPT_ADAPTER * ioc ;   struct pci_dev * pdev ;  int iocnum ; unsigned int port ; int cim_rev ; struct scsi_device * sdev ; VirtDevice * vdevice ; if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev0 ) ) cim_rev = 0 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev1 ) ) cim_rev = 1 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo ) ) cim_rev = 2 ; else if ( data_size == ( sizeof ( struct mpt_ioctl_iocinfo_rev0 ) + 12 ) ) cim_rev = 0 ; else return - EFAULT ; karg = memdup_user ( uarg , data_size ) ; if ( IS_ERR ( karg ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mpt_ioctl_iocinfo()<S2SV_blank>-<S2SV_blank>memdup_user<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>[%ld]\\n"" , __FILE__ , __LINE__ , PTR_ERR ( karg ) ) ;  return PTR_ERR ( karg ) ;  } if ( ( ( iocnum = mpt_verify_adapter ( karg -> hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_getiocinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; kfree ( karg ) ; return - ENODEV ; } if ( karg -> hdr . maxDataSize != data_size ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_getiocinfo<S2SV_blank>-<S2SV_blank>"" ""Structure<S2SV_blank>size<S2SV_blank>mismatch.<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>completed.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; kfree ( karg ) ; return - EFAULT ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_getiocinfo<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ioc -> bus_type == SAS ) karg -> adapterType = MPT_IOCTL_INTERFACE_SAS ; else if ( ioc -> bus_type == FC ) karg -> adapterType = MPT_IOCTL_INTERFACE_FC ; else karg -> adapterType = MPT_IOCTL_INTERFACE_SCSI ; if ( karg -> hdr . port > 1 ) { kfree ( karg ) ; return - EINVAL ; } port = karg -> hdr . port ; karg -> port = port ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg -> pciId = pdev -> device ; karg -> hwRev = pdev -> revision ; karg -> subSystemDevice = pdev -> subsystem_device ; karg -> subSystemVendor = pdev -> subsystem_vendor ; if ( cim_rev == 1 ) { karg -> pciInfo . u . bits . busNumber = pdev -> bus -> number ; karg -> pciInfo . u . bits . deviceNumber = PCI_SLOT ( pdev -> devfn ) ; karg -> pciInfo . u . bits . functionNumber = PCI_FUNC ( pdev -> devfn ) ; } else if ( cim_rev == 2 ) { karg -> pciInfo . u . bits . busNumber = pdev -> bus -> number ; karg -> pciInfo . u . bits . deviceNumber = PCI_SLOT ( pdev -> devfn ) ; karg -> pciInfo . u . bits . functionNumber = PCI_FUNC ( pdev -> devfn ) ; karg -> pciInfo . segmentID = pci_domain_nr ( pdev -> bus ) ; } karg -> numDevices = 0 ; if ( ioc -> sh ) { shost_for_each_device ( sdev , ioc -> sh ) { vdevice = sdev -> hostdata ; if ( vdevice == NULL || vdevice -> vtarget == NULL ) continue ; if ( vdevice -> vtarget -> tflags & MPT_TARGET_FLAGS_RAID_COMPONENT ) continue ; karg -> numDevices ++ ; } } karg -> FWVersion = ioc -> facts . FWVersion . Word ; karg -> BIOSVersion = ioc -> biosVersion ; strncpy ( karg -> driverVersion , MPT_LINUX_PACKAGE_NAME , MPT_IOCTL_VERSION_LENGTH ) ; karg -> driverVersion [ MPT_IOCTL_VERSION_LENGTH - 1 ] = '\\0' ; karg -> busChangeEvent = 0 ; karg -> hostId = ioc -> pfacts [ port ] . PortSCSIID ; karg -> rsvd [ 0 ] = karg -> rsvd [ 1 ] = 0 ; if ( copy_to_user ( ( char __user * ) arg , karg , data_size ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_getiocinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_iocinfo<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; kfree ( karg ) ; return - EFAULT ; } kfree ( karg ) ; return 0 ; }","static int mptctl_getiocinfo ( MPT_ADAPTER * ioc , unsigned long arg , unsigned int data_size ) {struct pci_dev * pdev ;int iocnum ;",1316
160,"buggy line: if ( IS_ERR ( karg ) ) {printk ( KERN_ERR MYNAM ""%s@%d::mpt_ioctl_iocinfo()<S2SV_blank>-<S2SV_blank>memdup_user<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>[%ld]\\\return PTR_ERR ( karg ) ;}cwe id:CWE-362context: static int  mptctl_getiocinfo ( unsigned long arg , unsigned int data_size )  { struct mpt_ioctl_iocinfo __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_iocinfo * karg ;  MPT_ADAPTER * ioc ;   struct pci_dev * pdev ;  int iocnum ; unsigned int port ; int cim_rev ; struct scsi_device * sdev ; VirtDevice * vdevice ; if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev0 ) ) cim_rev = 0 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev1 ) ) cim_rev = 1 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo ) ) cim_rev = 2 ; else if ( data_size == ( sizeof ( struct mpt_ioctl_iocinfo_rev0 ) + 12 ) ) cim_rev = 0 ; else return - EFAULT ; karg = memdup_user ( uarg , data_size ) ; if ( IS_ERR ( karg ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mpt_ioctl_iocinfo()<S2SV_blank>-<S2SV_blank>memdup_user<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>[%ld]\\n"" , __FILE__ , __LINE__ , PTR_ERR ( karg ) ) ;  return PTR_ERR ( karg ) ;  } if ( ( ( iocnum = mpt_verify_adapter ( karg -> hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_getiocinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; kfree ( karg ) ; return - ENODEV ; } if ( karg -> hdr . maxDataSize != data_size ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_getiocinfo<S2SV_blank>-<S2SV_blank>"" ""Structure<S2SV_blank>size<S2SV_blank>mismatch.<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>completed.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; kfree ( karg ) ; return - EFAULT ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_getiocinfo<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ioc -> bus_type == SAS ) karg -> adapterType = MPT_IOCTL_INTERFACE_SAS ; else if ( ioc -> bus_type == FC ) karg -> adapterType = MPT_IOCTL_INTERFACE_FC ; else karg -> adapterType = MPT_IOCTL_INTERFACE_SCSI ; if ( karg -> hdr . port > 1 ) { kfree ( karg ) ; return - EINVAL ; } port = karg -> hdr . port ; karg -> port = port ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg -> pciId = pdev -> device ; karg -> hwRev = pdev -> revision ; karg -> subSystemDevice = pdev -> subsystem_device ; karg -> subSystemVendor = pdev -> subsystem_vendor ; if ( cim_rev == 1 ) { karg -> pciInfo . u . bits . busNumber = pdev -> bus -> number ; karg -> pciInfo . u . bits . deviceNumber = PCI_SLOT ( pdev -> devfn ) ; karg -> pciInfo . u . bits . functionNumber = PCI_FUNC ( pdev -> devfn ) ; } else if ( cim_rev == 2 ) { karg -> pciInfo . u . bits . busNumber = pdev -> bus -> number ; karg -> pciInfo . u . bits . deviceNumber = PCI_SLOT ( pdev -> devfn ) ; karg -> pciInfo . u . bits . functionNumber = PCI_FUNC ( pdev -> devfn ) ; karg -> pciInfo . segmentID = pci_domain_nr ( pdev -> bus ) ; } karg -> numDevices = 0 ; if ( ioc -> sh ) { shost_for_each_device ( sdev , ioc -> sh ) { vdevice = sdev -> hostdata ; if ( vdevice == NULL || vdevice -> vtarget == NULL ) continue ; if ( vdevice -> vtarget -> tflags & MPT_TARGET_FLAGS_RAID_COMPONENT ) continue ; karg -> numDevices ++ ; } } karg -> FWVersion = ioc -> facts . FWVersion . Word ; karg -> BIOSVersion = ioc -> biosVersion ; strncpy ( karg -> driverVersion , MPT_LINUX_PACKAGE_NAME , MPT_IOCTL_VERSION_LENGTH ) ; karg -> driverVersion [ MPT_IOCTL_VERSION_LENGTH - 1 ] = '\\0' ; karg -> busChangeEvent = 0 ; karg -> hostId = ioc -> pfacts [ port ] . PortSCSIID ; karg -> rsvd [ 0 ] = karg -> rsvd [ 1 ] = 0 ; if ( copy_to_user ( ( char __user * ) arg , karg , data_size ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_getiocinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_iocinfo<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; kfree ( karg ) ; return - EFAULT ; } kfree ( karg ) ; return 0 ; }",if ( IS_ERR ( karg ) ;},1316
161,"buggy line: lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;lua_insert ( L , 2 ) ;cwe id:CWE-119context: int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , ""Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d."" , offset , len ) ; else if ( offset > len ) return luaL_error ( L , ""Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d."" , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , ""Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input."" ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , ""Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input."" ) ; } } if ( ! decode_all ) { int offset = len - c . left ;  lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;  lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;lua_insert ( L , 2 ) ;",1317
162,"buggy line: static inline int mount_entry_on_generic ( struct mntent * mntent ,  const char * path )  {cwe id:CWE-59context: static inline int mount_entry_on_generic ( struct mntent * mntent ,  const char * path )  { unsigned long mntflags ; char * mntdata ; int ret ; bool optional = hasmntopt ( mntent , ""optional"" ) != NULL ; ret = mount_entry_create_dir_file ( mntent , path ) ; if ( ret < 0 ) return optional ? 0 : - 1 ; cull_mntent_opt ( mntent ) ; if ( parse_mntopts ( mntent -> mnt_opts , & mntflags , & mntdata ) < 0 ) { free ( mntdata ) ; return - 1 ; } ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type ,  mntflags , mntdata , optional ) ;  free ( mntdata ) ; return ret ; }","static inline int mount_entry_on_generic ( struct mntent * mntent , const char * path , const char * rootfs ) {",1318
163,"buggy line: ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type ,  mntflags , mntdata , optional ) ;free ( mntdata ) ;cwe id:CWE-59context: static inline int mount_entry_on_generic ( struct mntent * mntent ,  const char * path )  { unsigned long mntflags ; char * mntdata ; int ret ; bool optional = hasmntopt ( mntent , ""optional"" ) != NULL ; ret = mount_entry_create_dir_file ( mntent , path ) ; if ( ret < 0 ) return optional ? 0 : - 1 ; cull_mntent_opt ( mntent ) ; if ( parse_mntopts ( mntent -> mnt_opts , & mntflags , & mntdata ) < 0 ) { free ( mntdata ) ; return - 1 ; } ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type ,  mntflags , mntdata , optional ) ;  free ( mntdata ) ; return ret ; }","ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type , mntflags , mntdata , optional , rootfs ) ;free ( mntdata ) ;",1318
164,"buggy line: pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 3 *  sizeof ( * pixels ) ) ;cwe id:CWE-119context: static Image * ReadHRZImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; ssize_t count , y ; size_t length ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 256 ; image -> rows = 240 ; image -> depth = 8 ;  pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 3 *  sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) ( 3 * image -> columns ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( 4 * * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( 4 * * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( 4 * * p ++ ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( SetImageProgress ( image , LoadImageTag , y , image -> rows ) == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 3 * sizeof ( * pixels ) ) ;",1319
165,"buggy line: int i , len ;size_t len_sent = 0 ;const char __user * p ;char * buf ;p = ( const char __user * ) current -> mm -> arg_start ;audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ;buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ;if ( ! buf ) {audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ;for ( i = 0 ;i < context -> execve . argc ;i ++ ) {len = audit_log_single_execve_arg ( context , ab , i , & len_sent , p , buf ) ;if ( len <= 0 ) break ;p += len ;kfree ( buf ) ;cwe id:CWE-362context: static void audit_log_execve_info ( struct audit_context * context , struct audit_buffer * * ab ) {  int i , len ;  size_t len_sent = 0 ;  const char __user * p ;  char * buf ; p = ( const char __user * ) current -> mm -> arg_start ;  audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ;   buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ;   if ( ! buf ) {  audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ; return ; }  for ( i = 0 ; i < context -> execve . argc ; i ++ ) {  len = audit_log_single_execve_arg ( context , ab , i , & len_sent , p , buf ) ; if ( len <= 0 ) break ; p += len ; } kfree ( buf ) ; }","long len_max ;long len_rem ;long len_full ;long len_buf ;long len_abuf ;long len_tmp ;bool require_data ;bool encode ;unsigned int iter ;unsigned int arg ;char * buf_head ;char * buf ;const char __user * p = ( const char __user * ) current -> mm -> arg_start ;char abuf [ 96 ] ;WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ;len_max = MAX_EXECVE_AUDIT_LEN ;buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ;if ( ! buf_head ) {audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ;buf = buf_head ;audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ;len_rem = len_max ;len_buf = 0 ;len_full = 0 ;require_data = true ;encode = false ;iter = 0 ;arg = 0 ;do {if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ;if ( require_data ) {if ( buf != buf_head ) {memmove ( buf_head , buf , len_buf ) ;buf = buf_head ;len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ;if ( len_tmp == - EFAULT ) {send_sig ( SIGKILL , current , 0 ) ;goto out ;}else if ( len_tmp == ( len_max - len_buf ) ) {require_data = true ;encode = true ;len_full = len_full * 2 ;p += len_tmp ;}else {require_data = false ;if ( ! * ab ) goto out ;}len_tmp = 0 ;if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) {if ( iter == 0 ) {len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d_len=%lu"" , arg , len_full ) ;}len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d[%d]="" , arg , iter ++ ) ;}else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d="" , arg ) ;WARN_ON ( len_tmp >= sizeof ( abuf ) ) ;abuf [ sizeof ( abuf ) - 1 ] = \'\\\\0\' ;audit_log_format ( * ab , ""%s"" , abuf ) ;len_rem -= len_tmp ;len_tmp = len_buf ;if ( encode ) {if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ;audit_log_n_hex ( * ab , buf , len_tmp ) ;len_rem -= len_tmp * 2 ;len_abuf -= len_tmp * 2 ;}else {if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ;audit_log_n_string ( * ab , buf , len_tmp ) ;len_rem -= len_tmp + 2 ;len_abuf -= len_tmp ;}len_buf -= len_tmp ;buf += len_tmp ;}if ( ( len_buf == 0 ) && ! require_data ) {arg ++ ;iter = 0 ;len_full = 0 ;require_data = true ;encode = false ;}}while ( arg < context -> execve . argc ) ;out : kfree ( buf_head ) ;",1320
166,"buggy line: fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ;if ( fd < 0 ) return - errno ;cwe id:CWE-264context: int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ;  fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ;  if ( fd < 0 ) return - errno ; if ( mode != MODE_INVALID ) { r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }","fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode ) ;if ( fd < 0 ) return - errno ;",1321
167,"buggy line: int pkt_len ;char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) {* err = file_error ( wth -> random_fh , err_info ) ;if ( * err == 0 ) {* err = WTAP_ERR_SHORT_READ ;}return FALSE ;}pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir ,  cap_dst , err , err_info ) ;if ( pkt_len == - 1 )  return FALSE ;if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , cap_dst , phdr , buf , err , err_info ) ) return FALSE ;return TRUE ;cwe id:CWE-20context: static gboolean netscreen_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {  int pkt_len ;   char line [ NETSCREEN_LINE_LENGTH ] ;  char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) { return FALSE ; } if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; }  pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir ,  cap_dst , err , err_info ) ;  if ( pkt_len == - 1 )  return FALSE ; if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , cap_dst , phdr , buf , err , err_info ) ) return FALSE ; return TRUE ; }","char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;return parse_netscreen_packet ( wth -> random_fh , phdr , buf , line , cap_int , & cap_dir , cap_dst , err , err_info ) ;",1322
168,"buggy line: inline void update_rq_clock ( struct rq * rq )  {if ( ! rq -> skip_clock_update ) {u64 irq_time ;rq -> clock = sched_clock_cpu ( cpu ) ;}cwe id:CWE-000context: inline void update_rq_clock ( struct rq * rq )  {  if ( ! rq -> skip_clock_update ) { int cpu = cpu_of ( rq ) ;  u64 irq_time ;  rq -> clock = sched_clock_cpu ( cpu ) ; irq_time = irq_time_cpu ( cpu ) ; if ( rq -> clock - irq_time > rq -> clock_task ) rq -> clock_task = rq -> clock - irq_time ; sched_irq_time_avg_update ( rq , irq_time ) ; }  } ",inline void update_rq_clock ( struct rq * rq ) {u64 irq_time ;if ( rq -> skip_clock_update ) return ;rq -> clock = sched_clock_cpu ( cpu ) ;,1323
169,"buggy line: cwe id:CWE-125context: static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) {  switch ( depth )  { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels >> 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } }  CheckNumberCompactPixels ;  compact_pixels ++ ; } } return ( i ) ; }",CheckNumberCompactPixels ;,1324
170,"buggy line: }continue ;}length ++ ;for ( j = 0 ;j < ( ssize_t ) length ;j ++ ) {switch ( depth )  {case 1 : {CheckNumberPixels ( 8 ) ;* pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ;break ;}case 2 : {CheckNumberPixels ( 4 ) ;* pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ;* pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ;* pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ;* pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ;break ;}case 4 : {CheckNumberPixels ( 2 ) ;* pixels ++ = ( * compact_pixels >> 4 ) & 0xff ;* pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ;break ;}default : {CheckNumberPixels ( 1 ) ;* pixels ++ = ( * compact_pixels ) ;break ;}}CheckNumberCompactPixels ;compact_pixels ++ ;cwe id:CWE-125context: static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) {  switch ( depth )  { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels >> 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } }  CheckNumberCompactPixels ;  compact_pixels ++ ; } } return ( i ) ; }",compact_pixels ++ ;,1324
171,"buggy line: raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ;}cwe id:CWE-120context: static void process_options ( argc , argv ) int argc ; char * argv [ ] ; { int i , l ; while ( argc > 1 && argv [ 1 ] [ 0 ] == '-' ) { argv ++ ; argc -- ; l = ( int ) strlen ( * argv ) ; if ( l < 4 ) l = 4 ; switch ( argv [ 0 ] [ 1 ] ) { case 'D' : case 'd' : if ( ( argv [ 0 ] [ 1 ] == 'D' && ! argv [ 0 ] [ 2 ] ) || ! strcmpi ( * argv , ""-debug"" ) ) { wizard = TRUE , discover = FALSE ; } else if ( ! strncmpi ( * argv , ""-DECgraphics"" , l ) ) { load_symset ( ""DECGraphics"" , PRIMARY ) ; switch_symbols ( TRUE ) ; } else {  raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ;  } break ; case 'X' : discover = TRUE , wizard = FALSE ; break ; # ifdef NEWS case 'n' : iflags . news = FALSE ; break ; # endif case 'u' : if ( argv [ 0 ] [ 2 ] ) { ( void ) strncpy ( plname , argv [ 0 ] + 2 , sizeof plname - 1 ) ; } else if ( argc > 1 ) { argc -- ; argv ++ ; ( void ) strncpy ( plname , argv [ 0 ] , sizeof plname - 1 ) ; } else { raw_print ( ""Player<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-u"" ) ; } break ; case 'I' : case 'i' : if ( ! strncmpi ( * argv , ""-IBMgraphics"" , l ) ) { load_symset ( ""IBMGraphics"" , PRIMARY ) ; load_symset ( ""RogueIBM"" , ROGUESET ) ; switch_symbols ( TRUE ) ; } else {  raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ;  } break ; case 'p' : if ( argv [ 0 ] [ 2 ] ) { if ( ( i = str2role ( & argv [ 0 ] [ 2 ] ) ) >= 0 ) flags . initrole = i ; } else if ( argc > 1 ) { argc -- ; argv ++ ; if ( ( i = str2role ( argv [ 0 ] ) ) >= 0 ) flags . initrole = i ; } break ; case 'r' : if ( argv [ 0 ] [ 2 ] ) { if ( ( i = str2race ( & argv [ 0 ] [ 2 ] ) ) >= 0 ) flags . initrace = i ; } else if ( argc > 1 ) { argc -- ; argv ++ ; if ( ( i = str2race ( argv [ 0 ] ) ) >= 0 ) flags . initrace = i ; } break ; case 'w' : config_error_init ( FALSE , ""command<S2SV_blank>line"" , FALSE ) ; choose_windows ( & argv [ 0 ] [ 2 ] ) ; config_error_done ( ) ; break ; case '@' : flags . randomall = 1 ; break ; default : if ( ( i = str2role ( & argv [ 0 ] [ 1 ] ) ) >= 0 ) { flags . initrole = i ; break ; } } } # ifdef SYSCF if ( argc > 1 ) raw_printf ( ""MAXPLAYERS<S2SV_blank>are<S2SV_blank>set<S2SV_blank>in<S2SV_blank>sysconf<S2SV_blank>file.\\n"" ) ; # else if ( argc > 1 ) locknum = atoi ( argv [ 1 ] ) ; # endif # ifdef MAX_NR_OF_PLAYERS if ( ! locknum || locknum > MAX_NR_OF_PLAYERS ) locknum = MAX_NR_OF_PLAYERS ; # endif # ifdef SYSCF if ( ! locknum || ( sysopt . maxplayers && locknum > sysopt . maxplayers ) ) locknum = sysopt . maxplayers ; # endif }","raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%.60s"" , * argv ) ;}",1325
172,"buggy line: raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ;}cwe id:CWE-120context: static void process_options ( argc , argv ) int argc ; char * argv [ ] ; { int i , l ; while ( argc > 1 && argv [ 1 ] [ 0 ] == '-' ) { argv ++ ; argc -- ; l = ( int ) strlen ( * argv ) ; if ( l < 4 ) l = 4 ; switch ( argv [ 0 ] [ 1 ] ) { case 'D' : case 'd' : if ( ( argv [ 0 ] [ 1 ] == 'D' && ! argv [ 0 ] [ 2 ] ) || ! strcmpi ( * argv , ""-debug"" ) ) { wizard = TRUE , discover = FALSE ; } else if ( ! strncmpi ( * argv , ""-DECgraphics"" , l ) ) { load_symset ( ""DECGraphics"" , PRIMARY ) ; switch_symbols ( TRUE ) ; } else {  raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ;  } break ; case 'X' : discover = TRUE , wizard = FALSE ; break ; # ifdef NEWS case 'n' : iflags . news = FALSE ; break ; # endif case 'u' : if ( argv [ 0 ] [ 2 ] ) { ( void ) strncpy ( plname , argv [ 0 ] + 2 , sizeof plname - 1 ) ; } else if ( argc > 1 ) { argc -- ; argv ++ ; ( void ) strncpy ( plname , argv [ 0 ] , sizeof plname - 1 ) ; } else { raw_print ( ""Player<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-u"" ) ; } break ; case 'I' : case 'i' : if ( ! strncmpi ( * argv , ""-IBMgraphics"" , l ) ) { load_symset ( ""IBMGraphics"" , PRIMARY ) ; load_symset ( ""RogueIBM"" , ROGUESET ) ; switch_symbols ( TRUE ) ; } else {  raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ;  } break ; case 'p' : if ( argv [ 0 ] [ 2 ] ) { if ( ( i = str2role ( & argv [ 0 ] [ 2 ] ) ) >= 0 ) flags . initrole = i ; } else if ( argc > 1 ) { argc -- ; argv ++ ; if ( ( i = str2role ( argv [ 0 ] ) ) >= 0 ) flags . initrole = i ; } break ; case 'r' : if ( argv [ 0 ] [ 2 ] ) { if ( ( i = str2race ( & argv [ 0 ] [ 2 ] ) ) >= 0 ) flags . initrace = i ; } else if ( argc > 1 ) { argc -- ; argv ++ ; if ( ( i = str2race ( argv [ 0 ] ) ) >= 0 ) flags . initrace = i ; } break ; case 'w' : config_error_init ( FALSE , ""command<S2SV_blank>line"" , FALSE ) ; choose_windows ( & argv [ 0 ] [ 2 ] ) ; config_error_done ( ) ; break ; case '@' : flags . randomall = 1 ; break ; default : if ( ( i = str2role ( & argv [ 0 ] [ 1 ] ) ) >= 0 ) { flags . initrole = i ; break ; } } } # ifdef SYSCF if ( argc > 1 ) raw_printf ( ""MAXPLAYERS<S2SV_blank>are<S2SV_blank>set<S2SV_blank>in<S2SV_blank>sysconf<S2SV_blank>file.\\n"" ) ; # else if ( argc > 1 ) locknum = atoi ( argv [ 1 ] ) ; # endif # ifdef MAX_NR_OF_PLAYERS if ( ! locknum || locknum > MAX_NR_OF_PLAYERS ) locknum = MAX_NR_OF_PLAYERS ; # endif # ifdef SYSCF if ( ! locknum || ( sysopt . maxplayers && locknum > sysopt . maxplayers ) ) locknum = sysopt . maxplayers ; # endif }","raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%.60s"" , * argv ) ;}",1325
173,"buggy line: struct blkif_response resp ;unsigned long flags ;resp . id = id ;resp . operation = op ;resp . status = st ;case BLKIF_PROTOCOL_NATIVE :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;case BLKIF_PROTOCOL_X86_32 :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;case BLKIF_PROTOCOL_X86_64 :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;}blk_rings -> common . rsp_prod_pvt ++ ;cwe id:CWE-200context: static void make_response ( struct xen_blkif_ring * ring , u64 id , unsigned short op , int st ) {  struct blkif_response resp ;  unsigned long flags ; union blkif_back_rings * blk_rings ; int notify ;  resp . id = id ;  resp . operation = op ; resp . status = st ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags ) ; blk_rings = & ring -> blk_rings ; switch ( ring -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_32 :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_64 :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ; break ; default : BUG ( ) ;  }  blk_rings -> common . rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & blk_rings -> common , notify ) ; spin_unlock_irqrestore ( & ring -> blk_ring_lock , flags ) ; if ( notify ) notify_remote_via_irq ( ring -> irq ) ; }","struct blkif_response * resp ;unsigned long flags ;case BLKIF_PROTOCOL_NATIVE : resp = RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) ;case BLKIF_PROTOCOL_X86_32 : memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ;case BLKIF_PROTOCOL_X86_64 : memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) ;}resp -> id = id ;resp -> operation = op ;resp -> status = st ;blk_rings -> common . rsp_prod_pvt ++ ;",1326
174,"buggy line: if ( ! ( mask & KADM5_ATTRIBUTES ) ||  ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ;cwe id:CWE-000context: static void check_1_6_dummy ( kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * * passptr ) { int i ; char * password = * passptr ;  if ( ! ( mask & KADM5_ATTRIBUTES ) ||  ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ; for ( i = 0 ; ( unsigned char ) password [ i ] == i + 1 ; i ++ ) ; if ( password [ i ] != '\\0' || i != 255 ) return ; * passptr = NULL ; }",if ( password == NULL || ! ( mask & KADM5_ATTRIBUTES ) || ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ;,1327
175,"buggy line: if ( ! n || ! buf || ! buf_size ) {datao = 6 + n -> offset ;if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;return ;}if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) ||  ( datao + 2 > buf_size ) ) {cwe id:CWE-125context: static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ;  if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ;  if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) ||  ( datao + 2 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ;  if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA ,  ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;  break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ;  n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;   n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;  n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ;  if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) ||  ( dataofs + s >= buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }","if ( CHECKOVERFLOW ( datao , buf_size , 12 ) ) {if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || ( datao + 2 > buf_size ) ) {",1328
176,"buggy line: if ( ! n -> entries ) {EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ;return ;}tcount = 0 ;for ( i = c , o = datao ;i ;-- i , o += 12 ) {size_t s ;if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA ,  ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;if ( s ) {size_t dataofs = o + 8 ;if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ;if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) ||  ( dataofs + s >= buf_size ) ) {cwe id:CWE-125context: static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ;  if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ;  if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) ||  ( datao + 2 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ;  if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA ,  ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;  break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ;  n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;   n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;  n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ;  if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) ||  ( dataofs + s >= buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }","if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;}n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ;if ( exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ;continue ;}n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ;if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) {",1328
177,"buggy line: cwe id:CWE-125context: static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ;  if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ;  if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) ||  ( datao + 2 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ;  if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA ,  ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;  break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ;  n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;   n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;  n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ;  if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) ||  ( dataofs + s >= buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }","continue ;}memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ;",1328
178,"buggy line: if ( ! dirout ) return ERROR_INT ( ""dirout<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ;if ( ! rootname ) return ERROR_INT ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ;if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ;if ( thumbwidth < MIN_THUMB_WIDTH ) {L_WARNING ( ""thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\\thumbwidth = MIN_THUMB_WIDTH ;}if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ;if ( viewwidth < MIN_VIEW_WIDTH ) {L_WARNING ( ""viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\\viewwidth = MIN_VIEW_WIDTH ;}# ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir<S2SV_blank>-p<S2SV_blank>%s"" , dirout ) ;ret = system ( charbuf ) ;# else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ;# endif if ( ret ) {L_ERROR ( ""output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\\return 1 ;}if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( ""safiles<S2SV_blank>not<S2SV_blank>made"" , procName , 1 ) ;sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ;mainname = stringNew ( charbuf ) ;sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;linkname = stringNew ( charbuf ) ;cwe id:CWE-119context: static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char charbuf [ 512 ] ; char htmlstring [ ] = ""<html>"" ; char framestring [ ] = ""</frameset></html>"" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( ""pixHtmlViewer"" ) ; if ( ! dirin ) return ERROR_INT ( ""dirin<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( ""dirout<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( ""thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( ""viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir<S2SV_blank>-p<S2SV_blank>%s"" , dirout ) ; ret = system ( charbuf ) ; # else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ; # endif if ( ret ) { L_ERROR ( ""output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\n"" , procName , dirout ) ; return 1 ; } if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( ""safiles<S2SV_blank>not<S2SV_blank>made"" , procName , 1 ) ;  sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ;  mainname = stringNew ( charbuf ) ;  sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;  linkname = stringNew ( charbuf ) ; linknameshort = stringJoin ( rootname , ""-links.html"" ) ; sathumbs = sarrayCreate ( 0 ) ; saviews = sarrayCreate ( 0 ) ; nfiles = sarrayGetCount ( safiles ) ; index = 0 ; for ( i = 0 ; i < nfiles ; i ++ ) { fname = sarrayGetString ( safiles , i , L_NOCOPY ) ; fullname = genPathname ( dirin , fname ) ; fprintf ( stderr , ""name:<S2SV_blank>%s\\n"" , fullname ) ; if ( ( pix = pixRead ( fullname ) ) == NULL ) { fprintf ( stderr , ""file<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>a<S2SV_blank>readable<S2SV_blank>image\\n"" , fullname ) ; lept_free ( fullname ) ; continue ; } lept_free ( fullname ) ; pixGetDimensions ( pix , & w , NULL , & d ) ; factor = ( l_float32 ) thumbwidth / ( l_float32 ) w ; pixthumb = pixScale ( pix , factor , factor ) ;  sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ;  sarrayAddString ( sathumbs , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixthumb ) ; lept_free ( outname ) ; pixDestroy ( & pixthumb ) ; factor = ( l_float32 ) viewwidth / ( l_float32 ) w ; if ( factor >= 1.0 ) pixview = pixClone ( pix ) ; else pixview = pixScale ( pix , factor , factor ) ; snprintf ( charbuf , sizeof ( charbuf ) , ""%s_view_%03d"" , rootname , index ) ; sarrayAddString ( saviews , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixview ) ; lept_free ( outname ) ; pixDestroy ( & pixview ) ; pixDestroy ( & pix ) ; index ++ ; } sahtml = sarrayCreate ( 0 ) ; sarrayAddString ( sahtml , htmlstring , L_COPY ) ; sprintf ( charbuf , ""<frameset<S2SV_blank>cols=\\""%d,<S2SV_blank>*\\"">"" , thumbwidth + 30 ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""thumbs\\""<S2SV_blank>src=\\""%s\\"">"" , linknameshort ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""views\\""<S2SV_blank>src=\\""%s\\"">"" , sarrayGetString ( saviews , 0 , L_NOCOPY ) ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sarrayAddString ( sahtml , framestring , L_COPY ) ; shtml = sarrayToString ( sahtml , 1 ) ; l_binaryWrite ( mainname , ""w"" , shtml , strlen ( shtml ) ) ; fprintf ( stderr , ""******************************************\\n"" ""Writing<S2SV_blank>html<S2SV_blank>file:<S2SV_blank>%s\\n"" ""******************************************\\n"" , mainname ) ; lept_free ( shtml ) ; lept_free ( mainname ) ; nimages = sarrayGetCount ( saviews ) ; fprintf ( stderr , ""num.<S2SV_blank>images<S2SV_blank>=<S2SV_blank>%d\\n"" , nimages ) ; salink = sarrayCreate ( 0 ) ; for ( i = 0 ; i < nimages ; i ++ ) { viewfile = sarrayGetString ( saviews , i , L_NOCOPY ) ; thumbfile = sarrayGetString ( sathumbs , i , L_NOCOPY ) ; sprintf ( charbuf , ""<a<S2SV_blank>href=\\""%s\\""<S2SV_blank>TARGET=views><img<S2SV_blank>src=\\""%s\\""></a>"" , viewfile , thumbfile ) ; sarrayAddString ( salink , charbuf , L_COPY ) ; } slink = sarrayToString ( salink , 1 ) ; l_binaryWrite ( linkname , ""w"" , slink , strlen ( slink ) ) ; lept_free ( slink ) ; lept_free ( linkname ) ; lept_free ( linknameshort ) ; sarrayDestroy ( & safiles ) ; sarrayDestroy ( & sathumbs ) ; sarrayDestroy ( & saviews ) ; sarrayDestroy ( & sahtml ) ; sarrayDestroy ( & salink ) ; return 0 ; }","snprintf ( charbuf , sizeof ( charbuf ) , ""%s/%s.html"" , dirout , rootname ) ;mainname = stringNew ( charbuf ) ;sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;linkname = stringNew ( charbuf ) ;",1329
179,"buggy line: sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ;sarrayAddString ( sathumbs , charbuf , L_COPY ) ;cwe id:CWE-119context: static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char charbuf [ 512 ] ; char htmlstring [ ] = ""<html>"" ; char framestring [ ] = ""</frameset></html>"" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( ""pixHtmlViewer"" ) ; if ( ! dirin ) return ERROR_INT ( ""dirin<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( ""dirout<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( ""thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( ""viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir<S2SV_blank>-p<S2SV_blank>%s"" , dirout ) ; ret = system ( charbuf ) ; # else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ; # endif if ( ret ) { L_ERROR ( ""output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\n"" , procName , dirout ) ; return 1 ; } if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( ""safiles<S2SV_blank>not<S2SV_blank>made"" , procName , 1 ) ;  sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ;  mainname = stringNew ( charbuf ) ;  sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;  linkname = stringNew ( charbuf ) ; linknameshort = stringJoin ( rootname , ""-links.html"" ) ; sathumbs = sarrayCreate ( 0 ) ; saviews = sarrayCreate ( 0 ) ; nfiles = sarrayGetCount ( safiles ) ; index = 0 ; for ( i = 0 ; i < nfiles ; i ++ ) { fname = sarrayGetString ( safiles , i , L_NOCOPY ) ; fullname = genPathname ( dirin , fname ) ; fprintf ( stderr , ""name:<S2SV_blank>%s\\n"" , fullname ) ; if ( ( pix = pixRead ( fullname ) ) == NULL ) { fprintf ( stderr , ""file<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>a<S2SV_blank>readable<S2SV_blank>image\\n"" , fullname ) ; lept_free ( fullname ) ; continue ; } lept_free ( fullname ) ; pixGetDimensions ( pix , & w , NULL , & d ) ; factor = ( l_float32 ) thumbwidth / ( l_float32 ) w ; pixthumb = pixScale ( pix , factor , factor ) ;  sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ;  sarrayAddString ( sathumbs , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixthumb ) ; lept_free ( outname ) ; pixDestroy ( & pixthumb ) ; factor = ( l_float32 ) viewwidth / ( l_float32 ) w ; if ( factor >= 1.0 ) pixview = pixClone ( pix ) ; else pixview = pixScale ( pix , factor , factor ) ; snprintf ( charbuf , sizeof ( charbuf ) , ""%s_view_%03d"" , rootname , index ) ; sarrayAddString ( saviews , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixview ) ; lept_free ( outname ) ; pixDestroy ( & pixview ) ; pixDestroy ( & pix ) ; index ++ ; } sahtml = sarrayCreate ( 0 ) ; sarrayAddString ( sahtml , htmlstring , L_COPY ) ; sprintf ( charbuf , ""<frameset<S2SV_blank>cols=\\""%d,<S2SV_blank>*\\"">"" , thumbwidth + 30 ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""thumbs\\""<S2SV_blank>src=\\""%s\\"">"" , linknameshort ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""views\\""<S2SV_blank>src=\\""%s\\"">"" , sarrayGetString ( saviews , 0 , L_NOCOPY ) ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sarrayAddString ( sahtml , framestring , L_COPY ) ; shtml = sarrayToString ( sahtml , 1 ) ; l_binaryWrite ( mainname , ""w"" , shtml , strlen ( shtml ) ) ; fprintf ( stderr , ""******************************************\\n"" ""Writing<S2SV_blank>html<S2SV_blank>file:<S2SV_blank>%s\\n"" ""******************************************\\n"" , mainname ) ; lept_free ( shtml ) ; lept_free ( mainname ) ; nimages = sarrayGetCount ( saviews ) ; fprintf ( stderr , ""num.<S2SV_blank>images<S2SV_blank>=<S2SV_blank>%d\\n"" , nimages ) ; salink = sarrayCreate ( 0 ) ; for ( i = 0 ; i < nimages ; i ++ ) { viewfile = sarrayGetString ( saviews , i , L_NOCOPY ) ; thumbfile = sarrayGetString ( sathumbs , i , L_NOCOPY ) ; sprintf ( charbuf , ""<a<S2SV_blank>href=\\""%s\\""<S2SV_blank>TARGET=views><img<S2SV_blank>src=\\""%s\\""></a>"" , viewfile , thumbfile ) ; sarrayAddString ( salink , charbuf , L_COPY ) ; } slink = sarrayToString ( salink , 1 ) ; l_binaryWrite ( linkname , ""w"" , slink , strlen ( slink ) ) ; lept_free ( slink ) ; lept_free ( linkname ) ; lept_free ( linknameshort ) ; sarrayDestroy ( & safiles ) ; sarrayDestroy ( & sathumbs ) ; sarrayDestroy ( & saviews ) ; sarrayDestroy ( & sahtml ) ; sarrayDestroy ( & salink ) ; return 0 ; }","snprintf ( charbuf , sizeof ( charbuf ) , ""%s_thumb_%03d"" , rootname , index ) ;sarrayAddString ( sathumbs , charbuf , L_COPY ) ;",1329
180,"buggy line: snapend_save = ndo -> ndo_snapend ;ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ;cwe id:CWE-125context: void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , ""#%d<S2SV_blank>%%s<S2SV_blank>unreachable"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , ""redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , ""router<S2SV_blank>advertisement"" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , ""<S2SV_blank>lifetime<S2SV_blank>"" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u"" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u"" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u:%02u"" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>%d:"" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>[size<S2SV_blank>%d]"" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>{%s<S2SV_blank>%u}"" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = ""time<S2SV_blank>exceeded<S2SV_blank>in-transit"" ; break ; case ICMP_TIMXCEED_REASS : str = ""ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded"" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>exceeded-#%d"" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%d"" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%d"" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>recv<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>xmit<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , ""type-#%d"" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , ""ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , icmp_sum ; if ( ND_TTEST2 ( * bp , plen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; if ( sum != 0 ) { icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)"" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; ip = ( const struct ip * ) bp ;  snapend_save = ndo -> ndo_snapend ;  ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , ""\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u"" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? ""in"" : """" , hlen ) ) ; } hlen -= 4 ; obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( icmp_mpls_ext_obj_values , ""unknown"" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u"" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp]"" ) ) ; }","snapend_save = ndo -> ndo_snapend ;ND_TCHECK_16BITS ( & ip -> ip_len ) ;ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ;",1330
181,"buggy line: struct dentry * dir ;struct fscrypt_info * ci ;cwe id:CWE-416context: static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) {  struct dentry * dir ;  struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; }  ci = d_inode ( dir ) -> i_crypt_info ;  if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ;  dir_has_key = ( ci != NULL ) ;  dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",struct dentry * dir ;,1331
182,"buggy line: ci = d_inode ( dir ) -> i_crypt_info ;if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ;dir_has_key = ( ci != NULL ) ;dput ( dir ) ;cwe id:CWE-416context: static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) {  struct dentry * dir ;  struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; }  ci = d_inode ( dir ) -> i_crypt_info ;  if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ;  dir_has_key = ( ci != NULL ) ;  dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",dir_has_key = ( ci != NULL ) ;dput ( dir ) ;,1331
183,"buggy line: void unbind_ports ( void ) {SERVICE_OPTIONS * opt ;CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ;opt = service_options . next ;service_options . next = NULL ;service_free ( & service_options ) ;cwe id:CWE-295context:  void unbind_ports ( void ) {  SERVICE_OPTIONS * opt ; s_poll_init ( fds , 1 ) ;  CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ;  opt = service_options . next ;  service_options . next = NULL ;  service_free ( & service_options ) ; while ( opt ) { unsigned i ; s_log ( LOG_DEBUG , ""Unbinding<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) unbind_port ( opt , i ) ; if ( opt -> exec_name && opt -> connect_addr . names ) { opt -> option . retry = 0 ; }  if ( opt -> ctx )  SSL_CTX_flush_sessions ( opt -> ctx , ( long ) time ( NULL ) + opt -> session_timeout + 1 ) ; s_log ( LOG_DEBUG , ""Service<S2SV_blank>[%s]<S2SV_blank>closed"" , opt -> servname ) ;  {  SERVICE_OPTIONS * garbage = opt ; opt = opt -> next ; garbage -> next = NULL ; service_free ( garbage ) ; } } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }",NOEXPORT void unbind_ports ( void ) {SERVICE_OPTIONS * opt ;for ( opt = service_options . next ;service_options . next = NULL ;service_free ( & service_options ) ;,1332
184,"buggy line: if ( opt -> ctx )  SSL_CTX_flush_sessions ( opt -> ctx , ( long ) time ( NULL ) + opt -> session_timeout + 1 ) ;{SERVICE_OPTIONS * garbage = opt ;opt = opt -> next ;garbage -> next = NULL ;service_free ( garbage ) ;CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ;}cwe id:CWE-295context:  void unbind_ports ( void ) {  SERVICE_OPTIONS * opt ; s_poll_init ( fds , 1 ) ;  CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ;  opt = service_options . next ;  service_options . next = NULL ;  service_free ( & service_options ) ; while ( opt ) { unsigned i ; s_log ( LOG_DEBUG , ""Unbinding<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) unbind_port ( opt , i ) ; if ( opt -> exec_name && opt -> connect_addr . names ) { opt -> option . retry = 0 ; }  if ( opt -> ctx )  SSL_CTX_flush_sessions ( opt -> ctx , ( long ) time ( NULL ) + opt -> session_timeout + 1 ) ; s_log ( LOG_DEBUG , ""Service<S2SV_blank>[%s]<S2SV_blank>closed"" , opt -> servname ) ;  {  SERVICE_OPTIONS * garbage = opt ; opt = opt -> next ; garbage -> next = NULL ; service_free ( garbage ) ; } } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }","
",1332
185,"buggy line: numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ;if ( argc > MAX_PACK_ARGS ) {archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ;return ARCHIVE_WARN ;}cwe id:CWE-119context: static int parse_device ( dev_t * pdev , struct archive * a , char * val ) { # define MAX_PACK_ARGS 3 unsigned long numbers [ MAX_PACK_ARGS ] ; char * p , * dev ; int argc ; pack_t * pack ; dev_t result ; const char * error = NULL ; memset ( pdev , 0 , sizeof ( * pdev ) ) ; if ( ( dev = strchr ( val , ',' ) ) != NULL ) { * dev ++ = '\\0' ; if ( ( pack = pack_find ( val ) ) == NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Unknown<S2SV_blank>format<S2SV_blank>`%s\'"" , val ) ; return ARCHIVE_WARN ; } argc = 0 ; while ( ( p = la_strsep ( & dev , "","" ) ) != NULL ) { if ( * p == '\\0' ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Missing<S2SV_blank>number"" ) ; return ARCHIVE_WARN ; }  numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ;   if ( argc > MAX_PACK_ARGS ) {  archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } } if ( argc < 2 ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Not<S2SV_blank>enough<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } result = ( * pack ) ( argc , numbers , & error ) ; if ( error != NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""%s"" , error ) ; return ARCHIVE_WARN ; } } else { result = ( dev_t ) mtree_atol ( & val ) ; } * pdev = result ; return ARCHIVE_OK ; # undef MAX_PACK_ARGS }","if ( argc >= MAX_PACK_ARGS ) {archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ;return ARCHIVE_WARN ;}numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ;",1333
186,"buggy line: context . Xtogo = i -> width ;context . curY = i -> posY ;cwe id:CWE-119context: static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ;  context . Xtogo = i -> width ;  context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Local<S2SV_blank>palette\\n"" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , ""interlaced<S2SV_blank>"" ) ; fprintf ( i -> parent -> log , ""img<S2SV_blank>pos(%hu,%hu)<S2SV_blank>size<S2SV_blank>%hux%hu<S2SV_blank>palbits=%hhu<S2SV_blank>imgbits=%hhu<S2SV_blank>ncolors=%hu\\n"" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""End<S2SV_blank>of<S2SV_blank>image<S2SV_blank>code\\n"" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""assez<S2SV_blank>de<S2SV_blank>pixels,<S2SV_blank>On<S2SV_blank>se<S2SV_blank>casse<S2SV_blank>!\\n"" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Code<S2SV_blank>clear<S2SV_blank>(free=%hu)<S2SV_blank>npix=%ld\\n"" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ; WritePixel ( i , & context , casspecial ) ; npix -- ; } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ; WritePixels ( i , & context , stackp , stack_top - stackp ) ; npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }","if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) {# if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\\# endif return - 1 ;}if ( ( i -> posX + i -> width ) > i -> parent -> width ) {# if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\\# endif i -> posX = i -> parent -> width - i -> width ;}if ( ( i -> posY + i -> height ) > i -> parent -> height ) {# if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\\# endif i -> posY = i -> parent -> height - i -> height ;}context . Xtogo = i -> width ;context . curY = i -> posY ;",1334
187,"buggy line: if ( n < 0 ) {if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ;syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ;goto error ;}if ( n == 0 ) {syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ;goto error ;}t = time ( NULL ) ;type = buf [ 0 ] ;p = buf + 1 ;DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ;cwe id:CWE-125context: void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0,<S2SV_blank>type=%d)"" , type ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case MINISSDPD_GET_VERSION : rp = rbuf ; CODELENGTH ( ( sizeof ( MINISSDPD_VERSION ) - 1 ) , rp ) ; memcpy ( rp , MINISSDPD_VERSION , sizeof ( MINISSDPD_VERSION ) - 1 ) ; rp += ( sizeof ( MINISSDPD_VERSION ) - 1 ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ; while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ; if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>already<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; sendNotifications ( NOTIF_NEW , NULL , newserv ) ; newserv = NULL ; break ; case MINISSDPD_NOTIF : rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } req -> is_notify = 1 ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }","if ( l > ( unsigned ) ( buf + n - p ) ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ;",1335
188,"buggy line: if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) {syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ;goto error ;}break ;case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ;while ( d && ( nrep < 255 ) ) {if ( d -> t < t ) {syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ;}else {if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ;if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) {m = d -> headers [ HEADER_LOCATION ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ;rp += d -> headers [ HEADER_LOCATION ] . l ;m = d -> headers [ HEADER_NT ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ;rp += d -> headers [ HEADER_NT ] . l ;m = d -> headers [ HEADER_USN ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ;rp += d -> headers [ HEADER_USN ] . l ;nrep ++ ;}}d = d -> next ;}for ( serv = servicelisthead . lh_first ;serv && ( nrep < 255 ) ;serv = serv -> entries . le_next ) {if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ;if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) {m = strlen ( serv -> location ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> location , m ) ;rp += m ;m = strlen ( serv -> st ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> st , m ) ;rp += m ;m = strlen ( serv -> usn ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> usn , m ) ;rp += m ;nrep ++ ;}}rbuf [ 0 ] = nrep ;syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ;if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) {syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ;goto error ;}break ;case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ;if ( ! newserv ) {syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ;goto error ;}memset ( newserv , 0 , sizeof ( struct service ) ) ;if ( containsForbiddenChars ( p , l ) ) {syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ;goto error ;}newserv -> st = malloc ( l + 1 ) ;if ( ! newserv -> st ) {syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ;goto error ;}memcpy ( newserv -> st , p , l ) ;newserv -> st [ l ] = \'\\\\0\' ;p += l ;if ( p >= buf + n ) {DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;cwe id:CWE-125context: void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0,<S2SV_blank>type=%d)"" , type ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case MINISSDPD_GET_VERSION : rp = rbuf ; CODELENGTH ( ( sizeof ( MINISSDPD_VERSION ) - 1 ) , rp ) ; memcpy ( rp , MINISSDPD_VERSION , sizeof ( MINISSDPD_VERSION ) - 1 ) ; rp += ( sizeof ( MINISSDPD_VERSION ) - 1 ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ; while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ; if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>already<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; sendNotifications ( NOTIF_NEW , NULL , newserv ) ; newserv = NULL ; break ; case MINISSDPD_NOTIF : rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } req -> is_notify = 1 ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }","if ( l > ( unsigned ) ( buf + n - p ) ) {DECODELENGTH_CHECKLIMIT ( l , p , buf + n - p ) ) ;if ( p + l > buf + n - p ) ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",1335
189,"buggy line: if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;cwe id:CWE-125context: void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0,<S2SV_blank>type=%d)"" , type ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case MINISSDPD_GET_VERSION : rp = rbuf ; CODELENGTH ( ( sizeof ( MINISSDPD_VERSION ) - 1 ) , rp ) ; memcpy ( rp , MINISSDPD_VERSION , sizeof ( MINISSDPD_VERSION ) - 1 ) ; rp += ( sizeof ( MINISSDPD_VERSION ) - 1 ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ; while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ; if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>already<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; sendNotifications ( NOTIF_NEW , NULL , newserv ) ; newserv = NULL ; break ; case MINISSDPD_NOTIF : rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } req -> is_notify = 1 ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }","if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",1335
190,"buggy line: if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;cwe id:CWE-125context: void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0,<S2SV_blank>type=%d)"" , type ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case MINISSDPD_GET_VERSION : rp = rbuf ; CODELENGTH ( ( sizeof ( MINISSDPD_VERSION ) - 1 ) , rp ) ; memcpy ( rp , MINISSDPD_VERSION , sizeof ( MINISSDPD_VERSION ) - 1 ) ; rp += ( sizeof ( MINISSDPD_VERSION ) - 1 ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ; while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ; if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;  if ( p + l > buf + n ) {  syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>already<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; sendNotifications ( NOTIF_NEW , NULL , newserv ) ; newserv = NULL ; break ; case MINISSDPD_NOTIF : rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } req -> is_notify = 1 ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }","if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",1335
191,"buggy line: RAnalOp next_op ;avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;cwe id:CWE-908context: INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;  RAnalOp next_op ;  avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""r%d,r%d,^,!,"" , r , d ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }","RAnalOp next_op = {0 };avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;",1336
192,"buggy line: # define ThrowDCMException ( exception , message ) {cwe id:CWE-20context: static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {  # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; }  char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ;  if ( tag == 0xFFFEE0DD )  break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }","# define ThrowDCMException ( exception , message ) \\\\\",1337
193,"buggy line: }char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;cwe id:CWE-20context: static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {  # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; }  char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ;  if ( tag == 0xFFFEE0DD )  break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }","\\\\\char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;",1337
194,"buggy line: cwe id:CWE-20context: static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {  # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; }  char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ;  if ( tag == 0xFFFEE0DD )  break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",1337
195,"buggy line: if ( tag == 0xFFFEE0DD )  break ;cwe id:CWE-20context: static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {  # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; }  char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ;  if ( tag == 0xFFFEE0DD )  break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }",if ( tag == 0xFFFEE0DD ) break ;,1337
196,buggy line: void recovery_delete_character ( void )  {if ( strlen ( mnemonic ) > 0 ) {cwe id:CWE-354context: void recovery_delete_character ( void )  {  if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; },"void recovery_delete_character ( void ) {if ( ! recovery_started ) {recovery_abort ( ) ;fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ;layoutHome ( ) ;return ;}if ( strlen ( mnemonic ) > 0 ) {",1338
197,"buggy line: enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , hashTable [ 1 ] ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ;TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\return NO_ERROR ;cwe id:CWE-20context: error_t enc624j600UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashTable [ 4 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc624j600CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } }  enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ;  enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , hashTable [ 1 ] ) ;  enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ;   enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ;   TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ;   TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ;   TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ;   TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ;  return NO_ERROR ; }","enc624j600WriteReg ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ;enc624j600WriteReg ( interface , ENC624J600_EHT3 , hashTable [ 0 ] ) ;enc624j600WriteReg ( interface , ENC624J600_EHT4 , hashTable [ 1 ] ) ;enc624j600WriteReg ( interface , ENC624J600_EHT1 ) ) ;TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\return NO_ERROR ;",1339
198,"buggy line: pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows *  sizeof ( * pixels ) ) ;cwe id:CWE-125context: static Image * ReadPDBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { unsigned char attributes , tag [ 3 ] ; Image * image ; MagickBooleanType status ; PDBImage pdb_image ; PDBInfo pdb_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; size_t bits_per_pixel , num_pad_bytes , one , packets ; ssize_t count , img_offset , comment_offset = 0 , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , sizeof ( pdb_info . name ) , ( unsigned char * ) pdb_info . name ) ; if ( count != sizeof ( pdb_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_info . attributes = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . version = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . create_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_time = ReadBlobMSBLong ( image ) ; pdb_info . archive_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_number = ReadBlobMSBLong ( image ) ; pdb_info . application_info = ReadBlobMSBLong ( image ) ; pdb_info . sort_info = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . type ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . id ) ; pdb_info . seed = ReadBlobMSBLong ( image ) ; pdb_info . next_record = ReadBlobMSBLong ( image ) ; pdb_info . number_records = ( short ) ReadBlobMSBShort ( image ) ; if ( ( memcmp ( pdb_info . type , ""vIMG"" , 4 ) != 0 ) || ( memcmp ( pdb_info . id , ""View"" , 4 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( pdb_info . next_record != 0 ) ThrowReaderException ( CoderError , ""MultipleRecordListNotSupported"" ) ; img_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) attributes ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x00"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; if ( pdb_info . number_records > 1 ) { comment_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x01"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } num_pad_bytes = ( size_t ) ( img_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- != 0 ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } count = ReadBlob ( image , sizeof ( pdb_image . name ) , ( unsigned char * ) pdb_image . name ) ; if ( count != sizeof ( pdb_image . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_image . version = ReadBlobByte ( image ) ; pdb_image . type = ( unsigned char ) ( ( int ) ReadBlobByte ( image ) ) ; pdb_image . reserved_1 = ReadBlobMSBLong ( image ) ; pdb_image . note = ReadBlobMSBLong ( image ) ; pdb_image . x_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . y_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . reserved_2 = ReadBlobMSBLong ( image ) ; pdb_image . x_anchor = ReadBlobMSBShort ( image ) ; pdb_image . y_anchor = ReadBlobMSBShort ( image ) ; pdb_image . width = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . height = ( short ) ReadBlobMSBShort ( image ) ; image -> columns = ( size_t ) pdb_image . width ; image -> rows = ( size_t ) pdb_image . height ; image -> depth = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; image -> storage_class = PseudoClass ; bits_per_pixel = pdb_image . type == 0 ? 2UL : pdb_image . type == 2 ? 4UL : 1UL ; one = 1 ; if ( AcquireImageColormap ( image , one << bits_per_pixel , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } packets = ( bits_per_pixel * image -> columns + 7 ) / 8 ;  pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows *  sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; switch ( pdb_image . version & 0x07 ) { case 0 : { image -> compression = NoCompression ; count = ( ssize_t ) ReadBlob ( image , packets * image -> rows , pixels ) ; break ; } case 1 : { image -> compression = RLECompression ; if ( ! DecodeImage ( image , pixels , packets * image -> rows ) ) ThrowReaderException ( CorruptImageError , ""RLEDecoderError"" ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompressionType"" ) ; } p = pixels ; switch ( bits_per_pixel ) { case 1 : { int bit ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( * p & ( 0x80 >> bit ) ? 0x00 : 0x01 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 2 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 3 ; x += 4 ) { index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 6 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 4 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 2 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 1 ; x += 2 ) { index = ConstrainColormapIndex ( image , 15UL - ( ( * p >> 4 ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 15UL - ( ( * p ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; if ( pdb_info . number_records > 1 ) { char * comment ; int c ; register char * p ; size_t length ; num_pad_bytes = ( size_t ) ( comment_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- ) ReadBlobByte ( image ) ; c = ReadBlobByte ( image ) ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; c != EOF ; p ++ ) { if ( ( size_t ) ( p - comment + MagickPathExtent ) >= length ) { * p = '\\0' ; length <<= 1 ; length += MagickPathExtent ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 257UL , image -> rows * sizeof ( * pixels ) ) ;",1340
199,"buggy line: cwe id:CWE-416context: void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; int type ; struct device * d = devlist ; unsigned char rbuf [ 4096 ] ; unsigned char * rp = rbuf + 1 ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( l == 0 && type != 3 ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0)"" ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case 1 : case 2 : case 3 : while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == 2 && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == 3 ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == 2 && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == 3 ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write ( req -> socket , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case 4 : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; }  if ( containsForbiddenChars ( p , l ) ) {  syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>allready<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; newserv = NULL ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write ( req -> socket , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }","memset ( newserv , 0 , sizeof ( struct service ) ) ;",1341
200,"buggy line: if ( containsForbiddenChars ( p , l ) ) {syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ;cwe id:CWE-416context: void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; int type ; struct device * d = devlist ; unsigned char rbuf [ 4096 ] ; unsigned char * rp = rbuf + 1 ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( l == 0 && type != 3 ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0)"" ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case 1 : case 2 : case 3 : while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == 2 && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == 3 ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == 2 && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == 3 ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write ( req -> socket , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case 4 : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; }  if ( containsForbiddenChars ( p , l ) ) {  syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>allready<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; newserv = NULL ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write ( req -> socket , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }","if ( containsForbiddenChars ( p , l ) ) {syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ;",1341
201,"buggy line: WORD32 i ;WORD32 st_rps_idx ;cwe id:CWE-000context: WORD32 ihevcd_ref_list ( codec_t * ps_codec , pps_t * ps_pps , sps_t * ps_sps , slice_header_t * ps_slice_hdr ) {  WORD32 i ;  WORD32 st_rps_idx ; WORD32 num_neg_pics , num_pos_pics ; WORD8 * pi1_used ; WORD16 * pi2_delta_poc ; UWORD32 u4_max_poc_lsb ; pic_buf_t * ps_pic_buf ; mv_buf_t * ps_mv_buf ; UWORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; WORD32 ai4_poc_st_curr_before [ MAX_DPB_SIZE ] , ai4_poc_st_foll [ MAX_DPB_SIZE ] , ai4_poc_st_curr_after [ MAX_DPB_SIZE ] ; WORD32 ai4_poc_lt_curr [ MAX_DPB_SIZE ] , ai4_poc_lt_foll [ MAX_DPB_SIZE ] ; UWORD32 u4_num_st_curr_before , u4_num_st_foll , u4_num_st_curr_after , u4_num_lt_curr , u4_num_lt_foll ; UWORD32 u4_num_total_curr ; WORD8 ai1_curr_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] , ai1_foll_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_curr [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_foll [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_curr_after [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_curr_before [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_foll [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_list_temp0 [ MAX_DPB_SIZE ] , * as_ref_pic_list_temp1 [ MAX_DPB_SIZE ] ; UWORD32 u4_num_rps_curr_temp_list0 , u4_num_rps_curr_temp_list1 ; WORD32 i4_pic_order_cnt_val ; WORD32 i4_poc_lt ; UNUSED ( as_ref_pic_lt_foll ) ; UNUSED ( as_ref_pic_st_foll ) ; UNUSED ( ps_pps ) ; RETURN_IF_NAL_INFO ; u4_max_poc_lsb = ( 1 << ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; i4_pic_order_cnt_val = ps_slice_hdr -> i4_abs_pic_order_cnt ; if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) { st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; pi2_delta_poc = ps_sps -> as_stref_picset [ st_rps_idx ] . ai2_delta_poc ; } else { st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; pi2_delta_poc = ps_slice_hdr -> s_stref_picset . ai2_delta_poc ; } u4_num_st_curr_before = 0 ; u4_num_st_foll = 0 ; for ( i = 0 ; i < num_neg_pics ; i ++ ) { if ( pi1_used [ i ] ) { ai4_poc_st_curr_before [ u4_num_st_curr_before ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_curr_before ++ ; } else { ai4_poc_st_foll [ u4_num_st_foll ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_foll ++ ; } } u4_num_st_curr_after = 0 ; for ( i = num_neg_pics ; i < num_neg_pics + num_pos_pics ; i ++ ) { if ( pi1_used [ i ] ) { ai4_poc_st_curr_after [ u4_num_st_curr_after ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_curr_after ++ ; } else { ai4_poc_st_foll [ u4_num_st_foll ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_foll ++ ; } } u4_num_lt_curr = 0 ; u4_num_lt_foll = 0 ; for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) { i4_poc_lt = ps_slice_hdr -> ai4_poc_lsb_lt [ i ] ; if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) { i4_poc_lt += i4_pic_order_cnt_val - ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] * u4_max_poc_lsb - ps_slice_hdr -> i4_pic_order_cnt_lsb ; } if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) { ai4_poc_lt_curr [ u4_num_lt_curr ] = i4_poc_lt ; ai1_curr_delta_poc_msb_present_flag [ u4_num_lt_curr ] = ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ; u4_num_lt_curr ++ ; } else { ai4_poc_lt_foll [ u4_num_lt_foll ] = i4_poc_lt ; ai1_foll_delta_poc_msb_present_flag [ u4_num_lt_foll ] = ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ; u4_num_lt_foll ++ ; } } u4_num_total_curr = u4_num_lt_curr + u4_num_st_curr_after + u4_num_st_curr_before ; if ( 0 == ps_codec -> i4_pic_present ) { for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf -> u1_used_as_ref = UNUSED_FOR_REF ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_lt_curr ; i ++ ) { if ( 0 == ai1_curr_delta_poc_msb_present_flag [ i ] ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_curr [ i ] = ps_pic_buf ; } else { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_curr [ i ] = ps_pic_buf ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_lt_foll ; i ++ ) { if ( 0 == ai1_foll_delta_poc_msb_present_flag [ i ] ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb ( ps_dpb_mgr , ai4_poc_lt_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_foll [ i ] = ps_pic_buf ; } else { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_lt_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_foll [ i ] = ps_pic_buf ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_st_curr_before ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_curr_before [ i ] = ps_pic_buf ; } for ( i = 0 ; i < ( WORD32 ) u4_num_st_curr_after ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_curr_after [ i ] = ps_pic_buf ; } for ( i = 0 ; i < ( WORD32 ) u4_num_st_foll ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_foll [ i ] = ps_pic_buf ; } u4_num_rps_curr_temp_list0 = ( WORD32 ) u4_num_total_curr > ps_slice_hdr -> i1_num_ref_idx_l0_active ? ( WORD32 ) u4_num_total_curr : ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx = 0 ; if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) { while ( r_idx < u4_num_rps_curr_temp_list0 ) { for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_before ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_before [ i ] ) { as_ref_pic_st_curr_before [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_st_curr_before [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_after ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_after [ i ] ) { as_ref_pic_st_curr_after [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_st_curr_after [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_lt_curr ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_lt_curr [ i ] ) { as_ref_pic_lt_curr [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_lt_curr [ i ] ; } } for ( r_idx = 0 ; ( WORD32 ) r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) { pic_buf_t * ps_pic_buf ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 ? ( void * ) as_ref_pic_list_temp0 [ ps_slice_hdr -> s_rplm . i1_list_entry_l0 [ r_idx ] ] : ( void * ) as_ref_pic_list_temp0 [ r_idx ] ; ps_pic_buf = ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ; if ( ps_pic_buf == NULL ) return IHEVCD_REF_PIC_NOT_FOUND ; ps_mv_buf = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ps_mv_buf ; } if ( ps_slice_hdr -> i1_slice_type == BSLICE ) { u4_num_rps_curr_temp_list1 = ( WORD32 ) u4_num_total_curr > ps_slice_hdr -> i1_num_ref_idx_l1_active ? ( WORD32 ) u4_num_total_curr : ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx = 0 ; while ( r_idx < u4_num_rps_curr_temp_list1 ) { for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_after ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_after [ i ] ) { as_ref_pic_st_curr_after [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_st_curr_after [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_before ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_before [ i ] ) { as_ref_pic_st_curr_before [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_st_curr_before [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_lt_curr ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_lt_curr [ i ] ) { as_ref_pic_lt_curr [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_lt_curr [ i ] ; } } for ( r_idx = 0 ; ( WORD32 ) r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) { pic_buf_t * ps_pic_buf ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 ? ( void * ) as_ref_pic_list_temp1 [ ps_slice_hdr -> s_rplm . i1_list_entry_l1 [ r_idx ] ] : ( void * ) as_ref_pic_list_temp1 [ r_idx ] ; ps_pic_buf = ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ; if ( ps_pic_buf == NULL ) return IHEVCD_REF_PIC_NOT_FOUND ; ps_mv_buf = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ps_mv_buf ; } } } DEBUG_PRINT_REF_LIST_POCS ( i4_pic_order_cnt_val , ps_slice_hdr , ps_dpb_mgr , u4_num_st_curr_before , u4_num_st_curr_after , u4_num_st_foll , u4_num_lt_curr , u4_num_lt_foll , ai4_poc_st_curr_before , ai4_poc_st_curr_after , ai4_poc_st_foll , ai4_poc_lt_curr , ai4_poc_lt_foll ) ; for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) && ( UNUSED_FOR_REF == ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf -> u1_used_as_ref ) ) { pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; mv_buf_t * ps_mv_buf ; ihevc_dpb_mgr_del_ref ( ps_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ;  for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ )  { if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) {  ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ;  break ; } ps_mv_buf ++ ; } } } return IHEVCD_SUCCESS ; }","WORD32 i , j ;WORD32 st_rps_idx ;",1342
202,"buggy line: for ( i = 0 ;i < num_neg_pics ;i ++ ) {cwe id:CWE-000context: WORD32 ihevcd_ref_list ( codec_t * ps_codec , pps_t * ps_pps , sps_t * ps_sps , slice_header_t * ps_slice_hdr ) {  WORD32 i ;  WORD32 st_rps_idx ; WORD32 num_neg_pics , num_pos_pics ; WORD8 * pi1_used ; WORD16 * pi2_delta_poc ; UWORD32 u4_max_poc_lsb ; pic_buf_t * ps_pic_buf ; mv_buf_t * ps_mv_buf ; UWORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; WORD32 ai4_poc_st_curr_before [ MAX_DPB_SIZE ] , ai4_poc_st_foll [ MAX_DPB_SIZE ] , ai4_poc_st_curr_after [ MAX_DPB_SIZE ] ; WORD32 ai4_poc_lt_curr [ MAX_DPB_SIZE ] , ai4_poc_lt_foll [ MAX_DPB_SIZE ] ; UWORD32 u4_num_st_curr_before , u4_num_st_foll , u4_num_st_curr_after , u4_num_lt_curr , u4_num_lt_foll ; UWORD32 u4_num_total_curr ; WORD8 ai1_curr_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] , ai1_foll_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_curr [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_foll [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_curr_after [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_curr_before [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_foll [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_list_temp0 [ MAX_DPB_SIZE ] , * as_ref_pic_list_temp1 [ MAX_DPB_SIZE ] ; UWORD32 u4_num_rps_curr_temp_list0 , u4_num_rps_curr_temp_list1 ; WORD32 i4_pic_order_cnt_val ; WORD32 i4_poc_lt ; UNUSED ( as_ref_pic_lt_foll ) ; UNUSED ( as_ref_pic_st_foll ) ; UNUSED ( ps_pps ) ; RETURN_IF_NAL_INFO ; u4_max_poc_lsb = ( 1 << ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; i4_pic_order_cnt_val = ps_slice_hdr -> i4_abs_pic_order_cnt ; if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) { st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; pi2_delta_poc = ps_sps -> as_stref_picset [ st_rps_idx ] . ai2_delta_poc ; } else { st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; pi2_delta_poc = ps_slice_hdr -> s_stref_picset . ai2_delta_poc ; } u4_num_st_curr_before = 0 ; u4_num_st_foll = 0 ; for ( i = 0 ; i < num_neg_pics ; i ++ ) { if ( pi1_used [ i ] ) { ai4_poc_st_curr_before [ u4_num_st_curr_before ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_curr_before ++ ; } else { ai4_poc_st_foll [ u4_num_st_foll ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_foll ++ ; } } u4_num_st_curr_after = 0 ; for ( i = num_neg_pics ; i < num_neg_pics + num_pos_pics ; i ++ ) { if ( pi1_used [ i ] ) { ai4_poc_st_curr_after [ u4_num_st_curr_after ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_curr_after ++ ; } else { ai4_poc_st_foll [ u4_num_st_foll ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_foll ++ ; } } u4_num_lt_curr = 0 ; u4_num_lt_foll = 0 ; for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) { i4_poc_lt = ps_slice_hdr -> ai4_poc_lsb_lt [ i ] ; if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) { i4_poc_lt += i4_pic_order_cnt_val - ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] * u4_max_poc_lsb - ps_slice_hdr -> i4_pic_order_cnt_lsb ; } if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) { ai4_poc_lt_curr [ u4_num_lt_curr ] = i4_poc_lt ; ai1_curr_delta_poc_msb_present_flag [ u4_num_lt_curr ] = ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ; u4_num_lt_curr ++ ; } else { ai4_poc_lt_foll [ u4_num_lt_foll ] = i4_poc_lt ; ai1_foll_delta_poc_msb_present_flag [ u4_num_lt_foll ] = ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ; u4_num_lt_foll ++ ; } } u4_num_total_curr = u4_num_lt_curr + u4_num_st_curr_after + u4_num_st_curr_before ; if ( 0 == ps_codec -> i4_pic_present ) { for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf -> u1_used_as_ref = UNUSED_FOR_REF ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_lt_curr ; i ++ ) { if ( 0 == ai1_curr_delta_poc_msb_present_flag [ i ] ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_curr [ i ] = ps_pic_buf ; } else { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_curr [ i ] = ps_pic_buf ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_lt_foll ; i ++ ) { if ( 0 == ai1_foll_delta_poc_msb_present_flag [ i ] ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb ( ps_dpb_mgr , ai4_poc_lt_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_foll [ i ] = ps_pic_buf ; } else { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_lt_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_foll [ i ] = ps_pic_buf ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_st_curr_before ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_curr_before [ i ] = ps_pic_buf ; } for ( i = 0 ; i < ( WORD32 ) u4_num_st_curr_after ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_curr_after [ i ] = ps_pic_buf ; } for ( i = 0 ; i < ( WORD32 ) u4_num_st_foll ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_foll [ i ] = ps_pic_buf ; } u4_num_rps_curr_temp_list0 = ( WORD32 ) u4_num_total_curr > ps_slice_hdr -> i1_num_ref_idx_l0_active ? ( WORD32 ) u4_num_total_curr : ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx = 0 ; if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) { while ( r_idx < u4_num_rps_curr_temp_list0 ) { for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_before ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_before [ i ] ) { as_ref_pic_st_curr_before [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_st_curr_before [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_after ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_after [ i ] ) { as_ref_pic_st_curr_after [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_st_curr_after [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_lt_curr ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_lt_curr [ i ] ) { as_ref_pic_lt_curr [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_lt_curr [ i ] ; } } for ( r_idx = 0 ; ( WORD32 ) r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) { pic_buf_t * ps_pic_buf ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 ? ( void * ) as_ref_pic_list_temp0 [ ps_slice_hdr -> s_rplm . i1_list_entry_l0 [ r_idx ] ] : ( void * ) as_ref_pic_list_temp0 [ r_idx ] ; ps_pic_buf = ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ; if ( ps_pic_buf == NULL ) return IHEVCD_REF_PIC_NOT_FOUND ; ps_mv_buf = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ps_mv_buf ; } if ( ps_slice_hdr -> i1_slice_type == BSLICE ) { u4_num_rps_curr_temp_list1 = ( WORD32 ) u4_num_total_curr > ps_slice_hdr -> i1_num_ref_idx_l1_active ? ( WORD32 ) u4_num_total_curr : ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx = 0 ; while ( r_idx < u4_num_rps_curr_temp_list1 ) { for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_after ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_after [ i ] ) { as_ref_pic_st_curr_after [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_st_curr_after [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_before ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_before [ i ] ) { as_ref_pic_st_curr_before [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_st_curr_before [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_lt_curr ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_lt_curr [ i ] ) { as_ref_pic_lt_curr [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_lt_curr [ i ] ; } } for ( r_idx = 0 ; ( WORD32 ) r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) { pic_buf_t * ps_pic_buf ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 ? ( void * ) as_ref_pic_list_temp1 [ ps_slice_hdr -> s_rplm . i1_list_entry_l1 [ r_idx ] ] : ( void * ) as_ref_pic_list_temp1 [ r_idx ] ; ps_pic_buf = ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ; if ( ps_pic_buf == NULL ) return IHEVCD_REF_PIC_NOT_FOUND ; ps_mv_buf = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ps_mv_buf ; } } } DEBUG_PRINT_REF_LIST_POCS ( i4_pic_order_cnt_val , ps_slice_hdr , ps_dpb_mgr , u4_num_st_curr_before , u4_num_st_curr_after , u4_num_st_foll , u4_num_lt_curr , u4_num_lt_foll , ai4_poc_st_curr_before , ai4_poc_st_curr_after , ai4_poc_st_foll , ai4_poc_lt_curr , ai4_poc_lt_foll ) ; for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) && ( UNUSED_FOR_REF == ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf -> u1_used_as_ref ) ) { pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; mv_buf_t * ps_mv_buf ; ihevc_dpb_mgr_del_ref ( ps_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ;  for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ )  { if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) {  ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ;  break ; } ps_mv_buf ++ ; } } } return IHEVCD_SUCCESS ; }",for ( j = 0 ;j < ps_codec -> i4_max_dpb_size ;j ++ ) {,1342
203,"buggy line: for ( i = 0 ;i ++ )  {ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ;break ;cwe id:CWE-000context: WORD32 ihevcd_ref_list ( codec_t * ps_codec , pps_t * ps_pps , sps_t * ps_sps , slice_header_t * ps_slice_hdr ) {  WORD32 i ;  WORD32 st_rps_idx ; WORD32 num_neg_pics , num_pos_pics ; WORD8 * pi1_used ; WORD16 * pi2_delta_poc ; UWORD32 u4_max_poc_lsb ; pic_buf_t * ps_pic_buf ; mv_buf_t * ps_mv_buf ; UWORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; WORD32 ai4_poc_st_curr_before [ MAX_DPB_SIZE ] , ai4_poc_st_foll [ MAX_DPB_SIZE ] , ai4_poc_st_curr_after [ MAX_DPB_SIZE ] ; WORD32 ai4_poc_lt_curr [ MAX_DPB_SIZE ] , ai4_poc_lt_foll [ MAX_DPB_SIZE ] ; UWORD32 u4_num_st_curr_before , u4_num_st_foll , u4_num_st_curr_after , u4_num_lt_curr , u4_num_lt_foll ; UWORD32 u4_num_total_curr ; WORD8 ai1_curr_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] , ai1_foll_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_curr [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_foll [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_curr_after [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_curr_before [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_foll [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_list_temp0 [ MAX_DPB_SIZE ] , * as_ref_pic_list_temp1 [ MAX_DPB_SIZE ] ; UWORD32 u4_num_rps_curr_temp_list0 , u4_num_rps_curr_temp_list1 ; WORD32 i4_pic_order_cnt_val ; WORD32 i4_poc_lt ; UNUSED ( as_ref_pic_lt_foll ) ; UNUSED ( as_ref_pic_st_foll ) ; UNUSED ( ps_pps ) ; RETURN_IF_NAL_INFO ; u4_max_poc_lsb = ( 1 << ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; i4_pic_order_cnt_val = ps_slice_hdr -> i4_abs_pic_order_cnt ; if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) { st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; pi2_delta_poc = ps_sps -> as_stref_picset [ st_rps_idx ] . ai2_delta_poc ; } else { st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; pi2_delta_poc = ps_slice_hdr -> s_stref_picset . ai2_delta_poc ; } u4_num_st_curr_before = 0 ; u4_num_st_foll = 0 ; for ( i = 0 ; i < num_neg_pics ; i ++ ) { if ( pi1_used [ i ] ) { ai4_poc_st_curr_before [ u4_num_st_curr_before ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_curr_before ++ ; } else { ai4_poc_st_foll [ u4_num_st_foll ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_foll ++ ; } } u4_num_st_curr_after = 0 ; for ( i = num_neg_pics ; i < num_neg_pics + num_pos_pics ; i ++ ) { if ( pi1_used [ i ] ) { ai4_poc_st_curr_after [ u4_num_st_curr_after ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_curr_after ++ ; } else { ai4_poc_st_foll [ u4_num_st_foll ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_foll ++ ; } } u4_num_lt_curr = 0 ; u4_num_lt_foll = 0 ; for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) { i4_poc_lt = ps_slice_hdr -> ai4_poc_lsb_lt [ i ] ; if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) { i4_poc_lt += i4_pic_order_cnt_val - ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] * u4_max_poc_lsb - ps_slice_hdr -> i4_pic_order_cnt_lsb ; } if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) { ai4_poc_lt_curr [ u4_num_lt_curr ] = i4_poc_lt ; ai1_curr_delta_poc_msb_present_flag [ u4_num_lt_curr ] = ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ; u4_num_lt_curr ++ ; } else { ai4_poc_lt_foll [ u4_num_lt_foll ] = i4_poc_lt ; ai1_foll_delta_poc_msb_present_flag [ u4_num_lt_foll ] = ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ; u4_num_lt_foll ++ ; } } u4_num_total_curr = u4_num_lt_curr + u4_num_st_curr_after + u4_num_st_curr_before ; if ( 0 == ps_codec -> i4_pic_present ) { for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf -> u1_used_as_ref = UNUSED_FOR_REF ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_lt_curr ; i ++ ) { if ( 0 == ai1_curr_delta_poc_msb_present_flag [ i ] ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_curr [ i ] = ps_pic_buf ; } else { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_curr [ i ] = ps_pic_buf ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_lt_foll ; i ++ ) { if ( 0 == ai1_foll_delta_poc_msb_present_flag [ i ] ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb ( ps_dpb_mgr , ai4_poc_lt_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_foll [ i ] = ps_pic_buf ; } else { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_lt_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_foll [ i ] = ps_pic_buf ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_st_curr_before ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_curr_before [ i ] = ps_pic_buf ; } for ( i = 0 ; i < ( WORD32 ) u4_num_st_curr_after ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_curr_after [ i ] = ps_pic_buf ; } for ( i = 0 ; i < ( WORD32 ) u4_num_st_foll ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_foll [ i ] = ps_pic_buf ; } u4_num_rps_curr_temp_list0 = ( WORD32 ) u4_num_total_curr > ps_slice_hdr -> i1_num_ref_idx_l0_active ? ( WORD32 ) u4_num_total_curr : ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx = 0 ; if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) { while ( r_idx < u4_num_rps_curr_temp_list0 ) { for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_before ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_before [ i ] ) { as_ref_pic_st_curr_before [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_st_curr_before [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_after ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_after [ i ] ) { as_ref_pic_st_curr_after [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_st_curr_after [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_lt_curr ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_lt_curr [ i ] ) { as_ref_pic_lt_curr [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_lt_curr [ i ] ; } } for ( r_idx = 0 ; ( WORD32 ) r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) { pic_buf_t * ps_pic_buf ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 ? ( void * ) as_ref_pic_list_temp0 [ ps_slice_hdr -> s_rplm . i1_list_entry_l0 [ r_idx ] ] : ( void * ) as_ref_pic_list_temp0 [ r_idx ] ; ps_pic_buf = ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ; if ( ps_pic_buf == NULL ) return IHEVCD_REF_PIC_NOT_FOUND ; ps_mv_buf = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ps_mv_buf ; } if ( ps_slice_hdr -> i1_slice_type == BSLICE ) { u4_num_rps_curr_temp_list1 = ( WORD32 ) u4_num_total_curr > ps_slice_hdr -> i1_num_ref_idx_l1_active ? ( WORD32 ) u4_num_total_curr : ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx = 0 ; while ( r_idx < u4_num_rps_curr_temp_list1 ) { for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_after ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_after [ i ] ) { as_ref_pic_st_curr_after [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_st_curr_after [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_before ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_before [ i ] ) { as_ref_pic_st_curr_before [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_st_curr_before [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_lt_curr ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_lt_curr [ i ] ) { as_ref_pic_lt_curr [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_lt_curr [ i ] ; } } for ( r_idx = 0 ; ( WORD32 ) r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) { pic_buf_t * ps_pic_buf ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 ? ( void * ) as_ref_pic_list_temp1 [ ps_slice_hdr -> s_rplm . i1_list_entry_l1 [ r_idx ] ] : ( void * ) as_ref_pic_list_temp1 [ r_idx ] ; ps_pic_buf = ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ; if ( ps_pic_buf == NULL ) return IHEVCD_REF_PIC_NOT_FOUND ; ps_mv_buf = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ps_mv_buf ; } } } DEBUG_PRINT_REF_LIST_POCS ( i4_pic_order_cnt_val , ps_slice_hdr , ps_dpb_mgr , u4_num_st_curr_before , u4_num_st_curr_after , u4_num_st_foll , u4_num_lt_curr , u4_num_lt_foll , ai4_poc_st_curr_before , ai4_poc_st_curr_after , ai4_poc_st_foll , ai4_poc_lt_curr , ai4_poc_lt_foll ) ; for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) && ( UNUSED_FOR_REF == ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf -> u1_used_as_ref ) ) { pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; mv_buf_t * ps_mv_buf ; ihevc_dpb_mgr_del_ref ( ps_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ;  for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ )  { if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) {  ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ;  break ; } ps_mv_buf ++ ; } } } return IHEVCD_SUCCESS ; }","for ( i = 0 ;i ++ ) {ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , j , BUF_MGR_REF ) ;break ;",1342
204,"buggy line: # endif case PTRACE_GET_THREAD_AREA :  ret = put_user ( task_thread_info ( child ) -> tp_value ,  datap ) ;cwe id:CWE-264context: long arch_ptrace ( struct task_struct * child , long request , unsigned long addr , unsigned long data ) { int ret ; unsigned long __user * datap = ( unsigned long __user * ) data ; switch ( request ) { case PTRACE_PEEKUSR : ret = ptrace_read_user ( child , addr , datap ) ; break ; case PTRACE_POKEUSR : ret = ptrace_write_user ( child , addr , data ) ; break ; case PTRACE_GETREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_SETREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_GETFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; case PTRACE_SETFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; # ifdef CONFIG_IWMMXT case PTRACE_GETWMMXREGS : ret = ptrace_getwmmxregs ( child , datap ) ; break ; case PTRACE_SETWMMXREGS : ret = ptrace_setwmmxregs ( child , datap ) ; break ; # endif case PTRACE_GET_THREAD_AREA :  ret = put_user ( task_thread_info ( child ) -> tp_value ,  datap ) ; break ; case PTRACE_SET_SYSCALL : task_thread_info ( child ) -> syscall = data ; ret = 0 ; break ; # ifdef CONFIG_CRUNCH case PTRACE_GETCRUNCHREGS : ret = ptrace_getcrunchregs ( child , datap ) ; break ; case PTRACE_SETCRUNCHREGS : ret = ptrace_setcrunchregs ( child , datap ) ; break ; # endif # ifdef CONFIG_VFP case PTRACE_GETVFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; case PTRACE_SETVFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; # endif # ifdef CONFIG_HAVE_HW_BREAKPOINT case PTRACE_GETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_gethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; case PTRACE_SETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_sethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; # endif default : ret = ptrace_request ( child , request , addr , data ) ; break ; } return ret ; }","# endif case PTRACE_GET_THREAD_AREA : ret = put_user ( task_thread_info ( child ) -> tp_value [ 0 ] , datap ) ;",1343
205,"buggy line: goto fail ;}cwe id:CWE-388context: static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n"" ) ;  goto fail ;  } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>"" ""in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n"" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }",ret = - EINVAL ;goto fail ;},1344
206,"buggy line: static char * print_object ( cJSON * item , int depth , int fmt )  {while ( child ) {++ numentries ;if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) return 0 ;if ( ! ( names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) {++ depth ;while ( child ) {names [ i ] = str = print_string_ptr ( child -> string ) ;entries [ i ++ ] = ret = print_value ( child , depth , fmt ) ;if ( str && ret ) len += strlen ( ret ) + strlen ( str ) + 2 + ( fmt ? 2 + depth : 0 ) ;else fail = 1 ;child = child -> next ;}if ( ! fail ) {out = ( char * ) cJSON_malloc ( len ) ;}if ( fail ) {for ( i = 0 ;if ( names [ i ] ) cJSON_free ( names [ i ] ) ;cwe id:CWE-119context:  static char * print_object ( cJSON * item , int depth , int fmt )  { char * * entries = 0 , * * names = 0 ; char * out = 0 , * ptr , * ret , * str ; int len = 7 , i = 0 , j ; cJSON * child = item -> child ; int numentries = 0 , fail = 0 ;  while ( child ) {  ++ numentries ; child = child -> next ; } if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) return 0 ; if ( ! ( names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) { cJSON_free ( entries ) ; return 0 ; } memset ( entries , 0 , sizeof ( char * ) * numentries ) ; memset ( names , 0 , sizeof ( char * ) * numentries ) ; child = item -> child ; ++ depth ; if ( fmt ) len += depth ; while ( child ) {  names [ i ] = str = print_string_ptr ( child -> string ) ;   entries [ i ++ ] = ret = print_value ( child , depth , fmt ) ;  if ( str && ret ) len += strlen ( ret ) + strlen ( str ) + 2 + ( fmt ? 2 + depth : 0 ) ; else fail = 1 ; child = child -> next ; }  if ( ! fail ) {  out = ( char * ) cJSON_malloc ( len ) ; if ( ! out ) fail = 1 ;  }  if ( fail ) {  for ( i = 0 ; i < numentries ; ++ i ) {  if ( names [ i ] ) cJSON_free ( names [ i ] ) ; if ( entries [ i ] ) cJSON_free ( entries [ i ] ) ; } cJSON_free ( names ) ; cJSON_free ( entries ) ; return 0 ; } * out = '{' ; ptr = out + 1 ;  if ( fmt )  * ptr ++ = '\\n' ; * ptr = 0 ;  for ( i = 0 ; i < numentries ; ++ i ) {  if ( fmt )  for ( j = 0 ; j < depth ; ++ j )  * ptr ++ = '\\t' ;  strcpy ( ptr , names [ i ] ) ;   ptr += strlen ( names [ i ] ) ;  * ptr ++ = ':' ;  if ( fmt )  * ptr ++ = '\\t' ; strcpy ( ptr , entries [ i ] ) ; ptr += strlen ( entries [ i ] ) ; if ( i != numentries - 1 ) * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; cJSON_free ( names [ i ] ) ; cJSON_free ( entries [ i ] ) ; } cJSON_free ( names ) ; cJSON_free ( entries ) ; if ( fmt )  for ( i = 0 ; i < depth - 1 ; ++ i )  * ptr ++ = '\\t' ; * ptr ++ = '}' ;  * ptr ++ = 0 ;  return out ; }","static char * print_object ( cJSON * item , int depth , int fmt , printbuffer * p ) {size_t tmplen = 0 ;+ numentries ;while ( child ) numentries ++ , child = child -> next ;if ( ! numentries ) {if ( p ) out = ensure ( p , fmt ? depth + 4 : 3 ) ;else out = ( char * ) cJSON_malloc ( fmt ? depth + 4 : 3 ) ;if ( ! out ) return 0 ;ptr = out ;* ptr ++ = '{' ;if ( fmt ) {* ptr ++ = '\\\for ( i = 0 ;i < depth ;i ++ ) * ptr ++ = '\\\\t' ;}* ptr ++ = '}' ;* ptr ++ = 0 ;return out ;}if ( p ) {i = p -> offset ;len = fmt ? 2 : 1 ;ptr = ensure ( p , len + 1 ) ;if ( ! ptr ) return 0 ;* ptr ++ = '{' ;if ( fmt ) * ptr ++ = '\\\* ptr = 0 ;p -> offset += len ;child = item -> child ;depth ++ ;while ( child ) {if ( fmt ) {ptr = ensure ( p , depth ) ;if ( ! ptr ) return 0 ;for ( j = 0 ;j < depth ;j ++ ) * ptr ++ = '\\\\t' ;p -> offset += depth ;}print_string_ptr ( child -> string , 0 , p ) ;p -> offset = update ( p ) ;len = fmt ? 2 : 1 ;ptr = ensure ( p , len ) ;if ( ! ptr ) return 0 ;* ptr ++ = ':' ;if ( fmt ) * ptr ++ = '\\\\t' ;p -> offset += len ;print_value ( child , depth , fmt , 0 , p ) ;p -> offset = update ( p ) ;len = ( fmt ? 1 : 0 ) + ( child -> next ? 1 : 0 ) ;ptr = ensure ( p , len + 1 ) ;if ( ! ptr ) return 0 ;if ( child -> next ) * ptr ++ = ',' ;if ( fmt ) * ptr ++ = '\\\* ptr = 0 ;p -> offset += len ;ptr = ensure ( p , fmt ? ( depth + 1 ) : 2 ) ;if ( ! ptr ) return 0 ;if ( fmt ) for ( i = 0 ;i < depth - 1 ;i ++ ) * ptr ++ = '\\\\t' ;* ptr ++ = '}' ;* ptr = 0 ;out = ( p -> buffer ) + i ;}else {entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ;if ( ! entries ) return 0 ;names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ;if ( ! names ) {+ depth ;depth ++ ;while ( child && ! fail ) out = ( char * ) cJSON_malloc ( len ) ;}if ( fail ) {for ( i = 0 ;if ( names [ i ] ) cJSON_free ( names [ i ] ) ;",1345
207,"buggy line: if ( fmt )  * ptr ++ = '\\\for ( i = 0 ;++ i ) {if ( fmt )  for ( j = 0 ;++ j )  * ptr ++ = '\\\\t' ;strcpy ( ptr , names [ i ] ) ;ptr += strlen ( names [ i ] ) ;* ptr ++ = ':' ;if ( fmt )  * ptr ++ = '\\\\t' ;strcpy ( ptr , entries [ i ] ) ;ptr += strlen ( entries [ i ] ) ;if ( i != numentries - 1 ) * ptr ++ = ',' ;if ( fmt ) * ptr ++ = '\\\if ( fmt )  for ( i = 0 ;++ i )  * ptr ++ = '\\\\t' ;* ptr ++ = 0 ;return out ;cwe id:CWE-119context:  static char * print_object ( cJSON * item , int depth , int fmt )  { char * * entries = 0 , * * names = 0 ; char * out = 0 , * ptr , * ret , * str ; int len = 7 , i = 0 , j ; cJSON * child = item -> child ; int numentries = 0 , fail = 0 ;  while ( child ) {  ++ numentries ; child = child -> next ; } if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) return 0 ; if ( ! ( names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) { cJSON_free ( entries ) ; return 0 ; } memset ( entries , 0 , sizeof ( char * ) * numentries ) ; memset ( names , 0 , sizeof ( char * ) * numentries ) ; child = item -> child ; ++ depth ; if ( fmt ) len += depth ; while ( child ) {  names [ i ] = str = print_string_ptr ( child -> string ) ;   entries [ i ++ ] = ret = print_value ( child , depth , fmt ) ;  if ( str && ret ) len += strlen ( ret ) + strlen ( str ) + 2 + ( fmt ? 2 + depth : 0 ) ; else fail = 1 ; child = child -> next ; }  if ( ! fail ) {  out = ( char * ) cJSON_malloc ( len ) ; if ( ! out ) fail = 1 ;  }  if ( fail ) {  for ( i = 0 ; i < numentries ; ++ i ) {  if ( names [ i ] ) cJSON_free ( names [ i ] ) ; if ( entries [ i ] ) cJSON_free ( entries [ i ] ) ; } cJSON_free ( names ) ; cJSON_free ( entries ) ; return 0 ; } * out = '{' ; ptr = out + 1 ;  if ( fmt )  * ptr ++ = '\\n' ; * ptr = 0 ;  for ( i = 0 ; i < numentries ; ++ i ) {  if ( fmt )  for ( j = 0 ; j < depth ; ++ j )  * ptr ++ = '\\t' ;  strcpy ( ptr , names [ i ] ) ;   ptr += strlen ( names [ i ] ) ;  * ptr ++ = ':' ;  if ( fmt )  * ptr ++ = '\\t' ; strcpy ( ptr , entries [ i ] ) ; ptr += strlen ( entries [ i ] ) ; if ( i != numentries - 1 ) * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; cJSON_free ( names [ i ] ) ; cJSON_free ( entries [ i ] ) ; } cJSON_free ( names ) ; cJSON_free ( entries ) ; if ( fmt )  for ( i = 0 ; i < depth - 1 ; ++ i )  * ptr ++ = '\\t' ; * ptr ++ = '}' ;  * ptr ++ = 0 ;  return out ; }","if ( fmt ) * ptr ++ = '\\\for ( i = 0 ;+ i ) {i ++ ) {if ( fmt ) for ( j = 0 ;+ j )  * ptr ++ = '\\\\t' ;j ++ ) * ptr ++ = '\\\\t' ;tmplen = strlen ( names [ i ] ) ;memcpy ( ptr , names [ i ] ) ;* ptr ++ = ':' ;if ( fmt ) * ptr ++ = '\\\\t' ;strcpy ( ptr , entries [ i ] , tmplen ) ;ptr += tmplen ;if ( fmt ) for ( i = 0 ;+ i )  * ptr ++ = '\\\\t' ;i ++ ) * ptr ++ = '\\\\t' ;* ptr ++ = 0 ;}return out ;",1345
208,"buggy line: struct ikev2_id id ;int id_len , idtype_len , i ;ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ;cwe id:CWE-125context: static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) {  struct ikev2_id id ;  int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ;  ND_TCHECK ( * ext ) ;  UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , ""<S2SV_blank>fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , ""<S2SV_blank>dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , ""<S2SV_blank>gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , ""<S2SV_blank>keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }","const struct ikev2_id * idp ;struct ikev2_id id ;int id_len , idtype_len , i ;idp = ( const struct ikev2_id * ) ext ;ND_TCHECK ( * idp ) ;UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ;",1346
209,"buggy line: RD_BOOL  ber_parse_header ( STREAM s , int tagval , int * length )  {cwe id:CWE-787context: RD_BOOL  ber_parse_header ( STREAM s , int tagval , int * length )  { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , ""ber_parse_header(),<S2SV_blank>expected<S2SV_blank>tag<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d"" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }","RD_BOOL ber_parse_header ( STREAM s , int tagval , uint32 * length ) {",1347
210,"buggy line: other = unix_peer_get ( sk ) ;if ( other ) {if ( unix_peer ( other ) != sk ) {sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ;if ( unix_recvq_full ( other ) )  writable = 0 ;}sock_put ( other ) ;cwe id:CWE-000context: static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , poll_table * wait ) { struct sock * sk = sock -> sk , * other ; unsigned int mask , writable ; sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; mask = 0 ; if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) mask |= POLLERR | ( sock_flag ( sk , SOCK_SELECT_ERR_QUEUE ) ? POLLPRI : 0 ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) mask |= POLLRDHUP | POLLIN | POLLRDNORM ; if ( sk -> sk_shutdown == SHUTDOWN_MASK ) mask |= POLLHUP ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) mask |= POLLIN | POLLRDNORM ; if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( sk -> sk_state == TCP_CLOSE ) mask |= POLLHUP ; if ( sk -> sk_state == TCP_SYN_SENT ) return mask ; } if ( ! ( poll_requested_events ( wait ) & ( POLLWRBAND | POLLWRNORM | POLLOUT ) ) ) return mask ; writable = unix_writable ( sk ) ;  other = unix_peer_get ( sk ) ;  if ( other ) {  if ( unix_peer ( other ) != sk ) {  sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ;  if ( unix_recvq_full ( other ) )  writable = 0 ;  }  sock_put ( other ) ; } if ( writable ) mask |= POLLOUT | POLLWRNORM | POLLWRBAND ; else set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; return mask ; }","if ( writable ) {unix_state_lock ( sk ) ;other = unix_peer ( sk ) ;if ( other && unix_peer ( other ) != sk && unix_recvq_full ( other ) && unix_dgram_peer_wake_me ( sk , other ) ) writable = 0 ;}sock_put ( other ) ;",1348
211,"buggy line: size_t  value ;cwe id:CWE-125context: static inline signed int ReadPropertyMSBLong ( const unsigned char * * p , size_t * length ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 4 ] ;  size_t  value ; if ( * length < 4 ) return ( - 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; }  value = ( size_t ) ( buffer [ 0 ] << 24 ) ;   value |= buffer [ 1 ] << 16 ;   value |= buffer [ 2 ] << 8 ;   value |= buffer [ 3 ] ;   quantum . unsigned_value = ( value & 0xffffffff ) ;  return ( quantum . signed_value ) ; }",unsigned int value ;,1349
212,"buggy line: value = ( size_t ) ( buffer [ 0 ] << 24 ) ;value |= buffer [ 1 ] << 16 ;value |= buffer [ 2 ] << 8 ;value |= buffer [ 3 ] ;quantum . unsigned_value = ( value & 0xffffffff ) ;return ( quantum . signed_value ) ;cwe id:CWE-125context: static inline signed int ReadPropertyMSBLong ( const unsigned char * * p , size_t * length ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 4 ] ;  size_t  value ; if ( * length < 4 ) return ( - 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; }  value = ( size_t ) ( buffer [ 0 ] << 24 ) ;   value |= buffer [ 1 ] << 16 ;   value |= buffer [ 2 ] << 8 ;   value |= buffer [ 3 ] ;   quantum . unsigned_value = ( value & 0xffffffff ) ;  return ( quantum . signed_value ) ; }",value = ( unsigned int ) buffer [ 0 ] << 24 ;value |= ( unsigned int ) buffer [ 1 ] << 16 ;value |= ( unsigned int ) buffer [ 2 ] << 8 ;value |= ( unsigned int ) buffer [ 3 ] ;quantum . unsigned_value = value & 0xffffffff ) ;return ( quantum . signed_value ) ;,1349
213,"buggy line: outpos += sprintf ( outpos , ""\\\}cwe id:CWE-20context: void Rectangle ( double x , double y , double w , double h ) {  outpos += sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , x , y , w , h ) ;   } ","sprintf ( outputbuffer , ""\\\sendClean ( outputbuffer ) ;}",1350
214,"buggy line: if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) {kfree_skb ( skb_out ) ;cwe id:CWE-399context: static struct sk_buff * batadv_frag_merge_packets ( struct hlist_head * chain , struct sk_buff * skb ) { struct batadv_frag_packet * packet ; struct batadv_frag_list_entry * entry ; struct sk_buff * skb_out = NULL ; int size , hdr_size = sizeof ( struct batadv_frag_packet ) ; packet = ( struct batadv_frag_packet * ) skb -> data ; size = ntohs ( packet -> total_size ) ; if ( size > batadv_frag_size_limit ( ) ) goto free ; entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) ; hlist_del ( & entry -> list ) ; skb_out = entry -> skb ; kfree ( entry ) ;  if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) {  kfree_skb ( skb_out ) ; skb_out = NULL ; goto free ; } skb_pull_rcsum ( skb_out , hdr_size ) ; memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ) ; skb_set_mac_header ( skb_out , - ETH_HLEN ) ; skb_reset_network_header ( skb_out ) ; skb_reset_transport_header ( skb_out ) ; hlist_for_each_entry ( entry , chain , list ) { size = entry -> skb -> len - hdr_size ; memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , size ) ; } free : batadv_frag_clear_chain ( chain ) ; return skb_out ; }","if ( pskb_expand_head ( skb_out , 0 , size - skb_out -> len , GFP_ATOMIC ) < 0 ) {kfree_skb ( skb_out ) ;",1351
215,buggy line: void exit_io_context ( void )  {task_lock ( current ) ;ioc = current -> io_context ;current -> io_context = NULL ;task_unlock ( current ) ;if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) {cwe id:CWE-20context:  void exit_io_context ( void )  { struct io_context * ioc ;  task_lock ( current ) ;   ioc = current -> io_context ;   current -> io_context = NULL ;   task_unlock ( current ) ;  if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; },void exit_io_context ( struct task_struct * task ) {task_lock ( task ) ;ioc = current -> io_context ;task -> io_context = NULL ;task_unlock ( task ) ;if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) {,1352
216,"buggy line: int ret = 0 ;# if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ;cwe id:CWE-200context: int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ;  int ret = 0 ;  # if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - EFAULT : 0 ; }","int ret = 0 ;if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT ;# if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ;",1353
217,"buggy line: * minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ;return GSS_S_DEFECTIVE_TOKEN ;if ( header -> buffer . length < token_wrapper_len + 14 ) {* minor_status = 0 ;cwe id:CWE-119context: static OM_uint32 kg_unseal_v1_iov ( krb5_context context , OM_uint32 * minor_status , krb5_gss_ctx_id_rec * ctx , gss_iov_buffer_desc * iov , int iov_count , size_t token_wrapper_len , int * conf_state , gss_qop_t * qop_state , int toktype ) { OM_uint32 code ; gss_iov_buffer_t header ; gss_iov_buffer_t trailer ; unsigned char * ptr ; int sealalg ; int signalg ; krb5_checksum cksum ; krb5_checksum md5cksum ; size_t cksum_len = 0 ; size_t conflen = 0 ; int direction ; krb5_ui_4 seqnum ; OM_uint32 retval ; size_t sumlen ; krb5_keyusage sign_usage = KG_USAGE_SIGN ; md5cksum . length = cksum . length = 0 ; md5cksum . contents = cksum . contents = NULL ; header = kg_locate_header_iov ( iov , iov_count , toktype ) ; assert ( header != NULL ) ; trailer = kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_TRAILER ) ; if ( trailer != NULL && trailer -> buffer . length != 0 ) {  * minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ;  return GSS_S_DEFECTIVE_TOKEN ; }  if ( header -> buffer . length < token_wrapper_len + 14 ) {  * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } ptr = ( unsigned char * ) header -> buffer . value + token_wrapper_len ; signalg = ptr [ 0 ] ; signalg |= ptr [ 1 ] << 8 ; sealalg = ptr [ 2 ] ; sealalg |= ptr [ 3 ] << 8 ; if ( ptr [ 4 ] != 0xFF || ptr [ 5 ] != 0xFF ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( toktype != KG_TOK_WRAP_MSG && sealalg != 0xFFFF ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( toktype == KG_TOK_WRAP_MSG && ! ( sealalg == 0xFFFF || sealalg == ctx -> sealalg ) ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ( ctx -> sealalg == SEAL_ALG_NONE && signalg > 1 ) || ( ctx -> sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3 ) || ( ctx -> sealalg == SEAL_ALG_DES3KD && signalg != SGN_ALG_HMAC_SHA1_DES3_KD ) || ( ctx -> sealalg == SEAL_ALG_MICROSOFT_RC4 && signalg != SGN_ALG_HMAC_MD5 ) ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_MD2_5 : case SGN_ALG_HMAC_MD5 : cksum_len = 8 ; if ( toktype != KG_TOK_WRAP_MSG ) sign_usage = 15 ; break ; case SGN_ALG_3 : cksum_len = 16 ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : cksum_len = 20 ; break ; default : * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } code = kg_get_seq_num ( context , ctx -> seq , ptr + 14 , ptr + 6 , & direction , & seqnum ) ; if ( code != 0 ) { * minor_status = code ; return GSS_S_BAD_SIG ; } if ( toktype == KG_TOK_WRAP_MSG ) { if ( sealalg != 0xFFFF ) { if ( ctx -> sealalg == SEAL_ALG_MICROSOFT_RC4 ) { unsigned char bigend_seqnum [ 4 ] ; krb5_keyblock * enc_key ; size_t i ; store_32_be ( seqnum , bigend_seqnum ) ; code = krb5_k_key_keyblock ( context , ctx -> enc , & enc_key ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } assert ( enc_key -> length == 16 ) ; for ( i = 0 ; i < enc_key -> length ; i ++ ) ( ( char * ) enc_key -> contents ) [ i ] ^= 0xF0 ; code = kg_arcfour_docrypt_iov ( context , enc_key , 0 , & bigend_seqnum [ 0 ] , 4 , iov , iov_count ) ; krb5_free_keyblock ( context , enc_key ) ; } else { code = kg_decrypt_iov ( context , 0 , ( ( ctx -> gss_flags & GSS_C_DCE_STYLE ) != 0 ) , 0 , 0 , ctx -> enc , KG_USAGE_SEAL , NULL , iov , iov_count ) ; } if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } } conflen = kg_confounder_size ( context , ctx -> enc -> keyblock . enctype ) ; } if ( header -> buffer . length != token_wrapper_len + 14 + cksum_len + conflen ) { retval = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_MD2_5 : case SGN_ALG_DES_MAC : case SGN_ALG_3 : md5cksum . checksum_type = CKSUMTYPE_RSA_MD5 ; break ; case SGN_ALG_HMAC_MD5 : md5cksum . checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : md5cksum . checksum_type = CKSUMTYPE_HMAC_SHA1_DES3 ; break ; default : abort ( ) ; } code = krb5_c_checksum_length ( context , md5cksum . checksum_type , & sumlen ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } md5cksum . length = sumlen ; code = kg_make_checksum_iov_v1 ( context , md5cksum . checksum_type , cksum_len , ctx -> seq , ctx -> enc , sign_usage , iov , iov_count , toktype , & md5cksum ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_3 : code = kg_encrypt_inplace ( context , ctx -> seq , KG_USAGE_SEAL , ( g_OID_equal ( ctx -> mech_used , gss_mech_krb5_old ) ? ctx -> seq -> keyblock . contents : NULL ) , md5cksum . contents , 16 ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } cksum . length = cksum_len ; cksum . contents = md5cksum . contents + 16 - cksum . length ; code = k5_bcmp ( cksum . contents , ptr + 14 , cksum . length ) ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : case SGN_ALG_HMAC_MD5 : code = k5_bcmp ( md5cksum . contents , ptr + 14 , cksum_len ) ; break ; default : code = 0 ; retval = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; break ; } if ( code != 0 ) { code = 0 ; retval = GSS_S_BAD_SIG ; goto cleanup ; } if ( toktype == KG_TOK_WRAP_MSG && ( ctx -> gss_flags & GSS_C_DCE_STYLE ) == 0 ) { retval = kg_fixup_padding_iov ( & code , iov , iov_count ) ; if ( retval != GSS_S_COMPLETE ) goto cleanup ; } if ( conf_state != NULL ) * conf_state = ( sealalg != 0xFFFF ) ; if ( qop_state != NULL ) * qop_state = GSS_C_QOP_DEFAULT ; if ( ( ctx -> initiate && direction != 0xff ) || ( ! ctx -> initiate && direction != 0 ) ) { * minor_status = ( OM_uint32 ) G_BAD_DIRECTION ; retval = GSS_S_BAD_SIG ; } code = 0 ; retval = g_order_check ( & ctx -> seqstate , ( gssint_uint64 ) seqnum ) ; cleanup : krb5_free_checksum_contents ( context , & md5cksum ) ; * minor_status = code ; return retval ; }",* minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ;return GSS_S_DEFECTIVE_TOKEN ;if ( ctx -> seq == NULL ) {* minor_status = 0 ;return GSS_S_DEFECTIVE_TOKEN ;}if ( header -> buffer . length < token_wrapper_len + 22 ) {* minor_status = 0 ;,1354
218,"buggy line: int i ;int ret ;ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ;if ( ! pci_is_enabled ( dev ) ) return ret ;if ( dev -> resource [ i ] . flags & IORESOURCE_IO )  * value |= PCI_COMMAND_IO ;if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ;}cwe id:CWE-264context: static int command_read ( struct pci_dev * dev , int offset , u16 * value , void * data ) {  int i ;  int ret ;  ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ;  if ( ! pci_is_enabled ( dev ) ) return ret ; for ( i = 0 ; i < PCI_ROM_RESOURCE ; i ++ ) { if ( dev -> resource [ i ] . flags & IORESOURCE_IO )  * value |= PCI_COMMAND_IO ;  if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ; } return ret ; }","int ret = pci_read_config_word ( dev , offset , value , data ) ;if ( ! pci_is_enabled ( dev ) ) return ret ;if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) * value |= cmd -> val & ~ PCI_COMMAND_GUEST ;",1355
219,"buggy line: static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ;if ( frame != NULL ) {YV12_BUFFER_CONFIG * fb ;vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ;yuvconfig2image ( & frame -> img , fb , NULL ) ;cwe id:CWE-119context: static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {   vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ;  if ( frame != NULL ) {  YV12_BUFFER_CONFIG * fb ;   vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ;  yuvconfig2image ( & frame -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }","static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {vp9_ref_frame_t * const frame = va_arg ( args , vp9_ref_frame_t * ) ;if ( frame != NULL ) {YV12_BUFFER_CONFIG * fb = get_ref_frame ( & ctx -> cpi -> common , frame -> idx ) ;if ( fb == NULL ) return VPX_CODEC_ERROR ;yuvconfig2image ( & frame -> img , fb , NULL ) ;",1356
220,buggy line: kfree ( fpl ) ;}cwe id:CWE-399context: void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ;  kfree ( fpl ) ;  } },free_uid ( fpl -> user ) ;kfree ( fpl ) ;},1357
221,"buggy line: kiocb_batch_free ( & batch ) ;put_ioctx ( ctx ) ;cwe id:CWE-399context: long do_io_submit ( aio_context_t ctx_id , long nr , struct iocb __user * __user * iocbpp , bool compat ) { struct kioctx * ctx ; long ret = 0 ; int i = 0 ; struct blk_plug plug ; struct kiocb_batch batch ; if ( unlikely ( nr < 0 ) ) return - EINVAL ; if ( unlikely ( nr > LONG_MAX / sizeof ( * iocbpp ) ) ) nr = LONG_MAX / sizeof ( * iocbpp ) ; if ( unlikely ( ! access_ok ( VERIFY_READ , iocbpp , ( nr * sizeof ( * iocbpp ) ) ) ) ) return - EFAULT ; ctx = lookup_ioctx ( ctx_id ) ; if ( unlikely ( ! ctx ) ) { pr_debug ( ""EINVAL:<S2SV_blank>io_submit:<S2SV_blank>invalid<S2SV_blank>context<S2SV_blank>id\\n"" ) ; return - EINVAL ; } kiocb_batch_init ( & batch , nr ) ; blk_start_plug ( & plug ) ; for ( i = 0 ; i < nr ; i ++ ) { struct iocb __user * user_iocb ; struct iocb tmp ; if ( unlikely ( __get_user ( user_iocb , iocbpp + i ) ) ) { ret = - EFAULT ; break ; } if ( unlikely ( copy_from_user ( & tmp , user_iocb , sizeof ( tmp ) ) ) ) { ret = - EFAULT ; break ; } ret = io_submit_one ( ctx , user_iocb , & tmp , & batch , compat ) ; if ( ret ) break ; } blk_finish_plug ( & plug ) ;  kiocb_batch_free ( & batch ) ;  put_ioctx ( ctx ) ; return i ? i : ret ; }","kiocb_batch_free ( ctx , & batch ) ;put_ioctx ( ctx ) ;",1358
222,"buggy line: req -> started = false ;list_del ( & req -> list ) ;req -> remaining = 0 ;if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ;if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ;req -> trb = NULL ;trace_dwc3_gadget_giveback ( req ) ;usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ;spin_lock ( & dwc -> lock ) ;if ( dep -> number > 1 )  pm_runtime_put ( dwc -> dev ) ;cwe id:CWE-189context: void dwc3_gadget_giveback ( struct dwc3_ep * dep , struct dwc3_request * req , int status ) { struct dwc3 * dwc = dep -> dwc ;  req -> started = false ;  list_del ( & req -> list ) ; req -> remaining = 0 ; if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ; if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ; req -> trb = NULL ; trace_dwc3_gadget_giveback ( req ) ; spin_unlock ( & dwc -> lock ) ; usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ; spin_lock ( & dwc -> lock ) ;  if ( dep -> number > 1 )  pm_runtime_put ( dwc -> dev ) ; }","dwc3_gadget_del_and_unmap_request ( dep , req , status ) ;",1359
223,"buggy line: char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ;char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ;if ( prefix != \'+\' && prefix != \'-\' && prefix != \'=\' ) {yyerror ( ""Logconfig<S2SV_blank>prefix<S2SV_blank>is<S2SV_blank>not<S2SV_blank>\\\'+\\\',<S2SV_blank>\\\'-\\\'<S2SV_blank>or<S2SV_blank>\\\'=\\\'\\\}else ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ;YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ;}case 216 : # line 1012 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;break ;case 217 : # line 1017 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;case 227 : # line 1048 ""ntp_parser.y""  {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;break ;case 228 : # line 1049 ""ntp_parser.y""  {( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ;break ;case 229 : # line 1054 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ;case 230 : # line 1056 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ;case 231 : # line 1061 ""ntp_parser.y"" {case 233 : # line 1067 ""ntp_parser.y"" {case 234 : # line 1071 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ;case 235 : # line 1072 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;case 236 : # line 1076 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ;case 237 :  # line 1077 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Address_node ) ) ;case 238 :  # line 1082 ""ntp_parser.y""  {cwe id:CWE-20context: int yyparse ( void ) # else int yyparse ( ) # endif # endif { int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yytoken = 0 ; yyss = yyssa ; yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; yyssp = yyss ; yyvsp = yyvs ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yyn == YYPACT_NINF ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = YYLEX ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yyn == 0 || yyn == YYTABLE_NINF ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; * ++ yyvsp = yylval ; goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 5 : # line 320 ""ntp_parser.y"" { msyslog ( LOG_ERR , ""syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d,<S2SV_blank>column<S2SV_blank>%d"" , ip_file -> fname , ip_file -> err_line_no , ip_file -> err_col_no ) ; } break ; case 19 : # line 354 ""ntp_parser.y"" { struct peer_node * my_node = create_peer_node ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ; if ( my_node ) enqueue ( cfgt . peers , my_node ) ; } break ; case 20 : # line 360 ""ntp_parser.y"" { struct peer_node * my_node = create_peer_node ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) , NULL ) ; if ( my_node ) enqueue ( cfgt . peers , my_node ) ; } break ; case 27 : # line 377 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) , AF_INET ) ; } break ; case 28 : # line 378 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) , AF_INET6 ) ; } break ; case 29 : # line 382 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) , 0 ) ; } break ; case 30 : # line 386 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 31 : # line 387 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 32 : # line 391 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 33 : # line 392 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 34 : # line 393 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 35 : # line 394 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 36 : # line 395 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 37 : # line 396 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 38 : # line 397 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 39 : # line 398 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 40 : # line 399 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 41 : # line 400 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 42 : # line 401 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 43 : # line 402 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 44 : # line 403 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 45 : # line 404 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 46 : # line 405 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 47 : # line 415 ""ntp_parser.y"" { struct unpeer_node * my_node = create_unpeer_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; if ( my_node ) enqueue ( cfgt . unpeers , my_node ) ; } break ; case 50 : # line 434 ""ntp_parser.y"" { cfgt . broadcastclient = 1 ; } break ; case 51 : # line 436 ""ntp_parser.y"" { append_queue ( cfgt . manycastserver , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 52 : # line 438 ""ntp_parser.y"" { append_queue ( cfgt . multicastclient , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 53 : # line 449 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 54 : # line 451 ""ntp_parser.y"" { cfgt . auth . control_key = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 55 : # line 453 ""ntp_parser.y"" { cfgt . auth . cryptosw ++ ; append_queue ( cfgt . auth . crypto_cmd_list , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 56 : # line 458 ""ntp_parser.y"" { cfgt . auth . keys = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 57 : # line 460 ""ntp_parser.y"" { cfgt . auth . keysdir = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 58 : # line 462 ""ntp_parser.y"" { cfgt . auth . request_key = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 59 : # line 464 ""ntp_parser.y"" { cfgt . auth . revoke = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 60 : # line 466 ""ntp_parser.y"" { cfgt . auth . trusted_key_list = ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ; } break ; case 61 : # line 468 ""ntp_parser.y"" { cfgt . auth . ntp_signd_socket = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 63 : # line 474 ""ntp_parser.y"" { ( yyval . Queue ) = create_queue ( ) ; } break ; case 64 : # line 479 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 65 : # line 486 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 66 : # line 496 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 67 : # line 498 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 68 : # line 500 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 69 : # line 502 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 70 : # line 504 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 71 : # line 506 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 72 : # line 508 ""ntp_parser.y"" { ( yyval . Attr_val ) = NULL ; cfgt . auth . revoke = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; msyslog ( LOG_WARNING , ""\'crypto<S2SV_blank>revoke<S2SV_blank>%d\'<S2SV_blank>is<S2SV_blank>deprecated,<S2SV_blank>"" ""please<S2SV_blank>use<S2SV_blank>\'revoke<S2SV_blank>%d\'<S2SV_blank>instead."" , cfgt . auth . revoke , cfgt . auth . revoke ) ; } break ; case 73 : # line 525 ""ntp_parser.y"" { append_queue ( cfgt . orphan_cmds , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 74 : # line 529 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 75 : # line 530 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 76 : # line 535 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 77 : # line 537 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 78 : # line 539 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 79 : # line 541 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 80 : # line 543 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 81 : # line 545 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 82 : # line 547 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 83 : # line 549 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 84 : # line 551 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 85 : # line 553 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 86 : # line 555 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 87 : # line 565 ""ntp_parser.y"" { append_queue ( cfgt . stats_list , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 88 : # line 567 ""ntp_parser.y"" { if ( input_from_file ) cfgt . stats_dir = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""statsdir<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 89 : # line 576 ""ntp_parser.y"" { enqueue ( cfgt . filegen_opts , create_filegen_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 90 : # line 583 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 91 : # line 584 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 100 : # line 600 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 101 : # line 607 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 102 : # line 617 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; else { ( yyval . Attr_val ) = NULL ; free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""filegen<S2SV_blank>file<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 103 : # line 627 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>type<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 104 : # line 636 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>link<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 105 : # line 645 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>nolink<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 106 : # line 653 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 107 : # line 654 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 115 : # line 674 ""ntp_parser.y"" { append_queue ( cfgt . discard_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 116 : # line 678 ""ntp_parser.y"" { append_queue ( cfgt . mru_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 117 : # line 682 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , NULL , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 118 : # line 687 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( ( yyvsp [ ( 2 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 5 ) - ( 5 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 119 : # line 692 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( NULL , NULL , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 120 : # line 697 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( create_address_node ( estrdup ( ""0.0.0.0"" ) , AF_INET ) , create_address_node ( estrdup ( ""0.0.0.0"" ) , AF_INET ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 121 : # line 710 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( create_address_node ( estrdup ( ""::"" ) , AF_INET6 ) , create_address_node ( estrdup ( ""::"" ) , AF_INET6 ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 122 : # line 723 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( NULL , NULL , enqueue ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) , ip_file -> line_no ) ) ; } break ; case 123 : # line 734 ""ntp_parser.y"" { ( yyval . Queue ) = create_queue ( ) ; } break ; case 124 : # line 736 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 139 : # line 758 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 140 : # line 760 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 141 : # line 764 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 142 : # line 765 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 143 : # line 766 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 144 : # line 771 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 145 : # line 773 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 146 : # line 777 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 147 : # line 778 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 148 : # line 779 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 149 : # line 780 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 150 : # line 781 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 151 : # line 782 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 152 : # line 783 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 153 : # line 784 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 154 : # line 793 ""ntp_parser.y"" { enqueue ( cfgt . fudge , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 155 : # line 798 ""ntp_parser.y"" { enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 156 : # line 800 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 157 : # line 804 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 158 : # line 805 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 159 : # line 806 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 160 : # line 807 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 161 : # line 808 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 162 : # line 809 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 163 : # line 810 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 164 : # line 811 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 165 : # line 820 ""ntp_parser.y"" { append_queue ( cfgt . enable_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 166 : # line 822 ""ntp_parser.y"" { append_queue ( cfgt . disable_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 167 : # line 827 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 168 : # line 834 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 169 : # line 843 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 170 : # line 844 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 171 : # line 845 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 172 : # line 846 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 173 : # line 847 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 174 : # line 848 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 175 : # line 850 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""enable/disable<S2SV_blank>stats<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 176 : # line 865 ""ntp_parser.y"" { append_queue ( cfgt . tinker , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 177 : # line 869 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 178 : # line 870 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 179 : # line 874 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 180 : # line 875 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 181 : # line 876 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 182 : # line 877 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 183 : # line 878 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 184 : # line 879 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 185 : # line 880 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 187 : # line 891 ""ntp_parser.y"" { if ( curr_include_level >= MAXINCLUDELEVEL ) { fprintf ( stderr , ""getconfig:<S2SV_blank>Maximum<S2SV_blank>include<S2SV_blank>file<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; msyslog ( LOG_ERR , ""getconfig:<S2SV_blank>Maximum<S2SV_blank>include<S2SV_blank>file<S2SV_blank>level<S2SV_blank>exceeded."" ) ; } else { fp [ curr_include_level + 1 ] = F_OPEN ( FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) , ""r"" ) ; if ( fp [ curr_include_level + 1 ] == NULL ) { fprintf ( stderr , ""getconfig:<S2SV_blank>Couldn\'t<S2SV_blank>open<S2SV_blank><%s>\\n"" , FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) ) ; msyslog ( LOG_ERR , ""getconfig:<S2SV_blank>Couldn\'t<S2SV_blank>open<S2SV_blank><%s>"" , FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) ) ; } else ip_file = fp [ ++ curr_include_level ] ; } } break ; case 188 : # line 907 ""ntp_parser.y"" { while ( curr_include_level != - 1 ) FCLOSE ( fp [ curr_include_level -- ] ) ; } break ; case 189 : # line 913 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; } break ; case 190 : # line 915 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 191 : # line 917 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; } break ; case 192 : # line 919 ""ntp_parser.y"" { } break ; case 193 : # line 921 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 194 : # line 924 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 195 : # line 926 ""ntp_parser.y"" { if ( input_from_file ) enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""logfile<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 196 : # line 937 ""ntp_parser.y"" { append_queue ( cfgt . logconfig , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 197 : # line 939 ""ntp_parser.y"" { append_queue ( cfgt . phone , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 198 : # line 941 ""ntp_parser.y"" { if ( input_from_file ) enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""saveconfigdir<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 199 : # line 951 ""ntp_parser.y"" { enqueue ( cfgt . setvar , ( yyvsp [ ( 2 ) - ( 2 ) ] . Set_var ) ) ; } break ; case 200 : # line 953 ""ntp_parser.y"" { enqueue ( cfgt . trap , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) , NULL ) ) ; } break ; case 201 : # line 955 ""ntp_parser.y"" { enqueue ( cfgt . trap , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 202 : # line 957 ""ntp_parser.y"" { append_queue ( cfgt . ttl , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 203 : # line 959 ""ntp_parser.y"" { enqueue ( cfgt . qos , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 204 : # line 964 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 205 : # line 966 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( T_WanderThreshold , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ( yyvsp [ ( 1 ) - ( 2 ) ] . String ) ) ) ; } break ; case 206 : # line 969 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ""\\0"" ) ) ; } break ; case 207 : # line 974 ""ntp_parser.y"" { ( yyval . Set_var ) = create_setvar_node ( ( yyvsp [ ( 1 ) - ( 4 ) ] . String ) , ( yyvsp [ ( 3 ) - ( 4 ) ] . String ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Integer ) ) ; } break ; case 208 : # line 976 ""ntp_parser.y"" { ( yyval . Set_var ) = create_setvar_node ( ( yyvsp [ ( 1 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , 0 ) ; } break ; case 209 : # line 981 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 210 : # line 982 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 211 : # line 986 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 212 : # line 987 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_pval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 213 : # line 991 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 214 : # line 992 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 215 : # line 997 ""ntp_parser.y"" {  char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ;   char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ;   if ( prefix != '+' && prefix != '-' && prefix != '=' ) {  yyerror ( ""Logconfig<S2SV_blank>prefix<S2SV_blank>is<S2SV_blank>not<S2SV_blank>\'+\',<S2SV_blank>\'-\'<S2SV_blank>or<S2SV_blank>\'=\'\\n"" ) ; } else ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ;  YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ;  } break ; case 216 : # line 1012 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1017 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1048 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; }  break ; case 228 : # line 1049 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; }  break ; case 229 : # line 1054 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1056 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1061 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1067 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1071 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 235 : # line 1072 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1076 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ;  case 237 :  # line 1077 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Address_node ) ) ; } break ; case 238 :  # line 1082 ""ntp_parser.y""  { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) != 0 && ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) != 1 ) { yyerror ( ""Integer<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>boolean<S2SV_blank>(0<S2SV_blank>or<S2SV_blank>1).<S2SV_blank>Assuming<S2SV_blank>1"" ) ; ( yyval . Integer ) = 1 ; } else ( yyval . Integer ) = ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ; } break ; case 239 :  # line 1090 ""ntp_parser.y""  { ( yyval . Integer ) = 1 ; } break ; case 240 :  # line 1091 ""ntp_parser.y""  { ( yyval . Integer ) = 0 ; } break ; case 241 :  # line 1095 ""ntp_parser.y""  { ( yyval . Double ) = ( double ) ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ; } break ; case 243 :  # line 1106 ""ntp_parser.y""  { cfgt . sim_details = create_sim_node ( ( yyvsp [ ( 3 ) - ( 5 ) ] . Queue ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Queue ) ) ; old_config_style = 1 ; } break ; case 244 :  # line 1120 ""ntp_parser.y""  { old_config_style = 0 ; } break ; case 245 :  # line 1124 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Attr_val ) ) ; } break ; case 246 :  # line 1125 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 247 :  # line 1129 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 248 :  # line 1130 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 249 :  # line 1134 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Sim_server ) ) ; } break ; case 250 :  # line 1135 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Sim_server ) ) ; } break ; case 251 :  # line 1140 ""ntp_parser.y""  { ( yyval . Sim_server ) = create_sim_server ( ( yyvsp [ ( 1 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 5 ) ] . Double ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Queue ) ) ; } break ; case 252 :  # line 1144 ""ntp_parser.y""  { ( yyval . Double ) = ( yyvsp [ ( 3 ) - ( 4 ) ] . Double ) ; } break ; case 253 :  # line 1148 ""ntp_parser.y""  { ( yyval . Address_node ) = ( yyvsp [ ( 3 ) - ( 3 ) ] . Address_node ) ; } break ; case 254 :  # line 1152 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Sim_script ) ) ; } break ; case 255 :  # line 1153 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Sim_script ) ) ; } break ; case 256 :  # line 1158 ""ntp_parser.y""  { ( yyval . Sim_script ) = create_sim_script_info ( ( yyvsp [ ( 3 ) - ( 6 ) ] . Double ) , ( yyvsp [ ( 5 ) - ( 6 ) ] . Queue ) ) ; } break ; case 257 :  # line 1162 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Attr_val ) ) ; } break ; case 258 :  # line 1163 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 259 :  # line 1168 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 260 :  # line 1170 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 261 :  # line 1172 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 262 :  # line 1174 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 263 :  # line 1176 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ;  # line 3826 ""ntp_parser.c""  default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else { YYSIZE_T yysize = yysyntax_error ( 0 , yystate , yychar ) ; if ( yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM ) { YYSIZE_T yyalloc = 2 * yysize ; if ( ! ( yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM ) ) yyalloc = YYSTACK_ALLOC_MAXIMUM ; if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yyalloc ) ; if ( yymsg ) yymsg_alloc = yyalloc ; else { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; } } if ( 0 < yysize && yysize <= yymsg_alloc ) { ( void ) yysyntax_error ( yymsg , yystate , yychar ) ; yyerror ( yymsg ) ; } else { yyerror ( YY_ ( ""syntax<S2SV_blank>error"" ) ) ; if ( yysize != 0 ) goto yyexhaustedlab ; } } # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( yyn != YYPACT_NINF ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } * ++ yyvsp = yylval ; YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined ( yyoverflow ) || YYERROR_VERBOSE yyexhaustedlab : yyerror ( YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval ) ; YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return YYID ( yyresult ) ; }","char prefix ;char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ) {case \'+\' : case \'-\' : case \'=\' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ;type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ;default : prefix = \'=\' ;type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ;( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ;YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;case 235 : # line 1082 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;break ;case 236 : # line 1086 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;break ;case 228 : # line 1059 ""ntp_parser.y"" {( yyval . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ;case 237 : # line 1087 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ;case 231 : # line 1071 ""ntp_parser.y"" {case 233 : # line 1077 ""ntp_parser.y"" {case 234 : # line 1081 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ;case 216 : # line 1012 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;case 217 : # line 1017 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;}break ;case 227 : # line 1048 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;case 228 : # line 1049 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ;case 238 : # line 1082 ""ntp_parser.y"" {",1360
224,"buggy line: case 239 :  # line 1090 ""ntp_parser.y""  {case 240 :  # line 1091 ""ntp_parser.y""  {case 241 :  # line 1095 ""ntp_parser.y""  {case 243 :  # line 1106 ""ntp_parser.y""  {case 244 :  # line 1120 ""ntp_parser.y""  {case 245 :  # line 1124 ""ntp_parser.y""  {case 246 :  # line 1125 ""ntp_parser.y""  {case 247 :  # line 1129 ""ntp_parser.y""  {case 248 :  # line 1130 ""ntp_parser.y""  {case 249 :  # line 1134 ""ntp_parser.y""  {case 250 :  # line 1135 ""ntp_parser.y""  {case 251 :  # line 1140 ""ntp_parser.y""  {case 252 :  # line 1144 ""ntp_parser.y""  {case 253 :  # line 1148 ""ntp_parser.y""  {case 254 :  # line 1152 ""ntp_parser.y""  {case 255 :  # line 1153 ""ntp_parser.y""  {case 256 :  # line 1158 ""ntp_parser.y""  {case 257 :  # line 1162 ""ntp_parser.y""  {case 258 :  # line 1163 ""ntp_parser.y""  {case 259 :  # line 1168 ""ntp_parser.y""  {case 260 :  # line 1170 ""ntp_parser.y""  {case 261 :  # line 1172 ""ntp_parser.y""  {case 262 :  # line 1174 ""ntp_parser.y""  {case 263 :  # line 1176 ""ntp_parser.y""  {# line 3826 ""ntp_parser.c""  default : break ;cwe id:CWE-20context: int yyparse ( void ) # else int yyparse ( ) # endif # endif { int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yytoken = 0 ; yyss = yyssa ; yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; yyssp = yyss ; yyvsp = yyvs ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yyn == YYPACT_NINF ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = YYLEX ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yyn == 0 || yyn == YYTABLE_NINF ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; * ++ yyvsp = yylval ; goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 5 : # line 320 ""ntp_parser.y"" { msyslog ( LOG_ERR , ""syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d,<S2SV_blank>column<S2SV_blank>%d"" , ip_file -> fname , ip_file -> err_line_no , ip_file -> err_col_no ) ; } break ; case 19 : # line 354 ""ntp_parser.y"" { struct peer_node * my_node = create_peer_node ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ; if ( my_node ) enqueue ( cfgt . peers , my_node ) ; } break ; case 20 : # line 360 ""ntp_parser.y"" { struct peer_node * my_node = create_peer_node ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) , NULL ) ; if ( my_node ) enqueue ( cfgt . peers , my_node ) ; } break ; case 27 : # line 377 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) , AF_INET ) ; } break ; case 28 : # line 378 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) , AF_INET6 ) ; } break ; case 29 : # line 382 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) , 0 ) ; } break ; case 30 : # line 386 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 31 : # line 387 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 32 : # line 391 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 33 : # line 392 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 34 : # line 393 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 35 : # line 394 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 36 : # line 395 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 37 : # line 396 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 38 : # line 397 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 39 : # line 398 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 40 : # line 399 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 41 : # line 400 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 42 : # line 401 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 43 : # line 402 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 44 : # line 403 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 45 : # line 404 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 46 : # line 405 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 47 : # line 415 ""ntp_parser.y"" { struct unpeer_node * my_node = create_unpeer_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; if ( my_node ) enqueue ( cfgt . unpeers , my_node ) ; } break ; case 50 : # line 434 ""ntp_parser.y"" { cfgt . broadcastclient = 1 ; } break ; case 51 : # line 436 ""ntp_parser.y"" { append_queue ( cfgt . manycastserver , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 52 : # line 438 ""ntp_parser.y"" { append_queue ( cfgt . multicastclient , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 53 : # line 449 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 54 : # line 451 ""ntp_parser.y"" { cfgt . auth . control_key = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 55 : # line 453 ""ntp_parser.y"" { cfgt . auth . cryptosw ++ ; append_queue ( cfgt . auth . crypto_cmd_list , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 56 : # line 458 ""ntp_parser.y"" { cfgt . auth . keys = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 57 : # line 460 ""ntp_parser.y"" { cfgt . auth . keysdir = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 58 : # line 462 ""ntp_parser.y"" { cfgt . auth . request_key = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 59 : # line 464 ""ntp_parser.y"" { cfgt . auth . revoke = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 60 : # line 466 ""ntp_parser.y"" { cfgt . auth . trusted_key_list = ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ; } break ; case 61 : # line 468 ""ntp_parser.y"" { cfgt . auth . ntp_signd_socket = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 63 : # line 474 ""ntp_parser.y"" { ( yyval . Queue ) = create_queue ( ) ; } break ; case 64 : # line 479 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 65 : # line 486 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 66 : # line 496 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 67 : # line 498 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 68 : # line 500 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 69 : # line 502 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 70 : # line 504 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 71 : # line 506 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 72 : # line 508 ""ntp_parser.y"" { ( yyval . Attr_val ) = NULL ; cfgt . auth . revoke = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; msyslog ( LOG_WARNING , ""\'crypto<S2SV_blank>revoke<S2SV_blank>%d\'<S2SV_blank>is<S2SV_blank>deprecated,<S2SV_blank>"" ""please<S2SV_blank>use<S2SV_blank>\'revoke<S2SV_blank>%d\'<S2SV_blank>instead."" , cfgt . auth . revoke , cfgt . auth . revoke ) ; } break ; case 73 : # line 525 ""ntp_parser.y"" { append_queue ( cfgt . orphan_cmds , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 74 : # line 529 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 75 : # line 530 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 76 : # line 535 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 77 : # line 537 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 78 : # line 539 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 79 : # line 541 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 80 : # line 543 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 81 : # line 545 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 82 : # line 547 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 83 : # line 549 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 84 : # line 551 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 85 : # line 553 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 86 : # line 555 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 87 : # line 565 ""ntp_parser.y"" { append_queue ( cfgt . stats_list , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 88 : # line 567 ""ntp_parser.y"" { if ( input_from_file ) cfgt . stats_dir = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""statsdir<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 89 : # line 576 ""ntp_parser.y"" { enqueue ( cfgt . filegen_opts , create_filegen_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 90 : # line 583 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 91 : # line 584 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 100 : # line 600 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 101 : # line 607 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 102 : # line 617 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; else { ( yyval . Attr_val ) = NULL ; free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""filegen<S2SV_blank>file<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 103 : # line 627 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>type<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 104 : # line 636 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>link<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 105 : # line 645 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>nolink<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 106 : # line 653 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 107 : # line 654 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 115 : # line 674 ""ntp_parser.y"" { append_queue ( cfgt . discard_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 116 : # line 678 ""ntp_parser.y"" { append_queue ( cfgt . mru_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 117 : # line 682 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , NULL , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 118 : # line 687 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( ( yyvsp [ ( 2 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 5 ) - ( 5 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 119 : # line 692 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( NULL , NULL , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 120 : # line 697 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( create_address_node ( estrdup ( ""0.0.0.0"" ) , AF_INET ) , create_address_node ( estrdup ( ""0.0.0.0"" ) , AF_INET ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 121 : # line 710 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( create_address_node ( estrdup ( ""::"" ) , AF_INET6 ) , create_address_node ( estrdup ( ""::"" ) , AF_INET6 ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 122 : # line 723 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( NULL , NULL , enqueue ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) , ip_file -> line_no ) ) ; } break ; case 123 : # line 734 ""ntp_parser.y"" { ( yyval . Queue ) = create_queue ( ) ; } break ; case 124 : # line 736 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 139 : # line 758 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 140 : # line 760 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 141 : # line 764 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 142 : # line 765 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 143 : # line 766 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 144 : # line 771 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 145 : # line 773 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 146 : # line 777 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 147 : # line 778 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 148 : # line 779 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 149 : # line 780 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 150 : # line 781 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 151 : # line 782 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 152 : # line 783 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 153 : # line 784 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 154 : # line 793 ""ntp_parser.y"" { enqueue ( cfgt . fudge , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 155 : # line 798 ""ntp_parser.y"" { enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 156 : # line 800 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 157 : # line 804 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 158 : # line 805 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 159 : # line 806 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 160 : # line 807 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 161 : # line 808 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 162 : # line 809 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 163 : # line 810 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 164 : # line 811 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 165 : # line 820 ""ntp_parser.y"" { append_queue ( cfgt . enable_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 166 : # line 822 ""ntp_parser.y"" { append_queue ( cfgt . disable_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 167 : # line 827 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 168 : # line 834 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 169 : # line 843 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 170 : # line 844 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 171 : # line 845 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 172 : # line 846 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 173 : # line 847 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 174 : # line 848 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 175 : # line 850 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""enable/disable<S2SV_blank>stats<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 176 : # line 865 ""ntp_parser.y"" { append_queue ( cfgt . tinker , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 177 : # line 869 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 178 : # line 870 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 179 : # line 874 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 180 : # line 875 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 181 : # line 876 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 182 : # line 877 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 183 : # line 878 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 184 : # line 879 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 185 : # line 880 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 187 : # line 891 ""ntp_parser.y"" { if ( curr_include_level >= MAXINCLUDELEVEL ) { fprintf ( stderr , ""getconfig:<S2SV_blank>Maximum<S2SV_blank>include<S2SV_blank>file<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; msyslog ( LOG_ERR , ""getconfig:<S2SV_blank>Maximum<S2SV_blank>include<S2SV_blank>file<S2SV_blank>level<S2SV_blank>exceeded."" ) ; } else { fp [ curr_include_level + 1 ] = F_OPEN ( FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) , ""r"" ) ; if ( fp [ curr_include_level + 1 ] == NULL ) { fprintf ( stderr , ""getconfig:<S2SV_blank>Couldn\'t<S2SV_blank>open<S2SV_blank><%s>\\n"" , FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) ) ; msyslog ( LOG_ERR , ""getconfig:<S2SV_blank>Couldn\'t<S2SV_blank>open<S2SV_blank><%s>"" , FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) ) ; } else ip_file = fp [ ++ curr_include_level ] ; } } break ; case 188 : # line 907 ""ntp_parser.y"" { while ( curr_include_level != - 1 ) FCLOSE ( fp [ curr_include_level -- ] ) ; } break ; case 189 : # line 913 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; } break ; case 190 : # line 915 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 191 : # line 917 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; } break ; case 192 : # line 919 ""ntp_parser.y"" { } break ; case 193 : # line 921 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 194 : # line 924 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 195 : # line 926 ""ntp_parser.y"" { if ( input_from_file ) enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""logfile<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 196 : # line 937 ""ntp_parser.y"" { append_queue ( cfgt . logconfig , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 197 : # line 939 ""ntp_parser.y"" { append_queue ( cfgt . phone , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 198 : # line 941 ""ntp_parser.y"" { if ( input_from_file ) enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""saveconfigdir<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 199 : # line 951 ""ntp_parser.y"" { enqueue ( cfgt . setvar , ( yyvsp [ ( 2 ) - ( 2 ) ] . Set_var ) ) ; } break ; case 200 : # line 953 ""ntp_parser.y"" { enqueue ( cfgt . trap , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) , NULL ) ) ; } break ; case 201 : # line 955 ""ntp_parser.y"" { enqueue ( cfgt . trap , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 202 : # line 957 ""ntp_parser.y"" { append_queue ( cfgt . ttl , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 203 : # line 959 ""ntp_parser.y"" { enqueue ( cfgt . qos , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 204 : # line 964 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 205 : # line 966 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( T_WanderThreshold , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ( yyvsp [ ( 1 ) - ( 2 ) ] . String ) ) ) ; } break ; case 206 : # line 969 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ""\\0"" ) ) ; } break ; case 207 : # line 974 ""ntp_parser.y"" { ( yyval . Set_var ) = create_setvar_node ( ( yyvsp [ ( 1 ) - ( 4 ) ] . String ) , ( yyvsp [ ( 3 ) - ( 4 ) ] . String ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Integer ) ) ; } break ; case 208 : # line 976 ""ntp_parser.y"" { ( yyval . Set_var ) = create_setvar_node ( ( yyvsp [ ( 1 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , 0 ) ; } break ; case 209 : # line 981 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 210 : # line 982 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 211 : # line 986 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 212 : # line 987 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_pval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 213 : # line 991 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 214 : # line 992 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 215 : # line 997 ""ntp_parser.y"" {  char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ;   char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ;   if ( prefix != '+' && prefix != '-' && prefix != '=' ) {  yyerror ( ""Logconfig<S2SV_blank>prefix<S2SV_blank>is<S2SV_blank>not<S2SV_blank>\'+\',<S2SV_blank>\'-\'<S2SV_blank>or<S2SV_blank>\'=\'\\n"" ) ; } else ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ;  YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ;  } break ; case 216 : # line 1012 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1017 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1048 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; }  break ; case 228 : # line 1049 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; }  break ; case 229 : # line 1054 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1056 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1061 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1067 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1071 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 235 : # line 1072 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1076 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ;  case 237 :  # line 1077 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Address_node ) ) ; } break ; case 238 :  # line 1082 ""ntp_parser.y""  { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) != 0 && ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) != 1 ) { yyerror ( ""Integer<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>boolean<S2SV_blank>(0<S2SV_blank>or<S2SV_blank>1).<S2SV_blank>Assuming<S2SV_blank>1"" ) ; ( yyval . Integer ) = 1 ; } else ( yyval . Integer ) = ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ; } break ; case 239 :  # line 1090 ""ntp_parser.y""  { ( yyval . Integer ) = 1 ; } break ; case 240 :  # line 1091 ""ntp_parser.y""  { ( yyval . Integer ) = 0 ; } break ; case 241 :  # line 1095 ""ntp_parser.y""  { ( yyval . Double ) = ( double ) ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ; } break ; case 243 :  # line 1106 ""ntp_parser.y""  { cfgt . sim_details = create_sim_node ( ( yyvsp [ ( 3 ) - ( 5 ) ] . Queue ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Queue ) ) ; old_config_style = 1 ; } break ; case 244 :  # line 1120 ""ntp_parser.y""  { old_config_style = 0 ; } break ; case 245 :  # line 1124 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Attr_val ) ) ; } break ; case 246 :  # line 1125 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 247 :  # line 1129 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 248 :  # line 1130 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 249 :  # line 1134 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Sim_server ) ) ; } break ; case 250 :  # line 1135 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Sim_server ) ) ; } break ; case 251 :  # line 1140 ""ntp_parser.y""  { ( yyval . Sim_server ) = create_sim_server ( ( yyvsp [ ( 1 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 5 ) ] . Double ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Queue ) ) ; } break ; case 252 :  # line 1144 ""ntp_parser.y""  { ( yyval . Double ) = ( yyvsp [ ( 3 ) - ( 4 ) ] . Double ) ; } break ; case 253 :  # line 1148 ""ntp_parser.y""  { ( yyval . Address_node ) = ( yyvsp [ ( 3 ) - ( 3 ) ] . Address_node ) ; } break ; case 254 :  # line 1152 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Sim_script ) ) ; } break ; case 255 :  # line 1153 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Sim_script ) ) ; } break ; case 256 :  # line 1158 ""ntp_parser.y""  { ( yyval . Sim_script ) = create_sim_script_info ( ( yyvsp [ ( 3 ) - ( 6 ) ] . Double ) , ( yyvsp [ ( 5 ) - ( 6 ) ] . Queue ) ) ; } break ; case 257 :  # line 1162 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Attr_val ) ) ; } break ; case 258 :  # line 1163 ""ntp_parser.y""  { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 259 :  # line 1168 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 260 :  # line 1170 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 261 :  # line 1172 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 262 :  # line 1174 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 263 :  # line 1176 ""ntp_parser.y""  { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ;  # line 3826 ""ntp_parser.c""  default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else { YYSIZE_T yysize = yysyntax_error ( 0 , yystate , yychar ) ; if ( yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM ) { YYSIZE_T yyalloc = 2 * yysize ; if ( ! ( yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM ) ) yyalloc = YYSTACK_ALLOC_MAXIMUM ; if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yyalloc ) ; if ( yymsg ) yymsg_alloc = yyalloc ; else { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; } } if ( 0 < yysize && yysize <= yymsg_alloc ) { ( void ) yysyntax_error ( yymsg , yystate , yychar ) ; yyerror ( yymsg ) ; } else { yyerror ( YY_ ( ""syntax<S2SV_blank>error"" ) ) ; if ( yysize != 0 ) goto yyexhaustedlab ; } } # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( yyn != YYPACT_NINF ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } * ++ yyvsp = yylval ; YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined ( yyoverflow ) || YYERROR_VERBOSE yyexhaustedlab : yyerror ( YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval ) ; YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return YYID ( yyresult ) ; }","case 239 : # line 1090 ""ntp_parser.y"" {case 240 : # line 1091 ""ntp_parser.y"" {case 241 : # line 1095 ""ntp_parser.y"" {case 243 : # line 1106 ""ntp_parser.y"" {case 244 : # line 1120 ""ntp_parser.y"" {case 245 : # line 1124 ""ntp_parser.y"" {case 246 : # line 1125 ""ntp_parser.y"" {case 247 : # line 1129 ""ntp_parser.y"" {case 248 : # line 1100 ""ntp_parser.y"" {case 249 : # line 1101 ""ntp_parser.y"" {case 250 : # line 1105 ""ntp_parser.y"" {case 251 : # line 1134 ""ntp_parser.y"" {case 252 : # line 1135 ""ntp_parser.y"" {case 253 : # line 1139 ""ntp_parser.y"" {case 254 : # line 1140 ""ntp_parser.y"" {case 255 : # line 1144 ""ntp_parser.y"" {case 256 : # line 1145 ""ntp_parser.y"" {case 257 : # line 1150 ""ntp_parser.y"" {case 258 : # line 1154 ""ntp_parser.y"" {case 259 : # line 1158 ""ntp_parser.y"" {case 260 : # line 1162 ""ntp_parser.y"" {case 261 : # line 1163 ""ntp_parser.y"" {case 262 : # line 1168 ""ntp_parser.y"" {case 263 : # line 1172 ""ntp_parser.y"" {# line 3836 ""ntp_parser.c"" default : break ;",1360
225,"buggy line: [ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain ,  [ DISCE_PROBE ] = sas_probe_devices ,  [ DISCE_SUSPEND ] = sas_suspend_devices ,  [ DISCE_RESUME ] = sas_resume_devices ,  [ DISCE_DESTRUCT ] = sas_destruct_devices , }cwe id:CWE-000context: void sas_init_disc ( struct sas_discovery * disc , struct asd_sas_port * port ) { int i ; static const work_func_t sas_event_fns [ DISC_NUM_EVENTS ] = { [ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain ,  [ DISCE_PROBE ] = sas_probe_devices ,  [ DISCE_SUSPEND ] = sas_suspend_devices ,  [ DISCE_RESUME ] = sas_resume_devices ,  [ DISCE_DESTRUCT ] = sas_destruct_devices , } ; disc -> pending = 0 ; for ( i = 0 ; i < DISC_NUM_EVENTS ; i ++ ) { INIT_SAS_WORK ( & disc -> disc_work [ i ] . work , sas_event_fns [ i ] ) ; disc -> disc_work [ i ] . port = port ; } }","[ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , [ DISCE_SUSPEND ] = sas_suspend_devices , [ DISCE_RESUME ] = sas_resume_devices , [ DISCE_DESTRUCT ] = sas_destruct_devices , }",1361
226,"buggy line: int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info ,  const char * name , int rep_quick )  {cwe id:CWE-362context: int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info ,  const char * name , int rep_quick )  { int got_error ; uint i ; ulong length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM sort_param ; MYISAM_SHARE * share = info -> s ; HA_KEYSEG * keyseg ; ulong * rec_per_key_part ; char llbuff [ 22 ] ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; DBUG_ENTER ( ""mi_repair_by_sort"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-<S2SV_blank>recovering<S2SV_blank>(with<S2SV_blank>sort)<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) ) ) goto err ; sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ; info -> opt_flag |= WRITE_CACHE_USED ; info -> rec_cache . file = info -> dfile ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param . record ) || ! mi_alloc_rec_buff ( info , - 1 , & sort_param . rec_buff ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>extra<S2SV_blank>record"" ) ; goto err ; } if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ; if ( param -> testflag & T_UNPACK ) { share -> options &= ~ HA_OPTION_COMPRESS_RECORD ; mi_int2store ( share -> state . header . options , share -> options ) ; } share -> state . dellink = HA_OFFSET_ERROR ; info -> rec_cache . file = new_file ; } info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; mi_drop_all_indexes ( param , info , FALSE ) ; key_map = share -> state . key_map ; if ( param -> testflag & T_CREATE_MISSING_KEYS ) { key_map = ~ key_map ; } sort_info . info = info ; sort_info . param = param ; set_data_file_type ( & sort_info , share ) ; sort_param . filepos = new_header_length ; sort_info . dupp = 0 ; sort_info . buff = 0 ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ; sort_param . wordlist = NULL ; init_alloc_root ( & sort_param . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ; if ( share -> data_file_type == DYNAMIC_RECORD ) length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ; else if ( share -> data_file_type == COMPRESSED_RECORD ) length = share -> base . min_block_length ; else length = share -> base . pack_reclength ; sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records : ( ha_rows ) ( sort_info . filelength / length + 1 ) ) ; sort_param . key_cmp = sort_key_cmp ; sort_param . lock_in_memory = lock_memory ; sort_param . tmpdir = param -> tmpdir ; sort_param . sort_info = & sort_info ; sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param . master = 1 ; del = info -> state -> del ; param -> glob_crc = 0 ; if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ; rec_per_key_part = param -> rec_per_key_part ; for ( sort_param . key = 0 ; sort_param . key < share -> base . keys ; rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) { sort_param . read_cache = param -> read_cache ; sort_param . keyinfo = share -> keyinfo + sort_param . key ; sort_param . seg = sort_param . keyinfo -> seg ; if ( ! mi_is_key_active ( key_map , sort_param . key ) ) { memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ; DBUG_PRINT ( ""repair"" , ( ""skipping<S2SV_blank>seemingly<S2SV_blank>disabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ; continue ; } if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\n"" , sort_param . key + 1 ) ; sort_param . max_pos = sort_param . pos = share -> pack . header_length ; keyseg = sort_param . seg ; bzero ( ( char * ) sort_param . unique , sizeof ( sort_param . unique ) ) ; sort_param . key_length = share -> rec_reflength ; for ( i = 0 ; keyseg [ i ] . type != HA_KEYTYPE_END ; i ++ ) { sort_param . key_length += keyseg [ i ] . length ; if ( keyseg [ i ] . flag & HA_SPACE_PACK ) sort_param . key_length += get_pack_length ( keyseg [ i ] . length ) ; if ( keyseg [ i ] . flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param . key_length += 2 + test ( keyseg [ i ] . length >= 127 ) ; if ( keyseg [ i ] . flag & HA_NULL_PART ) sort_param . key_length ++ ; } info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; if ( sort_param . keyinfo -> flag & HA_FULLTEXT ) { uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param . keyinfo -> seg -> charset -> mbmaxlen ; sort_param . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ; if ( sort_param . keyinfo -> parser == & ft_default_parser ) { sort_info . max_records = ( ha_rows ) ( sort_info . filelength / ft_min_word_len + 1 ) ; } else { sort_info . max_records = 10 * max ( param -> sort_buffer_length , MIN_SORT_BUFFER ) / sort_param . key_length ; } sort_param . key_read = sort_ft_key_read ; sort_param . key_write = sort_ft_key_write ; } else { sort_param . key_read = sort_key_read ; sort_param . key_write = sort_key_write ; } if ( _create_index_by_sort ( & sort_param , ( my_bool ) ( ! ( param -> testflag & T_VERBOSE ) ) , param -> sort_buffer_length ) ) { param -> retry_repair = 1 ; goto err ; } sort_param . calc_checksum = 0 ; free_root ( & sort_param . wordroot , MYF ( 0 ) ) ; sort_info . max_records = ( ha_rows ) info -> state -> records ; if ( param -> testflag & T_STATISTICS ) update_key_parts ( sort_param . keyinfo , rec_per_key_part , sort_param . unique , param -> stats_method == MI_STATS_METHOD_IGNORE_NULLS ? sort_param . notnull : NULL , ( ulonglong ) info -> state -> records ) ; mi_set_key_active ( share -> state . key_map , sort_param . key ) ; DBUG_PRINT ( ""repair"" , ( ""set<S2SV_blank>enabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ; if ( sort_param . fix_datafile ) { param -> read_cache . end_of_file = sort_param . filepos ; if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ; if ( param -> testflag & T_SAFE_REPAIR ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; goto err ; } } share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; mysql_file_close ( info -> dfile , MYF ( 0 ) ) ; info -> dfile = new_file ; share -> data_file_type = sort_info . new_data_file_type ; share -> pack . header_length = ( ulong ) new_header_length ; sort_param . fix_datafile = 0 ; } else info -> state -> data_file_length = sort_param . max_pos ; param -> read_cache . file = info -> dfile ; reinit_io_cache ( & param -> read_cache , READ_CACHE , share -> pack . header_length , 1 , 1 ) ; } if ( param -> testflag & T_WRITE_LOOP ) { ( void ) fputs ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\r"" , stdout ) ; ( void ) fflush ( stdout ) ; } if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ; mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ; got_error = 1 ; param -> retry_repair = 1 ; param -> testflag |= T_RETRY_WITHOUT_QUICK ; goto err ; } if ( rep_quick & T_FORCE_UNIQUENESS ) { my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ; # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ; # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; } if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ; if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; if ( ! ( param -> testflag & T_SILENT ) ) { if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; if ( ! got_error ) { if ( new_file >= 0 ) {  mysql_file_close ( new_file , MYF ( 0 ) ) ;  info -> dfile = new_file = - 1 ; if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>fixing<S2SV_blank>table"" , my_errno ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ; } mi_mark_crashed_on_repair ( info ) ; } else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ; share -> state . changed |= STATE_NOT_SORTED_PAGES ; my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ; my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ; my_free ( sort_info . key_block ) ; my_free ( sort_info . ft_buf ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ; if ( ! got_error && ( param -> testflag & T_UNPACK ) ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ; share -> pack . header_length = 0 ; } DBUG_RETURN ( got_error ) ; }","int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick , my_bool no_copy_stat ) {",1362
227,"buggy line: if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {mi_check_print_error ( param , ""Can\\\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\\\'%s\\\'"" , param -> temp_filename ) ;goto err ;}if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ;if ( param -> testflag & T_UNPACK ) {share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;mi_int2store ( share -> state . header . options , share -> options ) ;}share -> state . dellink = HA_OFFSET_ERROR ;info -> rec_cache . file = new_file ;}info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;mi_drop_all_indexes ( param , info , FALSE ) ;key_map = share -> state . key_map ;if ( param -> testflag & T_CREATE_MISSING_KEYS ) {key_map = ~ key_map ;}sort_info . info = info ;sort_info . param = param ;set_data_file_type ( & sort_info , share ) ;sort_param . filepos = new_header_length ;sort_info . dupp = 0 ;sort_info . buff = 0 ;param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ;sort_param . wordlist = NULL ;init_alloc_root ( & sort_param . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ;if ( share -> data_file_type == DYNAMIC_RECORD ) length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ;else if ( share -> data_file_type == COMPRESSED_RECORD ) length = share -> base . min_block_length ;else length = share -> base . pack_reclength ;sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records : ( ha_rows ) ( sort_info . filelength / length + 1 ) ) ;sort_param . key_cmp = sort_key_cmp ;sort_param . lock_in_memory = lock_memory ;sort_param . tmpdir = param -> tmpdir ;sort_param . sort_info = & sort_info ;sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ;sort_param . master = 1 ;del = info -> state -> del ;param -> glob_crc = 0 ;if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ;rec_per_key_part = param -> rec_per_key_part ;for ( sort_param . key = 0 ;sort_param . key < share -> base . keys ;rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) {sort_param . read_cache = param -> read_cache ;sort_param . keyinfo = share -> keyinfo + sort_param . key ;sort_param . seg = sort_param . keyinfo -> seg ;if ( ! mi_is_key_active ( key_map , sort_param . key ) ) {memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;DBUG_PRINT ( ""repair"" , ( ""skipping<S2SV_blank>seemingly<S2SV_blank>disabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ;continue ;}if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\\sort_param . max_pos = sort_param . pos = share -> pack . header_length ;keyseg = sort_param . seg ;bzero ( ( char * ) sort_param . unique , sizeof ( sort_param . unique ) ) ;sort_param . key_length = share -> rec_reflength ;for ( i = 0 ;keyseg [ i ] . type != HA_KEYTYPE_END ;i ++ ) {sort_param . key_length += keyseg [ i ] . length ;if ( keyseg [ i ] . flag & HA_SPACE_PACK ) sort_param . key_length += get_pack_length ( keyseg [ i ] . length ) ;if ( keyseg [ i ] . flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param . key_length += 2 + test ( keyseg [ i ] . length >= 127 ) ;if ( keyseg [ i ] . flag & HA_NULL_PART ) sort_param . key_length ++ ;}info -> state -> records = info -> state -> del = share -> state . split = 0 ;info -> state -> empty = 0 ;if ( sort_param . keyinfo -> flag & HA_FULLTEXT ) {uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param . keyinfo -> seg -> charset -> mbmaxlen ;sort_param . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ;if ( sort_param . keyinfo -> parser == & ft_default_parser ) {sort_info . max_records = ( ha_rows ) ( sort_info . filelength / ft_min_word_len + 1 ) ;}else {sort_info . max_records = 10 * max ( param -> sort_buffer_length , MIN_SORT_BUFFER ) / sort_param . key_length ;}sort_param . key_read = sort_ft_key_read ;sort_param . key_write = sort_ft_key_write ;}else {sort_param . key_read = sort_key_read ;sort_param . key_write = sort_key_write ;}if ( _create_index_by_sort ( & sort_param , ( my_bool ) ( ! ( param -> testflag & T_VERBOSE ) ) , param -> sort_buffer_length ) ) {param -> retry_repair = 1 ;goto err ;}sort_param . calc_checksum = 0 ;free_root ( & sort_param . wordroot , MYF ( 0 ) ) ;sort_info . max_records = ( ha_rows ) info -> state -> records ;if ( param -> testflag & T_STATISTICS ) update_key_parts ( sort_param . keyinfo , rec_per_key_part , sort_param . unique , param -> stats_method == MI_STATS_METHOD_IGNORE_NULLS ? sort_param . notnull : NULL , ( ulonglong ) info -> state -> records ) ;mi_set_key_active ( share -> state . key_map , sort_param . key ) ;DBUG_PRINT ( ""repair"" , ( ""set<S2SV_blank>enabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ;if ( sort_param . fix_datafile ) {param -> read_cache . end_of_file = sort_param . filepos ;if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ;if ( param -> testflag & T_SAFE_REPAIR ) {if ( info -> state -> records + 1 < start_records ) {info -> state -> records = start_records ;goto err ;}}share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ;share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;info -> dfile = new_file ;share -> data_file_type = sort_info . new_data_file_type ;share -> pack . header_length = ( ulong ) new_header_length ;sort_param . fix_datafile = 0 ;}else info -> state -> data_file_length = sort_param . max_pos ;param -> read_cache . file = info -> dfile ;reinit_io_cache ( & param -> read_cache , READ_CACHE , share -> pack . header_length , 1 , 1 ) ;}if ( param -> testflag & T_WRITE_LOOP ) {( void ) fputs ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\\\r"" , stdout ) ;( void ) fflush ( stdout ) ;}if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {mi_check_print_error ( param , ""Couldn\\\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ;mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ;got_error = 1 ;param -> retry_repair = 1 ;param -> testflag |= T_RETRY_WITHOUT_QUICK ;goto err ;}if ( rep_quick & T_FORCE_UNIQUENESS ) {my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ;# ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ;# endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;}if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;if ( ! ( param -> testflag & T_SILENT ) ) {if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\\if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ;}got_error = 0 ;if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;( void ) end_io_cache ( & info -> rec_cache ) ;if ( ! got_error ) {if ( new_file >= 0 ) {mysql_file_close ( new_file , MYF ( 0 ) ) ;info -> dfile = new_file = - 1 ;if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;cwe id:CWE-362context: int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info ,  const char * name , int rep_quick )  { int got_error ; uint i ; ulong length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM sort_param ; MYISAM_SHARE * share = info -> s ; HA_KEYSEG * keyseg ; ulong * rec_per_key_part ; char llbuff [ 22 ] ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; DBUG_ENTER ( ""mi_repair_by_sort"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-<S2SV_blank>recovering<S2SV_blank>(with<S2SV_blank>sort)<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) ) ) goto err ; sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ; info -> opt_flag |= WRITE_CACHE_USED ; info -> rec_cache . file = info -> dfile ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param . record ) || ! mi_alloc_rec_buff ( info , - 1 , & sort_param . rec_buff ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>extra<S2SV_blank>record"" ) ; goto err ; } if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ; if ( param -> testflag & T_UNPACK ) { share -> options &= ~ HA_OPTION_COMPRESS_RECORD ; mi_int2store ( share -> state . header . options , share -> options ) ; } share -> state . dellink = HA_OFFSET_ERROR ; info -> rec_cache . file = new_file ; } info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; mi_drop_all_indexes ( param , info , FALSE ) ; key_map = share -> state . key_map ; if ( param -> testflag & T_CREATE_MISSING_KEYS ) { key_map = ~ key_map ; } sort_info . info = info ; sort_info . param = param ; set_data_file_type ( & sort_info , share ) ; sort_param . filepos = new_header_length ; sort_info . dupp = 0 ; sort_info . buff = 0 ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ; sort_param . wordlist = NULL ; init_alloc_root ( & sort_param . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ; if ( share -> data_file_type == DYNAMIC_RECORD ) length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ; else if ( share -> data_file_type == COMPRESSED_RECORD ) length = share -> base . min_block_length ; else length = share -> base . pack_reclength ; sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records : ( ha_rows ) ( sort_info . filelength / length + 1 ) ) ; sort_param . key_cmp = sort_key_cmp ; sort_param . lock_in_memory = lock_memory ; sort_param . tmpdir = param -> tmpdir ; sort_param . sort_info = & sort_info ; sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param . master = 1 ; del = info -> state -> del ; param -> glob_crc = 0 ; if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ; rec_per_key_part = param -> rec_per_key_part ; for ( sort_param . key = 0 ; sort_param . key < share -> base . keys ; rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) { sort_param . read_cache = param -> read_cache ; sort_param . keyinfo = share -> keyinfo + sort_param . key ; sort_param . seg = sort_param . keyinfo -> seg ; if ( ! mi_is_key_active ( key_map , sort_param . key ) ) { memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ; DBUG_PRINT ( ""repair"" , ( ""skipping<S2SV_blank>seemingly<S2SV_blank>disabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ; continue ; } if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\n"" , sort_param . key + 1 ) ; sort_param . max_pos = sort_param . pos = share -> pack . header_length ; keyseg = sort_param . seg ; bzero ( ( char * ) sort_param . unique , sizeof ( sort_param . unique ) ) ; sort_param . key_length = share -> rec_reflength ; for ( i = 0 ; keyseg [ i ] . type != HA_KEYTYPE_END ; i ++ ) { sort_param . key_length += keyseg [ i ] . length ; if ( keyseg [ i ] . flag & HA_SPACE_PACK ) sort_param . key_length += get_pack_length ( keyseg [ i ] . length ) ; if ( keyseg [ i ] . flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param . key_length += 2 + test ( keyseg [ i ] . length >= 127 ) ; if ( keyseg [ i ] . flag & HA_NULL_PART ) sort_param . key_length ++ ; } info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; if ( sort_param . keyinfo -> flag & HA_FULLTEXT ) { uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param . keyinfo -> seg -> charset -> mbmaxlen ; sort_param . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ; if ( sort_param . keyinfo -> parser == & ft_default_parser ) { sort_info . max_records = ( ha_rows ) ( sort_info . filelength / ft_min_word_len + 1 ) ; } else { sort_info . max_records = 10 * max ( param -> sort_buffer_length , MIN_SORT_BUFFER ) / sort_param . key_length ; } sort_param . key_read = sort_ft_key_read ; sort_param . key_write = sort_ft_key_write ; } else { sort_param . key_read = sort_key_read ; sort_param . key_write = sort_key_write ; } if ( _create_index_by_sort ( & sort_param , ( my_bool ) ( ! ( param -> testflag & T_VERBOSE ) ) , param -> sort_buffer_length ) ) { param -> retry_repair = 1 ; goto err ; } sort_param . calc_checksum = 0 ; free_root ( & sort_param . wordroot , MYF ( 0 ) ) ; sort_info . max_records = ( ha_rows ) info -> state -> records ; if ( param -> testflag & T_STATISTICS ) update_key_parts ( sort_param . keyinfo , rec_per_key_part , sort_param . unique , param -> stats_method == MI_STATS_METHOD_IGNORE_NULLS ? sort_param . notnull : NULL , ( ulonglong ) info -> state -> records ) ; mi_set_key_active ( share -> state . key_map , sort_param . key ) ; DBUG_PRINT ( ""repair"" , ( ""set<S2SV_blank>enabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ; if ( sort_param . fix_datafile ) { param -> read_cache . end_of_file = sort_param . filepos ; if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ; if ( param -> testflag & T_SAFE_REPAIR ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; goto err ; } } share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; mysql_file_close ( info -> dfile , MYF ( 0 ) ) ; info -> dfile = new_file ; share -> data_file_type = sort_info . new_data_file_type ; share -> pack . header_length = ( ulong ) new_header_length ; sort_param . fix_datafile = 0 ; } else info -> state -> data_file_length = sort_param . max_pos ; param -> read_cache . file = info -> dfile ; reinit_io_cache ( & param -> read_cache , READ_CACHE , share -> pack . header_length , 1 , 1 ) ; } if ( param -> testflag & T_WRITE_LOOP ) { ( void ) fputs ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\r"" , stdout ) ; ( void ) fflush ( stdout ) ; } if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ; mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ; got_error = 1 ; param -> retry_repair = 1 ; param -> testflag |= T_RETRY_WITHOUT_QUICK ; goto err ; } if ( rep_quick & T_FORCE_UNIQUENESS ) { my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ; # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ; # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; } if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ; if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; if ( ! ( param -> testflag & T_SILENT ) ) { if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; if ( ! got_error ) { if ( new_file >= 0 ) {  mysql_file_close ( new_file , MYF ( 0 ) ) ;  info -> dfile = new_file = - 1 ; if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>fixing<S2SV_blank>table"" , my_errno ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ; } mi_mark_crashed_on_repair ( info ) ; } else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ; share -> state . changed |= STATE_NOT_SORTED_PAGES ; my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ; my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ; my_free ( sort_info . key_block ) ; my_free ( sort_info . ft_buf ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ; if ( ! got_error && ( param -> testflag & T_UNPACK ) ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ; share -> pack . header_length = 0 ; } DBUG_RETURN ( got_error ) ; }","if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , flags ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;",1362
228,"buggy line: # if uECC_VLI_NATIVE_LITTLE_ENDIAN  uECC_word_t * p = ( uECC_word_t * ) signature ;cwe id:CWE-000context: static int uECC_sign_with_k ( const uint8_t * private_key , const uint8_t * message_hash , unsigned hash_size , uECC_word_t * k , uint8_t * signature , uECC_Curve curve ) { uECC_word_t tmp [ uECC_MAX_WORDS ] ; uECC_word_t s [ uECC_MAX_WORDS ] ; uECC_word_t * k2 [ 2 ] = { tmp , s } ;  # if uECC_VLI_NATIVE_LITTLE_ENDIAN  uECC_word_t * p = ( uECC_word_t * ) signature ; # else uECC_word_t p [ uECC_MAX_WORDS * 2 ] ; # endif uECC_word_t carry ; wordcount_t num_words = curve -> num_words ; wordcount_t num_n_words = BITS_TO_WORDS ( curve -> num_n_bits ) ; bitcount_t num_n_bits = curve -> num_n_bits ; if ( uECC_vli_isZero ( k , num_words ) || uECC_vli_cmp ( curve -> n , k , num_n_words ) != 1 ) { return 0 ; } carry = regularize_k ( k , tmp , s , curve ) ;  EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ;  if ( uECC_vli_isZero ( p , num_words ) ) { return 0 ; } if ( ! g_rng_function ) { uECC_vli_clear ( tmp , num_n_words ) ; tmp [ 0 ] = 1 ; } else if ( ! uECC_generate_random_int ( tmp , curve -> n , num_n_words ) ) { return 0 ; } uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; uECC_vli_modInv ( k , k , curve -> n , num_n_words ) ; uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; # if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0 uECC_vli_nativeToBytes ( signature , curve -> num_bytes , p ) ; # endif # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # else uECC_vli_bytesToNative ( tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # endif s [ num_n_words - 1 ] = 0 ; uECC_vli_set ( s , p , num_words ) ; uECC_vli_modMult ( s , tmp , s , curve -> n , num_n_words ) ; bits2int ( tmp , message_hash , hash_size , curve ) ; uECC_vli_modAdd ( s , tmp , s , curve -> n , num_n_words ) ; uECC_vli_modMult ( s , s , k , curve -> n , num_n_words ) ; if ( uECC_vli_numBits ( s , num_n_words ) > ( bitcount_t ) curve -> num_bytes * 8 ) { return 0 ; } # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) signature + curve -> num_bytes , ( uint8_t * ) s , curve -> num_bytes ) ; # else uECC_vli_nativeToBytes ( signature + curve -> num_bytes , curve -> num_bytes , s ) ; # endif return 1 ; }",uECC_word_t * initial_Z = 0 ;# if uECC_VLI_NATIVE_LITTLE_ENDIAN uECC_word_t * p = ( uECC_word_t * ) signature ;,1363
229,"buggy line: EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ;if ( uECC_vli_isZero ( p , num_words ) ) {cwe id:CWE-000context: static int uECC_sign_with_k ( const uint8_t * private_key , const uint8_t * message_hash , unsigned hash_size , uECC_word_t * k , uint8_t * signature , uECC_Curve curve ) { uECC_word_t tmp [ uECC_MAX_WORDS ] ; uECC_word_t s [ uECC_MAX_WORDS ] ; uECC_word_t * k2 [ 2 ] = { tmp , s } ;  # if uECC_VLI_NATIVE_LITTLE_ENDIAN  uECC_word_t * p = ( uECC_word_t * ) signature ; # else uECC_word_t p [ uECC_MAX_WORDS * 2 ] ; # endif uECC_word_t carry ; wordcount_t num_words = curve -> num_words ; wordcount_t num_n_words = BITS_TO_WORDS ( curve -> num_n_bits ) ; bitcount_t num_n_bits = curve -> num_n_bits ; if ( uECC_vli_isZero ( k , num_words ) || uECC_vli_cmp ( curve -> n , k , num_n_words ) != 1 ) { return 0 ; } carry = regularize_k ( k , tmp , s , curve ) ;  EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ;  if ( uECC_vli_isZero ( p , num_words ) ) { return 0 ; } if ( ! g_rng_function ) { uECC_vli_clear ( tmp , num_n_words ) ; tmp [ 0 ] = 1 ; } else if ( ! uECC_generate_random_int ( tmp , curve -> n , num_n_words ) ) { return 0 ; } uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; uECC_vli_modInv ( k , k , curve -> n , num_n_words ) ; uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; # if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0 uECC_vli_nativeToBytes ( signature , curve -> num_bytes , p ) ; # endif # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # else uECC_vli_bytesToNative ( tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # endif s [ num_n_words - 1 ] = 0 ; uECC_vli_set ( s , p , num_words ) ; uECC_vli_modMult ( s , tmp , s , curve -> n , num_n_words ) ; bits2int ( tmp , message_hash , hash_size , curve ) ; uECC_vli_modAdd ( s , tmp , s , curve -> n , num_n_words ) ; uECC_vli_modMult ( s , s , k , curve -> n , num_n_words ) ; if ( uECC_vli_numBits ( s , num_n_words ) > ( bitcount_t ) curve -> num_bytes * 8 ) { return 0 ; } # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) signature + curve -> num_bytes , ( uint8_t * ) s , curve -> num_bytes ) ; # else uECC_vli_nativeToBytes ( signature + curve -> num_bytes , curve -> num_bytes , s ) ; # endif return 1 ; }","if ( g_rng_function ) {if ( ! uECC_generate_random_int ( k2 [ carry ] , initial_Z , num_n_bits + 1 , curve ) ;if ( uECC_vli_isZero ( p , num_words ) ) {",1363
230,"buggy line: dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ;bp += DAGID_LEN ;length -= DAGID_LEN ;}ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]"" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ;trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ;return ;cwe id:CWE-125context: static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = ""<elided>"" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]"" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ;  return ; tooshort : ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-length<S2SV_blank>too<S2SV_blank>short]"" ) ) ; return ; }","dagid_str = ip6addr_string ( ndo , ""%s"" , rpl_tstr ) ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ;return ;",1364
231,"buggy line: int family = sk -> sk_family ;struct sockaddr_in * sin ;struct sockaddr_in6 * sin6 ;if ( addr_len ) {if ( family == AF_INET ) * addr_len = sizeof ( * sin ) ;else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ;}return ip_recv_error ( sk , msg , len ) ;cwe id:CWE-200context: int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ;  int family = sk -> sk_family ;  struct sockaddr_in * sin ; struct sockaddr_in6 * sin6 ; struct sk_buff * skb ; int copied , err ; pr_debug ( ""ping_recvmsg(sk=%p,sk->num=%u)\\n"" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ;  if ( addr_len ) {  if ( family == AF_INET ) * addr_len = sizeof ( * sin ) ; else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ; } if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) {  sin = ( struct sockaddr_in * ) msg -> msg_name ;  sin -> sin_family = AF_INET ; sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;  if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ;  sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;  sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr ,  IP6CB ( skb ) -> iif ) ;  if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ; # endif } else { BUG ( ) ; } err = copied ; done : skb_free_datagram ( sk , skb ) ; out : pr_debug ( ""ping_recvmsg<S2SV_blank>-><S2SV_blank>%d\\n"" , err ) ; return err ; }","int family = sk -> sk_family ;struct sockaddr_in * return ip_recv_error ( sk , msg , len ) ;",1365
232,"buggy line: if ( family == AF_INET ) {sin = ( struct sockaddr_in * ) msg -> msg_name ;sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ;memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ;# if IS_ENABLED ( CONFIG_IPV6 ) }else if ( family == AF_INET6 ) {struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ;sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr ,  IP6CB ( skb ) -> iif ) ;if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;cwe id:CWE-200context: int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ;  int family = sk -> sk_family ;  struct sockaddr_in * sin ; struct sockaddr_in6 * sin6 ; struct sk_buff * skb ; int copied , err ; pr_debug ( ""ping_recvmsg(sk=%p,sk->num=%u)\\n"" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ;  if ( addr_len ) {  if ( family == AF_INET ) * addr_len = sizeof ( * sin ) ; else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ; } if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) {  sin = ( struct sockaddr_in * ) msg -> msg_name ;  sin -> sin_family = AF_INET ; sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;  if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ;  sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;  sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr ,  IP6CB ( skb ) -> iif ) ;  if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ; # endif } else { BUG ( ) ; } err = copied ; done : skb_free_datagram ( sk , skb ) ; out : pr_debug ( ""ping_recvmsg<S2SV_blank>-><S2SV_blank>%d\\n"" , err ) ; return err ; }","struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ;* addr_len = sizeof ( * sin6 ) ;if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;",1365
233,"buggy line: flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |  EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ;if ( mode & FALLOC_FL_KEEP_SIZE )  flags |= EXT4_GET_BLOCKS_KEEP_SIZE ;mutex_lock ( & inode -> i_mutex ) ;if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) {cwe id:CWE-17context: static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; struct address_space * mapping = inode -> i_mapping ; unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ;  flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |  EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ;  if ( mode & FALLOC_FL_KEEP_SIZE )  flags |= EXT4_GET_BLOCKS_KEEP_SIZE ;  mutex_lock ( & inode -> i_mutex ) ;  if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; if ( partial_end ) max_blocks += 1 ; }  if ( max_blocks > 0 ) {  truncate_pagecache_range ( inode , start , end - 1 ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , flags , mode ) ; if ( ret ) goto out_dio ; ret = ext4_es_remove_extent ( inode , 0 , EXT_MAX_BLOCKS ) ; if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }","mutex_lock ( & inode -> i_mutex ) ;if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) {",1366
234,"buggy line: if ( max_blocks > 0 ) {truncate_pagecache_range ( inode , start , end - 1 ) ;cwe id:CWE-17context: static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; struct address_space * mapping = inode -> i_mapping ; unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ;  flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |  EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ;  if ( mode & FALLOC_FL_KEEP_SIZE )  flags |= EXT4_GET_BLOCKS_KEEP_SIZE ;  mutex_lock ( & inode -> i_mutex ) ;  if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; if ( partial_end ) max_blocks += 1 ; }  if ( max_blocks > 0 ) {  truncate_pagecache_range ( inode , start , end - 1 ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , flags , mode ) ; if ( ret ) goto out_dio ; ret = ext4_es_remove_extent ( inode , 0 , EXT_MAX_BLOCKS ) ; if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }","}flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ;if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_SIZE ;if ( partial_begin || partial_end ) {ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ;if ( ret ) goto out_mutex ;}if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) {new_size = offset + len ;ret = inode_newsize_ok ( inode , new_size ) ;if ( ret ) goto out_mutex ;if ( max_blocks > 0 ) {flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;truncate_pagecache_range ( inode , start , end - 1 ) ;",1366
235,"buggy line: }else {uint32_t new_free_total = pool -> free_total * 2 ;cwe id:CWE-190context: void nw_buf_free ( nw_buf_pool * pool , nw_buf * buf ) { if ( pool -> free < pool -> free_total ) { pool -> free_arr [ pool -> free ++ ] = buf ;  } else {  uint32_t new_free_total = pool -> free_total * 2 ; void * new_arr = realloc ( pool -> free_arr , new_free_total * sizeof ( nw_buf * ) ) ; if ( new_arr ) { pool -> free_total = new_free_total ; pool -> free_arr = new_arr ; pool -> free_arr [ pool -> free ++ ] = buf ; } else { free ( buf ) ; }  }  }",}else if ( pool -> free_total < NW_BUF_POOL_MAX_SIZE ) {uint32_t new_free_total = pool -> free_total * 2 ;,1367
236,"buggy line: }}cwe id:CWE-190context: void nw_buf_free ( nw_buf_pool * pool , nw_buf * buf ) { if ( pool -> free < pool -> free_total ) { pool -> free_arr [ pool -> free ++ ] = buf ;  } else {  uint32_t new_free_total = pool -> free_total * 2 ; void * new_arr = realloc ( pool -> free_arr , new_free_total * sizeof ( nw_buf * ) ) ; if ( new_arr ) { pool -> free_total = new_free_total ; pool -> free_arr = new_arr ; pool -> free_arr [ pool -> free ++ ] = buf ; } else { free ( buf ) ; }  }  }",}else {free ( buf ) ;}},1367
237,"buggy line: bpf_map_inc ( map , true ) ;fdput ( f ) ;cwe id:CWE-000context: struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ;  bpf_map_inc ( map , true ) ;  fdput ( f ) ; return map ; }","map = bpf_map_inc ( map , true ) ;fdput ( f ) ;",1368
238,"buggy line: while ( * cp ) {int cval = 0 , meta = 0 ;if ( * cp == \'\\\\\\\\\' && cp [ 1 ] && index ( ""mM"" , cp [ 1 ] ) && cp [ 2 ] ) {meta = 1 ;cp += 2 ;}if ( * cp == \'\\\\\\\\\' && cp [ 1 ] && index ( ""0123456789xXoO"" , cp [ 1 ] ) && cp [ 2 ] ) {NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ;const char * dp ;int dcount = 0 ;cp ++ ;if ( * cp == \'x\' || * cp == \'X\' )   for ( ++ cp ;cp ++ )  cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ;else if ( * cp == \'o\' || * cp == \'O\' )  for ( ++ cp ;* cp && ( index ( ""01234567"" , * cp ) ) && ( dcount ++ < 3 ) ;cp ++ ) cval = ( cval * 8 ) + ( * cp - \'0\' ) ;else for ( ;* cp && ( index ( ""0123456789"" , * cp ) ) && ( dcount ++ < 3 ) ;cp ++ ) cval = ( cval * 10 ) + ( * cp - \'0\' ) ;else if ( * cp == \'\\\\\\\\\' && cp [ 1 ] ) {cwe id:CWE-269context: STATIC_OVL void escapes ( cp , tp ) const char * cp ; char * tp ; {  while ( * cp ) {  int cval = 0 , meta = 0 ; if ( * cp == '\\\\' && cp [ 1 ] && index ( ""mM"" , cp [ 1 ] ) && cp [ 2 ] ) { meta = 1 ; cp += 2 ; } if ( * cp == '\\\\' && cp [ 1 ] && index ( ""0123456789xXoO"" , cp [ 1 ] ) && cp [ 2 ] ) {  NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ;  const char * dp ;  int dcount = 0 ;   cp ++ ;   if ( * cp == 'x' || * cp == 'X' )   for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ )  cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ;  else if ( * cp == 'o' || * cp == 'O' )  for ( ++ cp ; * cp && ( index ( ""01234567"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 8 ) + ( * cp - '0' ) ; else for ( ; * cp && ( index ( ""0123456789"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 10 ) + ( * cp - '0' ) ; } else if ( * cp == '\\\\' && cp [ 1 ] ) { switch ( * ++ cp ) { case '\\\\' : cval = '\\\\' ; break ; case 'n' : cval = '\\n' ; break ; case 't' : cval = '\\t' ; break ; case 'b' : cval = '\\b' ; break ; case 'r' : cval = '\\r' ; break ; default : cval = * cp ; }  cp ++ ;  } else if ( * cp == '^' && cp [ 1 ] ) { cval = ( * ++ cp & 0x1f ) ; cp ++ ; } else cval = * cp ++ ; if ( meta ) cval |= 0x80 ;  * tp ++ = cval ;  } * tp = '\\0' ; }","static NEARDATA const char oct [ ] = ""01234567"" , dec [ ] = ""0123456789"" , hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ;const char * dp ;int dcount = 0 ;cp ++ ;if ( * cp == \'x\' || * cp == \'X\' ) for ( ++ cp ;cp ++ ) cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ;}while ( * ++ cp && ( dp = index ( hex , * cp ) ) != 0 && ++ dcount < 2 ) ;else {",1369
239,"buggy line: cp ++ ;}* tp ++ = cval ;}cwe id:CWE-269context: STATIC_OVL void escapes ( cp , tp ) const char * cp ; char * tp ; {  while ( * cp ) {  int cval = 0 , meta = 0 ; if ( * cp == '\\\\' && cp [ 1 ] && index ( ""mM"" , cp [ 1 ] ) && cp [ 2 ] ) { meta = 1 ; cp += 2 ; } if ( * cp == '\\\\' && cp [ 1 ] && index ( ""0123456789xXoO"" , cp [ 1 ] ) && cp [ 2 ] ) {  NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ;  const char * dp ;  int dcount = 0 ;   cp ++ ;   if ( * cp == 'x' || * cp == 'X' )   for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ )  cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ;  else if ( * cp == 'o' || * cp == 'O' )  for ( ++ cp ; * cp && ( index ( ""01234567"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 8 ) + ( * cp - '0' ) ; else for ( ; * cp && ( index ( ""0123456789"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 10 ) + ( * cp - '0' ) ; } else if ( * cp == '\\\\' && cp [ 1 ] ) { switch ( * ++ cp ) { case '\\\\' : cval = '\\\\' ; break ; case 'n' : cval = '\\n' ; break ; case 't' : cval = '\\t' ; break ; case 'b' : cval = '\\b' ; break ; case 'r' : cval = '\\r' ; break ; default : cval = * cp ; }  cp ++ ;  } else if ( * cp == '^' && cp [ 1 ] ) { cval = ( * ++ cp & 0x1f ) ; cp ++ ; } else cval = * cp ++ ; if ( meta ) cval |= 0x80 ;  * tp ++ = cval ;  } * tp = '\\0' ; }",cp ++ ;}* tp ++ = ( char ) cval ;},1369
240,"buggy line: int file_is_y4m ( const char detect [ 4 ] ) {if ( memcmp ( detect , ""YUV4"" , 4 ) == 0 ) {cwe id:CWE-119context:  int file_is_y4m ( const char detect [ 4 ] ) {  if ( memcmp ( detect , ""YUV4"" , 4 ) == 0 ) { return 1 ; } return 0 ; }","static int file_is_y4m ( const char detect [ 4 ] ) {if ( memcmp ( detect , ""YUV4"" , 4 ) == 0 ) {",1370
241,"buggy line: if ( size_left && size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;cwe id:CWE-190context: static void Process_ipfix_template_add ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { input_translation_t * translation_table ; ipfix_template_record_t * ipfix_template_record ; ipfix_template_elements_std_t * NextElement ; int i ; while ( size_left ) { uint32_t table_id , count , size_required ; uint32_t num_extensions = 0 ;  if ( size_left && size_left < 4 ) {  LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; table_id = ntohs ( ipfix_template_record -> TemplateID ) ; count = ntohs ( ipfix_template_record -> FieldCount ) ; dbg_printf ( ""\\n[%u]<S2SV_blank>Template<S2SV_blank>ID:<S2SV_blank>%u\\n"" , exporter -> info . id , table_id ) ; dbg_printf ( ""FieldCount:<S2SV_blank>%u<S2SV_blank>buffersize:<S2SV_blank>%u\\n"" , count , size_left ) ; memset ( ( void * ) cache . common_extensions , 0 , ( Max_num_extensions + 1 ) * sizeof ( uint32_t ) ) ; memset ( ( void * ) cache . lookup_info , 0 , 65536 * sizeof ( struct element_param_s ) ) ; for ( i = 1 ; ipfix_element_map [ i ] . id != 0 ; i ++ ) { uint32_t Type = ipfix_element_map [ i ] . id ; if ( ipfix_element_map [ i ] . id == ipfix_element_map [ i - 1 ] . id ) continue ; cache . lookup_info [ Type ] . index = i ; } cache . input_order = calloc ( count , sizeof ( struct order_s ) ) ; if ( ! cache . input_order ) { LogError ( ""Process_ipfix:<S2SV_blank>Panic!<S2SV_blank>malloc():<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d:<S2SV_blank>%s"" , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } cache . input_count = count ; size_required = 4 * count ; if ( size_left < size_required ) { LogError ( ""Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u"" , exporter -> info . id , size_required , size_left ) ; dbg_printf ( ""ERROR:<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u"" , size_required , size_left ) ; return ; } NextElement = ( ipfix_template_elements_std_t * ) ipfix_template_record -> elements ; for ( i = 0 ; i < count ; i ++ ) { uint16_t Type , Length ; uint32_t ext_id ; int Enterprise ; Type = ntohs ( NextElement -> Type ) ; Length = ntohs ( NextElement -> Length ) ; Enterprise = Type & 0x8000 ? 1 : 0 ; Type = Type & 0x7FFF ; ext_id = MapElement ( Type , Length , i ) ; if ( ext_id && extension_descriptor [ ext_id ] . enabled ) { if ( cache . common_extensions [ ext_id ] == 0 ) { cache . common_extensions [ ext_id ] = 1 ; num_extensions ++ ; } } if ( Enterprise ) { ipfix_template_elements_e_t * e = ( ipfix_template_elements_e_t * ) NextElement ; size_required += 4 ; if ( size_left < size_required ) { LogError ( ""Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u"" , exporter -> info . id , size_required , size_left ) ; dbg_printf ( ""ERROR:<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u"" , size_required , size_left ) ; return ; } if ( ntohl ( e -> EnterpriseNumber ) == IPFIX_ReverseInformationElement ) { dbg_printf ( ""<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>1,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u<S2SV_blank>Reverse<S2SV_blank>Information<S2SV_blank>Element:<S2SV_blank>%u\\n"" , i , Type , Length , ntohl ( e -> EnterpriseNumber ) ) ; } else { dbg_printf ( ""<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>1,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u<S2SV_blank>EnterpriseNumber:<S2SV_blank>%u\\n"" , i , Type , Length , ntohl ( e -> EnterpriseNumber ) ) ; } e ++ ; NextElement = ( ipfix_template_elements_std_t * ) e ; } else { dbg_printf ( ""<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>0,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u\\n"" , i , Type , Length ) ; NextElement ++ ; } } dbg_printf ( ""Processed:<S2SV_blank>%u\\n"" , size_required ) ; if ( compact_input_order ( ) ) { if ( extension_descriptor [ EX_ROUTER_IP_v4 ] . enabled ) { if ( cache . common_extensions [ EX_ROUTER_IP_v4 ] == 0 ) { cache . common_extensions [ EX_ROUTER_IP_v4 ] = 1 ; num_extensions ++ ; } dbg_printf ( ""Add<S2SV_blank>sending<S2SV_blank>router<S2SV_blank>IP<S2SV_blank>address<S2SV_blank>(%s)<S2SV_blank>=><S2SV_blank>Extension:<S2SV_blank>%u\\n"" , fs -> sa_family == PF_INET6 ? ""ipv6"" : ""ipv4"" , EX_ROUTER_IP_v4 ) ; } extension_descriptor [ EX_ROUTER_ID ] . enabled = 0 ; if ( extension_descriptor [ EX_RECEIVED ] . enabled ) { if ( cache . common_extensions [ EX_RECEIVED ] == 0 ) { cache . common_extensions [ EX_RECEIVED ] = 1 ; num_extensions ++ ; } dbg_printf ( ""Force<S2SV_blank>add<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>time,<S2SV_blank>Extension:<S2SV_blank>%u\\n"" , EX_RECEIVED ) ; } # ifdef DEVEL { int i ; for ( i = 4 ; extension_descriptor [ i ] . id ; i ++ ) { if ( cache . common_extensions [ i ] ) { printf ( ""Enabled<S2SV_blank>extension:<S2SV_blank>%i\\n"" , i ) ; } } } # endif translation_table = setup_translation_table ( exporter , table_id ) ; if ( translation_table -> extension_map_changed ) { dbg_printf ( ""Translation<S2SV_blank>Table<S2SV_blank>changed!<S2SV_blank>Add<S2SV_blank>extension<S2SV_blank>map<S2SV_blank>ID:<S2SV_blank>%i\\n"" , translation_table -> extension_info . map -> map_id ) ; AddExtensionMap ( fs , translation_table -> extension_info . map ) ; translation_table -> extension_map_changed = 0 ; dbg_printf ( ""Translation<S2SV_blank>Table<S2SV_blank>added!<S2SV_blank>map<S2SV_blank>ID:<S2SV_blank>%i\\n"" , translation_table -> extension_info . map -> map_id ) ; } if ( ! reorder_sequencer ( translation_table ) ) { LogError ( ""Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>reorder<S2SV_blank>sequencer.<S2SV_blank>Remove<S2SV_blank>table<S2SV_blank>id:<S2SV_blank>%u"" , exporter -> info . id , table_id ) ; remove_translation_table ( fs , exporter , table_id ) ; } } else { dbg_printf ( ""Template<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>any<S2SV_blank>common<S2SV_blank>fields<S2SV_blank>-<S2SV_blank>skip\\n"" ) ; } size_left -= size_required ; DataPtr = DataPtr + size_required + 4 ; if ( size_left < 4 ) { dbg_printf ( ""Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n"" , size_left ) ; size_left = 0 ; } free ( cache . input_order ) ; cache . input_order = NULL ; } }","if ( size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;",1371
242,"buggy line: PIX * pixc , * pixm , * pixg , * pixd ;PIXCMAP * cmap , * cmapd ;cwe id:CWE-125context: PIX * pixFewColorsOctcubeQuantMixed ( PIX * pixs , l_int32 level , l_int32 darkthresh , l_int32 lightthresh , l_int32 diffthresh , l_float32 minfract , l_int32 maxspan ) { l_int32 i , j , w , h , wplc , wplm , wpld , ncolors , index ; l_int32 rval , gval , bval , val , minval , maxval ; l_int32 * lut ; l_uint32 * datac , * datam , * datad , * linec , * linem , * lined ;  PIX * pixc , * pixm , * pixg , * pixd ;  PIXCMAP * cmap , * cmapd ; PROCNAME ( ""pixFewColorsOctcubeQuantMixed"" ) ; if ( ! pixs || pixGetDepth ( pixs ) != 32 ) return ( PIX * ) ERROR_PTR ( ""pixs<S2SV_blank>undefined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>32<S2SV_blank>bpp"" , procName , NULL ) ; if ( level <= 0 ) level = 3 ; if ( level > 6 ) return ( PIX * ) ERROR_PTR ( ""invalid<S2SV_blank>level"" , procName , NULL ) ; if ( darkthresh <= 0 ) darkthresh = 20 ; if ( lightthresh <= 0 ) lightthresh = 244 ; if ( diffthresh <= 0 ) diffthresh = 20 ; if ( minfract <= 0.0 ) minfract = 0.05 ; if ( maxspan <= 2 ) maxspan = 15 ;  if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL )   return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ;  cmap = pixGetColormap ( pixc ) ; ncolors = pixcmapGetCount ( cmap ) ; cmapd = pixcmapCreate ( 8 ) ; lut = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; for ( i = 0 ; i < 256 ; i ++ ) lut [ i ] = - 1 ; for ( i = 0 , index = 0 ; i < ncolors ; i ++ ) { pixcmapGetColor ( cmap , i , & rval , & gval , & bval ) ; minval = L_MIN ( rval , gval ) ; minval = L_MIN ( minval , bval ) ; if ( minval > lightthresh ) continue ; maxval = L_MAX ( rval , gval ) ; maxval = L_MAX ( maxval , bval ) ; if ( maxval < darkthresh ) continue ; if ( maxval - minval >= diffthresh ) { pixcmapAddColor ( cmapd , rval , gval , bval ) ; lut [ i ] = index ; index ++ ; } } pixGetDimensions ( pixs , & w , & h , NULL ) ; pixd = pixCreate ( w , h , 8 ) ; pixSetColormap ( pixd , cmapd ) ; pixm = pixCreate ( w , h , 1 ) ; datac = pixGetData ( pixc ) ; datam = pixGetData ( pixm ) ; datad = pixGetData ( pixd ) ; wplc = pixGetWpl ( pixc ) ; wplm = pixGetWpl ( pixm ) ; wpld = pixGetWpl ( pixd ) ; for ( i = 0 ; i < h ; i ++ ) { linec = datac + i * wplc ; linem = datam + i * wplm ; lined = datad + i * wpld ; for ( j = 0 ; j < w ; j ++ ) { val = GET_DATA_BYTE ( linec , j ) ; if ( lut [ val ] == - 1 ) SET_DATA_BIT ( linem , j ) ; else SET_DATA_BYTE ( lined , j , lut [ val ] ) ; } } pixg = pixConvertTo8 ( pixs , 0 ) ; pixGrayQuantFromHisto ( pixd , pixg , pixm , minfract , maxspan ) ; LEPT_FREE ( lut ) ; pixDestroy ( & pixc ) ; pixDestroy ( & pixm ) ; pixDestroy ( & pixg ) ; return pixd ; }","PIX * pix1 , * pixc , * pixm , * pixg , * pixd ;PIXCMAP * cmap , * cmapd ;",1372
243,"buggy line: if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL )   return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ;cmap = pixGetColormap ( pixc ) ;cwe id:CWE-125context: PIX * pixFewColorsOctcubeQuantMixed ( PIX * pixs , l_int32 level , l_int32 darkthresh , l_int32 lightthresh , l_int32 diffthresh , l_float32 minfract , l_int32 maxspan ) { l_int32 i , j , w , h , wplc , wplm , wpld , ncolors , index ; l_int32 rval , gval , bval , val , minval , maxval ; l_int32 * lut ; l_uint32 * datac , * datam , * datad , * linec , * linem , * lined ;  PIX * pixc , * pixm , * pixg , * pixd ;  PIXCMAP * cmap , * cmapd ; PROCNAME ( ""pixFewColorsOctcubeQuantMixed"" ) ; if ( ! pixs || pixGetDepth ( pixs ) != 32 ) return ( PIX * ) ERROR_PTR ( ""pixs<S2SV_blank>undefined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>32<S2SV_blank>bpp"" , procName , NULL ) ; if ( level <= 0 ) level = 3 ; if ( level > 6 ) return ( PIX * ) ERROR_PTR ( ""invalid<S2SV_blank>level"" , procName , NULL ) ; if ( darkthresh <= 0 ) darkthresh = 20 ; if ( lightthresh <= 0 ) lightthresh = 244 ; if ( diffthresh <= 0 ) diffthresh = 20 ; if ( minfract <= 0.0 ) minfract = 0.05 ; if ( maxspan <= 2 ) maxspan = 15 ;  if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL )   return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ;  cmap = pixGetColormap ( pixc ) ; ncolors = pixcmapGetCount ( cmap ) ; cmapd = pixcmapCreate ( 8 ) ; lut = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; for ( i = 0 ; i < 256 ; i ++ ) lut [ i ] = - 1 ; for ( i = 0 , index = 0 ; i < ncolors ; i ++ ) { pixcmapGetColor ( cmap , i , & rval , & gval , & bval ) ; minval = L_MIN ( rval , gval ) ; minval = L_MIN ( minval , bval ) ; if ( minval > lightthresh ) continue ; maxval = L_MAX ( rval , gval ) ; maxval = L_MAX ( maxval , bval ) ; if ( maxval < darkthresh ) continue ; if ( maxval - minval >= diffthresh ) { pixcmapAddColor ( cmapd , rval , gval , bval ) ; lut [ i ] = index ; index ++ ; } } pixGetDimensions ( pixs , & w , & h , NULL ) ; pixd = pixCreate ( w , h , 8 ) ; pixSetColormap ( pixd , cmapd ) ; pixm = pixCreate ( w , h , 1 ) ; datac = pixGetData ( pixc ) ; datam = pixGetData ( pixm ) ; datad = pixGetData ( pixd ) ; wplc = pixGetWpl ( pixc ) ; wplm = pixGetWpl ( pixm ) ; wpld = pixGetWpl ( pixd ) ; for ( i = 0 ; i < h ; i ++ ) { linec = datac + i * wplc ; linem = datam + i * wplm ; lined = datad + i * wpld ; for ( j = 0 ; j < w ; j ++ ) { val = GET_DATA_BYTE ( linec , j ) ; if ( lut [ val ] == - 1 ) SET_DATA_BIT ( linem , j ) ; else SET_DATA_BYTE ( lined , j , lut [ val ] ) ; } } pixg = pixConvertTo8 ( pixs , 0 ) ; pixGrayQuantFromHisto ( pixd , pixg , pixm , minfract , maxspan ) ; LEPT_FREE ( lut ) ; pixDestroy ( & pixc ) ; pixDestroy ( & pixm ) ; pixDestroy ( & pixg ) ; return pixd ; }","if ( ( pix1 = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ;pixc = pixConvertTo8 ( pix1 , 1 ) ;pixDestroy ( & pix1 ) ;cmap = pixGetColormap ( pixc ) ;",1372
244,"buggy line: int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) ,  top = p -> top ;cwe id:CWE-399context: int BN_GF2m_mod_inv ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) { BIGNUM * b , * c = NULL , * u = NULL , * v = NULL , * tmp ; int ret = 0 ; bn_check_top ( a ) ; bn_check_top ( p ) ; BN_CTX_start ( ctx ) ; if ( ( b = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( c = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( u = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( v = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ! BN_GF2m_mod ( u , a , p ) ) goto err ; if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_copy ( v , p ) ) goto err ; # if 0 if ( ! BN_one ( b ) ) goto err ; while ( 1 ) { while ( ! BN_is_odd ( u ) ) { if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_rshift1 ( u , u ) ) goto err ; if ( BN_is_odd ( b ) ) { if ( ! BN_GF2m_add ( b , b , p ) ) goto err ; } if ( ! BN_rshift1 ( b , b ) ) goto err ; } if ( BN_abs_is_word ( u , 1 ) ) break ; if ( BN_num_bits ( u ) < BN_num_bits ( v ) ) { tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; } if ( ! BN_GF2m_add ( u , u , v ) ) goto err ; if ( ! BN_GF2m_add ( b , b , c ) ) goto err ; } # else {  int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) ,  top = p -> top ; BN_ULONG * udp , * bdp , * vdp , * cdp ; bn_wexpand ( u , top ) ; udp = u -> d ; for ( i = u -> top ; i < top ; i ++ ) udp [ i ] = 0 ; u -> top = top ; bn_wexpand ( b , top ) ; bdp = b -> d ; bdp [ 0 ] = 1 ; for ( i = 1 ; i < top ; i ++ ) bdp [ i ] = 0 ; b -> top = top ; bn_wexpand ( c , top ) ; cdp = c -> d ; for ( i = 0 ; i < top ; i ++ ) cdp [ i ] = 0 ; c -> top = top ; vdp = v -> d ; while ( 1 ) { while ( ubits && ! ( udp [ 0 ] & 1 ) ) { BN_ULONG u0 , u1 , b0 , b1 , mask ; u0 = udp [ 0 ] ; b0 = bdp [ 0 ] ; mask = ( BN_ULONG ) 0 - ( b0 & 1 ) ; b0 ^= p -> d [ 0 ] & mask ; for ( i = 0 ; i < top - 1 ; i ++ ) { u1 = udp [ i + 1 ] ; udp [ i ] = ( ( u0 >> 1 ) | ( u1 << ( BN_BITS2 - 1 ) ) ) & BN_MASK2 ; u0 = u1 ; b1 = bdp [ i + 1 ] ^ ( p -> d [ i + 1 ] & mask ) ; bdp [ i ] = ( ( b0 >> 1 ) | ( b1 << ( BN_BITS2 - 1 ) ) ) & BN_MASK2 ; b0 = b1 ; } udp [ i ] = u0 >> 1 ; bdp [ i ] = b0 >> 1 ; ubits -- ; }  if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 )   break ;  if ( ubits < vbits ) { i = ubits ; ubits = vbits ; vbits = i ; tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; udp = vdp ; vdp = v -> d ; bdp = cdp ; cdp = c -> d ; } for ( i = 0 ; i < top ; i ++ ) { udp [ i ] ^= vdp [ i ] ; bdp [ i ] ^= cdp [ i ] ; } if ( ubits == vbits ) { BN_ULONG ul ; int utop = ( ubits - 1 ) / BN_BITS2 ; while ( ( ul = udp [ utop ] ) == 0 && utop ) utop -- ; ubits = utop * BN_BITS2 + BN_num_bits_word ( ul ) ; } } bn_correct_top ( b ) ; } # endif if ( ! BN_copy ( r , b ) ) goto err ; bn_check_top ( r ) ; ret = 1 ; err : # ifdef BN_DEBUG bn_correct_top ( c ) ; bn_correct_top ( u ) ; bn_correct_top ( v ) ; # endif BN_CTX_end ( ctx ) ; return ret ; }",int i ;int ubits = BN_num_bits ( u ) ;int vbits = BN_num_bits ( v ) ;int top = p -> top ;,1373
245,"buggy line: if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 )   break ;if ( ubits < vbits ) {cwe id:CWE-399context: int BN_GF2m_mod_inv ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) { BIGNUM * b , * c = NULL , * u = NULL , * v = NULL , * tmp ; int ret = 0 ; bn_check_top ( a ) ; bn_check_top ( p ) ; BN_CTX_start ( ctx ) ; if ( ( b = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( c = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( u = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( v = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ! BN_GF2m_mod ( u , a , p ) ) goto err ; if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_copy ( v , p ) ) goto err ; # if 0 if ( ! BN_one ( b ) ) goto err ; while ( 1 ) { while ( ! BN_is_odd ( u ) ) { if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_rshift1 ( u , u ) ) goto err ; if ( BN_is_odd ( b ) ) { if ( ! BN_GF2m_add ( b , b , p ) ) goto err ; } if ( ! BN_rshift1 ( b , b ) ) goto err ; } if ( BN_abs_is_word ( u , 1 ) ) break ; if ( BN_num_bits ( u ) < BN_num_bits ( v ) ) { tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; } if ( ! BN_GF2m_add ( u , u , v ) ) goto err ; if ( ! BN_GF2m_add ( b , b , c ) ) goto err ; } # else {  int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) ,  top = p -> top ; BN_ULONG * udp , * bdp , * vdp , * cdp ; bn_wexpand ( u , top ) ; udp = u -> d ; for ( i = u -> top ; i < top ; i ++ ) udp [ i ] = 0 ; u -> top = top ; bn_wexpand ( b , top ) ; bdp = b -> d ; bdp [ 0 ] = 1 ; for ( i = 1 ; i < top ; i ++ ) bdp [ i ] = 0 ; b -> top = top ; bn_wexpand ( c , top ) ; cdp = c -> d ; for ( i = 0 ; i < top ; i ++ ) cdp [ i ] = 0 ; c -> top = top ; vdp = v -> d ; while ( 1 ) { while ( ubits && ! ( udp [ 0 ] & 1 ) ) { BN_ULONG u0 , u1 , b0 , b1 , mask ; u0 = udp [ 0 ] ; b0 = bdp [ 0 ] ; mask = ( BN_ULONG ) 0 - ( b0 & 1 ) ; b0 ^= p -> d [ 0 ] & mask ; for ( i = 0 ; i < top - 1 ; i ++ ) { u1 = udp [ i + 1 ] ; udp [ i ] = ( ( u0 >> 1 ) | ( u1 << ( BN_BITS2 - 1 ) ) ) & BN_MASK2 ; u0 = u1 ; b1 = bdp [ i + 1 ] ^ ( p -> d [ i + 1 ] & mask ) ; bdp [ i ] = ( ( b0 >> 1 ) | ( b1 << ( BN_BITS2 - 1 ) ) ) & BN_MASK2 ; b0 = b1 ; } udp [ i ] = u0 >> 1 ; bdp [ i ] = b0 >> 1 ; ubits -- ; }  if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 )   break ;  if ( ubits < vbits ) { i = ubits ; ubits = vbits ; vbits = i ; tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; udp = vdp ; vdp = v -> d ; bdp = cdp ; cdp = c -> d ; } for ( i = 0 ; i < top ; i ++ ) { udp [ i ] ^= vdp [ i ] ; bdp [ i ] ^= cdp [ i ] ; } if ( ubits == vbits ) { BN_ULONG ul ; int utop = ( ubits - 1 ) / BN_BITS2 ; while ( ( ul = udp [ utop ] ) == 0 && utop ) utop -- ; ubits = utop * BN_BITS2 + BN_num_bits_word ( ul ) ; } } bn_correct_top ( b ) ; } # endif if ( ! BN_copy ( r , b ) ) goto err ; bn_check_top ( r ) ; ret = 1 ; err : # ifdef BN_DEBUG bn_correct_top ( c ) ; bn_correct_top ( u ) ; bn_correct_top ( v ) ; # endif BN_CTX_end ( ctx ) ; return ret ; }",if ( ubits <= BN_BITS2 ) {if ( udp [ 0 ] == 0 ) goto err ;if ( udp [ 0 ] == 1 ) break ;}if ( ubits < vbits ) {,1373
246,"buggy line: v_fn_ptr . vf = vp8_mse16x16 ;xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ;cwe id:CWE-119context: static void first_pass_motion_search ( VP8_COMP * cpi , MACROBLOCK * x , int_mv * ref_mv , MV * best_mv , YV12_BUFFER_CONFIG * recon_buffer , int * best_motion_err , int recon_yoffset ) { MACROBLOCKD * const xd = & x -> e_mbd ; BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; int num00 ; int_mv tmp_mv ; int_mv ref_mv_full ; int tmp_err ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; int n ; vp8_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ; int new_mv_mode_penalty = 256 ;  v_fn_ptr . vf = vp8_mse16x16 ;  xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ; tmp_mv . as_int = 0 ; ref_mv_full . as_mv . col = ref_mv -> as_mv . col >> 3 ; ref_mv_full . as_mv . row = ref_mv -> as_mv . row >> 3 ; tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } } } }",v_fn_ptr . vf = vpx_mse16x16 ;xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ;,1374
247,"buggy line: strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ;cwe id:CWE-000context: static int crypto_report_kpp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_kpp rkpp ;  strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ;  if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }","strncpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ;",1375
248,"buggy line: int strindex = 0 ;size_t length ;cwe id:CWE-89context: char * curl_easy_escape ( CURL * handle , const char * string , int inlength ) { size_t alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ; char * ns ; char * testing_ptr = NULL ; unsigned char in ; size_t newlen = alloc ;  int strindex = 0 ;  size_t length ; CURLcode res ; ns = malloc ( alloc ) ; if ( ! ns ) return NULL ; length = alloc - 1 ; while ( length -- ) { in = * string ; if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ; else { newlen += 2 ; if ( newlen > alloc ) { alloc *= 2 ; testing_ptr = realloc ( ns , alloc ) ; if ( ! testing_ptr ) { free ( ns ) ; return NULL ; } else { ns = testing_ptr ; } } res = Curl_convert_to_network ( handle , & in , 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } snprintf ( & ns [ strindex ] , 4 , ""%%%02X"" , in ) ; strindex += 3 ; } string ++ ; } ns [ strindex ] = 0 ; return ns ; }",size_t strindex = 0 ;size_t length ;,1376
249,"buggy line: value = 0 ;if ( bits < 0 ) {if ( msg -> oob ) {if ( bits == 8 ) {cwe id:CWE-119context: int MSG_ReadBits ( msg_t * msg , int bits ) { int value ; int get ; qboolean sgn ; int i , nbits ;  value = 0 ;  if ( bits < 0 ) { bits = - bits ; sgn = qtrue ; } else { sgn = qfalse ; }  if ( msg -> oob ) {  if ( bits == 8 ) { value = msg -> data [ msg -> readcount ] ; msg -> readcount += 1 ; msg -> bit += 8 ; } else if ( bits == 16 ) { short temp ; CopyLittleShort ( & temp , & msg -> data [ msg -> readcount ] ) ; value = temp ; msg -> readcount += 2 ; msg -> bit += 16 ; } else if ( bits == 32 ) { CopyLittleLong ( & value , & msg -> data [ msg -> readcount ] ) ; msg -> readcount += 4 ; msg -> bit += 32 ; } else Com_Error ( ERR_DROP , ""can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bits"" , bits ) ; } else { nbits = 0 ; if ( bits & 7 ) {  nbits = bits & 7 ;  for ( i = 0 ; i < nbits ; i ++ ) { value |= ( Huff_getBit ( msg -> data , & msg -> bit ) << i ) ; } bits = bits - nbits ; } if ( bits ) { for ( i = 0 ; i < bits ; i += 8 ) {  Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;   value |= ( get << ( i + nbits ) ) ;  } } msg -> readcount = ( msg -> bit >> 3 ) + 1 ; } if ( sgn && bits > 0 && bits < 32 ) { if ( value & ( 1 << ( bits - 1 ) ) ) { value |= - 1 ^ ( ( 1 << bits ) - 1 ) ; } } return value ; }",if ( msg -> readcount > msg -> cursize ) {return 0 ;}value = 0 ;if ( bits < 0 ) {if ( msg -> oob ) {if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}if ( bits == 8 ) {,1377
250,"buggy line: nbits = bits & 7 ;for ( i = 0 ;cwe id:CWE-119context: int MSG_ReadBits ( msg_t * msg , int bits ) { int value ; int get ; qboolean sgn ; int i , nbits ;  value = 0 ;  if ( bits < 0 ) { bits = - bits ; sgn = qtrue ; } else { sgn = qfalse ; }  if ( msg -> oob ) {  if ( bits == 8 ) { value = msg -> data [ msg -> readcount ] ; msg -> readcount += 1 ; msg -> bit += 8 ; } else if ( bits == 16 ) { short temp ; CopyLittleShort ( & temp , & msg -> data [ msg -> readcount ] ) ; value = temp ; msg -> readcount += 2 ; msg -> bit += 16 ; } else if ( bits == 32 ) { CopyLittleLong ( & value , & msg -> data [ msg -> readcount ] ) ; msg -> readcount += 4 ; msg -> bit += 32 ; } else Com_Error ( ERR_DROP , ""can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bits"" , bits ) ; } else { nbits = 0 ; if ( bits & 7 ) {  nbits = bits & 7 ;  for ( i = 0 ; i < nbits ; i ++ ) { value |= ( Huff_getBit ( msg -> data , & msg -> bit ) << i ) ; } bits = bits - nbits ; } if ( bits ) { for ( i = 0 ; i < bits ; i += 8 ) {  Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;   value |= ( get << ( i + nbits ) ) ;  } } msg -> readcount = ( msg -> bit >> 3 ) + 1 ; } if ( sgn && bits > 0 && bits < 32 ) { if ( value & ( 1 << ( bits - 1 ) ) ) { value |= - 1 ^ ( ( 1 << bits ) - 1 ) ; } } return value ; }","nbits = bits & 7 ;if ( msg -> bit , msg -> cursize << 3 + nbits > msg -> cursize << 3 ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}for ( i = 0 ;",1377
251,"buggy line: Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;value |= ( get << ( i + nbits ) ) ;}cwe id:CWE-119context: int MSG_ReadBits ( msg_t * msg , int bits ) { int value ; int get ; qboolean sgn ; int i , nbits ;  value = 0 ;  if ( bits < 0 ) { bits = - bits ; sgn = qtrue ; } else { sgn = qfalse ; }  if ( msg -> oob ) {  if ( bits == 8 ) { value = msg -> data [ msg -> readcount ] ; msg -> readcount += 1 ; msg -> bit += 8 ; } else if ( bits == 16 ) { short temp ; CopyLittleShort ( & temp , & msg -> data [ msg -> readcount ] ) ; value = temp ; msg -> readcount += 2 ; msg -> bit += 16 ; } else if ( bits == 32 ) { CopyLittleLong ( & value , & msg -> data [ msg -> readcount ] ) ; msg -> readcount += 4 ; msg -> bit += 32 ; } else Com_Error ( ERR_DROP , ""can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bits"" , bits ) ; } else { nbits = 0 ; if ( bits & 7 ) {  nbits = bits & 7 ;  for ( i = 0 ; i < nbits ; i ++ ) { value |= ( Huff_getBit ( msg -> data , & msg -> bit ) << i ) ; } bits = bits - nbits ; } if ( bits ) { for ( i = 0 ; i < bits ; i += 8 ) {  Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;   value |= ( get << ( i + nbits ) ) ;  } } msg -> readcount = ( msg -> bit >> 3 ) + 1 ; } if ( sgn && bits > 0 && bits < 32 ) { if ( value & ( 1 << ( bits - 1 ) ) ) { value |= - 1 ^ ( ( 1 << bits ) - 1 ) ; } } return value ; }","Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;value |= ( get << ( i + nbits ) ) ;if ( msg -> bit > msg -> cursize << 3 ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}}",1377
252,"buggy line: int err = - EINVAL ;if ( ! kcontrol ) return err ;cwe id:CWE-416context: int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ;  int err = - EINVAL ;  if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ;  up_write ( & card -> controls_rwsem ) ;   for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }",unsigned int count ;int err = - EINVAL ;if ( ! kcontrol ) return err ;,1378
253,"buggy line: up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < kcontrol -> count ;idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;cwe id:CWE-416context: int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ;  int err = - EINVAL ;  if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ;  up_write ( & card -> controls_rwsem ) ;   for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }","count = kcontrol -> count ;up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < count ;idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;",1378
254,"buggy line: out1 :  free_netdev ( net ) ;out : return status ;cwe id:CWE-000context: int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , ""blacklisted<S2SV_blank>by<S2SV_blank>%s\\n"" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long ) dev ; init_timer ( & dev -> delay ) ; mutex_init ( & dev -> phy_mutex ) ; mutex_init ( & dev -> interrupt_mutex ) ; dev -> interrupt_count = 0 ; dev -> net = net ; strcpy ( net -> name , ""usb%d"" ) ; memcpy ( net -> dev_addr , node_id , sizeof node_id ) ; dev -> hard_mtu = net -> mtu + net -> hard_header_len ; net -> netdev_ops = & usbnet_netdev_ops ; net -> watchdog_timeo = TX_TIMEOUT_JIFFIES ; net -> ethtool_ops = & usbnet_ethtool_ops ; if ( info -> bind ) { status = info -> bind ( dev , udev ) ; if ( status < 0 ) goto out1 ; if ( ( dev -> driver_info -> flags & FLAG_ETHER ) != 0 && ( ( dev -> driver_info -> flags & FLAG_POINTTOPOINT ) == 0 || ( net -> dev_addr [ 0 ] & 0x02 ) == 0 ) ) strcpy ( net -> name , ""eth%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) strcpy ( net -> name , ""wlan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) strcpy ( net -> name , ""wwan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_NOARP ) != 0 ) net -> flags |= IFF_NOARP ; if ( net -> mtu > ( dev -> hard_mtu - net -> hard_header_len ) ) net -> mtu = dev -> hard_mtu - net -> hard_header_len ; } else if ( ! info -> in || ! info -> out ) status = usbnet_get_endpoints ( dev , udev ) ; else { dev -> in = usb_rcvbulkpipe ( xdev , info -> in ) ; dev -> out = usb_sndbulkpipe ( xdev , info -> out ) ; if ( ! ( info -> flags & FLAG_NO_SETINT ) ) status = usb_set_interface ( xdev , interface -> desc . bInterfaceNumber , interface -> desc . bAlternateSetting ) ; else status = 0 ; } if ( status >= 0 && dev -> status ) status = init_status ( dev , udev ) ; if ( status < 0 ) goto out3 ; if ( ! dev -> rx_urb_size ) dev -> rx_urb_size = dev -> hard_mtu ; dev -> maxpacket = usb_maxpacket ( dev -> udev , dev -> out , 1 ) ; if ( ether_addr_equal ( net -> dev_addr , node_id ) ) net -> addr_assign_type = NET_ADDR_RANDOM ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wlan_type ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wwan_type ) ; usbnet_update_max_qlen ( dev ) ; if ( dev -> can_dma_sg && ! ( info -> flags & FLAG_SEND_ZLP ) && ! ( info -> flags & FLAG_MULTI_PACKET ) ) { dev -> padding_pkt = kzalloc ( 1 , GFP_KERNEL ) ; if ( ! dev -> padding_pkt ) { status = - ENOMEM ; goto out4 ; } } status = register_netdev ( net ) ; if ( status ) goto out5 ; netif_info ( dev , probe , dev -> net , ""register<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\n"" , udev -> dev . driver -> name , xdev -> bus -> bus_name , xdev -> devpath , dev -> driver_info -> description , net -> dev_addr ) ; usb_set_intfdata ( udev , dev ) ; netif_device_attach ( net ) ; if ( dev -> driver_info -> flags & FLAG_LINK_INTR ) usbnet_link_change ( dev , 0 , 0 ) ; return 0 ; out5 : kfree ( dev -> padding_pkt ) ; out4 : usb_free_urb ( dev -> interrupt ) ; out3 : if ( info -> unbind ) info -> unbind ( dev , udev ) ; out1 :  free_netdev ( net ) ;  out : return status ; }",out1 : cancel_work_sync ( & dev -> kevent ) ;del_timer_sync ( & dev -> delay ) ;free_netdev ( net ) ;out : return status ;,1379
255,"buggy line: int overhead = 16 + 4 + strlen ( ns ) + 1 ;int size = overhead ;if ( mongo_validate_ns ( conn , ns ) != MONGO_OK ) return MONGO_ERROR ;cwe id:CWE-190context: MONGO_EXPORT int mongo_insert_batch ( mongo * conn , const char * ns , const bson * * bsons , int count , mongo_write_concern * custom_write_concern , int flags ) { mongo_message * mm ; mongo_write_concern * write_concern = NULL ; int i ; char * data ;  int overhead = 16 + 4 + strlen ( ns ) + 1 ;   int size = overhead ;  if ( mongo_validate_ns ( conn , ns ) != MONGO_OK ) return MONGO_ERROR ; for ( i = 0 ; i < count ; i ++ ) { size += bson_size ( bsons [ i ] ) ; if ( mongo_bson_valid ( conn , bsons [ i ] , 1 ) != MONGO_OK ) return MONGO_ERROR ; } if ( ( size - overhead ) > conn -> max_bson_size ) { conn -> err = MONGO_BSON_TOO_LARGE ; return MONGO_ERROR ; } if ( mongo_choose_write_concern ( conn , custom_write_concern , & write_concern ) == MONGO_ERROR ) { return MONGO_ERROR ; } mm = mongo_message_create ( size , 0 , 0 , MONGO_OP_INSERT ) ; data = & mm -> data ; if ( flags & MONGO_CONTINUE_ON_ERROR ) data = mongo_data_append32 ( data , & ONE ) ; else data = mongo_data_append32 ( data , & ZERO ) ; data = mongo_data_append ( data , ns , strlen ( ns ) + 1 ) ; for ( i = 0 ; i < count ; i ++ ) { data = mongo_data_append ( data , bsons [ i ] -> data , bson_size ( bsons [ i ] ) ) ; } if ( write_concern ) { if ( mongo_message_send ( conn , mm ) == MONGO_ERROR ) { return MONGO_ERROR ; } return mongo_check_last_error ( conn , ns , write_concern ) ; } else { return mongo_message_send ( conn , mm ) ; } }","size_t overhead = 16 + 4 + strlen ( ns ) + 1 ;size_t size = overhead ;if ( mongo_validate_ns ( conn , ns ) != MONGO_OK ) return MONGO_ERROR ;",1380
256,"buggy line: if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK )  save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ;gtk_widget_destroy ( textview ) ;cwe id:CWE-200context: static void tv_details_row_activated ( GtkTreeView * tree_view , GtkTreePath * tree_path_UNUSED , GtkTreeViewColumn * column , gpointer user_data ) { gchar * item_name ; struct problem_item * item = get_current_problem_item_or_NULL ( tree_view , & item_name ) ; if ( ! item || ! ( item -> flags & CD_FLAG_TXT ) ) goto ret ; if ( ! strchr ( item -> content , '\\n' ) ) goto ret ; gint exitcode ; gchar * arg [ 3 ] ; arg [ 0 ] = ( char * ) ""xdg-open"" ; arg [ 1 ] = concat_path_file ( g_dump_dir_name , item_name ) ; arg [ 2 ] = NULL ; const gboolean spawn_ret = g_spawn_sync ( NULL , arg , NULL , G_SPAWN_SEARCH_PATH | G_SPAWN_STDOUT_TO_DEV_NULL , NULL , NULL , NULL , NULL , & exitcode , NULL ) ; if ( spawn_ret == FALSE || exitcode != EXIT_SUCCESS ) { GtkWidget * dialog = gtk_dialog_new_with_buttons ( _ ( ""View/edit<S2SV_blank>a<S2SV_blank>text<S2SV_blank>file"" ) , GTK_WINDOW ( g_wnd_assistant ) , GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT , NULL , NULL ) ; GtkWidget * vbox = gtk_dialog_get_content_area ( GTK_DIALOG ( dialog ) ) ; GtkWidget * scrolled = gtk_scrolled_window_new ( NULL , NULL ) ; GtkWidget * textview = gtk_text_view_new ( ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Save"" ) , GTK_RESPONSE_OK ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_box_pack_start ( GTK_BOX ( vbox ) , scrolled , TRUE , TRUE , 0 ) ; gtk_widget_set_size_request ( scrolled , 640 , 480 ) ; gtk_widget_show ( scrolled ) ; # if ( ( GTK_MAJOR_VERSION == 3 && GTK_MINOR_VERSION < 7 ) || ( GTK_MAJOR_VERSION == 3 && GTK_MINOR_VERSION == 7 && GTK_MICRO_VERSION < 8 ) ) gtk_scrolled_window_add_with_viewport ( GTK_SCROLLED_WINDOW ( scrolled ) , textview ) ; # else gtk_container_add ( GTK_CONTAINER ( scrolled ) , textview ) ; # endif gtk_widget_show ( textview ) ; load_text_to_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ; if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK )  save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ;  gtk_widget_destroy ( textview ) ; gtk_widget_destroy ( scrolled ) ; gtk_widget_destroy ( dialog ) ; } free ( arg [ 1 ] ) ; ret : g_free ( item_name ) ; }","if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK ) {save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ;problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;}gtk_widget_destroy ( textview ) ;",1381
257,"buggy line: last_id = ntohs ( * pid ) ;if ( last_id > 20000 ) wrap = 1 ;cwe id:CWE-20context: int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet<S2SV_blank>check<S2SV_blank>by<S2SV_blank>%s<S2SV_blank>%d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ;  last_id = ntohs ( * pid ) ;  if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got<S2SV_blank>packet<S2SV_blank>%d<S2SV_blank>%d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( ""<S2SV_blank>(DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",if ( plen < 0 ) return 0 ;last_id = ntohs ( * pid ) ;if ( last_id > 20000 ) wrap = 1 ;,1382
258,"buggy line: retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ;}}else acl = NULL ;switch ( handler -> flags ) {case ACL_TYPE_ACCESS : if ( acl ) {umode_t mode = inode -> i_mode ;retval = posix_acl_equiv_mode ( acl , & mode ) ;if ( retval < 0 ) goto err_out ;else {struct iattr iattr ;if ( retval == 0 ) {acl = NULL ;iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ;}}cwe id:CWE-285context: static int v9fs_xattr_set_acl ( const struct xattr_handler * handler , struct dentry * dentry , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { int retval ; struct posix_acl * acl ; struct v9fs_session_info * v9ses ; v9ses = v9fs_dentry2v9ses ( dentry ) ; if ( ( v9ses -> flags & V9FS_ACCESS_MASK ) != V9FS_ACCESS_CLIENT ) return v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( value ) { acl = posix_acl_from_xattr ( & init_user_ns , value , size ) ; if ( IS_ERR ( acl ) ) return PTR_ERR ( acl ) ; else if ( acl ) { retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ; if ( retval ) goto err_out ; } } else acl = NULL ; switch ( handler -> flags ) { case ACL_TYPE_ACCESS : if ( acl ) {  umode_t mode = inode -> i_mode ;  retval = posix_acl_equiv_mode ( acl , & mode ) ; if ( retval < 0 ) goto err_out ;  else {  struct iattr iattr ; if ( retval == 0 ) { acl = NULL ; value = NULL ; size = 0 ; } iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ; iattr . ia_valid = ATTR_MODE ; v9fs_vfs_setattr_dotl ( dentry , & iattr ) ;  }  } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { retval = acl ? - EINVAL : 0 ; goto err_out ; } break ; default : BUG ( ) ; } retval = v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( ! retval ) set_cached_acl ( inode , handler -> flags , acl ) ; err_out : posix_acl_release ( acl ) ; return retval ; }","struct iattr iattr ;retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ;if ( ! acl ) {}}",1383
259,"buggy line: if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) {continue ;cwe id:CWE-125context: static int dex_loadcode ( RBinFile * arch , RBinDexObj * bin ) { struct r_bin_t * rbin = arch -> rbin ; int i ; int * methods = NULL ; int sym_count = 0 ; if ( ! bin || bin -> methods_list ) { return false ; } bin -> code_from = UT64_MAX ; bin -> code_to = 0 ; bin -> methods_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> methods_list ) { return false ; } bin -> imports_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> imports_list ) { r_list_free ( bin -> methods_list ) ; return false ; } bin -> classes_list = r_list_newf ( ( RListFree ) __r_bin_class_free ) ; if ( ! bin -> classes_list ) { r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; return false ; } if ( bin -> header . method_size > bin -> size ) { bin -> header . method_size = 0 ; return false ; } bin -> header . method_size = R_MIN ( bin -> header . method_size , bin -> size ) ; bin -> header . class_size = R_MIN ( bin -> header . class_size , bin -> size ) ; bin -> header . strings_size = R_MIN ( bin -> header . strings_size , bin -> size ) ; if ( bin -> header . strings_size > bin -> size ) { eprintf ( ""Invalid<S2SV_blank>strings<S2SV_blank>size\\n"" ) ; return false ; } if ( bin -> classes ) { ut64 amount = sizeof ( int ) * bin -> header . method_size ; if ( amount > UT32_MAX || amount < bin -> header . method_size ) { return false ; } methods = calloc ( 1 , amount + 1 ) ; for ( i = 0 ; i < bin -> header . class_size ; i ++ ) { char * super_name , * class_name ; struct dex_class_t * c = & bin -> classes [ i ] ; class_name = dex_class_name ( bin , c ) ; super_name = dex_class_super_name ( bin , c ) ; if ( dexdump ) { rbin -> cb_printf ( ""Class<S2SV_blank>#%d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>-\\n"" , i ) ; } parse_class ( arch , bin , c , i , methods , & sym_count ) ; free ( class_name ) ; free ( super_name ) ; } } if ( methods ) { int import_count = 0 ; int sym_count = bin -> methods_list -> length ; for ( i = 0 ; i < bin -> header . method_size ; i ++ ) { int len = 0 ; if ( methods [ i ] ) { continue ; }  if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) {  continue ; } if ( is_class_idx_in_code_classes ( bin , bin -> methods [ i ] . class_id ) ) { continue ; } char * class_name = getstr ( bin , bin -> types [ bin -> methods [ i ] . class_id ] . descriptor_id ) ; if ( ! class_name ) { free ( class_name ) ; continue ; } len = strlen ( class_name ) ; if ( len < 1 ) { continue ; } class_name [ len - 1 ] = 0 ; char * method_name = dex_method_name ( bin , i ) ; char * signature = dex_method_signature ( bin , i ) ; if ( method_name && * method_name ) { RBinImport * imp = R_NEW0 ( RBinImport ) ; imp -> name = r_str_newf ( ""%s.method.%s%s"" , class_name , method_name , signature ) ; imp -> type = r_str_const ( ""FUNC"" ) ; imp -> bind = r_str_const ( ""NONE"" ) ; imp -> ordinal = import_count ++ ; r_list_append ( bin -> imports_list , imp ) ; RBinSymbol * sym = R_NEW0 ( RBinSymbol ) ; sym -> name = r_str_newf ( ""imp.%s"" , imp -> name ) ; sym -> type = r_str_const ( ""FUNC"" ) ; sym -> bind = r_str_const ( ""NONE"" ) ; sym -> paddr = sym -> vaddr = bin -> b -> base + bin -> header . method_offset + ( sizeof ( struct dex_method_t ) * i ) ; sym -> ordinal = sym_count ++ ; r_list_append ( bin -> methods_list , sym ) ; sdb_num_set ( mdb , sdb_fmt ( 0 , ""method.%d"" , i ) , sym -> paddr , 0 ) ; } free ( method_name ) ; free ( signature ) ; free ( class_name ) ; } free ( methods ) ; } return true ; }",if ( bin -> methods [ i ] . class_id > bin -> header . types_size ) {continue ;,1384
260,buggy line: case NPPVpluginNameString : case NPPVpluginDescriptionString :  case NPPVformValue :  type = RPC_TYPE_STRING ;case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory :  type = RPC_TYPE_BOOLEAN ;break ;cwe id:CWE-264context: int rpc_type_of_NPPVariable ( int variable ) { int type ; switch ( variable ) { case NPPVpluginNameString : case NPPVpluginDescriptionString :  case NPPVformValue :  type = RPC_TYPE_STRING ; break ; case NPPVpluginWindowSize : case NPPVpluginTimerInterval : type = RPC_TYPE_INT32 ; break ; case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory :  type = RPC_TYPE_BOOLEAN ;  break ; case NPPVpluginScriptableNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; },case NPPVpluginNameString : case NPPVpluginDescriptionString : case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId : type = RPC_TYPE_STRING ;case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling : type = RPC_TYPE_BOOLEAN ;break ;,1385
261,"buggy line: int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ;char * ns = malloc ( alloc ) ;unsigned char in ;int strindex = 0 ;unsigned long hex ;CURLcode res ;if ( ! ns ) return NULL ;cwe id:CWE-89context: char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen ) {  int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ;  char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ;  CURLcode res ;  if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ;  res = Curl_convert_from_network ( handle , & in , 1 ) ;   if ( res ) {  free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen )  * olen = strindex ;  return ns ; }",char * str = NULL ;size_t inputlen = length ;size_t outputlen ;CURLcode res ;if ( ! ns ) return NULL ;,1386
262,"buggy line: res = Curl_convert_from_network ( handle , & in , 1 ) ;if ( res ) {free ( ns ) ;return NULL ;}string += 2 ;alloc -= 2 ;}ns [ strindex ++ ] = in ;string ++ ;}ns [ strindex ] = 0 ;if ( olen )  * olen = strindex ;return ns ;cwe id:CWE-89context: char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen ) {  int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ;  char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ;  CURLcode res ;  if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ;  res = Curl_convert_from_network ( handle , & in , 1 ) ;   if ( res ) {  free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen )  * olen = strindex ;  return ns ; }","res = Curl_convert_from_network ( handle , string , inputlen , & str , & outputlen , FALSE ) ;if ( res ) return NULL ;if ( olen ) * olen = curlx_uztosi ( outputlen ) ;return str ;",1386
263,"buggy line: void nego_process_negotiation_response ( rdpNego * nego , wStream * s )  {return ;}}cwe id:CWE-125context:  void nego_process_negotiation_response ( rdpNego * nego , wStream * s )  { UINT16 length ; WLog_DBG ( TAG , ""RDP_NEG_RSP"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) { WLog_ERR ( TAG , ""Invalid<S2SV_blank>RDP_NEG_RSP"" ) ; nego -> state = NEGO_STATE_FAIL ;  return ;  } Stream_Read_UINT8 ( s , nego -> flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> SelectedProtocol ) ; nego -> state = NEGO_STATE_FINAL ;  } ","BOOL nego_process_negotiation_response ( rdpNego * nego , wStream * s ) {return FALSE ;}return TRUE ;}",1387
264,"buggy line: int i , target_bits_per_mb ;const double correction_factor = get_rate_correction_factor ( cpi ) ;const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i ,   correction_factor ) ;if ( bits_per_mb_at_this_q <= target_bits_per_mb ) {cwe id:CWE-119context: int vp9_rc_regulate_q ( const VP9_COMP * cpi , int target_bits_per_frame , int active_best_quality , int active_worst_quality ) { const VP9_COMMON * const cm = & cpi -> common ; int q = active_worst_quality ; int last_error = INT_MAX ;  int i , target_bits_per_mb ;  const double correction_factor = get_rate_correction_factor ( cpi ) ; target_bits_per_mb = ( ( uint64_t ) target_bits_per_frame << BPER_MB_NORMBITS ) / cm -> MBs ; i = active_best_quality ; do {  const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i ,   correction_factor ) ;  if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) q = i ; else q = i - 1 ; break ; } else { last_error = bits_per_mb_at_this_q - target_bits_per_mb ; } } while ( ++ i <= active_worst_quality ) ;  return q ;  }","int i , target_bits_per_mb , bits_per_mb_at_this_q ;const double correction_factor = get_rate_correction_factor ( cpi ) ;if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && cpi -> svc . temporal_layer_id == 0 && cpi -> svc . spatial_layer_id == 0 ) {bits_per_mb_at_this_q = ( int ) vp9_cyclic_refresh_rc_bits_per_mb ( cpi , i , correction_factor , cm -> bit_depth ) ;}if ( bits_per_mb_at_this_q <= target_bits_per_mb ) {",1388
265,"buggy line: return q ;}cwe id:CWE-119context: int vp9_rc_regulate_q ( const VP9_COMP * cpi , int target_bits_per_frame , int active_best_quality , int active_worst_quality ) { const VP9_COMMON * const cm = & cpi -> common ; int q = active_worst_quality ; int last_error = INT_MAX ;  int i , target_bits_per_mb ;  const double correction_factor = get_rate_correction_factor ( cpi ) ; target_bits_per_mb = ( ( uint64_t ) target_bits_per_frame << BPER_MB_NORMBITS ) / cm -> MBs ; i = active_best_quality ; do {  const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i ,   correction_factor ) ;  if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) q = i ; else q = i - 1 ; break ; } else { last_error = bits_per_mb_at_this_q - target_bits_per_mb ; } } while ( ++ i <= active_worst_quality ) ;  return q ;  }","if ( cpi -> oxcf . rc_mode == VPX_CBR && ( cpi -> rc . rc_1_frame * cpi -> rc . rc_2_frame == - 1 ) && cpi -> rc . q_1_frame != cpi -> rc . q_2_frame ) {q = clamp ( q , MIN ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) , MAX ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) ) ;}return q ;}",1388
266,"buggy line: value |= TJA1101_EXTENDED_CTRL_CONFIG_EN ;value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ;tja1101WritePhyReg ( interface , TJA1101_CONFIG1 , value ) ;cwe id:CWE-20context: error_t tja1101Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1101...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1101_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1101WritePhyReg ( interface , TJA1101_BASIC_CTRL , TJA1101_BASIC_CTRL_RESET ) ; while ( tja1101ReadPhyReg ( interface , TJA1101_BASIC_CTRL ) & TJA1101_BASIC_CTRL_RESET ) { } tja1101DumpPhyReg ( interface ) ; value = tja1101ReadPhyReg ( interface , TJA1101_EXTENDED_CTRL ) ; value |= TJA1101_EXTENDED_CTRL_CONFIG_EN ; tja1101WritePhyReg ( interface , TJA1101_EXTENDED_CTRL , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_CONFIG1 ) ; value &= ~ TJA1101_CONFIG1_MII_MODE ;  value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ;  tja1101WritePhyReg ( interface , TJA1101_CONFIG1 , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_COMM_CTRL ) ; value |= TJA1101_COMM_CTRL_AUTO_OP ; tja1101WritePhyReg ( interface , TJA1101_COMM_CTRL , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }","value |= TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT ;value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ;tja1101WritePhyReg ( interface , TJA1101_CONFIG1 , value ) ;",1389
267,"buggy line: strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ;rcipher . blocksize = alg -> cra_blocksize ;cwe id:CWE-200context: static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ;  strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ;  rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }","strncpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ;rcipher . blocksize = alg -> cra_blocksize ;",1390
268,"buggy line: if ( len < sizeof ( * prep ) ) {return ( - 1 ) ;}n = EXTRACT_32BITS ( & prep -> pp_n ) ;cwe id:CWE-125context: static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ;  if ( len < sizeof ( * prep ) ) {  return ( - 1 ) ;  }  n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }",if ( len < sizeof ( * prep ) || ! ND_TTEST ( * prep ) ) return ( - 1 ) ;n = EXTRACT_32BITS ( & prep -> pp_n ) ;,1391
269,"buggy line: mark_object ( & c -> object , NULL , NULL , data ) ;}cwe id:CWE-119context: static void mark_commit ( struct commit * c , void * data ) {  mark_object ( & c -> object , NULL , NULL , data ) ;  }","mark_object ( & c -> object , NULL , data ) ;}",1392
270,"buggy line: freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ;if ( ! freq_reg ) return - ENOMEM ;cwe id:CWE-476context: static int hi3660_stub_clk_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct resource * res ; unsigned int i ; int ret ; stub_clk_chan . cl . dev = dev ; stub_clk_chan . cl . tx_done = NULL ; stub_clk_chan . cl . tx_block = false ; stub_clk_chan . cl . knows_txdone = false ; stub_clk_chan . mbox = mbox_request_channel ( & stub_clk_chan . cl , 0 ) ; if ( IS_ERR ( stub_clk_chan . mbox ) ) return PTR_ERR ( stub_clk_chan . mbox ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ;  freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ;  if ( ! freq_reg ) return - ENOMEM ; freq_reg += HI3660_STUB_CLOCK_DATA ; for ( i = 0 ; i < HI3660_CLK_STUB_NUM ; i ++ ) { ret = devm_clk_hw_register ( & pdev -> dev , & hi3660_stub_clks [ i ] . hw ) ; if ( ret ) return ret ; } return devm_of_clk_add_hw_provider ( & pdev -> dev , hi3660_stub_clk_hw_get , hi3660_stub_clks ) ; }","if ( ! res ) return - EINVAL ;freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ;if ( ! freq_reg ) return - ENOMEM ;",1393
271,"buggy line: if ( TYPE ( n ) == parameters ) {cwe id:CWE-125context: static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg = NULL ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Py_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Py_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ;  if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d"" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }",if ( i < NCH ( n ) && TYPE ( n ) == parameters ) {,1394
272,"buggy line: if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;cwe id:CWE-125context: static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg = NULL ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Py_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Py_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ;  if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d"" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }","if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;",1394
273,"buggy line: static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride ,  MB_PREDICTION_MODE mode , TX_SIZE tx_size ,  int up_available , int left_available , int right_available , int x , int y , int plane ) {DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ;DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ;once ( init_intra_pred_fn_ptrs ) ;if ( plane == 0 ) {cwe id:CWE-119context: static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride ,  MB_PREDICTION_MODE mode , TX_SIZE tx_size ,  int up_available , int left_available , int right_available , int x , int y , int plane ) { int i ;  DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ;  DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ; uint8_t * above_row = above_data + 16 ; const uint8_t * const_above_row = above_row ; const int bs = 4 << tx_size ; int frame_width , frame_height ; int x0 , y0 ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;  once ( init_intra_pred_fn_ptrs ) ;  if ( plane == 0 ) { frame_width = xd -> cur_buf -> y_width ; frame_height = xd -> cur_buf -> y_height ; } else { frame_width = xd -> cur_buf -> uv_width ; frame_height = xd -> cur_buf -> uv_height ; } x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ;  vpx_memset ( left_col , 129 , 64 ) ;  if ( left_available ) { if ( xd -> mb_to_bottom_edge < 0 ) { if ( y0 + bs <= frame_height ) { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } else { const int extend_bottom = frame_height - y0 ; for ( i = 0 ; i < extend_bottom ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; for ( ; i < bs ; ++ i ) left_col [ i ] = ref [ ( extend_bottom - 1 ) * ref_stride - 1 ] ; } } else { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; }  }  if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) {  if ( x0 + 2 * bs <= frame_width ) {   if ( right_available && bs == 4 ) {  vpx_memcpy ( above_row , above_ref , 2 * bs ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ;  if ( right_available && bs == 4 ) {  vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { if ( bs == 4 && right_available && left_available ) { const_above_row = above_ref ; } else {  vpx_memcpy ( above_row , above_ref , bs ) ;   if ( bs == 4 && right_available )  vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ; else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; }  }  } else { vpx_memset ( above_row , 127 , bs * 2 ) ;  above_row [ - 1 ] = 127 ;  } if ( mode == DC_PRED ) { dc_pred [ left_available ] [ up_available ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } else { pred [ mode ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } }","static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , PREDICTION_MODE mode , TX_SIZE tx_size , int up_available , int left_available , int right_available , int x , int y , int plane ) {DECLARE_ALIGNED ( 16 , uint8_t , left_col [ 32 ] ) ;DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] ) ;if ( plane == 0 ) {",1395
274,"buggy line: vpx_memset ( left_col , 129 , 64 ) ;if ( left_available ) {cwe id:CWE-119context: static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride ,  MB_PREDICTION_MODE mode , TX_SIZE tx_size ,  int up_available , int left_available , int right_available , int x , int y , int plane ) { int i ;  DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ;  DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ; uint8_t * above_row = above_data + 16 ; const uint8_t * const_above_row = above_row ; const int bs = 4 << tx_size ; int frame_width , frame_height ; int x0 , y0 ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;  once ( init_intra_pred_fn_ptrs ) ;  if ( plane == 0 ) { frame_width = xd -> cur_buf -> y_width ; frame_height = xd -> cur_buf -> y_height ; } else { frame_width = xd -> cur_buf -> uv_width ; frame_height = xd -> cur_buf -> uv_height ; } x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ;  vpx_memset ( left_col , 129 , 64 ) ;  if ( left_available ) { if ( xd -> mb_to_bottom_edge < 0 ) { if ( y0 + bs <= frame_height ) { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } else { const int extend_bottom = frame_height - y0 ; for ( i = 0 ; i < extend_bottom ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; for ( ; i < bs ; ++ i ) left_col [ i ] = ref [ ( extend_bottom - 1 ) * ref_stride - 1 ] ; } } else { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; }  }  if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) {  if ( x0 + 2 * bs <= frame_width ) {   if ( right_available && bs == 4 ) {  vpx_memcpy ( above_row , above_ref , 2 * bs ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ;  if ( right_available && bs == 4 ) {  vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { if ( bs == 4 && right_available && left_available ) { const_above_row = above_ref ; } else {  vpx_memcpy ( above_row , above_ref , bs ) ;   if ( bs == 4 && right_available )  vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ; else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; }  }  } else { vpx_memset ( above_row , 127 , bs * 2 ) ;  above_row [ - 1 ] = 127 ;  } if ( mode == DC_PRED ) { dc_pred [ left_available ] [ up_available ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } else { pred [ mode ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } }",if ( extend_modes [ mode ] & NEED_LEFT ) {if ( left_available ) {,1395
275,"buggy line: }if ( up_available ) {if ( x0 + 2 * bs <= frame_width ) {if ( right_available && bs == 4 ) {vpx_memcpy ( above_row , above_ref , 2 * bs ) ;cwe id:CWE-119context: static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride ,  MB_PREDICTION_MODE mode , TX_SIZE tx_size ,  int up_available , int left_available , int right_available , int x , int y , int plane ) { int i ;  DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ;  DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ; uint8_t * above_row = above_data + 16 ; const uint8_t * const_above_row = above_row ; const int bs = 4 << tx_size ; int frame_width , frame_height ; int x0 , y0 ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;  once ( init_intra_pred_fn_ptrs ) ;  if ( plane == 0 ) { frame_width = xd -> cur_buf -> y_width ; frame_height = xd -> cur_buf -> y_height ; } else { frame_width = xd -> cur_buf -> uv_width ; frame_height = xd -> cur_buf -> uv_height ; } x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ;  vpx_memset ( left_col , 129 , 64 ) ;  if ( left_available ) { if ( xd -> mb_to_bottom_edge < 0 ) { if ( y0 + bs <= frame_height ) { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } else { const int extend_bottom = frame_height - y0 ; for ( i = 0 ; i < extend_bottom ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; for ( ; i < bs ; ++ i ) left_col [ i ] = ref [ ( extend_bottom - 1 ) * ref_stride - 1 ] ; } } else { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; }  }  if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) {  if ( x0 + 2 * bs <= frame_width ) {   if ( right_available && bs == 4 ) {  vpx_memcpy ( above_row , above_ref , 2 * bs ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ;  if ( right_available && bs == 4 ) {  vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { if ( bs == 4 && right_available && left_available ) { const_above_row = above_ref ; } else {  vpx_memcpy ( above_row , above_ref , bs ) ;   if ( bs == 4 && right_available )  vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ; else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; }  }  } else { vpx_memset ( above_row , 127 , bs * 2 ) ;  above_row [ - 1 ] = 127 ;  } if ( mode == DC_PRED ) { dc_pred [ left_available ] [ up_available ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } else { pred [ mode ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } }","memset ( left_col , 129 , bs ) ;}}if ( extend_modes [ mode ] & NEED_ABOVE ) {else {}if ( up_available ) {if ( x0 + bs <= frame_width ) {if ( right_available && bs == 4 ) {vpx_memcpy ( above_row , above_ref , 2 * bs ) ;",1395
276,"buggy line: const int r = frame_width - x0 ;if ( right_available && bs == 4 ) {vpx_memcpy ( above_row , above_ref , r ) ;vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ;}else {vpx_memcpy ( above_row , above_ref , bs ) ;vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ;}cwe id:CWE-119context: static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride ,  MB_PREDICTION_MODE mode , TX_SIZE tx_size ,  int up_available , int left_available , int right_available , int x , int y , int plane ) { int i ;  DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ;  DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ; uint8_t * above_row = above_data + 16 ; const uint8_t * const_above_row = above_row ; const int bs = 4 << tx_size ; int frame_width , frame_height ; int x0 , y0 ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;  once ( init_intra_pred_fn_ptrs ) ;  if ( plane == 0 ) { frame_width = xd -> cur_buf -> y_width ; frame_height = xd -> cur_buf -> y_height ; } else { frame_width = xd -> cur_buf -> uv_width ; frame_height = xd -> cur_buf -> uv_height ; } x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ;  vpx_memset ( left_col , 129 , 64 ) ;  if ( left_available ) { if ( xd -> mb_to_bottom_edge < 0 ) { if ( y0 + bs <= frame_height ) { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } else { const int extend_bottom = frame_height - y0 ; for ( i = 0 ; i < extend_bottom ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; for ( ; i < bs ; ++ i ) left_col [ i ] = ref [ ( extend_bottom - 1 ) * ref_stride - 1 ] ; } } else { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; }  }  if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) {  if ( x0 + 2 * bs <= frame_width ) {   if ( right_available && bs == 4 ) {  vpx_memcpy ( above_row , above_ref , 2 * bs ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ;  if ( right_available && bs == 4 ) {  vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { if ( bs == 4 && right_available && left_available ) { const_above_row = above_ref ; } else {  vpx_memcpy ( above_row , above_ref , bs ) ;   if ( bs == 4 && right_available )  vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ; else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; }  }  } else { vpx_memset ( above_row , 127 , bs * 2 ) ;  above_row [ - 1 ] = 127 ;  } if ( mode == DC_PRED ) { dc_pred [ left_available ] [ up_available ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } else { pred [ mode ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } }","memcpy ( above_row , above_ref , bs ) ;",1395
277,"buggy line: vpx_memcpy ( above_row , above_ref , bs ) ;if ( bs == 4 && right_available )  vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ;else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ;}}vpx_memset ( above_row , 127 , bs * 2 ) ;above_row [ - 1 ] = 127 ;}cwe id:CWE-119context: static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride ,  MB_PREDICTION_MODE mode , TX_SIZE tx_size ,  int up_available , int left_available , int right_available , int x , int y , int plane ) { int i ;  DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ;  DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ; uint8_t * above_row = above_data + 16 ; const uint8_t * const_above_row = above_row ; const int bs = 4 << tx_size ; int frame_width , frame_height ; int x0 , y0 ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;  once ( init_intra_pred_fn_ptrs ) ;  if ( plane == 0 ) { frame_width = xd -> cur_buf -> y_width ; frame_height = xd -> cur_buf -> y_height ; } else { frame_width = xd -> cur_buf -> uv_width ; frame_height = xd -> cur_buf -> uv_height ; } x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ;  vpx_memset ( left_col , 129 , 64 ) ;  if ( left_available ) { if ( xd -> mb_to_bottom_edge < 0 ) { if ( y0 + bs <= frame_height ) { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } else { const int extend_bottom = frame_height - y0 ; for ( i = 0 ; i < extend_bottom ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; for ( ; i < bs ; ++ i ) left_col [ i ] = ref [ ( extend_bottom - 1 ) * ref_stride - 1 ] ; } } else { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; }  }  if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) {  if ( x0 + 2 * bs <= frame_width ) {   if ( right_available && bs == 4 ) {  vpx_memcpy ( above_row , above_ref , 2 * bs ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ;  if ( right_available && bs == 4 ) {  vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { if ( bs == 4 && right_available && left_available ) { const_above_row = above_ref ; } else {  vpx_memcpy ( above_row , above_ref , bs ) ;   if ( bs == 4 && right_available )  vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ; else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; }  }  } else { vpx_memset ( above_row , 127 , bs * 2 ) ;  above_row [ - 1 ] = 127 ;  } if ( mode == DC_PRED ) { dc_pred [ left_available ] [ up_available ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } else { pred [ mode ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } }","memcpy ( above_row , above_ref , bs ) ;}}above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ;}else {memset ( above_row , 127 , bs ) ;above_row [ - 1 ] = 127 ;}}if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) {if ( up_available ) {const uint8_t * above_ref = ref - ref_stride ;if ( xd -> mb_to_right_edge < 0 ) {if ( x0 + 2 * bs <= frame_width ) {if ( right_available && bs == 4 ) {memcpy ( above_row , above_ref , 2 * bs ) ;}else {memcpy ( above_row , above_ref , bs ) ;memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ;}}else if ( x0 + bs <= frame_width ) {const int r = frame_width - x0 ;if ( right_available && bs == 4 ) {memcpy ( above_row , above_ref , r ) ;memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ;}else {memcpy ( above_row , above_ref , bs ) ;memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ;}}else if ( x0 <= frame_width ) {const int r = frame_width - x0 ;memcpy ( above_row , above_ref , r ) ;memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ;}}else {memcpy ( above_row , above_ref , bs ) ;if ( bs == 4 && right_available ) memcpy ( above_row + bs , above_ref + bs , bs ) ;else memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ;}}memset ( above_row , 127 , bs * 2 ) ;above_row [ - 1 ] = 127 ;}}",1395
278,"buggy line: end ++ ;}cwe id:CWE-000context: static xsltCompMatchPtr xsltCompilePatternInternal ( const xmlChar * pattern , xmlDocPtr doc , xmlNodePtr node , xsltStylesheetPtr style , xsltTransformContextPtr runtime , int novar ) { xsltParserContextPtr ctxt = NULL ; xsltCompMatchPtr element , first = NULL , previous = NULL ; int current , start , end , level , j ; if ( pattern == NULL ) { xsltTransformError ( NULL , NULL , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; return ( NULL ) ; } ctxt = xsltNewParserContext ( style , runtime ) ; if ( ctxt == NULL ) return ( NULL ) ; ctxt -> doc = doc ; ctxt -> elem = node ; current = end = 0 ; while ( pattern [ current ] != 0 ) { start = current ; while ( IS_BLANK_CH ( pattern [ current ] ) ) current ++ ; end = current ; level = 0 ; while ( ( pattern [ end ] != 0 ) && ( ( pattern [ end ] != '|' ) || ( level != 0 ) ) ) { if ( pattern [ end ] == '[' ) level ++ ; else if ( pattern [ end ] == ']' ) level -- ; else if ( pattern [ end ] == '\\'' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != '\\'' ) ) end ++ ; } else if ( pattern [ end ] == \'""\' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != \'""\' ) ) end ++ ; }  end ++ ;  } if ( current == end ) { xsltTransformError ( NULL , NULL , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; goto error ; } element = xsltNewCompMatch ( ) ; if ( element == NULL ) { goto error ; } if ( first == NULL ) first = element ; else if ( previous != NULL ) previous -> next = element ; previous = element ; ctxt -> comp = element ; ctxt -> base = xmlStrndup ( & pattern [ start ] , end - start ) ; if ( ctxt -> base == NULL ) goto error ; ctxt -> cur = & ( ctxt -> base ) [ current - start ] ; element -> pattern = ctxt -> base ; element -> nsList = xmlGetNsList ( doc , node ) ; j = 0 ; if ( element -> nsList != NULL ) { while ( element -> nsList [ j ] != NULL ) j ++ ; } element -> nsNr = j ; # ifdef WITH_XSLT_DEBUG_PATTERN xsltGenericDebug ( xsltGenericDebugContext , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>parsing<S2SV_blank>\'%s\'\\n"" , element -> pattern ) ; # endif element -> priority = 0 ; xsltCompileLocationPathPattern ( ctxt , novar ) ; if ( ctxt -> error ) { xsltTransformError ( NULL , style , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>\'%s\'\\n"" , element -> pattern ) ; if ( style != NULL ) style -> errors ++ ; goto error ; } xsltReverseCompMatch ( ctxt , element ) ; if ( element -> priority == 0 ) { if ( ( ( element -> steps [ 0 ] . op == XSLT_OP_ELEM ) || ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) || ( element -> steps [ 0 ] . op == XSLT_OP_PI ) ) && ( element -> steps [ 0 ] . value != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) && ( element -> steps [ 0 ] . value2 != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.25 ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_NS ) && ( element -> steps [ 0 ] . value != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.25 ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) && ( element -> steps [ 0 ] . value == NULL ) && ( element -> steps [ 0 ] . value2 == NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.5 ; } else if ( ( ( element -> steps [ 0 ] . op == XSLT_OP_PI ) || ( element -> steps [ 0 ] . op == XSLT_OP_TEXT ) || ( element -> steps [ 0 ] . op == XSLT_OP_ALL ) || ( element -> steps [ 0 ] . op == XSLT_OP_NODE ) || ( element -> steps [ 0 ] . op == XSLT_OP_COMMENT ) ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.5 ; } else { element -> priority = 0.5 ; } } # ifdef WITH_XSLT_DEBUG_PATTERN xsltGenericDebug ( xsltGenericDebugContext , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>parsed<S2SV_blank>%s,<S2SV_blank>default<S2SV_blank>priority<S2SV_blank>%f\\n"" , element -> pattern , element -> priority ) ; # endif if ( pattern [ end ] == '|' ) end ++ ; current = end ; } if ( end == 0 ) { xsltTransformError ( NULL , style , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; if ( style != NULL ) style -> errors ++ ; goto error ; } xsltFreeParserContext ( ctxt ) ; return ( first ) ; error : if ( ctxt != NULL ) xsltFreeParserContext ( ctxt ) ; if ( first != NULL ) xsltFreeCompMatchList ( first ) ; return ( NULL ) ; }",if ( pattern [ end ] == 0 ) break ;end ++ ;},1396
279,"buggy line: void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) {const JsVarFloat stopAtError = 0.0000001 ;if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ;else if ( ! isfinite ( val ) ) {if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ;else strncpy ( str , ""Infinity"" , len ) ;}cwe id:CWE-119context:  void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) {  const JsVarFloat stopAtError = 0.0000001 ;  if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ;  else if ( ! isfinite ( val ) ) {  if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ;   else strncpy ( str , ""Infinity"" , len ) ;  } else { if ( val < 0 ) { if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '-' ; val = - val ; } if ( ( ( JsVarInt ) ( val + stopAtError ) ) == ( 1 + ( JsVarInt ) val ) ) val = ( JsVarFloat ) ( 1 + ( JsVarInt ) val ) ; JsVarFloat d = 1 ; while ( d * radix <= val ) d *= radix ; while ( d >= 1 ) { int v = ( int ) ( val / d ) ; val -= v * d ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; d /= radix ; } # ifndef USE_NO_FLOATS if ( ( ( fractionalDigits < 0 ) && val > 0 ) || fractionalDigits > 0 ) { bool hasPt = false ; val *= radix ; while ( ( ( fractionalDigits < 0 ) && ( fractionalDigits > - 12 ) && ( val > stopAtError ) ) || ( fractionalDigits > 0 ) ) { int v = ( int ) ( val + ( ( fractionalDigits == 1 ) ? 0.4 : 0.00000001 ) ) ; val = ( val - v ) * radix ; if ( v == radix ) v = radix - 1 ; if ( ! hasPt ) { hasPt = true ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '.' ; } if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; fractionalDigits -- ; } } # endif * ( str ++ ) = 0 ; } }","void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) {assert ( len > 9 ) ;const JsVarFloat stopAtError = 0.0000001 ;if ( isnan ( val ) ) strcpy ( str , ""NaN"" , len ) ;else if ( ! isfinite ( val ) ) {if ( val < 0 ) strcpy ( str , ""-Infinity"" , len ) ;else strcpy ( str , ""Infinity"" , len ) ;}",1397
280,"buggy line: jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len )  {cwe id:CWE-190context:  jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len )  { jas_stream_t * in ; jas_iccprof_t * prof ; if ( ! ( in = jas_stream_memopen ( JAS_CAST ( char * , buf ) , len ) ) ) goto error ; if ( ! ( prof = jas_iccprof_load ( in ) ) ) goto error ; jas_stream_close ( in ) ; return prof ; error : if ( in ) jas_stream_close ( in ) ; return 0 ; }","jas_iccprof_t * jas_iccprof_createfrombuf ( jas_uchar * buf , int len ) {",1398
281,"buggy line: ei -> cur_aio_dio = NULL ;ei -> i_sync_tid = 0 ;cwe id:CWE-000context: static struct inode * ext4_alloc_inode ( struct super_block * sb ) { struct ext4_inode_info * ei ; ei = kmem_cache_alloc ( ext4_inode_cachep , GFP_NOFS ) ; if ( ! ei ) return NULL ; ei -> vfs_inode . i_version = 1 ; ei -> vfs_inode . i_data . writeback_index = 0 ; memset ( & ei -> i_cached_extent , 0 , sizeof ( struct ext4_ext_cache ) ) ; INIT_LIST_HEAD ( & ei -> i_prealloc_list ) ; spin_lock_init ( & ei -> i_prealloc_lock ) ; jbd2_journal_init_jbd_inode ( & ei -> jinode , & ei -> vfs_inode ) ; ei -> i_reserved_data_blocks = 0 ; ei -> i_reserved_meta_blocks = 0 ; ei -> i_allocated_meta_blocks = 0 ; ei -> i_da_metadata_calc_len = 0 ; ei -> i_delalloc_reserved_flag = 0 ; spin_lock_init ( & ( ei -> i_block_reservation_lock ) ) ; # ifdef CONFIG_QUOTA ei -> i_reserved_quota = 0 ; # endif INIT_LIST_HEAD ( & ei -> i_completed_io_list ) ;  ei -> cur_aio_dio = NULL ;  ei -> i_sync_tid = 0 ; ei -> i_datasync_tid = 0 ; return & ei -> vfs_inode ; }",spin_lock_init ( & ei -> i_completed_io_lock ) ;ei -> cur_aio_dio = NULL ;ei -> i_sync_tid = 0 ;,1399
282,"buggy line: BUG_ON ( ! thresholds ) ;usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ;cwe id:CWE-476context: static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) { struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; struct mem_cgroup_thresholds * thresholds ; struct mem_cgroup_threshold_ary * new ; int type = MEMFILE_TYPE ( cft -> private ) ; u64 usage ; int i , j , size ; mutex_lock ( & memcg -> thresholds_lock ) ; if ( type == _MEM ) thresholds = & memcg -> thresholds ; else if ( type == _MEMSWAP ) thresholds = & memcg -> memsw_thresholds ; else BUG ( ) ;  BUG_ON ( ! thresholds ) ;  usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; size = 0 ; for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) size ++ ; } new = thresholds -> spare ; if ( ! size ) { kfree ( new ) ; new = NULL ; goto swap_buffers ; } new -> size = size ; new -> current_threshold = - 1 ; for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) continue ; new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; if ( new -> entries [ j ] . threshold < usage ) { ++ new -> current_threshold ; } j ++ ; } swap_buffers : thresholds -> spare = thresholds -> primary ; rcu_assign_pointer ( thresholds -> primary , new ) ; synchronize_rcu ( ) ;  mutex_unlock ( & memcg -> thresholds_lock ) ;  }","BUG_ON ( ! thresholds ) ;if ( ! thresholds -> primary ) goto unlock ;usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ;",1400
283,"buggy line: mutex_unlock ( & memcg -> thresholds_lock ) ;}cwe id:CWE-476context: static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) { struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; struct mem_cgroup_thresholds * thresholds ; struct mem_cgroup_threshold_ary * new ; int type = MEMFILE_TYPE ( cft -> private ) ; u64 usage ; int i , j , size ; mutex_lock ( & memcg -> thresholds_lock ) ; if ( type == _MEM ) thresholds = & memcg -> thresholds ; else if ( type == _MEMSWAP ) thresholds = & memcg -> memsw_thresholds ; else BUG ( ) ;  BUG_ON ( ! thresholds ) ;  usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; size = 0 ; for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) size ++ ; } new = thresholds -> spare ; if ( ! size ) { kfree ( new ) ; new = NULL ; goto swap_buffers ; } new -> size = size ; new -> current_threshold = - 1 ; for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) continue ; new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; if ( new -> entries [ j ] . threshold < usage ) { ++ new -> current_threshold ; } j ++ ; } swap_buffers : thresholds -> spare = thresholds -> primary ; rcu_assign_pointer ( thresholds -> primary , new ) ; synchronize_rcu ( ) ;  mutex_unlock ( & memcg -> thresholds_lock ) ;  }",unlock : mutex_unlock ( & memcg -> thresholds_lock ) ;},1400
284,"buggy line: static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client ,  int id ) {handle = idr_find ( & client -> idr , id ) ;if ( handle ) ion_handle_get ( handle ) ;return handle ? handle : ERR_PTR ( - EINVAL ) ;}cwe id:CWE-264context:  static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client ,  int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ;  handle = idr_find ( & client -> idr , id ) ;  if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ;  return handle ? handle : ERR_PTR ( - EINVAL ) ;  }","struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , int id ) {handle = ion_handle_get_by_id_nolock ( client , id ) ;return handle ;}",1401
285,"buggy line: static void write_uncompressed_header ( VP9_COMP * cpi ,  struct vp9_write_bit_buffer * wb ) {VP9_COMMON * const cm = & cpi -> common ;vp9_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ;write_profile ( cm -> profile , wb ) ;vp9_wb_write_bit ( wb , 0 ) ;vp9_wb_write_bit ( wb , cm -> frame_type ) ;vp9_wb_write_bit ( wb , cm -> show_frame ) ;vp9_wb_write_bit ( wb , cm -> error_resilient_mode ) ;if ( cm -> frame_type == KEY_FRAME ) {const COLOR_SPACE cs = UNKNOWN ;write_sync_code ( wb ) ;if ( cm -> profile > PROFILE_1 ) {assert ( cm -> bit_depth > BITS_8 ) ;vp9_wb_write_bit ( wb , cm -> bit_depth - BITS_10 ) ;}vp9_wb_write_literal ( wb , cs , 3 ) ;if ( cs != SRGB ) {vp9_wb_write_bit ( wb , 0 ) ;if ( cm -> profile >= PROFILE_1 ) {vp9_wb_write_bit ( wb , cm -> subsampling_x ) ;vp9_wb_write_bit ( wb , cm -> subsampling_y ) ;vp9_wb_write_bit ( wb , 0 ) ;assert ( cm -> profile == PROFILE_1 ) ;vp9_wb_write_bit ( wb , 0 ) ;cwe id:CWE-119context: static void write_uncompressed_header ( VP9_COMP * cpi ,  struct vp9_write_bit_buffer * wb ) {  VP9_COMMON * const cm = & cpi -> common ;  vp9_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ;  write_profile ( cm -> profile , wb ) ;  vp9_wb_write_bit ( wb , 0 ) ;   vp9_wb_write_bit ( wb , cm -> frame_type ) ;   vp9_wb_write_bit ( wb , cm -> show_frame ) ;   vp9_wb_write_bit ( wb , cm -> error_resilient_mode ) ;  if ( cm -> frame_type == KEY_FRAME ) {  const COLOR_SPACE cs = UNKNOWN ;  write_sync_code ( wb ) ;  if ( cm -> profile > PROFILE_1 ) {  assert ( cm -> bit_depth > BITS_8 ) ; vp9_wb_write_bit ( wb , cm -> bit_depth - BITS_10 ) ; } vp9_wb_write_literal ( wb , cs , 3 ) ; if ( cs != SRGB ) { vp9_wb_write_bit ( wb , 0 ) ; if ( cm -> profile >= PROFILE_1 ) { vp9_wb_write_bit ( wb , cm -> subsampling_x ) ; vp9_wb_write_bit ( wb , cm -> subsampling_y ) ; vp9_wb_write_bit ( wb , 0 ) ; } } else {  assert ( cm -> profile == PROFILE_1 ) ;  vp9_wb_write_bit ( wb , 0 ) ; } write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vp9_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vp9_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm -> intra_only ) { write_sync_code ( wb ) ; vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; write_frame_size ( cm , wb ) ; } else { MV_REFERENCE_FRAME ref_frame ;  vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ;  for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) {  vp9_wb_write_literal ( wb , get_ref_frame_idx ( cpi , ref_frame ) ,  REF_FRAMES_LOG2 ) ;  vp9_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ;  } write_frame_size_with_refs ( cpi , wb ) ;  vp9_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ;   fix_interp_filter ( cm ) ;  write_interp_filter ( cm -> interp_filter , wb ) ; } } if ( ! cm -> error_resilient_mode ) {  vp9_wb_write_bit ( wb , cm -> refresh_frame_context ) ;   vp9_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ;  }  vp9_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ;  encode_loopfilter ( & cm -> lf , wb ) ; encode_quantization ( cm , wb ) ;  encode_segmentation ( cpi , wb ) ;  write_tile_info ( cm , wb ) ; }","static void write_uncompressed_header ( VP9_COMP * cpi , struct vpx_write_bit_buffer * wb ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ;vpx_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ;write_profile ( cm -> profile , wb ) ;vpx_wb_write_bit ( wb , 0 ) ;vpx_wb_write_bit ( wb , cm -> frame_type ) ;vpx_wb_write_bit ( wb , cm -> show_frame ) ;vpx_wb_write_bit ( wb , cm -> error_resilient_mode ) ;if ( cm -> frame_type == KEY_FRAME ) {write_sync_code ( wb ) ;write_bitdepth_colorspace_sampling ( cm , wb ) ;write_frame_size ( cm , wb ) ;else {if ( ! cm -> show_frame ) vpx_wb_write_bit ( wb , cm -> intra_only ) ;if ( ! cm -> error_resilient_mode ) vpx_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ;if ( cm -> intra_only ) {write_sync_code ( wb ) ;if ( cm -> profile > PROFILE_0 ) {write_bitdepth_colorspace_sampling ( cm , wb ) ;}vpx_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ;write_frame_size ( cm , wb ) ;assert ( cm -> profile == PROFILE_1 ) ;vp9_wb_write_bit ( wb , 0 ) ;",1402
286,"buggy line: vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ;for ( ref_frame = LAST_FRAME ;vp9_wb_write_literal ( wb , get_ref_frame_idx ( cpi , ref_frame ) ,  REF_FRAMES_LOG2 ) ;vp9_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ;}vp9_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ;fix_interp_filter ( cm ) ;write_interp_filter ( cm -> interp_filter , wb ) ;vp9_wb_write_bit ( wb , cm -> refresh_frame_context ) ;vp9_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ;}vp9_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ;encode_loopfilter ( & cm -> lf , wb ) ;encode_segmentation ( cpi , wb ) ;write_tile_info ( cm , wb ) ;cwe id:CWE-119context: static void write_uncompressed_header ( VP9_COMP * cpi ,  struct vp9_write_bit_buffer * wb ) {  VP9_COMMON * const cm = & cpi -> common ;  vp9_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ;  write_profile ( cm -> profile , wb ) ;  vp9_wb_write_bit ( wb , 0 ) ;   vp9_wb_write_bit ( wb , cm -> frame_type ) ;   vp9_wb_write_bit ( wb , cm -> show_frame ) ;   vp9_wb_write_bit ( wb , cm -> error_resilient_mode ) ;  if ( cm -> frame_type == KEY_FRAME ) {  const COLOR_SPACE cs = UNKNOWN ;  write_sync_code ( wb ) ;  if ( cm -> profile > PROFILE_1 ) {  assert ( cm -> bit_depth > BITS_8 ) ; vp9_wb_write_bit ( wb , cm -> bit_depth - BITS_10 ) ; } vp9_wb_write_literal ( wb , cs , 3 ) ; if ( cs != SRGB ) { vp9_wb_write_bit ( wb , 0 ) ; if ( cm -> profile >= PROFILE_1 ) { vp9_wb_write_bit ( wb , cm -> subsampling_x ) ; vp9_wb_write_bit ( wb , cm -> subsampling_y ) ; vp9_wb_write_bit ( wb , 0 ) ; } } else {  assert ( cm -> profile == PROFILE_1 ) ;  vp9_wb_write_bit ( wb , 0 ) ; } write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vp9_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vp9_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm -> intra_only ) { write_sync_code ( wb ) ; vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; write_frame_size ( cm , wb ) ; } else { MV_REFERENCE_FRAME ref_frame ;  vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ;  for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) {  vp9_wb_write_literal ( wb , get_ref_frame_idx ( cpi , ref_frame ) ,  REF_FRAMES_LOG2 ) ;  vp9_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ;  } write_frame_size_with_refs ( cpi , wb ) ;  vp9_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ;   fix_interp_filter ( cm ) ;  write_interp_filter ( cm -> interp_filter , wb ) ; } } if ( ! cm -> error_resilient_mode ) {  vp9_wb_write_bit ( wb , cm -> refresh_frame_context ) ;   vp9_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ;  }  vp9_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ;  encode_loopfilter ( & cm -> lf , wb ) ; encode_quantization ( cm , wb ) ;  encode_segmentation ( cpi , wb ) ;  write_tile_info ( cm , wb ) ; }","vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ;for ( ref_frame = LAST_FRAME ;assert ( get_ref_frame_map_idx ( cpi , ref_frame ) != INVALID_IDX ) ;vpx_wb_write_literal ( wb , get_ref_frame_map_idx ( cpi , ref_frame ) , REF_FRAMES_LOG2 ) ;vpx_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ;}vpx_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ;fix_interp_filter ( cm , cpi -> td . counts ) ;write_interp_filter ( cm -> interp_filter , wb ) ;vpx_wb_write_bit ( wb , cm -> refresh_frame_context ) ;vpx_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ;}vpx_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ;encode_loopfilter ( & cm -> lf , wb ) ;encode_segmentation ( cm , xd , wb ) ;write_tile_info ( cm , wb ) ;",1402
287,"buggy line: case 1005 : if ( strcmp ( optarg , ""north"" ) == 0 ) {im -> legendposition = NORTH ;}else if ( strcmp ( optarg , ""west"" ) == 0 ) {im -> legendposition = WEST ;}else if ( strcmp ( optarg , ""south"" ) == 0 ) {im -> legendposition = SOUTH ;}else if ( strcmp ( optarg , ""east"" ) == 0 ) {im -> legendposition = EAST ;}else {rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\\\'%s\\\'"" , optarg ) ;cwe id:CWE-134context: void rrd_graph_options ( int argc , char * argv [ ] , image_desc_t * im ) { int stroff ; char * parsetime_error = NULL ; char scan_gtm [ 12 ] , scan_mtm [ 12 ] , scan_ltm [ 12 ] , col_nam [ 12 ] ; time_t start_tmp = 0 , end_tmp = 0 ; long long_tmp ; rrd_time_value_t start_tv , end_tv ; long unsigned int color ; # define LONGOPT_UNITS_SI 255 struct option long_options [ ] = { { ""alt-autoscale"" , no_argument , 0 , 'A' } , { ""imgformat"" , required_argument , 0 , 'a' } , { ""font-smoothing-threshold"" , required_argument , 0 , 'B' } , { ""base"" , required_argument , 0 , 'b' } , { ""color"" , required_argument , 0 , 'c' } , { ""full-size-mode"" , no_argument , 0 , 'D' } , { ""daemon"" , required_argument , 0 , 'd' } , { ""slope-mode"" , no_argument , 0 , 'E' } , { ""end"" , required_argument , 0 , 'e' } , { ""force-rules-legend"" , no_argument , 0 , 'F' } , { ""imginfo"" , required_argument , 0 , 'f' } , { ""graph-render-mode"" , required_argument , 0 , 'G' } , { ""no-legend"" , no_argument , 0 , 'g' } , { ""height"" , required_argument , 0 , 'h' } , { ""no-minor"" , no_argument , 0 , 'I' } , { ""interlaced"" , no_argument , 0 , 'i' } , { ""alt-autoscale-min"" , no_argument , 0 , 'J' } , { ""only-graph"" , no_argument , 0 , 'j' } , { ""units-length"" , required_argument , 0 , 'L' } , { ""lower-limit"" , required_argument , 0 , 'l' } , { ""alt-autoscale-max"" , no_argument , 0 , 'M' } , { ""zoom"" , required_argument , 0 , 'm' } , { ""no-gridfit"" , no_argument , 0 , 'N' } , { ""font"" , required_argument , 0 , 'n' } , { ""logarithmic"" , no_argument , 0 , 'o' } , { ""pango-markup"" , no_argument , 0 , 'P' } , { ""font-render-mode"" , required_argument , 0 , 'R' } , { ""rigid"" , no_argument , 0 , 'r' } , { ""step"" , required_argument , 0 , 'S' } , { ""start"" , required_argument , 0 , 's' } , { ""tabwidth"" , required_argument , 0 , 'T' } , { ""title"" , required_argument , 0 , 't' } , { ""upper-limit"" , required_argument , 0 , 'u' } , { ""vertical-label"" , required_argument , 0 , 'v' } , { ""watermark"" , required_argument , 0 , 'W' } , { ""width"" , required_argument , 0 , 'w' } , { ""units-exponent"" , required_argument , 0 , 'X' } , { ""x-grid"" , required_argument , 0 , 'x' } , { ""alt-y-grid"" , no_argument , 0 , 'Y' } , { ""y-grid"" , required_argument , 0 , 'y' } , { ""lazy"" , no_argument , 0 , 'z' } , { ""units"" , required_argument , 0 , LONGOPT_UNITS_SI } , { ""alt-y-mrtg"" , no_argument , 0 , 1000 } , { ""disable-rrdtool-tag"" , no_argument , 0 , 1001 } , { ""right-axis"" , required_argument , 0 , 1002 } , { ""right-axis-label"" , required_argument , 0 , 1003 } , { ""right-axis-format"" , required_argument , 0 , 1004 } , { ""legend-position"" , required_argument , 0 , 1005 } , { ""legend-direction"" , required_argument , 0 , 1006 } , { ""border"" , required_argument , 0 , 1007 } , { ""grid-dash"" , required_argument , 0 , 1008 } , { ""dynamic-labels"" , no_argument , 0 , 1009 } , { ""left-axis-format"" , required_argument , 0 , 1010 } , { 0 , 0 , 0 , 0 } } ; optind = 0 ; opterr = 0 ; rrd_parsetime ( ""end-24h"" , & start_tv ) ; rrd_parsetime ( ""now"" , & end_tv ) ; while ( 1 ) { int option_index = 0 ; int opt ; int col_start , col_end ; opt = getopt_long ( argc , argv , ""Aa:B:b:c:Dd:Ee:Ff:G:gh:IiJjL:l:Mm:Nn:oPR:rS:s:T:t:u:v:W:w:X:x:Yy:z"" , long_options , & option_index ) ; if ( opt == EOF ) break ; switch ( opt ) { case 'I' : im -> extra_flags |= NOMINOR ; break ; case 'Y' : im -> extra_flags |= ALTYGRID ; break ; case 'A' : im -> extra_flags |= ALTAUTOSCALE ; break ; case 'J' : im -> extra_flags |= ALTAUTOSCALE_MIN ; break ; case 'M' : im -> extra_flags |= ALTAUTOSCALE_MAX ; break ; case 'j' : im -> extra_flags |= ONLY_GRAPH ; break ; case 'g' : im -> extra_flags |= NOLEGEND ; break ; case 1005 : if ( strcmp ( optarg , ""north"" ) == 0 ) { im -> legendposition = NORTH ; } else if ( strcmp ( optarg , ""west"" ) == 0 ) { im -> legendposition = WEST ; } else if ( strcmp ( optarg , ""south"" ) == 0 ) { im -> legendposition = SOUTH ; } else if ( strcmp ( optarg , ""east"" ) == 0 ) { im -> legendposition = EAST ; } else { rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 1006 : if ( strcmp ( optarg , ""topdown"" ) == 0 ) { im -> legenddirection = TOP_DOWN ; } else if ( strcmp ( optarg , ""bottomup"" ) == 0 ) { im -> legenddirection = BOTTOM_UP ; } else { rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'F' : im -> extra_flags |= FORCE_RULES_LEGEND ; break ; case 1001 : im -> extra_flags |= NO_RRDTOOL_TAG ; break ; case LONGOPT_UNITS_SI : if ( im -> extra_flags & FORCE_UNITS ) { rrd_set_error ( ""--units<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>used<S2SV_blank>once!"" ) ; return ; } if ( strcmp ( optarg , ""si"" ) == 0 ) im -> extra_flags |= FORCE_UNITS_SI ; else { rrd_set_error ( ""invalid<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>--units:<S2SV_blank>%s"" , optarg ) ; return ; } break ; case 'X' : im -> unitsexponent = atoi ( optarg ) ; break ; case 'L' : im -> unitslength = atoi ( optarg ) ; im -> forceleftspace = 1 ; break ; case 'T' : im -> tabwidth = atof ( optarg ) ; break ; case 'S' : im -> step = atoi ( optarg ) ; break ; case 'N' : im -> gridfit = 0 ; break ; case 'P' : im -> with_markup = 1 ; break ; case 's' : if ( ( parsetime_error = rrd_parsetime ( optarg , & start_tv ) ) ) { rrd_set_error ( ""start<S2SV_blank>time:<S2SV_blank>%s"" , parsetime_error ) ; return ; } break ; case 'e' : if ( ( parsetime_error = rrd_parsetime ( optarg , & end_tv ) ) ) { rrd_set_error ( ""end<S2SV_blank>time:<S2SV_blank>%s"" , parsetime_error ) ; return ; } break ; case 'x' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_x_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%10[A-Z]:%ld:%10[A-Z]:%ld:%10[A-Z]:%ld:%ld:%n"" , scan_gtm , & im -> xlab_user . gridst , scan_mtm , & im -> xlab_user . mgridst , scan_ltm , & im -> xlab_user . labst , & im -> xlab_user . precis , & stroff ) == 7 && stroff != 0 ) { strncpy ( im -> xlab_form , optarg + stroff , sizeof ( im -> xlab_form ) - 1 ) ; im -> xlab_form [ sizeof ( im -> xlab_form ) - 1 ] = '\\0' ; if ( ( int ) ( im -> xlab_user . gridtm = tmt_conv ( scan_gtm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_gtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . mgridtm = tmt_conv ( scan_mtm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_mtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . labtm = tmt_conv ( scan_ltm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_ltm ) ; return ; } im -> xlab_user . minsec = 1 ; im -> xlab_user . stst = im -> xlab_form ; } else { rrd_set_error ( ""invalid<S2SV_blank>x-grid<S2SV_blank>format"" ) ; return ; } break ; case 'y' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_y_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%lf:%d"" , & im -> ygridstep , & im -> ylabfact ) == 2 ) { if ( im -> ygridstep <= 0 ) { rrd_set_error ( ""grid<S2SV_blank>step<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } else if ( im -> ylabfact < 1 ) { rrd_set_error ( ""label<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>y-grid<S2SV_blank>format"" ) ; return ; } break ; case 1007 : im -> draw_3d_border = atoi ( optarg ) ; break ; case 1008 : if ( sscanf ( optarg , ""%lf:%lf"" , & im -> grid_dash_on , & im -> grid_dash_off ) != 2 ) { rrd_set_error ( ""expected<S2SV_blank>grid-dash<S2SV_blank>format<S2SV_blank>float:float"" ) ; return ; } break ; case 1009 : im -> dynamic_labels = 1 ; break ; case 1002 : if ( sscanf ( optarg , ""%lf:%lf"" , & im -> second_axis_scale , & im -> second_axis_shift ) == 2 ) { if ( im -> second_axis_scale == 0 ) { rrd_set_error ( ""the<S2SV_blank>second_axis_scale<S2SV_blank><S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0"" ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>right-axis<S2SV_blank>format<S2SV_blank>expected<S2SV_blank>scale:shift"" ) ; return ; } break ; case 1003 : strncpy ( im -> second_axis_legend , optarg , 150 ) ; im -> second_axis_legend [ 150 ] = '\\0' ; break ; case 1004 :  if ( bad_format ( optarg ) ) {  rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ; return ; } strncpy ( im -> second_axis_format , optarg , 150 ) ; im -> second_axis_format [ 150 ] = '\\0' ; break ; case 1010 :  if ( bad_format ( optarg ) ) {  rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ; return ; } strncpy ( im -> primary_axis_format , optarg , 150 ) ; im -> primary_axis_format [ 150 ] = '\\0' ; break ; case 'v' : strncpy ( im -> ylegend , optarg , 150 ) ; im -> ylegend [ 150 ] = '\\0' ; break ; case 'u' : im -> maxval = atof ( optarg ) ; break ; case 'l' : im -> minval = atof ( optarg ) ; break ; case 'b' : im -> base = atol ( optarg ) ; if ( im -> base != 1024 && im -> base != 1000 ) { rrd_set_error ( ""the<S2SV_blank>only<S2SV_blank>sensible<S2SV_blank>value<S2SV_blank>for<S2SV_blank>base<S2SV_blank>apart<S2SV_blank>from<S2SV_blank>1000<S2SV_blank>is<S2SV_blank>1024"" ) ; return ; } break ; case 'w' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""width<S2SV_blank>below<S2SV_blank>10<S2SV_blank>pixels"" ) ; return ; } im -> xsize = long_tmp ; break ; case 'h' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""height<S2SV_blank>below<S2SV_blank>10<S2SV_blank>pixels"" ) ; return ; } im -> ysize = long_tmp ; break ; case 'D' : im -> extra_flags |= FULL_SIZE_MODE ; break ; case 'i' : break ; case 'r' : im -> rigid = 1 ; break ; case 'f' : im -> imginfo = optarg ; break ; case 'a' : if ( ( int ) ( im -> imgformat = if_conv ( optarg ) ) == - 1 ) { rrd_set_error ( ""unsupported<S2SV_blank>graphics<S2SV_blank>format<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'z' : im -> lazy = 1 ; break ; case 'E' : im -> slopemode = 1 ; break ; case 'o' : im -> logarithmic = 1 ; break ; case 'c' : if ( sscanf ( optarg , ""%10[A-Z]#%n%8lx%n"" , col_nam , & col_start , & color , & col_end ) == 2 ) { int ci ; int col_len = col_end - col_start ; switch ( col_len ) { case 3 : color = ( ( ( color & 0xF00 ) * 0x110000 ) | ( ( color & 0x0F0 ) * 0x011000 ) | ( ( color & 0x00F ) * 0x001100 ) | 0x000000FF ) ; break ; case 4 : color = ( ( ( color & 0xF000 ) * 0x11000 ) | ( ( color & 0x0F00 ) * 0x01100 ) | ( ( color & 0x00F0 ) * 0x00110 ) | ( ( color & 0x000F ) * 0x00011 ) ) ; break ; case 6 : color = ( color << 8 ) + 0xff ; break ; case 8 : break ; default : rrd_set_error ( ""the<S2SV_blank>color<S2SV_blank>format<S2SV_blank>is<S2SV_blank>#RRGGBB[AA]"" ) ; return ; } if ( ( ci = grc_conv ( col_nam ) ) != - 1 ) { im -> graph_col [ ci ] = gfx_hex_to_col ( color ) ; } else { rrd_set_error ( ""invalid<S2SV_blank>color<S2SV_blank>name<S2SV_blank>\'%s\'"" , col_nam ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>color<S2SV_blank>def<S2SV_blank>format"" ) ; return ; } break ; case 'n' : { char prop [ 15 ] ; double size = 1 ; int end ; if ( sscanf ( optarg , ""%10[A-Z]:%lf%n"" , prop , & size , & end ) >= 2 ) { int sindex , propidx ; if ( ( sindex = text_prop_conv ( prop ) ) != - 1 ) { for ( propidx = sindex ; propidx < TEXT_PROP_LAST ; propidx ++ ) { if ( size > 0 ) { rrd_set_font_desc ( im , propidx , NULL , size ) ; } if ( ( int ) strlen ( optarg ) > end + 2 ) { if ( optarg [ end ] == ':' ) { rrd_set_font_desc ( im , propidx , optarg + end + 1 , 0 ) ; } else { rrd_set_error ( ""expected<S2SV_blank>:<S2SV_blank>after<S2SV_blank>font<S2SV_blank>size<S2SV_blank>in<S2SV_blank>\'%s\'"" , optarg ) ; return ; } } if ( propidx == sindex && sindex != 0 ) break ; } } else { rrd_set_error ( ""invalid<S2SV_blank>fonttag<S2SV_blank>\'%s\'"" , prop ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>text<S2SV_blank>property<S2SV_blank>format"" ) ; return ; } break ; } case 'm' : im -> zoom = atof ( optarg ) ; if ( im -> zoom <= 0.0 ) { rrd_set_error ( ""zoom<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } break ; case 't' : strncpy ( im -> title , optarg , 150 ) ; im -> title [ 150 ] = '\\0' ; break ; case 'R' : if ( strcmp ( optarg , ""normal"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else if ( strcmp ( optarg , ""light"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_SLIGHT ) ; } else if ( strcmp ( optarg , ""mono"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_NONE ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else { rrd_set_error ( ""unknown<S2SV_blank>font-render-mode<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'G' : if ( strcmp ( optarg , ""normal"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_GRAY ; else if ( strcmp ( optarg , ""mono"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_NONE ; else { rrd_set_error ( ""unknown<S2SV_blank>graph-render-mode<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'B' : break ; case 'W' : strncpy ( im -> watermark , optarg , 100 ) ; im -> watermark [ 99 ] = '\\0' ; break ; case 'd' : { if ( im -> daemon_addr != NULL ) { rrd_set_error ( ""You<S2SV_blank>cannot<S2SV_blank>specify<S2SV_blank>--daemon<S2SV_blank>"" ""more<S2SV_blank>than<S2SV_blank>once."" ) ; return ; } im -> daemon_addr = strdup ( optarg ) ; if ( im -> daemon_addr == NULL ) { rrd_set_error ( ""strdup<S2SV_blank>failed"" ) ; return ; } break ; } case '?' : if ( optopt != 0 ) rrd_set_error ( ""unknown<S2SV_blank>option<S2SV_blank>\'%c\'"" , optopt ) ; else rrd_set_error ( ""unknown<S2SV_blank>option<S2SV_blank>\'%s\'"" , argv [ optind - 1 ] ) ; return ; } } { int status = rrdc_connect ( im -> daemon_addr ) ; if ( status != 0 ) return ; } pango_cairo_context_set_font_options ( pango_layout_get_context ( im -> layout ) , im -> font_options ) ; pango_layout_context_changed ( im -> layout ) ; if ( im -> logarithmic && im -> minval <= 0 ) { rrd_set_error ( ""for<S2SV_blank>a<S2SV_blank>logarithmic<S2SV_blank>yaxis<S2SV_blank>you<S2SV_blank>must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>lower-limit<S2SV_blank>><S2SV_blank>0"" ) ; return ; } if ( rrd_proc_start_end ( & start_tv , & end_tv , & start_tmp , & end_tmp ) == - 1 ) { return ; } if ( start_tmp < 3600 * 24 * 365 * 10 ) { rrd_set_error ( ""the<S2SV_blank>first<S2SV_blank>entry<S2SV_blank>to<S2SV_blank>fetch<S2SV_blank>should<S2SV_blank>be<S2SV_blank>after<S2SV_blank>1980<S2SV_blank>(%ld)"" , start_tmp ) ; return ; } if ( end_tmp < start_tmp ) { rrd_set_error ( ""start<S2SV_blank>(%ld)<S2SV_blank>should<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>end<S2SV_blank>(%ld)"" , start_tmp , end_tmp ) ; return ; } im -> start = start_tmp ; im -> end = end_tmp ; im -> step = max ( ( long ) im -> step , ( im -> end - im -> start ) / im -> xsize ) ; }",case 1005 : if ( bad_format_axis ( optarg ) ) {,1403
288,"buggy line: case LONGOPT_UNITS_SI : if ( im -> extra_flags & FORCE_UNITS ) {rrd_set_error ( ""--units<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>used<S2SV_blank>once!"" ) ;cwe id:CWE-134context: void rrd_graph_options ( int argc , char * argv [ ] , image_desc_t * im ) { int stroff ; char * parsetime_error = NULL ; char scan_gtm [ 12 ] , scan_mtm [ 12 ] , scan_ltm [ 12 ] , col_nam [ 12 ] ; time_t start_tmp = 0 , end_tmp = 0 ; long long_tmp ; rrd_time_value_t start_tv , end_tv ; long unsigned int color ; # define LONGOPT_UNITS_SI 255 struct option long_options [ ] = { { ""alt-autoscale"" , no_argument , 0 , 'A' } , { ""imgformat"" , required_argument , 0 , 'a' } , { ""font-smoothing-threshold"" , required_argument , 0 , 'B' } , { ""base"" , required_argument , 0 , 'b' } , { ""color"" , required_argument , 0 , 'c' } , { ""full-size-mode"" , no_argument , 0 , 'D' } , { ""daemon"" , required_argument , 0 , 'd' } , { ""slope-mode"" , no_argument , 0 , 'E' } , { ""end"" , required_argument , 0 , 'e' } , { ""force-rules-legend"" , no_argument , 0 , 'F' } , { ""imginfo"" , required_argument , 0 , 'f' } , { ""graph-render-mode"" , required_argument , 0 , 'G' } , { ""no-legend"" , no_argument , 0 , 'g' } , { ""height"" , required_argument , 0 , 'h' } , { ""no-minor"" , no_argument , 0 , 'I' } , { ""interlaced"" , no_argument , 0 , 'i' } , { ""alt-autoscale-min"" , no_argument , 0 , 'J' } , { ""only-graph"" , no_argument , 0 , 'j' } , { ""units-length"" , required_argument , 0 , 'L' } , { ""lower-limit"" , required_argument , 0 , 'l' } , { ""alt-autoscale-max"" , no_argument , 0 , 'M' } , { ""zoom"" , required_argument , 0 , 'm' } , { ""no-gridfit"" , no_argument , 0 , 'N' } , { ""font"" , required_argument , 0 , 'n' } , { ""logarithmic"" , no_argument , 0 , 'o' } , { ""pango-markup"" , no_argument , 0 , 'P' } , { ""font-render-mode"" , required_argument , 0 , 'R' } , { ""rigid"" , no_argument , 0 , 'r' } , { ""step"" , required_argument , 0 , 'S' } , { ""start"" , required_argument , 0 , 's' } , { ""tabwidth"" , required_argument , 0 , 'T' } , { ""title"" , required_argument , 0 , 't' } , { ""upper-limit"" , required_argument , 0 , 'u' } , { ""vertical-label"" , required_argument , 0 , 'v' } , { ""watermark"" , required_argument , 0 , 'W' } , { ""width"" , required_argument , 0 , 'w' } , { ""units-exponent"" , required_argument , 0 , 'X' } , { ""x-grid"" , required_argument , 0 , 'x' } , { ""alt-y-grid"" , no_argument , 0 , 'Y' } , { ""y-grid"" , required_argument , 0 , 'y' } , { ""lazy"" , no_argument , 0 , 'z' } , { ""units"" , required_argument , 0 , LONGOPT_UNITS_SI } , { ""alt-y-mrtg"" , no_argument , 0 , 1000 } , { ""disable-rrdtool-tag"" , no_argument , 0 , 1001 } , { ""right-axis"" , required_argument , 0 , 1002 } , { ""right-axis-label"" , required_argument , 0 , 1003 } , { ""right-axis-format"" , required_argument , 0 , 1004 } , { ""legend-position"" , required_argument , 0 , 1005 } , { ""legend-direction"" , required_argument , 0 , 1006 } , { ""border"" , required_argument , 0 , 1007 } , { ""grid-dash"" , required_argument , 0 , 1008 } , { ""dynamic-labels"" , no_argument , 0 , 1009 } , { ""left-axis-format"" , required_argument , 0 , 1010 } , { 0 , 0 , 0 , 0 } } ; optind = 0 ; opterr = 0 ; rrd_parsetime ( ""end-24h"" , & start_tv ) ; rrd_parsetime ( ""now"" , & end_tv ) ; while ( 1 ) { int option_index = 0 ; int opt ; int col_start , col_end ; opt = getopt_long ( argc , argv , ""Aa:B:b:c:Dd:Ee:Ff:G:gh:IiJjL:l:Mm:Nn:oPR:rS:s:T:t:u:v:W:w:X:x:Yy:z"" , long_options , & option_index ) ; if ( opt == EOF ) break ; switch ( opt ) { case 'I' : im -> extra_flags |= NOMINOR ; break ; case 'Y' : im -> extra_flags |= ALTYGRID ; break ; case 'A' : im -> extra_flags |= ALTAUTOSCALE ; break ; case 'J' : im -> extra_flags |= ALTAUTOSCALE_MIN ; break ; case 'M' : im -> extra_flags |= ALTAUTOSCALE_MAX ; break ; case 'j' : im -> extra_flags |= ONLY_GRAPH ; break ; case 'g' : im -> extra_flags |= NOLEGEND ; break ; case 1005 : if ( strcmp ( optarg , ""north"" ) == 0 ) { im -> legendposition = NORTH ; } else if ( strcmp ( optarg , ""west"" ) == 0 ) { im -> legendposition = WEST ; } else if ( strcmp ( optarg , ""south"" ) == 0 ) { im -> legendposition = SOUTH ; } else if ( strcmp ( optarg , ""east"" ) == 0 ) { im -> legendposition = EAST ; } else { rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 1006 : if ( strcmp ( optarg , ""topdown"" ) == 0 ) { im -> legenddirection = TOP_DOWN ; } else if ( strcmp ( optarg , ""bottomup"" ) == 0 ) { im -> legenddirection = BOTTOM_UP ; } else { rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'F' : im -> extra_flags |= FORCE_RULES_LEGEND ; break ; case 1001 : im -> extra_flags |= NO_RRDTOOL_TAG ; break ; case LONGOPT_UNITS_SI : if ( im -> extra_flags & FORCE_UNITS ) { rrd_set_error ( ""--units<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>used<S2SV_blank>once!"" ) ; return ; } if ( strcmp ( optarg , ""si"" ) == 0 ) im -> extra_flags |= FORCE_UNITS_SI ; else { rrd_set_error ( ""invalid<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>--units:<S2SV_blank>%s"" , optarg ) ; return ; } break ; case 'X' : im -> unitsexponent = atoi ( optarg ) ; break ; case 'L' : im -> unitslength = atoi ( optarg ) ; im -> forceleftspace = 1 ; break ; case 'T' : im -> tabwidth = atof ( optarg ) ; break ; case 'S' : im -> step = atoi ( optarg ) ; break ; case 'N' : im -> gridfit = 0 ; break ; case 'P' : im -> with_markup = 1 ; break ; case 's' : if ( ( parsetime_error = rrd_parsetime ( optarg , & start_tv ) ) ) { rrd_set_error ( ""start<S2SV_blank>time:<S2SV_blank>%s"" , parsetime_error ) ; return ; } break ; case 'e' : if ( ( parsetime_error = rrd_parsetime ( optarg , & end_tv ) ) ) { rrd_set_error ( ""end<S2SV_blank>time:<S2SV_blank>%s"" , parsetime_error ) ; return ; } break ; case 'x' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_x_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%10[A-Z]:%ld:%10[A-Z]:%ld:%10[A-Z]:%ld:%ld:%n"" , scan_gtm , & im -> xlab_user . gridst , scan_mtm , & im -> xlab_user . mgridst , scan_ltm , & im -> xlab_user . labst , & im -> xlab_user . precis , & stroff ) == 7 && stroff != 0 ) { strncpy ( im -> xlab_form , optarg + stroff , sizeof ( im -> xlab_form ) - 1 ) ; im -> xlab_form [ sizeof ( im -> xlab_form ) - 1 ] = '\\0' ; if ( ( int ) ( im -> xlab_user . gridtm = tmt_conv ( scan_gtm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_gtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . mgridtm = tmt_conv ( scan_mtm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_mtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . labtm = tmt_conv ( scan_ltm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_ltm ) ; return ; } im -> xlab_user . minsec = 1 ; im -> xlab_user . stst = im -> xlab_form ; } else { rrd_set_error ( ""invalid<S2SV_blank>x-grid<S2SV_blank>format"" ) ; return ; } break ; case 'y' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_y_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%lf:%d"" , & im -> ygridstep , & im -> ylabfact ) == 2 ) { if ( im -> ygridstep <= 0 ) { rrd_set_error ( ""grid<S2SV_blank>step<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } else if ( im -> ylabfact < 1 ) { rrd_set_error ( ""label<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>y-grid<S2SV_blank>format"" ) ; return ; } break ; case 1007 : im -> draw_3d_border = atoi ( optarg ) ; break ; case 1008 : if ( sscanf ( optarg , ""%lf:%lf"" , & im -> grid_dash_on , & im -> grid_dash_off ) != 2 ) { rrd_set_error ( ""expected<S2SV_blank>grid-dash<S2SV_blank>format<S2SV_blank>float:float"" ) ; return ; } break ; case 1009 : im -> dynamic_labels = 1 ; break ; case 1002 : if ( sscanf ( optarg , ""%lf:%lf"" , & im -> second_axis_scale , & im -> second_axis_shift ) == 2 ) { if ( im -> second_axis_scale == 0 ) { rrd_set_error ( ""the<S2SV_blank>second_axis_scale<S2SV_blank><S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0"" ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>right-axis<S2SV_blank>format<S2SV_blank>expected<S2SV_blank>scale:shift"" ) ; return ; } break ; case 1003 : strncpy ( im -> second_axis_legend , optarg , 150 ) ; im -> second_axis_legend [ 150 ] = '\\0' ; break ; case 1004 :  if ( bad_format ( optarg ) ) {  rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ; return ; } strncpy ( im -> second_axis_format , optarg , 150 ) ; im -> second_axis_format [ 150 ] = '\\0' ; break ; case 1010 :  if ( bad_format ( optarg ) ) {  rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ; return ; } strncpy ( im -> primary_axis_format , optarg , 150 ) ; im -> primary_axis_format [ 150 ] = '\\0' ; break ; case 'v' : strncpy ( im -> ylegend , optarg , 150 ) ; im -> ylegend [ 150 ] = '\\0' ; break ; case 'u' : im -> maxval = atof ( optarg ) ; break ; case 'l' : im -> minval = atof ( optarg ) ; break ; case 'b' : im -> base = atol ( optarg ) ; if ( im -> base != 1024 && im -> base != 1000 ) { rrd_set_error ( ""the<S2SV_blank>only<S2SV_blank>sensible<S2SV_blank>value<S2SV_blank>for<S2SV_blank>base<S2SV_blank>apart<S2SV_blank>from<S2SV_blank>1000<S2SV_blank>is<S2SV_blank>1024"" ) ; return ; } break ; case 'w' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""width<S2SV_blank>below<S2SV_blank>10<S2SV_blank>pixels"" ) ; return ; } im -> xsize = long_tmp ; break ; case 'h' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""height<S2SV_blank>below<S2SV_blank>10<S2SV_blank>pixels"" ) ; return ; } im -> ysize = long_tmp ; break ; case 'D' : im -> extra_flags |= FULL_SIZE_MODE ; break ; case 'i' : break ; case 'r' : im -> rigid = 1 ; break ; case 'f' : im -> imginfo = optarg ; break ; case 'a' : if ( ( int ) ( im -> imgformat = if_conv ( optarg ) ) == - 1 ) { rrd_set_error ( ""unsupported<S2SV_blank>graphics<S2SV_blank>format<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'z' : im -> lazy = 1 ; break ; case 'E' : im -> slopemode = 1 ; break ; case 'o' : im -> logarithmic = 1 ; break ; case 'c' : if ( sscanf ( optarg , ""%10[A-Z]#%n%8lx%n"" , col_nam , & col_start , & color , & col_end ) == 2 ) { int ci ; int col_len = col_end - col_start ; switch ( col_len ) { case 3 : color = ( ( ( color & 0xF00 ) * 0x110000 ) | ( ( color & 0x0F0 ) * 0x011000 ) | ( ( color & 0x00F ) * 0x001100 ) | 0x000000FF ) ; break ; case 4 : color = ( ( ( color & 0xF000 ) * 0x11000 ) | ( ( color & 0x0F00 ) * 0x01100 ) | ( ( color & 0x00F0 ) * 0x00110 ) | ( ( color & 0x000F ) * 0x00011 ) ) ; break ; case 6 : color = ( color << 8 ) + 0xff ; break ; case 8 : break ; default : rrd_set_error ( ""the<S2SV_blank>color<S2SV_blank>format<S2SV_blank>is<S2SV_blank>#RRGGBB[AA]"" ) ; return ; } if ( ( ci = grc_conv ( col_nam ) ) != - 1 ) { im -> graph_col [ ci ] = gfx_hex_to_col ( color ) ; } else { rrd_set_error ( ""invalid<S2SV_blank>color<S2SV_blank>name<S2SV_blank>\'%s\'"" , col_nam ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>color<S2SV_blank>def<S2SV_blank>format"" ) ; return ; } break ; case 'n' : { char prop [ 15 ] ; double size = 1 ; int end ; if ( sscanf ( optarg , ""%10[A-Z]:%lf%n"" , prop , & size , & end ) >= 2 ) { int sindex , propidx ; if ( ( sindex = text_prop_conv ( prop ) ) != - 1 ) { for ( propidx = sindex ; propidx < TEXT_PROP_LAST ; propidx ++ ) { if ( size > 0 ) { rrd_set_font_desc ( im , propidx , NULL , size ) ; } if ( ( int ) strlen ( optarg ) > end + 2 ) { if ( optarg [ end ] == ':' ) { rrd_set_font_desc ( im , propidx , optarg + end + 1 , 0 ) ; } else { rrd_set_error ( ""expected<S2SV_blank>:<S2SV_blank>after<S2SV_blank>font<S2SV_blank>size<S2SV_blank>in<S2SV_blank>\'%s\'"" , optarg ) ; return ; } } if ( propidx == sindex && sindex != 0 ) break ; } } else { rrd_set_error ( ""invalid<S2SV_blank>fonttag<S2SV_blank>\'%s\'"" , prop ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>text<S2SV_blank>property<S2SV_blank>format"" ) ; return ; } break ; } case 'm' : im -> zoom = atof ( optarg ) ; if ( im -> zoom <= 0.0 ) { rrd_set_error ( ""zoom<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } break ; case 't' : strncpy ( im -> title , optarg , 150 ) ; im -> title [ 150 ] = '\\0' ; break ; case 'R' : if ( strcmp ( optarg , ""normal"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else if ( strcmp ( optarg , ""light"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_SLIGHT ) ; } else if ( strcmp ( optarg , ""mono"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_NONE ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else { rrd_set_error ( ""unknown<S2SV_blank>font-render-mode<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'G' : if ( strcmp ( optarg , ""normal"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_GRAY ; else if ( strcmp ( optarg , ""mono"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_NONE ; else { rrd_set_error ( ""unknown<S2SV_blank>graph-render-mode<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'B' : break ; case 'W' : strncpy ( im -> watermark , optarg , 100 ) ; im -> watermark [ 99 ] = '\\0' ; break ; case 'd' : { if ( im -> daemon_addr != NULL ) { rrd_set_error ( ""You<S2SV_blank>cannot<S2SV_blank>specify<S2SV_blank>--daemon<S2SV_blank>"" ""more<S2SV_blank>than<S2SV_blank>once."" ) ; return ; } im -> daemon_addr = strdup ( optarg ) ; if ( im -> daemon_addr == NULL ) { rrd_set_error ( ""strdup<S2SV_blank>failed"" ) ; return ; } break ; } case '?' : if ( optopt != 0 ) rrd_set_error ( ""unknown<S2SV_blank>option<S2SV_blank>\'%c\'"" , optopt ) ; else rrd_set_error ( ""unknown<S2SV_blank>option<S2SV_blank>\'%s\'"" , argv [ optind - 1 ] ) ; return ; } } { int status = rrdc_connect ( im -> daemon_addr ) ; if ( status != 0 ) return ; } pango_cairo_context_set_font_options ( pango_layout_get_context ( im -> layout ) , im -> font_options ) ; pango_layout_context_changed ( im -> layout ) ; if ( im -> logarithmic && im -> minval <= 0 ) { rrd_set_error ( ""for<S2SV_blank>a<S2SV_blank>logarithmic<S2SV_blank>yaxis<S2SV_blank>you<S2SV_blank>must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>lower-limit<S2SV_blank>><S2SV_blank>0"" ) ; return ; } if ( rrd_proc_start_end ( & start_tv , & end_tv , & start_tmp , & end_tmp ) == - 1 ) { return ; } if ( start_tmp < 3600 * 24 * 365 * 10 ) { rrd_set_error ( ""the<S2SV_blank>first<S2SV_blank>entry<S2SV_blank>to<S2SV_blank>fetch<S2SV_blank>should<S2SV_blank>be<S2SV_blank>after<S2SV_blank>1980<S2SV_blank>(%ld)"" , start_tmp ) ; return ; } if ( end_tmp < start_tmp ) { rrd_set_error ( ""start<S2SV_blank>(%ld)<S2SV_blank>should<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>end<S2SV_blank>(%ld)"" , start_tmp , end_tmp ) ; return ; } im -> start = start_tmp ; im -> end = end_tmp ; im -> step = max ( ( long ) im -> step , ( im -> end - im -> start ) / im -> xsize ) ; }",case LONGOPT_UNITS_SI : if ( bad_format_axis ( optarg ) ) {,1403
289,"buggy line: case 1004 :  if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;case 1010 :  if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;cwe id:CWE-134context: void rrd_graph_options ( int argc , char * argv [ ] , image_desc_t * im ) { int stroff ; char * parsetime_error = NULL ; char scan_gtm [ 12 ] , scan_mtm [ 12 ] , scan_ltm [ 12 ] , col_nam [ 12 ] ; time_t start_tmp = 0 , end_tmp = 0 ; long long_tmp ; rrd_time_value_t start_tv , end_tv ; long unsigned int color ; # define LONGOPT_UNITS_SI 255 struct option long_options [ ] = { { ""alt-autoscale"" , no_argument , 0 , 'A' } , { ""imgformat"" , required_argument , 0 , 'a' } , { ""font-smoothing-threshold"" , required_argument , 0 , 'B' } , { ""base"" , required_argument , 0 , 'b' } , { ""color"" , required_argument , 0 , 'c' } , { ""full-size-mode"" , no_argument , 0 , 'D' } , { ""daemon"" , required_argument , 0 , 'd' } , { ""slope-mode"" , no_argument , 0 , 'E' } , { ""end"" , required_argument , 0 , 'e' } , { ""force-rules-legend"" , no_argument , 0 , 'F' } , { ""imginfo"" , required_argument , 0 , 'f' } , { ""graph-render-mode"" , required_argument , 0 , 'G' } , { ""no-legend"" , no_argument , 0 , 'g' } , { ""height"" , required_argument , 0 , 'h' } , { ""no-minor"" , no_argument , 0 , 'I' } , { ""interlaced"" , no_argument , 0 , 'i' } , { ""alt-autoscale-min"" , no_argument , 0 , 'J' } , { ""only-graph"" , no_argument , 0 , 'j' } , { ""units-length"" , required_argument , 0 , 'L' } , { ""lower-limit"" , required_argument , 0 , 'l' } , { ""alt-autoscale-max"" , no_argument , 0 , 'M' } , { ""zoom"" , required_argument , 0 , 'm' } , { ""no-gridfit"" , no_argument , 0 , 'N' } , { ""font"" , required_argument , 0 , 'n' } , { ""logarithmic"" , no_argument , 0 , 'o' } , { ""pango-markup"" , no_argument , 0 , 'P' } , { ""font-render-mode"" , required_argument , 0 , 'R' } , { ""rigid"" , no_argument , 0 , 'r' } , { ""step"" , required_argument , 0 , 'S' } , { ""start"" , required_argument , 0 , 's' } , { ""tabwidth"" , required_argument , 0 , 'T' } , { ""title"" , required_argument , 0 , 't' } , { ""upper-limit"" , required_argument , 0 , 'u' } , { ""vertical-label"" , required_argument , 0 , 'v' } , { ""watermark"" , required_argument , 0 , 'W' } , { ""width"" , required_argument , 0 , 'w' } , { ""units-exponent"" , required_argument , 0 , 'X' } , { ""x-grid"" , required_argument , 0 , 'x' } , { ""alt-y-grid"" , no_argument , 0 , 'Y' } , { ""y-grid"" , required_argument , 0 , 'y' } , { ""lazy"" , no_argument , 0 , 'z' } , { ""units"" , required_argument , 0 , LONGOPT_UNITS_SI } , { ""alt-y-mrtg"" , no_argument , 0 , 1000 } , { ""disable-rrdtool-tag"" , no_argument , 0 , 1001 } , { ""right-axis"" , required_argument , 0 , 1002 } , { ""right-axis-label"" , required_argument , 0 , 1003 } , { ""right-axis-format"" , required_argument , 0 , 1004 } , { ""legend-position"" , required_argument , 0 , 1005 } , { ""legend-direction"" , required_argument , 0 , 1006 } , { ""border"" , required_argument , 0 , 1007 } , { ""grid-dash"" , required_argument , 0 , 1008 } , { ""dynamic-labels"" , no_argument , 0 , 1009 } , { ""left-axis-format"" , required_argument , 0 , 1010 } , { 0 , 0 , 0 , 0 } } ; optind = 0 ; opterr = 0 ; rrd_parsetime ( ""end-24h"" , & start_tv ) ; rrd_parsetime ( ""now"" , & end_tv ) ; while ( 1 ) { int option_index = 0 ; int opt ; int col_start , col_end ; opt = getopt_long ( argc , argv , ""Aa:B:b:c:Dd:Ee:Ff:G:gh:IiJjL:l:Mm:Nn:oPR:rS:s:T:t:u:v:W:w:X:x:Yy:z"" , long_options , & option_index ) ; if ( opt == EOF ) break ; switch ( opt ) { case 'I' : im -> extra_flags |= NOMINOR ; break ; case 'Y' : im -> extra_flags |= ALTYGRID ; break ; case 'A' : im -> extra_flags |= ALTAUTOSCALE ; break ; case 'J' : im -> extra_flags |= ALTAUTOSCALE_MIN ; break ; case 'M' : im -> extra_flags |= ALTAUTOSCALE_MAX ; break ; case 'j' : im -> extra_flags |= ONLY_GRAPH ; break ; case 'g' : im -> extra_flags |= NOLEGEND ; break ; case 1005 : if ( strcmp ( optarg , ""north"" ) == 0 ) { im -> legendposition = NORTH ; } else if ( strcmp ( optarg , ""west"" ) == 0 ) { im -> legendposition = WEST ; } else if ( strcmp ( optarg , ""south"" ) == 0 ) { im -> legendposition = SOUTH ; } else if ( strcmp ( optarg , ""east"" ) == 0 ) { im -> legendposition = EAST ; } else { rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 1006 : if ( strcmp ( optarg , ""topdown"" ) == 0 ) { im -> legenddirection = TOP_DOWN ; } else if ( strcmp ( optarg , ""bottomup"" ) == 0 ) { im -> legenddirection = BOTTOM_UP ; } else { rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'F' : im -> extra_flags |= FORCE_RULES_LEGEND ; break ; case 1001 : im -> extra_flags |= NO_RRDTOOL_TAG ; break ; case LONGOPT_UNITS_SI : if ( im -> extra_flags & FORCE_UNITS ) { rrd_set_error ( ""--units<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>used<S2SV_blank>once!"" ) ; return ; } if ( strcmp ( optarg , ""si"" ) == 0 ) im -> extra_flags |= FORCE_UNITS_SI ; else { rrd_set_error ( ""invalid<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>--units:<S2SV_blank>%s"" , optarg ) ; return ; } break ; case 'X' : im -> unitsexponent = atoi ( optarg ) ; break ; case 'L' : im -> unitslength = atoi ( optarg ) ; im -> forceleftspace = 1 ; break ; case 'T' : im -> tabwidth = atof ( optarg ) ; break ; case 'S' : im -> step = atoi ( optarg ) ; break ; case 'N' : im -> gridfit = 0 ; break ; case 'P' : im -> with_markup = 1 ; break ; case 's' : if ( ( parsetime_error = rrd_parsetime ( optarg , & start_tv ) ) ) { rrd_set_error ( ""start<S2SV_blank>time:<S2SV_blank>%s"" , parsetime_error ) ; return ; } break ; case 'e' : if ( ( parsetime_error = rrd_parsetime ( optarg , & end_tv ) ) ) { rrd_set_error ( ""end<S2SV_blank>time:<S2SV_blank>%s"" , parsetime_error ) ; return ; } break ; case 'x' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_x_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%10[A-Z]:%ld:%10[A-Z]:%ld:%10[A-Z]:%ld:%ld:%n"" , scan_gtm , & im -> xlab_user . gridst , scan_mtm , & im -> xlab_user . mgridst , scan_ltm , & im -> xlab_user . labst , & im -> xlab_user . precis , & stroff ) == 7 && stroff != 0 ) { strncpy ( im -> xlab_form , optarg + stroff , sizeof ( im -> xlab_form ) - 1 ) ; im -> xlab_form [ sizeof ( im -> xlab_form ) - 1 ] = '\\0' ; if ( ( int ) ( im -> xlab_user . gridtm = tmt_conv ( scan_gtm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_gtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . mgridtm = tmt_conv ( scan_mtm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_mtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . labtm = tmt_conv ( scan_ltm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_ltm ) ; return ; } im -> xlab_user . minsec = 1 ; im -> xlab_user . stst = im -> xlab_form ; } else { rrd_set_error ( ""invalid<S2SV_blank>x-grid<S2SV_blank>format"" ) ; return ; } break ; case 'y' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_y_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%lf:%d"" , & im -> ygridstep , & im -> ylabfact ) == 2 ) { if ( im -> ygridstep <= 0 ) { rrd_set_error ( ""grid<S2SV_blank>step<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } else if ( im -> ylabfact < 1 ) { rrd_set_error ( ""label<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>y-grid<S2SV_blank>format"" ) ; return ; } break ; case 1007 : im -> draw_3d_border = atoi ( optarg ) ; break ; case 1008 : if ( sscanf ( optarg , ""%lf:%lf"" , & im -> grid_dash_on , & im -> grid_dash_off ) != 2 ) { rrd_set_error ( ""expected<S2SV_blank>grid-dash<S2SV_blank>format<S2SV_blank>float:float"" ) ; return ; } break ; case 1009 : im -> dynamic_labels = 1 ; break ; case 1002 : if ( sscanf ( optarg , ""%lf:%lf"" , & im -> second_axis_scale , & im -> second_axis_shift ) == 2 ) { if ( im -> second_axis_scale == 0 ) { rrd_set_error ( ""the<S2SV_blank>second_axis_scale<S2SV_blank><S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0"" ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>right-axis<S2SV_blank>format<S2SV_blank>expected<S2SV_blank>scale:shift"" ) ; return ; } break ; case 1003 : strncpy ( im -> second_axis_legend , optarg , 150 ) ; im -> second_axis_legend [ 150 ] = '\\0' ; break ; case 1004 :  if ( bad_format ( optarg ) ) {  rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ; return ; } strncpy ( im -> second_axis_format , optarg , 150 ) ; im -> second_axis_format [ 150 ] = '\\0' ; break ; case 1010 :  if ( bad_format ( optarg ) ) {  rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ; return ; } strncpy ( im -> primary_axis_format , optarg , 150 ) ; im -> primary_axis_format [ 150 ] = '\\0' ; break ; case 'v' : strncpy ( im -> ylegend , optarg , 150 ) ; im -> ylegend [ 150 ] = '\\0' ; break ; case 'u' : im -> maxval = atof ( optarg ) ; break ; case 'l' : im -> minval = atof ( optarg ) ; break ; case 'b' : im -> base = atol ( optarg ) ; if ( im -> base != 1024 && im -> base != 1000 ) { rrd_set_error ( ""the<S2SV_blank>only<S2SV_blank>sensible<S2SV_blank>value<S2SV_blank>for<S2SV_blank>base<S2SV_blank>apart<S2SV_blank>from<S2SV_blank>1000<S2SV_blank>is<S2SV_blank>1024"" ) ; return ; } break ; case 'w' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""width<S2SV_blank>below<S2SV_blank>10<S2SV_blank>pixels"" ) ; return ; } im -> xsize = long_tmp ; break ; case 'h' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""height<S2SV_blank>below<S2SV_blank>10<S2SV_blank>pixels"" ) ; return ; } im -> ysize = long_tmp ; break ; case 'D' : im -> extra_flags |= FULL_SIZE_MODE ; break ; case 'i' : break ; case 'r' : im -> rigid = 1 ; break ; case 'f' : im -> imginfo = optarg ; break ; case 'a' : if ( ( int ) ( im -> imgformat = if_conv ( optarg ) ) == - 1 ) { rrd_set_error ( ""unsupported<S2SV_blank>graphics<S2SV_blank>format<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'z' : im -> lazy = 1 ; break ; case 'E' : im -> slopemode = 1 ; break ; case 'o' : im -> logarithmic = 1 ; break ; case 'c' : if ( sscanf ( optarg , ""%10[A-Z]#%n%8lx%n"" , col_nam , & col_start , & color , & col_end ) == 2 ) { int ci ; int col_len = col_end - col_start ; switch ( col_len ) { case 3 : color = ( ( ( color & 0xF00 ) * 0x110000 ) | ( ( color & 0x0F0 ) * 0x011000 ) | ( ( color & 0x00F ) * 0x001100 ) | 0x000000FF ) ; break ; case 4 : color = ( ( ( color & 0xF000 ) * 0x11000 ) | ( ( color & 0x0F00 ) * 0x01100 ) | ( ( color & 0x00F0 ) * 0x00110 ) | ( ( color & 0x000F ) * 0x00011 ) ) ; break ; case 6 : color = ( color << 8 ) + 0xff ; break ; case 8 : break ; default : rrd_set_error ( ""the<S2SV_blank>color<S2SV_blank>format<S2SV_blank>is<S2SV_blank>#RRGGBB[AA]"" ) ; return ; } if ( ( ci = grc_conv ( col_nam ) ) != - 1 ) { im -> graph_col [ ci ] = gfx_hex_to_col ( color ) ; } else { rrd_set_error ( ""invalid<S2SV_blank>color<S2SV_blank>name<S2SV_blank>\'%s\'"" , col_nam ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>color<S2SV_blank>def<S2SV_blank>format"" ) ; return ; } break ; case 'n' : { char prop [ 15 ] ; double size = 1 ; int end ; if ( sscanf ( optarg , ""%10[A-Z]:%lf%n"" , prop , & size , & end ) >= 2 ) { int sindex , propidx ; if ( ( sindex = text_prop_conv ( prop ) ) != - 1 ) { for ( propidx = sindex ; propidx < TEXT_PROP_LAST ; propidx ++ ) { if ( size > 0 ) { rrd_set_font_desc ( im , propidx , NULL , size ) ; } if ( ( int ) strlen ( optarg ) > end + 2 ) { if ( optarg [ end ] == ':' ) { rrd_set_font_desc ( im , propidx , optarg + end + 1 , 0 ) ; } else { rrd_set_error ( ""expected<S2SV_blank>:<S2SV_blank>after<S2SV_blank>font<S2SV_blank>size<S2SV_blank>in<S2SV_blank>\'%s\'"" , optarg ) ; return ; } } if ( propidx == sindex && sindex != 0 ) break ; } } else { rrd_set_error ( ""invalid<S2SV_blank>fonttag<S2SV_blank>\'%s\'"" , prop ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>text<S2SV_blank>property<S2SV_blank>format"" ) ; return ; } break ; } case 'm' : im -> zoom = atof ( optarg ) ; if ( im -> zoom <= 0.0 ) { rrd_set_error ( ""zoom<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } break ; case 't' : strncpy ( im -> title , optarg , 150 ) ; im -> title [ 150 ] = '\\0' ; break ; case 'R' : if ( strcmp ( optarg , ""normal"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else if ( strcmp ( optarg , ""light"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_SLIGHT ) ; } else if ( strcmp ( optarg , ""mono"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_NONE ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else { rrd_set_error ( ""unknown<S2SV_blank>font-render-mode<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'G' : if ( strcmp ( optarg , ""normal"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_GRAY ; else if ( strcmp ( optarg , ""mono"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_NONE ; else { rrd_set_error ( ""unknown<S2SV_blank>graph-render-mode<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'B' : break ; case 'W' : strncpy ( im -> watermark , optarg , 100 ) ; im -> watermark [ 99 ] = '\\0' ; break ; case 'd' : { if ( im -> daemon_addr != NULL ) { rrd_set_error ( ""You<S2SV_blank>cannot<S2SV_blank>specify<S2SV_blank>--daemon<S2SV_blank>"" ""more<S2SV_blank>than<S2SV_blank>once."" ) ; return ; } im -> daemon_addr = strdup ( optarg ) ; if ( im -> daemon_addr == NULL ) { rrd_set_error ( ""strdup<S2SV_blank>failed"" ) ; return ; } break ; } case '?' : if ( optopt != 0 ) rrd_set_error ( ""unknown<S2SV_blank>option<S2SV_blank>\'%c\'"" , optopt ) ; else rrd_set_error ( ""unknown<S2SV_blank>option<S2SV_blank>\'%s\'"" , argv [ optind - 1 ] ) ; return ; } } { int status = rrdc_connect ( im -> daemon_addr ) ; if ( status != 0 ) return ; } pango_cairo_context_set_font_options ( pango_layout_get_context ( im -> layout ) , im -> font_options ) ; pango_layout_context_changed ( im -> layout ) ; if ( im -> logarithmic && im -> minval <= 0 ) { rrd_set_error ( ""for<S2SV_blank>a<S2SV_blank>logarithmic<S2SV_blank>yaxis<S2SV_blank>you<S2SV_blank>must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>lower-limit<S2SV_blank>><S2SV_blank>0"" ) ; return ; } if ( rrd_proc_start_end ( & start_tv , & end_tv , & start_tmp , & end_tmp ) == - 1 ) { return ; } if ( start_tmp < 3600 * 24 * 365 * 10 ) { rrd_set_error ( ""the<S2SV_blank>first<S2SV_blank>entry<S2SV_blank>to<S2SV_blank>fetch<S2SV_blank>should<S2SV_blank>be<S2SV_blank>after<S2SV_blank>1980<S2SV_blank>(%ld)"" , start_tmp ) ; return ; } if ( end_tmp < start_tmp ) { rrd_set_error ( ""start<S2SV_blank>(%ld)<S2SV_blank>should<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>end<S2SV_blank>(%ld)"" , start_tmp , end_tmp ) ; return ; } im -> start = start_tmp ; im -> end = end_tmp ; im -> step = max ( ( long ) im -> step , ( im -> end - im -> start ) / im -> xsize ) ; }","case 1004 : if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;case 1010 : if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;",1403
290,"buggy line: p = strchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;q = strchr ( p + 1 , \'<S2SV_blank>\' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;cwe id:CWE-20context: error_t httpClientSetQueryString ( HttpClientContext * context , const char_t * queryString ) { size_t m ; size_t n ; char_t * p ; char_t * q ; if ( context == NULL || queryString == NULL ) return ERROR_INVALID_PARAMETER ; if ( context -> requestState != HTTP_REQ_STATE_FORMAT_HEADER ) return ERROR_WRONG_STATE ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ;  p = strchr ( context -> buffer , '<S2SV_blank>' ) ;  if ( p == NULL ) return ERROR_INVALID_SYNTAX ; p = strpbrk ( p + 1 , ""<S2SV_blank>?"" ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; if ( * p == '?' ) {  q = strchr ( p + 1 , '<S2SV_blank>' ) ;  if ( q == NULL ) return ERROR_INVALID_SYNTAX ; m = q - p ; } else { q = p ; m = 0 ; } n = osStrlen ( queryString ) ; if ( n == 0 ) { osMemmove ( p , p + m , context -> buffer + context -> bufferLen + 1 - q ) ; } else { n ++ ; if ( ( context -> bufferLen + n - m ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + n , q , context -> buffer + context -> bufferLen + 1 - q ) ; p [ 0 ] = '?' ; osStrncpy ( p + 1 , queryString , n - 1 ) ; } context -> bufferLen = context -> bufferLen + n - m ; return NO_ERROR ; }","p = osStrchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;q = osStrchr ( p + 1 , \'<S2SV_blank>\' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;",1404
291,"buggy line: if ( kwonlyargs == NULL ) {cwe id:CWE-125context: static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ;  if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }",if ( i < NCH ( n ) && kwonlyargs == NULL ) {,1405
292,"buggy line: if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;cwe id:CWE-125context: static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ;  if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }","if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;",1405
293,"buggy line: vpx_memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;vp8_init_mbmode_probs ( pc ) ;vp8_default_coef_probs ( pc ) ;vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ;xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ;vpx_memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ;vpx_memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ;pc -> refresh_golden_frame = 1 ;cwe id:CWE-119context: static void init_frame ( VP8D_COMP * pbi ) { VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; if ( pc -> frame_type == KEY_FRAME ) {  vpx_memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;  vp8_init_mbmode_probs ( pc ) ; vp8_default_coef_probs ( pc ) ;  vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ;  xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ;  vpx_memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ;   vpx_memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ;  pc -> refresh_golden_frame = 1 ; pc -> refresh_alt_ref_frame = 1 ; pc -> copy_buffer_to_gf = 0 ; pc -> copy_buffer_to_arf = 0 ; pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] = 0 ; pc -> ref_frame_sign_bias [ ALTREF_FRAME ] = 0 ; } else { if ( ! pc -> use_bilinear_mc_filter ) { xd -> subpixel_predict = vp8_sixtap_predict4x4 ; xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; } else { xd -> subpixel_predict = vp8_bilinear_predict4x4 ; xd -> subpixel_predict8x4 = vp8_bilinear_predict8x4 ; xd -> subpixel_predict8x8 = vp8_bilinear_predict8x8 ; xd -> subpixel_predict16x16 = vp8_bilinear_predict16x16 ; } if ( pbi -> decoded_key_frame && pbi -> ec_enabled && ! pbi -> ec_active ) pbi -> ec_active = 1 ; } xd -> left_context = & pc -> left_context ; xd -> mode_info_context = pc -> mi ; xd -> frame_type = pc -> frame_type ; xd -> mode_info_context -> mbmi . mode = DC_PRED ; xd -> mode_info_stride = pc -> mode_info_stride ; xd -> corrupted = 0 ; xd -> fullpixel_mask = 0xffffffff ; if ( pc -> full_pixel ) xd -> fullpixel_mask = 0xfffffff8 ; }","memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;vp8_init_mbmode_probs ( pc ) ;memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ;xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ;memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ;memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ;pc -> refresh_golden_frame = 1 ;",1406
294,"buggy line: uint16_t n ;uint32_t status ;Enc624j600Context * context ;context = ( Enc624j600Context * ) interface -> nicContext ;if ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PKTCNT )  {enc624j600WriteReg ( interface , ENC624J600_REG_ERXRDPT , context -> nextPacket ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA ,  ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ;context -> nextPacket = letoh16 ( context -> nextPacket ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ;n = letoh16 ( n ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & status , sizeof ( uint32_t ) ) ;status = letoh32 ( status ) ;if ( ( status & RSV_RECEIVED_OK ) != 0 )  {n = MIN ( n , ETH_MAX_FRAME_SIZE ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , n ) ;error = NO_ERROR ;enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ;}enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , context -> nextPacket - 2 ) ;}enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_PKTDEC ) ;}nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ;}cwe id:CWE-20context: error_t enc624j600ReceivePacket ( NetInterface * interface ) { error_t error ;  uint16_t n ;  uint32_t status ;  Enc624j600Context * context ;  context = ( Enc624j600Context * ) interface -> nicContext ;  if ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PKTCNT )  {  enc624j600WriteReg ( interface , ENC624J600_REG_ERXRDPT , context -> nextPacket ) ;  enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA ,  ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ;  context -> nextPacket = letoh16 ( context -> nextPacket ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ; n = letoh16 ( n ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & status , sizeof ( uint32_t ) ) ; status = letoh32 ( status ) ;  if ( ( status & RSV_RECEIVED_OK ) != 0 )  {  n = MIN ( n , ETH_MAX_FRAME_SIZE ) ;   enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , n ) ;  error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } if ( context -> nextPacket == ENC624J600_RX_BUFFER_START ) {  enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ;  } else {  enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , context -> nextPacket - 2 ) ;  }  enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_PKTDEC ) ;  } else { error = ERROR_BUFFER_EMPTY ; } if ( ! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ;  nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ;  } return error ; }","uint16_t length ;uint32_t status ;uint8_t header [ 8 ] ;Enc624j600Context * context ;context = ( Enc624j600Context * ) interface -> nicContext ;if ( enc624j600ReadReg ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT ) {enc624j600WriteReg ( interface , ENC624J600_ERXRDPT , context -> nextPacket ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , header , sizeof ( uint16_t ) ) ;context -> nextPacket = letoh16 ( context -> nextPacket ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & n , sizeof ( header ) ) ;context -> nextPacket = LOAD16LE ( header ) ;length = LOAD16LE ( header + 2 ) ;status = LOAD32LE ( header + 4 ) ;if ( ( status & RSV_RECEIVED_OK ) != 0 ) {length = MIN ( n , ETH_MAX_FRAME_SIZE ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , length ) ;error = NO_ERROR ;enc624j600WriteReg ( interface , ENC624J600_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ;}enc624j600WriteReg ( interface , ENC624J600_ERXTAIL , context -> nextPacket - 2 ) ;}enc624j600SetBit ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_PKTDEC ) ;}nicProcessPacket ( interface , context -> rxBuffer , length , & ancillary ) ;}",1407
295,"buggy line: while ( ibuf [ ind ] == 0x01 ) {if ( ibuf [ ind + 1 ] == 0xFE ) {cwe id:CWE-119context: static int gemsafe_get_cert_len ( sc_card_t * card ) { int r ; u8 ibuf [ GEMSAFE_MAX_OBJLEN ] ; u8 * iptr ; struct sc_path path ; struct sc_file * file ; size_t objlen , certlen ; unsigned int ind , i = 0 ; sc_format_path ( GEMSAFE_PATH , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r != SC_SUCCESS || ! file ) return SC_ERROR_INTERNAL ; r = sc_read_binary ( card , 0 , ibuf , GEMSAFE_READ_QUANTUM , 0 ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; objlen = ( ( ( size_t ) ibuf [ 0 ] ) << 8 ) | ibuf [ 1 ] ; sc_log ( card -> ctx , ""Stored<S2SV_blank>object<S2SV_blank>is<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , objlen ) ; if ( objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN ) { sc_log ( card -> ctx , ""Invalid<S2SV_blank>object<S2SV_blank>size:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , objlen ) ; return SC_ERROR_INTERNAL ; } ind = 2 ;  while ( ibuf [ ind ] == 0x01 ) {  if ( ibuf [ ind + 1 ] == 0xFE ) { gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; sc_log ( card -> ctx , ""Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>allocated<S2SV_blank>and<S2SV_blank>uses<S2SV_blank>key_ref<S2SV_blank>%d"" , i + 1 , gemsafe_prkeys [ i ] . ref ) ; ind += 9 ; } else { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; sc_log ( card -> ctx , ""Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unallocated"" , i + 1 ) ; ind += 8 ; } i ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } iptr = ibuf + GEMSAFE_READ_QUANTUM ; while ( ( size_t ) ( iptr - ibuf ) < objlen ) { r = sc_read_binary ( card , iptr - ibuf , iptr , MIN ( GEMSAFE_READ_QUANTUM , objlen - ( iptr - ibuf ) ) , 0 ) ; if ( r < 0 ) { sc_log ( card -> ctx , ""Could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>cert<S2SV_blank>object"" ) ; return SC_ERROR_INTERNAL ; } iptr += GEMSAFE_READ_QUANTUM ; } i = 0 ; while ( ind < objlen - 1 ) { if ( ibuf [ ind ] == 0x30 && ibuf [ ind + 1 ] == 0x82 ) { while ( i < gemsafe_cert_max && gemsafe_cert [ i ] . label == NULL ) i ++ ; if ( i == gemsafe_cert_max ) { sc_log ( card -> ctx , ""Warning:<S2SV_blank>Found<S2SV_blank>orphaned<S2SV_blank>certificate<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d"" , ind ) ; return SC_SUCCESS ; } if ( ind + 3 >= sizeof ibuf ) return SC_ERROR_INVALID_DATA ; certlen = ( ( ( ( size_t ) ibuf [ ind + 2 ] ) << 8 ) | ibuf [ ind + 3 ] ) + 4 ; sc_log ( card -> ctx , ""Found<S2SV_blank>certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , i + 1 , ind , certlen ) ; gemsafe_cert [ i ] . index = ind ; gemsafe_cert [ i ] . count = certlen ; ind += certlen ; i ++ ; } else ind ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { if ( gemsafe_cert [ i ] . label ) { sc_log ( card -> ctx , ""Warning:<S2SV_blank>Certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>missing"" , i + 1 ) ; gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } } return SC_SUCCESS ; }",while ( ibuf [ ind ] == 0x01 && i < gemsafe_cert_max ) {if ( ibuf [ ind + 1 ] == 0xFE ) {,1408
296,"buggy line: if ( vmx_set_msr ( vcpu , & msr ) != 0 ) {trace_kvm_msr_write_ex ( ecx , data ) ;cwe id:CWE-264context: static int handle_wrmsr ( struct kvm_vcpu * vcpu ) { struct msr_data msr ; u32 ecx = vcpu -> arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( vcpu -> arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( vcpu -> arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ;  if ( vmx_set_msr ( vcpu , & msr ) != 0 ) {  trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( vcpu ) ; return 1 ; }","if ( kvm_set_msr ( vcpu , & msr ) != 0 ) {trace_kvm_msr_write_ex ( ecx , data ) ;",1409
297,"buggy line: static VALUE read_memory ( VALUE klass , VALUE content )  {xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt (  ( const char * ) StringValuePtr ( content ) , ( int ) RSTRING_LEN ( content )  ) ;VALUE rb_schema ;VALUE errors = rb_ary_new ( ) ;cwe id:CWE-611context:  static VALUE read_memory ( VALUE klass , VALUE content )  { xmlSchemaPtr schema ;  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt (  ( const char * ) StringValuePtr ( content ) , ( int ) RSTRING_LEN ( content )  ) ;  VALUE rb_schema ; VALUE errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; # endif schema = xmlSchemaParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlSchemaFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , ""Could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>document"" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , ""@errors"" , errors ) ;  return rb_schema ;  }","static VALUE read_memory ( int argc , VALUE * argv , VALUE klass ) {VALUE content ;VALUE parse_options ;int parse_options_int ;xmlSchemaParserCtxtPtr ctx ;VALUE errors ;VALUE rb_schema ;int scanned_args = 0 ;scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ;if ( scanned_args == 1 ) {parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ;}parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( ""to_i"" ) , 0 ) ) ;ctx = xmlSchemaNewMemParserCtxt ( ( const char * ) StringValuePtr ( content ) ) ;errors = rb_ary_new ( ) ;rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;",1410
298,"buggy line: return rb_schema ;}cwe id:CWE-611context:  static VALUE read_memory ( VALUE klass , VALUE content )  { xmlSchemaPtr schema ;  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt (  ( const char * ) StringValuePtr ( content ) , ( int ) RSTRING_LEN ( content )  ) ;  VALUE rb_schema ; VALUE errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; # endif schema = xmlSchemaParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlSchemaFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , ""Could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>document"" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , ""@errors"" , errors ) ;  return rb_schema ;  }",return rb_schema ;},1410
299,"buggy line: unsigned int len ;unsigned long start = 0 , off ;struct au1200fb_device * fbdev = info -> par ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {cwe id:CWE-119context: static int au1200fb_fb_mmap ( struct fb_info * info , struct vm_area_struct * vma ) {  unsigned int len ;  unsigned long start = 0 , off ;  struct au1200fb_device * fbdev = info -> par ;  if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= _CACHE_MASK ;  return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }",struct au1200fb_device * fbdev = info -> par ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {,1411
300,"buggy line: return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;cwe id:CWE-119context: static int au1200fb_fb_mmap ( struct fb_info * info , struct vm_area_struct * vma ) {  unsigned int len ;  unsigned long start = 0 , off ;  struct au1200fb_device * fbdev = info -> par ;  if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= _CACHE_MASK ;  return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }","return vm_iomap_memory ( vma , vma -> vm_start , off >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;",1411
301,"buggy line: if ( ! new_service_options . next )  errstr = parse_global_option ( CMD_SET_VALUE , config_opt , config_arg ) ;if ( errstr == option_not_found ) errstr = parse_service_option ( CMD_SET_VALUE , section_ptr , config_opt , config_arg ) ;cwe id:CWE-295context: NOEXPORT int options_file ( char * path , CONF_TYPE type , SERVICE_OPTIONS * * section_ptr ) { DISK_FILE * df ; char line_text [ CONFLINELEN ] , * errstr ; char config_line [ CONFLINELEN ] , * config_opt , * config_arg ; int i , line_number = 0 ; # ifndef USE_WIN32 int fd ; char * tmp_str ; # endif s_log ( LOG_NOTICE , ""Reading<S2SV_blank>configuration<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>%s"" , type == CONF_FD ? ""descriptor"" : ""file"" , path ) ; # ifndef USE_WIN32 if ( type == CONF_FD ) { fd = ( int ) strtol ( path , & tmp_str , 10 ) ; if ( tmp_str == path || * tmp_str ) { s_log ( LOG_ERR , ""Invalid<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>number"" ) ; print_syntax ( ) ; return 1 ; } df = file_fdopen ( fd ) ; } else # endif df = file_open ( path , FILE_MODE_READ ) ; if ( ! df ) { s_log ( LOG_ERR , ""Cannot<S2SV_blank>open<S2SV_blank>configuration<S2SV_blank>file"" ) ; if ( type != CONF_RELOAD ) print_syntax ( ) ; return 1 ; } while ( file_getline ( df , line_text , CONFLINELEN ) >= 0 ) { memcpy ( config_line , line_text , CONFLINELEN ) ; ++ line_number ; config_opt = config_line ; if ( line_number == 1 ) { if ( config_opt [ 0 ] == ( char ) 0xef && config_opt [ 1 ] == ( char ) 0xbb && config_opt [ 2 ] == ( char ) 0xbf ) { s_log ( LOG_NOTICE , ""UTF-8<S2SV_blank>byte<S2SV_blank>order<S2SV_blank>mark<S2SV_blank>detected"" ) ; config_opt += 3 ; } else { s_log ( LOG_NOTICE , ""UTF-8<S2SV_blank>byte<S2SV_blank>order<S2SV_blank>mark<S2SV_blank>not<S2SV_blank>detected"" ) ; } } while ( isspace ( ( unsigned char ) * config_opt ) ) ++ config_opt ; for ( i = ( int ) strlen ( config_opt ) - 1 ; i >= 0 && isspace ( ( unsigned char ) config_opt [ i ] ) ; -- i ) config_opt [ i ] = '\\0' ; if ( config_opt [ 0 ] == '\\0' || config_opt [ 0 ] == '#' || config_opt [ 0 ] == ';' ) continue ; if ( config_opt [ 0 ] == '[' && config_opt [ strlen ( config_opt ) - 1 ] == ']' ) { if ( init_section ( 0 , section_ptr ) ) { file_close ( df ) ; return 1 ; } { SERVICE_OPTIONS * new_section ; new_section = str_alloc_detached ( sizeof ( SERVICE_OPTIONS ) ) ; new_section -> next = NULL ; ( * section_ptr ) -> next = new_section ; * section_ptr = new_section ; } ++ config_opt ; config_opt [ strlen ( config_opt ) - 1 ] = '\\0' ; ( * section_ptr ) -> servname = str_dup_detached ( config_opt ) ; ( * section_ptr ) -> session = NULL ; parse_service_option ( CMD_SET_COPY , section_ptr , NULL , NULL ) ; continue ; } config_arg = strchr ( config_line , '=' ) ; if ( ! config_arg ) { s_log ( LOG_ERR , ""%s:%d:<S2SV_blank>\\""%s\\"":<S2SV_blank>No<S2SV_blank>\'=\'<S2SV_blank>found"" , path , line_number , line_text ) ; file_close ( df ) ; return 1 ; } * config_arg ++ = '\\0' ; for ( i = ( int ) strlen ( config_opt ) - 1 ; i >= 0 && isspace ( ( unsigned char ) config_opt [ i ] ) ; -- i ) config_opt [ i ] = '\\0' ; while ( isspace ( ( unsigned char ) * config_arg ) ) ++ config_arg ; errstr = option_not_found ; if ( ! new_service_options . next )  errstr = parse_global_option ( CMD_SET_VALUE , config_opt , config_arg ) ;  if ( errstr == option_not_found ) errstr = parse_service_option ( CMD_SET_VALUE , section_ptr , config_opt , config_arg ) ; if ( errstr ) { s_log ( LOG_ERR , ""%s:%d:<S2SV_blank>\\""%s\\"":<S2SV_blank>%s"" , path , line_number , line_text , errstr ) ; file_close ( df ) ; return 1 ; } } file_close ( df ) ; return 0 ; }","if ( ! new_service_options . next ) errstr = parse_global_option ( CMD_SET_VALUE , & new_global_options , config_opt , config_arg ) ;if ( errstr == option_not_found ) errstr = parse_service_option ( CMD_SET_VALUE , section_ptr , config_opt , config_arg ) ;",1412
302,"buggy line: out += 4 ;}cwe id:CWE-119context: int ImagingPcdDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) { int x ; int chunk ; UINT8 * out ; UINT8 * ptr ; ptr = buf ; chunk = 3 * state -> xsize ; for ( ; ; ) { if ( bytes < chunk ) return ptr - buf ; out = state -> buffer ; for ( x = 0 ; x < state -> xsize ; x ++ ) { out [ 0 ] = ptr [ x ] ; out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ; out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;  out += 4 ;  } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ; if ( ++ state -> y >= state -> ysize ) return - 1 ; out = state -> buffer ; for ( x = 0 ; x < state -> xsize ; x ++ ) { out [ 0 ] = ptr [ x + state -> xsize ] ; out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ; out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;  out += 4 ;  } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ; if ( ++ state -> y >= state -> ysize ) return - 1 ; ptr += chunk ; bytes -= chunk ; } }",out += 3 ;},1413
303,"buggy line: out += 4 ;}cwe id:CWE-119context: int ImagingPcdDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) { int x ; int chunk ; UINT8 * out ; UINT8 * ptr ; ptr = buf ; chunk = 3 * state -> xsize ; for ( ; ; ) { if ( bytes < chunk ) return ptr - buf ; out = state -> buffer ; for ( x = 0 ; x < state -> xsize ; x ++ ) { out [ 0 ] = ptr [ x ] ; out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ; out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;  out += 4 ;  } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ; if ( ++ state -> y >= state -> ysize ) return - 1 ; out = state -> buffer ; for ( x = 0 ; x < state -> xsize ; x ++ ) { out [ 0 ] = ptr [ x + state -> xsize ] ; out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ; out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;  out += 4 ;  } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ; if ( ++ state -> y >= state -> ysize ) return - 1 ; ptr += chunk ; bytes -= chunk ; } }",out += 3 ;},1413
304,"buggy line: alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ;data . period = event -> hw . last_period ;if ( alpha_perf_event_set_period ( event , hwc , idx ) ) {if ( perf_event_overflow ( event , 1 , & data , regs ) ) {alpha_pmu_stop ( event , 0 ) ;cwe id:CWE-399context: static void alpha_perf_event_irq_handler ( unsigned long la_ptr , struct pt_regs * regs ) { struct cpu_hw_events * cpuc ; struct perf_sample_data data ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , j ; __get_cpu_var ( irq_pmi_count ) ++ ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; wrperfmon ( PERFMON_CMD_DISABLE , cpuc -> idx_mask ) ; if ( unlikely ( la_ptr >= alpha_pmu -> num_pmcs ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>silly<S2SV_blank>index<S2SV_blank>%ld\\n"" , la_ptr ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } idx = la_ptr ; perf_sample_data_init ( & data , 0 ) ; for ( j = 0 ; j < cpuc -> n_events ; j ++ ) { if ( cpuc -> current_idx [ j ] == idx ) break ; } if ( unlikely ( j == cpuc -> n_events ) ) { wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } event = cpuc -> event [ j ] ; if ( unlikely ( ! event ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>No<S2SV_blank>event<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d!\\n"" , idx ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } hwc = & event -> hw ; alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ; data . period = event -> hw . last_period ; if ( alpha_perf_event_set_period ( event , hwc , idx ) ) {  if ( perf_event_overflow ( event , 1 , & data , regs ) ) {  alpha_pmu_stop ( event , 0 ) ; } } wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; }","alpha_perf_event_update ( event , & data , regs ) ) {alpha_pmu_stop ( event , 0 ) ;",1414
305,"buggy line: if ( ! CDROM_CAN ( CDC_MEDIA_CHANGED ) ) return - ENOSYS ;if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) return media_changed ( cdi , 1 ) ;if ( ( unsigned int ) arg >= cdi -> capacity )  return - EINVAL ;cwe id:CWE-119context: static int cdrom_ioctl_media_changed ( struct cdrom_device_info * cdi , unsigned long arg ) { struct cdrom_changer_info * info ; int ret ; cd_dbg ( CD_DO_IOCTL , ""entering<S2SV_blank>CDROM_MEDIA_CHANGED\\n"" ) ; if ( ! CDROM_CAN ( CDC_MEDIA_CHANGED ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) return media_changed ( cdi , 1 ) ;  if ( ( unsigned int ) arg >= cdi -> capacity )  return - EINVAL ; info = kmalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( ! info ) return - ENOMEM ; ret = cdrom_read_mech_status ( cdi , info ) ; if ( ! ret ) ret = info -> slots [ arg ] . change ; kfree ( info ) ; return ret ; }",if ( arg >= cdi -> capacity ) return - EINVAL ;,1415
306,"buggy line: err = - EINVAL ;if ( ! po -> running ) goto out ;cwe id:CWE-362context: static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ;  err = - EINVAL ;  if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; refcount_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ;  if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( refcount_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; refcount_set ( & match -> sk_ref , refcount_read ( & match -> sk_ref ) + 1 ) ; __fanout_link ( sk , po ) ; err = 0 ; } }  out :  if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }","
",1416
307,"buggy line: goto out ;}if ( ! fanout_find_new_id ( sk , & id ) ) {err = - ENOMEM ;goto out ;}flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ;}match = NULL ;list_for_each_entry ( f , & fanout_list , list ) {if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) {match = f ;break ;}}err = - EINVAL ;if ( match && match -> flags != flags ) goto out ;if ( ! match ) {err = - ENOMEM ;match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ;if ( ! match ) goto out ;write_pnet ( & match -> net , sock_net ( sk ) ) ;match -> id = id ;match -> type = type ;cwe id:CWE-362context: static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ;  err = - EINVAL ;  if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; refcount_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ;  if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( refcount_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; refcount_set ( & match -> sk_ref , refcount_read ( & match -> sk_ref ) + 1 ) ; __fanout_link ( sk , po ) ; err = 0 ; } }  out :  if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }",spin_lock ( & po -> bind_lock ) ;if ( po -> running && match -> type = type ;,1416
308,"buggy line: if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {cwe id:CWE-362context: static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ;  err = - EINVAL ;  if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; refcount_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ;  if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( refcount_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; refcount_set ( & match -> sk_ref , refcount_read ( & match -> sk_ref ) + 1 ) ; __fanout_link ( sk , po ) ; err = 0 ; } }  out :  if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }",if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {,1416
309,"buggy line: out :  if ( err && rollover ) {cwe id:CWE-362context: static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ;  err = - EINVAL ;  if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; refcount_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ;  if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( refcount_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; refcount_set ( & match -> sk_ref , refcount_read ( & match -> sk_ref ) + 1 ) ; __fanout_link ( sk , po ) ; err = 0 ; } }  out :  if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }",spin_unlock ( & po -> bind_lock ) ;if ( err && ! refcount_read ( & match -> sk_ref ) ) {list_del ( & match -> list ) ;kfree ( match ) ;}out : if ( err && rollover ) {,1416
310,"buggy line: if ( handle -> nmi ) {handle -> event -> pending_wakeup = 1 ;}else  perf_event_wakeup ( handle -> event ) ;cwe id:CWE-400context: static void perf_output_wakeup ( struct perf_output_handle * handle ) { atomic_set ( & handle -> rb -> poll , POLL_IN ) ;  if ( handle -> nmi ) {  handle -> event -> pending_wakeup = 1 ; irq_work_queue ( & handle -> event -> pending ) ;  } else  perf_event_wakeup ( handle -> event ) ; }",handle -> event -> pending_wakeup = 1 ;,1417
311,"buggy line: int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs )  {while ( * s && len > 0 ) {if ( * s & 0x80 ) {if ( u >= PLANE_SIZE ) {u -= PLANE_SIZE ;* op ++ = ( wchar_t ) ( SURROGATE_PAIR |   ( ( u >> 10 ) & SURROGATE_BITS ) ) ;* op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW |  ( u & SURROGATE_BITS ) ) ;}else {* op ++ = ( wchar_t ) u ;}* op ++ = * s ++ ;len -- ;cwe id:CWE-119context:  int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs )  { u16 * op ; int size ; unicode_t u ; op = pwcs ;  while ( * s && len > 0 ) {  if ( * s & 0x80 ) { size = utf8_to_utf32 ( s , len , & u ) ; if ( size < 0 ) return - EINVAL ;  if ( u >= PLANE_SIZE ) {   u -= PLANE_SIZE ;   * op ++ = ( wchar_t ) ( SURROGATE_PAIR |   ( ( u >> 10 ) & SURROGATE_BITS ) ) ;  * op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW |  ( u & SURROGATE_BITS ) ) ;  } else {  * op ++ = ( wchar_t ) u ;  } s += size ; len -= size ; } else {  * op ++ = * s ++ ;  len -- ; } } return op - pwcs ; }","int utf8s_to_utf16s ( const u8 * s , int len , enum utf16_endian endian , wchar_t * pwcs , int maxlen ) {while ( len > 0 && maxlen > 0 && * s ) {if ( * s & 0x80 ) {if ( u >= PLANE_SIZE ) {if ( maxlen < 2 ) break ;u -= PLANE_SIZE ;put_utf16 ( op ++ , SURROGATE_PAIR | ( ( u >> 10 ) & SURROGATE_BITS ) , endian ) ;put_utf16 ( op ++ , SURROGATE_PAIR | SURROGATE_LOW | ( u & SURROGATE_BITS ) , endian ) ;maxlen -= 2 ;}else {put_utf16 ( op ++ , u , endian ) ;maxlen -- ;}* op ++ = * s ++ ;len -- ;",1418
312,"buggy line: int v , i ;if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) {cwe id:CWE-787context: static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , uint32_t length ) {  int v , i ;  if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length ; i ++ ) { v = bytestream2_get_byte ( & s -> gb ) ; s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; } } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) ||  ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) )  return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length / 2 ; i ++ ) { v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; if ( s -> bit_depth > 8 ) AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; else s -> transparent_color_be [ i ] = v ; } } else { return AVERROR_INVALIDDATA ; } bytestream2_skip ( & s -> gb , 4 ) ; s -> has_trns = 1 ; return 0 ; }","int v , i ;if ( ! ( s -> state & PNG_IHDR ) ) {av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>before<S2SV_blank>IHDR\\\return AVERROR_INVALIDDATA ;}if ( s -> state & PNG_IDAT ) {av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>after<S2SV_blank>IDAT\\\return AVERROR_INVALIDDATA ;}if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) {",1419
313,"buggy line: if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) ||  ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) )  return AVERROR_INVALIDDATA ;cwe id:CWE-787context: static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , uint32_t length ) {  int v , i ;  if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length ; i ++ ) { v = bytestream2_get_byte ( & s -> gb ) ; s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; } } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) ||  ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) )  return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length / 2 ; i ++ ) { v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; if ( s -> bit_depth > 8 ) AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; else s -> transparent_color_be [ i ] = v ; } } else { return AVERROR_INVALIDDATA ; } bytestream2_skip ( & s -> gb , 4 ) ; s -> has_trns = 1 ; return 0 ; }",if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) || s -> bit_depth == 1 ) return AVERROR_INVALIDDATA ;,1419
314,"buggy line: print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>failed,<S2SV_blank>won\\\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" ) ;if ( as_console ) {cwe id:CWE-399context: int cib_connect ( gboolean full ) { int rc = pcmk_ok ; static gboolean need_pass = TRUE ; CRM_CHECK ( cib != NULL , return - EINVAL ) ; if ( getenv ( ""CIB_passwd"" ) != NULL ) { need_pass = FALSE ; } if ( watch_fencing && st == NULL ) { st = stonith_api_new ( ) ; } if ( watch_fencing && st -> state == stonith_disconnected ) { crm_trace ( ""Connecting<S2SV_blank>to<S2SV_blank>stonith"" ) ; rc = st -> cmds -> connect ( st , crm_system_name , NULL ) ; if ( rc == pcmk_ok ) { crm_trace ( ""Setting<S2SV_blank>up<S2SV_blank>stonith<S2SV_blank>callbacks"" ) ; st -> cmds -> register_notification ( st , T_STONITH_NOTIFY_FENCE , mon_st_callback ) ; } } if ( cib -> state != cib_connected_query && cib -> state != cib_connected_command ) { crm_trace ( ""Connecting<S2SV_blank>to<S2SV_blank>the<S2SV_blank>CIB"" ) ; if ( as_console && need_pass && cib -> variant == cib_remote ) { need_pass = FALSE ; print_as ( ""Password:"" ) ; } rc = cib -> cmds -> signon ( cib , crm_system_name , cib_query ) ; if ( rc != pcmk_ok ) { return rc ; } current_cib = get_cib_copy ( cib ) ; mon_refresh_display ( NULL ) ; if ( full ) { if ( rc == pcmk_ok ) { rc = cib -> cmds -> set_connection_dnotify ( cib , mon_cib_connection_destroy ) ; if ( rc == - EPROTONOSUPPORT ) {  print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>failed,<S2SV_blank>won\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" ) ;  if ( as_console ) { sleep ( 2 ) ; } rc = pcmk_ok ; } } if ( rc == pcmk_ok ) { cib -> cmds -> del_notify_callback ( cib , T_CIB_DIFF_NOTIFY , crm_diff_update ) ; rc = cib -> cmds -> add_notify_callback ( cib , T_CIB_DIFF_NOTIFY , crm_diff_update ) ; } if ( rc != pcmk_ok ) { print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>failed,<S2SV_blank>could<S2SV_blank>not<S2SV_blank>monitor<S2SV_blank>CIB<S2SV_blank>actions"" ) ; if ( as_console ) { sleep ( 2 ) ; } clean_up ( - rc ) ; } } } return rc ; }","print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>won\\\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" ) ;if ( as_console ) {",1420
315,"buggy line: dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ;dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ;cwe id:CWE-358context: static void DefragTrackerInit ( DefragTracker * dt , Packet * p ) { COPY_ADDRESS ( & p -> src , & dt -> src_addr ) ; COPY_ADDRESS ( & p -> dst , & dt -> dst_addr ) ; if ( PKT_IS_IPV4 ( p ) ) { dt -> id = ( int32_t ) IPV4_GET_IPID ( p ) ; dt -> af = AF_INET ; } else { dt -> id = ( int32_t ) IPV6_EXTHDR_GET_FH_ID ( p ) ; dt -> af = AF_INET6 ; }  dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ;  dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ; dt -> policy = DefragGetOsPolicy ( p ) ; dt -> host_timeout = DefragPolicyGetHostTimeout ( p ) ; dt -> remove = 0 ; dt -> seen_last = 0 ; TAILQ_INIT ( & dt -> frags ) ; ( void ) DefragTrackerIncrUsecnt ( dt ) ; }",dt -> proto = IP_GET_IPPROTO ( p ) ;dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ;dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ;,1421
316,"buggy line: status = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHSR ) ;if ( ( status & RXFHSR_RXFV ) != 0 )  {if ( ( status & ( RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE ) ) == 0 )  {n = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHBCR ) & RXFHBCR_RXBC_MASK ;if ( n > 0 && n <= ETH_MAX_FRAME_SIZE ) {ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ;ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ;ksz8851ReadFifo ( interface , context -> rxBuffer , n ) ;ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ;ancillary = NET_DEFAULT_RX_ANCILLARY ;ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_RRXEF ) ;return ERROR_INVALID_PACKET ;cwe id:CWE-20context: error_t ksz8851ReceivePacket ( NetInterface * interface ) { size_t n ; uint16_t status ; Ksz8851Context * context ; NetRxAncillary ancillary ; context = ( Ksz8851Context * ) interface -> nicContext ;  status = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHSR ) ;   if ( ( status & RXFHSR_RXFV ) != 0 )  {  if ( ( status & ( RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE ) ) == 0 )  {  n = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHBCR ) & RXFHBCR_RXBC_MASK ;  if ( n > 0 && n <= ETH_MAX_FRAME_SIZE ) {  ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ;   ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ;  ksz8851ReadFifo ( interface , context -> rxBuffer , n ) ;  ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ;  ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; return NO_ERROR ; } } }  ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_RRXEF ) ;  return ERROR_INVALID_PACKET ; }","status = ksz8851ReadReg ( interface , KSZ8851_RXFHSR ) ;if ( ( status & KSZ8851_RXFHSR_RXFV ) != 0 ) {if ( ( status & ( KSZ8851_RXFHSR_RXMR | KSZ8851_RXFHSR_RXFTL | KSZ8851_RXFHSR_RXRF | KSZ8851_RXFHSR_RXCE ) ) == 0 ) {n = ksz8851ReadReg ( interface , KSZ8851_RXFHBCR ) & KSZ8851_RXFHBCR_RXBC ;if ( n > 0 && n <= ETH_MAX_FRAME_SIZE ) {ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ;ksz8851SetBit ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA ) ;ksz8851ReadFifo ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA ) ;ancillary = NET_DEFAULT_RX_ANCILLARY ;ksz8851SetBit ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RRXEF ) ;return ERROR_INVALID_PACKET ;",1422
317,"buggy line: static stmt_ty  ast_for_funcdef_impl ( struct compiling * c , const node * n ,   asdl_seq * decorator_seq , int is_async )   {identifier name ;cwe id:CWE-125context: static stmt_ty  ast_for_funcdef_impl ( struct compiling * c , const node * n ,   asdl_seq * decorator_seq , int is_async )   {  identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async<S2SV_blank>functions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.5<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns ,  type_comment , LINENO ( n ) ,  n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }","static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n0 , asdl_seq * decorator_seq , int is_async ) {const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ;identifier name ;",1423
318,"buggy line: if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns ,  type_comment , LINENO ( n ) ,  n -> n_col_offset , c -> c_arena ) ;cwe id:CWE-125context: static stmt_ty  ast_for_funcdef_impl ( struct compiling * c , const node * n ,   asdl_seq * decorator_seq , int is_async )   {  identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async<S2SV_blank>functions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.5<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns ,  type_comment , LINENO ( n ) ,  n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }","if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , c -> c_arena ) ;",1423
319,"buggy line: pgd = pgd_offset ( mm , 0xA0000 ) ;if ( pgd_none_or_clear_bad ( pgd ) ) goto out ;cwe id:CWE-264context: static void mark_screen_rdonly ( struct mm_struct * mm ) { pgd_t * pgd ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; spinlock_t * ptl ; int i ;  pgd = pgd_offset ( mm , 0xA0000 ) ;  if ( pgd_none_or_clear_bad ( pgd ) ) goto out ; pud = pud_offset ( pgd , 0xA0000 ) ; if ( pud_none_or_clear_bad ( pud ) ) goto out ; pmd = pmd_offset ( pud , 0xA0000 ) ; split_huge_page_pmd ( mm , pmd ) ; if ( pmd_none_or_clear_bad ( pmd ) ) goto out ; pte = pte_offset_map_lock ( mm , pmd , 0xA0000 , & ptl ) ; for ( i = 0 ; i < 32 ; i ++ ) { if ( pte_present ( * pte ) ) set_pte ( pte , pte_wrprotect ( * pte ) ) ; pte ++ ; } pte_unmap_unlock ( pte , ptl ) ; out :  flush_tlb ( ) ;  }","down_write ( & mm -> mmap_sem ) ;pgd = pgd_offset ( mm , 0xA0000 ) ;if ( pgd_none_or_clear_bad ( pgd ) ) goto out ;",1424
320,"buggy line: out :  flush_tlb ( ) ;}cwe id:CWE-264context: static void mark_screen_rdonly ( struct mm_struct * mm ) { pgd_t * pgd ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; spinlock_t * ptl ; int i ;  pgd = pgd_offset ( mm , 0xA0000 ) ;  if ( pgd_none_or_clear_bad ( pgd ) ) goto out ; pud = pud_offset ( pgd , 0xA0000 ) ; if ( pud_none_or_clear_bad ( pud ) ) goto out ; pmd = pmd_offset ( pud , 0xA0000 ) ; split_huge_page_pmd ( mm , pmd ) ; if ( pmd_none_or_clear_bad ( pmd ) ) goto out ; pte = pte_offset_map_lock ( mm , pmd , 0xA0000 , & ptl ) ; for ( i = 0 ; i < 32 ; i ++ ) { if ( pte_present ( * pte ) ) set_pte ( pte , pte_wrprotect ( * pte ) ) ; pte ++ ; } pte_unmap_unlock ( pte , ptl ) ; out :  flush_tlb ( ) ;  }",out : up_write ( & mm -> mmap_sem ) ;flush_tlb ( ) ;},1424
321,"buggy line: return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL ,  & sa , NULL ) ;cwe id:CWE-20context: static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { char * command , * args = value ; size_t arg_size ; int error ; if ( size == 0 ) return - EINVAL ; if ( args [ size - 1 ] != '\\0' ) { if ( size == PAGE_SIZE ) return - EINVAL ; args [ size ] = '\\0' ; } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else if ( strcmp ( command , ""permipc"" ) == 0 ) { error = aa_setprocattr_permipc ( args ) ; } else { struct common_audit_data sa ; COMMON_AUDIT_DATA_INIT ( & sa , NONE ) ; sa . aad . op = OP_SETPROCATTR ; sa . aad . info = name ; sa . aad . error = - EINVAL ;  return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL ,  & sa , NULL ) ; } } else if ( strcmp ( name , ""exec"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ; } else { return - EINVAL ; } if ( ! error ) error = size ; return error ; }","return aa_audit ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL ) ;",1425
322,"buggy line: cstate = 0 ;if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) {return - 1 ;}if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth ||  ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) {return - 1 ;if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) {jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\\return - 1 ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;if ( jas_stream_eof ( in ) ) {jas_free ( siz -> comps ) ;return - 1 ;}return 0 ;}cwe id:CWE-20context: static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ;  cstate = 0 ;  if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) {  return - 1 ;  }  if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth ||  ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n"" ) ; return - 1 ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { jas_free ( siz -> comps ) ; return - 1 ; } return 0 ; }","siz -> comps = 0 ;cstate = 0 ;if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) {goto error ;if ( ! siz -> width || ! siz -> height ) {jas_eprintf ( ""reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\\goto error ;}if ( ! siz -> tilewidth || ! siz -> tileheight ) {jas_eprintf ( ""tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\\goto error ;}if ( ! siz -> numcomps || siz -> numcomps > 16384 ) {jas_eprintf ( ""number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> xoff >= siz -> width ) {jas_eprintf ( ""XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> yoff >= siz -> height ) {jas_eprintf ( ""YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) {jas_eprintf ( ""XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) {jas_eprintf ( ""YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;goto error ;goto error ;goto error ;goto error ;",1426
323,"buggy line: ptr_check_result = sn_coap_parser_check_packet_ptr ( * packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ;if ( 0 != ptr_check_result ) {tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ;dst_coap_msg_ptr -> token_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , dst_coap_msg_ptr -> token_len ) ;if ( dst_coap_msg_ptr -> token_ptr == NULL ) {tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>token!"" ) ;return - 1 ;}message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ;}while ( message_left && ( * * packet_data_pptr != 0xff ) ) {uint16_t option_len = ( * * packet_data_pptr & 0x0F ) ;uint16_t option_number = ( * * packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT ) ;message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ;int8_t option_parse_result ;option_number += previous_option_number ;option_parse_result = parse_ext_option ( & option_len , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ;case COAP_OPTION_MAX_AGE : case COAP_OPTION_PROXY_URI : case COAP_OPTION_ETAG : case COAP_OPTION_URI_HOST : case COAP_OPTION_LOCATION_PATH : case COAP_OPTION_URI_PORT : case COAP_OPTION_LOCATION_QUERY : case COAP_OPTION_OBSERVE : case COAP_OPTION_URI_QUERY : case COAP_OPTION_BLOCK2 : case COAP_OPTION_BLOCK1 : case COAP_OPTION_ACCEPT : case COAP_OPTION_SIZE1 : case COAP_OPTION_SIZE2 : if ( sn_coap_parser_alloc_options ( handle , dst_coap_msg_ptr ) == NULL ) {cwe id:CWE-401context: static int8_t sn_coap_parser_options_parse ( struct coap_s * handle , uint8_t * * packet_data_pptr , sn_coap_hdr_s * dst_coap_msg_ptr , uint8_t * packet_data_start_ptr , uint16_t packet_len ) { uint8_t previous_option_number = 0 ; int8_t ret_status = 0 ; uint16_t message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; dst_coap_msg_ptr -> token_len = * packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK ; if ( dst_coap_msg_ptr -> token_len ) { int8_t ptr_check_result ; if ( ( dst_coap_msg_ptr -> token_len > 8 ) || dst_coap_msg_ptr -> token_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>token<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } ptr_check_result = sn_coap_parser_check_packet_ptr ( * packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; if ( 0 != ptr_check_result ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } dst_coap_msg_ptr -> token_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , dst_coap_msg_ptr -> token_len ) ; if ( dst_coap_msg_ptr -> token_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>token!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; } while ( message_left && ( * * packet_data_pptr != 0xff ) ) { uint16_t option_len = ( * * packet_data_pptr & 0x0F ) ; uint16_t option_number = ( * * packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT ) ; message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; int8_t option_parse_result ; option_parse_result = parse_ext_option ( & option_number , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; }  option_number += previous_option_number ;  option_parse_result = parse_ext_option ( & option_len , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; } previous_option_number = option_number ; switch ( option_number ) { case COAP_OPTION_MAX_AGE : case COAP_OPTION_PROXY_URI : case COAP_OPTION_ETAG : case COAP_OPTION_URI_HOST : case COAP_OPTION_LOCATION_PATH : case COAP_OPTION_URI_PORT : case COAP_OPTION_LOCATION_QUERY : case COAP_OPTION_OBSERVE : case COAP_OPTION_URI_QUERY : case COAP_OPTION_BLOCK2 : case COAP_OPTION_BLOCK1 : case COAP_OPTION_ACCEPT : case COAP_OPTION_SIZE1 : case COAP_OPTION_SIZE2 : if ( sn_coap_parser_alloc_options ( handle , dst_coap_msg_ptr ) == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>options!"" ) ; return - 1 ; } break ; } if ( message_left < option_len ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>would<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>parsing<S2SV_blank>options!"" ) ; return - 1 ; } switch ( option_number ) { case COAP_OPTION_CONTENT_FORMAT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> content_format != COAP_CT_NONE ) ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_CONTENT_FORMAT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> content_format = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_MAX_AGE : if ( option_len > 4 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_MAX_AGE<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> max_age = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_PROXY_URI : if ( ( option_len > 1034 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>allocation<S2SV_blank>failed!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_ETAG :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr ,  message_left , & dst_coap_msg_ptr -> options_list_ptr -> etag_ptr , ( uint16_t * ) & dst_coap_msg_ptr -> options_list_ptr -> etag_len , COAP_OPTION_ETAG , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_HOST : if ( ( option_len > 255 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_host_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>allocation<S2SV_blank>failed!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_LOCATION_PATH : if ( dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>exists!"" ) ; return - 1 ; } ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_path_len , COAP_OPTION_LOCATION_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PORT : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_port != COAP_OPTION_URI_PORT_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PORT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_port = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_LOCATION_QUERY :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left ,  & dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_query_len , COAP_OPTION_LOCATION_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PATH :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left ,  & dst_coap_msg_ptr -> uri_path_ptr , & dst_coap_msg_ptr -> uri_path_len , COAP_OPTION_URI_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_OBSERVE : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> observe != COAP_OBSERVE_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_OBSERVE<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> observe = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_URI_QUERY : ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_len , COAP_OPTION_URI_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_QUERY<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_BLOCK2 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block2 != COAP_OPTION_BLOCK_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK2<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_BLOCK1 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block1 != COAP_OPTION_BLOCK_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK1<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_ACCEPT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> options_list_ptr -> accept != COAP_CT_NONE ) ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ACCEPT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> accept = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE1 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size1 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE1<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size1 = true ; dst_coap_msg_ptr -> options_list_ptr -> size1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE2 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size2 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE2<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size2 = true ; dst_coap_msg_ptr -> options_list_ptr -> size2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; default : tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>option!"" ) ; return - 1 ; } if ( ( * packet_data_pptr - packet_data_start_ptr ) > packet_len ) { return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; } return 0 ; }","if ( sn_coap_parser_add_u16_limit ( option_number , previous_option_number , & option_number ) != 0 ) {option_number += previous_option_number ;option_parse_result = parse_ext_option ( & option_len , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ;case COAP_OPTION_MAX_AGE : case COAP_OPTION_PROXY_URI : case COAP_OPTION_ETAG : if ( dst_coap_msg_ptr -> options_list_ptr -> etag_ptr ) {tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>exists!"" ) ;return - 1 ;}case COAP_OPTION_URI_HOST : case COAP_OPTION_LOCATION_PATH : case COAP_OPTION_URI_PORT : case COAP_OPTION_LOCATION_QUERY : if ( dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr ) {tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>exists!"" ) ;return - 1 ;}case COAP_OPTION_OBSERVE : case COAP_OPTION_URI_QUERY : case COAP_OPTION_BLOCK2 : case COAP_OPTION_BLOCK1 : case COAP_OPTION_ACCEPT : case COAP_OPTION_SIZE1 : case COAP_OPTION_SIZE2 : if ( sn_coap_parser_alloc_options ( handle , dst_coap_msg_ptr ) == NULL ) {",1427
324,"buggy line: case COAP_OPTION_ETAG :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr ,  message_left , & dst_coap_msg_ptr -> options_list_ptr -> etag_ptr , ( uint16_t * ) & dst_coap_msg_ptr -> options_list_ptr -> etag_len , COAP_OPTION_ETAG , option_len ) ;cwe id:CWE-401context: static int8_t sn_coap_parser_options_parse ( struct coap_s * handle , uint8_t * * packet_data_pptr , sn_coap_hdr_s * dst_coap_msg_ptr , uint8_t * packet_data_start_ptr , uint16_t packet_len ) { uint8_t previous_option_number = 0 ; int8_t ret_status = 0 ; uint16_t message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; dst_coap_msg_ptr -> token_len = * packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK ; if ( dst_coap_msg_ptr -> token_len ) { int8_t ptr_check_result ; if ( ( dst_coap_msg_ptr -> token_len > 8 ) || dst_coap_msg_ptr -> token_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>token<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } ptr_check_result = sn_coap_parser_check_packet_ptr ( * packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; if ( 0 != ptr_check_result ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } dst_coap_msg_ptr -> token_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , dst_coap_msg_ptr -> token_len ) ; if ( dst_coap_msg_ptr -> token_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>token!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; } while ( message_left && ( * * packet_data_pptr != 0xff ) ) { uint16_t option_len = ( * * packet_data_pptr & 0x0F ) ; uint16_t option_number = ( * * packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT ) ; message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; int8_t option_parse_result ; option_parse_result = parse_ext_option ( & option_number , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; }  option_number += previous_option_number ;  option_parse_result = parse_ext_option ( & option_len , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; } previous_option_number = option_number ; switch ( option_number ) { case COAP_OPTION_MAX_AGE : case COAP_OPTION_PROXY_URI : case COAP_OPTION_ETAG : case COAP_OPTION_URI_HOST : case COAP_OPTION_LOCATION_PATH : case COAP_OPTION_URI_PORT : case COAP_OPTION_LOCATION_QUERY : case COAP_OPTION_OBSERVE : case COAP_OPTION_URI_QUERY : case COAP_OPTION_BLOCK2 : case COAP_OPTION_BLOCK1 : case COAP_OPTION_ACCEPT : case COAP_OPTION_SIZE1 : case COAP_OPTION_SIZE2 : if ( sn_coap_parser_alloc_options ( handle , dst_coap_msg_ptr ) == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>options!"" ) ; return - 1 ; } break ; } if ( message_left < option_len ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>would<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>parsing<S2SV_blank>options!"" ) ; return - 1 ; } switch ( option_number ) { case COAP_OPTION_CONTENT_FORMAT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> content_format != COAP_CT_NONE ) ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_CONTENT_FORMAT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> content_format = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_MAX_AGE : if ( option_len > 4 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_MAX_AGE<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> max_age = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_PROXY_URI : if ( ( option_len > 1034 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>allocation<S2SV_blank>failed!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_ETAG :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr ,  message_left , & dst_coap_msg_ptr -> options_list_ptr -> etag_ptr , ( uint16_t * ) & dst_coap_msg_ptr -> options_list_ptr -> etag_len , COAP_OPTION_ETAG , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_HOST : if ( ( option_len > 255 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_host_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>allocation<S2SV_blank>failed!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_LOCATION_PATH : if ( dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>exists!"" ) ; return - 1 ; } ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_path_len , COAP_OPTION_LOCATION_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PORT : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_port != COAP_OPTION_URI_PORT_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PORT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_port = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_LOCATION_QUERY :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left ,  & dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_query_len , COAP_OPTION_LOCATION_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PATH :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left ,  & dst_coap_msg_ptr -> uri_path_ptr , & dst_coap_msg_ptr -> uri_path_len , COAP_OPTION_URI_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_OBSERVE : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> observe != COAP_OBSERVE_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_OBSERVE<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> observe = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_URI_QUERY : ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_len , COAP_OPTION_URI_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_QUERY<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_BLOCK2 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block2 != COAP_OPTION_BLOCK_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK2<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_BLOCK1 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block1 != COAP_OPTION_BLOCK_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK1<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_ACCEPT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> options_list_ptr -> accept != COAP_CT_NONE ) ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ACCEPT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> accept = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE1 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size1 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE1<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size1 = true ; dst_coap_msg_ptr -> options_list_ptr -> size1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE2 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size2 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE2<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size2 = true ; dst_coap_msg_ptr -> options_list_ptr -> size2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; default : tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>option!"" ) ; return - 1 ; } if ( ( * packet_data_pptr - packet_data_start_ptr ) > packet_len ) { return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; } return 0 ; }","case COAP_OPTION_ETAG : ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> etag_ptr , ( uint16_t * ) & dst_coap_msg_ptr -> options_list_ptr -> etag_len , COAP_OPTION_ETAG , option_len ) ;",1427
325,"buggy line: case COAP_OPTION_LOCATION_QUERY :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left ,  & dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_query_len , COAP_OPTION_LOCATION_QUERY , option_len ) ;case COAP_OPTION_URI_PATH :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left ,  & dst_coap_msg_ptr -> uri_path_ptr , & dst_coap_msg_ptr -> uri_path_len , COAP_OPTION_URI_PATH , option_len ) ;cwe id:CWE-401context: static int8_t sn_coap_parser_options_parse ( struct coap_s * handle , uint8_t * * packet_data_pptr , sn_coap_hdr_s * dst_coap_msg_ptr , uint8_t * packet_data_start_ptr , uint16_t packet_len ) { uint8_t previous_option_number = 0 ; int8_t ret_status = 0 ; uint16_t message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; dst_coap_msg_ptr -> token_len = * packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK ; if ( dst_coap_msg_ptr -> token_len ) { int8_t ptr_check_result ; if ( ( dst_coap_msg_ptr -> token_len > 8 ) || dst_coap_msg_ptr -> token_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>token<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } ptr_check_result = sn_coap_parser_check_packet_ptr ( * packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; if ( 0 != ptr_check_result ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } dst_coap_msg_ptr -> token_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , dst_coap_msg_ptr -> token_len ) ; if ( dst_coap_msg_ptr -> token_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>token!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; } while ( message_left && ( * * packet_data_pptr != 0xff ) ) { uint16_t option_len = ( * * packet_data_pptr & 0x0F ) ; uint16_t option_number = ( * * packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT ) ; message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; int8_t option_parse_result ; option_parse_result = parse_ext_option ( & option_number , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; }  option_number += previous_option_number ;  option_parse_result = parse_ext_option ( & option_len , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; } previous_option_number = option_number ; switch ( option_number ) { case COAP_OPTION_MAX_AGE : case COAP_OPTION_PROXY_URI : case COAP_OPTION_ETAG : case COAP_OPTION_URI_HOST : case COAP_OPTION_LOCATION_PATH : case COAP_OPTION_URI_PORT : case COAP_OPTION_LOCATION_QUERY : case COAP_OPTION_OBSERVE : case COAP_OPTION_URI_QUERY : case COAP_OPTION_BLOCK2 : case COAP_OPTION_BLOCK1 : case COAP_OPTION_ACCEPT : case COAP_OPTION_SIZE1 : case COAP_OPTION_SIZE2 : if ( sn_coap_parser_alloc_options ( handle , dst_coap_msg_ptr ) == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>options!"" ) ; return - 1 ; } break ; } if ( message_left < option_len ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>would<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>parsing<S2SV_blank>options!"" ) ; return - 1 ; } switch ( option_number ) { case COAP_OPTION_CONTENT_FORMAT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> content_format != COAP_CT_NONE ) ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_CONTENT_FORMAT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> content_format = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_MAX_AGE : if ( option_len > 4 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_MAX_AGE<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> max_age = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_PROXY_URI : if ( ( option_len > 1034 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>allocation<S2SV_blank>failed!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_ETAG :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr ,  message_left , & dst_coap_msg_ptr -> options_list_ptr -> etag_ptr , ( uint16_t * ) & dst_coap_msg_ptr -> options_list_ptr -> etag_len , COAP_OPTION_ETAG , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_HOST : if ( ( option_len > 255 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_host_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>allocation<S2SV_blank>failed!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_LOCATION_PATH : if ( dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>exists!"" ) ; return - 1 ; } ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_path_len , COAP_OPTION_LOCATION_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PORT : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_port != COAP_OPTION_URI_PORT_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PORT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_port = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_LOCATION_QUERY :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left ,  & dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_query_len , COAP_OPTION_LOCATION_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PATH :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left ,  & dst_coap_msg_ptr -> uri_path_ptr , & dst_coap_msg_ptr -> uri_path_len , COAP_OPTION_URI_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_OBSERVE : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> observe != COAP_OBSERVE_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_OBSERVE<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> observe = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_URI_QUERY : ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_len , COAP_OPTION_URI_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_QUERY<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_BLOCK2 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block2 != COAP_OPTION_BLOCK_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK2<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_BLOCK1 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block1 != COAP_OPTION_BLOCK_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK1<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_ACCEPT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> options_list_ptr -> accept != COAP_CT_NONE ) ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ACCEPT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> accept = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE1 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size1 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE1<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size1 = true ; dst_coap_msg_ptr -> options_list_ptr -> size1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE2 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size2 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE2<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size2 = true ; dst_coap_msg_ptr -> options_list_ptr -> size2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; default : tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>option!"" ) ; return - 1 ; } if ( ( * packet_data_pptr - packet_data_start_ptr ) > packet_len ) { return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; } return 0 ; }","case COAP_OPTION_LOCATION_QUERY : ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_query_len , COAP_OPTION_LOCATION_QUERY , option_len ) ;case COAP_OPTION_URI_PATH : if ( dst_coap_msg_ptr -> uri_path_ptr ) {tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>exists!"" ) ;return - 1 ;}ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> uri_path_ptr , & dst_coap_msg_ptr -> uri_path_len , COAP_OPTION_URI_PATH , option_len ) ;",1427
326,"buggy line: if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) {goto _xmi_end ;cwe id:CWE-125context: struct _mdi * _WM_ParseNewXmi ( uint8_t * xmi_data , uint32_t xmi_size ) { struct _mdi * xmi_mdi = NULL ; uint32_t xmi_tmpdata = 0 ; uint8_t xmi_formcnt = 0 ; uint32_t xmi_catlen = 0 ; uint32_t xmi_subformlen = 0 ; uint32_t i = 0 ; uint32_t j = 0 ; uint32_t xmi_evntlen = 0 ; uint32_t xmi_divisions = 60 ; uint32_t xmi_tempo = 500000 ; uint32_t xmi_sample_count = 0 ; float xmi_sample_count_f = 0.0 ; float xmi_sample_remainder = 0.0 ; float xmi_samples_per_delta_f = 0.0 ; uint8_t xmi_ch = 0 ; uint8_t xmi_note = 0 ; uint32_t * xmi_notelen = NULL ; uint32_t setup_ret = 0 ; uint32_t xmi_delta = 0 ; uint32_t xmi_lowestdelta = 0 ; uint32_t xmi_evnt_cnt = 0 ; if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XDIRINFO"" , 8 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 8 ; xmi_size -= 8 ; xmi_data += 4 ; xmi_size -= 4 ; xmi_formcnt = * xmi_data ++ ; if ( xmi_formcnt == 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_size -- ; xmi_tmpdata -= 13 ; xmi_data += xmi_tmpdata ; xmi_size -= xmi_tmpdata ; if ( memcmp ( xmi_data , ""CAT<S2SV_blank>"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_catlen = * xmi_data ++ << 24 ; xmi_catlen |= * xmi_data ++ << 16 ; xmi_catlen |= * xmi_data ++ << 8 ; xmi_catlen |= * xmi_data ++ ; xmi_size -= 4 ; UNUSED ( xmi_catlen ) ; if ( memcmp ( xmi_data , ""XMID"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( xmi_mdi , xmi_divisions ) ; _WM_midi_setup_tempo ( xmi_mdi , xmi_tempo ) ; xmi_samples_per_delta_f = _WM_GetSamplesPerTick ( xmi_divisions , xmi_tempo ) ; xmi_notelen = malloc ( sizeof ( uint32_t ) * 16 * 128 ) ; memset ( xmi_notelen , 0 , ( sizeof ( uint32_t ) * 16 * 128 ) ) ; for ( i = 0 ; i < xmi_formcnt ; i ++ ) { if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_subformlen = * xmi_data ++ << 24 ; xmi_subformlen |= * xmi_data ++ << 16 ; xmi_subformlen |= * xmi_data ++ << 8 ; xmi_subformlen |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XMID"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_subformlen -= 4 ; do { if ( ! memcmp ( xmi_data , ""TIMB"" , 4 ) ) { xmi_data += 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_data += xmi_tmpdata ; xmi_size -= ( 8 + xmi_tmpdata ) ; xmi_subformlen -= ( 8 + xmi_tmpdata ) ; } else if ( ! memcmp ( xmi_data , ""RBRN"" , 4 ) ) { xmi_data += 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_data += xmi_tmpdata ; xmi_size -= ( 8 + xmi_tmpdata ) ; xmi_subformlen -= ( 8 + xmi_tmpdata ) ; } else if ( ! memcmp ( xmi_data , ""EVNT"" , 4 ) ) { xmi_data += 4 ; xmi_evnt_cnt ++ ; xmi_evntlen = * xmi_data ++ << 24 ; xmi_evntlen |= * xmi_data ++ << 16 ; xmi_evntlen |= * xmi_data ++ << 8 ; xmi_evntlen |= * xmi_data ++ ; xmi_size -= 8 ; xmi_subformlen -= 8 ; do { if ( * xmi_data < 0x80 ) { xmi_delta = 0 ; if ( * xmi_data > 0x7f ) { while ( * xmi_data > 0x7f ) { xmi_delta = ( xmi_delta << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; } } xmi_delta = ( xmi_delta << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; do { if ( ( xmi_lowestdelta != 0 ) && ( xmi_lowestdelta <= xmi_delta ) ) { xmi_tmpdata = xmi_lowestdelta ; } else { xmi_tmpdata = xmi_delta ; } xmi_sample_count_f = ( ( ( float ) xmi_tmpdata * xmi_samples_per_delta_f ) + xmi_sample_remainder ) ; xmi_sample_count = ( uint32_t ) xmi_sample_count_f ; xmi_sample_remainder = xmi_sample_count_f - ( float ) xmi_sample_count ; xmi_mdi -> events [ xmi_mdi -> event_count - 1 ] . samples_to_next += xmi_sample_count ; xmi_mdi -> extra_info . approx_total_samples += xmi_sample_count ; xmi_lowestdelta = 0 ; for ( j = 0 ; j < ( 16 * 128 ) ; j ++ ) { if ( xmi_notelen [ j ] == 0 ) continue ; xmi_notelen [ j ] -= xmi_tmpdata ; if ( xmi_notelen [ j ] == 0 ) { xmi_ch = j / 128 ; xmi_note = j - ( xmi_ch * 128 ) ; _WM_midi_setup_noteoff ( xmi_mdi , xmi_ch , xmi_note , 0 ) ; } else { if ( ( xmi_lowestdelta == 0 ) || ( xmi_lowestdelta > xmi_notelen [ j ] ) ) { xmi_lowestdelta = xmi_notelen [ j ] ; } } } xmi_delta -= xmi_tmpdata ; } while ( xmi_delta ) ; } else { if ( ( xmi_data [ 0 ] == 0xff ) && ( xmi_data [ 1 ] == 0x51 ) && ( xmi_data [ 2 ] == 0x03 ) ) { setup_ret = 6 ; goto _XMI_Next_Event ; }  if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) {  goto _xmi_end ; } if ( ( * xmi_data & 0xf0 ) == 0x90 ) { xmi_ch = * xmi_data & 0x0f ; xmi_note = xmi_data [ 1 ] ; xmi_data += setup_ret ; xmi_size -= setup_ret ; xmi_evntlen -= setup_ret ; xmi_subformlen -= setup_ret ; xmi_tmpdata = 0 ; if ( * xmi_data > 0x7f ) { while ( * xmi_data > 0x7f ) { xmi_tmpdata = ( xmi_tmpdata << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; } } xmi_tmpdata = ( xmi_tmpdata << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; xmi_notelen [ 128 * xmi_ch + xmi_note ] = xmi_tmpdata ; if ( ( xmi_tmpdata > 0 ) && ( ( xmi_lowestdelta == 0 ) || ( xmi_tmpdata < xmi_lowestdelta ) ) ) { xmi_lowestdelta = xmi_tmpdata ; } } else { _XMI_Next_Event : xmi_data += setup_ret ; xmi_size -= setup_ret ; xmi_evntlen -= setup_ret ; xmi_subformlen -= setup_ret ; } } } while ( xmi_evntlen ) ; } else { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } } while ( xmi_subformlen ) ; } if ( ( xmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _xmi_end ; } xmi_mdi -> extra_info . current_sample = 0 ; xmi_mdi -> current_event = & xmi_mdi -> events [ 0 ] ; xmi_mdi -> samples_to_mix = 0 ; xmi_mdi -> note = NULL ; if ( xmi_evnt_cnt > 1 ) { xmi_mdi -> is_type2 = 1 ; } _WM_ResetToStart ( xmi_mdi ) ; _xmi_end : if ( xmi_notelen != NULL ) free ( xmi_notelen ) ; if ( xmi_mdi -> reverb ) return ( xmi_mdi ) ; _WM_freeMDI ( xmi_mdi ) ; return NULL ; }","if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , xmi_size , 0 ) ) == 0 ) {goto _xmi_end ;",1428
327,"buggy line: total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) )  return 0 ;do_wakeup = 0 ;cwe id:CWE-17context: static ssize_t pipe_read ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t pos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; int do_wakeup ; ssize_t ret ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ;  total_len = iov_length ( iov , nr_segs ) ;  if ( unlikely ( total_len == 0 ) )  return 0 ;  do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; for ( ; ; ) { int bufs = pipe -> nrbufs ; if ( bufs ) { int curbuf = pipe -> curbuf ; struct pipe_buffer * buf = pipe -> bufs + curbuf ; const struct pipe_buf_operations * ops = buf -> ops ;  void * addr ;   size_t chars = buf -> len ;   int error , atomic ;  if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe , buf ) ; if ( error ) { if ( ! ret ) ret = error ; break ; }  atomic = ! iov_fault_in_pages_write ( iov , chars ) ;  redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; if ( unlikely ( error ) ) { if ( atomic ) { atomic = 0 ; goto redo ; } if ( ! ret ) ret = error ; break ; } ret += chars ; buf -> offset += chars ; buf -> len -= chars ; if ( buf -> flags & PIPE_BUF_FLAG_PACKET ) { total_len = chars ; buf -> len = 0 ; } if ( ! buf -> len ) { buf -> ops = NULL ; ops -> release ( pipe , buf ) ; curbuf = ( curbuf + 1 ) & ( pipe -> buffers - 1 ) ; pipe -> curbuf = curbuf ; pipe -> nrbufs = -- bufs ; do_wakeup = 1 ; } total_len -= chars ; if ( ! total_len ) break ; } if ( bufs ) continue ; if ( ! pipe -> writers ) break ; if ( ! pipe -> waiting_writers ) { if ( ret ) break ; if ( filp -> f_flags & O_NONBLOCK ) { ret = - EAGAIN ; break ; } } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } pipe_wait ( pipe ) ; } __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } if ( ret > 0 ) file_accessed ( filp ) ; return ret ; }","struct iov_iter iter ;total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) ) return 0 ;iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) ;do_wakeup = 0 ;",1429
328,"buggy line: void * addr ;size_t chars = buf -> len ;int error , atomic ;if ( chars > total_len ) chars = total_len ;atomic = ! iov_fault_in_pages_write ( iov , chars ) ;redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ;else addr = kmap ( buf -> page ) ;error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ;if ( atomic ) kunmap_atomic ( addr ) ;else kunmap ( buf -> page ) ;if ( unlikely ( error ) ) {if ( atomic ) {atomic = 0 ;goto redo ;}if ( ! ret ) ret = error ;cwe id:CWE-17context: static ssize_t pipe_read ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t pos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; int do_wakeup ; ssize_t ret ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ;  total_len = iov_length ( iov , nr_segs ) ;  if ( unlikely ( total_len == 0 ) )  return 0 ;  do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; for ( ; ; ) { int bufs = pipe -> nrbufs ; if ( bufs ) { int curbuf = pipe -> curbuf ; struct pipe_buffer * buf = pipe -> bufs + curbuf ; const struct pipe_buf_operations * ops = buf -> ops ;  void * addr ;   size_t chars = buf -> len ;   int error , atomic ;  if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe , buf ) ; if ( error ) { if ( ! ret ) ret = error ; break ; }  atomic = ! iov_fault_in_pages_write ( iov , chars ) ;  redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; if ( unlikely ( error ) ) { if ( atomic ) { atomic = 0 ; goto redo ; } if ( ! ret ) ret = error ; break ; } ret += chars ; buf -> offset += chars ; buf -> len -= chars ; if ( buf -> flags & PIPE_BUF_FLAG_PACKET ) { total_len = chars ; buf -> len = 0 ; } if ( ! buf -> len ) { buf -> ops = NULL ; ops -> release ( pipe , buf ) ; curbuf = ( curbuf + 1 ) & ( pipe -> buffers - 1 ) ; pipe -> curbuf = curbuf ; pipe -> nrbufs = -- bufs ; do_wakeup = 1 ; } total_len -= chars ; if ( ! total_len ) break ; } if ( bufs ) continue ; if ( ! pipe -> writers ) break ; if ( ! pipe -> waiting_writers ) { if ( ret ) break ; if ( filp -> f_flags & O_NONBLOCK ) { ret = - EAGAIN ; break ; } } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } pipe_wait ( pipe ) ; } __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } if ( ret > 0 ) file_accessed ( filp ) ; return ret ; }","size_t chars = buf -> len ;size_t written ;int error ;if ( chars > total_len ) chars = total_len ;written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ;if ( unlikely ( written < chars ) ) {if ( ! ret ) ret = - EFAULT ;",1429
329,"buggy line: # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) {cwe id:CWE-787context: static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } }  IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;  p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ;  next_pixel = MagickFalse ;  displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }",# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) # define GIFOutputCode ( code ) \\\\\,1430
330,"buggy line: }IndexPacket index ;cwe id:CWE-787context: static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } }  IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;  p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ;  next_pixel = MagickFalse ;  displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }",\\\\\IndexPacket index ;,1430
331,"buggy line: cwe id:CWE-787context: static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } }  IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;  p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ;  next_pixel = MagickFalse ;  displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }",next_pixel = MagickFalse ;displacement = 1 ;,1430
332,"buggy line: index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;p ++ ;next_pixel = MagickFalse ;displacement = 1 ;cwe id:CWE-787context: static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } }  IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;  p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ;  next_pixel = MagickFalse ;  displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }",index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;p ++ ;if ( k < 0 ) continue ;,1430
333,"buggy line: passert ( GLOBALS_ARE_RESET ( ) ) ;}cwe id:CWE-20context: static void ikev2_parent_inI2outR2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inI2outR2:<S2SV_blank>calculating<S2SV_blank>g^{xy},<S2SV_blank>sending<S2SV_blank>R2"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI2outR2_tail ( pcrc , r ) ; if ( e > STF_FAIL ) { int v2_notify_num = e - STF_FAIL ; DBG_log ( ""ikev2_parent_inI2outR2_tail<S2SV_blank>returned<S2SV_blank>STF_FAIL<S2SV_blank>with<S2SV_blank>%s"" , enum_name ( & ikev2_notify_names , v2_notify_num ) ) ; } else if ( e != STF_OK ) { DBG_log ( ""ikev2_parent_inI2outR2_tail<S2SV_blank>returned<S2SV_blank>%s"" , enum_name ( & stfstatus_name , e ) ) ; } if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ;  passert ( GLOBALS_ARE_RESET ( ) ) ;  }",},1431
334,"buggy line: p_fm_config_conx_hdlt hdl ;int instance = 0 ;cwe id:CWE-362context: int main ( int argc , char * argv [ ] ) {  p_fm_config_conx_hdlt hdl ;  int instance = 0 ; fm_mgr_config_errno_t res ; char * rem_addr = NULL ; char * community = ""public"" ; char Opts [ 256 ] ; int arg ; char * command ; int i ; strcpy ( Opts , ""i:d:h-"" ) ; while ( ( arg = getopt ( argc , argv , Opts ) ) != EOF ) { switch ( arg ) { case 'h' : case '-' : usage ( argv [ 0 ] ) ; return ( 0 ) ; case 'i' : instance = atol ( optarg ) ; break ; case 'd' : rem_addr = optarg ; break ; default : usage ( argv [ 0 ] ) ; return ( - 1 ) ; } } if ( optind >= argc ) { fprintf ( stderr , ""Command<S2SV_blank>required\\n"" ) ; usage ( argv [ 0 ] ) ; return - 1 ; } command = argv [ optind ++ ] ; printf ( ""Connecting<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>FM<S2SV_blank>instance<S2SV_blank>%d\\n"" , ( rem_addr == NULL ) ? ""LOCAL"" : rem_addr , instance ) ; if ( ( res = fm_mgr_config_init ( & hdl , instance , rem_addr , community ) ) != FM_CONF_OK ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>the<S2SV_blank>client<S2SV_blank>handle:<S2SV_blank>%d\\n"" , res ) ;  goto die_clean ;  } if ( ( res = fm_mgr_config_connect ( hdl ) ) != FM_CONF_OK ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>connect:<S2SV_blank>(%d)<S2SV_blank>%s\\n"" , res , fm_mgr_get_error_str ( res ) ) ;  goto die_clean ;  } for ( i = 0 ; i < commandListLen ; i ++ ) { if ( strcmp ( command , commandList [ i ] . name ) == 0 ) {  return commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ;   }  } fprintf ( stderr , ""Command<S2SV_blank>(%s)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>valid\\n"" , command ) ; usage ( argv [ 0 ] ) ; res = - 1 ;  die_clean :  if ( hdl ) free ( hdl ) ;  return res ;  }",p_fm_config_conx_hdlt hdl = NULL ;int instance = 0 ;,1432
335,"buggy line: goto die_clean ;}goto die_clean ;}return commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ;}}die_clean :  if ( hdl ) free ( hdl ) ;return res ;}cwe id:CWE-362context: int main ( int argc , char * argv [ ] ) {  p_fm_config_conx_hdlt hdl ;  int instance = 0 ; fm_mgr_config_errno_t res ; char * rem_addr = NULL ; char * community = ""public"" ; char Opts [ 256 ] ; int arg ; char * command ; int i ; strcpy ( Opts , ""i:d:h-"" ) ; while ( ( arg = getopt ( argc , argv , Opts ) ) != EOF ) { switch ( arg ) { case 'h' : case '-' : usage ( argv [ 0 ] ) ; return ( 0 ) ; case 'i' : instance = atol ( optarg ) ; break ; case 'd' : rem_addr = optarg ; break ; default : usage ( argv [ 0 ] ) ; return ( - 1 ) ; } } if ( optind >= argc ) { fprintf ( stderr , ""Command<S2SV_blank>required\\n"" ) ; usage ( argv [ 0 ] ) ; return - 1 ; } command = argv [ optind ++ ] ; printf ( ""Connecting<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>FM<S2SV_blank>instance<S2SV_blank>%d\\n"" , ( rem_addr == NULL ) ? ""LOCAL"" : rem_addr , instance ) ; if ( ( res = fm_mgr_config_init ( & hdl , instance , rem_addr , community ) ) != FM_CONF_OK ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>the<S2SV_blank>client<S2SV_blank>handle:<S2SV_blank>%d\\n"" , res ) ;  goto die_clean ;  } if ( ( res = fm_mgr_config_connect ( hdl ) ) != FM_CONF_OK ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>connect:<S2SV_blank>(%d)<S2SV_blank>%s\\n"" , res , fm_mgr_get_error_str ( res ) ) ;  goto die_clean ;  } for ( i = 0 ; i < commandListLen ; i ++ ) { if ( strcmp ( command , commandList [ i ] . name ) == 0 ) {  return commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ;   }  } fprintf ( stderr , ""Command<S2SV_blank>(%s)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>valid\\n"" , command ) ; usage ( argv [ 0 ] ) ; res = - 1 ;  die_clean :  if ( hdl ) free ( hdl ) ;  return res ;  }","goto cleanup ;}goto cleanup ;}res = commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ;goto cleanup ;}}cleanup : if ( hdl ) {if ( hdl -> sm_hdl ) {if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ;}if ( hdl -> pm_hdl ) {if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ;}if ( hdl -> fe_hdl ) {if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ;}free ( hdl ) ;}return res ;}",1432
336,"buggy line: if ( jas_init ( ) ) {abort ( ) ;infile = 0 ;verbose = 0 ;cwe id:CWE-190context: int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; char * fmtname ; int debug ; size_t max_mem ;  if ( jas_init ( ) ) {  abort ( ) ; } cmdname = argv [ 0 ] ;  infile = 0 ;  verbose = 0 ; debug = 0 ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) max_mem = JAS_DEFAULT_MAX_MEM_USAGE ; # endif while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( ""%s\\n"" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case OPT_INFILE : infile = jas_optarg ; break ;  case OPT_MAXMEM :  max_mem = strtoull ( jas_optarg , 0 , 10 ) ; break ; case OPT_HELP : default : usage ( ) ; break ; } } jas_setdbglevel ( debug ) ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) jas_set_max_mem_usage ( max_mem ) ; # endif if ( infile ) { if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>input<S2SV_blank>image<S2SV_blank>file<S2SV_blank>%s\\n"" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>standard<S2SV_blank>input\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( ( fmtid = jas_image_getfmt ( instream ) ) < 0 ) { fprintf ( stderr , ""unknown<S2SV_blank>image<S2SV_blank>format\\n"" ) ; }  if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {  jas_stream_close ( instream ) ; fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\n"" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ;  if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {  fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\n"" ) ; } if ( numcmpts ) { width = jas_image_cmptwidth ( image , 0 ) ; height = jas_image_cmptheight ( image , 0 ) ; depth = jas_image_cmptprec ( image , 0 ) ; } else { width = 0 ; height = 0 ; depth = 0 ; }  if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {  abort ( ) ; }  printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ;  jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; return EXIT_SUCCESS ; }","size_t max_samples ;char optstr [ 32 ] ;if ( jas_init ( ) ) {abort ( ) ;max_samples = 64 * JAS_MEBI ;infile = 0 ;verbose = 0 ;case OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ;break ;",1433
337,"buggy line: case OPT_MAXMEM :  max_mem = strtoull ( jas_optarg , 0 , 10 ) ;cwe id:CWE-190context: int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; char * fmtname ; int debug ; size_t max_mem ;  if ( jas_init ( ) ) {  abort ( ) ; } cmdname = argv [ 0 ] ;  infile = 0 ;  verbose = 0 ; debug = 0 ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) max_mem = JAS_DEFAULT_MAX_MEM_USAGE ; # endif while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( ""%s\\n"" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case OPT_INFILE : infile = jas_optarg ; break ;  case OPT_MAXMEM :  max_mem = strtoull ( jas_optarg , 0 , 10 ) ; break ; case OPT_HELP : default : usage ( ) ; break ; } } jas_setdbglevel ( debug ) ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) jas_set_max_mem_usage ( max_mem ) ; # endif if ( infile ) { if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>input<S2SV_blank>image<S2SV_blank>file<S2SV_blank>%s\\n"" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>standard<S2SV_blank>input\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( ( fmtid = jas_image_getfmt ( instream ) ) < 0 ) { fprintf ( stderr , ""unknown<S2SV_blank>image<S2SV_blank>format\\n"" ) ; }  if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {  jas_stream_close ( instream ) ; fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\n"" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ;  if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {  fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\n"" ) ; } if ( numcmpts ) { width = jas_image_cmptwidth ( image , 0 ) ; height = jas_image_cmptheight ( image , 0 ) ; depth = jas_image_cmptprec ( image , 0 ) ; } else { width = 0 ; height = 0 ; depth = 0 ; }  if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {  abort ( ) ; }  printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ;  jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; return EXIT_SUCCESS ; }","case OPT_MAXMEM : max_mem = strtoull ( jas_optarg , 0 , 10 ) ;",1433
338,"buggy line: cwe id:CWE-190context: int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; char * fmtname ; int debug ; size_t max_mem ;  if ( jas_init ( ) ) {  abort ( ) ; } cmdname = argv [ 0 ] ;  infile = 0 ;  verbose = 0 ; debug = 0 ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) max_mem = JAS_DEFAULT_MAX_MEM_USAGE ; # endif while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( ""%s\\n"" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case OPT_INFILE : infile = jas_optarg ; break ;  case OPT_MAXMEM :  max_mem = strtoull ( jas_optarg , 0 , 10 ) ; break ; case OPT_HELP : default : usage ( ) ; break ; } } jas_setdbglevel ( debug ) ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) jas_set_max_mem_usage ( max_mem ) ; # endif if ( infile ) { if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>input<S2SV_blank>image<S2SV_blank>file<S2SV_blank>%s\\n"" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>standard<S2SV_blank>input\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( ( fmtid = jas_image_getfmt ( instream ) ) < 0 ) { fprintf ( stderr , ""unknown<S2SV_blank>image<S2SV_blank>format\\n"" ) ; }  if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {  jas_stream_close ( instream ) ; fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\n"" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ;  if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {  fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\n"" ) ; } if ( numcmpts ) { width = jas_image_cmptwidth ( image , 0 ) ; height = jas_image_cmptheight ( image , 0 ) ; depth = jas_image_cmptprec ( image , 0 ) ; } else { width = 0 ; height = 0 ; depth = 0 ; }  if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {  abort ( ) ; }  printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ;  jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; return EXIT_SUCCESS ; }","snprintf ( optstr , sizeof ( optstr ) , ""max_samples=%-zu"" , max_samples ) ;",1433
339,"buggy line: if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {jas_stream_close ( instream ) ;if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\\cwe id:CWE-190context: int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; char * fmtname ; int debug ; size_t max_mem ;  if ( jas_init ( ) ) {  abort ( ) ; } cmdname = argv [ 0 ] ;  infile = 0 ;  verbose = 0 ; debug = 0 ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) max_mem = JAS_DEFAULT_MAX_MEM_USAGE ; # endif while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( ""%s\\n"" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case OPT_INFILE : infile = jas_optarg ; break ;  case OPT_MAXMEM :  max_mem = strtoull ( jas_optarg , 0 , 10 ) ; break ; case OPT_HELP : default : usage ( ) ; break ; } } jas_setdbglevel ( debug ) ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) jas_set_max_mem_usage ( max_mem ) ; # endif if ( infile ) { if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>input<S2SV_blank>image<S2SV_blank>file<S2SV_blank>%s\\n"" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>standard<S2SV_blank>input\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( ( fmtid = jas_image_getfmt ( instream ) ) < 0 ) { fprintf ( stderr , ""unknown<S2SV_blank>image<S2SV_blank>format\\n"" ) ; }  if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {  jas_stream_close ( instream ) ; fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\n"" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ;  if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {  fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\n"" ) ; } if ( numcmpts ) { width = jas_image_cmptwidth ( image , 0 ) ; height = jas_image_cmptheight ( image , 0 ) ; depth = jas_image_cmptprec ( image , 0 ) ; } else { width = 0 ; height = 0 ; depth = 0 ; }  if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {  abort ( ) ; }  printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ;  jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; return EXIT_SUCCESS ; }","if ( ! ( image = jas_image_decode ( instream , fmtid , optstr ) ) ) {jas_stream_close ( instream ) ;if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {jas_eprintf ( ""format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\\return EXIT_FAILURE ;}if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\\",1433
340,"buggy line: if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {abort ( ) ;}printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\\jas_image_destroy ( image ) ;cwe id:CWE-190context: int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; char * fmtname ; int debug ; size_t max_mem ;  if ( jas_init ( ) ) {  abort ( ) ; } cmdname = argv [ 0 ] ;  infile = 0 ;  verbose = 0 ; debug = 0 ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) max_mem = JAS_DEFAULT_MAX_MEM_USAGE ; # endif while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( ""%s\\n"" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case OPT_INFILE : infile = jas_optarg ; break ;  case OPT_MAXMEM :  max_mem = strtoull ( jas_optarg , 0 , 10 ) ; break ; case OPT_HELP : default : usage ( ) ; break ; } } jas_setdbglevel ( debug ) ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) jas_set_max_mem_usage ( max_mem ) ; # endif if ( infile ) { if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>input<S2SV_blank>image<S2SV_blank>file<S2SV_blank>%s\\n"" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>standard<S2SV_blank>input\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( ( fmtid = jas_image_getfmt ( instream ) ) < 0 ) { fprintf ( stderr , ""unknown<S2SV_blank>image<S2SV_blank>format\\n"" ) ; }  if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {  jas_stream_close ( instream ) ; fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\n"" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ;  if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {  fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\n"" ) ; } if ( numcmpts ) { width = jas_image_cmptwidth ( image , 0 ) ; height = jas_image_cmptheight ( image , 0 ) ; depth = jas_image_cmptprec ( image , 0 ) ; } else { width = 0 ; height = 0 ; depth = 0 ; }  if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {  abort ( ) ; }  printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ;  jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; return EXIT_SUCCESS ; }","printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\\jas_image_destroy ( image ) ;",1433
341,"buggy line: CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;if ( test_suite [ i ] . function ( ) ) {cwe id:CWE-20context: int main ( int argc , char * * argv ) { const char * test_name = NULL ; bool skip_sanity_suite = false ; for ( int i = 1 ; i < argc ; ++ i ) { if ( ! strcmp ( ""--help"" , argv [ i ] ) ) { print_usage ( argv [ 0 ] ) ; return 0 ; } if ( ! strcmp ( ""--insanity"" , argv [ i ] ) ) { skip_sanity_suite = true ; continue ; } if ( ! is_valid ( argv [ i ] ) ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>test<S2SV_blank>name.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( test_name != NULL ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>arguments.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } test_name = argv [ i ] ; } if ( is_shell_running ( ) ) { printf ( ""Run<S2SV_blank>\'adb<S2SV_blank>shell<S2SV_blank>stop\'<S2SV_blank>before<S2SV_blank>running<S2SV_blank>%s.\\n"" , argv [ 0 ] ) ; return - 1 ; } config_t * config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stack<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } for ( const config_section_node_t * node = config_section_begin ( config ) ; node != config_section_end ( config ) ; node = config_section_next ( node ) ) { const char * name = config_section_name ( node ) ; if ( config_has_key ( config , name , ""LinkKey"" ) && string_to_bdaddr ( name , & bt_remote_bdaddr ) ) { break ; } } config_free ( config ) ; if ( bdaddr_is_empty ( & bt_remote_bdaddr ) ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>paired<S2SV_blank>device<S2SV_blank>in<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( ! hal_open ( callbacks_get_adapter_struct ( ) ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Bluetooth<S2SV_blank>HAL.\\n"" ) ; return 1 ; } if ( ! btsocket_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>Bluetooth<S2SV_blank>sockets.\\n"" ) ; return 2 ; } if ( ! pan_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PAN.\\n"" ) ; return 3 ; } if ( ! gatt_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>GATT.\\n"" ) ; return 4 ; } watchdog_running = true ; pthread_create ( & watchdog_thread , NULL , watchdog_fn , NULL ) ; static const char * DEFAULT = ""\\x1b[0m"" ; static const char * GREEN = ""\\x1b[0;32m"" ; static const char * RED = ""\\x1b[0;31m"" ; if ( ! isatty ( fileno ( stdout ) ) ) { DEFAULT = GREEN = RED = """" ; } int pass = 0 ; int fail = 0 ; int case_num = 0 ; if ( ! skip_sanity_suite ) { for ( size_t i = 0 ; i < sanity_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , sanity_suite [ i ] . function_name ) ) { callbacks_init ( ) ; if ( sanity_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } callbacks_cleanup ( ) ; ++ watchdog_id ; } } } if ( fail ) { printf ( ""\\n%sSanity<S2SV_blank>suite<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>errors.%s\\n"" , RED , fail , DEFAULT ) ; hal_close ( ) ; return 4 ; } for ( size_t i = 0 ; i < test_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , test_suite [ i ] . function_name ) ) { callbacks_init ( ) ;  CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;  if ( test_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } CALL_AND_WAIT ( bt_interface -> disable ( ) , adapter_state_changed ) ; callbacks_cleanup ( ) ; ++ watchdog_id ; } } printf ( ""\\n"" ) ; if ( fail ) { printf ( ""%d/%d<S2SV_blank>tests<S2SV_blank>failed.<S2SV_blank>See<S2SV_blank>above<S2SV_blank>for<S2SV_blank>failed<S2SV_blank>test<S2SV_blank>cases.\\n"" , fail , sanity_suite_size + test_suite_size ) ; } else { printf ( ""All<S2SV_blank>tests<S2SV_blank>passed!\\n"" ) ; } watchdog_running = false ; pthread_join ( watchdog_thread , NULL ) ; hal_close ( ) ; return 0 ; }","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;if ( test_suite [ i ] . function ( ) ) {",1434
342,"buggy line: if ( ( conn -> validator == NULL ) ||  cherokee_buffer_is_empty ( & conn -> validator -> user ) )  return ret_error ;cwe id:CWE-287context: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) ||  cherokee_buffer_is_empty ( & conn -> validator -> user ) )  return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree<S2SV_blank>search<S2SV_blank>(%s):<S2SV_blank>done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access<S2SV_blank>to<S2SV_blank>use<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>been<S2SV_blank>granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ;,1435
343,"buggy line: for ( row = 0 ;row < height ;row ++ )  {cwe id:CWE-119context: void CLASS panasonic_load_raw ( ) { int row , col , i , j , sh = 0 , pred [ 2 ] , nonz [ 2 ] ; pana_bits ( 0 ) ;  for ( row = 0 ; row < height ; row ++ )  { # ifdef LIBRAW_LIBRARY_BUILD checkCancel ( ) ; # endif for ( col = 0 ; col < raw_width ; col ++ ) { if ( ( i = col % 14 ) == 0 ) pred [ 0 ] = pred [ 1 ] = nonz [ 0 ] = nonz [ 1 ] = 0 ; if ( i % 3 == 2 ) sh = 4 >> ( 3 - pana_bits ( 2 ) ) ; if ( nonz [ i & 1 ] ) { if ( ( j = pana_bits ( 8 ) ) ) { if ( ( pred [ i & 1 ] -= 0x80 << sh ) < 0 || sh == 4 ) pred [ i & 1 ] &= ~ ( ( ~ 0u ) << sh ) ; pred [ i & 1 ] += j << sh ; } } else if ( ( nonz [ i & 1 ] = pana_bits ( 8 ) ) || i > 11 ) pred [ i & 1 ] = nonz [ i & 1 ] << 4 | pana_bits ( 4 ) ;  if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width )  derror ( ) ; } } }",for ( row = 0 ;row < raw_height ;row ++ ) {,1436
344,"buggy line: if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width )  derror ( ) ;cwe id:CWE-119context: void CLASS panasonic_load_raw ( ) { int row , col , i , j , sh = 0 , pred [ 2 ] , nonz [ 2 ] ; pana_bits ( 0 ) ;  for ( row = 0 ; row < height ; row ++ )  { # ifdef LIBRAW_LIBRARY_BUILD checkCancel ( ) ; # endif for ( col = 0 ; col < raw_width ; col ++ ) { if ( ( i = col % 14 ) == 0 ) pred [ 0 ] = pred [ 1 ] = nonz [ 0 ] = nonz [ 1 ] = 0 ; if ( i % 3 == 2 ) sh = 4 >> ( 3 - pana_bits ( 2 ) ) ; if ( nonz [ i & 1 ] ) { if ( ( j = pana_bits ( 8 ) ) ) { if ( ( pred [ i & 1 ] -= 0x80 << sh ) < 0 || sh == 4 ) pred [ i & 1 ] &= ~ ( ( ~ 0u ) << sh ) ; pred [ i & 1 ] += j << sh ; } } else if ( ( nonz [ i & 1 ] = pana_bits ( 8 ) ) || i > 11 ) pred [ i & 1 ] = nonz [ i & 1 ] << 4 | pana_bits ( 4 ) ;  if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width )  derror ( ) ; } } }","if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width && row < height ) derror ( ) ;",1436
345,"buggy line: if ( len < needed ) {param -> flags |= DM_BUFFER_FULL_FLAG ;cwe id:CWE-787context: static int list_devices ( struct file * filp , struct dm_ioctl * param , size_t param_size ) { unsigned int i ; struct hash_cell * hc ; size_t len , needed = 0 ; struct gendisk * disk ; struct dm_name_list * orig_nl , * nl , * old_nl = NULL ; uint32_t * event_nr ; down_write ( & _hash_lock ) ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { needed += align_val ( offsetof ( struct dm_name_list , name ) + strlen ( hc -> name ) + 1 ) ; needed += align_val ( sizeof ( uint32_t ) ) ; } } nl = orig_nl = get_result_buffer ( param , param_size , & len ) ;  if ( len < needed ) {  param -> flags |= DM_BUFFER_FULL_FLAG ; goto out ; } param -> data_size = param -> data_start + needed ; nl -> dev = 0 ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { if ( old_nl ) old_nl -> next = ( uint32_t ) ( ( void * ) nl - ( void * ) old_nl ) ; disk = dm_disk ( hc -> md ) ; nl -> dev = huge_encode_dev ( disk_devt ( disk ) ) ; nl -> next = 0 ; strcpy ( nl -> name , hc -> name ) ; old_nl = nl ; event_nr = align_ptr ( nl -> name + strlen ( hc -> name ) + 1 ) ; * event_nr = dm_get_event_nr ( hc -> md ) ; nl = align_ptr ( event_nr + 1 ) ; } } BUG_ON ( ( char * ) nl - ( char * ) orig_nl != needed ) ; out : up_write ( & _hash_lock ) ; return 0 ; }",if ( len < needed || len < sizeof ( nl -> dev ) ) {param -> flags |= DM_BUFFER_FULL_FLAG ;,1437
346,"buggy line: ExitLoop :  if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) {cwe id:CWE-125context: static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ;  ExitLoop :  if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }",quantum_info = DestroyQuantumInfo ( quantum_info ) ;ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) {,1438
347,"buggy line: int idx , ret = - EINVAL ;if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ;irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ;BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ;hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) {if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ;cwe id:CWE-20context: static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ;  int idx , ret = - EINVAL ;  if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ;  BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ;   hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) {  if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed<S2SV_blank>to<S2SV_blank>back<S2SV_blank>to<S2SV_blank>remapped<S2SV_blank>mode,<S2SV_blank>irq:<S2SV_blank>%u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>update<S2SV_blank>PI<S2SV_blank>IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }","int idx , ret = 0 ;if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ;if ( guest_irq >= irq_rt -> nr_rt_entries ) ;hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] ) ) {pr_warn_once ( ""no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\\goto out ;}hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) {if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ;",1439
348,"buggy line: if ( bfqq )  bfq_idle_slice_timer_body ( bfqq ) ;return HRTIMER_NORESTART ;cwe id:CWE-416context: static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq )  bfq_idle_slice_timer_body ( bfqq ) ;  return HRTIMER_NORESTART ; }","if ( bfqq ) bfq_idle_slice_timer_body ( bfqd , bfqq ) ;return HRTIMER_NORESTART ;",1440
349,"buggy line: return rold -> umin_value == 0 &&  rold -> umax_value == U64_MAX && rold -> smin_value == S64_MIN && rold -> smax_value == S64_MAX && tnum_is_unknown ( rold -> var_off ) ;cwe id:CWE-119context: static bool regsafe ( struct bpf_reg_state * rold , struct bpf_reg_state * rcur , struct idpair * idmap ) { if ( ! ( rold -> live & REG_LIVE_READ ) ) return true ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , live ) ) == 0 ) return true ; if ( rold -> type == NOT_INIT ) return true ; if ( rcur -> type == NOT_INIT ) return false ; switch ( rold -> type ) { case SCALAR_VALUE : if ( rcur -> type == SCALAR_VALUE ) { return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; } else {  return rold -> umin_value == 0 &&  rold -> umax_value == U64_MAX && rold -> smin_value == S64_MIN && rold -> smax_value == S64_MAX && tnum_is_unknown ( rold -> var_off ) ; } case PTR_TO_MAP_VALUE : return memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) == 0 && range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_MAP_VALUE_OR_NULL : if ( rcur -> type != PTR_TO_MAP_VALUE_OR_NULL ) return false ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) ) return false ; return check_ids ( rold -> id , rcur -> id , idmap ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET : if ( rcur -> type != rold -> type ) return false ; if ( rold -> range > rcur -> range ) return false ; if ( rold -> off != rcur -> off ) return false ; if ( rold -> id && ! check_ids ( rold -> id , rcur -> id , idmap ) ) return false ; return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_CTX : case CONST_PTR_TO_MAP : case PTR_TO_STACK : case PTR_TO_PACKET_END : default : return false ; } WARN_ON_ONCE ( 1 ) ; return false ; }",return false ;,1441
350,"buggy line: BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;sa -> rc_family = AF_BLUETOOTH ;cwe id:CWE-200context: static int rfcomm_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; struct sock * sk = sock -> sk ;  BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;  sa -> rc_family = AF_BLUETOOTH ; sa -> rc_channel = rfcomm_pi ( sk ) -> channel ; if ( peer ) bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> dst ) ; else bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> src ) ; * len = sizeof ( struct sockaddr_rc ) ; return 0 ; }","BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;memset ( sa , 0 , sizeof ( * sa ) ) ;sa -> rc_family = AF_BLUETOOTH ;",1442
351,buggy line: if ( ! handle )  return NULL ;cwe id:CWE-476context: void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ;  if ( ! handle )  return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; },if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ;,1443
352,"buggy line: length += 1 ;length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ;length += update_prepare_bounds ( context , orderInfo ) ;cwe id:CWE-125context: static int update_prepare_order_info ( rdpContext * context , ORDER_INFO * orderInfo , UINT32 orderType ) { int length = 1 ; orderInfo -> fieldFlags = 0 ; orderInfo -> orderType = orderType ; orderInfo -> controlFlags = ORDER_STANDARD ; orderInfo -> controlFlags |= ORDER_TYPE_CHANGE ; length += 1 ;  length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ;  length += update_prepare_bounds ( context , orderInfo ) ; return length ; }","length += get_primary_drawing_order_field_bytes ( orderInfo -> orderType ] ;length += update_prepare_bounds ( context , orderInfo ) ;",1444
353,"buggy line: olddentry = ovl_dentry_upper ( old ) ;newdentry = ovl_dentry_upper ( new ) ;if ( newdentry ) {newdentry = opaquedir ;opaquedir = NULL ;dget ( newdentry ) ;newdentry = lookup_one_len ( new -> d_name . name , new_upperdir ,  new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) )  goto out_unlock ;}err = - ESTALE ;if ( olddentry -> d_parent != old_upperdir )  goto out_dput ;if ( newdentry -> d_parent != new_upperdir )   goto out_dput ;if ( olddentry == trap ) goto out_dput ;if ( newdentry == trap ) goto out_dput ;cwe id:CWE-20context: static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_lower ( old ) -> d_inode == ovl_dentry_lower ( new ) -> d_inode ) goto out ; } if ( OVL_TYPE_UPPER ( new_type ) && OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_upper ( old ) -> d_inode == ovl_dentry_upper ( new ) -> d_inode ) goto out ; } } else { if ( ovl_dentry_is_opaque ( new ) ) new_type = __OVL_PATH_UPPER ; else new_type = __OVL_PATH_UPPER | __OVL_PATH_PURE ; } err = ovl_want_write ( old ) ; if ( err ) goto out ; err = ovl_copy_up ( old ) ; if ( err ) goto out_drop_write ; err = ovl_copy_up ( new -> d_parent ) ; if ( err ) goto out_drop_write ; if ( ! overwrite ) { err = ovl_copy_up ( new ) ; if ( err ) goto out_drop_write ; } old_opaque = ! OVL_TYPE_PURE_UPPER ( old_type ) ; new_opaque = ! OVL_TYPE_PURE_UPPER ( new_type ) ; if ( old_opaque || new_opaque ) { err = - ENOMEM ; override_cred = prepare_creds ( ) ; if ( ! override_cred ) goto out_drop_write ; cap_raise ( override_cred -> cap_effective , CAP_SYS_ADMIN ) ; cap_raise ( override_cred -> cap_effective , CAP_DAC_OVERRIDE ) ; cap_raise ( override_cred -> cap_effective , CAP_FOWNER ) ; cap_raise ( override_cred -> cap_effective , CAP_FSETID ) ; cap_raise ( override_cred -> cap_effective , CAP_CHOWN ) ; old_cred = override_creds ( override_cred ) ; } if ( overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) { opaquedir = ovl_check_empty_and_clear ( new ) ; err = PTR_ERR ( opaquedir ) ; if ( IS_ERR ( opaquedir ) ) { opaquedir = NULL ; goto out_revert_creds ; } } if ( overwrite ) { if ( old_opaque ) { if ( new -> d_inode || ! new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } } else if ( is_dir && ! new -> d_inode && new_opaque ) { flags |= RENAME_EXCHANGE ; cleanup_whiteout = true ; } } old_upperdir = ovl_dentry_upper ( old -> d_parent ) ; new_upperdir = ovl_dentry_upper ( new -> d_parent ) ; trap = lock_rename ( new_upperdir , old_upperdir ) ;  olddentry = ovl_dentry_upper ( old ) ;  newdentry = ovl_dentry_upper ( new ) ; if ( newdentry ) { if ( opaquedir ) { newdentry = opaquedir ; opaquedir = NULL ; } else { dget ( newdentry ) ; } } else { new_create = true ;  newdentry = lookup_one_len ( new -> d_name . name , new_upperdir ,  new -> d_name . len ) ;  err = PTR_ERR ( newdentry ) ;   if ( IS_ERR ( newdentry ) )  goto out_unlock ;  }  err = - ESTALE ;  if ( olddentry -> d_parent != old_upperdir )  goto out_dput ;  if ( newdentry -> d_parent != new_upperdir )   goto out_dput ;  if ( olddentry == trap ) goto out_dput ; if ( newdentry == trap ) goto out_dput ; if ( is_dir && ! old_opaque && new_opaque ) { err = ovl_set_opaque ( olddentry ) ; if ( err ) goto out_dput ; } if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) { err = ovl_set_opaque ( newdentry ) ; if ( err ) goto out_dput ; } if ( old_opaque || new_opaque ) { err = ovl_do_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , flags ) ; } else { BUG_ON ( flags & ~ RENAME_EXCHANGE ) ; err = vfs_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , NULL , flags ) ; } if ( err ) { if ( is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( newdentry ) ; goto out_dput ; } if ( is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( newdentry ) ; if ( old_opaque != new_opaque ) { ovl_dentry_set_opaque ( old , new_opaque ) ; if ( ! overwrite ) ovl_dentry_set_opaque ( new , old_opaque ) ; } if ( cleanup_whiteout ) ovl_cleanup ( old_upperdir -> d_inode , newdentry ) ; ovl_dentry_version_inc ( old -> d_parent ) ; ovl_dentry_version_inc ( new -> d_parent ) ; out_dput : dput ( newdentry ) ;  out_unlock :  unlock_rename ( new_upperdir , old_upperdir ) ; out_revert_creds : if ( old_opaque || new_opaque ) { revert_creds ( old_cred ) ; put_cred ( override_cred ) ; } out_drop_write : ovl_drop_write ( old ) ; out : dput ( opaquedir ) ; return err ; }","olddentry = lookup_one_len ( old -> d_name . name , new_upperdir , new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) ) goto out_unlock ;}err = - ESTALE ;if ( olddentry -> d_parent != old_upperdir ) goto out_dput ;if ( newdentry -> d_parent != new_upperdir ) goto out_dput ;if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ;newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) ) goto out_dput_old ;err = - ESTALE ;if ( ovl_dentry_upper ( new ) ) {if ( newdentry != opaquedir ) goto out_dput ;if ( newdentry != ovl_dentry_upper ( new ) ) goto out_dput ;if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ;}out_dput_old : dput ( olddentry ) ;",1445
354,"buggy line: out_unlock :  unlock_rename ( new_upperdir , old_upperdir ) ;cwe id:CWE-20context: static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_lower ( old ) -> d_inode == ovl_dentry_lower ( new ) -> d_inode ) goto out ; } if ( OVL_TYPE_UPPER ( new_type ) && OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_upper ( old ) -> d_inode == ovl_dentry_upper ( new ) -> d_inode ) goto out ; } } else { if ( ovl_dentry_is_opaque ( new ) ) new_type = __OVL_PATH_UPPER ; else new_type = __OVL_PATH_UPPER | __OVL_PATH_PURE ; } err = ovl_want_write ( old ) ; if ( err ) goto out ; err = ovl_copy_up ( old ) ; if ( err ) goto out_drop_write ; err = ovl_copy_up ( new -> d_parent ) ; if ( err ) goto out_drop_write ; if ( ! overwrite ) { err = ovl_copy_up ( new ) ; if ( err ) goto out_drop_write ; } old_opaque = ! OVL_TYPE_PURE_UPPER ( old_type ) ; new_opaque = ! OVL_TYPE_PURE_UPPER ( new_type ) ; if ( old_opaque || new_opaque ) { err = - ENOMEM ; override_cred = prepare_creds ( ) ; if ( ! override_cred ) goto out_drop_write ; cap_raise ( override_cred -> cap_effective , CAP_SYS_ADMIN ) ; cap_raise ( override_cred -> cap_effective , CAP_DAC_OVERRIDE ) ; cap_raise ( override_cred -> cap_effective , CAP_FOWNER ) ; cap_raise ( override_cred -> cap_effective , CAP_FSETID ) ; cap_raise ( override_cred -> cap_effective , CAP_CHOWN ) ; old_cred = override_creds ( override_cred ) ; } if ( overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) { opaquedir = ovl_check_empty_and_clear ( new ) ; err = PTR_ERR ( opaquedir ) ; if ( IS_ERR ( opaquedir ) ) { opaquedir = NULL ; goto out_revert_creds ; } } if ( overwrite ) { if ( old_opaque ) { if ( new -> d_inode || ! new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } } else if ( is_dir && ! new -> d_inode && new_opaque ) { flags |= RENAME_EXCHANGE ; cleanup_whiteout = true ; } } old_upperdir = ovl_dentry_upper ( old -> d_parent ) ; new_upperdir = ovl_dentry_upper ( new -> d_parent ) ; trap = lock_rename ( new_upperdir , old_upperdir ) ;  olddentry = ovl_dentry_upper ( old ) ;  newdentry = ovl_dentry_upper ( new ) ; if ( newdentry ) { if ( opaquedir ) { newdentry = opaquedir ; opaquedir = NULL ; } else { dget ( newdentry ) ; } } else { new_create = true ;  newdentry = lookup_one_len ( new -> d_name . name , new_upperdir ,  new -> d_name . len ) ;  err = PTR_ERR ( newdentry ) ;   if ( IS_ERR ( newdentry ) )  goto out_unlock ;  }  err = - ESTALE ;  if ( olddentry -> d_parent != old_upperdir )  goto out_dput ;  if ( newdentry -> d_parent != new_upperdir )   goto out_dput ;  if ( olddentry == trap ) goto out_dput ; if ( newdentry == trap ) goto out_dput ; if ( is_dir && ! old_opaque && new_opaque ) { err = ovl_set_opaque ( olddentry ) ; if ( err ) goto out_dput ; } if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) { err = ovl_set_opaque ( newdentry ) ; if ( err ) goto out_dput ; } if ( old_opaque || new_opaque ) { err = ovl_do_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , flags ) ; } else { BUG_ON ( flags & ~ RENAME_EXCHANGE ) ; err = vfs_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , NULL , flags ) ; } if ( err ) { if ( is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( newdentry ) ; goto out_dput ; } if ( is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( newdentry ) ; if ( old_opaque != new_opaque ) { ovl_dentry_set_opaque ( old , new_opaque ) ; if ( ! overwrite ) ovl_dentry_set_opaque ( new , old_opaque ) ; } if ( cleanup_whiteout ) ovl_cleanup ( old_upperdir -> d_inode , newdentry ) ; ovl_dentry_version_inc ( old -> d_parent ) ; ovl_dentry_version_inc ( new -> d_parent ) ; out_dput : dput ( newdentry ) ;  out_unlock :  unlock_rename ( new_upperdir , old_upperdir ) ; out_revert_creds : if ( old_opaque || new_opaque ) { revert_creds ( old_cred ) ; put_cred ( override_cred ) ; } out_drop_write : ovl_drop_write ( old ) ; out : dput ( opaquedir ) ; return err ; }","out_unlock : unlock_rename ( new_upperdir , old_upperdir ) ;",1445
355,"buggy line: # if 0  DATA_ENSURE ( 1 ) ;p ++ ;s ++ ;# endif if ( * p != * s ++ ) goto fail ;DATA_ENSURE ( 0 ) ;cwe id:CWE-125context: static int match_at ( regex_t * reg , const UChar * str , const UChar * end , # ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE const UChar * right_range , # endif const UChar * sstart , UChar * sprev , OnigMatchArg * msa ) { static UChar FinishCode [ ] = { OP_FINISH } ; int i , n , num_mem , best_len , pop_level ; LengthType tlen , tlen2 ; MemNumType mem ; RelAddrType addr ; UChar * s , * q , * sbegin ; int is_alloca ; char * alloc_base ; OnigStackType * stk_base , * stk , * stk_end ; OnigStackType * stkp ; OnigStackIndex si ; OnigStackIndex * repeat_stk ; OnigStackIndex * mem_start_stk , * mem_end_stk ; # ifdef USE_COMBINATION_EXPLOSION_CHECK int scv ; unsigned char * state_check_buff = msa -> state_check_buff ; int num_comb_exp_check = reg -> num_comb_exp_check ; # endif UChar * p = reg -> p ; OnigOptionType option = reg -> options ; OnigEncoding encode = reg -> enc ; OnigCaseFoldType case_fold_flag = reg -> case_fold_flag ; pop_level = reg -> stack_pop_level ; num_mem = reg -> num_mem ; STACK_INIT ( INIT_MATCH_STACK_SIZE ) ; UPDATE_FOR_STACK_REALLOC ; for ( i = 1 ; i <= num_mem ; i ++ ) { mem_start_stk [ i ] = mem_end_stk [ i ] = INVALID_STACK_INDEX ; } # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""match_at:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>start:<S2SV_blank>%d,<S2SV_blank>sprev:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) sstart , ( int ) sprev ) ; fprintf ( stderr , ""size:<S2SV_blank>%d,<S2SV_blank>start<S2SV_blank>offset:<S2SV_blank>%d\\n"" , ( int ) ( end - str ) , ( int ) ( sstart - str ) ) ; # endif STACK_PUSH_ENSURED ( STK_ALT , FinishCode ) ; best_len = ONIG_MISMATCH ; s = ( UChar * ) sstart ; while ( 1 ) { # ifdef ONIG_DEBUG_MATCH { UChar * q , * bp , buf [ 50 ] ; int len ; fprintf ( stderr , ""%4d><S2SV_blank>\\"""" , ( int ) ( s - str ) ) ; bp = buf ; for ( i = 0 , q = s ; i < 7 && q < end ; i ++ ) { len = enclen ( encode , q ) ; while ( len -- > 0 ) * bp ++ = * q ++ ; } if ( q < end ) { xmemcpy ( bp , ""...\\"""" , 4 ) ; bp += 4 ; } else { xmemcpy ( bp , ""\\"""" , 1 ) ; bp += 1 ; } * bp = 0 ; fputs ( ( char * ) buf , stderr ) ; for ( i = 0 ; i < 20 - ( bp - buf ) ; i ++ ) fputc ( '<S2SV_blank>' , stderr ) ; onig_print_compiled_byte_code ( stderr , p , NULL , encode ) ; fprintf ( stderr , ""\\n"" ) ; } # endif sbegin = s ; switch ( * p ++ ) { case OP_END : MOP_IN ( OP_END ) ; n = s - sstart ; if ( n > best_len ) { OnigRegion * region ; # ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE if ( IS_FIND_LONGEST ( option ) ) { if ( n > msa -> best_len ) { msa -> best_len = n ; msa -> best_s = ( UChar * ) sstart ; } else goto end_best_len ; } # endif best_len = n ; region = msa -> region ; if ( region ) { # ifdef USE_POSIX_API_REGION_OPTION if ( IS_POSIX_REGION ( msa -> options ) ) { posix_regmatch_t * rmt = ( posix_regmatch_t * ) region ; rmt [ 0 ] . rm_so = sstart - str ; rmt [ 0 ] . rm_eo = s - str ; for ( i = 1 ; i <= num_mem ; i ++ ) { if ( mem_end_stk [ i ] != INVALID_STACK_INDEX ) { if ( BIT_STATUS_AT ( reg -> bt_mem_start , i ) ) rmt [ i ] . rm_so = STACK_AT ( mem_start_stk [ i ] ) -> u . mem . pstr - str ; else rmt [ i ] . rm_so = ( UChar * ) ( ( void * ) ( mem_start_stk [ i ] ) ) - str ; rmt [ i ] . rm_eo = ( BIT_STATUS_AT ( reg -> bt_mem_end , i ) ? STACK_AT ( mem_end_stk [ i ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ i ] ) ) - str ; } else { rmt [ i ] . rm_so = rmt [ i ] . rm_eo = ONIG_REGION_NOTPOS ; } } } else { # endif region -> beg [ 0 ] = sstart - str ; region -> end [ 0 ] = s - str ; for ( i = 1 ; i <= num_mem ; i ++ ) { if ( mem_end_stk [ i ] != INVALID_STACK_INDEX ) { if ( BIT_STATUS_AT ( reg -> bt_mem_start , i ) ) region -> beg [ i ] = STACK_AT ( mem_start_stk [ i ] ) -> u . mem . pstr - str ; else region -> beg [ i ] = ( UChar * ) ( ( void * ) mem_start_stk [ i ] ) - str ; region -> end [ i ] = ( BIT_STATUS_AT ( reg -> bt_mem_end , i ) ? STACK_AT ( mem_end_stk [ i ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ i ] ) ) - str ; } else { region -> beg [ i ] = region -> end [ i ] = ONIG_REGION_NOTPOS ; } } # ifdef USE_CAPTURE_HISTORY if ( reg -> capture_history != 0 ) { int r ; OnigCaptureTreeNode * node ; if ( IS_NULL ( region -> history_root ) ) { region -> history_root = node = history_node_new ( ) ; CHECK_NULL_RETURN_MEMERR ( node ) ; } else { node = region -> history_root ; history_tree_clear ( node ) ; } node -> group = 0 ; node -> beg = sstart - str ; node -> end = s - str ; stkp = stk_base ; r = make_capture_history_tree ( region -> history_root , & stkp , stk , ( UChar * ) str , reg ) ; if ( r < 0 ) { best_len = r ; goto finish ; } } # endif # ifdef USE_POSIX_API_REGION_OPTION } # endif } } # ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE end_best_len : # endif MOP_OUT ; if ( IS_FIND_CONDITION ( option ) ) { if ( IS_FIND_NOT_EMPTY ( option ) && s == sstart ) { best_len = ONIG_MISMATCH ; goto fail ; } if ( IS_FIND_LONGEST ( option ) && DATA_ENSURE_CHECK1 ) { goto fail ; } } goto finish ; break ; case OP_EXACT1 : MOP_IN ( OP_EXACT1 ) ;  # if 0  DATA_ENSURE ( 1 ) ; if ( * p != * s ) goto fail ;  p ++ ; s ++ ;  # endif if ( * p != * s ++ ) goto fail ; DATA_ENSURE ( 0 ) ; p ++ ; MOP_OUT ; break ; case OP_EXACT1_IC : MOP_IN ( OP_EXACT1_IC ) ; { int len ; UChar * q , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; DATA_ENSURE ( 1 ) ; len = ONIGENC_MBC_CASE_FOLD ( encode , case_fold_flag , & s , end , lowbuf ) ; DATA_ENSURE ( 0 ) ; q = lowbuf ; while ( len -- > 0 ) { if ( * p != * q ) { goto fail ; } p ++ ; q ++ ; } } MOP_OUT ; break ; case OP_EXACT2 : MOP_IN ( OP_EXACT2 ) ; DATA_ENSURE ( 2 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACT3 : MOP_IN ( OP_EXACT3 ) ; DATA_ENSURE ( 3 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACT4 : MOP_IN ( OP_EXACT4 ) ; DATA_ENSURE ( 4 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACT5 : MOP_IN ( OP_EXACT5 ) ; DATA_ENSURE ( 5 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACTN : MOP_IN ( OP_EXACTN ) ; GET_LENGTH_INC ( tlen , p ) ; DATA_ENSURE ( tlen ) ; while ( tlen -- > 0 ) { if ( * p ++ != * s ++ ) goto fail ; } sprev = s - 1 ; MOP_OUT ; continue ; break ; case OP_EXACTN_IC : MOP_IN ( OP_EXACTN_IC ) ; { int len ; UChar * q , * endp , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; GET_LENGTH_INC ( tlen , p ) ; endp = p + tlen ; while ( p < endp ) { sprev = s ; DATA_ENSURE ( 1 ) ; len = ONIGENC_MBC_CASE_FOLD ( encode , case_fold_flag , & s , end , lowbuf ) ; DATA_ENSURE ( 0 ) ; q = lowbuf ; while ( len -- > 0 ) { if ( * p != * q ) goto fail ; p ++ ; q ++ ; } } } MOP_OUT ; continue ; break ; case OP_EXACTMB2N1 : MOP_IN ( OP_EXACTMB2N1 ) ; DATA_ENSURE ( 2 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; MOP_OUT ; break ; case OP_EXACTMB2N2 : MOP_IN ( OP_EXACTMB2N2 ) ; DATA_ENSURE ( 4 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; sprev = s ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACTMB2N3 : MOP_IN ( OP_EXACTMB2N3 ) ; DATA_ENSURE ( 6 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; sprev = s ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACTMB2N : MOP_IN ( OP_EXACTMB2N ) ; GET_LENGTH_INC ( tlen , p ) ; DATA_ENSURE ( tlen * 2 ) ; while ( tlen -- > 0 ) { if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; } sprev = s - 2 ; MOP_OUT ; continue ; break ; case OP_EXACTMB3N : MOP_IN ( OP_EXACTMB3N ) ; GET_LENGTH_INC ( tlen , p ) ; DATA_ENSURE ( tlen * 3 ) ; while ( tlen -- > 0 ) { if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; } sprev = s - 3 ; MOP_OUT ; continue ; break ; case OP_EXACTMBN : MOP_IN ( OP_EXACTMBN ) ; GET_LENGTH_INC ( tlen , p ) ; GET_LENGTH_INC ( tlen2 , p ) ; tlen2 *= tlen ; DATA_ENSURE ( tlen2 ) ; while ( tlen2 -- > 0 ) { if ( * p != * s ) goto fail ; p ++ ; s ++ ; } sprev = s - tlen ; MOP_OUT ; continue ; break ; case OP_CCLASS : MOP_IN ( OP_CCLASS ) ; DATA_ENSURE ( 1 ) ; if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) == 0 ) goto fail ; p += SIZE_BITSET ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_CCLASS_MB : MOP_IN ( OP_CCLASS_MB ) ; if ( ! ONIGENC_IS_MBC_HEAD ( encode , s ) ) goto fail ; cclass_mb : GET_LENGTH_INC ( tlen , p ) ; { OnigCodePoint code ; UChar * ss ; int mb_len ; DATA_ENSURE ( 1 ) ; mb_len = enclen ( encode , s ) ; DATA_ENSURE ( mb_len ) ; ss = s ; s += mb_len ; code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; # ifdef PLATFORM_UNALIGNED_WORD_ACCESS if ( ! onig_is_in_code_range ( p , code ) ) goto fail ; # else q = p ; ALIGNMENT_RIGHT ( q ) ; if ( ! onig_is_in_code_range ( q , code ) ) goto fail ; # endif } p += tlen ; MOP_OUT ; break ; case OP_CCLASS_MIX : MOP_IN ( OP_CCLASS_MIX ) ; DATA_ENSURE ( 1 ) ; if ( ONIGENC_IS_MBC_HEAD ( encode , s ) ) { p += SIZE_BITSET ; goto cclass_mb ; } else { if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) == 0 ) goto fail ; p += SIZE_BITSET ; GET_LENGTH_INC ( tlen , p ) ; p += tlen ; s ++ ; } MOP_OUT ; break ; case OP_CCLASS_NOT : MOP_IN ( OP_CCLASS_NOT ) ; DATA_ENSURE ( 1 ) ; if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) != 0 ) goto fail ; p += SIZE_BITSET ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_CCLASS_MB_NOT : MOP_IN ( OP_CCLASS_MB_NOT ) ; DATA_ENSURE ( 1 ) ; if ( ! ONIGENC_IS_MBC_HEAD ( encode , s ) ) { s ++ ; GET_LENGTH_INC ( tlen , p ) ; p += tlen ; goto cc_mb_not_success ; } cclass_mb_not : GET_LENGTH_INC ( tlen , p ) ; { OnigCodePoint code ; UChar * ss ; int mb_len = enclen ( encode , s ) ; if ( ! DATA_ENSURE_CHECK ( mb_len ) ) { DATA_ENSURE ( 1 ) ; s = ( UChar * ) end ; p += tlen ; goto cc_mb_not_success ; } ss = s ; s += mb_len ; code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; # ifdef PLATFORM_UNALIGNED_WORD_ACCESS if ( onig_is_in_code_range ( p , code ) ) goto fail ; # else q = p ; ALIGNMENT_RIGHT ( q ) ; if ( onig_is_in_code_range ( q , code ) ) goto fail ; # endif } p += tlen ; cc_mb_not_success : MOP_OUT ; break ; case OP_CCLASS_MIX_NOT : MOP_IN ( OP_CCLASS_MIX_NOT ) ; DATA_ENSURE ( 1 ) ; if ( ONIGENC_IS_MBC_HEAD ( encode , s ) ) { p += SIZE_BITSET ; goto cclass_mb_not ; } else { if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) != 0 ) goto fail ; p += SIZE_BITSET ; GET_LENGTH_INC ( tlen , p ) ; p += tlen ; s ++ ; } MOP_OUT ; break ; case OP_CCLASS_NODE : MOP_IN ( OP_CCLASS_NODE ) ; { OnigCodePoint code ; void * node ; int mb_len ; UChar * ss ; DATA_ENSURE ( 1 ) ; GET_POINTER_INC ( node , p ) ; mb_len = enclen ( encode , s ) ; ss = s ; s += mb_len ; DATA_ENSURE ( 0 ) ; code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; if ( onig_is_code_in_cc_len ( mb_len , code , node ) == 0 ) goto fail ; } MOP_OUT ; break ; case OP_ANYCHAR : MOP_IN ( OP_ANYCHAR ) ; DATA_ENSURE ( 1 ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; s += n ; MOP_OUT ; break ; case OP_ANYCHAR_ML : MOP_IN ( OP_ANYCHAR_ML ) ; DATA_ENSURE ( 1 ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; s += n ; MOP_OUT ; break ; case OP_ANYCHAR_STAR : MOP_IN ( OP_ANYCHAR_STAR ) ; while ( DATA_ENSURE_CHECK1 ) { STACK_PUSH_ALT ( p , s , sprev ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; sprev = s ; s += n ; } MOP_OUT ; break ; case OP_ANYCHAR_ML_STAR : MOP_IN ( OP_ANYCHAR_ML_STAR ) ; while ( DATA_ENSURE_CHECK1 ) { STACK_PUSH_ALT ( p , s , sprev ) ; n = enclen ( encode , s ) ; if ( n > 1 ) { DATA_ENSURE ( n ) ; sprev = s ; s += n ; } else { sprev = s ; s ++ ; } } MOP_OUT ; break ; case OP_ANYCHAR_STAR_PEEK_NEXT : MOP_IN ( OP_ANYCHAR_STAR_PEEK_NEXT ) ; while ( DATA_ENSURE_CHECK1 ) { if ( * p == * s ) { STACK_PUSH_ALT ( p + 1 , s , sprev ) ; } n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; sprev = s ; s += n ; } p ++ ; MOP_OUT ; break ; case OP_ANYCHAR_ML_STAR_PEEK_NEXT : MOP_IN ( OP_ANYCHAR_ML_STAR_PEEK_NEXT ) ; while ( DATA_ENSURE_CHECK1 ) { if ( * p == * s ) { STACK_PUSH_ALT ( p + 1 , s , sprev ) ; } n = enclen ( encode , s ) ; if ( n > 1 ) { DATA_ENSURE ( n ) ; sprev = s ; s += n ; } else { sprev = s ; s ++ ; } } p ++ ; MOP_OUT ; break ; # ifdef USE_COMBINATION_EXPLOSION_CHECK case OP_STATE_CHECK_ANYCHAR_STAR : MOP_IN ( OP_STATE_CHECK_ANYCHAR_STAR ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; while ( DATA_ENSURE_CHECK1 ) { STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; STACK_PUSH_ALT_WITH_STATE_CHECK ( p , s , sprev , mem ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; sprev = s ; s += n ; } MOP_OUT ; break ; case OP_STATE_CHECK_ANYCHAR_ML_STAR : MOP_IN ( OP_STATE_CHECK_ANYCHAR_ML_STAR ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; while ( DATA_ENSURE_CHECK1 ) { STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; STACK_PUSH_ALT_WITH_STATE_CHECK ( p , s , sprev , mem ) ; n = enclen ( encode , s ) ; if ( n > 1 ) { DATA_ENSURE ( n ) ; sprev = s ; s += n ; } else { sprev = s ; s ++ ; } } MOP_OUT ; break ; # endif case OP_WORD : MOP_IN ( OP_WORD ) ; DATA_ENSURE ( 1 ) ; if ( ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_NOT_WORD : MOP_IN ( OP_NOT_WORD ) ; DATA_ENSURE ( 1 ) ; if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_WORD_BOUND : MOP_IN ( OP_WORD_BOUND ) ; if ( ON_STR_BEGIN ( s ) ) { DATA_ENSURE ( 1 ) ; if ( ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; } else if ( ON_STR_END ( s ) ) { if ( ! ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } else { if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) == ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } MOP_OUT ; continue ; break ; case OP_NOT_WORD_BOUND : MOP_IN ( OP_NOT_WORD_BOUND ) ; if ( ON_STR_BEGIN ( s ) ) { if ( DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; } else if ( ON_STR_END ( s ) ) { if ( ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } else { if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) != ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } MOP_OUT ; continue ; break ; # ifdef USE_WORD_BEGIN_END case OP_WORD_BEGIN : MOP_IN ( OP_WORD_BEGIN ) ; if ( DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD ( encode , s , end ) ) { if ( ON_STR_BEGIN ( s ) || ! ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) { MOP_OUT ; continue ; } } goto fail ; break ; case OP_WORD_END : MOP_IN ( OP_WORD_END ) ; if ( ! ON_STR_BEGIN ( s ) && ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) { if ( ON_STR_END ( s ) || ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) { MOP_OUT ; continue ; } } goto fail ; break ; # endif case OP_BEGIN_BUF : MOP_IN ( OP_BEGIN_BUF ) ; if ( ! ON_STR_BEGIN ( s ) ) goto fail ; MOP_OUT ; continue ; break ; case OP_END_BUF : MOP_IN ( OP_END_BUF ) ; if ( ! ON_STR_END ( s ) ) goto fail ; MOP_OUT ; continue ; break ; case OP_BEGIN_LINE : MOP_IN ( OP_BEGIN_LINE ) ; if ( ON_STR_BEGIN ( s ) ) { if ( IS_NOTBOL ( msa -> options ) ) goto fail ; MOP_OUT ; continue ; } else if ( ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) && ! ON_STR_END ( s ) ) { MOP_OUT ; continue ; } goto fail ; break ; case OP_END_LINE : MOP_IN ( OP_END_LINE ) ; if ( ON_STR_END ( s ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE if ( IS_EMPTY_STR || ! ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) ) { # endif if ( IS_NOTEOL ( msa -> options ) ) goto fail ; MOP_OUT ; continue ; # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE } # endif } else if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) { MOP_OUT ; continue ; } # ifdef USE_CRNL_AS_LINE_TERMINATOR else if ( ONIGENC_IS_MBC_CRNL ( encode , s , end ) ) { MOP_OUT ; continue ; } # endif goto fail ; break ; case OP_SEMI_END_BUF : MOP_IN ( OP_SEMI_END_BUF ) ; if ( ON_STR_END ( s ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE if ( IS_EMPTY_STR || ! ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) ) { # endif if ( IS_NOTEOL ( msa -> options ) ) goto fail ; MOP_OUT ; continue ; # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE } # endif } else if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) && ON_STR_END ( s + enclen ( encode , s ) ) ) { MOP_OUT ; continue ; } # ifdef USE_CRNL_AS_LINE_TERMINATOR else if ( ONIGENC_IS_MBC_CRNL ( encode , s , end ) ) { UChar * ss = s + enclen ( encode , s ) ; ss += enclen ( encode , ss ) ; if ( ON_STR_END ( ss ) ) { MOP_OUT ; continue ; } } # endif goto fail ; break ; case OP_BEGIN_POSITION : MOP_IN ( OP_BEGIN_POSITION ) ; if ( s != msa -> start ) goto fail ; MOP_OUT ; continue ; break ; case OP_MEMORY_START_PUSH : MOP_IN ( OP_MEMORY_START_PUSH ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_PUSH_MEM_START ( mem , s ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_START : MOP_IN ( OP_MEMORY_START ) ; GET_MEMNUM_INC ( mem , p ) ; mem_start_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_END_PUSH : MOP_IN ( OP_MEMORY_END_PUSH ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_PUSH_MEM_END ( mem , s ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_END : MOP_IN ( OP_MEMORY_END ) ; GET_MEMNUM_INC ( mem , p ) ; mem_end_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; MOP_OUT ; continue ; break ; # ifdef USE_SUBEXP_CALL case OP_MEMORY_END_PUSH_REC : MOP_IN ( OP_MEMORY_END_PUSH_REC ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_GET_MEM_START ( mem , stkp ) ; STACK_PUSH_MEM_END ( mem , s ) ; mem_start_stk [ mem ] = GET_STACK_INDEX ( stkp ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_END_REC : MOP_IN ( OP_MEMORY_END_REC ) ; GET_MEMNUM_INC ( mem , p ) ; mem_end_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; STACK_GET_MEM_START ( mem , stkp ) ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) mem_start_stk [ mem ] = GET_STACK_INDEX ( stkp ) ; else mem_start_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) stkp -> u . mem . pstr ) ; STACK_PUSH_MEM_END_MARK ( mem ) ; MOP_OUT ; continue ; break ; # endif case OP_BACKREF1 : MOP_IN ( OP_BACKREF1 ) ; mem = 1 ; goto backref ; break ; case OP_BACKREF2 : MOP_IN ( OP_BACKREF2 ) ; mem = 2 ; goto backref ; break ; case OP_BACKREFN : MOP_IN ( OP_BACKREFN ) ; GET_MEMNUM_INC ( mem , p ) ; backref : { int len ; UChar * pstart , * pend ; if ( mem > num_mem ) goto fail ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; STRING_CMP ( pstart , s , n ) ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; MOP_OUT ; continue ; } break ; case OP_BACKREFN_IC : MOP_IN ( OP_BACKREFN_IC ) ; GET_MEMNUM_INC ( mem , p ) ; { int len ; UChar * pstart , * pend ; if ( mem > num_mem ) goto fail ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; STRING_CMP_IC ( case_fold_flag , pstart , & s , n ) ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; MOP_OUT ; continue ; } break ; case OP_BACKREF_MULTI : MOP_IN ( OP_BACKREF_MULTI ) ; { int len , is_fail ; UChar * pstart , * pend , * swork ; GET_LENGTH_INC ( tlen , p ) ; for ( i = 0 ; i < tlen ; i ++ ) { GET_MEMNUM_INC ( mem , p ) ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; swork = s ; STRING_CMP_VALUE ( pstart , swork , n , is_fail ) ; if ( is_fail ) continue ; s = swork ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; p += ( SIZE_MEMNUM * ( tlen - i - 1 ) ) ; break ; } if ( i == tlen ) goto fail ; MOP_OUT ; continue ; } break ; case OP_BACKREF_MULTI_IC : MOP_IN ( OP_BACKREF_MULTI_IC ) ; { int len , is_fail ; UChar * pstart , * pend , * swork ; GET_LENGTH_INC ( tlen , p ) ; for ( i = 0 ; i < tlen ; i ++ ) { GET_MEMNUM_INC ( mem , p ) ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; swork = s ; STRING_CMP_VALUE_IC ( case_fold_flag , pstart , & swork , n , is_fail ) ; if ( is_fail ) continue ; s = swork ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; p += ( SIZE_MEMNUM * ( tlen - i - 1 ) ) ; break ; } if ( i == tlen ) goto fail ; MOP_OUT ; continue ; } break ; # ifdef USE_BACKREF_WITH_LEVEL case OP_BACKREF_WITH_LEVEL : { int len ; OnigOptionType ic ; LengthType level ; GET_OPTION_INC ( ic , p ) ; GET_LENGTH_INC ( level , p ) ; GET_LENGTH_INC ( tlen , p ) ; sprev = s ; if ( backref_match_at_nested_level ( reg , stk , stk_base , ic , case_fold_flag , ( int ) level , ( int ) tlen , p , & s , end ) ) { while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; p += ( SIZE_MEMNUM * tlen ) ; } else goto fail ; MOP_OUT ; continue ; } break ; # endif # if 0 case OP_SET_OPTION_PUSH : MOP_IN ( OP_SET_OPTION_PUSH ) ; GET_OPTION_INC ( option , p ) ; STACK_PUSH_ALT ( p , s , sprev ) ; p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL ; MOP_OUT ; continue ; break ; case OP_SET_OPTION : MOP_IN ( OP_SET_OPTION ) ; GET_OPTION_INC ( option , p ) ; MOP_OUT ; continue ; break ; # endif case OP_NULL_CHECK_START : MOP_IN ( OP_NULL_CHECK_START ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_PUSH_NULL_CHECK_START ( mem , s ) ; MOP_OUT ; continue ; break ; case OP_NULL_CHECK_END : MOP_IN ( OP_NULL_CHECK_END ) ; { int isnull ; GET_MEMNUM_INC ( mem , p ) ; STACK_NULL_CHECK ( isnull , mem , s ) ; if ( isnull ) { # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""NULL_CHECK_END:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n"" , ( int ) mem , ( int ) s ) ; # endif null_check_found : switch ( * p ++ ) { case OP_JUMP : case OP_PUSH : p += SIZE_RELADDR ; break ; case OP_REPEAT_INC : case OP_REPEAT_INC_NG : case OP_REPEAT_INC_SG : case OP_REPEAT_INC_NG_SG : p += SIZE_MEMNUM ; break ; default : goto unexpected_bytecode_error ; break ; } } } MOP_OUT ; continue ; break ; # ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT case OP_NULL_CHECK_END_MEMST : MOP_IN ( OP_NULL_CHECK_END_MEMST ) ; { int isnull ; GET_MEMNUM_INC ( mem , p ) ; STACK_NULL_CHECK_MEMST ( isnull , mem , s , reg ) ; if ( isnull ) { # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""NULL_CHECK_END_MEMST:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n"" , ( int ) mem , ( int ) s ) ; # endif if ( isnull == - 1 ) goto fail ; goto null_check_found ; } } MOP_OUT ; continue ; break ; # endif # ifdef USE_SUBEXP_CALL case OP_NULL_CHECK_END_MEMST_PUSH : MOP_IN ( OP_NULL_CHECK_END_MEMST_PUSH ) ; { int isnull ; GET_MEMNUM_INC ( mem , p ) ; # ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT STACK_NULL_CHECK_MEMST_REC ( isnull , mem , s , reg ) ; # else STACK_NULL_CHECK_REC ( isnull , mem , s ) ; # endif if ( isnull ) { # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""NULL_CHECK_END_MEMST_PUSH:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n"" , ( int ) mem , ( int ) s ) ; # endif if ( isnull == - 1 ) goto fail ; goto null_check_found ; } else { STACK_PUSH_NULL_CHECK_END ( mem ) ; } } MOP_OUT ; continue ; break ; # endif case OP_JUMP : MOP_IN ( OP_JUMP ) ; GET_RELADDR_INC ( addr , p ) ; p += addr ; MOP_OUT ; CHECK_INTERRUPT_IN_MATCH_AT ; continue ; break ; case OP_PUSH : MOP_IN ( OP_PUSH ) ; GET_RELADDR_INC ( addr , p ) ; STACK_PUSH_ALT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; break ; # ifdef USE_COMBINATION_EXPLOSION_CHECK case OP_STATE_CHECK_PUSH : MOP_IN ( OP_STATE_CHECK_PUSH ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; GET_RELADDR_INC ( addr , p ) ; STACK_PUSH_ALT_WITH_STATE_CHECK ( p + addr , s , sprev , mem ) ; MOP_OUT ; continue ; break ; case OP_STATE_CHECK_PUSH_OR_JUMP : MOP_IN ( OP_STATE_CHECK_PUSH_OR_JUMP ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; GET_RELADDR_INC ( addr , p ) ; STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) { p += addr ; } else { STACK_PUSH_ALT_WITH_STATE_CHECK ( p + addr , s , sprev , mem ) ; } MOP_OUT ; continue ; break ; case OP_STATE_CHECK : MOP_IN ( OP_STATE_CHECK ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; STACK_PUSH_STATE_CHECK ( s , mem ) ; MOP_OUT ; continue ; break ; # endif case OP_POP : MOP_IN ( OP_POP ) ; STACK_POP_ONE ; MOP_OUT ; continue ; break ; case OP_PUSH_OR_JUMP_EXACT1 : MOP_IN ( OP_PUSH_OR_JUMP_EXACT1 ) ; GET_RELADDR_INC ( addr , p ) ; if ( * p == * s && DATA_ENSURE_CHECK1 ) { p ++ ; STACK_PUSH_ALT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; } p += ( addr + 1 ) ; MOP_OUT ; continue ; break ; case OP_PUSH_IF_PEEK_NEXT : MOP_IN ( OP_PUSH_IF_PEEK_NEXT ) ; GET_RELADDR_INC ( addr , p ) ; if ( * p == * s ) { p ++ ; STACK_PUSH_ALT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; } p ++ ; MOP_OUT ; continue ; break ; case OP_REPEAT : MOP_IN ( OP_REPEAT ) ; { GET_MEMNUM_INC ( mem , p ) ; GET_RELADDR_INC ( addr , p ) ; STACK_ENSURE ( 1 ) ; repeat_stk [ mem ] = GET_STACK_INDEX ( stk ) ; STACK_PUSH_REPEAT ( mem , p ) ; if ( reg -> repeat_range [ mem ] . lower == 0 ) { STACK_PUSH_ALT ( p + addr , s , sprev ) ; } } MOP_OUT ; continue ; break ; case OP_REPEAT_NG : MOP_IN ( OP_REPEAT_NG ) ; { GET_MEMNUM_INC ( mem , p ) ; GET_RELADDR_INC ( addr , p ) ; STACK_ENSURE ( 1 ) ; repeat_stk [ mem ] = GET_STACK_INDEX ( stk ) ; STACK_PUSH_REPEAT ( mem , p ) ; if ( reg -> repeat_range [ mem ] . lower == 0 ) { STACK_PUSH_ALT ( p , s , sprev ) ; p += addr ; } } MOP_OUT ; continue ; break ; case OP_REPEAT_INC : MOP_IN ( OP_REPEAT_INC ) ; GET_MEMNUM_INC ( mem , p ) ; si = repeat_stk [ mem ] ; stkp = STACK_AT ( si ) ; repeat_inc : stkp -> u . repeat . count ++ ; if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . upper ) { } else if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . lower ) { STACK_PUSH_ALT ( p , s , sprev ) ; p = STACK_AT ( si ) -> u . repeat . pcode ; } else { p = stkp -> u . repeat . pcode ; } STACK_PUSH_REPEAT_INC ( si ) ; MOP_OUT ; CHECK_INTERRUPT_IN_MATCH_AT ; continue ; break ; case OP_REPEAT_INC_SG : MOP_IN ( OP_REPEAT_INC_SG ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_GET_REPEAT ( mem , stkp ) ; si = GET_STACK_INDEX ( stkp ) ; goto repeat_inc ; break ; case OP_REPEAT_INC_NG : MOP_IN ( OP_REPEAT_INC_NG ) ; GET_MEMNUM_INC ( mem , p ) ; si = repeat_stk [ mem ] ; stkp = STACK_AT ( si ) ; repeat_inc_ng : stkp -> u . repeat . count ++ ; if ( stkp -> u . repeat . count < reg -> repeat_range [ mem ] . upper ) { if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . lower ) { UChar * pcode = stkp -> u . repeat . pcode ; STACK_PUSH_REPEAT_INC ( si ) ; STACK_PUSH_ALT ( pcode , s , sprev ) ; } else { p = stkp -> u . repeat . pcode ; STACK_PUSH_REPEAT_INC ( si ) ; } } else if ( stkp -> u . repeat . count == reg -> repeat_range [ mem ] . upper ) { STACK_PUSH_REPEAT_INC ( si ) ; } MOP_OUT ; CHECK_INTERRUPT_IN_MATCH_AT ; continue ; break ; case OP_REPEAT_INC_NG_SG : MOP_IN ( OP_REPEAT_INC_NG_SG ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_GET_REPEAT ( mem , stkp ) ; si = GET_STACK_INDEX ( stkp ) ; goto repeat_inc_ng ; break ; case OP_PUSH_POS : MOP_IN ( OP_PUSH_POS ) ; STACK_PUSH_POS ( s , sprev ) ; MOP_OUT ; continue ; break ; case OP_POP_POS : MOP_IN ( OP_POP_POS ) ; { STACK_POS_END ( stkp ) ; s = stkp -> u . state . pstr ; sprev = stkp -> u . state . pstr_prev ; } MOP_OUT ; continue ; break ; case OP_PUSH_POS_NOT : MOP_IN ( OP_PUSH_POS_NOT ) ; GET_RELADDR_INC ( addr , p ) ; STACK_PUSH_POS_NOT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; break ; case OP_FAIL_POS : MOP_IN ( OP_FAIL_POS ) ; STACK_POP_TIL_POS_NOT ; goto fail ; break ; case OP_PUSH_STOP_BT : MOP_IN ( OP_PUSH_STOP_BT ) ; STACK_PUSH_STOP_BT ; MOP_OUT ; continue ; break ; case OP_POP_STOP_BT : MOP_IN ( OP_POP_STOP_BT ) ; STACK_STOP_BT_END ; MOP_OUT ; continue ; break ; case OP_LOOK_BEHIND : MOP_IN ( OP_LOOK_BEHIND ) ; GET_LENGTH_INC ( tlen , p ) ; s = ( UChar * ) ONIGENC_STEP_BACK ( encode , str , s , ( int ) tlen ) ; if ( IS_NULL ( s ) ) goto fail ; sprev = ( UChar * ) onigenc_get_prev_char_head ( encode , str , s ) ; MOP_OUT ; continue ; break ; case OP_PUSH_LOOK_BEHIND_NOT : MOP_IN ( OP_PUSH_LOOK_BEHIND_NOT ) ; GET_RELADDR_INC ( addr , p ) ; GET_LENGTH_INC ( tlen , p ) ; q = ( UChar * ) ONIGENC_STEP_BACK ( encode , str , s , ( int ) tlen ) ; if ( IS_NULL ( q ) ) { p += addr ; } else { STACK_PUSH_LOOK_BEHIND_NOT ( p + addr , s , sprev ) ; s = q ; sprev = ( UChar * ) onigenc_get_prev_char_head ( encode , str , s ) ; } MOP_OUT ; continue ; break ; case OP_FAIL_LOOK_BEHIND_NOT : MOP_IN ( OP_FAIL_LOOK_BEHIND_NOT ) ; STACK_POP_TIL_LOOK_BEHIND_NOT ; goto fail ; break ; # ifdef USE_SUBEXP_CALL case OP_CALL : MOP_IN ( OP_CALL ) ; GET_ABSADDR_INC ( addr , p ) ; STACK_PUSH_CALL_FRAME ( p ) ; p = reg -> p + addr ; MOP_OUT ; continue ; break ; case OP_RETURN : MOP_IN ( OP_RETURN ) ; STACK_RETURN ( p ) ; STACK_PUSH_RETURN ; MOP_OUT ; continue ; break ; # endif case OP_FINISH : goto finish ; break ; fail : MOP_OUT ; case OP_FAIL : MOP_IN ( OP_FAIL ) ; STACK_POP ; p = stk -> u . state . pcode ; s = stk -> u . state . pstr ; sprev = stk -> u . state . pstr_prev ; # ifdef USE_COMBINATION_EXPLOSION_CHECK if ( stk -> u . state . state_check != 0 ) { stk -> type = STK_STATE_CHECK_MARK ; stk ++ ; } # endif MOP_OUT ; continue ; break ; default : goto bytecode_error ; } sprev = sbegin ; } finish : STACK_SAVE ; return best_len ; # ifdef ONIG_DEBUG stack_error : STACK_SAVE ; return ONIGERR_STACK_BUG ; # endif bytecode_error : STACK_SAVE ; return ONIGERR_UNDEFINED_BYTECODE ; unexpected_bytecode_error : STACK_SAVE ; return ONIGERR_UNEXPECTED_BYTECODE ; }",DATA_ENSURE ( 1 ) ;s ++ ;,1446
356,"buggy line: for ( plane = 0 ;plane ++ )  vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ;cwe id:CWE-119context: void vp9_foreach_transformed_block ( const MACROBLOCKD * const xd , BLOCK_SIZE bsize , foreach_transformed_block_visitor visit , void * arg ) { int plane ;  for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ )  vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ; }","for ( plane = 0 ;++ plane ) vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ;",1447
357,"buggy line: int copied , error = - EINVAL ;msg -> msg_namelen = 0 ;cwe id:CWE-20context: int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ;  int copied , error = - EINVAL ;  msg -> msg_namelen = 0 ; if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( ""%d<S2SV_blank>-=<S2SV_blank>%d\\n"" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }","int copied , error = - EINVAL ;",1448
358,"buggy line: return mount_entry_on_generic ( mntent , path ) ;}cwe id:CWE-59context: static int mount_entry_on_relative_rootfs ( struct mntent * mntent , const char * rootfs ) { char path [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/%s"" , rootfs , mntent -> mnt_dir ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; }  return mount_entry_on_generic ( mntent , path ) ;  }","return mount_entry_on_generic ( mntent , path , rootfs ) ;}",1449
359,"buggy line: return fd ;}cwe id:CWE-20context: static inline int mk_vhost_fdt_open ( int id , unsigned int hash , struct session_request * sr ) { int i ; int fd ; struct vhost_fdt_hash_table * ht = NULL ; struct vhost_fdt_hash_chain * hc ; if ( config -> fdt == MK_FALSE ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } ht = mk_vhost_fdt_table_lookup ( id , sr -> host_conf ) ; if ( mk_unlikely ( ! ht ) ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } hc = mk_vhost_fdt_chain_lookup ( hash , ht ) ; if ( hc ) { hc -> readers ++ ; return hc -> fd ; } fd = open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; if ( fd == - 1 ) { return - 1 ; } if ( ht -> av_slots <= 0 ) { return fd ; } for ( i = 0 ; i < VHOST_FDT_HASHTABLE_CHAINS ; i ++ ) { hc = & ht -> chain [ i ] ; if ( hc -> fd == - 1 ) { hc -> fd = fd ; hc -> hash = hash ; hc -> readers ++ ; ht -> av_slots -- ; sr -> vhost_fdt_id = id ; sr -> vhost_fdt_hash = hash ;  return fd ;  } } return - 1 ; }",sr -> fd_is_fdt = MK_TRUE ;return fd ;},1450
360,"buggy line: static void construct_get_dest_keyring ( struct key * * _dest_keyring )  {kenter ( ""%p"" , dest_keyring ) ;if ( dest_keyring ) {key_get ( dest_keyring ) ;}else {switch ( cred -> jit_keyring ) {case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) {authkey = cred -> request_key_auth ;down_read ( & authkey -> sem ) ;rka = authkey -> payload . data [ 0 ] ;if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ;up_read ( & authkey -> sem ) ;if ( dest_keyring )  break ;}cwe id:CWE-862context:  static void construct_get_dest_keyring ( struct key * * _dest_keyring )  { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ;  kenter ( ""%p"" , dest_keyring ) ;  if ( dest_keyring ) { key_get ( dest_keyring ) ;  } else {  switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring )  break ;  } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; }  }  * _dest_keyring = dest_keyring ; kleave ( ""<S2SV_blank>[dk<S2SV_blank>%d]"" , key_serial ( dest_keyring ) ) ;  return ;  }","static int construct_get_dest_keyring ( struct key * * _dest_keyring ) {int ret ;kenter ( ""%p"" , dest_keyring ) ;if ( dest_keyring ) {do_perm_check = false ;break ;}}",1451
361,"buggy line: }* _dest_keyring = dest_keyring ;return ;}cwe id:CWE-862context:  static void construct_get_dest_keyring ( struct key * * _dest_keyring )  { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ;  kenter ( ""%p"" , dest_keyring ) ;  if ( dest_keyring ) { key_get ( dest_keyring ) ;  } else {  switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring )  break ;  } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; }  }  * _dest_keyring = dest_keyring ; kleave ( ""<S2SV_blank>[dk<S2SV_blank>%d]"" , key_serial ( dest_keyring ) ) ;  return ;  }","if ( dest_keyring && do_perm_check ) {ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ;if ( ret ) {key_put ( dest_keyring ) ;return 0 ret ;}}}* _dest_keyring = dest_keyring ;return ;}",1451
362,"buggy line: static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & cpi -> mb ;set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;if ( ! frame_is_intra_only ( cm ) ) {vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col ,  rate , dist , bsize ) ;}else {MB_PREDICTION_MODE intramode = DC_PRED ;set_mode_info ( & xd -> mi [ 0 ] -> mbmi , bsize , intramode ) ;}cwe id:CWE-119context:  static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCK * const x = & cpi -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ;  set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;   xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;  if ( ! frame_is_intra_only ( cm ) ) {  vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col ,  rate , dist , bsize ) ; } else { MB_PREDICTION_MODE intramode = DC_PRED ; set_mode_info ( & xd -> mi [ 0 ] -> mbmi , bsize , intramode ) ; } duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; }","static void nonrd_pick_sb_modes ( VP9_COMP * cpi , TileDataEnc * tile_data , MACROBLOCK * const x , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {TileInfo * const tile_info = & tile_data -> tile_info ;MB_MODE_INFO * mbmi ;set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;if ( ! frame_is_intra_only ( cm ) ) {vp9_pick_inter_mode ( cpi , tile_info , x , tile_data , mi_row , mi_col , rd_cost , bsize , ctx ) ;else vp9_pick_inter_mode_sub8x8 ( cpi , x , mi_row , mi_col , rd_cost , bsize , ctx ) ;if ( rd_cost -> rate == INT_MAX ) vp9_rd_cost_reset ( rd_cost ) ;ctx -> rate = rd_cost -> rate ;ctx -> dist = rd_cost -> dist ;",1452
363,"buggy line: dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ;if ( csum )  dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ;if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) {cwe id:CWE-119context: static int virtnet_probe ( struct virtio_device * vdev ) { int i , err ; struct net_device * dev ; struct virtnet_info * vi ; u16 max_queue_pairs ; if ( ! vdev -> config -> get ) { dev_err ( & vdev -> dev , ""%s<S2SV_blank>failure:<S2SV_blank>config<S2SV_blank>access<S2SV_blank>disabled\\n"" , __func__ ) ; return - EINVAL ; } if ( ! virtnet_validate_features ( vdev ) ) return - EINVAL ; err = virtio_cread_feature ( vdev , VIRTIO_NET_F_MQ , struct virtio_net_config , max_virtqueue_pairs , & max_queue_pairs ) ; if ( err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN || max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX || ! virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) max_queue_pairs = 1 ; dev = alloc_etherdev_mq ( sizeof ( struct virtnet_info ) , max_queue_pairs ) ; if ( ! dev ) return - ENOMEM ; dev -> priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE ; dev -> netdev_ops = & virtnet_netdev ; dev -> features = NETIF_F_HIGHDMA ; dev -> ethtool_ops = & virtnet_ethtool_ops ; SET_NETDEV_DEV ( dev , & vdev -> dev ) ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CSUM ) ) {  dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ;  if ( csum )  dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ;  if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) { dev -> hw_features |= NETIF_F_TSO | NETIF_F_UFO | NETIF_F_TSO_ECN | NETIF_F_TSO6 ; } if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO4 ) ) dev -> hw_features |= NETIF_F_TSO ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO6 ) ) dev -> hw_features |= NETIF_F_TSO6 ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_ECN ) ) dev -> hw_features |= NETIF_F_TSO_ECN ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_UFO ) ) dev -> hw_features |= NETIF_F_UFO ; dev -> features |= NETIF_F_GSO_ROBUST ; if ( gso ) dev -> features |= dev -> hw_features & ( NETIF_F_ALL_TSO | NETIF_F_UFO ) ; } if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_CSUM ) ) dev -> features |= NETIF_F_RXCSUM ; dev -> vlan_features = dev -> features ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MAC ) ) virtio_cread_bytes ( vdev , offsetof ( struct virtio_net_config , mac ) , dev -> dev_addr , dev -> addr_len ) ; else eth_hw_addr_random ( dev ) ; vi = netdev_priv ( dev ) ; vi -> dev = dev ; vi -> vdev = vdev ; vdev -> priv = vi ; vi -> stats = alloc_percpu ( struct virtnet_stats ) ; err = - ENOMEM ; if ( vi -> stats == NULL ) goto free ; for_each_possible_cpu ( i ) { struct virtnet_stats * virtnet_stats ; virtnet_stats = per_cpu_ptr ( vi -> stats , i ) ; u64_stats_init ( & virtnet_stats -> tx_syncp ) ; u64_stats_init ( & virtnet_stats -> rx_syncp ) ; } INIT_WORK ( & vi -> config_work , virtnet_config_changed_work ) ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_TSO4 ) || virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_TSO6 ) || virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_ECN ) || virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_UFO ) ) vi -> big_packets = true ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MRG_RXBUF ) ) vi -> mergeable_rx_bufs = true ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MRG_RXBUF ) || virtio_has_feature ( vdev , VIRTIO_F_VERSION_1 ) ) vi -> hdr_len = sizeof ( struct virtio_net_hdr_mrg_rxbuf ) ; else vi -> hdr_len = sizeof ( struct virtio_net_hdr ) ; if ( virtio_has_feature ( vdev , VIRTIO_F_ANY_LAYOUT ) || virtio_has_feature ( vdev , VIRTIO_F_VERSION_1 ) ) vi -> any_header_sg = true ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) vi -> has_cvq = true ; if ( vi -> any_header_sg ) dev -> needed_headroom = vi -> hdr_len ; vi -> curr_queue_pairs = 1 ; vi -> max_queue_pairs = max_queue_pairs ; err = init_vqs ( vi ) ; if ( err ) goto free_stats ; # ifdef CONFIG_SYSFS if ( vi -> mergeable_rx_bufs ) dev -> sysfs_rx_queue_group = & virtio_net_mrg_rx_group ; # endif netif_set_real_num_tx_queues ( dev , vi -> curr_queue_pairs ) ; netif_set_real_num_rx_queues ( dev , vi -> curr_queue_pairs ) ; err = register_netdev ( dev ) ; if ( err ) { pr_debug ( ""virtio_net:<S2SV_blank>registering<S2SV_blank>device<S2SV_blank>failed\\n"" ) ; goto free_vqs ; } virtio_device_ready ( vdev ) ; for ( i = 0 ; i < vi -> curr_queue_pairs ; i ++ ) { try_fill_recv ( vi , & vi -> rq [ i ] , GFP_KERNEL ) ; if ( vi -> rq [ i ] . vq -> num_free == virtqueue_get_vring_size ( vi -> rq [ i ] . vq ) ) { free_unused_bufs ( vi ) ; err = - ENOMEM ; goto free_recv_bufs ; } } vi -> nb . notifier_call = & virtnet_cpu_callback ; err = register_hotcpu_notifier ( & vi -> nb ) ; if ( err ) { pr_debug ( ""virtio_net:<S2SV_blank>registering<S2SV_blank>cpu<S2SV_blank>notifier<S2SV_blank>failed\\n"" ) ; goto free_recv_bufs ; } if ( virtio_has_feature ( vi -> vdev , VIRTIO_NET_F_STATUS ) ) { netif_carrier_off ( dev ) ; schedule_work ( & vi -> config_work ) ; } else { vi -> status = VIRTIO_NET_S_LINK_UP ; netif_carrier_on ( dev ) ; } pr_debug ( ""virtnet:<S2SV_blank>registered<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>RX<S2SV_blank>and<S2SV_blank>TX<S2SV_blank>vq\'s\\n"" , dev -> name , max_queue_pairs ) ; return 0 ; free_recv_bufs : vi -> vdev -> config -> reset ( vdev ) ; free_receive_bufs ( vi ) ; unregister_netdev ( dev ) ; free_vqs : cancel_delayed_work_sync ( & vi -> refill ) ; free_receive_page_frags ( vi ) ; virtnet_del_vqs ( vi ) ; free_stats : free_percpu ( vi -> stats ) ; free : free_netdev ( dev ) ; return err ; }","dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG ;if ( csum ) dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG ;if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) {",1453
364,"buggy line: cwe id:CWE-787context: MYSOFA_EXPORT struct MYSOFA_HRTF * mysofa_load ( const char * filename , int * err ) { struct READER reader ; struct MYSOFA_HRTF * hrtf = NULL ; if ( filename == NULL ) filename = CMAKE_INSTALL_PREFIX ""/share/libmysofa/default.sofa"" ; if ( strcmp ( filename , ""-"" ) ) reader . fhd = fopen ( filename , ""rb"" ) ; else reader . fhd = stdin ; if ( ! reader . fhd ) { log ( ""cannot<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s\\n"" , filename ) ; * err = errno ; return NULL ; } reader . gcol = NULL ; reader . all = NULL ;  * err = superblockRead ( & reader , & reader . superblock ) ;  if ( ! * err ) { hrtf = getHrtf ( & reader , err ) ; } superblockFree ( & reader , & reader . superblock ) ; gcolFree ( reader . gcol ) ; if ( strcmp ( filename , ""-"" ) ) fclose ( reader . fhd ) ; return hrtf ; }",reader . recursive_counter = 0 ;,1454
365,"buggy line: * err = superblockRead ( & reader , & reader . superblock ) ;if ( ! * err ) {cwe id:CWE-787context: MYSOFA_EXPORT struct MYSOFA_HRTF * mysofa_load ( const char * filename , int * err ) { struct READER reader ; struct MYSOFA_HRTF * hrtf = NULL ; if ( filename == NULL ) filename = CMAKE_INSTALL_PREFIX ""/share/libmysofa/default.sofa"" ; if ( strcmp ( filename , ""-"" ) ) reader . fhd = fopen ( filename , ""rb"" ) ; else reader . fhd = stdin ; if ( ! reader . fhd ) { log ( ""cannot<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s\\n"" , filename ) ; * err = errno ; return NULL ; } reader . gcol = NULL ; reader . all = NULL ;  * err = superblockRead ( & reader , & reader . superblock ) ;  if ( ! * err ) { hrtf = getHrtf ( & reader , err ) ; } superblockFree ( & reader , & reader . superblock ) ; gcolFree ( reader . gcol ) ; if ( strcmp ( filename , ""-"" ) ) fclose ( reader . fhd ) ; return hrtf ; }","* err = superblockRead ( & reader , & reader . superblock ) ;if ( ! * err ) {",1454
366,"buggy line: if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) )  {cwe id:CWE-908context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;  if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) )  { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { ValidateColormapValue ( image , * p & mask , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) {",1455
367,"buggy line: int tmp ;if ( copy_from_user ( buf , buffer , count ) )  return - EFAULT ;cwe id:CWE-119context: static ssize_t exitcode_proc_write ( struct file * file , const char __user * buffer , size_t count , loff_t * pos ) { char * end , buf [ sizeof ( ""nnnnn\\0"" ) ] ;  int tmp ;   if ( copy_from_user ( buf , buffer , count ) )  return - EFAULT ; tmp = simple_strtol ( buf , & end , 0 ) ; if ( ( * end != '\\0' ) && ! isspace ( * end ) ) return - EINVAL ; uml_exitcode = tmp ; return count ; }","size_t size ;int tmp ;size = min ( count , sizeof ( buf ) ) ;if ( copy_from_user ( buf , buffer , size ) ) return - EFAULT ;",1456
368,"buggy line: pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ;pMap -> ranges [ 0 ] . addr = memPtr ;cwe id:CWE-189context: static int sysMapFD ( int fd , MemMapping * pMap ) { off_t start ; size_t length ; void * memPtr ; assert ( pMap != NULL ) ; if ( getFileStartAndLength ( fd , & start , & length ) < 0 ) return - 1 ; memPtr = mmap ( NULL , length , PROT_READ , MAP_PRIVATE , fd , start ) ; if ( memPtr == MAP_FAILED ) { LOGW ( ""mmap(%d,<S2SV_blank>R,<S2SV_blank>PRIVATE,<S2SV_blank>%d,<S2SV_blank>%d)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( int ) length , fd , ( int ) start , strerror ( errno ) ) ; return - 1 ; } pMap -> addr = memPtr ; pMap -> length = length ; pMap -> range_count = 1 ;  pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ;  pMap -> ranges [ 0 ] . addr = memPtr ; pMap -> ranges [ 0 ] . length = length ; return 0 ; }","if ( pMap -> ranges == NULL ) {LOGE ( ""malloc<S2SV_blank>failed:<S2SV_blank>%s\\\munmap ( memPtr , length ) ;return - 1 ;}pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ;pMap -> ranges [ 0 ] . addr = memPtr ;",1457
369,"buggy line: case S_IFREG : case S_IFLNK : case S_IFDIR :  switch ( dip -> di_format ) {case XFS_DINODE_FMT_LOCAL : if ( S_ISREG ( mode ) ) return __this_address ;if ( di_size > XFS_DFORK_DSIZE ( dip , mp ) ) return __this_address ;if ( dip -> di_nextents ) return __this_address ;case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ;default : return __this_address ;}switch ( dip -> di_aformat ) {case XFS_DINODE_FMT_LOCAL : if ( dip -> di_anextents ) return __this_address ;case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ;default : return __this_address ;}cwe id:CWE-476context: xfs_failaddr_t xfs_dinode_verify ( struct xfs_mount * mp , xfs_ino_t ino , struct xfs_dinode * dip ) { xfs_failaddr_t fa ; uint16_t mode ; uint16_t flags ; uint64_t flags2 ; uint64_t di_size ; if ( dip -> di_magic != cpu_to_be16 ( XFS_DINODE_MAGIC ) ) return __this_address ; if ( dip -> di_version >= 3 ) { if ( ! xfs_sb_version_hascrc ( & mp -> m_sb ) ) return __this_address ; if ( ! xfs_verify_cksum ( ( char * ) dip , mp -> m_sb . sb_inodesize , XFS_DINODE_CRC_OFF ) ) return __this_address ; if ( be64_to_cpu ( dip -> di_ino ) != ino ) return __this_address ; if ( ! uuid_equal ( & dip -> di_uuid , & mp -> m_sb . sb_meta_uuid ) ) return __this_address ; } di_size = be64_to_cpu ( dip -> di_size ) ; if ( di_size & ( 1ULL << 63 ) ) return __this_address ; mode = be16_to_cpu ( dip -> di_mode ) ; if ( mode && xfs_mode_to_ftype ( mode ) == XFS_DIR3_FT_UNKNOWN ) return __this_address ; if ( ( S_ISLNK ( mode ) || S_ISDIR ( mode ) ) && di_size == 0 ) return __this_address ; if ( mode && be32_to_cpu ( dip -> di_nextents ) + be16_to_cpu ( dip -> di_anextents ) > be64_to_cpu ( dip -> di_nblocks ) ) return __this_address ; if ( mode && XFS_DFORK_BOFF ( dip ) > mp -> m_sb . sb_inodesize ) return __this_address ; flags = be16_to_cpu ( dip -> di_flags ) ; if ( mode && ( flags & XFS_DIFLAG_REALTIME ) && ! mp -> m_rtdev_targp ) return __this_address ; switch ( mode & S_IFMT ) { case S_IFIFO : case S_IFCHR : case S_IFBLK : case S_IFSOCK : if ( dip -> di_format != XFS_DINODE_FMT_DEV ) return __this_address ; break ; case S_IFREG : case S_IFLNK : case S_IFDIR :  switch ( dip -> di_format ) {  case XFS_DINODE_FMT_LOCAL : if ( S_ISREG ( mode ) ) return __this_address ; if ( di_size > XFS_DFORK_DSIZE ( dip , mp ) ) return __this_address ; if ( dip -> di_nextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { switch ( dip -> di_aformat ) { case XFS_DINODE_FMT_LOCAL : if ( dip -> di_anextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } } else { switch ( dip -> di_aformat ) { case 0 : case XFS_DINODE_FMT_EXTENTS : break ; default : return __this_address ; } if ( dip -> di_anextents ) return __this_address ; } fa = xfs_inode_validate_extsize ( mp , be32_to_cpu ( dip -> di_extsize ) , mode , flags ) ; if ( fa ) return fa ; if ( dip -> di_version < 3 ) return NULL ; flags2 = be64_to_cpu ( dip -> di_flags2 ) ; if ( ( flags2 & ( XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE ) ) && ! xfs_sb_version_hasreflink ( & mp -> m_sb ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( mode & S_IFMT ) != S_IFREG ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags & XFS_DIFLAG_REALTIME ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags2 & XFS_DIFLAG2_DAX ) ) return __this_address ; fa = xfs_inode_validate_cowextsize ( mp , be32_to_cpu ( dip -> di_cowextsize ) , mode , flags , flags2 ) ; if ( fa ) return fa ; return NULL ; }","case S_IFREG : case S_IFLNK : case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ;if ( fa ) return fa ;fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ;if ( fa ) return fa ;",1458
370,"buggy line: if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 )  return ret ;cwe id:CWE-119context: static int decode_unit ( SCPRContext * s , PixelModel * pixel , unsigned step , unsigned * rval ) { GetByteContext * gb = & s -> gb ; RangeCoder * rc = & s -> rc ; unsigned totfr = pixel -> total_freq ; unsigned value , x = 0 , cumfr = 0 , cnt_x = 0 ; int i , j , ret , c , cnt_c ; if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) return ret ; while ( x < 16 ) { cnt_x = pixel -> lookup [ x ] ; if ( value >= cumfr + cnt_x ) cumfr += cnt_x ; else break ; x ++ ; } c = x * 16 ; cnt_c = 0 ; while ( c < 256 ) { cnt_c = pixel -> freq [ c ] ; if ( value >= cumfr + cnt_c ) cumfr += cnt_c ; else break ; c ++ ; }  if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 )  return ret ; pixel -> freq [ c ] = cnt_c + step ; pixel -> lookup [ x ] = cnt_x + step ; totfr += step ; if ( totfr > BOT ) { totfr = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { unsigned nc = ( pixel -> freq [ i ] >> 1 ) + 1 ; pixel -> freq [ i ] = nc ; totfr += nc ; } for ( i = 0 ; i < 16 ; i ++ ) { unsigned sum = 0 ; unsigned i16_17 = i << 4 ; for ( j = 0 ; j < 16 ; j ++ ) sum += pixel -> freq [ i16_17 + j ] ; pixel -> lookup [ i ] = sum ; } } pixel -> total_freq = totfr ; * rval = c & s -> cbits ; return 0 ; }","if ( x >= 16 || c >= 256 ) {return AVERROR_INVALIDDATA ;}if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) return ret ;",1459
371,"buggy line: jas_tvparser_destroy ( tvp ) ;if ( ! cmpt -> sampperx || ! cmpt -> samppery ) {return 0 ;error : if ( cmpt ) {cwe id:CWE-416context: static int mif_process_cmpt ( mif_hdr_t * hdr , char * buf ) { jas_tvparser_t * tvp ; mif_cmpt_t * cmpt ; int id ; cmpt = 0 ; tvp = 0 ; if ( ! ( cmpt = mif_cmpt_create ( ) ) ) { goto error ; } cmpt -> tlx = 0 ; cmpt -> tly = 0 ; cmpt -> sampperx = 0 ; cmpt -> samppery = 0 ; cmpt -> width = 0 ; cmpt -> height = 0 ; cmpt -> prec = 0 ; cmpt -> sgnd = - 1 ; cmpt -> data = 0 ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { goto error ; } while ( ! ( id = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case MIF_TLX : cmpt -> tlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_TLY : cmpt -> tly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_WIDTH : cmpt -> width = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HEIGHT : cmpt -> height = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HSAMP : cmpt -> sampperx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_VSAMP : cmpt -> samppery = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_PREC : cmpt -> prec = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_SGND : cmpt -> sgnd = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_DATA : if ( ! ( cmpt -> data = jas_strdup ( jas_tvparser_getval ( tvp ) ) ) ) { return - 1 ; } break ; } }  jas_tvparser_destroy ( tvp ) ;  if ( ! cmpt -> sampperx || ! cmpt -> samppery ) { goto error ; } if ( mif_hdr_addcmpt ( hdr , hdr -> numcmpts , cmpt ) ) { goto error ; }  return 0 ;  error : if ( cmpt ) { mif_cmpt_destroy ( cmpt ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return - 1 ; }",if ( ! cmpt -> sampperx || ! cmpt -> samppery ) {jas_tvparser_destroy ( tvp ) ;return 0 ;error : if ( cmpt ) {,1460
372,"buggy line: if ( ! ctx -> cfg . rc_target_bitrate ) return res ;if ( img ) res = validate_img ( ctx , img ) ;if ( ! res ) res = validate_config ( ctx , & ctx -> cfg , & ctx -> vp8_cfg , 1 ) ;pick_quickcompress_mode ( ctx , duration , deadline ) ;vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ;if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) )  || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) {ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ;return VPX_CODEC_INVALID_PARAM ;}if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF ) ) {int ref = 7 ;if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP8_LAST_FRAME ;if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP8_GOLD_FRAME ;if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP8_ALTR_FRAME ;vp8_use_as_reference ( ctx -> cpi , ref ) ;}if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) {int upd = 7 ;if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP8_LAST_FRAME ;if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP8_GOLD_FRAME ;if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP8_ALTR_FRAME ;vp8_update_reference ( ctx -> cpi , upd ) ;}if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) {vp8_update_entropy ( ctx -> cpi , 0 ) ;cwe id:CWE-119context: static vpx_codec_err_t vp8e_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ! ctx -> cfg . rc_target_bitrate ) return res ; if ( img ) res = validate_img ( ctx , img ) ; if ( ! res ) res = validate_config ( ctx , & ctx -> cfg , & ctx -> vp8_cfg , 1 ) ; pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ;  if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) )  || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ; return VPX_CODEC_INVALID_PARAM ; } if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP8_LAST_FRAME ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP8_GOLD_FRAME ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP8_ALTR_FRAME ; vp8_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP8_LAST_FRAME ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP8_GOLD_FRAME ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP8_ALTR_FRAME ; vp8_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp8_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { flags |= VPX_EFLAG_FORCE_KF ; ctx -> fixed_kf_cntr = 1 ; } } if ( ! res && ctx -> cpi ) { unsigned int lib_flags ; YV12_BUFFER_CONFIG sd ; int64_t dst_time_stamp , dst_end_time_stamp ; unsigned long size , cx_data_sz ; unsigned char * cx_data ; unsigned char * cx_data_end ; int comp_data_state = 0 ; if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) ( ( VP8_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ; if ( ctx -> base . init_flags & VPX_CODEC_USE_OUTPUT_PARTITION ) ( ( VP8_COMP * ) ctx -> cpi ) -> output_partition = 1 ; lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; dst_time_stamp = pts * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; if ( img != NULL ) { res = image2yuvconfig ( img , & sd ) ; if ( vp8_receive_raw_frame ( ctx -> cpi , ctx -> next_frame_flag | lib_flags , & sd , dst_time_stamp , dst_end_time_stamp ) ) { VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ; res = update_error_state ( ctx , & cpi -> common . error ) ; } ctx -> next_frame_flag = 0 ; } cx_data = ctx -> cx_data ; cx_data_sz = ctx -> cx_data_sz ; cx_data_end = ctx -> cx_data + cx_data_sz ; lib_flags = 0 ; while ( cx_data_sz >= ctx -> cx_data_sz / 2 ) { comp_data_state = vp8_get_compressed_data ( ctx -> cpi , & lib_flags , & size , cx_data , cx_data_end , & dst_time_stamp , & dst_end_time_stamp , ! img ) ; if ( comp_data_state == VPX_CODEC_CORRUPT_FRAME ) return VPX_CODEC_CORRUPT_FRAME ; else if ( comp_data_state == - 1 ) break ; if ( size ) { vpx_codec_pts_t round , delta ; vpx_codec_cx_pkt_t pkt ; VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ;  round = ( vpx_codec_pts_t ) 1000000  * ctx -> cfg . g_timebase . num / 2 - 1 ; delta = ( dst_end_time_stamp - dst_time_stamp ) ; pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ; pkt . data . frame . duration = ( unsigned long ) ( ( delta * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) ; pkt . data . frame . flags = lib_flags << 16 ; if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; if ( ! cpi -> common . show_frame ) { pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; pkt . data . frame . duration = 0 ; } if ( cpi -> droppable ) pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; if ( cpi -> output_partition ) { int i ; const int num_partitions = ( 1 << cpi -> common . multi_token_partition ) + 1 ; pkt . data . frame . flags |= VPX_FRAME_IS_FRAGMENT ; for ( i = 0 ; i < num_partitions ; ++ i ) { # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING pkt . data . frame . buf = cpi -> partition_d [ i ] ; # else pkt . data . frame . buf = cx_data ; cx_data += cpi -> partition_sz [ i ] ; cx_data_sz -= cpi -> partition_sz [ i ] ; # endif pkt . data . frame . sz = cpi -> partition_sz [ i ] ; pkt . data . frame . partition_id = i ; if ( i == ( num_partitions - 1 ) ) pkt . data . frame . flags &= ~ VPX_FRAME_IS_FRAGMENT ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; } # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING cx_data_sz -= ctx -> cx_data_sz / 2 ; # endif } else { pkt . data . frame . buf = cx_data ; pkt . data . frame . sz = size ; pkt . data . frame . partition_id = - 1 ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; cx_data += size ; cx_data_sz -= size ; } } } } return res ; }","if ( ! flags ) {flags = ctx -> control_frame_flags ;ctx -> control_frame_flags = 0 ;res = set_reference_and_update ( ctx , flags ) ;",1461
373,"buggy line: round = ( vpx_codec_pts_t ) 1000000  * ctx -> cfg . g_timebase . num / 2 - 1 ;cwe id:CWE-119context: static vpx_codec_err_t vp8e_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ! ctx -> cfg . rc_target_bitrate ) return res ; if ( img ) res = validate_img ( ctx , img ) ; if ( ! res ) res = validate_config ( ctx , & ctx -> cfg , & ctx -> vp8_cfg , 1 ) ; pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ;  if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) )  || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ; return VPX_CODEC_INVALID_PARAM ; } if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP8_LAST_FRAME ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP8_GOLD_FRAME ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP8_ALTR_FRAME ; vp8_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP8_LAST_FRAME ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP8_GOLD_FRAME ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP8_ALTR_FRAME ; vp8_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp8_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { flags |= VPX_EFLAG_FORCE_KF ; ctx -> fixed_kf_cntr = 1 ; } } if ( ! res && ctx -> cpi ) { unsigned int lib_flags ; YV12_BUFFER_CONFIG sd ; int64_t dst_time_stamp , dst_end_time_stamp ; unsigned long size , cx_data_sz ; unsigned char * cx_data ; unsigned char * cx_data_end ; int comp_data_state = 0 ; if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) ( ( VP8_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ; if ( ctx -> base . init_flags & VPX_CODEC_USE_OUTPUT_PARTITION ) ( ( VP8_COMP * ) ctx -> cpi ) -> output_partition = 1 ; lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; dst_time_stamp = pts * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; if ( img != NULL ) { res = image2yuvconfig ( img , & sd ) ; if ( vp8_receive_raw_frame ( ctx -> cpi , ctx -> next_frame_flag | lib_flags , & sd , dst_time_stamp , dst_end_time_stamp ) ) { VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ; res = update_error_state ( ctx , & cpi -> common . error ) ; } ctx -> next_frame_flag = 0 ; } cx_data = ctx -> cx_data ; cx_data_sz = ctx -> cx_data_sz ; cx_data_end = ctx -> cx_data + cx_data_sz ; lib_flags = 0 ; while ( cx_data_sz >= ctx -> cx_data_sz / 2 ) { comp_data_state = vp8_get_compressed_data ( ctx -> cpi , & lib_flags , & size , cx_data , cx_data_end , & dst_time_stamp , & dst_end_time_stamp , ! img ) ; if ( comp_data_state == VPX_CODEC_CORRUPT_FRAME ) return VPX_CODEC_CORRUPT_FRAME ; else if ( comp_data_state == - 1 ) break ; if ( size ) { vpx_codec_pts_t round , delta ; vpx_codec_cx_pkt_t pkt ; VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ;  round = ( vpx_codec_pts_t ) 1000000  * ctx -> cfg . g_timebase . num / 2 - 1 ; delta = ( dst_end_time_stamp - dst_time_stamp ) ; pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ; pkt . data . frame . duration = ( unsigned long ) ( ( delta * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) ; pkt . data . frame . flags = lib_flags << 16 ; if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; if ( ! cpi -> common . show_frame ) { pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; pkt . data . frame . duration = 0 ; } if ( cpi -> droppable ) pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; if ( cpi -> output_partition ) { int i ; const int num_partitions = ( 1 << cpi -> common . multi_token_partition ) + 1 ; pkt . data . frame . flags |= VPX_FRAME_IS_FRAGMENT ; for ( i = 0 ; i < num_partitions ; ++ i ) { # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING pkt . data . frame . buf = cpi -> partition_d [ i ] ; # else pkt . data . frame . buf = cx_data ; cx_data += cpi -> partition_sz [ i ] ; cx_data_sz -= cpi -> partition_sz [ i ] ; # endif pkt . data . frame . sz = cpi -> partition_sz [ i ] ; pkt . data . frame . partition_id = i ; if ( i == ( num_partitions - 1 ) ) pkt . data . frame . flags &= ~ VPX_FRAME_IS_FRAGMENT ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; } # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING cx_data_sz -= ctx -> cx_data_sz / 2 ; # endif } else { pkt . data . frame . buf = cx_data ; pkt . data . frame . sz = size ; pkt . data . frame . partition_id = - 1 ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; cx_data += size ; cx_data_sz -= size ; } } } } return res ; }",round = ( vpx_codec_pts_t ) 10000000 * ctx -> cfg . g_timebase . num / 2 - 1 ;,1461
374,"buggy line: BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ;if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;cwe id:CWE-125context: static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ;  if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }","BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ;if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",1462
375,"buggy line: if ( is_sampling_event ( event ) ) {if ( ! head ) {WARN_ON_ONCE ( swhash -> online ) ;return - EINVAL ;}hlist_add_head_rcu ( & event -> hlist_entry , head ) ;cwe id:CWE-362context: static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ;  if ( ! head ) {  WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ;  }  hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }","if ( WARN_ON_ONCE ( is_sampling_event ( event ) ) {if ( ! head ) ) return - EINVAL ;}hlist_add_head_rcu ( & event -> hlist_entry , head ) ;",1463
376,"buggy line: static int bgp_attr_print ( netdissect_options * ndo ,  u_int atype , const u_char * pptr , u_int len )  {cwe id:CWE-674context: static int bgp_attr_print ( netdissect_options * ndo ,  u_int atype , const u_char * pptr , u_int len )  { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; }  if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) )  return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }","static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len , const unsigned attr_set_level ) {",1464
377,"buggy line: if ( ! len ) {cwe id:CWE-674context: static int bgp_attr_print ( netdissect_options * ndo ,  u_int atype , const u_char * pptr , u_int len )  { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; }  if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) )  return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }","if ( attr_set_level == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ;else if ( ! len ) {",1464
378,"buggy line: if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) )  return 0 ;cwe id:CWE-674context: static int bgp_attr_print ( netdissect_options * ndo ,  u_int atype , const u_char * pptr , u_int len )  { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; }  if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) )  return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }","if ( ! bgp_attr_print ( ndo , atype , tptr , alen , attr_set_level + 1 ) ) return 0 ;",1464
379,"buggy line: StringBuffer_append ( res -> outputbuffer , ""<h2>Monit<S2SV_blank>runtime<S2SV_blank>status</h2>"" ) ;StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\\\'status-table\\\'><tr>"" ""<th<S2SV_blank>width=\\\'40%%\\\'>Parameter</th>"" ""<th<S2SV_blank>width=\\\'60%%\\\'>Value</th></tr>"" ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Monit<S2SV_blank>ID</td><td>%s</td></tr>"" , Run . id ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Host</td><td>%s</td></tr>"" , Run . system -> name ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Process<S2SV_blank>id</td><td>%d</td></tr>"" , pid ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Effective<S2SV_blank>user<S2SV_blank>running<S2SV_blank>Monit</td>"" ""<td>%s</td></tr>"" , Run . Env . user ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Controlfile</td><td>%s</td></tr>"" , Run . files . control ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Debug</td><td>%s</td></tr>"" , Run . debug ? ""True"" : ""False"" ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Log</td><td>%s</td></tr>"" , ( Run . flags & Run_Log ) ? ""True"" : ""False"" ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>syslog</td><td>%s</td></tr>"" , ( Run . flags & Run_UseSyslog ) ? ""True"" : ""False"" ) ;if ( Run . eventlist_dir ) {if ( Run . eventlist_slots < 0 ) snprintf ( buf , STRLEN , ""unlimited"" ) ;else snprintf ( buf , STRLEN , ""%d"" , Run . eventlist_slots ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Event<S2SV_blank>queue</td>"" ""<td>base<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>slots</td></tr>"" , Run . eventlist_dir , Run . eventlist_slots ) ;cwe id:CWE-352context: static void do_runtime ( HttpRequest req , HttpResponse res ) { int pid = exist_daemon ( ) ; char buf [ STRLEN ] ; do_head ( res , ""_runtime"" , ""Runtime"" , 1000 ) ; StringBuffer_append ( res -> outputbuffer , ""<h2>Monit<S2SV_blank>runtime<S2SV_blank>status</h2>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\'status-table\'><tr>"" ""<th<S2SV_blank>width=\'40%%\'>Parameter</th>"" ""<th<S2SV_blank>width=\'60%%\'>Value</th></tr>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Monit<S2SV_blank>ID</td><td>%s</td></tr>"" , Run . id ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Host</td><td>%s</td></tr>"" , Run . system -> name ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Process<S2SV_blank>id</td><td>%d</td></tr>"" , pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Effective<S2SV_blank>user<S2SV_blank>running<S2SV_blank>Monit</td>"" ""<td>%s</td></tr>"" , Run . Env . user ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Controlfile</td><td>%s</td></tr>"" , Run . files . control ) ; if ( Run . files . log ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Logfile</td><td>%s</td></tr>"" , Run . files . log ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Pidfile</td><td>%s</td></tr>"" , Run . files . pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>State<S2SV_blank>file</td><td>%s</td></tr>"" , Run . files . state ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Debug</td><td>%s</td></tr>"" , Run . debug ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Log</td><td>%s</td></tr>"" , ( Run . flags & Run_Log ) ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>syslog</td><td>%s</td></tr>"" , ( Run . flags & Run_UseSyslog ) ? ""True"" : ""False"" ) ; if ( Run . eventlist_dir ) { if ( Run . eventlist_slots < 0 ) snprintf ( buf , STRLEN , ""unlimited"" ) ; else snprintf ( buf , STRLEN , ""%d"" , Run . eventlist_slots ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Event<S2SV_blank>queue</td>"" ""<td>base<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>slots</td></tr>"" , Run . eventlist_dir , Run . eventlist_slots ) ; } # ifdef HAVE_OPENSSL { const char * options = Ssl_printOptions ( & ( Run . ssl ) , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>SSL<S2SV_blank>options</td><td>%s</td></tr>"" , options ) ; } # endif if ( Run . mmonits ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>M/Monit<S2SV_blank>server(s)</td><td>"" ) ; for ( Mmonit_T c = Run . mmonits ; c ; c = c -> next ) { StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>with<S2SV_blank>timeout<S2SV_blank>%s"" , c -> url -> url , Str_milliToTime ( c -> timeout , ( char [ 23 ] ) { } ) ) ; # ifdef HAVE_OPENSSL if ( c -> ssl . flags ) { StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>SSL/TLS"" ) ; const char * options = Ssl_printOptions ( & c -> ssl , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>with<S2SV_blank>options<S2SV_blank>{%s}"" , options ) ; if ( c -> ssl . checksum ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>and<S2SV_blank>certificate<S2SV_blank>checksum<S2SV_blank>%s<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>\'%s\'"" , checksumnames [ c -> ssl . checksumType ] , c -> ssl . checksum ) ; } # endif if ( c -> url -> user ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>credentials"" ) ; if ( c -> next ) StringBuffer_append ( res -> outputbuffer , ""</td></tr><tr><td>&nbsp;</td><td>"" ) ; } StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . mailservers ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Mail<S2SV_blank>server(s)</td><td>"" ) ; for ( MailServer_T mta = Run . mailservers ; mta ; mta = mta -> next ) { StringBuffer_append ( res -> outputbuffer , ""%s:%d"" , mta -> host , mta -> port ) ; # ifdef HAVE_OPENSSL if ( mta -> ssl . flags ) { StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>SSL/TLS"" ) ; const char * options = Ssl_printOptions ( & mta -> ssl , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>with<S2SV_blank>options<S2SV_blank>{%s}"" , options ) ; if ( mta -> ssl . checksum ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>and<S2SV_blank>certificate<S2SV_blank>checksum<S2SV_blank>%s<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>\'%s\'"" , checksumnames [ mta -> ssl . checksumType ] , mta -> ssl . checksum ) ; } # endif if ( mta -> next ) StringBuffer_append ( res -> outputbuffer , ""</td></tr><tr><td>&nbsp;</td><td>"" ) ; } StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . from ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>from</td><td>"" ) ; if ( Run . MailFormat . from -> name ) StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>&lt;%s&gt;"" , Run . MailFormat . from -> name , Run . MailFormat . from -> address ) ; else StringBuffer_append ( res -> outputbuffer , ""%s"" , Run . MailFormat . from -> address ) ; StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . replyto ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>reply<S2SV_blank>to</td><td>"" ) ; if ( Run . MailFormat . replyto -> name ) StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>&lt;%s&gt;"" , Run . MailFormat . replyto -> name , Run . MailFormat . replyto -> address ) ; else StringBuffer_append ( res -> outputbuffer , ""%s"" , Run . MailFormat . replyto -> address ) ; StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . subject ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>subject</td><td>%s</td></tr>"" , Run . MailFormat . subject ) ; if ( Run . MailFormat . message ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>message</td><td>%s</td></tr>"" , Run . MailFormat . message ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>Send/Expect<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . sendExpectBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>file<S2SV_blank>content<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . fileContentBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>HTTP<S2SV_blank>content<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . httpContentBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>program<S2SV_blank>output</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . programOutput , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>network<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . networkTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>check<S2SV_blank>program<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . programTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>stop<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . stopTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>start<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . startTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>restart<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . restartTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>On<S2SV_blank>reboot</td><td>%s</td></tr>"" , onrebootnames [ Run . onreboot ] ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Poll<S2SV_blank>time</td><td>%d<S2SV_blank>seconds<S2SV_blank>with<S2SV_blank>start<S2SV_blank>delay<S2SV_blank>%d<S2SV_blank>seconds</td></tr>"" , Run . polltime , Run . startdelay ) ; if ( Run . httpd . flags & Httpd_Net ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>bind<S2SV_blank>address</td><td>%s</td></tr>"" , Run . httpd . socket . net . address ? Run . httpd . socket . net . address : ""Any/All"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>portnumber</td><td>%d</td></tr>"" , Run . httpd . socket . net . port ) ; } else if ( Run . httpd . flags & Httpd_Unix ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>unix<S2SV_blank>socket</td><td>%s</td></tr>"" , Run . httpd . socket . unix . path ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>signature</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_Signature ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>ssl<S2SV_blank>encryption</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_Ssl ? ""True"" : ""False"" ) ; if ( Run . httpd . flags & Httpd_Ssl ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>PEM<S2SV_blank>key/certificate<S2SV_blank>file</td><td>%s</td></tr>"" , Run . httpd . socket . net . ssl . pem ) ; if ( Run . httpd . socket . net . ssl . clientpem != NULL ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certification"" ""</td><td>%s</td></tr>"" , ""Enabled"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certificate<S2SV_blank>file"" ""</td><td>%s</td></tr>"" , Run . httpd . socket . net . ssl . clientpem ) ; } else { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certification"" ""</td><td>%s</td></tr>"" , ""Disabled"" ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>Allow<S2SV_blank>self<S2SV_blank>certified<S2SV_blank>certificates<S2SV_blank>"" ""</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_AllowSelfSignedCertificates ? ""True"" : ""False"" ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>auth.<S2SV_blank>style</td><td>%s</td></tr>"" , Run . httpd . credentials && Engine_hasAllow ( ) ? ""Basic<S2SV_blank>Authentication<S2SV_blank>and<S2SV_blank>Host/Net<S2SV_blank>allow<S2SV_blank>list"" : Run . httpd . credentials ? ""Basic<S2SV_blank>Authentication"" : Engine_hasAllow ( ) ? ""Host/Net<S2SV_blank>allow<S2SV_blank>list"" : ""No<S2SV_blank>authentication"" ) ; print_alerts ( res , Run . maillist ) ; StringBuffer_append ( res -> outputbuffer , ""</table>"" ) ; if ( ! is_readonly ( req ) ) { StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\'buttons\'><tr>"" ) ; StringBuffer_append ( res -> outputbuffer ,  ""<td<S2SV_blank>style=\'color:red;\'><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>""  ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank><input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; if ( ( Run . flags & Run_Log ) && ! ( Run . flags & Run_UseSyslog ) ) { StringBuffer_append ( res -> outputbuffer ,  ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ;  } StringBuffer_append ( res -> outputbuffer , ""</tr></table>"" ) ; } do_foot ( res ) ; }","StringBuffer_append ( res -> outputbuffer , ""<td<S2SV_blank>style=\\\'color:red;\\\'>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\\\'_runtime\\\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'action\\\'<S2SV_blank>value=\\\'stop\\\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'>"" ""</form>"" ""</td>"" , res -> token ) ;StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\\\'_runtime\\\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'action\\\'<S2SV_blank>value=\\\'validate\\\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'>"" ""</form>"" ""</td>"" , res -> token ) ;StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\\\'_viewlog\\\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'>"" ""</form>"" ""</td>"" , res -> token ) ;",1465
380,"buggy line: StringBuffer_append ( res -> outputbuffer ,  ""<td<S2SV_blank>style=\\\'color:red;\\\'><form<S2SV_blank>method=POST<S2SV_blank>action=\\\'_runtime\\\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>""  ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'action\\\'<S2SV_blank>value=\\\'stop\\\'><input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'></form></td>"" ) ;StringBuffer_append ( res -> outputbuffer ,  ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\\\'_viewlog\\\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'></form></td>"" ) ;}cwe id:CWE-352context: static void do_runtime ( HttpRequest req , HttpResponse res ) { int pid = exist_daemon ( ) ; char buf [ STRLEN ] ; do_head ( res , ""_runtime"" , ""Runtime"" , 1000 ) ; StringBuffer_append ( res -> outputbuffer , ""<h2>Monit<S2SV_blank>runtime<S2SV_blank>status</h2>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\'status-table\'><tr>"" ""<th<S2SV_blank>width=\'40%%\'>Parameter</th>"" ""<th<S2SV_blank>width=\'60%%\'>Value</th></tr>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Monit<S2SV_blank>ID</td><td>%s</td></tr>"" , Run . id ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Host</td><td>%s</td></tr>"" , Run . system -> name ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Process<S2SV_blank>id</td><td>%d</td></tr>"" , pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Effective<S2SV_blank>user<S2SV_blank>running<S2SV_blank>Monit</td>"" ""<td>%s</td></tr>"" , Run . Env . user ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Controlfile</td><td>%s</td></tr>"" , Run . files . control ) ; if ( Run . files . log ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Logfile</td><td>%s</td></tr>"" , Run . files . log ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Pidfile</td><td>%s</td></tr>"" , Run . files . pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>State<S2SV_blank>file</td><td>%s</td></tr>"" , Run . files . state ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Debug</td><td>%s</td></tr>"" , Run . debug ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Log</td><td>%s</td></tr>"" , ( Run . flags & Run_Log ) ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>syslog</td><td>%s</td></tr>"" , ( Run . flags & Run_UseSyslog ) ? ""True"" : ""False"" ) ; if ( Run . eventlist_dir ) { if ( Run . eventlist_slots < 0 ) snprintf ( buf , STRLEN , ""unlimited"" ) ; else snprintf ( buf , STRLEN , ""%d"" , Run . eventlist_slots ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Event<S2SV_blank>queue</td>"" ""<td>base<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>slots</td></tr>"" , Run . eventlist_dir , Run . eventlist_slots ) ; } # ifdef HAVE_OPENSSL { const char * options = Ssl_printOptions ( & ( Run . ssl ) , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>SSL<S2SV_blank>options</td><td>%s</td></tr>"" , options ) ; } # endif if ( Run . mmonits ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>M/Monit<S2SV_blank>server(s)</td><td>"" ) ; for ( Mmonit_T c = Run . mmonits ; c ; c = c -> next ) { StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>with<S2SV_blank>timeout<S2SV_blank>%s"" , c -> url -> url , Str_milliToTime ( c -> timeout , ( char [ 23 ] ) { } ) ) ; # ifdef HAVE_OPENSSL if ( c -> ssl . flags ) { StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>SSL/TLS"" ) ; const char * options = Ssl_printOptions ( & c -> ssl , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>with<S2SV_blank>options<S2SV_blank>{%s}"" , options ) ; if ( c -> ssl . checksum ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>and<S2SV_blank>certificate<S2SV_blank>checksum<S2SV_blank>%s<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>\'%s\'"" , checksumnames [ c -> ssl . checksumType ] , c -> ssl . checksum ) ; } # endif if ( c -> url -> user ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>credentials"" ) ; if ( c -> next ) StringBuffer_append ( res -> outputbuffer , ""</td></tr><tr><td>&nbsp;</td><td>"" ) ; } StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . mailservers ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Mail<S2SV_blank>server(s)</td><td>"" ) ; for ( MailServer_T mta = Run . mailservers ; mta ; mta = mta -> next ) { StringBuffer_append ( res -> outputbuffer , ""%s:%d"" , mta -> host , mta -> port ) ; # ifdef HAVE_OPENSSL if ( mta -> ssl . flags ) { StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>SSL/TLS"" ) ; const char * options = Ssl_printOptions ( & mta -> ssl , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>with<S2SV_blank>options<S2SV_blank>{%s}"" , options ) ; if ( mta -> ssl . checksum ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>and<S2SV_blank>certificate<S2SV_blank>checksum<S2SV_blank>%s<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>\'%s\'"" , checksumnames [ mta -> ssl . checksumType ] , mta -> ssl . checksum ) ; } # endif if ( mta -> next ) StringBuffer_append ( res -> outputbuffer , ""</td></tr><tr><td>&nbsp;</td><td>"" ) ; } StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . from ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>from</td><td>"" ) ; if ( Run . MailFormat . from -> name ) StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>&lt;%s&gt;"" , Run . MailFormat . from -> name , Run . MailFormat . from -> address ) ; else StringBuffer_append ( res -> outputbuffer , ""%s"" , Run . MailFormat . from -> address ) ; StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . replyto ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>reply<S2SV_blank>to</td><td>"" ) ; if ( Run . MailFormat . replyto -> name ) StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>&lt;%s&gt;"" , Run . MailFormat . replyto -> name , Run . MailFormat . replyto -> address ) ; else StringBuffer_append ( res -> outputbuffer , ""%s"" , Run . MailFormat . replyto -> address ) ; StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . subject ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>subject</td><td>%s</td></tr>"" , Run . MailFormat . subject ) ; if ( Run . MailFormat . message ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>message</td><td>%s</td></tr>"" , Run . MailFormat . message ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>Send/Expect<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . sendExpectBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>file<S2SV_blank>content<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . fileContentBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>HTTP<S2SV_blank>content<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . httpContentBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>program<S2SV_blank>output</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . programOutput , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>network<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . networkTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>check<S2SV_blank>program<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . programTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>stop<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . stopTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>start<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . startTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>restart<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . restartTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>On<S2SV_blank>reboot</td><td>%s</td></tr>"" , onrebootnames [ Run . onreboot ] ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Poll<S2SV_blank>time</td><td>%d<S2SV_blank>seconds<S2SV_blank>with<S2SV_blank>start<S2SV_blank>delay<S2SV_blank>%d<S2SV_blank>seconds</td></tr>"" , Run . polltime , Run . startdelay ) ; if ( Run . httpd . flags & Httpd_Net ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>bind<S2SV_blank>address</td><td>%s</td></tr>"" , Run . httpd . socket . net . address ? Run . httpd . socket . net . address : ""Any/All"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>portnumber</td><td>%d</td></tr>"" , Run . httpd . socket . net . port ) ; } else if ( Run . httpd . flags & Httpd_Unix ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>unix<S2SV_blank>socket</td><td>%s</td></tr>"" , Run . httpd . socket . unix . path ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>signature</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_Signature ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>ssl<S2SV_blank>encryption</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_Ssl ? ""True"" : ""False"" ) ; if ( Run . httpd . flags & Httpd_Ssl ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>PEM<S2SV_blank>key/certificate<S2SV_blank>file</td><td>%s</td></tr>"" , Run . httpd . socket . net . ssl . pem ) ; if ( Run . httpd . socket . net . ssl . clientpem != NULL ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certification"" ""</td><td>%s</td></tr>"" , ""Enabled"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certificate<S2SV_blank>file"" ""</td><td>%s</td></tr>"" , Run . httpd . socket . net . ssl . clientpem ) ; } else { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certification"" ""</td><td>%s</td></tr>"" , ""Disabled"" ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>Allow<S2SV_blank>self<S2SV_blank>certified<S2SV_blank>certificates<S2SV_blank>"" ""</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_AllowSelfSignedCertificates ? ""True"" : ""False"" ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>auth.<S2SV_blank>style</td><td>%s</td></tr>"" , Run . httpd . credentials && Engine_hasAllow ( ) ? ""Basic<S2SV_blank>Authentication<S2SV_blank>and<S2SV_blank>Host/Net<S2SV_blank>allow<S2SV_blank>list"" : Run . httpd . credentials ? ""Basic<S2SV_blank>Authentication"" : Engine_hasAllow ( ) ? ""Host/Net<S2SV_blank>allow<S2SV_blank>list"" : ""No<S2SV_blank>authentication"" ) ; print_alerts ( res , Run . maillist ) ; StringBuffer_append ( res -> outputbuffer , ""</table>"" ) ; if ( ! is_readonly ( req ) ) { StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\'buttons\'><tr>"" ) ; StringBuffer_append ( res -> outputbuffer ,  ""<td<S2SV_blank>style=\'color:red;\'><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>""  ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank><input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; if ( ( Run . flags & Run_Log ) && ! ( Run . flags & Run_UseSyslog ) ) { StringBuffer_append ( res -> outputbuffer ,  ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ;  } StringBuffer_append ( res -> outputbuffer , ""</tr></table>"" ) ; } do_foot ( res ) ; }","StringBuffer_append ( res -> outputbuffer , ""<td<S2SV_blank>style=\\\'color:red;\\\'><form<S2SV_blank>method=POST<S2SV_blank>action=\\\'_runtime\\\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'action\\\'<S2SV_blank>value=\\\'stop\\\'><input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'></form></td>"" ) ;StringBuffer_append ( res -> outputbuffer , ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\\\'_viewlog\\\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'></form></td>"" ) ;}",1465
381,"buggy line: vpx_memcpy ( dest , source , dest_width ) ;}cwe id:CWE-119context: void vp8_vertical_band_2_1_scale_c ( unsigned char * source , unsigned int src_pitch , unsigned char * dest , unsigned int dest_pitch , unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ;  vpx_memcpy ( dest , source , dest_width ) ;  }","memcpy ( dest , source , dest_width ) ;}",1466
382,"buggy line: snprintf ( constr1 , 32 , ""%lld"" , deadline ) ;confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""Deadline<S2SV_blank>%s"" , ctime ( ( const time_t * ) & deadline ) ) ;cwe id:CWE-120context: bool zx_confirmZxLiquidTx ( uint32_t data_total , const EthereumSignTx * msg ) { ( void ) data_total ; const TokenType * token ; char constr1 [ 40 ] , constr2 [ 40 ] , * arStr = """" ; uint8_t * tokenAddress , * deadlineBytes ; bignum256 tokenAmount , tokenMinAmount , ethMinAmount ; uint64_t deadline ; if ( isAddLiquidityEthCall ( msg ) ) { arStr = ""uniswap<S2SV_blank>add<S2SV_blank>liquidity"" ; } else if ( isRemoveLiquidityEthCall ( msg ) ) { arStr = ""uniswap<S2SV_blank>remove<S2SV_blank>liquidity"" ; } else { return false ; } tokenAddress = ( uint8_t * ) ( msg -> data_initial_chunk . bytes + 4 + 32 - 20 ) ; token = tokenByChainAddress ( msg -> chain_id , tokenAddress ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 32 , 32 , & tokenAmount ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 2 * 32 , 32 , & tokenMinAmount ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 3 * 32 , 32 , & ethMinAmount ) ; deadlineBytes = ( uint8_t * ) ( msg -> data_initial_chunk . bytes + 4 + 6 * 32 - 8 ) ; deadline = ( ( uint64_t ) deadlineBytes [ 0 ] << 8 * 7 ) | ( ( uint64_t ) deadlineBytes [ 1 ] << 8 * 6 ) | ( ( uint64_t ) deadlineBytes [ 2 ] << 8 * 5 ) | ( ( uint64_t ) deadlineBytes [ 3 ] << 8 * 4 ) | ( ( uint64_t ) deadlineBytes [ 4 ] << 8 * 3 ) | ( ( uint64_t ) deadlineBytes [ 5 ] << 8 * 2 ) | ( ( uint64_t ) deadlineBytes [ 6 ] << 8 * 1 ) | ( ( uint64_t ) deadlineBytes [ 7 ] ) ; char tokbuf [ 32 ] ; ethereumFormatAmount ( & tokenAmount , token , msg -> chain_id , tokbuf , sizeof ( tokbuf ) ) ; snprintf ( constr1 , 32 , ""%s"" , tokbuf ) ; ethereumFormatAmount ( & tokenMinAmount , token , msg -> chain_id , tokbuf , sizeof ( tokbuf ) ) ; snprintf ( constr2 , 32 , ""%s"" , tokbuf ) ; confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""%s\\nMinimum<S2SV_blank>%s"" , constr1 , constr2 ) ; if ( ! confirmFromAccountMatch ( msg , arStr ) ) { return false ; } ethereumFormatAmount ( & ethMinAmount , NULL , msg -> chain_id , tokbuf , sizeof ( tokbuf ) ) ; snprintf ( constr1 , 32 , ""%s"" , tokbuf ) ; confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""Minimum<S2SV_blank>%s"" , constr1 ) ;  snprintf ( constr1 , 32 , ""%lld"" , deadline ) ;  confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""Deadline<S2SV_blank>%s"" , ctime ( ( const time_t * ) & deadline ) ) ; return true ; }","confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""Deadline<S2SV_blank>%s"" , ctime ( ( const time_t * ) & deadline ) ) ;",1467
383,"buggy line: assert ( n >= 0 && n < 32 ) ;v = 0 ;cwe id:CWE-000context: long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ;  assert ( n >= 0 && n < 32 ) ;  v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }",if ( n < 0 || n >= 32 ) {return - 1 ;}v = 0 ;,1468
384,"buggy line: if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs ,  & len , & iovec , compat ) ;else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs ,  len , iovec ) ;if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ;cwe id:CWE-000context: static ssize_t aio_run_iocb ( struct kiocb * req , unsigned opcode , char __user * buf , size_t len , bool compat ) { struct file * file = req -> ki_filp ; ssize_t ret ; unsigned long nr_segs ; int rw ; fmode_t mode ; aio_rw_op * rw_op ; rw_iter_op * iter_op ; struct iovec inline_vecs [ UIO_FASTIOV ] , * iovec = inline_vecs ; struct iov_iter iter ; switch ( opcode ) { case IOCB_CMD_PREAD : case IOCB_CMD_PREADV : mode = FMODE_READ ; rw = READ ; rw_op = file -> f_op -> aio_read ; iter_op = file -> f_op -> read_iter ; goto rw_common ; case IOCB_CMD_PWRITE : case IOCB_CMD_PWRITEV : mode = FMODE_WRITE ; rw = WRITE ; rw_op = file -> f_op -> aio_write ; iter_op = file -> f_op -> write_iter ; goto rw_common ; rw_common : if ( unlikely ( ! ( file -> f_mode & mode ) ) ) return - EBADF ; if ( ! rw_op && ! iter_op ) return - EINVAL ; if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs ,  & len , & iovec , compat ) ;  else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs ,  len , iovec ) ;  if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ; if ( ret < 0 ) { if ( iovec != inline_vecs ) kfree ( iovec ) ; return ret ; } len = ret ; if ( req -> ki_pos < 0 ) { ret = - EINVAL ; break ; } if ( rw == WRITE ) file_start_write ( file ) ; if ( iter_op ) {  iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ;  ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iovec , nr_segs , req -> ki_pos ) ; } if ( rw == WRITE ) file_end_write ( file ) ; break ; case IOCB_CMD_FDSYNC : if ( ! file -> f_op -> aio_fsync ) return - EINVAL ; ret = file -> f_op -> aio_fsync ( req , 1 ) ; break ; case IOCB_CMD_FSYNC : if ( ! file -> f_op -> aio_fsync ) return - EINVAL ; ret = file -> f_op -> aio_fsync ( req , 0 ) ; break ; default : pr_debug ( ""EINVAL:<S2SV_blank>no<S2SV_blank>operation<S2SV_blank>provided\\n"" ) ; return - EINVAL ; } if ( iovec != inline_vecs ) kfree ( iovec ) ; if ( ret != - EIOCBQUEUED ) { if ( unlikely ( ret == - ERESTARTSYS || ret == - ERESTARTNOINTR || ret == - ERESTARTNOHAND || ret == - ERESTART_RESTARTBLOCK ) ) ret = - EINTR ; aio_complete ( req , ret , 0 ) ; } return 0 ; }","if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs , & len , & iovec , compat , & iter ) ;else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs , len , iovec , & iter ) ;if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ;",1469
385,"buggy line: iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ;ret = iter_op ( req , & iter ) ;ret = rw_op ( req , iovec , nr_segs , req -> ki_pos ) ;cwe id:CWE-000context: static ssize_t aio_run_iocb ( struct kiocb * req , unsigned opcode , char __user * buf , size_t len , bool compat ) { struct file * file = req -> ki_filp ; ssize_t ret ; unsigned long nr_segs ; int rw ; fmode_t mode ; aio_rw_op * rw_op ; rw_iter_op * iter_op ; struct iovec inline_vecs [ UIO_FASTIOV ] , * iovec = inline_vecs ; struct iov_iter iter ; switch ( opcode ) { case IOCB_CMD_PREAD : case IOCB_CMD_PREADV : mode = FMODE_READ ; rw = READ ; rw_op = file -> f_op -> aio_read ; iter_op = file -> f_op -> read_iter ; goto rw_common ; case IOCB_CMD_PWRITE : case IOCB_CMD_PWRITEV : mode = FMODE_WRITE ; rw = WRITE ; rw_op = file -> f_op -> aio_write ; iter_op = file -> f_op -> write_iter ; goto rw_common ; rw_common : if ( unlikely ( ! ( file -> f_mode & mode ) ) ) return - EBADF ; if ( ! rw_op && ! iter_op ) return - EINVAL ; if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs ,  & len , & iovec , compat ) ;  else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs ,  len , iovec ) ;  if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ; if ( ret < 0 ) { if ( iovec != inline_vecs ) kfree ( iovec ) ; return ret ; } len = ret ; if ( req -> ki_pos < 0 ) { ret = - EINVAL ; break ; } if ( rw == WRITE ) file_start_write ( file ) ; if ( iter_op ) {  iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ;  ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iovec , nr_segs , req -> ki_pos ) ; } if ( rw == WRITE ) file_end_write ( file ) ; break ; case IOCB_CMD_FDSYNC : if ( ! file -> f_op -> aio_fsync ) return - EINVAL ; ret = file -> f_op -> aio_fsync ( req , 1 ) ; break ; case IOCB_CMD_FSYNC : if ( ! file -> f_op -> aio_fsync ) return - EINVAL ; ret = file -> f_op -> aio_fsync ( req , 0 ) ; break ; default : pr_debug ( ""EINVAL:<S2SV_blank>no<S2SV_blank>operation<S2SV_blank>provided\\n"" ) ; return - EINVAL ; } if ( iovec != inline_vecs ) kfree ( iovec ) ; if ( ret != - EIOCBQUEUED ) { if ( unlikely ( ret == - ERESTARTSYS || ret == - ERESTARTNOINTR || ret == - ERESTARTNOHAND || ret == - ERESTART_RESTARTBLOCK ) ) ret = - EINTR ; aio_complete ( req , ret , 0 ) ; } return 0 ; }","ret = iter_op ( req , & iter ) ;ret = rw_op ( req , iter . iov , iter . nr_segs , req -> ki_pos ) ;",1469
386,"buggy line: if ( ! el )  return 0 ;cwe id:CWE-20context: static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d:<S2SV_blank>Client<S2SV_blank>using<S2SV_blank>the<S2SV_blank>%s<S2SV_blank>protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d:<S2SV_blank>Realign<S2SV_blank>input<S2SV_blank>buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d<S2SV_blank>Read<S2SV_blank>binary<S2SV_blank>protocol<S2SV_blank>data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d<S2SV_blank><S2SV_blank><S2SV_blank>"" , c -> sfd ) ; } fprintf ( stderr , ""<S2SV_blank>0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid<S2SV_blank>magic:<S2SV_blank><S2SV_blank>%x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ;  if ( ! el )  return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }","if ( ! el ) {if ( c -> rbytes > 1024 ) {char * ptr = c -> rcurr ;while ( * ptr == \'<S2SV_blank>\' ) {++ ptr ;}if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) {conn_set_state ( c , conn_closing ) ;return 1 ;}}return 0 ;}",1470
387,"buggy line: err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) ,  USB_DT_OTG , ( void * * ) & desc ) ;if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ;cwe id:CWE-400context: static int usb_enumerate_device_otg ( struct usb_device * udev ) { int err = 0 ; # ifdef CONFIG_USB_OTG if ( ! udev -> bus -> is_b_host && udev -> config && udev -> parent == udev -> bus -> root_hub ) { struct usb_otg_descriptor * desc = NULL ; struct usb_bus * bus = udev -> bus ; unsigned port1 = udev -> portnum ; err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) ,  USB_DT_OTG , ( void * * ) & desc ) ;  if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ; dev_info ( & udev -> dev , ""Dual-Role<S2SV_blank>OTG<S2SV_blank>device<S2SV_blank>on<S2SV_blank>%sHNP<S2SV_blank>port\\n"" , ( port1 == bus -> otg_port ) ? """" : ""non-"" ) ; if ( port1 == bus -> otg_port ) { bus -> b_hnp_enable = 1 ; err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_B_HNP_ENABLE , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) { dev_err ( & udev -> dev , ""can\'t<S2SV_blank>set<S2SV_blank>HNP<S2SV_blank>mode:<S2SV_blank>%d\\n"" , err ) ; bus -> b_hnp_enable = 0 ; } } else if ( desc -> bLength == sizeof ( struct usb_otg_descriptor ) ) { err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_A_ALT_HNP_SUPPORT , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) dev_err ( & udev -> dev , ""set<S2SV_blank>a_alt_hnp_support<S2SV_blank>failed:<S2SV_blank>%d\\n"" , err ) ; } } # endif return err ; }","err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , USB_DT_OTG , ( void * * ) & desc , sizeof ( * desc ) ) ;if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ;",1471
388,"buggy line: if ( iad_num == USB_MAXIADS ) {dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\\config -> intf_assoc [ iad_num ] =  ( struct usb_interface_assoc_descriptor  * ) header ;cwe id:CWE-119context: static int usb_parse_configuration ( struct usb_device * dev , int cfgidx , struct usb_host_config * config , unsigned char * buffer , int size ) { struct device * ddev = & dev -> dev ; unsigned char * buffer0 = buffer ; int cfgno ; int nintf , nintf_orig ; int i , j , n ; struct usb_interface_cache * intfc ; unsigned char * buffer2 ; int size2 ; struct usb_descriptor_header * header ; int len , retval ; u8 inums [ USB_MAXINTERFACES ] , nalts [ USB_MAXINTERFACES ] ; unsigned iad_num = 0 ; memcpy ( & config -> desc , buffer , USB_DT_CONFIG_SIZE ) ; if ( config -> desc . bDescriptorType != USB_DT_CONFIG || config -> desc . bLength < USB_DT_CONFIG_SIZE || config -> desc . bLength > size ) { dev_err ( ddev , ""invalid<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>config<S2SV_blank>index<S2SV_blank>%d:<S2SV_blank>"" ""type<S2SV_blank>=<S2SV_blank>0x%X,<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%d\\n"" , cfgidx , config -> desc . bDescriptorType , config -> desc . bLength ) ; return - EINVAL ; } cfgno = config -> desc . bConfigurationValue ; buffer += config -> desc . bLength ; size -= config -> desc . bLength ; nintf = nintf_orig = config -> desc . bNumInterfaces ; if ( nintf > USB_MAXINTERFACES ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>interfaces:<S2SV_blank>%d,<S2SV_blank>"" ""using<S2SV_blank>maximum<S2SV_blank>allowed:<S2SV_blank>%d\\n"" , cfgno , nintf , USB_MAXINTERFACES ) ; nintf = USB_MAXINTERFACES ; } n = 0 ; for ( ( buffer2 = buffer , size2 = size ) ; size2 > 0 ; ( buffer2 += header -> bLength , size2 -= header -> bLength ) ) { if ( size2 < sizeof ( struct usb_descriptor_header ) ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>descriptor<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>excess<S2SV_blank>"" ""byte%s,<S2SV_blank>ignoring\\n"" , cfgno , size2 , plural ( size2 ) ) ; break ; } header = ( struct usb_descriptor_header * ) buffer2 ; if ( ( header -> bLength > size2 ) || ( header -> bLength < 2 ) ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>descriptor<S2SV_blank>"" ""of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping<S2SV_blank>remainder<S2SV_blank>of<S2SV_blank>the<S2SV_blank>config\\n"" , cfgno , header -> bLength ) ; break ; } if ( header -> bDescriptorType == USB_DT_INTERFACE ) { struct usb_interface_descriptor * d ; int inum ; d = ( struct usb_interface_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_SIZE ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>"" ""interface<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>"" ""skipping\\n"" , cfgno , d -> bLength ) ; continue ; } inum = d -> bInterfaceNumber ; if ( ( dev -> quirks & USB_QUIRK_HONOR_BNUMINTERFACES ) && n >= nintf_orig ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>more<S2SV_blank>interface<S2SV_blank>"" ""descriptors,<S2SV_blank>than<S2SV_blank>it<S2SV_blank>declares<S2SV_blank>in<S2SV_blank>"" ""bNumInterfaces,<S2SV_blank>ignoring<S2SV_blank>interface<S2SV_blank>"" ""number:<S2SV_blank>%d\\n"" , cfgno , inum ) ; continue ; } if ( inum >= nintf_orig ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>"" ""interface<S2SV_blank>number:<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n"" , cfgno , inum , nintf_orig - 1 ) ; for ( i = 0 ; i < n ; ++ i ) { if ( inums [ i ] == inum ) break ; } if ( i < n ) { if ( nalts [ i ] < 255 ) ++ nalts [ i ] ; } else if ( n < USB_MAXINTERFACES ) { inums [ n ] = inum ; nalts [ n ] = 1 ; ++ n ; } } else if ( header -> bDescriptorType == USB_DT_INTERFACE_ASSOCIATION ) {  if ( iad_num == USB_MAXIADS ) {  dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\n"" , cfgno ) ; } else { config -> intf_assoc [ iad_num ] =  ( struct usb_interface_assoc_descriptor  * ) header ; iad_num ++ ; } } else if ( header -> bDescriptorType == USB_DT_DEVICE || header -> bDescriptorType == USB_DT_CONFIG ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>contains<S2SV_blank>an<S2SV_blank>unexpected<S2SV_blank>"" ""descriptor<S2SV_blank>of<S2SV_blank>type<S2SV_blank>0x%X,<S2SV_blank>skipping\\n"" , cfgno , header -> bDescriptorType ) ; } size = buffer2 - buffer ; config -> desc . wTotalLength = cpu_to_le16 ( buffer2 - buffer0 ) ; if ( n != nintf ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>interface%s,<S2SV_blank>different<S2SV_blank>from<S2SV_blank>"" ""the<S2SV_blank>descriptor\'s<S2SV_blank>value:<S2SV_blank>%d\\n"" , cfgno , n , plural ( n ) , nintf_orig ) ; else if ( n == 0 ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>interfaces?\\n"" , cfgno ) ; config -> desc . bNumInterfaces = nintf = n ; for ( i = 0 ; i < nintf ; ++ i ) { for ( j = 0 ; j < nintf ; ++ j ) { if ( inums [ j ] == i ) break ; } if ( j >= nintf ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>interface<S2SV_blank>number<S2SV_blank>"" ""%d\\n"" , cfgno , i ) ; } for ( i = 0 ; i < nintf ; ++ i ) { j = nalts [ i ] ; if ( j > USB_MAXALTSETTING ) { dev_warn ( ddev , ""too<S2SV_blank>many<S2SV_blank>alternate<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>"" ""config<S2SV_blank>%d<S2SV_blank>interface<S2SV_blank>%d:<S2SV_blank>%d,<S2SV_blank>"" ""using<S2SV_blank>maximum<S2SV_blank>allowed:<S2SV_blank>%d\\n"" , cfgno , inums [ i ] , j , USB_MAXALTSETTING ) ; nalts [ i ] = j = USB_MAXALTSETTING ; } len = sizeof ( * intfc ) + sizeof ( struct usb_host_interface ) * j ; config -> intf_cache [ i ] = intfc = kzalloc ( len , GFP_KERNEL ) ; if ( ! intfc ) return - ENOMEM ; kref_init ( & intfc -> ref ) ; } config -> extra = buffer ; i = find_next_descriptor ( buffer , size , USB_DT_INTERFACE , USB_DT_INTERFACE , & n ) ; config -> extralen = i ; if ( n > 0 ) dev_dbg ( ddev , ""skipped<S2SV_blank>%d<S2SV_blank>descriptor%s<S2SV_blank>after<S2SV_blank>%s\\n"" , n , plural ( n ) , ""configuration"" ) ; buffer += i ; size -= i ; while ( size > 0 ) { retval = usb_parse_interface ( ddev , cfgno , config , buffer , size , inums , nalts ) ; if ( retval < 0 ) return retval ; buffer += retval ; size -= retval ; } for ( i = 0 ; i < nintf ; ++ i ) { intfc = config -> intf_cache [ i ] ; for ( j = 0 ; j < intfc -> num_altsetting ; ++ j ) { for ( n = 0 ; n < intfc -> num_altsetting ; ++ n ) { if ( intfc -> altsetting [ n ] . desc . bAlternateSetting == j ) break ; } if ( n >= intfc -> num_altsetting ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>interface<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>"" ""altsetting<S2SV_blank>%d\\n"" , cfgno , inums [ i ] , j ) ; } } return 0 ; }","struct usb_interface_assoc_descriptor * d ;d = ( struct usb_interface_assoc_descriptor * ) header ;if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) {dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\\continue ;}if ( iad_num == USB_MAXIADS ) {dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\\config -> intf_assoc [ iad_num ] = d ;",1472
389,"buggy line: if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )   return - ENOMEM ;if ( info -> count < 1 ) return - EINVAL ;down_write ( & card -> controls_rwsem ) ;_kctl = snd_ctl_find_id ( card , & info -> id ) ;err = 0 ;if ( _kctl ) {if ( replace ) err = snd_ctl_remove ( card , _kctl ) ;else err = - EBUSY ;}else {if ( replace ) err = - ENOENT ;up_write ( & card -> controls_rwsem ) ;if ( err < 0 ) return err ;cwe id:CWE-190context: static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ;  if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )   return - ENOMEM ;  if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ; ue -> card = card ; ue -> info = * info ; ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }","if ( info -> count < 1 ) return - EINVAL ;if ( replace ) {err = snd_ctl_remove_user_ctl ( file , & info -> id ) ;if ( err ) return err ;if ( card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ;",1473
390,"buggy line: exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ;return 0 ;cwe id:CWE-285context: static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) { struct Client * agent_p = NULL ; struct Client * saslserv_p = NULL ; if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ; if ( strlen ( client_p -> id ) == 3 ) {  exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ;  return 0 ; } saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ; if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) { sendto_one ( source_p , form_str ( ERR_SASLABORTED ) , me . name , EmptyString ( source_p -> name ) ? ""*"" : source_p -> name ) ; return 0 ; } if ( source_p -> localClient -> sasl_complete ) { * source_p -> localClient -> sasl_agent = '\\0' ; source_p -> localClient -> sasl_complete = 0 ; } if ( strlen ( parv [ 1 ] ) > 400 ) { sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? ""*"" : source_p -> name ) ; return 0 ; } if ( ! * source_p -> id ) { strcpy ( source_p -> id , generate_uid ( ) ) ; add_to_id_hash ( source_p -> id , source_p ) ; } if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ; if ( agent_p == NULL ) { sendto_one ( saslserv_p , "":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>H<S2SV_blank>%s<S2SV_blank>%s"" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , source_p -> host , source_p -> sockhost ) ; if ( ! strcmp ( parv [ 1 ] , ""EXTERNAL"" ) && source_p -> certfp != NULL ) sendto_one ( saslserv_p , "":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>%s"" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] , source_p -> certfp ) ; else sendto_one ( saslserv_p , "":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>S<S2SV_blank>%s"" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] ) ; rb_strlcpy ( source_p -> localClient -> sasl_agent , saslserv_p -> id , IDLEN ) ; } else sendto_one ( agent_p , "":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>C<S2SV_blank>%s"" , me . id , agent_p -> servptr -> name , source_p -> id , agent_p -> id , parv [ 1 ] ) ; source_p -> localClient -> sasl_out ++ ; return 0 ; }","exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ;return 0 ;}if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) {exit_client ( client_p , client_p , client_p , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;return 0 ;",1474
391,"buggy line: if ( ctxt -> rip_relative )  ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ;cwe id:CWE-284context: int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes ^ 12 ; else ctxt -> ad_bytes = def_ad_bytes ^ 6 ; break ; case 0x26 : case 0x2e : case 0x36 : case 0x3e : has_seg_override = true ; ctxt -> seg_override = ( ctxt -> b >> 3 ) & 3 ; break ; case 0x64 : case 0x65 : has_seg_override = true ; ctxt -> seg_override = ctxt -> b & 7 ; break ; case 0x40 ... 0x4f : if ( mode != X86EMUL_MODE_PROT64 ) goto done_prefixes ; ctxt -> rex_prefix = ctxt -> b ; continue ; case 0xf0 : ctxt -> lock_prefix = 1 ; break ; case 0xf2 : case 0xf3 : ctxt -> rep_prefix = ctxt -> b ; break ; default : goto done_prefixes ; } ctxt -> rex_prefix = 0 ; } done_prefixes : if ( ctxt -> rex_prefix & 8 ) ctxt -> op_bytes = 8 ; opcode = opcode_table [ ctxt -> b ] ; if ( ctxt -> b == 0x0f ) { ctxt -> opcode_len = 2 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = twobyte_table [ ctxt -> b ] ; if ( ctxt -> b == 0x38 ) { ctxt -> opcode_len = 3 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = opcode_map_0f_38 [ ctxt -> b ] ; } } ctxt -> d = opcode . flags ; if ( ctxt -> d & ModRM ) ctxt -> modrm = insn_fetch ( u8 , ctxt ) ; if ( ctxt -> opcode_len == 1 && ( ctxt -> b == 0xc5 || ctxt -> b == 0xc4 ) && ( mode == X86EMUL_MODE_PROT64 || ( ctxt -> modrm & 0xc0 ) == 0xc0 ) ) { ctxt -> d = NotImpl ; } while ( ctxt -> d & GroupMask ) { switch ( ctxt -> d & GroupMask ) { case Group : goffset = ( ctxt -> modrm >> 3 ) & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case GroupDual : goffset = ( ctxt -> modrm >> 3 ) & 7 ; if ( ( ctxt -> modrm >> 6 ) == 3 ) opcode = opcode . u . gdual -> mod3 [ goffset ] ; else opcode = opcode . u . gdual -> mod012 [ goffset ] ; break ; case RMExt : goffset = ctxt -> modrm & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case Prefix : if ( ctxt -> rep_prefix && op_prefix ) return EMULATION_FAILED ; simd_prefix = op_prefix ? 0x66 : ctxt -> rep_prefix ; switch ( simd_prefix ) { case 0x00 : opcode = opcode . u . gprefix -> pfx_no ; break ; case 0x66 : opcode = opcode . u . gprefix -> pfx_66 ; break ; case 0xf2 : opcode = opcode . u . gprefix -> pfx_f2 ; break ; case 0xf3 : opcode = opcode . u . gprefix -> pfx_f3 ; break ; } break ; case Escape : if ( ctxt -> modrm > 0xbf ) opcode = opcode . u . esc -> high [ ctxt -> modrm - 0xc0 ] ; else opcode = opcode . u . esc -> op [ ( ctxt -> modrm >> 3 ) & 7 ] ; break ; case InstrDual : if ( ( ctxt -> modrm >> 6 ) == 3 ) opcode = opcode . u . idual -> mod3 ; else opcode = opcode . u . idual -> mod012 ; break ; case ModeDual : if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) opcode = opcode . u . mdual -> mode64 ; else opcode = opcode . u . mdual -> mode32 ; break ; default : return EMULATION_FAILED ; } ctxt -> d &= ~ ( u64 ) GroupMask ; ctxt -> d |= opcode . flags ; } if ( ctxt -> d == 0 ) return EMULATION_FAILED ; ctxt -> execute = opcode . u . execute ; if ( unlikely ( ctxt -> ud ) && likely ( ! ( ctxt -> d & EmulateOnUD ) ) ) return EMULATION_FAILED ; if ( unlikely ( ctxt -> d & ( NotImpl | Stack | Op3264 | Sse | Mmx | Intercept | CheckPerm | NearBranch | No16 ) ) ) { ctxt -> check_perm = opcode . check_perm ; ctxt -> intercept = opcode . intercept ; if ( ctxt -> d & NotImpl ) return EMULATION_FAILED ; if ( mode == X86EMUL_MODE_PROT64 ) { if ( ctxt -> op_bytes == 4 && ( ctxt -> d & Stack ) ) ctxt -> op_bytes = 8 ; else if ( ctxt -> d & NearBranch ) ctxt -> op_bytes = 8 ; } if ( ctxt -> d & Op3264 ) { if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> op_bytes = 8 ; else ctxt -> op_bytes = 4 ; } if ( ( ctxt -> d & No16 ) && ctxt -> op_bytes == 2 ) ctxt -> op_bytes = 4 ; if ( ctxt -> d & Sse ) ctxt -> op_bytes = 16 ; else if ( ctxt -> d & Mmx ) ctxt -> op_bytes = 8 ; } if ( ctxt -> d & ModRM ) { rc = decode_modrm ( ctxt , & ctxt -> memop ) ; if ( ! has_seg_override ) { has_seg_override = true ; ctxt -> seg_override = ctxt -> modrm_seg ; } } else if ( ctxt -> d & MemAbs ) rc = decode_abs ( ctxt , & ctxt -> memop ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; if ( ! has_seg_override ) ctxt -> seg_override = VCPU_SREG_DS ; ctxt -> memop . addr . mem . seg = ctxt -> seg_override ; rc = decode_operand ( ctxt , & ctxt -> src , ( ctxt -> d >> SrcShift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ;  if ( ctxt -> rip_relative )  ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ; done : return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ; }","if ( ctxt -> rip_relative && likely ( ctxt -> memopp ) ) ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ;",1475
392,"buggy line: int size = mmap_event -> event_id . header . size ;int ret ;perf_event_header__init_id ( & mmap_event -> event_id . header , & sample , event ) ;ret = perf_output_begin ( & handle , event ,  mmap_event -> event_id . header . size , 0 , 0 ) ;if ( ret ) goto out ;cwe id:CWE-400context: static void perf_event_mmap_output ( struct perf_event * event , struct perf_mmap_event * mmap_event ) { struct perf_output_handle handle ; struct perf_sample_data sample ; int size = mmap_event -> event_id . header . size ; int ret ; perf_event_header__init_id ( & mmap_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event ,  mmap_event -> event_id . header . size , 0 , 0 ) ;  if ( ret ) goto out ; mmap_event -> event_id . pid = perf_event_pid ( event , current ) ; mmap_event -> event_id . tid = perf_event_tid ( event , current ) ; perf_output_put ( & handle , mmap_event -> event_id ) ; __output_copy ( & handle , mmap_event -> file_name , mmap_event -> file_size ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; out : mmap_event -> event_id . header . size = size ; }","int size = mmap_event -> event_id . header . size , 0 ) ;if ( ret ) goto out ;",1476
393,buggy line: dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;random_ether_addr ( dev -> dev_addr ) ;cwe id:CWE-264context: static void ifb_setup ( struct net_device * dev ) { dev -> destructor = free_netdev ; dev -> netdev_ops = & ifb_netdev_ops ; ether_setup ( dev ) ; dev -> tx_queue_len = TX_Q_LIMIT ; dev -> features |= IFB_FEATURES ; dev -> vlan_features |= IFB_FEATURES ; dev -> flags |= IFF_NOARP ; dev -> flags &= ~ IFF_MULTICAST ;  dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;  random_ether_addr ( dev -> dev_addr ) ; },dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;random_ether_addr ( dev -> dev_addr ) ;,1477
394,"buggy line: distortion = vp8_variance16x16  ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ;cwe id:CWE-119context: void vp8_pick_intra_mode ( MACROBLOCK * x , int * rate_ ) { int error4x4 , error16x16 = INT_MAX ; int rate , best_rate = 0 , distortion , best_sse ; MB_PREDICTION_MODE mode , best_mode = DC_PRED ; int this_rd ; unsigned int sse ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; xd -> mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; pick_intra_mbuv_mode ( x ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { xd -> mode_info_context -> mbmi . mode = mode ; vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ;  distortion = vp8_variance16x16  ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ; rate = x -> mbmode_cost [ xd -> frame_type ] [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( error16x16 > this_rd ) { error16x16 = this_rd ; best_mode = mode ; best_sse = sse ; best_rate = rate ; } } xd -> mode_info_context -> mbmi . mode = best_mode ; error4x4 = pick_intra4x4mby_modes ( x , & rate , & best_sse ) ; if ( error4x4 < error16x16 ) { xd -> mode_info_context -> mbmi . mode = B_PRED ; best_rate = rate ; } * rate_ = best_rate ; }","distortion = vpx_variance16x16 ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ;",1478
395,"buggy line: enc624j600WriteReg ( interface , ENC624J600_REG_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ;if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) {temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR1 ) ;interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ;temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR2 ) ;interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ;temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR3 ) ;interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MAADR1 , temp ) ;temp = htole16 ( interface -> macAddr . w [ 1 ] ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MAADR2 , temp ) ;temp = htole16 ( interface -> macAddr . w [ 2 ] ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MAADR3 , temp ) ;}enc624j600WriteReg ( interface , ENC624J600_REG_ERXST , ENC624J600_RX_BUFFER_START ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ERXFCON , ERXFCON_HTEN |  ERXFCON_CRCEN | ERXFCON_RUNTEN | ERXFCON_UCEN | ERXFCON_BCEN ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 ,  MACON2_DEFER | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MAMXFL , ETH_MAX_FRAME_SIZE ) ;enc624j600WritePhyReg ( interface , ENC624J600_PHY_REG_PHANA , PHANA_ADPAUS0 |  PHANA_AD100FD | PHANA_AD100 | PHANA_AD10FD | PHANA_AD10 | PHANA_ADIEEE0 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EIR , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EIE , EIE_INTIE |  EIE_LINKIE | EIE_PKTIE | EIE_TXIE | EIE_TXABTIE ) ;enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_RXEN ) ;enc624j600DumpReg ( interface ) ;cwe id:CWE-20context: error_t enc624j600Init ( NetInterface * interface ) { uint16_t temp ; Enc624j600Context * context ; TRACE_INFO ( ""Initializing<S2SV_blank>ENC624J600<S2SV_blank>Ethernet<S2SV_blank>controller...\\r\\n"" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; context = ( Enc624j600Context * ) interface -> nicContext ; context -> nextPacket = ENC624J600_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; } enc624j600SoftReset ( interface ) ;  enc624j600WriteReg ( interface , ENC624J600_REG_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ;  if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) {  temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR1 ) ;  interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ;  temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR2 ) ;  interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ;  temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR3 ) ;  interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ; macAddrToEui64 ( & interface -> macAddr , & interface -> eui64 ) ; } else { temp = htole16 ( interface -> macAddr . w [ 0 ] ) ;  enc624j600WriteReg ( interface , ENC624J600_REG_MAADR1 , temp ) ;  temp = htole16 ( interface -> macAddr . w [ 1 ] ) ;  enc624j600WriteReg ( interface , ENC624J600_REG_MAADR2 , temp ) ;  temp = htole16 ( interface -> macAddr . w [ 2 ] ) ;  enc624j600WriteReg ( interface , ENC624J600_REG_MAADR3 , temp ) ;  }  enc624j600WriteReg ( interface , ENC624J600_REG_ERXST , ENC624J600_RX_BUFFER_START ) ;   enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ;   enc624j600WriteReg ( interface , ENC624J600_REG_ERXFCON , ERXFCON_HTEN |  ERXFCON_CRCEN | ERXFCON_RUNTEN | ERXFCON_UCEN | ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , 0x0000 ) ;  enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , 0x0000 ) ;   enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , 0x0000 ) ;   enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , 0x0000 ) ;   enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 ,  MACON2_DEFER | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ; enc624j600WriteReg ( interface , ENC624J600_REG_MAMXFL , ETH_MAX_FRAME_SIZE ) ;  enc624j600WritePhyReg ( interface , ENC624J600_PHY_REG_PHANA , PHANA_ADPAUS0 |  PHANA_AD100FD | PHANA_AD100 | PHANA_AD10FD | PHANA_AD10 | PHANA_ADIEEE0 ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EIR , 0x0000 ) ;  enc624j600WriteReg ( interface , ENC624J600_REG_EIE , EIE_INTIE |  EIE_LINKIE | EIE_PKTIE | EIE_TXIE | EIE_TXABTIE ) ;  enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_RXEN ) ;  enc624j600DumpReg ( interface ) ; enc624j600DumpPhyReg ( interface ) ; osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }","enc624j600WriteReg ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH ) ;if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) {temp = enc624j600ReadReg ( interface , ENC624J600_MAADR1 ) ;interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ;temp = enc624j600ReadReg ( interface , ENC624J600_MAADR2 ) ;interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ;temp = enc624j600ReadReg ( interface , ENC624J600_MAADR3 ) ;interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ;enc624j600WriteReg ( interface , ENC624J600_MAADR1 , temp ) ;temp = htole16 ( interface -> macAddr . w [ 1 ] ) ;enc624j600WriteReg ( interface , ENC624J600_MAADR2 , temp ) ;temp = htole16 ( interface -> macAddr . w [ 2 ] ) ;enc624j600WriteReg ( interface , ENC624J600_MAADR3 , temp ) ;}enc624j600WriteReg ( interface , ENC624J600_ERXST , ENC624J600_RX_BUFFER_START ) ;enc624j600WriteReg ( interface , ENC624J600_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ;enc624j600WriteReg ( interface , ENC624J600_ERXFCON , ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ERXFCON_RUNTEN | ENC624J600_ERXFCON_UCEN | ENC624J600_ERXFCON_BCEN ) ;enc624j600WriteReg ( interface , ENC624J600_EHT1 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_EHT2 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_EHT3 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_EHT4 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT ) ;enc624j600WriteReg ( interface , ENC624J600_MAMXFL , ETH_MAX_FRAME_SIZE ) ;enc624j600WritePhyReg ( interface , ENC624J600_PHANA , ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD100 | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10 | ENC624J600_PHANA_ADIEEE_DEFAULT ) ;enc624j600WriteReg ( interface , ENC624J600_EIR , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE | ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE | ENC624J600_EIE_TXIE | ENC624J600_EIE_TXABTIE ) ;enc624j600SetBit ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_RXEN ) ;enc624j600DumpReg ( interface ) ;",1479
396,"buggy line: maxlen = strlen ( ( char * ) psf -> header ) ;start = ( ( char * ) psf -> header ) + maxlen ;maxlen = sizeof ( psf -> header ) - maxlen ;va_start ( argptr , format ) ;psf -> headindex = strlen ( ( char * ) psf -> header ) ;return ;cwe id:CWE-119context: void psf_asciiheader_printf ( SF_PRIVATE * psf , const char * format , ... ) { va_list argptr ; int maxlen ; char * start ;  maxlen = strlen ( ( char * ) psf -> header ) ;   start = ( ( char * ) psf -> header ) + maxlen ;   maxlen = sizeof ( psf -> header ) - maxlen ;  va_start ( argptr , format ) ; vsnprintf ( start , maxlen , format , argptr ) ; va_end ( argptr ) ; start [ maxlen - 1 ] = 0 ;  psf -> headindex = strlen ( ( char * ) psf -> header ) ;  return ; }","maxlen = psf -> header . ptr ) ;start = ( ( char * ) psf -> header . len - maxlen ;va_start ( argptr , format ) ;psf -> header . indx = strlen ( ( char * ) psf -> header . ptr ) ;return ;",1480
397,"buggy line: if ( ( e -> target_offset == sizeof ( struct arpt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> arp ) ) ||  visited ) {cwe id:CWE-119context: static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_ARP_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) ) { pr_notice ( ""arptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ) ;  if ( ( e -> target_offset == sizeof ( struct arpt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> arp ) ) ||  visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_ARP_NUMHOOKS ) ; oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct arpt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct arpt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct arpt_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct arpt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",1481
398,"buggy line: if ( ! arr || ! json_is_array ( arr ) ) goto out ;merkles = json_array_size ( arr ) ;job_id = json_array_string ( val , 0 ) ;prev_hash = __json_array_string ( val , 1 ) ;coinbase1 = json_array_string ( val , 2 ) ;coinbase2 = json_array_string ( val , 3 ) ;bbversion = __json_array_string ( val , 5 ) ;nbit = __json_array_string ( val , 6 ) ;ntime = __json_array_string ( val , 7 ) ;clean = json_is_true ( json_array_get ( val , 8 ) ) ;if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) {if ( job_id )  free ( job_id ) ;cwe id:CWE-119context: static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , header [ 228 ] ; unsigned char * cb1 = NULL , * cb2 = NULL ; size_t cb1_len , cb2_len , alloc_len ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = __json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = __json_array_string ( val , 5 ) ; nbit = __json_array_string ( val , 6 ) ; ntime = __json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ;  if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) {   if ( job_id )  free ( job_id ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; free ( pool -> swork . job_id ) ; pool -> swork . job_id = job_id ; snprintf ( pool -> prev_hash , 65 , ""%s"" , prev_hash ) ; cb1_len = strlen ( coinbase1 ) / 2 ; cb2_len = strlen ( coinbase2 ) / 2 ; snprintf ( pool -> bbversion , 9 , ""%s"" , bbversion ) ; snprintf ( pool -> nbit , 9 , ""%s"" , nbit ) ; snprintf ( pool -> ntime , 9 , ""%s"" , ntime ) ; pool -> swork . clean = clean ; alloc_len = pool -> coinbase_len = cb1_len + pool -> n1_len + pool -> n2size + cb2_len ; pool -> nonce2_offset = cb1_len + pool -> n1_len ; for ( i = 0 ; i < pool -> merkles ; i ++ ) free ( pool -> swork . merkle_bin [ i ] ) ; if ( merkles ) { pool -> swork . merkle_bin = realloc ( pool -> swork . merkle_bin , sizeof ( char * ) * merkles + 1 ) ; for ( i = 0 ; i < merkles ; i ++ ) { char * merkle = json_array_string ( arr , i ) ; pool -> swork . merkle_bin [ i ] = malloc ( 32 ) ; if ( unlikely ( ! pool -> swork . merkle_bin [ i ] ) ) quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>malloc<S2SV_blank>pool<S2SV_blank>swork<S2SV_blank>merkle_bin"" ) ; if ( opt_protocol ) applog ( LOG_DEBUG , ""merkle<S2SV_blank>%d:<S2SV_blank>%s"" , i , merkle ) ; ret = hex2bin ( pool -> swork . merkle_bin [ i ] , merkle , 32 ) ; free ( merkle ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>merkle<S2SV_blank>to<S2SV_blank>merkle_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; goto out_unlock ; } } } pool -> merkles = merkles ; if ( clean ) pool -> nonce2 = 0 ; # if 0 header_len = strlen ( pool -> bbversion ) + strlen ( pool -> prev_hash ) ; 32 + strlen ( pool -> ntime ) + strlen ( pool -> nbit ) + 8 + 96 ; # endif snprintf ( header , 225 , ""%s%s%s%s%s%s%s"" , pool -> bbversion , pool -> prev_hash , blank_merkle , pool -> ntime , pool -> nbit , ""00000000"" , workpadding ) ; ret = hex2bin ( pool -> header_bin , header , 112 ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; goto out_unlock ; } cb1 = alloca ( cb1_len ) ; ret = hex2bin ( cb1 , coinbase1 , cb1_len ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>cb1<S2SV_blank>to<S2SV_blank>cb1_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; goto out_unlock ; } cb2 = alloca ( cb2_len ) ; ret = hex2bin ( cb2 , coinbase2 , cb2_len ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>cb2<S2SV_blank>to<S2SV_blank>cb2_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; goto out_unlock ; } free ( pool -> coinbase ) ; align_len ( & alloc_len ) ; pool -> coinbase = calloc ( alloc_len , 1 ) ; if ( unlikely ( ! pool -> coinbase ) ) quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool<S2SV_blank>coinbase<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; memcpy ( pool -> coinbase , cb1 , cb1_len ) ; memcpy ( pool -> coinbase + cb1_len , pool -> nonce1bin , pool -> n1_len ) ; memcpy ( pool -> coinbase + cb1_len + pool -> n1_len + pool -> n2size , cb2 , cb2_len ) ; if ( opt_debug ) { char * cb = bin2hex ( pool -> coinbase , pool -> coinbase_len ) ; applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>coinbase<S2SV_blank>%s"" , pool -> pool_no , cb ) ; free ( cb ) ; } out_unlock : cg_wunlock ( & pool -> data_lock ) ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""job_id:<S2SV_blank>%s"" , job_id ) ; applog ( LOG_DEBUG , ""prev_hash:<S2SV_blank>%s"" , prev_hash ) ; applog ( LOG_DEBUG , ""coinbase1:<S2SV_blank>%s"" , coinbase1 ) ; applog ( LOG_DEBUG , ""coinbase2:<S2SV_blank>%s"" , coinbase2 ) ; applog ( LOG_DEBUG , ""bbversion:<S2SV_blank>%s"" , bbversion ) ; applog ( LOG_DEBUG , ""nbit:<S2SV_blank>%s"" , nbit ) ; applog ( LOG_DEBUG , ""ntime:<S2SV_blank>%s"" , ntime ) ; applog ( LOG_DEBUG , ""clean:<S2SV_blank>%s"" , clean ? ""yes"" : ""no"" ) ; } free ( coinbase1 ) ; free ( coinbase2 ) ; pool -> getwork_requested ++ ; total_getworks ++ ; if ( pool == current_pool ( ) ) opt_work_update = true ; out : return ret ; }",if ( ! valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) {free ( job_id ) free ( job_id ) ;,1482
399,"buggy line: if ( ctx -> priv -> alg_priv )   ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ;ctx -> iface = NULL ;cwe id:CWE-119context: vpx_codec_err_t vpx_codec_destroy ( vpx_codec_ctx_t * ctx ) { vpx_codec_err_t res ; if ( ! ctx ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else {  if ( ctx -> priv -> alg_priv )   ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ;  ctx -> iface = NULL ; ctx -> name = NULL ; ctx -> priv = NULL ; res = VPX_CODEC_OK ; } return SAVE_STATUS ( ctx , res ) ; }",ctx -> iface -> destroy ( ( vpx_codec_alg_priv_t * ) ctx -> priv -> alg_priv ) ;ctx -> iface = NULL ;,1483
400,"buggy line: case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON :  return 1 ;case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ;cwe id:CWE-20context: static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON :  return 1 ;  case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return 1 ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_PREEMPTION_TIMER : return vmcs12 -> pin_based_vm_exec_control & PIN_BASED_VMX_PREEMPTION_TIMER ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }","case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : return 1 ;case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ;",1484
401,"buggy line: sf -> adaptive_rd_thresh = 1 ;sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ;sf -> allow_skip_recode = 1 ;if ( speed >= 1 ) {sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ;sf -> less_rectangular_check = 1 ;sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD  : USE_LARGESTALL ;if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ;else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ;sf -> adaptive_motion_search = 1 ;sf -> auto_mv_step_size = 1 ;sf -> adaptive_rd_thresh = 2 ;sf -> subpel_iters_per_step = 1 ;sf -> mode_skip_start = 10 ;sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ;}sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD  : USE_LARGESTALL ;if ( MIN ( cm -> width , cm -> height ) >= 720 )  sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ;else sf -> disable_split_mask = LAST_AND_INTRA_SPLIT_ONLY ;sf -> adaptive_pred_interp_filter = 2 ;sf -> reference_masking = 1 ;sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ;sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ;sf -> adjust_partitioning_from_last_frame = 1 ;if ( MIN ( cm -> width , cm -> height ) >= 720 )  sf -> disable_split_mask = DISABLE_ALL_SPLIT ;sf -> recode_loop = ALLOW_RECODE_KFMAXBW ;sf -> adaptive_rd_thresh = 3 ;sf -> mode_skip_start = 6 ;sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ;sf -> use_fast_coef_costing = 1 ;sf -> disable_split_mask = DISABLE_ALL_SPLIT ;sf -> adaptive_rd_thresh = 4 ;sf -> mode_search_skip_flags |= FLAG_SKIP_COMP_REFMISMATCH |  FLAG_EARLY_TERMINATE ;sf -> disable_filter_search_var_thresh = 200 ;sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ;sf -> use_lp32x32fdct = 1 ;}sf -> partition_search_type = FIXED_PARTITION ;sf -> optimize_coefficients = 0 ;sf -> search_method = HEX ;sf -> disable_filter_search_var_thresh = 500 ;sf -> intra_y_mode_mask [ i ] = INTRA_DC_ONLY ;sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ;}cpi -> allow_encode_breakout = ENCODE_BREAKOUT_ENABLED ;cwe id:CWE-119context: static void set_good_speed_feature ( VP9_COMP * cpi , VP9_COMMON * cm , SPEED_FEATURES * sf , int speed ) {  sf -> adaptive_rd_thresh = 1 ;  sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ; sf -> allow_skip_recode = 1 ; if ( speed >= 1 ) {  sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ;   sf -> less_rectangular_check = 1 ;   sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD  : USE_LARGESTALL ; if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ; sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search = 1 ;  sf -> auto_mv_step_size = 1 ;  sf -> adaptive_rd_thresh = 2 ;  sf -> subpel_iters_per_step = 1 ;  sf -> mode_skip_start = 10 ; sf -> adaptive_pred_interp_filter = 1 ; sf -> recode_loop = ALLOW_RECODE_KFARFGF ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ;  sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ;  } if ( speed >= 2 ) {  sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD  : USE_LARGESTALL ;  if ( MIN ( cm -> width , cm -> height ) >= 720 )  sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = LAST_AND_INTRA_SPLIT_ONLY ; sf -> adaptive_pred_interp_filter = 2 ; sf -> reference_masking = 1 ; sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ; sf -> disable_filter_search_var_thresh = 100 ; sf -> comp_inter_joint_search_thresh = BLOCK_SIZES ; sf -> auto_min_max_partition_size = RELAXED_NEIGHBORING_MIN_MAX ;  sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ;  sf -> adjust_partitioning_from_last_frame = 1 ; sf -> last_partitioning_redo_frequency = 3 ; } if ( speed >= 3 ) {  if ( MIN ( cm -> width , cm -> height ) >= 720 )  sf -> disable_split_mask = DISABLE_ALL_SPLIT ; else sf -> disable_split_mask = DISABLE_ALL_INTER_SPLIT ; sf -> recode_loop = ALLOW_RECODE_KFMAXBW ; sf -> adaptive_rd_thresh = 3 ; sf -> mode_skip_start = 6 ;  sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ;  sf -> use_fast_coef_costing = 1 ; } if ( speed >= 4 ) { sf -> use_square_partition_only = 1 ; sf -> tx_size_search_method = USE_LARGESTALL ;  sf -> disable_split_mask = DISABLE_ALL_SPLIT ;   sf -> adaptive_rd_thresh = 4 ;   sf -> mode_search_skip_flags |= FLAG_SKIP_COMP_REFMISMATCH |  FLAG_EARLY_TERMINATE ; sf -> disable_filter_search_var_thresh = 200 ;  sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ;   sf -> use_lp32x32fdct = 1 ;  } if ( speed >= 5 ) { int i ;  sf -> partition_search_type = FIXED_PARTITION ;  sf -> optimize_coefficients = 0 ;  sf -> search_method = HEX ;  sf -> disable_filter_search_var_thresh = 500 ; for ( i = 0 ; i < TX_SIZES ; ++ i ) {  sf -> intra_y_mode_mask [ i ] = INTRA_DC_ONLY ;   sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ;  } cpi -> allow_encode_breakout = ENCODE_BREAKOUT_ENABLED ; } }","const int boosted = frame_is_boosted ( cpi ) ;sf -> adaptive_rd_thresh = 1 ;sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ;sf -> mv . adaptive_motion_search = 1 ;sf -> mv . auto_mv_step_size = 1 ;sf -> adaptive_rd_thresh = 2 ;sf -> subpel_iters_per_step = 1 ;sf -> mode_skip_start = 10 ;sf -> tx_size_search_breakout = 1 ;sf -> partition_search_breakout_rate_thr = 80 ;sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ;}sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD : USE_LARGESTALL ;sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ;sf -> mode_search_skip_flags = ( cm -> frame_type == KEY_FRAME ) ? 0 : FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ;sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ;sf -> adjust_partitioning_from_last_frame = 1 ;if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = DISABLE_ALL_SPLIT ;sf -> allow_partition_search_skip = 1 ;sf -> disable_split_mask = DISABLE_ALL_SPLIT ;sf -> adaptive_rd_thresh = 4 ;sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ;sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ;sf -> adaptive_interp_filter_search = 1 ;}sf -> mv . search_method = BIGDIA ;sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE ;sf -> optimize_coefficients = 0 ;sf -> mv . search_method = HEX ;sf -> disable_filter_search_var_thresh = 500 ;sf -> intra_y_mode_mask [ i ] = INTRA_DC ;sf -> intra_uv_mode_mask [ i ] = INTRA_DC ;}sf -> partition_search_breakout_rate_thr = 500 ;sf -> mv . reduce_first_step_size = 1 ;sf -> simple_model_rd_from_var = 1 ;",1485
402,"buggy line: dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;BUG_ON ( dh == NULL ) ;cwe id:CWE-20context: static int dccp_packet ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info ctinfo , u_int8_t pf , unsigned int hooknum , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; enum ip_conntrack_dir dir = CTINFO2DIR ( ctinfo ) ; struct dccp_hdr _dh , * dh ; u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ;  dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;  BUG_ON ( dh == NULL ) ; type = dh -> dccph_type ; if ( type == DCCP_PKT_RESET && ! test_bit ( IPS_SEEN_REPLY_BIT , & ct -> status ) ) { nf_ct_kill_acct ( ct , ctinfo , skb ) ; return NF_ACCEPT ; } spin_lock_bh ( & ct -> lock ) ; role = ct -> proto . dccp . role [ dir ] ; old_state = ct -> proto . dccp . state ; new_state = dccp_state_table [ role ] [ type ] [ old_state ] ; switch ( new_state ) { case CT_DCCP_REQUEST : if ( old_state == CT_DCCP_TIMEWAIT && role == CT_DCCP_ROLE_SERVER ) { ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_SERVER ; } break ; case CT_DCCP_RESPOND : if ( old_state == CT_DCCP_REQUEST ) ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; break ; case CT_DCCP_PARTOPEN : if ( old_state == CT_DCCP_RESPOND && type == DCCP_PKT_ACK && dccp_ack_seq ( dh ) == ct -> proto . dccp . handshake_seq ) set_bit ( IPS_ASSURED_BIT , & ct -> status ) ; break ; case CT_DCCP_IGNORE : if ( ct -> proto . dccp . last_dir == ! dir && ct -> proto . dccp . last_pkt == DCCP_PKT_REQUEST && type == DCCP_PKT_RESPONSE ) { ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; new_state = CT_DCCP_RESPOND ; break ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; spin_unlock_bh ( & ct -> lock ) ; if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>packet<S2SV_blank>ignored<S2SV_blank>"" ) ; return NF_ACCEPT ; case CT_DCCP_INVALID : spin_unlock_bh ( & ct -> lock ) ; if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ) ; return - NF_ACCEPT ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; ct -> proto . dccp . state = new_state ; spin_unlock_bh ( & ct -> lock ) ; if ( new_state != old_state ) nf_conntrack_event_cache ( IPCT_PROTOINFO , ct ) ; nf_ct_refresh_acct ( ct , ctinfo , skb , timeouts [ new_state ] ) ; return NF_ACCEPT ; }","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;BUG_ON ( dh == NULL ) ;",1486
403,"buggy line: if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) )  return - EFAULT ;cwe id:CWE-200context: int compat_get_timex ( struct timex * txc , const struct compat_timex __user * utp ) { struct compat_timex tx32 ;  if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) )  return - EFAULT ; txc -> modes = tx32 . modes ; txc -> offset = tx32 . offset ; txc -> freq = tx32 . freq ; txc -> maxerror = tx32 . maxerror ; txc -> esterror = tx32 . esterror ; txc -> status = tx32 . status ; txc -> constant = tx32 . constant ; txc -> precision = tx32 . precision ; txc -> tolerance = tx32 . tolerance ; txc -> time . tv_sec = tx32 . time . tv_sec ; txc -> time . tv_usec = tx32 . time . tv_usec ; txc -> tick = tx32 . tick ; txc -> ppsfreq = tx32 . ppsfreq ; txc -> jitter = tx32 . jitter ; txc -> shift = tx32 . shift ; txc -> stabil = tx32 . stabil ; txc -> jitcnt = tx32 . jitcnt ; txc -> calcnt = tx32 . calcnt ; txc -> errcnt = tx32 . errcnt ; txc -> stbcnt = tx32 . stbcnt ; return 0 ; }","memset ( txc , 0 , sizeof ( struct timex ) ) ;if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) return - EFAULT ;",1487
404,"buggy line: int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ;if ( ret == - 1 ) {cwe id:CWE-284context: static void * sock_poll_thread ( void * arg ) { struct pollfd pfds [ MAX_POLL ] ; memset ( pfds , 0 , sizeof ( pfds ) ) ; int h = ( intptr_t ) arg ; for ( ; ; ) { prepare_poll_fds ( h , pfds ) ;  int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ;  if ( ret == - 1 ) { APPL_TRACE_ERROR ( ""poll<S2SV_blank>ret<S2SV_blank>-1,<S2SV_blank>exit<S2SV_blank>the<S2SV_blank>thread,<S2SV_blank>errno:%d,<S2SV_blank>err:%s"" , errno , strerror ( errno ) ) ; break ; } if ( ret != 0 ) { int need_process_data_fd = TRUE ; if ( pfds [ 0 ] . revents ) { asrt ( pfds [ 0 ] . fd == ts [ h ] . cmd_fdr ) ; if ( ! process_cmd_sock ( h ) ) { APPL_TRACE_DEBUG ( ""h:%d,<S2SV_blank>process_cmd_sock<S2SV_blank>return<S2SV_blank>false,<S2SV_blank>exit..."" , h ) ; break ; } if ( ret == 1 ) need_process_data_fd = FALSE ; else ret -- ; } if ( need_process_data_fd ) process_data_sock ( h , pfds , ret ) ; } else { APPL_TRACE_DEBUG ( ""no<S2SV_blank>data,<S2SV_blank>select<S2SV_blank>ret:<S2SV_blank>%d"" , ret ) } ; } ts [ h ] . thread_id = - 1 ; APPL_TRACE_DEBUG ( ""socket<S2SV_blank>poll<S2SV_blank>thread<S2SV_blank>exiting,<S2SV_blank>h:%d"" , h ) ; return 0 ; }","int ret = TEMP_FAILURE_RETRY ( poll ( pfds , ts [ h ] . poll_count , - 1 ) ) ;if ( ret == - 1 ) {",1488
405,"buggy line: int goodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ;if ( goodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ;cwe id:CWE-416context: void luaD_shrinkstack ( lua_State * L ) { int inuse = stackinuse ( L ) ;  int goodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ;  if ( goodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ; if ( inuse <= ( LUAI_MAXSTACK - EXTRA_STACK ) && goodsize < L -> stacksize ) luaD_reallocstack ( L , goodsize , 0 ) ; else condmovestack ( L , { } , { } ) ; luaE_shrinkCI ( L ) ; }",int goodsize = inuse + BASIC_STACK_SIZE ;if ( goodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ;,1489
406,"buggy line: Py_INCREF ( Py_None ) ;return Py_None ;cwe id:CWE-125context: PyObject * ast2obj_alias ( void * _o ) { alias_ty o = ( alias_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) {  Py_INCREF ( Py_None ) ;  return Py_None ; } result = PyType_GenericNew ( alias_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> asname ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_asname , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",Py_RETURN_NONE ;,1490
407,"buggy line: node * ch = CHILD ( n , 0 ) ;switch ( TYPE ( ch ) ) {case NAME : {PyObject * name = NEW_IDENTIFIER ( ch ) ;if ( ! name ) return NULL ;return Name ( name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ;}case STRING : {PyObject * kind , * str = parsestrplus ( c , n ) ;const char * raw , * s = STR ( CHILD ( n , 0 ) ) ;int quote = Py_CHARMASK ( * s ) ;cwe id:CWE-125context: static expr_ty ast_for_atom ( struct compiling * c , const node * n ) { node * ch = CHILD ( n , 0 ) ; switch ( TYPE ( ch ) ) { case NAME : { PyObject * name = NEW_IDENTIFIER ( ch ) ; if ( ! name ) return NULL ; return Name ( name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case STRING : { PyObject * kind , * str = parsestrplus ( c , n ) ;  const char * raw , * s = STR ( CHILD ( n , 0 ) ) ;  int quote = Py_CHARMASK ( * s ) ; char * ch , s_kind [ 3 ] = { 0 , 0 , 0 } ; ch = s_kind ; raw = s ; while ( * raw && * raw != '\\'' && * raw != \'""\' ) { * ch ++ = * raw ++ ; } kind = PyUnicode_FromString ( s_kind ) ; if ( ! kind ) { return NULL ; } if ( ! str ) { # ifdef Py_USING_UNICODE if ( PyErr_ExceptionMatches ( PyExc_UnicodeError ) ) { PyObject * type , * value , * tback , * errstr ; PyErr_Fetch ( & type , & value , & tback ) ; errstr = PyObject_Str ( value ) ; if ( errstr ) {  char * s = """" ;  char buf [ 128 ] ; s = _PyUnicode_AsString ( errstr ) ; PyOS_snprintf ( buf , sizeof ( buf ) , ""(unicode<S2SV_blank>error)<S2SV_blank>%s"" , s ) ; ast_error ( n , buf ) ; Py_DECREF ( errstr ) ; } else { ast_error ( n , ""(unicode<S2SV_blank>error)<S2SV_blank>unknown<S2SV_blank>error"" ) ; } Py_DECREF ( type ) ; Py_DECREF ( value ) ; Py_XDECREF ( tback ) ; } # endif return NULL ; } PyArena_AddPyObject ( c -> c_arena , str ) ; return Str ( str , kind , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case NUMBER : { PyObject * pynum = parsenumber ( c , STR ( ch ) ) ; if ( ! pynum ) return NULL ; PyArena_AddPyObject ( c -> c_arena , pynum ) ; return Num ( pynum , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case LPAR : ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RPAR ) return Tuple ( NULL , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( TYPE ( ch ) == yield_expr ) return ast_for_expr ( c , ch ) ; return ast_for_testlist_comp ( c , ch ) ; case LSQB : ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RSQB ) return List ( NULL , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; REQ ( ch , listmaker ) ; if ( NCH ( ch ) == 1 || TYPE ( CHILD ( ch , 1 ) ) == COMMA ) { asdl_seq * elts = seq_for_testlist ( c , ch ) ; if ( ! elts ) return NULL ; return List ( elts , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else return ast_for_listcomp ( c , ch ) ; case LBRACE : { int i , size ; asdl_seq * keys , * values ; ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RBRACE ) { return Dict ( NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else if ( NCH ( ch ) == 1 || TYPE ( CHILD ( ch , 1 ) ) == COMMA ) { asdl_seq * elts ; size = ( NCH ( ch ) + 1 ) / 2 ; elts = asdl_seq_new ( size , c -> c_arena ) ; if ( ! elts ) return NULL ; for ( i = 0 ; i < NCH ( ch ) ; i += 2 ) { expr_ty expression ; expression = ast_for_expr ( c , CHILD ( ch , i ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( elts , i / 2 , expression ) ; } return Set ( elts , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) { return ast_for_setcomp ( c , ch ) ; } else if ( NCH ( ch ) > 3 && TYPE ( CHILD ( ch , 3 ) ) == comp_for ) { return ast_for_dictcomp ( c , ch ) ; } else { size = ( NCH ( ch ) + 1 ) / 4 ; keys = asdl_seq_new ( size , c -> c_arena ) ; if ( ! keys ) return NULL ; values = asdl_seq_new ( size , c -> c_arena ) ; if ( ! values ) return NULL ; for ( i = 0 ; i < NCH ( ch ) ; i += 4 ) { expr_ty expression ; expression = ast_for_expr ( c , CHILD ( ch , i ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( keys , i / 4 , expression ) ; expression = ast_for_expr ( c , CHILD ( ch , i + 2 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( values , i / 4 , expression ) ; } return Dict ( keys , values , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } } case BACKQUOTE : { expr_ty expression ; if ( Py_Py3kWarningFlag && ! ast_warn ( c , n , ""backquote<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>3.x;<S2SV_blank>use<S2SV_blank>repr()"" ) ) return NULL ; expression = ast_for_testlist ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; return Repr ( expression , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } default : PyErr_Format ( PyExc_SystemError , ""unhandled<S2SV_blank>atom<S2SV_blank>%d"" , TYPE ( ch ) ) ; return NULL ; } }","node * ch = CHILD ( n , 0 ) ) ;",1491
408,"buggy line: char * s = """" ;char buf [ 128 ] ;cwe id:CWE-125context: static expr_ty ast_for_atom ( struct compiling * c , const node * n ) { node * ch = CHILD ( n , 0 ) ; switch ( TYPE ( ch ) ) { case NAME : { PyObject * name = NEW_IDENTIFIER ( ch ) ; if ( ! name ) return NULL ; return Name ( name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case STRING : { PyObject * kind , * str = parsestrplus ( c , n ) ;  const char * raw , * s = STR ( CHILD ( n , 0 ) ) ;  int quote = Py_CHARMASK ( * s ) ; char * ch , s_kind [ 3 ] = { 0 , 0 , 0 } ; ch = s_kind ; raw = s ; while ( * raw && * raw != '\\'' && * raw != \'""\' ) { * ch ++ = * raw ++ ; } kind = PyUnicode_FromString ( s_kind ) ; if ( ! kind ) { return NULL ; } if ( ! str ) { # ifdef Py_USING_UNICODE if ( PyErr_ExceptionMatches ( PyExc_UnicodeError ) ) { PyObject * type , * value , * tback , * errstr ; PyErr_Fetch ( & type , & value , & tback ) ; errstr = PyObject_Str ( value ) ; if ( errstr ) {  char * s = """" ;  char buf [ 128 ] ; s = _PyUnicode_AsString ( errstr ) ; PyOS_snprintf ( buf , sizeof ( buf ) , ""(unicode<S2SV_blank>error)<S2SV_blank>%s"" , s ) ; ast_error ( n , buf ) ; Py_DECREF ( errstr ) ; } else { ast_error ( n , ""(unicode<S2SV_blank>error)<S2SV_blank>unknown<S2SV_blank>error"" ) ; } Py_DECREF ( type ) ; Py_DECREF ( value ) ; Py_XDECREF ( tback ) ; } # endif return NULL ; } PyArena_AddPyObject ( c -> c_arena , str ) ; return Str ( str , kind , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case NUMBER : { PyObject * pynum = parsenumber ( c , STR ( ch ) ) ; if ( ! pynum ) return NULL ; PyArena_AddPyObject ( c -> c_arena , pynum ) ; return Num ( pynum , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case LPAR : ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RPAR ) return Tuple ( NULL , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( TYPE ( ch ) == yield_expr ) return ast_for_expr ( c , ch ) ; return ast_for_testlist_comp ( c , ch ) ; case LSQB : ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RSQB ) return List ( NULL , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; REQ ( ch , listmaker ) ; if ( NCH ( ch ) == 1 || TYPE ( CHILD ( ch , 1 ) ) == COMMA ) { asdl_seq * elts = seq_for_testlist ( c , ch ) ; if ( ! elts ) return NULL ; return List ( elts , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else return ast_for_listcomp ( c , ch ) ; case LBRACE : { int i , size ; asdl_seq * keys , * values ; ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RBRACE ) { return Dict ( NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else if ( NCH ( ch ) == 1 || TYPE ( CHILD ( ch , 1 ) ) == COMMA ) { asdl_seq * elts ; size = ( NCH ( ch ) + 1 ) / 2 ; elts = asdl_seq_new ( size , c -> c_arena ) ; if ( ! elts ) return NULL ; for ( i = 0 ; i < NCH ( ch ) ; i += 2 ) { expr_ty expression ; expression = ast_for_expr ( c , CHILD ( ch , i ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( elts , i / 2 , expression ) ; } return Set ( elts , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) { return ast_for_setcomp ( c , ch ) ; } else if ( NCH ( ch ) > 3 && TYPE ( CHILD ( ch , 3 ) ) == comp_for ) { return ast_for_dictcomp ( c , ch ) ; } else { size = ( NCH ( ch ) + 1 ) / 4 ; keys = asdl_seq_new ( size , c -> c_arena ) ; if ( ! keys ) return NULL ; values = asdl_seq_new ( size , c -> c_arena ) ; if ( ! values ) return NULL ; for ( i = 0 ; i < NCH ( ch ) ; i += 4 ) { expr_ty expression ; expression = ast_for_expr ( c , CHILD ( ch , i ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( keys , i / 4 , expression ) ; expression = ast_for_expr ( c , CHILD ( ch , i + 2 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( values , i / 4 , expression ) ; } return Dict ( keys , values , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } } case BACKQUOTE : { expr_ty expression ; if ( Py_Py3kWarningFlag && ! ast_warn ( c , n , ""backquote<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>3.x;<S2SV_blank>use<S2SV_blank>repr()"" ) ) return NULL ; expression = ast_for_testlist ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; return Repr ( expression , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } default : PyErr_Format ( PyExc_SystemError , ""unhandled<S2SV_blank>atom<S2SV_blank>%d"" , TYPE ( ch ) ) ; return NULL ; } }","const char * s = """" ;char buf [ 128 ] ;",1491
409,"buggy line: int is_keyframe_qaunt_set = 0 ;vpx_codec_err_t res = VPX_CODEC_OK ;cwe id:CWE-119context: static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) { char * input_string ; char * option_name ; char * option_value ; char * input_ptr ;  int is_keyframe_qaunt_set = 0 ;  vpx_codec_err_t res = VPX_CODEC_OK ; if ( options == NULL ) return VPX_CODEC_OK ; input_string = strdup ( options ) ; option_name = strtok_r ( input_string , ""="" , & input_ptr ) ; while ( option_name != NULL ) { option_value = strtok_r ( NULL , ""<S2SV_blank>"" , & input_ptr ) ; if ( option_value == NULL ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""option<S2SV_blank>missing<S2SV_blank>value:<S2SV_blank>%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; }  if ( strcmp ( ""encoding-mode"" , option_name ) == 0 ) {  res = set_option_encoding_mode ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ;  } else if ( strcmp ( ""layers"" , option_name ) == 0 ) {  svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) { res = parse_scale_factors ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ;  } else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) {  res = parse_quantizer_values ( svc_ctx , option_value , 0 ) ; if ( res != VPX_CODEC_OK ) break ;  if ( ! is_keyframe_qaunt_set ) {  SvcInternal * const si = get_svc_internal ( svc_ctx ) ; memcpy ( get_svc_internal ( svc_ctx ) -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ; } } else if ( strcmp ( ""quantizers-keyframe"" , option_name ) == 0 ) { res = parse_quantizer_values ( svc_ctx , option_value , 1 ) ; if ( res != VPX_CODEC_OK ) break ;  is_keyframe_qaunt_set = 1 ;  } else { svc_log ( svc_ctx , SVC_LOG_ERROR , ""invalid<S2SV_blank>option:<S2SV_blank>%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; } option_name = strtok_r ( NULL , ""="" , & input_ptr ) ; } free ( input_string ) ;  return res ;  }","SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ;vpx_codec_err_t res = VPX_CODEC_OK ;int i , alt_ref_enabled = 0 ;",1492
410,"buggy line: if ( strcmp ( ""encoding-mode"" , option_name ) == 0 ) {res = set_option_encoding_mode ( svc_ctx , option_value ) ;}svc_ctx -> spatial_layers = atoi ( option_value ) ;else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) {res = parse_scale_factors ( svc_ctx , option_value ) ;if ( res != VPX_CODEC_OK ) break ;}else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) {res = parse_quantizer_values ( svc_ctx , option_value , 0 ) ;if ( ! is_keyframe_qaunt_set ) {SvcInternal * const si = get_svc_internal ( svc_ctx ) ;memcpy ( get_svc_internal ( svc_ctx ) -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ;else if ( strcmp ( ""quantizers-keyframe"" , option_name ) == 0 ) {res = parse_quantizer_values ( svc_ctx , option_value , 1 ) ;is_keyframe_qaunt_set = 1 ;}cwe id:CWE-119context: static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) { char * input_string ; char * option_name ; char * option_value ; char * input_ptr ;  int is_keyframe_qaunt_set = 0 ;  vpx_codec_err_t res = VPX_CODEC_OK ; if ( options == NULL ) return VPX_CODEC_OK ; input_string = strdup ( options ) ; option_name = strtok_r ( input_string , ""="" , & input_ptr ) ; while ( option_name != NULL ) { option_value = strtok_r ( NULL , ""<S2SV_blank>"" , & input_ptr ) ; if ( option_value == NULL ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""option<S2SV_blank>missing<S2SV_blank>value:<S2SV_blank>%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; }  if ( strcmp ( ""encoding-mode"" , option_name ) == 0 ) {  res = set_option_encoding_mode ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ;  } else if ( strcmp ( ""layers"" , option_name ) == 0 ) {  svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) { res = parse_scale_factors ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ;  } else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) {  res = parse_quantizer_values ( svc_ctx , option_value , 0 ) ; if ( res != VPX_CODEC_OK ) break ;  if ( ! is_keyframe_qaunt_set ) {  SvcInternal * const si = get_svc_internal ( svc_ctx ) ; memcpy ( get_svc_internal ( svc_ctx ) -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ; } } else if ( strcmp ( ""quantizers-keyframe"" , option_name ) == 0 ) { res = parse_quantizer_values ( svc_ctx , option_value , 1 ) ; if ( res != VPX_CODEC_OK ) break ;  is_keyframe_qaunt_set = 1 ;  } else { svc_log ( svc_ctx , SVC_LOG_ERROR , ""invalid<S2SV_blank>option:<S2SV_blank>%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; } option_name = strtok_r ( NULL , ""="" , & input_ptr ) ; } free ( input_string ) ;  return res ;  }","if ( strcmp ( ""spatial-layers"" , option_name ) == 0 ) {svc_ctx -> spatial_layers = atoi ( option_value ) ;}else if ( strcmp ( ""max-quantizers"" , option_name ) == 0 ) {res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL ) ;}svc_ctx -> spatial_layers = atoi ( option_value ) ;else if ( strcmp ( ""min-quantizers"" , option_name ) == 0 ) {res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL ) ;else if ( strcmp ( ""auto-alt-refs"" , option_name ) == 0 ) {res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL ) ;if ( res != VPX_CODEC_OK ) break ;else if ( strcmp ( ""bitrates"" , option_name ) == 0 ) {res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ;}else if ( strcmp ( ""multi-frame-contexts"" , option_name ) == 0 ) {si -> use_multiple_frame_contexts = atoi ( option_value ) ;}",1492
411,"buggy line: return res ;}cwe id:CWE-119context: static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) { char * input_string ; char * option_name ; char * option_value ; char * input_ptr ;  int is_keyframe_qaunt_set = 0 ;  vpx_codec_err_t res = VPX_CODEC_OK ; if ( options == NULL ) return VPX_CODEC_OK ; input_string = strdup ( options ) ; option_name = strtok_r ( input_string , ""="" , & input_ptr ) ; while ( option_name != NULL ) { option_value = strtok_r ( NULL , ""<S2SV_blank>"" , & input_ptr ) ; if ( option_value == NULL ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""option<S2SV_blank>missing<S2SV_blank>value:<S2SV_blank>%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; }  if ( strcmp ( ""encoding-mode"" , option_name ) == 0 ) {  res = set_option_encoding_mode ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ;  } else if ( strcmp ( ""layers"" , option_name ) == 0 ) {  svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) { res = parse_scale_factors ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ;  } else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) {  res = parse_quantizer_values ( svc_ctx , option_value , 0 ) ; if ( res != VPX_CODEC_OK ) break ;  if ( ! is_keyframe_qaunt_set ) {  SvcInternal * const si = get_svc_internal ( svc_ctx ) ; memcpy ( get_svc_internal ( svc_ctx ) -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ; } } else if ( strcmp ( ""quantizers-keyframe"" , option_name ) == 0 ) { res = parse_quantizer_values ( svc_ctx , option_value , 1 ) ; if ( res != VPX_CODEC_OK ) break ;  is_keyframe_qaunt_set = 1 ;  } else { svc_log ( svc_ctx , SVC_LOG_ERROR , ""invalid<S2SV_blank>option:<S2SV_blank>%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; } option_name = strtok_r ( NULL , ""="" , & input_ptr ) ; } free ( input_string ) ;  return res ;  }","for ( i = 0 ;i < svc_ctx -> spatial_layers ;++ i ) {if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ;}if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ;for ( i = 0 ;i < svc_ctx -> spatial_layers ;++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ;if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) {svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc:<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>ref:<S2SV_blank>Maxinum<S2SV_blank>%d(REF_FRAMES<S2SV_blank>-<S2SV_blank>layers)<S2SV_blank>layers<S2SV_blank>could"" ""enabled<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>reference<S2SV_blank>frame,<S2SV_blank>but<S2SV_blank>%<S2SV_blank>layers<S2SV_blank>are<S2SV_blank>enabled\\\res = VPX_CODEC_INVALID_PARAM ;}return res ;}",1492
412,"buggy line: if ( is_sampling_event ( event ) ) {if ( ! head ) {WARN_ON_ONCE ( swhash -> online ) ;return - EINVAL ;}hlist_add_head_rcu ( & event -> hlist_entry , head ) ;cwe id:CWE-416context: static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ;  if ( ! head ) {  WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ;  }  hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }","if ( WARN_ON_ONCE ( is_sampling_event ( event ) ) {if ( ! head ) ) return - EINVAL ;}hlist_add_head_rcu ( & event -> hlist_entry , head ) ;",1493
413,"buggy line: for ( s += 9 ;isspace ( * s ) ;if ( * s == \'/\' ) {while ( * t && ! isspace ( * t ) ) t ++ ;free ( font_name ) ;cwe id:CWE-119context: static void t1mac_output_ascii ( char * s , int len ) { if ( blocktyp == POST_BINARY ) { output_current_post ( ) ; blocktyp = POST_ASCII ; } if ( len > 0 && s [ len - 1 ] == '\\n' ) s [ len - 1 ] = '\\r' ; t1mac_output_data ( ( byte * ) s , len ) ; if ( strncmp ( s , ""/FontName"" , 9 ) == 0 ) {  for ( s += 9 ; isspace ( * s ) ; s ++ ) ;  if ( * s == '/' ) { const char * t = ++ s ;  while ( * t && ! isspace ( * t ) ) t ++ ;  free ( font_name ) ; font_name = ( char * ) malloc ( t - s + 1 ) ; memcpy ( font_name , s , t - s ) ; font_name [ t - s ] = 0 ; } } }",for ( s += 9 ;isspace ( ( unsigned char ) * s ) ;if ( * s == \'/\' ) {while ( * t && ! isspace ( ( unsigned char ) * t ) ) t ++ ;free ( font_name ) ;,1494
414,"buggy line: if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) ||  ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) )  return KADM5_BAD_MASK ;if ( entry == ( kadm5_principal_ent_t ) NULL )  return EINVAL ;cwe id:CWE-000context: kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) { int ret , ret2 , i ; kadm5_policy_ent_rec pol ; krb5_boolean have_pol = FALSE ; krb5_db_entry * kdb ; krb5_tl_data * tl_data_orig ; osa_princ_ent_rec adb ; kadm5_server_handle_t handle = server_handle ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ;  if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) ||  ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ;  if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) )  return KADM5_BAD_MASK ;  if ( entry == ( kadm5_principal_ent_t ) NULL )  return EINVAL ; if ( mask & KADM5_TL_DATA ) { tl_data_orig = entry -> tl_data ; while ( tl_data_orig ) { if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; tl_data_orig = tl_data_orig -> tl_data_next ; } } ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; if ( ret ) return ( ret ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & pol , & have_pol ) ; if ( ret ) goto done ; adb . aux_attributes |= KADM5_POLICY ; if ( adb . policy ) free ( adb . policy ) ; adb . policy = strdup ( entry -> policy ) ; } if ( have_pol ) { if ( pol . pw_max_life ) { ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & ( kdb -> pw_expiration ) ) ; if ( ret ) goto done ; kdb -> pw_expiration += pol . pw_max_life ; } else { kdb -> pw_expiration = 0 ; } } if ( ( mask & KADM5_POLICY_CLR ) && ( adb . aux_attributes & KADM5_POLICY ) ) { free ( adb . policy ) ; adb . policy = NULL ; adb . aux_attributes &= ~ KADM5_POLICY ; kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; if ( mask & KADM5_PW_EXPIRATION ) kdb -> pw_expiration = entry -> pw_expiration ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; if ( ( mask & KADM5_KVNO ) ) { for ( i = 0 ; i < kdb -> n_key_data ; i ++ ) kdb -> key_data [ i ] . key_data_kvno = entry -> kvno ; } if ( mask & KADM5_TL_DATA ) { krb5_tl_data * tl ; for ( tl = entry -> tl_data ; tl ; tl = tl -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl ) ; if ( ret ) { goto done ; } } } if ( mask & KADM5_FAIL_AUTH_COUNT ) { if ( entry -> fail_auth_count != 0 ) { ret = KADM5_BAD_SERVER_PARAMS ; goto done ; } kdb -> fail_auth_count = 0 ; } kdb -> mask = mask ; ret = k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask ) ; if ( ret ) goto done ; ret = kdb_put_entry ( handle , kdb , & adb ) ; if ( ret ) goto done ; ( void ) k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask ) ; ret = KADM5_OK ; done : if ( have_pol ) { ret2 = kadm5_free_policy_ent ( handle -> lhandle , & pol ) ; ret = ret ? ret : ret2 ; } kdb_free_entry ( handle , kdb , & adb ) ; return ret ; }",if ( entry == NULL ) return EINVAL ;if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ;,1495
415,"buggy line: for ( plane = 0 ;plane < 4 && frame -> data [ plane ] ;int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ;cwe id:CWE-119context: static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc -> log2_chroma_h ;  for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) {  int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ; uint8_t * data = frame -> data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink -> h , vsub ) : inlink -> h ; if ( linesize < 0 ) return linesize ; for ( i = 0 ; i < h ; i ++ ) { plane_checksum [ plane ] = av_adler32_update ( plane_checksum [ plane ] , data , linesize ) ; checksum = av_adler32_update ( checksum , data , linesize ) ; data += frame -> linesize [ plane ] ; } } av_log ( ctx , AV_LOG_INFO , ""n:%"" PRId64 ""<S2SV_blank>pts:%s<S2SV_blank>pts_time:%s<S2SV_blank>pos:%"" PRId64 ""<S2SV_blank>"" ""fmt:%s<S2SV_blank>sar:%d/%d<S2SV_blank>s:%dx%d<S2SV_blank>i:%c<S2SV_blank>iskey:%d<S2SV_blank>type:%c<S2SV_blank>"" ""checksum:%08X<S2SV_blank>plane_checksum:[%08X"" , inlink -> frame_count , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & inlink -> time_base ) , av_frame_get_pkt_pos ( frame ) , desc -> name , frame -> sample_aspect_ratio . num , frame -> sample_aspect_ratio . den , frame -> width , frame -> height , ! frame -> interlaced_frame ? 'P' : frame -> top_field_first ? 'T' : 'B' , frame -> key_frame , av_get_picture_type_char ( frame -> pict_type ) , checksum , plane_checksum [ 0 ] ) ;  for ( plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane ++ )  av_log ( ctx , AV_LOG_INFO , ""<S2SV_blank>%08X"" , plane_checksum [ plane ] ) ; av_log ( ctx , AV_LOG_INFO , ""]\\n"" ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , frame ) ; }","for ( plane = 0 ;plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] && frame -> linesize [ plane ] ;int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ;",1496
416,"buggy line: for ( plane = 1 ;plane ++ )  av_log ( ctx , AV_LOG_INFO , ""<S2SV_blank>%08X"" , plane_checksum [ plane ] ) ;cwe id:CWE-119context: static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc -> log2_chroma_h ;  for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) {  int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ; uint8_t * data = frame -> data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink -> h , vsub ) : inlink -> h ; if ( linesize < 0 ) return linesize ; for ( i = 0 ; i < h ; i ++ ) { plane_checksum [ plane ] = av_adler32_update ( plane_checksum [ plane ] , data , linesize ) ; checksum = av_adler32_update ( checksum , data , linesize ) ; data += frame -> linesize [ plane ] ; } } av_log ( ctx , AV_LOG_INFO , ""n:%"" PRId64 ""<S2SV_blank>pts:%s<S2SV_blank>pts_time:%s<S2SV_blank>pos:%"" PRId64 ""<S2SV_blank>"" ""fmt:%s<S2SV_blank>sar:%d/%d<S2SV_blank>s:%dx%d<S2SV_blank>i:%c<S2SV_blank>iskey:%d<S2SV_blank>type:%c<S2SV_blank>"" ""checksum:%08X<S2SV_blank>plane_checksum:[%08X"" , inlink -> frame_count , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & inlink -> time_base ) , av_frame_get_pkt_pos ( frame ) , desc -> name , frame -> sample_aspect_ratio . num , frame -> sample_aspect_ratio . den , frame -> width , frame -> height , ! frame -> interlaced_frame ? 'P' : frame -> top_field_first ? 'T' : 'B' , frame -> key_frame , av_get_picture_type_char ( frame -> pict_type ) , checksum , plane_checksum [ 0 ] ) ;  for ( plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane ++ )  av_log ( ctx , AV_LOG_INFO , ""<S2SV_blank>%08X"" , plane_checksum [ plane ] ) ; av_log ( ctx , AV_LOG_INFO , ""]\\n"" ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , frame ) ; }","for ( plane = 1 ;plane ++ ) av_log ( ctx , AV_LOG_INFO , ""<S2SV_blank>%08X"" , plane_checksum [ plane ] ) ;",1496
417,"buggy line: mb_index ++ ;}fprintf ( mvs , ""\\\mb_index = 0 ;cwe id:CWE-119context: void vp8_print_modes_and_motion_vectors ( MODE_INFO * mi , int rows , int cols , int frame ) { int mb_row ; int mb_col ; int mb_index = 0 ; FILE * mvs = fopen ( ""mvs.stt"" , ""a"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . mode ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>mv<S2SV_blank>ref<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . ref_frame ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""UV<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . uv_mode ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; }  fprintf ( mvs , ""\\n"" ) ;  mb_index = 0 ; fprintf ( mvs , ""Mbs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; if ( mi [ mb_index ] . mbmi . mode == B_PRED ) fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . as_mode ) ; else fprintf ( mvs , ""xx<S2SV_blank>"" ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%5d:%-5d"" , mi [ mb_index ] . mbmi . mv . as_mv . row / 2 , mi [ mb_index ] . mbmi . mv . as_mv . col / 2 ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; } fprintf ( mvs , ""\\n"" ) ;  mb_index = 0 ;  fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; fprintf ( mvs , ""%3d:%-3d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . row , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . col ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; fclose ( mvs ) ; }","
",1497
418,"buggy line: mb_index ++ ;}cwe id:CWE-119context: void vp8_print_modes_and_motion_vectors ( MODE_INFO * mi , int rows , int cols , int frame ) { int mb_row ; int mb_col ; int mb_index = 0 ; FILE * mvs = fopen ( ""mvs.stt"" , ""a"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . mode ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>mv<S2SV_blank>ref<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . ref_frame ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""UV<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . uv_mode ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; }  fprintf ( mvs , ""\\n"" ) ;  mb_index = 0 ; fprintf ( mvs , ""Mbs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; if ( mi [ mb_index ] . mbmi . mode == B_PRED ) fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . as_mode ) ; else fprintf ( mvs , ""xx<S2SV_blank>"" ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%5d:%-5d"" , mi [ mb_index ] . mbmi . mv . as_mv . row / 2 , mi [ mb_index ] . mbmi . mv . as_mv . col / 2 ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; } fprintf ( mvs , ""\\n"" ) ;  mb_index = 0 ;  fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; fprintf ( mvs , ""%3d:%-3d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . row , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . col ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; fclose ( mvs ) ; }","
",1497
419,"buggy line: fprintf ( mvs , ""\\\mb_index = 0 ;cwe id:CWE-119context: void vp8_print_modes_and_motion_vectors ( MODE_INFO * mi , int rows , int cols , int frame ) { int mb_row ; int mb_col ; int mb_index = 0 ; FILE * mvs = fopen ( ""mvs.stt"" , ""a"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . mode ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>mv<S2SV_blank>ref<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . ref_frame ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""UV<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . uv_mode ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; }  fprintf ( mvs , ""\\n"" ) ;  mb_index = 0 ; fprintf ( mvs , ""Mbs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; if ( mi [ mb_index ] . mbmi . mode == B_PRED ) fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . as_mode ) ; else fprintf ( mvs , ""xx<S2SV_blank>"" ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%5d:%-5d"" , mi [ mb_index ] . mbmi . mv . as_mv . row / 2 , mi [ mb_index ] . mbmi . mv . as_mv . col / 2 ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; } fprintf ( mvs , ""\\n"" ) ;  mb_index = 0 ;  fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; fprintf ( mvs , ""%3d:%-3d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . row , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . col ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; fclose ( mvs ) ; }","fprintf ( mvs , ""\\\mb_index = 0 ;",1497
420,"buggy line: mb_index = 0 ;fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\\cwe id:CWE-119context: void vp8_print_modes_and_motion_vectors ( MODE_INFO * mi , int rows , int cols , int frame ) { int mb_row ; int mb_col ; int mb_index = 0 ; FILE * mvs = fopen ( ""mvs.stt"" , ""a"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . mode ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>mv<S2SV_blank>ref<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . ref_frame ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""UV<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . uv_mode ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; }  fprintf ( mvs , ""\\n"" ) ;  mb_index = 0 ; fprintf ( mvs , ""Mbs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; if ( mi [ mb_index ] . mbmi . mode == B_PRED ) fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . as_mode ) ; else fprintf ( mvs , ""xx<S2SV_blank>"" ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%5d:%-5d"" , mi [ mb_index ] . mbmi . mv . as_mv . row / 2 , mi [ mb_index ] . mbmi . mv . as_mv . col / 2 ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; } fprintf ( mvs , ""\\n"" ) ;  mb_index = 0 ;  fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; fprintf ( mvs , ""%3d:%-3d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . row , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . col ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; fclose ( mvs ) ; }","mb_index = 0 ;fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\\",1497
421,"buggy line: Py_ssize_t i ;PyObject * new_memo = PyDict_New ( ) ;cwe id:CWE-190context: static PyObject * _pickle_UnpicklerMemoProxy_copy_impl ( UnpicklerMemoProxyObject * self ) {  Py_ssize_t i ;  PyObject * new_memo = PyDict_New ( ) ; if ( new_memo == NULL ) return NULL ; for ( i = 0 ; i < self -> unpickler -> memo_size ; i ++ ) { int status ; PyObject * key , * value ; value = self -> unpickler -> memo [ i ] ; if ( value == NULL ) continue ; key = PyLong_FromSsize_t ( i ) ; if ( key == NULL ) goto error ; status = PyDict_SetItem ( new_memo , key , value ) ; Py_DECREF ( key ) ; if ( status < 0 ) goto error ; } return new_memo ; error : Py_DECREF ( new_memo ) ; return NULL ; }",size_t i ;PyObject * new_memo = PyDict_New ( ) ;,1498
422,"buggy line: cwe id:CWE-125context: static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,="" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,="" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , ""C,!,%s,+,a,-="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""C,!,%s,[1],+,a,-="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,=,C,!="" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , ""%s,a,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , ""%s,a,&="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,&="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , ""%s,a,^="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,^="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , ""1,a,<<=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , ""1,a,&,C,=,1,a,>>="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , ""1,a,<<,C,|,a,=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,++=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,--=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""+"" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""-"" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , ""%s,a,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , ""%s,x,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , ""%s,y,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ;  if ( data [ 1 ] <= 127 )  op -> jump = addr + data [ 1 ] + op -> size ;  else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;   op -> fail = addr + op -> size ;  _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , ""0x%04x,pc,="" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , ""0x%04x,[2],pc,="" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+="" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+="" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , ""%s,a,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , ""%s,x,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , ""%s,y,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , ""a,%s,=[1]"" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , ""x,%s,=[1]"" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""y,%s,=[1]"" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }",if ( len > 1 ) {,1499
423,"buggy line: if ( data [ 1 ] <= 127 )  op -> jump = addr + data [ 1 ] + op -> size ;else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;op -> fail = addr + op -> size ;_6502_anal_esil_ccall ( op , data [ 0 ] ) ;cwe id:CWE-125context: static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,="" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,="" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , ""C,!,%s,+,a,-="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""C,!,%s,[1],+,a,-="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,=,C,!="" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , ""%s,a,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , ""%s,a,&="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,&="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , ""%s,a,^="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,^="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , ""1,a,<<=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , ""1,a,&,C,=,1,a,>>="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , ""1,a,<<,C,|,a,=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,++=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,--=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""+"" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""-"" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , ""%s,a,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , ""%s,x,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , ""%s,y,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ;  if ( data [ 1 ] <= 127 )  op -> jump = addr + data [ 1 ] + op -> size ;  else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;   op -> fail = addr + op -> size ;  _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , ""0x%04x,pc,="" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , ""0x%04x,[2],pc,="" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+="" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+="" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , ""%s,a,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , ""%s,x,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , ""%s,y,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , ""a,%s,=[1]"" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , ""x,%s,=[1]"" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""y,%s,=[1]"" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }","if ( data [ 1 ] <= 127 ) {op -> jump = addr + data [ 1 ] + op -> size ;}else {op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;}}else {op -> jump = addr ;}op -> fail = addr + op -> size ;_6502_anal_esil_ccall ( op , data [ 0 ] ) ;",1499
424,"buggy line: do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) ,  mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ;cwe id:CWE-416context: int dbd_db_login ( SV * dbh , imp_dbh_t * imp_dbh , char * dbname , char * user , char * password ) { # ifdef dTHR dTHR ; # endif dTHX ; D_imp_xxh ( dbh ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""imp_dbh->connect:<S2SV_blank>dsn<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>pwd<S2SV_blank>=<S2SV_blank>%s\\n"" , dbname ? dbname : ""NULL"" , user ? user : ""NULL"" , password ? password : ""NULL"" ) ; imp_dbh -> stats . auto_reconnects_ok = 0 ; imp_dbh -> stats . auto_reconnects_failed = 0 ; imp_dbh -> bind_type_guessing = FALSE ; imp_dbh -> bind_comment_placeholders = FALSE ; imp_dbh -> has_transactions = TRUE ; imp_dbh -> auto_reconnect = FALSE ; # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_dbh -> enable_utf8 = FALSE ; # endif if ( ! my_login ( aTHX_ dbh , imp_dbh ) ) {  do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) ,  mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; return FALSE ; } DBIc_ACTIVE_on ( imp_dbh ) ; DBIc_on ( imp_dbh , DBIcf_IMPSET ) ; return TRUE ; }","if ( imp_dbh -> pmysql ) do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ;",1500
425,"buggy line: if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) )   pthread_mutex_unlock ( & slot_lock ) ;BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ;}cwe id:CWE-284context: void btsock_rfc_signaled ( UNUSED_ATTR int fd , int flags , uint32_t user_id ) { pthread_mutex_lock ( & slot_lock ) ; rfc_slot_t * slot = find_rfc_slot_by_id ( user_id ) ; if ( ! slot ) goto out ; bool need_close = false ; if ( flags & SOCK_THREAD_FD_RD && ! slot -> f . server ) { if ( slot -> f . connected ) { int size = 0 ;  if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) )   pthread_mutex_unlock ( & slot_lock ) ;   BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ;  } else { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>signaled<S2SV_blank>for<S2SV_blank>read<S2SV_blank>while<S2SV_blank>disconnected,<S2SV_blank>slot:<S2SV_blank>%d,<S2SV_blank>channel:<S2SV_blank>%d"" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( flags & SOCK_THREAD_FD_WR ) { if ( ! slot -> f . connected || ! flush_incoming_que_on_wr_signal ( slot ) ) { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>signaled<S2SV_blank>for<S2SV_blank>write<S2SV_blank>while<S2SV_blank>disconnected<S2SV_blank>(or<S2SV_blank>write<S2SV_blank>failure),<S2SV_blank>slot:<S2SV_blank>%d,<S2SV_blank>channel:<S2SV_blank>%d"" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ;  if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size )  cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; }","if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( TEMP_FAILURE_RETRY ( ioctl ( slot -> fd , FIONREAD , & size ) ) {BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ;}}",1501
426,"buggy line: if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) {if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size )  cleanup_rfc_slot ( slot ) ;cwe id:CWE-284context: void btsock_rfc_signaled ( UNUSED_ATTR int fd , int flags , uint32_t user_id ) { pthread_mutex_lock ( & slot_lock ) ; rfc_slot_t * slot = find_rfc_slot_by_id ( user_id ) ; if ( ! slot ) goto out ; bool need_close = false ; if ( flags & SOCK_THREAD_FD_RD && ! slot -> f . server ) { if ( slot -> f . connected ) { int size = 0 ;  if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) )   pthread_mutex_unlock ( & slot_lock ) ;   BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ;  } else { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>signaled<S2SV_blank>for<S2SV_blank>read<S2SV_blank>while<S2SV_blank>disconnected,<S2SV_blank>slot:<S2SV_blank>%d,<S2SV_blank>channel:<S2SV_blank>%d"" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( flags & SOCK_THREAD_FD_WR ) { if ( ! slot -> f . connected || ! flush_incoming_que_on_wr_signal ( slot ) ) { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>signaled<S2SV_blank>for<S2SV_blank>write<S2SV_blank>while<S2SV_blank>disconnected<S2SV_blank>(or<S2SV_blank>write<S2SV_blank>failure),<S2SV_blank>slot:<S2SV_blank>%d,<S2SV_blank>channel:<S2SV_blank>%d"" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ;  if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size )  cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; }","if ( need_close || TEMP_FAILURE_RETRY ( ( flags & SOCK_THREAD_FD_EXCEPTION ) ) {if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) ) != 0 || ! size ) cleanup_rfc_slot ( slot ) ;",1501
427,"buggy line: struct ieee_802_11_phdr phdr ;col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PPI"" ) ;cwe id:CWE-20context: static void dissect_ppi ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) { proto_tree * ppi_tree = NULL , * ppi_flags_tree = NULL , * seg_tree = NULL , * ampdu_tree = NULL ; proto_tree * agg_tree = NULL ; proto_item * ti = NULL ; tvbuff_t * next_tvb ; int offset = 0 ; guint version , flags ; gint tot_len , data_len ; guint data_type ; guint32 dlt ; guint32 n_ext_flags = 0 ; guint32 ampdu_id = 0 ; fragment_head * fd_head = NULL ; fragment_item * ft_fdh = NULL ; gint mpdu_count = 0 ; gchar * mpdu_str ; gboolean first_mpdu = TRUE ; guint last_frame = 0 ; gint len_remain , ampdu_len = 0 ;  struct ieee_802_11_phdr phdr ;  col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PPI"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; version = tvb_get_guint8 ( tvb , offset ) ; flags = tvb_get_guint8 ( tvb , offset + 1 ) ; tot_len = tvb_get_letohs ( tvb , offset + 2 ) ; dlt = tvb_get_letohl ( tvb , offset + 4 ) ; col_add_fstr ( pinfo -> cinfo , COL_INFO , ""PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes"" , version , tot_len ) ; if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_ppi , tvb , 0 , tot_len , ""PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes"" , version , tot_len ) ; ppi_tree = proto_item_add_subtree ( ti , ett_ppi_pph ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_version , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ti = proto_tree_add_item ( ppi_tree , hf_ppi_head_flags , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; ppi_flags_tree = proto_item_add_subtree ( ti , ett_ppi_flags ) ; proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_alignment , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_reserved , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_len , tvb , offset + 2 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_dlt , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ) ; } tot_len -= PPI_V0_HEADER_LEN ; offset += 8 ; memset ( & phdr , 0 , sizeof ( phdr ) ) ; phdr . fcs_len = - 1 ; phdr . decrypted = FALSE ; phdr . datapad = FALSE ; phdr . phy = PHDR_802_11_PHY_UNKNOWN ; phdr . presence_flags = 0 ; while ( tot_len > 0 ) { data_type = tvb_get_letohs ( tvb , offset ) ; data_len = tvb_get_letohs ( tvb , offset + 2 ) + 4 ; tot_len -= data_len ; switch ( data_type ) { case PPI_80211_COMMON : dissect_80211_common ( tvb , pinfo , ppi_tree , offset , data_len , & phdr ) ; break ; case PPI_80211N_MAC : dissect_80211n_mac ( tvb , pinfo , ppi_tree , offset , data_len , TRUE , & n_ext_flags , & ampdu_id , & phdr ) ; break ; case PPI_80211N_MAC_PHY : dissect_80211n_mac_phy ( tvb , pinfo , ppi_tree , offset , data_len , & n_ext_flags , & ampdu_id , & phdr ) ; break ; case PPI_SPECTRUM_MAP : ADD_BASIC_TAG ( hf_spectrum_map ) ; break ; case PPI_PROCESS_INFO : ADD_BASIC_TAG ( hf_process_info ) ; break ; case PPI_CAPTURE_INFO : ADD_BASIC_TAG ( hf_capture_info ) ; break ; case PPI_AGGREGATION_EXTENSION : dissect_aggregation_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; break ; case PPI_8023_EXTENSION : dissect_8023_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; break ; case PPI_GPS_INFO : if ( ppi_gps_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_gps , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_gps_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_VECTOR_INFO : if ( ppi_vector_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_vector , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_vector_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_SENSOR_INFO : if ( ppi_sensor_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_harris , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_sensor_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_ANTENNA_INFO : if ( ppi_antenna_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_antenna , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_antenna_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case FNET_PRIVATE : if ( ppi_fnet_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_fnet , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_fnet_handle , next_tvb , pinfo , ppi_tree ) ; } break ; default : proto_tree_add_item ( ppi_tree , hf_ppi_reserved , tvb , offset , data_len , ENC_NA ) ; } offset += data_len ; if ( IS_PPI_FLAG_ALIGN ( flags ) ) { offset += PADDING4 ( offset ) ; } } if ( ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE ( n_ext_flags ) ) { len_remain = tvb_captured_length_remaining ( tvb , offset ) ; # if 0 if ( DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { pad_len = PADDING4 ( len_remain ) ; } # endif pinfo -> fragmented = TRUE ; fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; while ( fd_head ) { ampdu_len += fd_head -> len + PADDING4 ( fd_head -> len ) + 4 ; fd_head = fd_head -> next ; } if ( ampdu_len > AGGREGATE_MAX ) { if ( tree ) { proto_tree_add_expert_format ( ppi_tree , pinfo , & ei_ppi_invalid_length , tvb , offset , - 1 , ""Aggregate<S2SV_blank>length<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>(%u)"" , AGGREGATE_MAX ) ; THROW ( ReportedBoundsError ) ; } else { return ; } } fragment_add_seq_next ( & ampdu_reassembly_table , tvb , offset , pinfo , ampdu_id , NULL , len_remain , TRUE ) ; pinfo -> fragmented = TRUE ; fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; if ( fd_head && tree ) { ft_fdh = fd_head ; seg_tree = proto_tree_add_subtree_format ( ppi_tree , tvb , offset , - 1 , ett_ampdu_segments , & ti , ""A-MPDU<S2SV_blank>(%u<S2SV_blank>bytes<S2SV_blank>w/hdrs):"" , ampdu_len ) ; PROTO_ITEM_SET_GENERATED ( ti ) ; while ( ft_fdh ) { if ( ft_fdh -> tvb_data && ft_fdh -> len ) { last_frame = ft_fdh -> frame ; if ( ! first_mpdu ) proto_item_append_text ( ti , "","" ) ; first_mpdu = FALSE ; proto_item_append_text ( ti , ""<S2SV_blank>#%u(%u)"" , ft_fdh -> frame , ft_fdh -> len ) ; proto_tree_add_uint_format ( seg_tree , hf_ampdu_segment , tvb , 0 , 0 , last_frame , ""Frame:<S2SV_blank>%u<S2SV_blank>(%u<S2SV_blank>byte%s)"" , last_frame , ft_fdh -> len , plurality ( ft_fdh -> len , """" , ""s"" ) ) ; } ft_fdh = ft_fdh -> next ; } if ( last_frame && last_frame != pinfo -> fd -> num ) proto_tree_add_uint ( seg_tree , hf_ampdu_reassembled_in , tvb , 0 , 0 , last_frame ) ; } if ( fd_head && ! DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_get_id_by_filter_name ( ""wlan_aggregate"" ) , tvb , 0 , tot_len , ""IEEE<S2SV_blank>802.11<S2SV_blank>Aggregate<S2SV_blank>MPDU"" ) ; agg_tree = proto_item_add_subtree ( ti , ett_ampdu ) ; } while ( fd_head ) { if ( fd_head -> tvb_data && fd_head -> len ) { mpdu_count ++ ; mpdu_str = wmem_strdup_printf ( wmem_packet_scope ( ) , ""MPDU<S2SV_blank>#%d"" , mpdu_count ) ; next_tvb = tvb_new_chain ( tvb , fd_head -> tvb_data ) ; add_new_data_source ( pinfo , next_tvb , mpdu_str ) ; ampdu_tree = proto_tree_add_subtree ( agg_tree , next_tvb , 0 , - 1 , ett_ampdu_segment , NULL , mpdu_str ) ; call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , ampdu_tree , & phdr ) ; } fd_head = fd_head -> next ; } proto_tree_add_uint ( seg_tree , hf_ampdu_count , tvb , 0 , 0 , mpdu_count ) ; pinfo -> fragmented = FALSE ; } else { next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""IEEE<S2SV_blank>802.11n"" ) ; col_set_str ( pinfo -> cinfo , COL_INFO , ""Unreassembled<S2SV_blank>A-MPDU<S2SV_blank>data"" ) ; call_dissector ( data_handle , next_tvb , pinfo , tree ) ; } return ; } next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; if ( dlt == 105 ) { call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , tree , & phdr ) ; } else {  dissector_try_uint ( wtap_encap_dissector_table ,   wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ;  } }","struct ieee_802_11_phdr phdr ;int wtap_encap ;struct eth_phdr eth ;void * phdrp ;col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PPI"" ) ;",1502
428,"buggy line: next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ;call_dissector ( ppi_gps_handle , next_tvb , pinfo , ppi_tree ) ;}break ;case PPI_VECTOR_INFO : if ( ppi_vector_handle == NULL ) {proto_tree_add_item ( ppi_tree , hf_ppi_vector , tvb , offset , data_len , ENC_NA ) ;}else {next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ;call_dissector ( ppi_vector_handle , next_tvb , pinfo , ppi_tree ) ;}case PPI_SENSOR_INFO : if ( ppi_sensor_handle == NULL ) {proto_tree_add_item ( ppi_tree , hf_ppi_harris , tvb , offset , data_len , ENC_NA ) ;}else {next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ;call_dissector ( ppi_sensor_handle , next_tvb , pinfo , ppi_tree ) ;}case PPI_ANTENNA_INFO : if ( ppi_antenna_handle == NULL ) {proto_tree_add_item ( ppi_tree , hf_ppi_antenna , tvb , offset , data_len , ENC_NA ) ;}else {next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ;call_dissector ( ppi_antenna_handle , next_tvb , pinfo , ppi_tree ) ;}break ;case FNET_PRIVATE : if ( ppi_fnet_handle == NULL ) {proto_tree_add_item ( ppi_tree , hf_ppi_fnet , tvb , offset , data_len , ENC_NA ) ;}else {next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ;call_dissector ( ppi_fnet_handle , next_tvb , pinfo , ppi_tree ) ;}break ;default : proto_tree_add_item ( ppi_tree , hf_ppi_reserved , tvb , offset , data_len , ENC_NA ) ;}offset += data_len ;if ( IS_PPI_FLAG_ALIGN ( flags ) ) {offset += PADDING4 ( offset ) ;}}if ( ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE ( n_ext_flags ) ) {len_remain = tvb_captured_length_remaining ( tvb , offset ) ;# if 0 if ( DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) {pad_len = PADDING4 ( len_remain ) ;# endif pinfo -> fragmented = TRUE ;fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ;while ( fd_head ) {ampdu_len += fd_head -> len + PADDING4 ( fd_head -> len ) + 4 ;fd_head = fd_head -> next ;if ( ampdu_len > AGGREGATE_MAX ) {if ( tree ) {proto_tree_add_expert_format ( ppi_tree , pinfo , & ei_ppi_invalid_length , tvb , offset , - 1 , ""Aggregate<S2SV_blank>length<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>(%u)"" , AGGREGATE_MAX ) ;THROW ( ReportedBoundsError ) ;}else {return ;}}fragment_add_seq_next ( & ampdu_reassembly_table , tvb , offset , pinfo , ampdu_id , NULL , len_remain , TRUE ) ;pinfo -> fragmented = TRUE ;fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ;if ( fd_head && tree ) {ft_fdh = fd_head ;seg_tree = proto_tree_add_subtree_format ( ppi_tree , tvb , offset , - 1 , ett_ampdu_segments , & ti , ""A-MPDU<S2SV_blank>(%u<S2SV_blank>bytes<S2SV_blank>w/hdrs):"" , ampdu_len ) ;PROTO_ITEM_SET_GENERATED ( ti ) ;while ( ft_fdh ) {if ( ft_fdh -> tvb_data && ft_fdh -> len ) {last_frame = ft_fdh -> frame ;if ( ! first_mpdu ) proto_item_append_text ( ti , "","" ) ;first_mpdu = FALSE ;proto_item_append_text ( ti , ""<S2SV_blank>#%u(%u)"" , ft_fdh -> frame , ft_fdh -> len ) ;proto_tree_add_uint_format ( seg_tree , hf_ampdu_segment , tvb , 0 , 0 , last_frame , ""Frame:<S2SV_blank>%u<S2SV_blank>(%u<S2SV_blank>byte%s)"" , last_frame , ft_fdh -> len , plurality ( ft_fdh -> len , """" , ""s"" ) ) ;}ft_fdh = ft_fdh -> next ;}if ( last_frame && last_frame != pinfo -> fd -> num ) proto_tree_add_uint ( seg_tree , hf_ampdu_reassembled_in , tvb , 0 , 0 , last_frame ) ;}if ( fd_head && ! DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) {if ( tree ) {ti = proto_tree_add_protocol_format ( tree , proto_get_id_by_filter_name ( ""wlan_aggregate"" ) , tvb , 0 , tot_len , ""IEEE<S2SV_blank>802.11<S2SV_blank>Aggregate<S2SV_blank>MPDU"" ) ;agg_tree = proto_item_add_subtree ( ti , ett_ampdu ) ;}while ( fd_head ) {if ( fd_head -> tvb_data && fd_head -> len ) {mpdu_count ++ ;mpdu_str = wmem_strdup_printf ( wmem_packet_scope ( ) , ""MPDU<S2SV_blank>#%d"" , mpdu_count ) ;next_tvb = tvb_new_chain ( tvb , fd_head -> tvb_data ) ;add_new_data_source ( pinfo , next_tvb , mpdu_str ) ;ampdu_tree = proto_tree_add_subtree ( agg_tree , next_tvb , 0 , - 1 , ett_ampdu_segment , NULL , mpdu_str ) ;call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , ampdu_tree , & phdr ) ;}fd_head = fd_head -> next ;}proto_tree_add_uint ( seg_tree , hf_ampdu_count , tvb , 0 , 0 , mpdu_count ) ;pinfo -> fragmented = FALSE ;}else {next_tvb = tvb_new_subset_remaining ( tvb , offset ) ;col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""IEEE<S2SV_blank>802.11n"" ) ;col_set_str ( pinfo -> cinfo , COL_INFO , ""Unreassembled<S2SV_blank>A-MPDU<S2SV_blank>data"" ) ;call_dissector ( data_handle , next_tvb , pinfo , tree ) ;}return ;}next_tvb = tvb_new_subset_remaining ( tvb , offset ) ;if ( dlt == 105 ) {call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , tree , & phdr ) ;}else {dissector_try_uint ( wtap_encap_dissector_table ,   wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ;}cwe id:CWE-20context: static void dissect_ppi ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) { proto_tree * ppi_tree = NULL , * ppi_flags_tree = NULL , * seg_tree = NULL , * ampdu_tree = NULL ; proto_tree * agg_tree = NULL ; proto_item * ti = NULL ; tvbuff_t * next_tvb ; int offset = 0 ; guint version , flags ; gint tot_len , data_len ; guint data_type ; guint32 dlt ; guint32 n_ext_flags = 0 ; guint32 ampdu_id = 0 ; fragment_head * fd_head = NULL ; fragment_item * ft_fdh = NULL ; gint mpdu_count = 0 ; gchar * mpdu_str ; gboolean first_mpdu = TRUE ; guint last_frame = 0 ; gint len_remain , ampdu_len = 0 ;  struct ieee_802_11_phdr phdr ;  col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PPI"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; version = tvb_get_guint8 ( tvb , offset ) ; flags = tvb_get_guint8 ( tvb , offset + 1 ) ; tot_len = tvb_get_letohs ( tvb , offset + 2 ) ; dlt = tvb_get_letohl ( tvb , offset + 4 ) ; col_add_fstr ( pinfo -> cinfo , COL_INFO , ""PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes"" , version , tot_len ) ; if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_ppi , tvb , 0 , tot_len , ""PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes"" , version , tot_len ) ; ppi_tree = proto_item_add_subtree ( ti , ett_ppi_pph ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_version , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ti = proto_tree_add_item ( ppi_tree , hf_ppi_head_flags , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; ppi_flags_tree = proto_item_add_subtree ( ti , ett_ppi_flags ) ; proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_alignment , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_reserved , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_len , tvb , offset + 2 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_dlt , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ) ; } tot_len -= PPI_V0_HEADER_LEN ; offset += 8 ; memset ( & phdr , 0 , sizeof ( phdr ) ) ; phdr . fcs_len = - 1 ; phdr . decrypted = FALSE ; phdr . datapad = FALSE ; phdr . phy = PHDR_802_11_PHY_UNKNOWN ; phdr . presence_flags = 0 ; while ( tot_len > 0 ) { data_type = tvb_get_letohs ( tvb , offset ) ; data_len = tvb_get_letohs ( tvb , offset + 2 ) + 4 ; tot_len -= data_len ; switch ( data_type ) { case PPI_80211_COMMON : dissect_80211_common ( tvb , pinfo , ppi_tree , offset , data_len , & phdr ) ; break ; case PPI_80211N_MAC : dissect_80211n_mac ( tvb , pinfo , ppi_tree , offset , data_len , TRUE , & n_ext_flags , & ampdu_id , & phdr ) ; break ; case PPI_80211N_MAC_PHY : dissect_80211n_mac_phy ( tvb , pinfo , ppi_tree , offset , data_len , & n_ext_flags , & ampdu_id , & phdr ) ; break ; case PPI_SPECTRUM_MAP : ADD_BASIC_TAG ( hf_spectrum_map ) ; break ; case PPI_PROCESS_INFO : ADD_BASIC_TAG ( hf_process_info ) ; break ; case PPI_CAPTURE_INFO : ADD_BASIC_TAG ( hf_capture_info ) ; break ; case PPI_AGGREGATION_EXTENSION : dissect_aggregation_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; break ; case PPI_8023_EXTENSION : dissect_8023_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; break ; case PPI_GPS_INFO : if ( ppi_gps_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_gps , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_gps_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_VECTOR_INFO : if ( ppi_vector_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_vector , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_vector_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_SENSOR_INFO : if ( ppi_sensor_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_harris , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_sensor_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_ANTENNA_INFO : if ( ppi_antenna_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_antenna , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_antenna_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case FNET_PRIVATE : if ( ppi_fnet_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_fnet , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_fnet_handle , next_tvb , pinfo , ppi_tree ) ; } break ; default : proto_tree_add_item ( ppi_tree , hf_ppi_reserved , tvb , offset , data_len , ENC_NA ) ; } offset += data_len ; if ( IS_PPI_FLAG_ALIGN ( flags ) ) { offset += PADDING4 ( offset ) ; } } if ( ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE ( n_ext_flags ) ) { len_remain = tvb_captured_length_remaining ( tvb , offset ) ; # if 0 if ( DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { pad_len = PADDING4 ( len_remain ) ; } # endif pinfo -> fragmented = TRUE ; fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; while ( fd_head ) { ampdu_len += fd_head -> len + PADDING4 ( fd_head -> len ) + 4 ; fd_head = fd_head -> next ; } if ( ampdu_len > AGGREGATE_MAX ) { if ( tree ) { proto_tree_add_expert_format ( ppi_tree , pinfo , & ei_ppi_invalid_length , tvb , offset , - 1 , ""Aggregate<S2SV_blank>length<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>(%u)"" , AGGREGATE_MAX ) ; THROW ( ReportedBoundsError ) ; } else { return ; } } fragment_add_seq_next ( & ampdu_reassembly_table , tvb , offset , pinfo , ampdu_id , NULL , len_remain , TRUE ) ; pinfo -> fragmented = TRUE ; fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; if ( fd_head && tree ) { ft_fdh = fd_head ; seg_tree = proto_tree_add_subtree_format ( ppi_tree , tvb , offset , - 1 , ett_ampdu_segments , & ti , ""A-MPDU<S2SV_blank>(%u<S2SV_blank>bytes<S2SV_blank>w/hdrs):"" , ampdu_len ) ; PROTO_ITEM_SET_GENERATED ( ti ) ; while ( ft_fdh ) { if ( ft_fdh -> tvb_data && ft_fdh -> len ) { last_frame = ft_fdh -> frame ; if ( ! first_mpdu ) proto_item_append_text ( ti , "","" ) ; first_mpdu = FALSE ; proto_item_append_text ( ti , ""<S2SV_blank>#%u(%u)"" , ft_fdh -> frame , ft_fdh -> len ) ; proto_tree_add_uint_format ( seg_tree , hf_ampdu_segment , tvb , 0 , 0 , last_frame , ""Frame:<S2SV_blank>%u<S2SV_blank>(%u<S2SV_blank>byte%s)"" , last_frame , ft_fdh -> len , plurality ( ft_fdh -> len , """" , ""s"" ) ) ; } ft_fdh = ft_fdh -> next ; } if ( last_frame && last_frame != pinfo -> fd -> num ) proto_tree_add_uint ( seg_tree , hf_ampdu_reassembled_in , tvb , 0 , 0 , last_frame ) ; } if ( fd_head && ! DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_get_id_by_filter_name ( ""wlan_aggregate"" ) , tvb , 0 , tot_len , ""IEEE<S2SV_blank>802.11<S2SV_blank>Aggregate<S2SV_blank>MPDU"" ) ; agg_tree = proto_item_add_subtree ( ti , ett_ampdu ) ; } while ( fd_head ) { if ( fd_head -> tvb_data && fd_head -> len ) { mpdu_count ++ ; mpdu_str = wmem_strdup_printf ( wmem_packet_scope ( ) , ""MPDU<S2SV_blank>#%d"" , mpdu_count ) ; next_tvb = tvb_new_chain ( tvb , fd_head -> tvb_data ) ; add_new_data_source ( pinfo , next_tvb , mpdu_str ) ; ampdu_tree = proto_tree_add_subtree ( agg_tree , next_tvb , 0 , - 1 , ett_ampdu_segment , NULL , mpdu_str ) ; call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , ampdu_tree , & phdr ) ; } fd_head = fd_head -> next ; } proto_tree_add_uint ( seg_tree , hf_ampdu_count , tvb , 0 , 0 , mpdu_count ) ; pinfo -> fragmented = FALSE ; } else { next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""IEEE<S2SV_blank>802.11n"" ) ; col_set_str ( pinfo -> cinfo , COL_INFO , ""Unreassembled<S2SV_blank>A-MPDU<S2SV_blank>data"" ) ; call_dissector ( data_handle , next_tvb , pinfo , tree ) ; } return ; } next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; if ( dlt == 105 ) { call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , tree , & phdr ) ; } else {  dissector_try_uint ( wtap_encap_dissector_table ,   wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ;  } }","wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ;switch ( wtap_encap ) {case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ;phdrp = & eth ;default : phdrp = NULL ;dissector_try_uint_new ( wtap_encap_dissector_table , wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree , TRUE , phdrp ) ;",1502
429,"buggy line: sh = s_malloc ( hdrlen + initlen + 1 ) ;if ( sh == NULL ) return NULL ;cwe id:CWE-190context: sds sdsnewlen ( const void * init , size_t initlen ) { void * sh ; sds s ; char type = sdsReqType ( initlen ) ; if ( type == SDS_TYPE_5 && initlen == 0 ) type = SDS_TYPE_8 ; int hdrlen = sdsHdrSize ( type ) ; unsigned char * fp ;  sh = s_malloc ( hdrlen + initlen + 1 ) ;  if ( sh == NULL ) return NULL ; if ( init == SDS_NOINIT ) init = NULL ; else if ( ! init ) memset ( sh , 0 , hdrlen + initlen + 1 ) ; s = ( char * ) sh + hdrlen ; fp = ( ( unsigned char * ) s ) - 1 ; switch ( type ) { case SDS_TYPE_5 : { * fp = type | ( initlen << SDS_TYPE_BITS ) ; break ; } case SDS_TYPE_8 : { SDS_HDR_VAR ( 8 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_16 : { SDS_HDR_VAR ( 16 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_32 : { SDS_HDR_VAR ( 32 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_64 : { SDS_HDR_VAR ( 64 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } } if ( initlen && init ) memcpy ( s , init , initlen ) ; s [ initlen ] = '\\0' ; return s ; }",assert ( initlen + hdrlen + 1 > initlen ) ;sh = s_malloc ( hdrlen + initlen + 1 ) ;if ( sh == NULL ) return NULL ;,1503
430,"buggy line: static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) {cwe id:CWE-787context:  static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ;  UINT32 tempWidth ;  tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ;  for ( y = 0 ; y < context -> height ; y ++ )  { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; }  } ","static BOOL nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , UINT32 scanline ) {",1504
431,"buggy line: UINT32 tempWidth ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;for ( y = 0 ;y ++ )  {cwe id:CWE-787context:  static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ;  UINT32 tempWidth ;  tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ;  for ( y = 0 ; y < context -> height ; y ++ )  { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; }  } ","UINT32 tempWidth ;if ( ! context || data || ( scanline == 0 ) ) return FALSE ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ;if ( rw < scanline * 2 ) return FALSE ;for ( y = 0 ;y ++ ) {",1504
432,"buggy line: cwe id:CWE-787context:  static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ;  UINT32 tempWidth ;  tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ;  for ( y = 0 ; y < context -> height ; y ++ )  { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; }  } ",return TRUE ;,1504
433,"buggy line: }cwe id:CWE-787context:  static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ;  UINT32 tempWidth ;  tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ;  for ( y = 0 ; y < context -> height ; y ++ )  { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; }  } ",},1504
434,"buggy line: while ( offset < end_offset )  offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ;return offset ;}cwe id:CWE-399context: static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) { guint32 size ; int end_offset ; if ( di -> conformant_run ) return offset ; offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ; end_offset = offset + ( size * 2 ) ; if ( end_offset < offset ) { end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ; }  while ( offset < end_offset )  offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ;  return offset ;  }","while ( offset > 0 && offset < end_offset ) {offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ;}return offset ;}",1505
435,"buggy line: case '(' : if ( top - op_stack > nr_parens )  return ERR_PTR ( - EINVAL ) ;* ( ++ top ) = invert ;cwe id:CWE-401context: static struct prog_entry * predicate_parse ( const char * str , int nr_parens , int nr_preds , parse_pred_fn parse_pred , void * data , struct filter_parse_error * pe ) { struct prog_entry * prog_stack ; struct prog_entry * prog ; const char * ptr = str ; char * inverts = NULL ; int * op_stack ; int * top ; int invert = 0 ; int ret = - ENOMEM ; int len ; int N = 0 ; int i ; nr_preds += 2 ; op_stack = kmalloc_array ( nr_parens , sizeof ( * op_stack ) , GFP_KERNEL ) ; if ( ! op_stack ) return ERR_PTR ( - ENOMEM ) ; prog_stack = kcalloc ( nr_preds , sizeof ( * prog_stack ) , GFP_KERNEL ) ; if ( ! prog_stack ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } inverts = kmalloc_array ( nr_preds , sizeof ( * inverts ) , GFP_KERNEL ) ; if ( ! inverts ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } top = op_stack ; prog = prog_stack ; * top = 0 ; while ( * ptr ) { const char * next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case '(' : if ( top - op_stack > nr_parens )  return ERR_PTR ( - EINVAL ) ;  * ( ++ top ) = invert ; continue ; case '!' : if ( ! is_not ( next ) ) break ; invert = ! invert ; continue ; } if ( N >= nr_preds ) { parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } inverts [ N ] = invert ; prog [ N ] . target = N - 1 ; len = parse_pred ( next , data , ptr - str , pe , & prog [ N ] . pred ) ; if ( len < 0 ) { ret = len ; goto out_free ; } ptr = next + len ; N ++ ; ret = - 1 ; while ( 1 ) { next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case ')' : case '\\0' : break ; case '&' : case '|' : if ( next [ 1 ] == next [ 0 ] ) { ptr ++ ; break ; } default : parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } invert = * top & INVERT ; if ( * top & PROCESS_AND ) { update_preds ( prog , N - 1 , invert ) ; * top &= ~ PROCESS_AND ; } if ( * next == '&' ) { * top |= PROCESS_AND ; break ; } if ( * top & PROCESS_OR ) { update_preds ( prog , N - 1 , ! invert ) ; * top &= ~ PROCESS_OR ; } if ( * next == '|' ) { * top |= PROCESS_OR ; break ; } if ( ! * next ) goto out ; if ( top == op_stack ) { ret = - 1 ; parse_error ( pe , FILT_ERR_TOO_MANY_CLOSE , ptr - str ) ; goto out_free ; } top -- ; } } out : if ( top != op_stack ) { parse_error ( pe , FILT_ERR_TOO_MANY_OPEN , ptr - str ) ; goto out_free ; } if ( ! N ) { ret = - EINVAL ; parse_error ( pe , FILT_ERR_NO_FILTER , ptr - str ) ; goto out_free ; } prog [ N ] . pred = NULL ; prog [ N ] . target = 1 ; prog [ N + 1 ] . pred = NULL ; prog [ N + 1 ] . target = 0 ; prog [ N - 1 ] . target = N ; prog [ N - 1 ] . when_to_branch = false ; for ( i = N - 1 ; i -- ; ) { int target = prog [ i ] . target ; if ( prog [ i ] . when_to_branch == prog [ target ] . when_to_branch ) prog [ i ] . target = prog [ target ] . target ; } for ( i = 0 ; i < N ; i ++ ) { invert = inverts [ i ] ^ prog [ i ] . when_to_branch ; prog [ i ] . when_to_branch = invert ; if ( WARN_ON ( prog [ i ] . target <= i ) ) { ret = - EINVAL ; goto out_free ; } } kfree ( op_stack ) ; kfree ( inverts ) ; return prog ; out_free : kfree ( op_stack ) ; kfree ( inverts ) ; if ( prog_stack ) { for ( i = 0 ; prog_stack [ i ] . pred ; i ++ ) kfree ( prog_stack [ i ] . pred ) ; kfree ( prog_stack ) ; } return ERR_PTR ( ret ) ; }",case '(' : if ( top - op_stack > nr_parens ) {ret = - EINVAL ;goto out_free ;}* ( ++ top ) = invert ;,1506
436,"buggy line: const RATE_CONTROL * rc = & cpi -> rc ;int target ;target = ( ( cpi -> oxcf . starting_buffer_level / 2 ) > INT_MAX )   ? INT_MAX : ( int ) ( cpi -> oxcf . starting_buffer_level / 2 ) ;}const int initial_boost = 32 ;int kf_boost = MAX ( initial_boost , ( int ) ( 2 * cpi -> output_framerate - 16 ) ) ;if ( rc -> frames_since_key < cpi -> output_framerate / 2 ) {kf_boost = ( int ) ( kf_boost * rc -> frames_since_key /  ( cpi -> output_framerate / 2 ) ) ;}target = ( ( 16 + kf_boost ) * rc -> av_per_frame_bandwidth ) >> 4 ;}cwe id:CWE-119context: static int calc_iframe_target_size_one_pass_cbr ( const VP9_COMP * cpi ) {  const RATE_CONTROL * rc = & cpi -> rc ;  int target ; if ( cpi -> common . current_video_frame == 0 ) {  target = ( ( cpi -> oxcf . starting_buffer_level / 2 ) > INT_MAX )   ? INT_MAX : ( int ) ( cpi -> oxcf . starting_buffer_level / 2 ) ;  } else { const int initial_boost = 32 ;  int kf_boost = MAX ( initial_boost , ( int ) ( 2 * cpi -> output_framerate - 16 ) ) ;   if ( rc -> frames_since_key < cpi -> output_framerate / 2 ) {  kf_boost = ( int ) ( kf_boost * rc -> frames_since_key /  ( cpi -> output_framerate / 2 ) ) ;  }  target = ( ( 16 + kf_boost ) * rc -> av_per_frame_bandwidth ) >> 4 ;  } return vp9_rc_clamp_iframe_target_size ( cpi , target ) ; }","const RATE_CONTROL * rc = & cpi -> rc ;const VP9EncoderConfig * oxcf = & cpi -> oxcf ;const SVC * const svc = & cpi -> svc ;int target ;target = ( ( rc -> starting_buffer_level / 2 ) > INT_MAX ) ? INT_MAX : ( int ) ( rc -> starting_buffer_level / 2 ) ;}int kf_boost = 32 ;double framerate = cpi -> framerate ;if ( svc -> number_temporal_layers > 1 && oxcf -> rc_mode == VPX_CBR ) {const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ;const LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ;framerate = lc -> framerate ;}kf_boost = MAX ( kf_boost , ( int ) ( 2 * framerate - 16 ) ) ;if ( rc -> frames_since_key < framerate / 2 ) {kf_boost = ( int ) ( kf_boost * rc -> frames_since_key / ( framerate / 2 ) ) ;}target = ( ( 16 + kf_boost ) * rc -> avg_frame_bandwidth ) >> 4 ;}",1507
437,buggy line: update_db_bp_intercept ( vcpu ) ;}cwe id:CWE-399context: static void enable_nmi_window ( struct kvm_vcpu * vcpu ) { struct vcpu_svm * svm = to_svm ( vcpu ) ; if ( ( svm -> vcpu . arch . hflags & ( HF_NMI_MASK | HF_IRET_MASK ) ) == HF_NMI_MASK ) return ; svm -> nmi_singlestep = true ; svm -> vmcb -> save . rflags |= ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ;  update_db_bp_intercept ( vcpu ) ;  },},1508
438,"buggy line: static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data )  {int ret ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 ,  indx , data , size , 100 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\return ret ;}cwe id:CWE-119context:  static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data )  {  int ret ;  ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 ,  indx , data , size , 100 ) ;  if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\n"" , __func__ , ret ) ;  return ret ;  }","static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , const void * data ) {u8 * buf ;int ret ;buf = kmemdup ( data , size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , indx , buf , size , 100 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\kfree ( buf ) ;return ret ;}",1509
439,"buggy line: static TX_MODE read_tx_mode ( vp9_reader * r ) {TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ;if ( tx_mode == ALLOW_32X32 )  tx_mode += vp9_read_bit ( r ) ;return tx_mode ;cwe id:CWE-119context:  static TX_MODE read_tx_mode ( vp9_reader * r ) {   TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ;  if ( tx_mode == ALLOW_32X32 )  tx_mode += vp9_read_bit ( r ) ;  return tx_mode ; }","static TX_MODE read_tx_mode ( vpx_reader * r ) {TX_MODE tx_mode = vpx_read_literal ( r , 2 ) ;if ( tx_mode == ALLOW_32X32 ) tx_mode += vpx_read_bit ( r ) ;return tx_mode ;",1510
440,"buggy line: register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ;ND_PRINT ( ( ndo , ""\\\cwe id:CWE-125context: static int ospf6_decode_v3 ( netdissect_options * ndo , register const struct ospf6hdr * op , register const u_char * dataend ) { register const rtrid_t * ap ; register const struct lsr6 * lsrp ; register const struct lsa6_hdr * lshp ; register const struct lsa6 * lsap ; register int i ; switch ( op -> ospf6_type ) { case OSPF_TYPE_HELLO : {  register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\tOptions<S2SV_blank>[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & hellop -> hello_options ) ) ) ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Hello<S2SV_blank>Timer<S2SV_blank>%us,<S2SV_blank>Dead<S2SV_blank>Timer<S2SV_blank>%us,<S2SV_blank>Interface-ID<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u"" , EXTRACT_16BITS ( & hellop -> hello_helloint ) , EXTRACT_16BITS ( & hellop -> hello_deadint ) , ipaddr_string ( ndo , & hellop -> hello_ifid ) , hellop -> hello_priority ) ) ; ND_TCHECK ( hellop -> hello_dr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr ) != 0 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Designated<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & hellop -> hello_dr ) ) ) ; ND_TCHECK ( hellop -> hello_bdr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_bdr ) != 0 ) ND_PRINT ( ( ndo , "",<S2SV_blank>Backup<S2SV_blank>Designated<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & hellop -> hello_bdr ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Neighbor<S2SV_blank>List:"" ) ) ; ap = hellop -> hello_neighbor ; while ( ( const u_char * ) ap < dataend ) { ND_TCHECK ( * ap ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , ipaddr_string ( ndo , ap ) ) ) ; ++ ap ; } } break ; } case OSPF_TYPE_DD : { register const struct dd6 * ddp = ( const struct dd6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( ddp -> db_options ) ; ND_PRINT ( ( ndo , ""\\n\\tOptions<S2SV_blank>[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & ddp -> db_options ) ) ) ) ; ND_TCHECK ( ddp -> db_flags ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>DD<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( ospf6_dd_flag_values , ""none"" , ddp -> db_flags ) ) ) ; ND_TCHECK ( ddp -> db_seq ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>DD-Sequence<S2SV_blank>0x%08x"" , EXTRACT_16BITS ( & ddp -> db_mtu ) , EXTRACT_32BITS ( & ddp -> db_seq ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { lshp = ddp -> db_lshdr ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; } case OSPF_TYPE_LS_REQ : if ( ndo -> ndo_vflag > 1 ) { lsrp = ( const struct lsr6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lsrp < dataend ) { ND_TCHECK ( * lsrp ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & lsrp -> ls_router ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lsrp -> ls_type ) , & lsrp -> ls_stateid ) ; ++ lsrp ; } } break ; case OSPF_TYPE_LS_UPDATE : if ( ndo -> ndo_vflag > 1 ) { register const struct lsu6 * lsup = ( const struct lsu6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( lsup -> lsu_count ) ; i = EXTRACT_32BITS ( & lsup -> lsu_count ) ; lsap = lsup -> lsu_lsa ; while ( ( const u_char * ) lsap < dataend && i -- ) { if ( ospf6_print_lsa ( ndo , lsap , dataend ) ) goto trunc ; lsap = ( const struct lsa6 * ) ( ( const u_char * ) lsap + EXTRACT_16BITS ( & lsap -> ls_hdr . ls_length ) ) ; } } break ; case OSPF_TYPE_LS_ACK : if ( ndo -> ndo_vflag > 1 ) { lshp = ( const struct lsa6_hdr * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; default : break ; } return ( 0 ) ; trunc : return ( 1 ) ; }","register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ;ND_TCHECK_32BITS ( & hellop -> hello_options ) ;ND_PRINT ( ( ndo , ""\\\",1511
441,"buggy line: if ( * ( unsigned char * ) data > 1 )  return - ENOTSUPP ;cwe id:CWE-129context: int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) {  if ( * ( unsigned char * ) data > 1 )  return - ENOTSUPP ; return 1 ; }",if ( datalen != 1 ) return - EINVAL ;if ( * ( unsigned char * ) data > 1 ) return - ENOTSUPP ;,1512
442,"buggy line: rc -> uwbd . task = kthread_run ( uwbd , rc , ""uwbd"" ) ;if ( rc -> uwbd . task == NULL )  printk ( KERN_ERR ""UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;else  rc -> uwbd . pid = rc -> uwbd . task -> pid ;}cwe id:CWE-119context: void uwbd_start ( struct uwb_rc * rc ) {  rc -> uwbd . task = kthread_run ( uwbd , rc , ""uwbd"" ) ;   if ( rc -> uwbd . task == NULL )  printk ( KERN_ERR ""UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;<S2SV_blank>"" ""UWB<S2SV_blank>won\'t<S2SV_blank>work\\n"" ) ;  else  rc -> uwbd . pid = rc -> uwbd . task -> pid ;  } ","struct task_struct * task = kthread_run ( uwbd , rc , ""uwbd"" ) ;if ( IS_ERR ( task ) ) {rc -> uwbd . task = NULL ;printk ( KERN_ERR ""UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;}else {rc -> uwbd . task = task ;rc -> uwbd . pid = rc -> uwbd . task -> pid ;}}",1513
443,"buggy line: case 6 :  # line 96 ""re_grammar.y""  {# line 1045 ""re_grammar.c""  break ;case 26 :  # line 97 ""re_grammar.y""  {# line 1051 ""re_grammar.c"" break ;case 27 :  # line 98 ""re_grammar.y""  {# line 1057 ""re_grammar.c"" break ;case 28 :  # line 99 ""re_grammar.y""  {# line 1063 ""re_grammar.c"" break ;case 29 :  # line 100 ""re_grammar.y""  {# line 1069 ""re_grammar.c"" break ;cwe id:CWE-674context: static void yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , RE_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = ""Deleting"" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 6 :  # line 96 ""re_grammar.y""  { yr_free ( ( ( * yyvaluep ) . class_vector ) ) ; }  # line 1045 ""re_grammar.c""  break ; case 26 :  # line 97 ""re_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1051 ""re_grammar.c"" break ; case 27 :  # line 98 ""re_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1057 ""re_grammar.c"" break ; case 28 :  # line 99 ""re_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1063 ""re_grammar.c"" break ; case 29 :  # line 100 ""re_grammar.y""  { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1069 ""re_grammar.c"" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }","case 6 : # line 104 ""re_grammar.y"" {# line 1053 ""re_grammar.c"" break ;case 26 : # line 105 ""re_grammar.y"" {# line 1059 ""re_grammar.c"" break ;case 27 : # line 106 ""re_grammar.y"" {# line 1065 ""re_grammar.c"" break ;case 28 : # line 107 ""re_grammar.y"" {# line 1071 ""re_grammar.c"" break ;case 29 : # line 108 ""re_grammar.y"" {# line 1077 ""re_grammar.c"" break ;",1514
444,"buggy line: * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ;if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) {cwe id:CWE-125context: void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx -> data . bpp ) : idx ;  * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ;  if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) { ptr ++ ; } else { idx += gfx -> data . bpp ; if ( idx >= 8 ) ptr ++ ; } } else { int i ; for ( i = 0 ; i < gfx -> data . bpp ; i += 8 ) { * ptr = ( char ) ( col >> i ) ; ptr ++ ; } } } }",assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;* ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ;if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) {,1515
445,"buggy line: MACROBLOCKD * xd = args -> xd ;TOKENEXTRA * * tp = args -> tp ;struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ;struct macroblockd_plane * pd = & xd -> plane [ plane ] ;const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;const int segment_id = mbmi -> segment_id ;unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ;vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] =  cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ;unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] =  cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ;const uint8_t * const band = get_band_translate ( tx_size ) ;int aoff , loff ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ;cwe id:CWE-119context: static void tokenize_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; VP9_COMP * cpi = args -> cpi ;  MACROBLOCKD * xd = args -> xd ;  TOKENEXTRA * * tp = args -> tp ; uint8_t token_cache [ 32 * 32 ] ;  struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ;  struct macroblockd_plane * pd = & xd -> plane [ plane ] ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; int pt ; int c ; TOKENEXTRA * t = * tp ; int eob = p -> eobs [ block ] ; const PLANE_TYPE type = pd -> plane_type ;  const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;  const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ; vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] =  cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ;  unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] =  cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ;  const uint8_t * const band = get_band_translate ( tx_size ) ; const int seg_eob = get_tx_eob ( & cpi -> common . seg , segment_id , tx_size ) ;  int aoff , loff ;  txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ; pt = get_entropy_context ( tx_size , pd -> above_context + aoff , pd -> left_context + loff ) ; so = get_scan ( xd , tx_size , type , block ) ; scan = so -> scan ; nb = so -> neighbors ; c = 0 ; while ( c < eob ) { int v = 0 ; int skip_eob = 0 ; v = qcoeff [ scan [ c ] ] ; while ( ! v ) { add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , ZERO_TOKEN , skip_eob , counts [ band [ c ] ] [ pt ] ) ; eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ; skip_eob = 1 ; token_cache [ scan [ c ] ] = 0 ; ++ c ; pt = get_coef_context ( nb , token_cache , c ) ; v = qcoeff [ scan [ c ] ] ; }  add_token ( & t , coef_probs [ band [ c ] ] [ pt ] ,   vp9_dct_value_tokens_ptr [ v ] . extra ,   ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token ,  ( uint8_t ) skip_eob , counts [ band [ c ] ] [ pt ] ) ; eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ; token_cache [ scan [ c ] ] =  vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ;  ++ c ; pt = get_coef_context ( nb , token_cache , c ) ; } if ( c < seg_eob ) { add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , EOB_TOKEN , 0 , counts [ band [ c ] ] [ pt ] ) ; ++ eob_branch [ band [ c ] ] [ pt ] ; } * tp = t ; vp9_set_contexts ( xd , pd , plane_bsize , tx_size , c > 0 , aoff , loff ) ; }","ThreadData * const td = args -> td ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;TOKENEXTRA * * tp = args -> tp ;struct macroblock_plane * p = & x -> plane [ plane ] ;struct macroblockd_plane * pd = & xd -> plane [ plane ] ;const tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;const int segment_id = mbmi -> segment_id ;unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = td -> rd_counts . coef_counts [ tx_size ] [ type ] [ ref ] ;vpx_prob ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ;vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = cpi -> common . fc -> coef_probs [ tx_size ] [ type ] [ ref ] ;unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] = td -> counts -> eob_branch [ tx_size ] [ type ] [ ref ] ;const uint8_t * const band = get_band_translate ( tx_size ) ;int16_t token ;EXTRABIT extra ;int aoff , loff ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ;",1516
446,"buggy line: add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , ZERO_TOKEN , skip_eob , counts [ band [ c ] ] [ pt ] ) ;skip_eob = 1 ;token_cache [ scan [ c ] ] = 0 ;v = qcoeff [ scan [ c ] ] ;}add_token ( & t , coef_probs [ band [ c ] ] [ pt ] ,   vp9_dct_value_tokens_ptr [ v ] . extra ,   ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token ,  ( uint8_t ) skip_eob , counts [ band [ c ] ] [ pt ] ) ;eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ;token_cache [ scan [ c ] ] =  vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ;++ c ;pt = get_coef_context ( nb , token_cache , c ) ;cwe id:CWE-119context: static void tokenize_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; VP9_COMP * cpi = args -> cpi ;  MACROBLOCKD * xd = args -> xd ;  TOKENEXTRA * * tp = args -> tp ; uint8_t token_cache [ 32 * 32 ] ;  struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ;  struct macroblockd_plane * pd = & xd -> plane [ plane ] ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; int pt ; int c ; TOKENEXTRA * t = * tp ; int eob = p -> eobs [ block ] ; const PLANE_TYPE type = pd -> plane_type ;  const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;  const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ; vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] =  cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ;  unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] =  cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ;  const uint8_t * const band = get_band_translate ( tx_size ) ; const int seg_eob = get_tx_eob ( & cpi -> common . seg , segment_id , tx_size ) ;  int aoff , loff ;  txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ; pt = get_entropy_context ( tx_size , pd -> above_context + aoff , pd -> left_context + loff ) ; so = get_scan ( xd , tx_size , type , block ) ; scan = so -> scan ; nb = so -> neighbors ; c = 0 ; while ( c < eob ) { int v = 0 ; int skip_eob = 0 ; v = qcoeff [ scan [ c ] ] ; while ( ! v ) { add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , ZERO_TOKEN , skip_eob , counts [ band [ c ] ] [ pt ] ) ; eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ; skip_eob = 1 ; token_cache [ scan [ c ] ] = 0 ; ++ c ; pt = get_coef_context ( nb , token_cache , c ) ; v = qcoeff [ scan [ c ] ] ; }  add_token ( & t , coef_probs [ band [ c ] ] [ pt ] ,   vp9_dct_value_tokens_ptr [ v ] . extra ,   ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token ,  ( uint8_t ) skip_eob , counts [ band [ c ] ] [ pt ] ) ; eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ; token_cache [ scan [ c ] ] =  vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ;  ++ c ; pt = get_coef_context ( nb , token_cache , c ) ; } if ( c < seg_eob ) { add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , EOB_TOKEN , 0 , counts [ band [ c ] ] [ pt ] ) ; ++ eob_branch [ band [ c ] ] [ pt ] ; } * tp = t ; vp9_set_contexts ( xd , pd , plane_bsize , tx_size , c > 0 , aoff , loff ) ; }","add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , extra , ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token , ( uint8_t ) skip_eob , counts [ band [ c ] ] [ pt ] ) ;token_cache [ scan [ c ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ;+ c ;",1516
447,"buggy line: SrcList * pSrc = pSelect -> pSrc ;if ( pSrc == 0 ) {cwe id:CWE-674context: static int renameTableSelectCb ( Walker * pWalker , Select * pSelect ) { int i ; RenameCtx * p = pWalker -> u . pRename ;  SrcList * pSrc = pSelect -> pSrc ;  if ( pSrc == 0 ) { assert ( pWalker -> pParse -> db -> mallocFailed ) ; return WRC_Abort ; } for ( i = 0 ; i < pSrc -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pSrc -> a [ i ] ; if ( pItem -> pTab == p -> pTab ) { renameTokenFind ( pWalker -> pParse , p , pItem -> zName ) ; } } renameWalkWith ( pWalker , pSelect ) ; return WRC_Continue ; }",SrcList * pSrc = pSelect -> pSrc ;if ( pSelect -> selFlags & SF_View ) return WRC_Prune ;if ( pSrc == 0 ) {,1517
448,"buggy line: if ( addr & ( shmlba - 1 ) ) {if ( shmflg & SHM_RND )  addr &= ~ ( shmlba - 1 ) ;cwe id:CWE-000context: long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) {  if ( shmflg & SHM_RND )  addr &= ~ ( shmlba - 1 ) ; else # ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) # endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock ; } err = - EACCES ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr , shmflg ) ; if ( err ) goto out_unlock ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ipc_valid_object ( & shp -> shm_perm ) ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; } path = shp -> shm_file -> f_path ; path_get ( & path ) ; shp -> shm_nattch ++ ; size = i_size_read ( d_inode ( path . dentry ) ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; err = - ENOMEM ; sfd = kzalloc ( sizeof ( * sfd ) , GFP_KERNEL ) ; if ( ! sfd ) { path_put ( & path ) ; goto out_nattch ; } file = alloc_file ( & path , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge : & shm_file_operations ) ; err = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) { kfree ( sfd ) ; path_put ( & path ) ; goto out_nattch ; } file -> private_data = sfd ; file -> f_mapping = shp -> shm_file -> f_mapping ; sfd -> id = shp -> shm_perm . id ; sfd -> ns = get_ipc_ns ( ns ) ; sfd -> file = shp -> shm_file ; sfd -> vm_ops = NULL ; err = security_mmap_file ( file , prot , flags ) ; if ( err ) goto out_fput ; if ( down_write_killable ( & current -> mm -> mmap_sem ) ) { err = - EINTR ; goto out_fput ; } if ( addr && ! ( shmflg & SHM_REMAP ) ) { err = - EINVAL ; if ( addr + size < addr ) goto invalid ; if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) goto invalid ; } addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate , NULL ) ; * raddr = addr ; err = 0 ; if ( IS_ERR_VALUE ( addr ) ) err = ( long ) addr ; invalid : up_write ( & current -> mm -> mmap_sem ) ; if ( populate ) mm_populate ( addr , populate ) ; out_fput : fput ( file ) ; out_nattch : down_write ( & shm_ids ( ns ) . rwsem ) ; shp = shm_lock ( ns , shmid ) ; shp -> shm_nattch -- ; if ( shm_may_destroy ( ns , shp ) ) shm_destroy ( ns , shp ) ; else shm_unlock ( shp ) ; up_write ( & shm_ids ( ns ) . rwsem ) ; return err ; out_unlock : rcu_read_unlock ( ) ; out : return err ; }",if ( ( addr & ( shmlba - 1 ) ) {if ( shmflg & SHM_RND ) && addr >= shmlba ) addr &= ~ ( shmlba - 1 ) ;,1518
449,"buggy line: serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ;if ( ! serv ) {cwe id:CWE-404context: static struct svc_serv * nfs_callback_create_svc ( int minorversion ) { struct nfs_callback_data * cb_info = & nfs_callback_info [ minorversion ] ; struct svc_serv * serv ; struct svc_serv_ops * sv_ops ; if ( cb_info -> serv ) { svc_get ( cb_info -> serv ) ; return cb_info -> serv ; } switch ( minorversion ) { case 0 : sv_ops = nfs4_cb_sv_ops [ 0 ] ; break ; default : sv_ops = nfs4_cb_sv_ops [ 1 ] ; } if ( sv_ops == NULL ) return ERR_PTR ( - ENOTSUPP ) ; if ( cb_info -> users ) printk ( KERN_WARNING ""nfs_callback_create_svc:<S2SV_blank>no<S2SV_blank>kthread,<S2SV_blank>%d<S2SV_blank>users??\\n"" , cb_info -> users ) ;  serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ;  if ( ! serv ) { printk ( KERN_ERR ""nfs_callback_create_svc:<S2SV_blank>create<S2SV_blank>service<S2SV_blank>failed\\n"" ) ; return ERR_PTR ( - ENOMEM ) ; } cb_info -> serv = serv ; serv -> sv_maxconn = 1024 ; dprintk ( ""nfs_callback_create_svc:<S2SV_blank>service<S2SV_blank>created\\n"" ) ; return serv ; }","serv = svc_create_pooled ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ;if ( ! serv ) {",1519
450,"buggy line: void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) {PointZZ_p R0 , R1 , tmp ;cwe id:CWE-347context:  void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) {  PointZZ_p R0 , R1 , tmp ; mpz_inits ( R1 . x , R1 . y , tmp . x , tmp . y , NULL ) ; mpz_init_set ( R0 . x , point -> x ) ; mpz_init_set ( R0 . y , point -> y ) ; pointZZ_pDouble ( & R1 , point , curve ) ; int dbits = mpz_sizeinbase ( scalar , 2 ) , i ; for ( i = dbits - 2 ; i >= 0 ; i -- ) { if ( mpz_tstbit ( scalar , i ) ) { mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pAdd ( & R0 , & R1 , & tmp , curve ) ; mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pDouble ( & R1 , & tmp , curve ) ; } else { mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pAdd ( & R1 , & R0 , & tmp , curve ) ; mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pDouble ( & R0 , & tmp , curve ) ; } } mpz_init_set ( rop -> x , R0 . x ) ; mpz_init_set ( rop -> y , R0 . y ) ; mpz_clears ( R0 . x , R0 . y , R1 . x , R1 . y , tmp . x , tmp . y , NULL ) ; }","void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) {if ( pointZZ_pIsIdentityElement ( point ) ) {return pointZZ_pSetToIdentityElement ( rop ) ;}PointZZ_p R0 , R1 , tmp ;",1520
451,"buggy line: gss_buffer_desc client_name ,  service_name ;cwe id:CWE-772context: gstrings_ret * get_strings_2_svc ( gstrings_arg * arg , struct svc_req * rqstp ) { static gstrings_ret ret ; char * prime_arg ;  gss_buffer_desc client_name ,  service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gstrings_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_GET ; log_unauth ( ""kadm5_get_strings"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_strings ( ( void * ) handle , arg -> princ , & ret . strings , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_strings"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ;  gss_release_buffer ( & minor_stat , & client_name ) ;  gss_release_buffer ( & minor_stat , & service_name ) ;  exit_func :  free_server_handle ( handle ) ; return & ret ; }",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,1521
452,"buggy line: gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;cwe id:CWE-772context: gstrings_ret * get_strings_2_svc ( gstrings_arg * arg , struct svc_req * rqstp ) { static gstrings_ret ret ; char * prime_arg ;  gss_buffer_desc client_name ,  service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gstrings_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_GET ; log_unauth ( ""kadm5_get_strings"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_strings ( ( void * ) handle , arg -> princ , & ret . strings , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_strings"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ;  gss_release_buffer ( & minor_stat , & client_name ) ;  gss_release_buffer ( & minor_stat , & service_name ) ;  exit_func :  free_server_handle ( handle ) ; return & ret ; }","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",1521
453,buggy line: case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool :  case NPNVSupportsWindowless :  type = RPC_TYPE_BOOLEAN ;cwe id:CWE-264context: int rpc_type_of_NPNVariable ( int variable ) { int type ; switch ( variable ) { case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool :  case NPNVSupportsWindowless :  type = RPC_TYPE_BOOLEAN ; break ; case NPNVToolkit : case NPNVnetscapeWindow : type = RPC_TYPE_UINT32 ; break ; case NPNVWindowNPObject : case NPNVPluginElementNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; },case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling : type = RPC_TYPE_BOOLEAN ;,1522
454,"buggy line: ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ;close ( fd ) ;cwe id:CWE-284context: ssize_t socket_write_and_transfer_fd ( const socket_t * socket , const void * buf , size_t count , int fd ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ; if ( fd == INVALID_FD ) return socket_write ( socket , buf , count ) ; struct msghdr msg ; struct iovec iov ; char control_buf [ CMSG_SPACE ( sizeof ( int ) ) ] ; iov . iov_base = ( void * ) buf ; iov . iov_len = count ; msg . msg_iov = & iov ; msg . msg_iovlen = 1 ; msg . msg_control = control_buf ; msg . msg_controllen = sizeof ( control_buf ) ; msg . msg_name = NULL ; msg . msg_namelen = 0 ; struct cmsghdr * header = CMSG_FIRSTHDR ( & msg ) ; header -> cmsg_level = SOL_SOCKET ; header -> cmsg_type = SCM_RIGHTS ; header -> cmsg_len = CMSG_LEN ( sizeof ( int ) ) ; * ( int * ) CMSG_DATA ( header ) = fd ;  ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ;  close ( fd ) ; return ret ; }","ssize_t ret = TEMP_FAILURE_RETRY ( sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ) ;close ( fd ) ;",1523
455,"buggy line: do ret = send ( sock_fd , buf , s , 0 ) ;while ( ret < 0 && errno == EINTR ) ;cwe id:CWE-284context: int sock_send_all ( int sock_fd , const uint8_t * buf , int len ) { int s = len ; int ret ; while ( s ) {  do ret = send ( sock_fd , buf , s , 0 ) ;  while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( ""sock<S2SV_blank>fd:%d<S2SV_blank>send<S2SV_blank>errno:%d,<S2SV_blank>ret:%d"" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; s -= ret ; } return len ; }","do ret = TEMP_FAILURE_RETRY ( send ( sock_fd , buf , s , 0 ) ) ;while ( ret < 0 && errno == EINTR ) ;",1524
456,"buggy line: for ( xIter = crm_first_attr ( xml ) ;const char * prop_name = ( const char * ) xIter -> name ;if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 ) {continue ;char * path = xml_get_path ( xml ) ;crm_trace ( ""Cannot<S2SV_blank>add<S2SV_blank>new<S2SV_blank>node<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s"" , crm_element_name ( xml ) , path ) ;cwe id:CWE-264context: static void __xml_acl_post_process ( xmlNode * xml ) { xmlNode * cIter = __xml_first_child ( xml ) ; xml_private_t * p = xml -> _private ; if ( is_set ( p -> flags , xpf_created ) ) { xmlAttr * xIter = NULL ;  for ( xIter = crm_first_attr ( xml ) ; xIter != NULL ; xIter = xIter -> next ) {  const char * prop_name = ( const char * ) xIter -> name ;  if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 ) {  continue ; } else if ( __xml_acl_check ( xml , NULL , xpf_acl_write ) ) { crm_trace ( ""Creation<S2SV_blank>of<S2SV_blank>%s=%s<S2SV_blank>is<S2SV_blank>allowed"" , crm_element_name ( xml ) , ID ( xml ) ) ; break ; } else {  char * path = xml_get_path ( xml ) ;  crm_trace ( ""Cannot<S2SV_blank>add<S2SV_blank>new<S2SV_blank>node<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s"" , crm_element_name ( xml ) , path ) ; if ( xml != xmlDocGetRootElement ( xml -> doc ) ) { xmlUnlinkNode ( xml ) ; xmlFreeNode ( xml ) ; } free ( path ) ; return ; } }  }  while ( cIter != NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; __xml_acl_post_process ( child ) ; } }","char * path = xml_get_path ( xml ) ;for ( xIter = crm_first_attr ( xml ) ;const char * prop_name = ( const char * ) xIter -> name ;if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 && strstr ( path , ""/"" XML_CIB_TAG_ACLS ""/"" ) == NULL ) {continue ;crm_trace ( ""Cannot<S2SV_blank>add<S2SV_blank>new<S2SV_blank>node<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s"" , crm_element_name ( xml ) , path ) ;",1525
457,"buggy line: }while ( cIter != NULL ) {cwe id:CWE-264context: static void __xml_acl_post_process ( xmlNode * xml ) { xmlNode * cIter = __xml_first_child ( xml ) ; xml_private_t * p = xml -> _private ; if ( is_set ( p -> flags , xpf_created ) ) { xmlAttr * xIter = NULL ;  for ( xIter = crm_first_attr ( xml ) ; xIter != NULL ; xIter = xIter -> next ) {  const char * prop_name = ( const char * ) xIter -> name ;  if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 ) {  continue ; } else if ( __xml_acl_check ( xml , NULL , xpf_acl_write ) ) { crm_trace ( ""Creation<S2SV_blank>of<S2SV_blank>%s=%s<S2SV_blank>is<S2SV_blank>allowed"" , crm_element_name ( xml ) , ID ( xml ) ) ; break ; } else {  char * path = xml_get_path ( xml ) ;  crm_trace ( ""Cannot<S2SV_blank>add<S2SV_blank>new<S2SV_blank>node<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s"" , crm_element_name ( xml ) , path ) ; if ( xml != xmlDocGetRootElement ( xml -> doc ) ) { xmlUnlinkNode ( xml ) ; xmlFreeNode ( xml ) ; } free ( path ) ; return ; } }  }  while ( cIter != NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; __xml_acl_post_process ( child ) ; } }",free ( path ) ;}while ( cIter != NULL ) {,1525
458,"buggy line: if ( ! dirout ) return ERROR_INT ( ""dirout<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ;if ( ! rootname ) return ERROR_INT ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ;if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ;if ( thumbwidth < MIN_THUMB_WIDTH ) {L_WARNING ( ""thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\\thumbwidth = MIN_THUMB_WIDTH ;}if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ;if ( viewwidth < MIN_VIEW_WIDTH ) {L_WARNING ( ""viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\\viewwidth = MIN_VIEW_WIDTH ;}# ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir<S2SV_blank>-p<S2SV_blank>%s"" , dirout ) ;ret = system ( charbuf ) ;# else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ;# endif if ( ret ) {L_ERROR ( ""output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\\return 1 ;}if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( ""safiles<S2SV_blank>not<S2SV_blank>made"" , procName , 1 ) ;sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ;mainname = stringNew ( charbuf ) ;sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;linkname = stringNew ( charbuf ) ;cwe id:CWE-119context: static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char charbuf [ 512 ] ; char htmlstring [ ] = ""<html>"" ; char framestring [ ] = ""</frameset></html>"" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( ""pixHtmlViewer"" ) ; if ( ! dirin ) return ERROR_INT ( ""dirin<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( ""dirout<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( ""thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( ""viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir<S2SV_blank>-p<S2SV_blank>%s"" , dirout ) ; ret = system ( charbuf ) ; # else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ; # endif if ( ret ) { L_ERROR ( ""output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\n"" , procName , dirout ) ; return 1 ; } if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( ""safiles<S2SV_blank>not<S2SV_blank>made"" , procName , 1 ) ;  sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ;  mainname = stringNew ( charbuf ) ;  sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;  linkname = stringNew ( charbuf ) ; linknameshort = stringJoin ( rootname , ""-links.html"" ) ; sathumbs = sarrayCreate ( 0 ) ; saviews = sarrayCreate ( 0 ) ; nfiles = sarrayGetCount ( safiles ) ; index = 0 ; for ( i = 0 ; i < nfiles ; i ++ ) { fname = sarrayGetString ( safiles , i , L_NOCOPY ) ; fullname = genPathname ( dirin , fname ) ; fprintf ( stderr , ""name:<S2SV_blank>%s\\n"" , fullname ) ; if ( ( pix = pixRead ( fullname ) ) == NULL ) { fprintf ( stderr , ""file<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>a<S2SV_blank>readable<S2SV_blank>image\\n"" , fullname ) ; lept_free ( fullname ) ; continue ; } lept_free ( fullname ) ; pixGetDimensions ( pix , & w , NULL , & d ) ; factor = ( l_float32 ) thumbwidth / ( l_float32 ) w ; pixthumb = pixScale ( pix , factor , factor ) ;  sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ;  sarrayAddString ( sathumbs , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixthumb ) ; lept_free ( outname ) ; pixDestroy ( & pixthumb ) ; factor = ( l_float32 ) viewwidth / ( l_float32 ) w ; if ( factor >= 1.0 ) pixview = pixClone ( pix ) ; else pixview = pixScale ( pix , factor , factor ) ; snprintf ( charbuf , sizeof ( charbuf ) , ""%s_view_%03d"" , rootname , index ) ; sarrayAddString ( saviews , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixview ) ; lept_free ( outname ) ; pixDestroy ( & pixview ) ; pixDestroy ( & pix ) ; index ++ ; } sahtml = sarrayCreate ( 0 ) ; sarrayAddString ( sahtml , htmlstring , L_COPY ) ; sprintf ( charbuf , ""<frameset<S2SV_blank>cols=\\""%d,<S2SV_blank>*\\"">"" , thumbwidth + 30 ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""thumbs\\""<S2SV_blank>src=\\""%s\\"">"" , linknameshort ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""views\\""<S2SV_blank>src=\\""%s\\"">"" , sarrayGetString ( saviews , 0 , L_NOCOPY ) ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sarrayAddString ( sahtml , framestring , L_COPY ) ; shtml = sarrayToString ( sahtml , 1 ) ; l_binaryWrite ( mainname , ""w"" , shtml , strlen ( shtml ) ) ; fprintf ( stderr , ""******************************************\\n"" ""Writing<S2SV_blank>html<S2SV_blank>file:<S2SV_blank>%s\\n"" ""******************************************\\n"" , mainname ) ; lept_free ( shtml ) ; lept_free ( mainname ) ; nimages = sarrayGetCount ( saviews ) ; fprintf ( stderr , ""num.<S2SV_blank>images<S2SV_blank>=<S2SV_blank>%d\\n"" , nimages ) ; salink = sarrayCreate ( 0 ) ; for ( i = 0 ; i < nimages ; i ++ ) { viewfile = sarrayGetString ( saviews , i , L_NOCOPY ) ; thumbfile = sarrayGetString ( sathumbs , i , L_NOCOPY ) ; sprintf ( charbuf , ""<a<S2SV_blank>href=\\""%s\\""<S2SV_blank>TARGET=views><img<S2SV_blank>src=\\""%s\\""></a>"" , viewfile , thumbfile ) ; sarrayAddString ( salink , charbuf , L_COPY ) ; } slink = sarrayToString ( salink , 1 ) ; l_binaryWrite ( linkname , ""w"" , slink , strlen ( slink ) ) ; lept_free ( slink ) ; lept_free ( linkname ) ; lept_free ( linknameshort ) ; sarrayDestroy ( & safiles ) ; sarrayDestroy ( & sathumbs ) ; sarrayDestroy ( & saviews ) ; sarrayDestroy ( & sahtml ) ; sarrayDestroy ( & salink ) ; return 0 ; }","snprintf ( charbuf , sizeof ( charbuf ) , ""%s/%s.html"" , dirout , rootname ) ;mainname = stringNew ( charbuf ) ;sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;linkname = stringNew ( charbuf ) ;",1526
459,"buggy line: sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ;sarrayAddString ( sathumbs , charbuf , L_COPY ) ;cwe id:CWE-119context: static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char charbuf [ 512 ] ; char htmlstring [ ] = ""<html>"" ; char framestring [ ] = ""</frameset></html>"" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( ""pixHtmlViewer"" ) ; if ( ! dirin ) return ERROR_INT ( ""dirin<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( ""dirout<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( ""thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( ""viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir<S2SV_blank>-p<S2SV_blank>%s"" , dirout ) ; ret = system ( charbuf ) ; # else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ; # endif if ( ret ) { L_ERROR ( ""output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\n"" , procName , dirout ) ; return 1 ; } if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( ""safiles<S2SV_blank>not<S2SV_blank>made"" , procName , 1 ) ;  sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ;  mainname = stringNew ( charbuf ) ;  sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;  linkname = stringNew ( charbuf ) ; linknameshort = stringJoin ( rootname , ""-links.html"" ) ; sathumbs = sarrayCreate ( 0 ) ; saviews = sarrayCreate ( 0 ) ; nfiles = sarrayGetCount ( safiles ) ; index = 0 ; for ( i = 0 ; i < nfiles ; i ++ ) { fname = sarrayGetString ( safiles , i , L_NOCOPY ) ; fullname = genPathname ( dirin , fname ) ; fprintf ( stderr , ""name:<S2SV_blank>%s\\n"" , fullname ) ; if ( ( pix = pixRead ( fullname ) ) == NULL ) { fprintf ( stderr , ""file<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>a<S2SV_blank>readable<S2SV_blank>image\\n"" , fullname ) ; lept_free ( fullname ) ; continue ; } lept_free ( fullname ) ; pixGetDimensions ( pix , & w , NULL , & d ) ; factor = ( l_float32 ) thumbwidth / ( l_float32 ) w ; pixthumb = pixScale ( pix , factor , factor ) ;  sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ;  sarrayAddString ( sathumbs , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixthumb ) ; lept_free ( outname ) ; pixDestroy ( & pixthumb ) ; factor = ( l_float32 ) viewwidth / ( l_float32 ) w ; if ( factor >= 1.0 ) pixview = pixClone ( pix ) ; else pixview = pixScale ( pix , factor , factor ) ; snprintf ( charbuf , sizeof ( charbuf ) , ""%s_view_%03d"" , rootname , index ) ; sarrayAddString ( saviews , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixview ) ; lept_free ( outname ) ; pixDestroy ( & pixview ) ; pixDestroy ( & pix ) ; index ++ ; } sahtml = sarrayCreate ( 0 ) ; sarrayAddString ( sahtml , htmlstring , L_COPY ) ; sprintf ( charbuf , ""<frameset<S2SV_blank>cols=\\""%d,<S2SV_blank>*\\"">"" , thumbwidth + 30 ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""thumbs\\""<S2SV_blank>src=\\""%s\\"">"" , linknameshort ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""views\\""<S2SV_blank>src=\\""%s\\"">"" , sarrayGetString ( saviews , 0 , L_NOCOPY ) ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sarrayAddString ( sahtml , framestring , L_COPY ) ; shtml = sarrayToString ( sahtml , 1 ) ; l_binaryWrite ( mainname , ""w"" , shtml , strlen ( shtml ) ) ; fprintf ( stderr , ""******************************************\\n"" ""Writing<S2SV_blank>html<S2SV_blank>file:<S2SV_blank>%s\\n"" ""******************************************\\n"" , mainname ) ; lept_free ( shtml ) ; lept_free ( mainname ) ; nimages = sarrayGetCount ( saviews ) ; fprintf ( stderr , ""num.<S2SV_blank>images<S2SV_blank>=<S2SV_blank>%d\\n"" , nimages ) ; salink = sarrayCreate ( 0 ) ; for ( i = 0 ; i < nimages ; i ++ ) { viewfile = sarrayGetString ( saviews , i , L_NOCOPY ) ; thumbfile = sarrayGetString ( sathumbs , i , L_NOCOPY ) ; sprintf ( charbuf , ""<a<S2SV_blank>href=\\""%s\\""<S2SV_blank>TARGET=views><img<S2SV_blank>src=\\""%s\\""></a>"" , viewfile , thumbfile ) ; sarrayAddString ( salink , charbuf , L_COPY ) ; } slink = sarrayToString ( salink , 1 ) ; l_binaryWrite ( linkname , ""w"" , slink , strlen ( slink ) ) ; lept_free ( slink ) ; lept_free ( linkname ) ; lept_free ( linknameshort ) ; sarrayDestroy ( & safiles ) ; sarrayDestroy ( & sathumbs ) ; sarrayDestroy ( & saviews ) ; sarrayDestroy ( & sahtml ) ; sarrayDestroy ( & salink ) ; return 0 ; }","snprintf ( charbuf , sizeof ( charbuf ) , ""%s_thumb_%03d"" , rootname , index ) ;sarrayAddString ( sathumbs , charbuf , L_COPY ) ;",1526
460,buggy line: static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {if ( svc_ctx == NULL ) return NULL ;return ( const SvcInternal * ) svc_ctx -> internal ;}cwe id:CWE-119context:  static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {  if ( svc_ctx == NULL ) return NULL ;  return ( const SvcInternal * ) svc_ctx -> internal ;  },static const SvcInternal_t * get_const_svc_internal ( const SvcContext * svc_ctx ) {if ( svc_ctx == NULL ) return NULL ;return ( const SvcInternal_t * ) svc_ctx -> internal ;},1527
461,"buggy line: spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ;flush_rq -> tag = - 1 ;cwe id:CWE-264context: static void flush_end_io ( struct request * flush_rq , int error ) { struct request_queue * q = flush_rq -> q ; struct list_head * running ; bool queued = false ; struct request * rq , * n ; unsigned long flags = 0 ; struct blk_flush_queue * fq = blk_get_flush_queue ( q , flush_rq -> mq_ctx ) ; if ( q -> mq_ops ) {  spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ;  flush_rq -> tag = - 1 ; } running = & fq -> flush_queue [ fq -> flush_running_idx ] ; BUG_ON ( fq -> flush_pending_idx == fq -> flush_running_idx ) ; fq -> flush_running_idx ^= 1 ; if ( ! q -> mq_ops ) elv_completed_request ( q , flush_rq ) ; list_for_each_entry_safe ( rq , n , running , flush . list ) { unsigned int seq = blk_flush_cur_seq ( rq ) ; BUG_ON ( seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH ) ; queued |= blk_flush_complete_seq ( rq , fq , seq , error ) ; } if ( queued || fq -> flush_queue_delayed ) { WARN_ON ( q -> mq_ops ) ; blk_run_queue_async ( q ) ; } fq -> flush_queue_delayed = 0 ; if ( q -> mq_ops ) spin_unlock_irqrestore ( & fq -> mq_flush_lock , flags ) ; }","struct blk_mq_hw_ctx * hctx ;spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ;hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ;blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq ) ;flush_rq -> tag = - 1 ;",1528
462,"buggy line: int length ;ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;in_uint8s ( s , length ) ;cwe id:CWE-787context: static RD_BOOL mcs_parse_domain_params ( STREAM s ) {  int length ;   ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;  in_uint8s ( s , length ) ; return s_check ( s ) ; }","uint32 length ;struct stream packet = * s ;ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint8s ( s , length ) ;",1529
463,"buggy line: if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) {if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) {if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) {cwe id:CWE-704context: static void merge_param ( HashTable * params , zval * zdata , zval * * * current_param , zval * * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , ""params<S2SV_blank>=<S2SV_blank>"" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , ""\\n"" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( ""value"" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , ""arguments"" , sizeof ( ""arguments"" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args ; if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_update ( params , hkey . str , hkey . len , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_index_update ( params , hkey . num , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } } else { if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_find ( params , hkey . str , hkey . len , ( void * ) & ptr ) ; } else { zend_hash_index_find ( params , hkey . num , ( void * ) & ptr ) ; } zdata_ptr = & zdata ; if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) { zval * * test_ptr ; while ( Z_TYPE_PP ( zdata_ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & test_ptr ) ) {  if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) {  if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { if ( SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } else { if ( SUCCESS == zend_hash_index_find ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else if ( hkey . num ) { Z_ADDREF_PP ( test_ptr ) ; zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } } else { Z_ADDREF_PP ( test_ptr ) ; if ( Z_TYPE_PP ( ptr ) != IS_ARRAY ) { zval_dtor ( * ptr ) ; array_init ( * ptr ) ; } if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else if ( hkey . num ) { zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } break ; } } } } while ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( ptr ) , ( void * ) & ptr ) ) ; * current_param = ptr ; }","if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) {if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) {if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) {",1530
464,"buggy line: char buffer [ 80 ] ;int ret ;cwe id:CWE-119context: int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip , int only_420 ) {  char buffer [ 80 ] ;  int ret ; int i ; for ( i = 0 ; i < 79 ; i ++ ) { if ( _nskip > 0 ) { buffer [ i ] = * _skip ++ ; _nskip -- ; } else { if ( ! file_read ( buffer + i , 1 , _fin ) ) return - 1 ; } if ( buffer [ i ] == '\\n' ) break ; } if ( _nskip > 0 ) return - 1 ; if ( i == 79 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>header;<S2SV_blank>not<S2SV_blank>a<S2SV_blank>YUV2MPEG2<S2SV_blank>file?\\n"" ) ; return - 1 ; } buffer [ i ] = '\\0' ; if ( memcmp ( buffer , ""YUV4MPEG"" , 8 ) ) { fprintf ( stderr , ""Incomplete<S2SV_blank>magic<S2SV_blank>for<S2SV_blank>YUV4MPEG<S2SV_blank>file.\\n"" ) ; return - 1 ; } if ( buffer [ 8 ] != '2' ) { fprintf ( stderr , ""Incorrect<S2SV_blank>YUV<S2SV_blank>input<S2SV_blank>file<S2SV_blank>version;<S2SV_blank>YUV4MPEG2<S2SV_blank>required.\\n"" ) ; } ret = y4m_parse_tags ( _y4m , buffer + 5 ) ; if ( ret < 0 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>YUV4MPEG2<S2SV_blank>header.\\n"" ) ; return ret ; } if ( _y4m -> interlace == '?' ) { fprintf ( stderr , ""Warning:<S2SV_blank>Input<S2SV_blank>video<S2SV_blank>interlacing<S2SV_blank>format<S2SV_blank>unknown;<S2SV_blank>"" ""assuming<S2SV_blank>progressive<S2SV_blank>scan.\\n"" ) ; } else if ( _y4m -> interlace != 'p' ) { fprintf ( stderr , ""Input<S2SV_blank>video<S2SV_blank>is<S2SV_blank>interlaced;<S2SV_blank>"" ""Only<S2SV_blank>progressive<S2SV_blank>scan<S2SV_blank>handled.\\n"" ) ; return - 1 ; } _y4m -> vpx_fmt = VPX_IMG_FMT_I420 ;  _y4m -> vpx_bps = 12 ;   if ( strcmp ( _y4m -> chroma_type , ""420"" ) == 0 ||  strcmp ( _y4m -> chroma_type , ""420jpeg"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ;  } else if ( strcmp ( _y4m -> chroma_type , ""420mpeg2"" ) == 0 ) {  _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xmpeg2_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""420paldv"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = 3 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xpaldv_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""422jpeg"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422jpeg_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""422"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I422 ;  _y4m -> vpx_bps = 16 ;  _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;  _y4m -> convert = y4m_convert_null ;  } } else if ( strcmp ( _y4m -> chroma_type , ""411"" ) == 0 ) { _y4m -> src_c_dec_h = 4 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 3 ) / 4 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_411_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""444"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I444 ;  _y4m -> vpx_bps = 24 ;  _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; }  } else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) {  _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ;  if ( only_420 ) {   _y4m -> dst_c_dec_h = 2 ;  _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> vpx_bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , ""mono"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else {  fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n"" , _y4m -> chroma_type ) ;  return - 1 ; }  _y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h  + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;  _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ;   _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ;  return 0 ; }",char buffer [ 80 ] = {0 };int ret ;,1531
465,"buggy line: _y4m -> vpx_bps = 12 ;if ( strcmp ( _y4m -> chroma_type , ""420"" ) == 0 ||  strcmp ( _y4m -> chroma_type , ""420jpeg"" ) == 0 ) {_y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;}else if ( strcmp ( _y4m -> chroma_type , ""420mpeg2"" ) == 0 ) {_y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;_y4m -> convert = y4m_convert_42xmpeg2_42xjpeg ;else if ( strcmp ( _y4m -> chroma_type , ""420paldv"" ) == 0 ) {_y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = 3 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;_y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;_y4m -> convert = y4m_convert_42xpaldv_42xjpeg ;}else if ( strcmp ( _y4m -> chroma_type , ""422jpeg"" ) == 0 ) {_y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ;_y4m -> src_c_dec_v = 1 ;_y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;_y4m -> convert = y4m_convert_422jpeg_420jpeg ;else if ( strcmp ( _y4m -> chroma_type , ""422"" ) == 0 ) {_y4m -> dst_c_dec_h = 2 ;_y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;_y4m -> convert = y4m_convert_422_420jpeg ;else {_y4m -> vpx_fmt = VPX_IMG_FMT_I422 ;_y4m -> vpx_bps = 16 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;_y4m -> convert = y4m_convert_null ;}cwe id:CWE-119context: int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip , int only_420 ) {  char buffer [ 80 ] ;  int ret ; int i ; for ( i = 0 ; i < 79 ; i ++ ) { if ( _nskip > 0 ) { buffer [ i ] = * _skip ++ ; _nskip -- ; } else { if ( ! file_read ( buffer + i , 1 , _fin ) ) return - 1 ; } if ( buffer [ i ] == '\\n' ) break ; } if ( _nskip > 0 ) return - 1 ; if ( i == 79 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>header;<S2SV_blank>not<S2SV_blank>a<S2SV_blank>YUV2MPEG2<S2SV_blank>file?\\n"" ) ; return - 1 ; } buffer [ i ] = '\\0' ; if ( memcmp ( buffer , ""YUV4MPEG"" , 8 ) ) { fprintf ( stderr , ""Incomplete<S2SV_blank>magic<S2SV_blank>for<S2SV_blank>YUV4MPEG<S2SV_blank>file.\\n"" ) ; return - 1 ; } if ( buffer [ 8 ] != '2' ) { fprintf ( stderr , ""Incorrect<S2SV_blank>YUV<S2SV_blank>input<S2SV_blank>file<S2SV_blank>version;<S2SV_blank>YUV4MPEG2<S2SV_blank>required.\\n"" ) ; } ret = y4m_parse_tags ( _y4m , buffer + 5 ) ; if ( ret < 0 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>YUV4MPEG2<S2SV_blank>header.\\n"" ) ; return ret ; } if ( _y4m -> interlace == '?' ) { fprintf ( stderr , ""Warning:<S2SV_blank>Input<S2SV_blank>video<S2SV_blank>interlacing<S2SV_blank>format<S2SV_blank>unknown;<S2SV_blank>"" ""assuming<S2SV_blank>progressive<S2SV_blank>scan.\\n"" ) ; } else if ( _y4m -> interlace != 'p' ) { fprintf ( stderr , ""Input<S2SV_blank>video<S2SV_blank>is<S2SV_blank>interlaced;<S2SV_blank>"" ""Only<S2SV_blank>progressive<S2SV_blank>scan<S2SV_blank>handled.\\n"" ) ; return - 1 ; } _y4m -> vpx_fmt = VPX_IMG_FMT_I420 ;  _y4m -> vpx_bps = 12 ;   if ( strcmp ( _y4m -> chroma_type , ""420"" ) == 0 ||  strcmp ( _y4m -> chroma_type , ""420jpeg"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ;  } else if ( strcmp ( _y4m -> chroma_type , ""420mpeg2"" ) == 0 ) {  _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xmpeg2_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""420paldv"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = 3 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xpaldv_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""422jpeg"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422jpeg_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""422"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I422 ;  _y4m -> vpx_bps = 16 ;  _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;  _y4m -> convert = y4m_convert_null ;  } } else if ( strcmp ( _y4m -> chroma_type , ""411"" ) == 0 ) { _y4m -> src_c_dec_h = 4 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 3 ) / 4 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_411_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""444"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I444 ;  _y4m -> vpx_bps = 24 ;  _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; }  } else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) {  _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ;  if ( only_420 ) {   _y4m -> dst_c_dec_h = 2 ;  _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> vpx_bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , ""mono"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else {  fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n"" , _y4m -> chroma_type ) ;  return - 1 ; }  _y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h  + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;  _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ;   _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ;  return 0 ; }","_y4m -> bps = 12 ;_y4m -> bit_depth = 8 ;if ( strcmp ( _y4m -> chroma_type , ""420p10"" ) == 0 ) {_y4m -> src_c_dec_h = 2 ;_y4m -> bps = 16 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;else if ( strcmp ( _y4m -> chroma_type , ""422p10"" ) == 0 ) {_y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ;_y4m -> bps = 20 ;_y4m -> bit_depth = 10 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;_y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;_y4m -> convert = y4m_convert_null ;fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p10<S2SV_blank>to<S2SV_blank>420jpeg\\\return - 1 ;}else if ( strcmp ( _y4m -> chroma_type , ""422p12"" ) == 0 ) {_y4m -> src_c_dec_h = 2 ;_y4m -> src_c_dec_v = 1 ;_y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ;_y4m -> bps = 24 ;_y4m -> bit_depth = 12 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ;_y4m -> convert = y4m_convert_null ;if ( only_420 ) {fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p12<S2SV_blank>to<S2SV_blank>420jpeg\\\return - 1 ;}",1531
466,"buggy line: _y4m -> vpx_bps = 24 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;}_y4m -> src_c_dec_h = 1 ;if ( only_420 ) {_y4m -> dst_c_dec_h = 2 ;_y4m -> dst_c_dec_v = 2 ;cwe id:CWE-119context: int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip , int only_420 ) {  char buffer [ 80 ] ;  int ret ; int i ; for ( i = 0 ; i < 79 ; i ++ ) { if ( _nskip > 0 ) { buffer [ i ] = * _skip ++ ; _nskip -- ; } else { if ( ! file_read ( buffer + i , 1 , _fin ) ) return - 1 ; } if ( buffer [ i ] == '\\n' ) break ; } if ( _nskip > 0 ) return - 1 ; if ( i == 79 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>header;<S2SV_blank>not<S2SV_blank>a<S2SV_blank>YUV2MPEG2<S2SV_blank>file?\\n"" ) ; return - 1 ; } buffer [ i ] = '\\0' ; if ( memcmp ( buffer , ""YUV4MPEG"" , 8 ) ) { fprintf ( stderr , ""Incomplete<S2SV_blank>magic<S2SV_blank>for<S2SV_blank>YUV4MPEG<S2SV_blank>file.\\n"" ) ; return - 1 ; } if ( buffer [ 8 ] != '2' ) { fprintf ( stderr , ""Incorrect<S2SV_blank>YUV<S2SV_blank>input<S2SV_blank>file<S2SV_blank>version;<S2SV_blank>YUV4MPEG2<S2SV_blank>required.\\n"" ) ; } ret = y4m_parse_tags ( _y4m , buffer + 5 ) ; if ( ret < 0 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>YUV4MPEG2<S2SV_blank>header.\\n"" ) ; return ret ; } if ( _y4m -> interlace == '?' ) { fprintf ( stderr , ""Warning:<S2SV_blank>Input<S2SV_blank>video<S2SV_blank>interlacing<S2SV_blank>format<S2SV_blank>unknown;<S2SV_blank>"" ""assuming<S2SV_blank>progressive<S2SV_blank>scan.\\n"" ) ; } else if ( _y4m -> interlace != 'p' ) { fprintf ( stderr , ""Input<S2SV_blank>video<S2SV_blank>is<S2SV_blank>interlaced;<S2SV_blank>"" ""Only<S2SV_blank>progressive<S2SV_blank>scan<S2SV_blank>handled.\\n"" ) ; return - 1 ; } _y4m -> vpx_fmt = VPX_IMG_FMT_I420 ;  _y4m -> vpx_bps = 12 ;   if ( strcmp ( _y4m -> chroma_type , ""420"" ) == 0 ||  strcmp ( _y4m -> chroma_type , ""420jpeg"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ;  } else if ( strcmp ( _y4m -> chroma_type , ""420mpeg2"" ) == 0 ) {  _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xmpeg2_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""420paldv"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = 3 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xpaldv_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""422jpeg"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422jpeg_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""422"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I422 ;  _y4m -> vpx_bps = 16 ;  _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;  _y4m -> convert = y4m_convert_null ;  } } else if ( strcmp ( _y4m -> chroma_type , ""411"" ) == 0 ) { _y4m -> src_c_dec_h = 4 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 3 ) / 4 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_411_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""444"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I444 ;  _y4m -> vpx_bps = 24 ;  _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; }  } else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) {  _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ;  if ( only_420 ) {   _y4m -> dst_c_dec_h = 2 ;  _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> vpx_bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , ""mono"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else {  fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n"" , _y4m -> chroma_type ) ;  return - 1 ; }  _y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h  + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;  _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ;   _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ;  return 0 ; }",_y4m -> vpx_bps = 24 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;}_y4m -> src_c_dec_h = 1 ;if ( only_420 ) {_y4m -> dst_c_dec_h = 2 ;_y4m -> dst_c_dec_v = 2 ;,1531
467,"buggy line: fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\\return - 1 ;_y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h  + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;_y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ;_y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ;return 0 ;cwe id:CWE-119context: int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip , int only_420 ) {  char buffer [ 80 ] ;  int ret ; int i ; for ( i = 0 ; i < 79 ; i ++ ) { if ( _nskip > 0 ) { buffer [ i ] = * _skip ++ ; _nskip -- ; } else { if ( ! file_read ( buffer + i , 1 , _fin ) ) return - 1 ; } if ( buffer [ i ] == '\\n' ) break ; } if ( _nskip > 0 ) return - 1 ; if ( i == 79 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>header;<S2SV_blank>not<S2SV_blank>a<S2SV_blank>YUV2MPEG2<S2SV_blank>file?\\n"" ) ; return - 1 ; } buffer [ i ] = '\\0' ; if ( memcmp ( buffer , ""YUV4MPEG"" , 8 ) ) { fprintf ( stderr , ""Incomplete<S2SV_blank>magic<S2SV_blank>for<S2SV_blank>YUV4MPEG<S2SV_blank>file.\\n"" ) ; return - 1 ; } if ( buffer [ 8 ] != '2' ) { fprintf ( stderr , ""Incorrect<S2SV_blank>YUV<S2SV_blank>input<S2SV_blank>file<S2SV_blank>version;<S2SV_blank>YUV4MPEG2<S2SV_blank>required.\\n"" ) ; } ret = y4m_parse_tags ( _y4m , buffer + 5 ) ; if ( ret < 0 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>YUV4MPEG2<S2SV_blank>header.\\n"" ) ; return ret ; } if ( _y4m -> interlace == '?' ) { fprintf ( stderr , ""Warning:<S2SV_blank>Input<S2SV_blank>video<S2SV_blank>interlacing<S2SV_blank>format<S2SV_blank>unknown;<S2SV_blank>"" ""assuming<S2SV_blank>progressive<S2SV_blank>scan.\\n"" ) ; } else if ( _y4m -> interlace != 'p' ) { fprintf ( stderr , ""Input<S2SV_blank>video<S2SV_blank>is<S2SV_blank>interlaced;<S2SV_blank>"" ""Only<S2SV_blank>progressive<S2SV_blank>scan<S2SV_blank>handled.\\n"" ) ; return - 1 ; } _y4m -> vpx_fmt = VPX_IMG_FMT_I420 ;  _y4m -> vpx_bps = 12 ;   if ( strcmp ( _y4m -> chroma_type , ""420"" ) == 0 ||  strcmp ( _y4m -> chroma_type , ""420jpeg"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ;  } else if ( strcmp ( _y4m -> chroma_type , ""420mpeg2"" ) == 0 ) {  _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xmpeg2_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""420paldv"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = 3 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xpaldv_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""422jpeg"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422jpeg_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""422"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I422 ;  _y4m -> vpx_bps = 16 ;  _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;  _y4m -> convert = y4m_convert_null ;  } } else if ( strcmp ( _y4m -> chroma_type , ""411"" ) == 0 ) { _y4m -> src_c_dec_h = 4 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 3 ) / 4 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_411_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""444"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I444 ;  _y4m -> vpx_bps = 24 ;  _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; }  } else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) {  _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ;  if ( only_420 ) {   _y4m -> dst_c_dec_h = 2 ;  _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> vpx_bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , ""mono"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else {  fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n"" , _y4m -> chroma_type ) ;  return - 1 ; }  _y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h  + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;  _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ;   _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ;  return 0 ; }","fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p10<S2SV_blank>to<S2SV_blank>420jpeg\\\return - 1 ;}}else if ( strcmp ( _y4m -> chroma_type , ""444p12"" ) == 0 ) {_y4m -> src_c_dec_h = 1 ;_y4m -> src_c_dec_v = 1 ;_y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ;_y4m -> bps = 36 ;_y4m -> bit_depth = 12 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;_y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;_y4m -> convert = y4m_convert_null ;if ( only_420 ) {fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p12<S2SV_blank>to<S2SV_blank>420jpeg\\\return - 1 ;}}else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) {_y4m -> src_c_dec_h = 1 ;_y4m -> src_c_dec_v = 1 ;if ( only_420 ) {_y4m -> dst_c_dec_h = 2 ;_y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ;_y4m -> convert = y4m_convert_444_420jpeg ;}else {_y4m -> vpx_fmt = VPX_IMG_FMT_444A ;_y4m -> bps = 32 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;_y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;_y4m -> convert = y4m_convert_null ;}}else if ( strcmp ( _y4m -> chroma_type , ""mono"" ) == 0 ) {_y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ;_y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;_y4m -> convert = y4m_convert_mono_420jpeg ;}else {fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\\return - 1 ;_y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;if ( _y4m -> bit_depth == 8 ) _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ;else _y4m -> dst_buf = ( unsigned char * ) malloc ( 2 * _y4m -> dst_buf_sz ) ;if ( _y4m -> aux_buf_sz > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ;return 0 ;",1531
468,"buggy line: struct obj * otmp = readobjnam ( buf , ( struct obj * ) 0 ) ;if ( otmp ) {cwe id:CWE-120context: boolean proc_wizkit_line ( buf ) char * buf ; {  struct obj * otmp = readobjnam ( buf , ( struct obj * ) 0 ) ;  if ( otmp ) { if ( otmp != & zeroobj ) wizkit_addinv ( otmp ) ; } else { config_error_add ( ""Bad<S2SV_blank>wizkit<S2SV_blank>item:<S2SV_blank>\\""%.60s\\"""" , buf ) ; return FALSE ; } return TRUE ; }","struct obj * otmp ;if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\\\0' ;otmp = readobjnam ( buf , ( struct obj * ) 0 ) ;if ( otmp ) {",1532
469,"buggy line: long long directory_table_end , table_start ;if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 )  return FALSE ;if ( read_uids_guids ( & table_start ) == FALSE )  return FALSE ;if ( parse_exports_table ( & table_start ) == FALSE )  return FALSE ;if ( read_fragment_table ( & directory_table_end ) == FALSE )  return FALSE ;if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE )  return FALSE ;if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ;}cwe id:CWE-20context: int read_filesystem_tables_4 ( ) {  long long directory_table_end , table_start ;  if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 )  return FALSE ;  if ( read_uids_guids ( & table_start ) == FALSE )  return FALSE ;  if ( parse_exports_table ( & table_start ) == FALSE )  return FALSE ;   if ( read_fragment_table ( & directory_table_end ) == FALSE )  return FALSE ; if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE )  return FALSE ;  if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ; if ( no_xattrs ) sBlk . s . xattr_id_table_start = SQUASHFS_INVALID_BLK ; return TRUE ;  } ","long long table_start ;if ( sBlk . s . xattr_id_table_start != SQUASHFS_INVALID_BLK ) {if ( sBlk . s . xattr_id_table_start >= sBlk . s . bytes_used ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 ) goto corrupted ;}else table_start = sBlk . s . bytes_used ;if ( sBlk . s . id_table_start >= table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( sBlk . s . no_ids == 0 ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( sBlk . s . no_ids > ( sBlk . s . inodes * 2L ) ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( read_id_table ( & table_start ) == FALSE ) goto corrupted ;if ( sBlk . s . lookup_table_start != SQUASHFS_INVALID_BLK ) {if ( sBlk . s . lookup_table_start >= table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>lookup<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( parse_exports_table ( & table_start ) == FALSE ) goto corrupted ;}if ( sBlk . s . fragments != 0 ) {if ( sBlk . s . fragment_table_start >= table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( sBlk . s . fragments > sBlk . s . inodes ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( read_fragment_table ( & table_start ) == FALSE ) goto corrupted ;}else {if ( sBlk . s . fragment_table_start != table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>invalid<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}}if ( sBlk . s . directory_table_start >= table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>directory<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( read_directory_table ( sBlk . s . directory_table_start , table_start ) == FALSE ) goto corrupted ;if ( sBlk . s . inode_table_start >= sBlk . s . directory_table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>inode<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE ) return FALSE ;if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ;corrupted : ERROR ( ""File<S2SV_blank>system<S2SV_blank>corruption<S2SV_blank>detected\\\return FALSE ;}",1533
470,"buggy line: static struct env *  createenv ( const struct rule * rule )  {env -> count = 0 ;if ( rule -> options & KEEPENV ) {cwe id:CWE-732context: static struct env *  createenv ( const struct rule * rule )  { struct env * env ; u_int i ; env = malloc ( sizeof ( * env ) ) ; if ( ! env ) err ( 1 , NULL ) ; RB_INIT ( & env -> root ) ;  env -> count = 0 ;  if ( rule -> options & KEEPENV ) { extern char * * environ ; for ( i = 0 ; environ [ i ] != NULL ; i ++ ) { struct envnode * node ; const char * e , * eq ; size_t len ; char keybuf [ 1024 ] ; e = environ [ i ] ; if ( ( eq = strchr ( e , '=' ) ) == NULL || eq == e ) continue ; len = eq - e ; if ( len > sizeof ( keybuf ) - 1 ) continue ; memcpy ( keybuf , e , len ) ; keybuf [ len ] = '\\0' ; node = createnode ( keybuf , eq + 1 ) ; if ( RB_INSERT ( envtree , & env -> root , node ) ) { freenode ( node ) ; } else { env -> count ++ ; } }  }  return env ; }","static struct env * createenv ( const struct rule * rule , const struct passwd * mypw , const struct passwd * targpw ) {env -> count = 0 ;addnode ( env , ""DOAS_USER"" , mypw -> pw_name ) ;if ( rule -> options & KEEPENV ) {",1534
471,"buggy line: }return env ;cwe id:CWE-732context: static struct env *  createenv ( const struct rule * rule )  { struct env * env ; u_int i ; env = malloc ( sizeof ( * env ) ) ; if ( ! env ) err ( 1 , NULL ) ; RB_INIT ( & env -> root ) ;  env -> count = 0 ;  if ( rule -> options & KEEPENV ) { extern char * * environ ; for ( i = 0 ; environ [ i ] != NULL ; i ++ ) { struct envnode * node ; const char * e , * eq ; size_t len ; char keybuf [ 1024 ] ; e = environ [ i ] ; if ( ( eq = strchr ( e , '=' ) ) == NULL || eq == e ) continue ; len = eq - e ; if ( len > sizeof ( keybuf ) - 1 ) continue ; memcpy ( keybuf , e , len ) ; keybuf [ len ] = '\\0' ; node = createnode ( keybuf , eq + 1 ) ; if ( RB_INSERT ( envtree , & env -> root , node ) ) { freenode ( node ) ; } else { env -> count ++ ; } }  }  return env ; }","}else {static const char * copyset [ ] = {""DISPLAY"" , ""TERM"" , NULL };addnode ( env , ""HOME"" , targpw -> pw_dir ) ;addnode ( env , ""LOGNAME"" , targpw -> pw_name ) ;addnode ( env , ""PATH"" , getenv ( ""PATH"" ) ) ;addnode ( env , ""SHELL"" , targpw -> pw_shell ) ;addnode ( env , ""USER"" , targpw -> pw_name ) ;fillenv ( env , copyset ) ;}return env ;",1534
472,"buggy line: if ( unlikely ( skb -> len <= mss ) ) goto out ;if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) {int type = skb_shinfo ( skb ) -> gso_type ;if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ;skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ;segs = NULL ;goto out ;}if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ;else {offset = skb_checksum_start_offset ( skb ) ;csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ;offset += skb -> csum_offset ;* ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ;skb -> ip_summed = CHECKSUM_NONE ;tnl_hlen = skb_tnl_header_len ( skb ) ;if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) {if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ;cwe id:CWE-189context: static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ; else { offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len ( skb ) ;  if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) {  if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ; segs = skb_segment ( skb , features ) ; } out : return segs ; }","if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) {if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ;",1535
473,"buggy line: vp9_clear_system_state ( ) ;if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) {vpx_memset ( cpi -> segmentation_map , 0 , cm -> mi_rows * cm -> mi_cols ) ;vpx_memset ( cpi -> complexity_map , 0 , cm -> mi_rows * cm -> mi_cols ) ;vp9_enable_segmentation ( seg ) ;vp9_disable_segfeature ( seg , 0 , SEG_LVL_ALT_Q ) ;for ( segment = 1 ;segment < 2 ;segment ++ ) {const int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex ,  in_frame_q_adj_ratio [ segment ] ) ;vp9_enable_segfeature ( seg , segment , SEG_LVL_ALT_Q ) ;}cwe id:CWE-119context: void vp9_setup_in_frame_q_adj ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; struct segmentation * const seg = & cm -> seg ;  vp9_clear_system_state ( ) ;  if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { int segment ;  vpx_memset ( cpi -> segmentation_map , 0 , cm -> mi_rows * cm -> mi_cols ) ;  vpx_memset ( cpi -> complexity_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , 0 , SEG_LVL_ALT_Q ) ; for ( segment = 1 ; segment < 2 ; segment ++ ) { const int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex ,  in_frame_q_adj_ratio [ segment ] ) ;  vp9_enable_segfeature ( seg , segment , SEG_LVL_ALT_Q ) ; vp9_set_segdata ( seg , segment , SEG_LVL_ALT_Q , qindex_delta ) ; } }  } ","vpx_clear_system_state ( ) ;if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) {const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ;memset ( cpi -> segmentation_map , DEFAULT_AQ2_SEG , cm -> mi_rows * cm -> mi_cols ) ;if ( cpi -> rc . sb64_target_rate < 256 ) {vp9_disable_segmentation ( seg ) ;return ;}vp9_enable_segmentation ( seg ) ;vp9_disable_segfeature ( seg , DEFAULT_AQ2_SEG , SEG_LVL_ALT_Q ) ;for ( segment = 0 ;segment < AQ_C_SEGMENTS ;++ segment ) {int qindex_delta ;if ( segment == DEFAULT_AQ2_SEG ) continue ;qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , aq_c_q_adj_factor [ aq_strength ] [ segment ] , cm -> bit_depth ) ;if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) {qindex_delta = - cm -> base_qindex + 1 ;}if ( ( cm -> base_qindex + qindex_delta ) > 0 ) {vp9_enable_segfeature ( seg , segment , SEG_LVL_ALT_Q ) ;}}",1536
474,"buggy line: if ( ! mod_type ) return 0 ;if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ;Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ;if ( ! Module_type ) return 0 ;Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields ,  1 ) ;if ( ! Interactive_type ) return 0 ;Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ;if ( ! Expression_type ) return 0 ;if ( ! Suite_type ) return 0 ;stmt_type = make_type ( ""stmt"" , & AST_type , NULL , 0 ) ;if ( ! stmt_type ) return 0 ;if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ;FunctionDef_type = make_type ( ""FunctionDef"" , stmt_type , FunctionDef_fields ,  5 ) ;if ( ! FunctionDef_type ) return 0 ;AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type ,  AsyncFunctionDef_fields , 5 ) ;if ( ! AsyncFunctionDef_type ) return 0 ;ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ;if ( ! ClassDef_type ) return 0 ;Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ;if ( ! Return_type ) return 0 ;Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ;if ( ! Delete_type ) return 0 ;Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 2 ) ;if ( ! Assign_type ) return 0 ;AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ;if ( ! AugAssign_type ) return 0 ;AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ;if ( ! AnnAssign_type ) return 0 ;For_type = make_type ( ""For"" , stmt_type , For_fields , 4 ) ;AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , AsyncFor_fields , 4 ) ;While_type = make_type ( ""While"" , stmt_type , While_fields , 3 ) ;If_type = make_type ( ""If"" , stmt_type , If_fields , 3 ) ;cwe id:CWE-125context: static int init_types ( void ) { static int initialized ; if ( initialized ) return 1 ; if ( add_ast_fields ( ) < 0 ) return 0 ; mod_type = make_type ( ""mod"" , & AST_type , NULL , 0 ) ; if ( ! mod_type ) return 0 ; if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ;  Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ;   if ( ! Module_type ) return 0 ;   Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields ,  1 ) ;  if ( ! Interactive_type ) return 0 ;   Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ;  if ( ! Expression_type ) return 0 ; Suite_type = make_type ( ""Suite"" , mod_type , Suite_fields , 1 ) ; if ( ! Suite_type ) return 0 ; stmt_type = make_type ( ""stmt"" , & AST_type , NULL , 0 ) ; if ( ! stmt_type ) return 0 ; if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ; FunctionDef_type = make_type ( ""FunctionDef"" , stmt_type , FunctionDef_fields ,  5 ) ;   if ( ! FunctionDef_type ) return 0 ;  AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type ,  AsyncFunctionDef_fields , 5 ) ;   if ( ! AsyncFunctionDef_type ) return 0 ;   ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ;   if ( ! ClassDef_type ) return 0 ;   Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ;  if ( ! Return_type ) return 0 ;  Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ;  if ( ! Delete_type ) return 0 ;  Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 2 ) ;  if ( ! Assign_type ) return 0 ;  AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ;  if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields , 4 ) ; if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , AsyncFor_fields , 4 ) ; if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" , stmt_type , With_fields , 2 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" , stmt_type , AsyncWith_fields , 2 ) ; if ( ! AsyncWith_type ) return 0 ; Raise_type = make_type ( ""Raise"" , stmt_type , Raise_fields , 2 ) ; if ( ! Raise_type ) return 0 ; Try_type = make_type ( ""Try"" , stmt_type , Try_fields , 4 ) ; if ( ! Try_type ) return 0 ; Assert_type = make_type ( ""Assert"" , stmt_type , Assert_fields , 2 ) ; if ( ! Assert_type ) return 0 ; Import_type = make_type ( ""Import"" , stmt_type , Import_fields , 1 ) ; if ( ! Import_type ) return 0 ; ImportFrom_type = make_type ( ""ImportFrom"" , stmt_type , ImportFrom_fields , 3 ) ; if ( ! ImportFrom_type ) return 0 ; Global_type = make_type ( ""Global"" , stmt_type , Global_fields , 1 ) ; if ( ! Global_type ) return 0 ; Nonlocal_type = make_type ( ""Nonlocal"" , stmt_type , Nonlocal_fields , 1 ) ; if ( ! Nonlocal_type ) return 0 ; Expr_type = make_type ( ""Expr"" , stmt_type , Expr_fields , 1 ) ; if ( ! Expr_type ) return 0 ; Pass_type = make_type ( ""Pass"" , stmt_type , NULL , 0 ) ; if ( ! Pass_type ) return 0 ; Break_type = make_type ( ""Break"" , stmt_type , NULL , 0 ) ; if ( ! Break_type ) return 0 ; Continue_type = make_type ( ""Continue"" , stmt_type , NULL , 0 ) ; if ( ! Continue_type ) return 0 ; expr_type = make_type ( ""expr"" , & AST_type , NULL , 0 ) ; if ( ! expr_type ) return 0 ; if ( ! add_attributes ( expr_type , expr_attributes , 4 ) ) return 0 ; BoolOp_type = make_type ( ""BoolOp"" , expr_type , BoolOp_fields , 2 ) ; if ( ! BoolOp_type ) return 0 ; NamedExpr_type = make_type ( ""NamedExpr"" , expr_type , NamedExpr_fields , 2 ) ; if ( ! NamedExpr_type ) return 0 ; BinOp_type = make_type ( ""BinOp"" , expr_type , BinOp_fields , 3 ) ; if ( ! BinOp_type ) return 0 ; UnaryOp_type = make_type ( ""UnaryOp"" , expr_type , UnaryOp_fields , 2 ) ; if ( ! UnaryOp_type ) return 0 ; Lambda_type = make_type ( ""Lambda"" , expr_type , Lambda_fields , 2 ) ; if ( ! Lambda_type ) return 0 ; IfExp_type = make_type ( ""IfExp"" , expr_type , IfExp_fields , 3 ) ; if ( ! IfExp_type ) return 0 ; Dict_type = make_type ( ""Dict"" , expr_type , Dict_fields , 2 ) ; if ( ! Dict_type ) return 0 ; Set_type = make_type ( ""Set"" , expr_type , Set_fields , 1 ) ; if ( ! Set_type ) return 0 ; ListComp_type = make_type ( ""ListComp"" , expr_type , ListComp_fields , 2 ) ; if ( ! ListComp_type ) return 0 ; SetComp_type = make_type ( ""SetComp"" , expr_type , SetComp_fields , 2 ) ; if ( ! SetComp_type ) return 0 ; DictComp_type = make_type ( ""DictComp"" , expr_type , DictComp_fields , 3 ) ; if ( ! DictComp_type ) return 0 ; GeneratorExp_type = make_type ( ""GeneratorExp"" , expr_type , GeneratorExp_fields , 2 ) ; if ( ! GeneratorExp_type ) return 0 ; Await_type = make_type ( ""Await"" , expr_type , Await_fields , 1 ) ; if ( ! Await_type ) return 0 ; Yield_type = make_type ( ""Yield"" , expr_type , Yield_fields , 1 ) ; if ( ! Yield_type ) return 0 ; YieldFrom_type = make_type ( ""YieldFrom"" , expr_type , YieldFrom_fields , 1 ) ; if ( ! YieldFrom_type ) return 0 ; Compare_type = make_type ( ""Compare"" , expr_type , Compare_fields , 3 ) ; if ( ! Compare_type ) return 0 ; Call_type = make_type ( ""Call"" , expr_type , Call_fields , 3 ) ; if ( ! Call_type ) return 0 ; FormattedValue_type = make_type ( ""FormattedValue"" , expr_type , FormattedValue_fields , 3 ) ; if ( ! FormattedValue_type ) return 0 ; JoinedStr_type = make_type ( ""JoinedStr"" , expr_type , JoinedStr_fields , 1 ) ; if ( ! JoinedStr_type ) return 0 ; Constant_type = make_type ( ""Constant"" , expr_type , Constant_fields , 1 ) ; if ( ! Constant_type ) return 0 ; Attribute_type = make_type ( ""Attribute"" , expr_type , Attribute_fields , 3 ) ; if ( ! Attribute_type ) return 0 ; Subscript_type = make_type ( ""Subscript"" , expr_type , Subscript_fields , 3 ) ; if ( ! Subscript_type ) return 0 ; Starred_type = make_type ( ""Starred"" , expr_type , Starred_fields , 2 ) ; if ( ! Starred_type ) return 0 ; Name_type = make_type ( ""Name"" , expr_type , Name_fields , 2 ) ; if ( ! Name_type ) return 0 ; List_type = make_type ( ""List"" , expr_type , List_fields , 2 ) ; if ( ! List_type ) return 0 ; Tuple_type = make_type ( ""Tuple"" , expr_type , Tuple_fields , 2 ) ; if ( ! Tuple_type ) return 0 ; expr_context_type = make_type ( ""expr_context"" , & AST_type , NULL , 0 ) ; if ( ! expr_context_type ) return 0 ; if ( ! add_attributes ( expr_context_type , NULL , 0 ) ) return 0 ; Load_type = make_type ( ""Load"" , expr_context_type , NULL , 0 ) ; if ( ! Load_type ) return 0 ; Load_singleton = PyType_GenericNew ( Load_type , NULL , NULL ) ; if ( ! Load_singleton ) return 0 ; Store_type = make_type ( ""Store"" , expr_context_type , NULL , 0 ) ; if ( ! Store_type ) return 0 ; Store_singleton = PyType_GenericNew ( Store_type , NULL , NULL ) ; if ( ! Store_singleton ) return 0 ; Del_type = make_type ( ""Del"" , expr_context_type , NULL , 0 ) ; if ( ! Del_type ) return 0 ; Del_singleton = PyType_GenericNew ( Del_type , NULL , NULL ) ; if ( ! Del_singleton ) return 0 ; AugLoad_type = make_type ( ""AugLoad"" , expr_context_type , NULL , 0 ) ; if ( ! AugLoad_type ) return 0 ; AugLoad_singleton = PyType_GenericNew ( AugLoad_type , NULL , NULL ) ; if ( ! AugLoad_singleton ) return 0 ; AugStore_type = make_type ( ""AugStore"" , expr_context_type , NULL , 0 ) ; if ( ! AugStore_type ) return 0 ; AugStore_singleton = PyType_GenericNew ( AugStore_type , NULL , NULL ) ; if ( ! AugStore_singleton ) return 0 ; Param_type = make_type ( ""Param"" , expr_context_type , NULL , 0 ) ; if ( ! Param_type ) return 0 ; Param_singleton = PyType_GenericNew ( Param_type , NULL , NULL ) ; if ( ! Param_singleton ) return 0 ; NamedStore_type = make_type ( ""NamedStore"" , expr_context_type , NULL , 0 ) ; if ( ! NamedStore_type ) return 0 ; NamedStore_singleton = PyType_GenericNew ( NamedStore_type , NULL , NULL ) ; if ( ! NamedStore_singleton ) return 0 ; slice_type = make_type ( ""slice"" , & AST_type , NULL , 0 ) ; if ( ! slice_type ) return 0 ; if ( ! add_attributes ( slice_type , NULL , 0 ) ) return 0 ; Slice_type = make_type ( ""Slice"" , slice_type , Slice_fields , 3 ) ; if ( ! Slice_type ) return 0 ; ExtSlice_type = make_type ( ""ExtSlice"" , slice_type , ExtSlice_fields , 1 ) ; if ( ! ExtSlice_type ) return 0 ; Index_type = make_type ( ""Index"" , slice_type , Index_fields , 1 ) ; if ( ! Index_type ) return 0 ; boolop_type = make_type ( ""boolop"" , & AST_type , NULL , 0 ) ; if ( ! boolop_type ) return 0 ; if ( ! add_attributes ( boolop_type , NULL , 0 ) ) return 0 ; And_type = make_type ( ""And"" , boolop_type , NULL , 0 ) ; if ( ! And_type ) return 0 ; And_singleton = PyType_GenericNew ( And_type , NULL , NULL ) ; if ( ! And_singleton ) return 0 ; Or_type = make_type ( ""Or"" , boolop_type , NULL , 0 ) ; if ( ! Or_type ) return 0 ; Or_singleton = PyType_GenericNew ( Or_type , NULL , NULL ) ; if ( ! Or_singleton ) return 0 ; operator_type = make_type ( ""operator"" , & AST_type , NULL , 0 ) ; if ( ! operator_type ) return 0 ; if ( ! add_attributes ( operator_type , NULL , 0 ) ) return 0 ; Add_type = make_type ( ""Add"" , operator_type , NULL , 0 ) ; if ( ! Add_type ) return 0 ; Add_singleton = PyType_GenericNew ( Add_type , NULL , NULL ) ; if ( ! Add_singleton ) return 0 ; Sub_type = make_type ( ""Sub"" , operator_type , NULL , 0 ) ; if ( ! Sub_type ) return 0 ; Sub_singleton = PyType_GenericNew ( Sub_type , NULL , NULL ) ; if ( ! Sub_singleton ) return 0 ; Mult_type = make_type ( ""Mult"" , operator_type , NULL , 0 ) ; if ( ! Mult_type ) return 0 ; Mult_singleton = PyType_GenericNew ( Mult_type , NULL , NULL ) ; if ( ! Mult_singleton ) return 0 ; MatMult_type = make_type ( ""MatMult"" , operator_type , NULL , 0 ) ; if ( ! MatMult_type ) return 0 ; MatMult_singleton = PyType_GenericNew ( MatMult_type , NULL , NULL ) ; if ( ! MatMult_singleton ) return 0 ; Div_type = make_type ( ""Div"" , operator_type , NULL , 0 ) ; if ( ! Div_type ) return 0 ; Div_singleton = PyType_GenericNew ( Div_type , NULL , NULL ) ; if ( ! Div_singleton ) return 0 ; Mod_type = make_type ( ""Mod"" , operator_type , NULL , 0 ) ; if ( ! Mod_type ) return 0 ; Mod_singleton = PyType_GenericNew ( Mod_type , NULL , NULL ) ; if ( ! Mod_singleton ) return 0 ; Pow_type = make_type ( ""Pow"" , operator_type , NULL , 0 ) ; if ( ! Pow_type ) return 0 ; Pow_singleton = PyType_GenericNew ( Pow_type , NULL , NULL ) ; if ( ! Pow_singleton ) return 0 ; LShift_type = make_type ( ""LShift"" , operator_type , NULL , 0 ) ; if ( ! LShift_type ) return 0 ; LShift_singleton = PyType_GenericNew ( LShift_type , NULL , NULL ) ; if ( ! LShift_singleton ) return 0 ; RShift_type = make_type ( ""RShift"" , operator_type , NULL , 0 ) ; if ( ! RShift_type ) return 0 ; RShift_singleton = PyType_GenericNew ( RShift_type , NULL , NULL ) ; if ( ! RShift_singleton ) return 0 ; BitOr_type = make_type ( ""BitOr"" , operator_type , NULL , 0 ) ; if ( ! BitOr_type ) return 0 ; BitOr_singleton = PyType_GenericNew ( BitOr_type , NULL , NULL ) ; if ( ! BitOr_singleton ) return 0 ; BitXor_type = make_type ( ""BitXor"" , operator_type , NULL , 0 ) ; if ( ! BitXor_type ) return 0 ; BitXor_singleton = PyType_GenericNew ( BitXor_type , NULL , NULL ) ; if ( ! BitXor_singleton ) return 0 ; BitAnd_type = make_type ( ""BitAnd"" , operator_type , NULL , 0 ) ; if ( ! BitAnd_type ) return 0 ; BitAnd_singleton = PyType_GenericNew ( BitAnd_type , NULL , NULL ) ; if ( ! BitAnd_singleton ) return 0 ; FloorDiv_type = make_type ( ""FloorDiv"" , operator_type , NULL , 0 ) ; if ( ! FloorDiv_type ) return 0 ; FloorDiv_singleton = PyType_GenericNew ( FloorDiv_type , NULL , NULL ) ; if ( ! FloorDiv_singleton ) return 0 ; unaryop_type = make_type ( ""unaryop"" , & AST_type , NULL , 0 ) ; if ( ! unaryop_type ) return 0 ; if ( ! add_attributes ( unaryop_type , NULL , 0 ) ) return 0 ; Invert_type = make_type ( ""Invert"" , unaryop_type , NULL , 0 ) ; if ( ! Invert_type ) return 0 ; Invert_singleton = PyType_GenericNew ( Invert_type , NULL , NULL ) ; if ( ! Invert_singleton ) return 0 ; Not_type = make_type ( ""Not"" , unaryop_type , NULL , 0 ) ; if ( ! Not_type ) return 0 ; Not_singleton = PyType_GenericNew ( Not_type , NULL , NULL ) ; if ( ! Not_singleton ) return 0 ; UAdd_type = make_type ( ""UAdd"" , unaryop_type , NULL , 0 ) ; if ( ! UAdd_type ) return 0 ; UAdd_singleton = PyType_GenericNew ( UAdd_type , NULL , NULL ) ; if ( ! UAdd_singleton ) return 0 ; USub_type = make_type ( ""USub"" , unaryop_type , NULL , 0 ) ; if ( ! USub_type ) return 0 ; USub_singleton = PyType_GenericNew ( USub_type , NULL , NULL ) ; if ( ! USub_singleton ) return 0 ; cmpop_type = make_type ( ""cmpop"" , & AST_type , NULL , 0 ) ; if ( ! cmpop_type ) return 0 ; if ( ! add_attributes ( cmpop_type , NULL , 0 ) ) return 0 ; Eq_type = make_type ( ""Eq"" , cmpop_type , NULL , 0 ) ; if ( ! Eq_type ) return 0 ; Eq_singleton = PyType_GenericNew ( Eq_type , NULL , NULL ) ; if ( ! Eq_singleton ) return 0 ; NotEq_type = make_type ( ""NotEq"" , cmpop_type , NULL , 0 ) ; if ( ! NotEq_type ) return 0 ; NotEq_singleton = PyType_GenericNew ( NotEq_type , NULL , NULL ) ; if ( ! NotEq_singleton ) return 0 ; Lt_type = make_type ( ""Lt"" , cmpop_type , NULL , 0 ) ; if ( ! Lt_type ) return 0 ; Lt_singleton = PyType_GenericNew ( Lt_type , NULL , NULL ) ; if ( ! Lt_singleton ) return 0 ; LtE_type = make_type ( ""LtE"" , cmpop_type , NULL , 0 ) ; if ( ! LtE_type ) return 0 ; LtE_singleton = PyType_GenericNew ( LtE_type , NULL , NULL ) ; if ( ! LtE_singleton ) return 0 ; Gt_type = make_type ( ""Gt"" , cmpop_type , NULL , 0 ) ; if ( ! Gt_type ) return 0 ; Gt_singleton = PyType_GenericNew ( Gt_type , NULL , NULL ) ; if ( ! Gt_singleton ) return 0 ; GtE_type = make_type ( ""GtE"" , cmpop_type , NULL , 0 ) ; if ( ! GtE_type ) return 0 ; GtE_singleton = PyType_GenericNew ( GtE_type , NULL , NULL ) ; if ( ! GtE_singleton ) return 0 ; Is_type = make_type ( ""Is"" , cmpop_type , NULL , 0 ) ; if ( ! Is_type ) return 0 ; Is_singleton = PyType_GenericNew ( Is_type , NULL , NULL ) ; if ( ! Is_singleton ) return 0 ; IsNot_type = make_type ( ""IsNot"" , cmpop_type , NULL , 0 ) ; if ( ! IsNot_type ) return 0 ; IsNot_singleton = PyType_GenericNew ( IsNot_type , NULL , NULL ) ; if ( ! IsNot_singleton ) return 0 ; In_type = make_type ( ""In"" , cmpop_type , NULL , 0 ) ; if ( ! In_type ) return 0 ; In_singleton = PyType_GenericNew ( In_type , NULL , NULL ) ; if ( ! In_singleton ) return 0 ; NotIn_type = make_type ( ""NotIn"" , cmpop_type , NULL , 0 ) ; if ( ! NotIn_type ) return 0 ; NotIn_singleton = PyType_GenericNew ( NotIn_type , NULL , NULL ) ; if ( ! NotIn_singleton ) return 0 ; comprehension_type = make_type ( ""comprehension"" , & AST_type , comprehension_fields , 4 ) ; if ( ! comprehension_type ) return 0 ; if ( ! add_attributes ( comprehension_type , NULL , 0 ) ) return 0 ; excepthandler_type = make_type ( ""excepthandler"" , & AST_type , NULL , 0 ) ; if ( ! excepthandler_type ) return 0 ; if ( ! add_attributes ( excepthandler_type , excepthandler_attributes , 4 ) ) return 0 ; ExceptHandler_type = make_type ( ""ExceptHandler"" , excepthandler_type , ExceptHandler_fields , 3 ) ; if ( ! ExceptHandler_type ) return 0 ; arguments_type = make_type ( ""arguments"" , & AST_type , arguments_fields , 6 ) ; if ( ! arguments_type ) return 0 ; if ( ! add_attributes ( arguments_type , NULL , 0 ) ) return 0 ;  arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 2 ) ;  if ( ! arg_type ) return 0 ; if ( ! add_attributes ( arg_type , arg_attributes , 4 ) ) return 0 ; keyword_type = make_type ( ""keyword"" , & AST_type , keyword_fields , 2 ) ; if ( ! keyword_type ) return 0 ; if ( ! add_attributes ( keyword_type , NULL , 0 ) ) return 0 ; alias_type = make_type ( ""alias"" , & AST_type , alias_fields , 2 ) ; if ( ! alias_type ) return 0 ; if ( ! add_attributes ( alias_type , NULL , 0 ) ) return 0 ; withitem_type = make_type ( ""withitem"" , & AST_type , withitem_fields , 2 ) ; if ( ! withitem_type ) return 0 ; if ( ! add_attributes ( withitem_type , NULL , 0 ) ) return 0 ;  initialized = 1 ;  return 1 ; }","if ( ! Interactive_type ) return 0 ;Expression_type = make_type ( ""Expression"" , mod_type , Module_fields , 2 ) ;if ( ! Module_type ) return 0 ;Interactive_type = make_type ( ""Interactive"" , mod_type , Expression_fields , 1 ) ;if ( ! Expression_type ) return 0 ;FunctionType_type = make_type ( ""FunctionType"" , mod_type , Interactive_fields , 1 ) ;if ( ! Interactive_type ) return 0 ;Expression_type = make_type ( ""Expression"" , mod_type , FunctionType_fields , 2 ) ;if ( ! FunctionType_type ) return 0 ;if ( ! ClassDef_type ) return 0 ;Return_type = make_type ( ""Return"" , stmt_type , FunctionDef_fields , 6 ) ;if ( ! FunctionDef_type ) return 0 ;AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , AsyncFunctionDef_fields , 6 ) ;if ( ! AsyncFunctionDef_type ) return 0 ;ClassDef_type = make_type ( ""ClassDef"" , stmt_type , Return_fields , 1 ) ;AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , Delete_fields , 1 ) ;if ( ! Delete_type ) return 0 ;Assign_type = make_type ( ""Assign"" , stmt_type , AsyncFor_fields , 5 ) ;if ( ! FunctionDef_type ) return 0 ;AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , AsyncFunctionDef_fields , 5 ) ;if ( ! AsyncFunctionDef_type ) return 0 ;ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ;if ( ! ClassDef_type ) return 0 ;Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ;While_type = make_type ( ""While"" , stmt_type , Delete_fields , 1 ) ;if ( ! Delete_type ) return 0 ;Assign_type = make_type ( ""Assign"" , stmt_type , While_fields , 3 ) ;If_type = make_type ( ""If"" , stmt_type , AugAssign_fields , 3 ) ;if ( ! AugAssign_type ) return 0 ;AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , If_fields , 3 ) ;if ( ! If_type ) return 0 ;With_type = make_type ( ""With"" , stmt_type , For_fields , 4 ) ;if ( ! For_type ) return 0 ;AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , With_fields , 3 ) ;if ( ! With_type ) return 0 ;AsyncWith_type = make_type ( ""AsyncWith"" , stmt_type , While_fields , 3 ) ;if ( ! While_type ) return 0 ;If_type = make_type ( ""If"" , stmt_type , AsyncWith_fields , 3 ) ;",1537
475,"buggy line: arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 2 ) ;if ( ! arg_type ) return 0 ;cwe id:CWE-125context: static int init_types ( void ) { static int initialized ; if ( initialized ) return 1 ; if ( add_ast_fields ( ) < 0 ) return 0 ; mod_type = make_type ( ""mod"" , & AST_type , NULL , 0 ) ; if ( ! mod_type ) return 0 ; if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ;  Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ;   if ( ! Module_type ) return 0 ;   Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields ,  1 ) ;  if ( ! Interactive_type ) return 0 ;   Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ;  if ( ! Expression_type ) return 0 ; Suite_type = make_type ( ""Suite"" , mod_type , Suite_fields , 1 ) ; if ( ! Suite_type ) return 0 ; stmt_type = make_type ( ""stmt"" , & AST_type , NULL , 0 ) ; if ( ! stmt_type ) return 0 ; if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ; FunctionDef_type = make_type ( ""FunctionDef"" , stmt_type , FunctionDef_fields ,  5 ) ;   if ( ! FunctionDef_type ) return 0 ;  AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type ,  AsyncFunctionDef_fields , 5 ) ;   if ( ! AsyncFunctionDef_type ) return 0 ;   ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ;   if ( ! ClassDef_type ) return 0 ;   Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ;  if ( ! Return_type ) return 0 ;  Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ;  if ( ! Delete_type ) return 0 ;  Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 2 ) ;  if ( ! Assign_type ) return 0 ;  AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ;  if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields , 4 ) ; if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , AsyncFor_fields , 4 ) ; if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" , stmt_type , With_fields , 2 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" , stmt_type , AsyncWith_fields , 2 ) ; if ( ! AsyncWith_type ) return 0 ; Raise_type = make_type ( ""Raise"" , stmt_type , Raise_fields , 2 ) ; if ( ! Raise_type ) return 0 ; Try_type = make_type ( ""Try"" , stmt_type , Try_fields , 4 ) ; if ( ! Try_type ) return 0 ; Assert_type = make_type ( ""Assert"" , stmt_type , Assert_fields , 2 ) ; if ( ! Assert_type ) return 0 ; Import_type = make_type ( ""Import"" , stmt_type , Import_fields , 1 ) ; if ( ! Import_type ) return 0 ; ImportFrom_type = make_type ( ""ImportFrom"" , stmt_type , ImportFrom_fields , 3 ) ; if ( ! ImportFrom_type ) return 0 ; Global_type = make_type ( ""Global"" , stmt_type , Global_fields , 1 ) ; if ( ! Global_type ) return 0 ; Nonlocal_type = make_type ( ""Nonlocal"" , stmt_type , Nonlocal_fields , 1 ) ; if ( ! Nonlocal_type ) return 0 ; Expr_type = make_type ( ""Expr"" , stmt_type , Expr_fields , 1 ) ; if ( ! Expr_type ) return 0 ; Pass_type = make_type ( ""Pass"" , stmt_type , NULL , 0 ) ; if ( ! Pass_type ) return 0 ; Break_type = make_type ( ""Break"" , stmt_type , NULL , 0 ) ; if ( ! Break_type ) return 0 ; Continue_type = make_type ( ""Continue"" , stmt_type , NULL , 0 ) ; if ( ! Continue_type ) return 0 ; expr_type = make_type ( ""expr"" , & AST_type , NULL , 0 ) ; if ( ! expr_type ) return 0 ; if ( ! add_attributes ( expr_type , expr_attributes , 4 ) ) return 0 ; BoolOp_type = make_type ( ""BoolOp"" , expr_type , BoolOp_fields , 2 ) ; if ( ! BoolOp_type ) return 0 ; NamedExpr_type = make_type ( ""NamedExpr"" , expr_type , NamedExpr_fields , 2 ) ; if ( ! NamedExpr_type ) return 0 ; BinOp_type = make_type ( ""BinOp"" , expr_type , BinOp_fields , 3 ) ; if ( ! BinOp_type ) return 0 ; UnaryOp_type = make_type ( ""UnaryOp"" , expr_type , UnaryOp_fields , 2 ) ; if ( ! UnaryOp_type ) return 0 ; Lambda_type = make_type ( ""Lambda"" , expr_type , Lambda_fields , 2 ) ; if ( ! Lambda_type ) return 0 ; IfExp_type = make_type ( ""IfExp"" , expr_type , IfExp_fields , 3 ) ; if ( ! IfExp_type ) return 0 ; Dict_type = make_type ( ""Dict"" , expr_type , Dict_fields , 2 ) ; if ( ! Dict_type ) return 0 ; Set_type = make_type ( ""Set"" , expr_type , Set_fields , 1 ) ; if ( ! Set_type ) return 0 ; ListComp_type = make_type ( ""ListComp"" , expr_type , ListComp_fields , 2 ) ; if ( ! ListComp_type ) return 0 ; SetComp_type = make_type ( ""SetComp"" , expr_type , SetComp_fields , 2 ) ; if ( ! SetComp_type ) return 0 ; DictComp_type = make_type ( ""DictComp"" , expr_type , DictComp_fields , 3 ) ; if ( ! DictComp_type ) return 0 ; GeneratorExp_type = make_type ( ""GeneratorExp"" , expr_type , GeneratorExp_fields , 2 ) ; if ( ! GeneratorExp_type ) return 0 ; Await_type = make_type ( ""Await"" , expr_type , Await_fields , 1 ) ; if ( ! Await_type ) return 0 ; Yield_type = make_type ( ""Yield"" , expr_type , Yield_fields , 1 ) ; if ( ! Yield_type ) return 0 ; YieldFrom_type = make_type ( ""YieldFrom"" , expr_type , YieldFrom_fields , 1 ) ; if ( ! YieldFrom_type ) return 0 ; Compare_type = make_type ( ""Compare"" , expr_type , Compare_fields , 3 ) ; if ( ! Compare_type ) return 0 ; Call_type = make_type ( ""Call"" , expr_type , Call_fields , 3 ) ; if ( ! Call_type ) return 0 ; FormattedValue_type = make_type ( ""FormattedValue"" , expr_type , FormattedValue_fields , 3 ) ; if ( ! FormattedValue_type ) return 0 ; JoinedStr_type = make_type ( ""JoinedStr"" , expr_type , JoinedStr_fields , 1 ) ; if ( ! JoinedStr_type ) return 0 ; Constant_type = make_type ( ""Constant"" , expr_type , Constant_fields , 1 ) ; if ( ! Constant_type ) return 0 ; Attribute_type = make_type ( ""Attribute"" , expr_type , Attribute_fields , 3 ) ; if ( ! Attribute_type ) return 0 ; Subscript_type = make_type ( ""Subscript"" , expr_type , Subscript_fields , 3 ) ; if ( ! Subscript_type ) return 0 ; Starred_type = make_type ( ""Starred"" , expr_type , Starred_fields , 2 ) ; if ( ! Starred_type ) return 0 ; Name_type = make_type ( ""Name"" , expr_type , Name_fields , 2 ) ; if ( ! Name_type ) return 0 ; List_type = make_type ( ""List"" , expr_type , List_fields , 2 ) ; if ( ! List_type ) return 0 ; Tuple_type = make_type ( ""Tuple"" , expr_type , Tuple_fields , 2 ) ; if ( ! Tuple_type ) return 0 ; expr_context_type = make_type ( ""expr_context"" , & AST_type , NULL , 0 ) ; if ( ! expr_context_type ) return 0 ; if ( ! add_attributes ( expr_context_type , NULL , 0 ) ) return 0 ; Load_type = make_type ( ""Load"" , expr_context_type , NULL , 0 ) ; if ( ! Load_type ) return 0 ; Load_singleton = PyType_GenericNew ( Load_type , NULL , NULL ) ; if ( ! Load_singleton ) return 0 ; Store_type = make_type ( ""Store"" , expr_context_type , NULL , 0 ) ; if ( ! Store_type ) return 0 ; Store_singleton = PyType_GenericNew ( Store_type , NULL , NULL ) ; if ( ! Store_singleton ) return 0 ; Del_type = make_type ( ""Del"" , expr_context_type , NULL , 0 ) ; if ( ! Del_type ) return 0 ; Del_singleton = PyType_GenericNew ( Del_type , NULL , NULL ) ; if ( ! Del_singleton ) return 0 ; AugLoad_type = make_type ( ""AugLoad"" , expr_context_type , NULL , 0 ) ; if ( ! AugLoad_type ) return 0 ; AugLoad_singleton = PyType_GenericNew ( AugLoad_type , NULL , NULL ) ; if ( ! AugLoad_singleton ) return 0 ; AugStore_type = make_type ( ""AugStore"" , expr_context_type , NULL , 0 ) ; if ( ! AugStore_type ) return 0 ; AugStore_singleton = PyType_GenericNew ( AugStore_type , NULL , NULL ) ; if ( ! AugStore_singleton ) return 0 ; Param_type = make_type ( ""Param"" , expr_context_type , NULL , 0 ) ; if ( ! Param_type ) return 0 ; Param_singleton = PyType_GenericNew ( Param_type , NULL , NULL ) ; if ( ! Param_singleton ) return 0 ; NamedStore_type = make_type ( ""NamedStore"" , expr_context_type , NULL , 0 ) ; if ( ! NamedStore_type ) return 0 ; NamedStore_singleton = PyType_GenericNew ( NamedStore_type , NULL , NULL ) ; if ( ! NamedStore_singleton ) return 0 ; slice_type = make_type ( ""slice"" , & AST_type , NULL , 0 ) ; if ( ! slice_type ) return 0 ; if ( ! add_attributes ( slice_type , NULL , 0 ) ) return 0 ; Slice_type = make_type ( ""Slice"" , slice_type , Slice_fields , 3 ) ; if ( ! Slice_type ) return 0 ; ExtSlice_type = make_type ( ""ExtSlice"" , slice_type , ExtSlice_fields , 1 ) ; if ( ! ExtSlice_type ) return 0 ; Index_type = make_type ( ""Index"" , slice_type , Index_fields , 1 ) ; if ( ! Index_type ) return 0 ; boolop_type = make_type ( ""boolop"" , & AST_type , NULL , 0 ) ; if ( ! boolop_type ) return 0 ; if ( ! add_attributes ( boolop_type , NULL , 0 ) ) return 0 ; And_type = make_type ( ""And"" , boolop_type , NULL , 0 ) ; if ( ! And_type ) return 0 ; And_singleton = PyType_GenericNew ( And_type , NULL , NULL ) ; if ( ! And_singleton ) return 0 ; Or_type = make_type ( ""Or"" , boolop_type , NULL , 0 ) ; if ( ! Or_type ) return 0 ; Or_singleton = PyType_GenericNew ( Or_type , NULL , NULL ) ; if ( ! Or_singleton ) return 0 ; operator_type = make_type ( ""operator"" , & AST_type , NULL , 0 ) ; if ( ! operator_type ) return 0 ; if ( ! add_attributes ( operator_type , NULL , 0 ) ) return 0 ; Add_type = make_type ( ""Add"" , operator_type , NULL , 0 ) ; if ( ! Add_type ) return 0 ; Add_singleton = PyType_GenericNew ( Add_type , NULL , NULL ) ; if ( ! Add_singleton ) return 0 ; Sub_type = make_type ( ""Sub"" , operator_type , NULL , 0 ) ; if ( ! Sub_type ) return 0 ; Sub_singleton = PyType_GenericNew ( Sub_type , NULL , NULL ) ; if ( ! Sub_singleton ) return 0 ; Mult_type = make_type ( ""Mult"" , operator_type , NULL , 0 ) ; if ( ! Mult_type ) return 0 ; Mult_singleton = PyType_GenericNew ( Mult_type , NULL , NULL ) ; if ( ! Mult_singleton ) return 0 ; MatMult_type = make_type ( ""MatMult"" , operator_type , NULL , 0 ) ; if ( ! MatMult_type ) return 0 ; MatMult_singleton = PyType_GenericNew ( MatMult_type , NULL , NULL ) ; if ( ! MatMult_singleton ) return 0 ; Div_type = make_type ( ""Div"" , operator_type , NULL , 0 ) ; if ( ! Div_type ) return 0 ; Div_singleton = PyType_GenericNew ( Div_type , NULL , NULL ) ; if ( ! Div_singleton ) return 0 ; Mod_type = make_type ( ""Mod"" , operator_type , NULL , 0 ) ; if ( ! Mod_type ) return 0 ; Mod_singleton = PyType_GenericNew ( Mod_type , NULL , NULL ) ; if ( ! Mod_singleton ) return 0 ; Pow_type = make_type ( ""Pow"" , operator_type , NULL , 0 ) ; if ( ! Pow_type ) return 0 ; Pow_singleton = PyType_GenericNew ( Pow_type , NULL , NULL ) ; if ( ! Pow_singleton ) return 0 ; LShift_type = make_type ( ""LShift"" , operator_type , NULL , 0 ) ; if ( ! LShift_type ) return 0 ; LShift_singleton = PyType_GenericNew ( LShift_type , NULL , NULL ) ; if ( ! LShift_singleton ) return 0 ; RShift_type = make_type ( ""RShift"" , operator_type , NULL , 0 ) ; if ( ! RShift_type ) return 0 ; RShift_singleton = PyType_GenericNew ( RShift_type , NULL , NULL ) ; if ( ! RShift_singleton ) return 0 ; BitOr_type = make_type ( ""BitOr"" , operator_type , NULL , 0 ) ; if ( ! BitOr_type ) return 0 ; BitOr_singleton = PyType_GenericNew ( BitOr_type , NULL , NULL ) ; if ( ! BitOr_singleton ) return 0 ; BitXor_type = make_type ( ""BitXor"" , operator_type , NULL , 0 ) ; if ( ! BitXor_type ) return 0 ; BitXor_singleton = PyType_GenericNew ( BitXor_type , NULL , NULL ) ; if ( ! BitXor_singleton ) return 0 ; BitAnd_type = make_type ( ""BitAnd"" , operator_type , NULL , 0 ) ; if ( ! BitAnd_type ) return 0 ; BitAnd_singleton = PyType_GenericNew ( BitAnd_type , NULL , NULL ) ; if ( ! BitAnd_singleton ) return 0 ; FloorDiv_type = make_type ( ""FloorDiv"" , operator_type , NULL , 0 ) ; if ( ! FloorDiv_type ) return 0 ; FloorDiv_singleton = PyType_GenericNew ( FloorDiv_type , NULL , NULL ) ; if ( ! FloorDiv_singleton ) return 0 ; unaryop_type = make_type ( ""unaryop"" , & AST_type , NULL , 0 ) ; if ( ! unaryop_type ) return 0 ; if ( ! add_attributes ( unaryop_type , NULL , 0 ) ) return 0 ; Invert_type = make_type ( ""Invert"" , unaryop_type , NULL , 0 ) ; if ( ! Invert_type ) return 0 ; Invert_singleton = PyType_GenericNew ( Invert_type , NULL , NULL ) ; if ( ! Invert_singleton ) return 0 ; Not_type = make_type ( ""Not"" , unaryop_type , NULL , 0 ) ; if ( ! Not_type ) return 0 ; Not_singleton = PyType_GenericNew ( Not_type , NULL , NULL ) ; if ( ! Not_singleton ) return 0 ; UAdd_type = make_type ( ""UAdd"" , unaryop_type , NULL , 0 ) ; if ( ! UAdd_type ) return 0 ; UAdd_singleton = PyType_GenericNew ( UAdd_type , NULL , NULL ) ; if ( ! UAdd_singleton ) return 0 ; USub_type = make_type ( ""USub"" , unaryop_type , NULL , 0 ) ; if ( ! USub_type ) return 0 ; USub_singleton = PyType_GenericNew ( USub_type , NULL , NULL ) ; if ( ! USub_singleton ) return 0 ; cmpop_type = make_type ( ""cmpop"" , & AST_type , NULL , 0 ) ; if ( ! cmpop_type ) return 0 ; if ( ! add_attributes ( cmpop_type , NULL , 0 ) ) return 0 ; Eq_type = make_type ( ""Eq"" , cmpop_type , NULL , 0 ) ; if ( ! Eq_type ) return 0 ; Eq_singleton = PyType_GenericNew ( Eq_type , NULL , NULL ) ; if ( ! Eq_singleton ) return 0 ; NotEq_type = make_type ( ""NotEq"" , cmpop_type , NULL , 0 ) ; if ( ! NotEq_type ) return 0 ; NotEq_singleton = PyType_GenericNew ( NotEq_type , NULL , NULL ) ; if ( ! NotEq_singleton ) return 0 ; Lt_type = make_type ( ""Lt"" , cmpop_type , NULL , 0 ) ; if ( ! Lt_type ) return 0 ; Lt_singleton = PyType_GenericNew ( Lt_type , NULL , NULL ) ; if ( ! Lt_singleton ) return 0 ; LtE_type = make_type ( ""LtE"" , cmpop_type , NULL , 0 ) ; if ( ! LtE_type ) return 0 ; LtE_singleton = PyType_GenericNew ( LtE_type , NULL , NULL ) ; if ( ! LtE_singleton ) return 0 ; Gt_type = make_type ( ""Gt"" , cmpop_type , NULL , 0 ) ; if ( ! Gt_type ) return 0 ; Gt_singleton = PyType_GenericNew ( Gt_type , NULL , NULL ) ; if ( ! Gt_singleton ) return 0 ; GtE_type = make_type ( ""GtE"" , cmpop_type , NULL , 0 ) ; if ( ! GtE_type ) return 0 ; GtE_singleton = PyType_GenericNew ( GtE_type , NULL , NULL ) ; if ( ! GtE_singleton ) return 0 ; Is_type = make_type ( ""Is"" , cmpop_type , NULL , 0 ) ; if ( ! Is_type ) return 0 ; Is_singleton = PyType_GenericNew ( Is_type , NULL , NULL ) ; if ( ! Is_singleton ) return 0 ; IsNot_type = make_type ( ""IsNot"" , cmpop_type , NULL , 0 ) ; if ( ! IsNot_type ) return 0 ; IsNot_singleton = PyType_GenericNew ( IsNot_type , NULL , NULL ) ; if ( ! IsNot_singleton ) return 0 ; In_type = make_type ( ""In"" , cmpop_type , NULL , 0 ) ; if ( ! In_type ) return 0 ; In_singleton = PyType_GenericNew ( In_type , NULL , NULL ) ; if ( ! In_singleton ) return 0 ; NotIn_type = make_type ( ""NotIn"" , cmpop_type , NULL , 0 ) ; if ( ! NotIn_type ) return 0 ; NotIn_singleton = PyType_GenericNew ( NotIn_type , NULL , NULL ) ; if ( ! NotIn_singleton ) return 0 ; comprehension_type = make_type ( ""comprehension"" , & AST_type , comprehension_fields , 4 ) ; if ( ! comprehension_type ) return 0 ; if ( ! add_attributes ( comprehension_type , NULL , 0 ) ) return 0 ; excepthandler_type = make_type ( ""excepthandler"" , & AST_type , NULL , 0 ) ; if ( ! excepthandler_type ) return 0 ; if ( ! add_attributes ( excepthandler_type , excepthandler_attributes , 4 ) ) return 0 ; ExceptHandler_type = make_type ( ""ExceptHandler"" , excepthandler_type , ExceptHandler_fields , 3 ) ; if ( ! ExceptHandler_type ) return 0 ; arguments_type = make_type ( ""arguments"" , & AST_type , arguments_fields , 6 ) ; if ( ! arguments_type ) return 0 ; if ( ! add_attributes ( arguments_type , NULL , 0 ) ) return 0 ;  arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 2 ) ;  if ( ! arg_type ) return 0 ; if ( ! add_attributes ( arg_type , arg_attributes , 4 ) ) return 0 ; keyword_type = make_type ( ""keyword"" , & AST_type , keyword_fields , 2 ) ; if ( ! keyword_type ) return 0 ; if ( ! add_attributes ( keyword_type , NULL , 0 ) ) return 0 ; alias_type = make_type ( ""alias"" , & AST_type , alias_fields , 2 ) ; if ( ! alias_type ) return 0 ; if ( ! add_attributes ( alias_type , NULL , 0 ) ) return 0 ; withitem_type = make_type ( ""withitem"" , & AST_type , withitem_fields , 2 ) ; if ( ! withitem_type ) return 0 ; if ( ! add_attributes ( withitem_type , NULL , 0 ) ) return 0 ;  initialized = 1 ;  return 1 ; }","arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 3 ) ;if ( ! arg_type ) return 0 ;type_ignore_type = make_type ( ""type_ignore"" , & AST_type , NULL , 0 ) ;if ( ! type_ignore_type ) return 0 ;if ( ! add_attributes ( type_ignore_type , NULL , 0 ) ) return 0 ;TypeIgnore_type = make_type ( ""TypeIgnore"" , type_ignore_type , TypeIgnore_fields , 1 ) ;if ( ! TypeIgnore_type ) return 0 ;",1537
476,"buggy line: initialized = 1 ;return 1 ;cwe id:CWE-125context: static int init_types ( void ) { static int initialized ; if ( initialized ) return 1 ; if ( add_ast_fields ( ) < 0 ) return 0 ; mod_type = make_type ( ""mod"" , & AST_type , NULL , 0 ) ; if ( ! mod_type ) return 0 ; if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ;  Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ;   if ( ! Module_type ) return 0 ;   Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields ,  1 ) ;  if ( ! Interactive_type ) return 0 ;   Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ;  if ( ! Expression_type ) return 0 ; Suite_type = make_type ( ""Suite"" , mod_type , Suite_fields , 1 ) ; if ( ! Suite_type ) return 0 ; stmt_type = make_type ( ""stmt"" , & AST_type , NULL , 0 ) ; if ( ! stmt_type ) return 0 ; if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ; FunctionDef_type = make_type ( ""FunctionDef"" , stmt_type , FunctionDef_fields ,  5 ) ;   if ( ! FunctionDef_type ) return 0 ;  AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type ,  AsyncFunctionDef_fields , 5 ) ;   if ( ! AsyncFunctionDef_type ) return 0 ;   ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ;   if ( ! ClassDef_type ) return 0 ;   Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ;  if ( ! Return_type ) return 0 ;  Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ;  if ( ! Delete_type ) return 0 ;  Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 2 ) ;  if ( ! Assign_type ) return 0 ;  AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ;  if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields , 4 ) ; if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , AsyncFor_fields , 4 ) ; if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" , stmt_type , With_fields , 2 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" , stmt_type , AsyncWith_fields , 2 ) ; if ( ! AsyncWith_type ) return 0 ; Raise_type = make_type ( ""Raise"" , stmt_type , Raise_fields , 2 ) ; if ( ! Raise_type ) return 0 ; Try_type = make_type ( ""Try"" , stmt_type , Try_fields , 4 ) ; if ( ! Try_type ) return 0 ; Assert_type = make_type ( ""Assert"" , stmt_type , Assert_fields , 2 ) ; if ( ! Assert_type ) return 0 ; Import_type = make_type ( ""Import"" , stmt_type , Import_fields , 1 ) ; if ( ! Import_type ) return 0 ; ImportFrom_type = make_type ( ""ImportFrom"" , stmt_type , ImportFrom_fields , 3 ) ; if ( ! ImportFrom_type ) return 0 ; Global_type = make_type ( ""Global"" , stmt_type , Global_fields , 1 ) ; if ( ! Global_type ) return 0 ; Nonlocal_type = make_type ( ""Nonlocal"" , stmt_type , Nonlocal_fields , 1 ) ; if ( ! Nonlocal_type ) return 0 ; Expr_type = make_type ( ""Expr"" , stmt_type , Expr_fields , 1 ) ; if ( ! Expr_type ) return 0 ; Pass_type = make_type ( ""Pass"" , stmt_type , NULL , 0 ) ; if ( ! Pass_type ) return 0 ; Break_type = make_type ( ""Break"" , stmt_type , NULL , 0 ) ; if ( ! Break_type ) return 0 ; Continue_type = make_type ( ""Continue"" , stmt_type , NULL , 0 ) ; if ( ! Continue_type ) return 0 ; expr_type = make_type ( ""expr"" , & AST_type , NULL , 0 ) ; if ( ! expr_type ) return 0 ; if ( ! add_attributes ( expr_type , expr_attributes , 4 ) ) return 0 ; BoolOp_type = make_type ( ""BoolOp"" , expr_type , BoolOp_fields , 2 ) ; if ( ! BoolOp_type ) return 0 ; NamedExpr_type = make_type ( ""NamedExpr"" , expr_type , NamedExpr_fields , 2 ) ; if ( ! NamedExpr_type ) return 0 ; BinOp_type = make_type ( ""BinOp"" , expr_type , BinOp_fields , 3 ) ; if ( ! BinOp_type ) return 0 ; UnaryOp_type = make_type ( ""UnaryOp"" , expr_type , UnaryOp_fields , 2 ) ; if ( ! UnaryOp_type ) return 0 ; Lambda_type = make_type ( ""Lambda"" , expr_type , Lambda_fields , 2 ) ; if ( ! Lambda_type ) return 0 ; IfExp_type = make_type ( ""IfExp"" , expr_type , IfExp_fields , 3 ) ; if ( ! IfExp_type ) return 0 ; Dict_type = make_type ( ""Dict"" , expr_type , Dict_fields , 2 ) ; if ( ! Dict_type ) return 0 ; Set_type = make_type ( ""Set"" , expr_type , Set_fields , 1 ) ; if ( ! Set_type ) return 0 ; ListComp_type = make_type ( ""ListComp"" , expr_type , ListComp_fields , 2 ) ; if ( ! ListComp_type ) return 0 ; SetComp_type = make_type ( ""SetComp"" , expr_type , SetComp_fields , 2 ) ; if ( ! SetComp_type ) return 0 ; DictComp_type = make_type ( ""DictComp"" , expr_type , DictComp_fields , 3 ) ; if ( ! DictComp_type ) return 0 ; GeneratorExp_type = make_type ( ""GeneratorExp"" , expr_type , GeneratorExp_fields , 2 ) ; if ( ! GeneratorExp_type ) return 0 ; Await_type = make_type ( ""Await"" , expr_type , Await_fields , 1 ) ; if ( ! Await_type ) return 0 ; Yield_type = make_type ( ""Yield"" , expr_type , Yield_fields , 1 ) ; if ( ! Yield_type ) return 0 ; YieldFrom_type = make_type ( ""YieldFrom"" , expr_type , YieldFrom_fields , 1 ) ; if ( ! YieldFrom_type ) return 0 ; Compare_type = make_type ( ""Compare"" , expr_type , Compare_fields , 3 ) ; if ( ! Compare_type ) return 0 ; Call_type = make_type ( ""Call"" , expr_type , Call_fields , 3 ) ; if ( ! Call_type ) return 0 ; FormattedValue_type = make_type ( ""FormattedValue"" , expr_type , FormattedValue_fields , 3 ) ; if ( ! FormattedValue_type ) return 0 ; JoinedStr_type = make_type ( ""JoinedStr"" , expr_type , JoinedStr_fields , 1 ) ; if ( ! JoinedStr_type ) return 0 ; Constant_type = make_type ( ""Constant"" , expr_type , Constant_fields , 1 ) ; if ( ! Constant_type ) return 0 ; Attribute_type = make_type ( ""Attribute"" , expr_type , Attribute_fields , 3 ) ; if ( ! Attribute_type ) return 0 ; Subscript_type = make_type ( ""Subscript"" , expr_type , Subscript_fields , 3 ) ; if ( ! Subscript_type ) return 0 ; Starred_type = make_type ( ""Starred"" , expr_type , Starred_fields , 2 ) ; if ( ! Starred_type ) return 0 ; Name_type = make_type ( ""Name"" , expr_type , Name_fields , 2 ) ; if ( ! Name_type ) return 0 ; List_type = make_type ( ""List"" , expr_type , List_fields , 2 ) ; if ( ! List_type ) return 0 ; Tuple_type = make_type ( ""Tuple"" , expr_type , Tuple_fields , 2 ) ; if ( ! Tuple_type ) return 0 ; expr_context_type = make_type ( ""expr_context"" , & AST_type , NULL , 0 ) ; if ( ! expr_context_type ) return 0 ; if ( ! add_attributes ( expr_context_type , NULL , 0 ) ) return 0 ; Load_type = make_type ( ""Load"" , expr_context_type , NULL , 0 ) ; if ( ! Load_type ) return 0 ; Load_singleton = PyType_GenericNew ( Load_type , NULL , NULL ) ; if ( ! Load_singleton ) return 0 ; Store_type = make_type ( ""Store"" , expr_context_type , NULL , 0 ) ; if ( ! Store_type ) return 0 ; Store_singleton = PyType_GenericNew ( Store_type , NULL , NULL ) ; if ( ! Store_singleton ) return 0 ; Del_type = make_type ( ""Del"" , expr_context_type , NULL , 0 ) ; if ( ! Del_type ) return 0 ; Del_singleton = PyType_GenericNew ( Del_type , NULL , NULL ) ; if ( ! Del_singleton ) return 0 ; AugLoad_type = make_type ( ""AugLoad"" , expr_context_type , NULL , 0 ) ; if ( ! AugLoad_type ) return 0 ; AugLoad_singleton = PyType_GenericNew ( AugLoad_type , NULL , NULL ) ; if ( ! AugLoad_singleton ) return 0 ; AugStore_type = make_type ( ""AugStore"" , expr_context_type , NULL , 0 ) ; if ( ! AugStore_type ) return 0 ; AugStore_singleton = PyType_GenericNew ( AugStore_type , NULL , NULL ) ; if ( ! AugStore_singleton ) return 0 ; Param_type = make_type ( ""Param"" , expr_context_type , NULL , 0 ) ; if ( ! Param_type ) return 0 ; Param_singleton = PyType_GenericNew ( Param_type , NULL , NULL ) ; if ( ! Param_singleton ) return 0 ; NamedStore_type = make_type ( ""NamedStore"" , expr_context_type , NULL , 0 ) ; if ( ! NamedStore_type ) return 0 ; NamedStore_singleton = PyType_GenericNew ( NamedStore_type , NULL , NULL ) ; if ( ! NamedStore_singleton ) return 0 ; slice_type = make_type ( ""slice"" , & AST_type , NULL , 0 ) ; if ( ! slice_type ) return 0 ; if ( ! add_attributes ( slice_type , NULL , 0 ) ) return 0 ; Slice_type = make_type ( ""Slice"" , slice_type , Slice_fields , 3 ) ; if ( ! Slice_type ) return 0 ; ExtSlice_type = make_type ( ""ExtSlice"" , slice_type , ExtSlice_fields , 1 ) ; if ( ! ExtSlice_type ) return 0 ; Index_type = make_type ( ""Index"" , slice_type , Index_fields , 1 ) ; if ( ! Index_type ) return 0 ; boolop_type = make_type ( ""boolop"" , & AST_type , NULL , 0 ) ; if ( ! boolop_type ) return 0 ; if ( ! add_attributes ( boolop_type , NULL , 0 ) ) return 0 ; And_type = make_type ( ""And"" , boolop_type , NULL , 0 ) ; if ( ! And_type ) return 0 ; And_singleton = PyType_GenericNew ( And_type , NULL , NULL ) ; if ( ! And_singleton ) return 0 ; Or_type = make_type ( ""Or"" , boolop_type , NULL , 0 ) ; if ( ! Or_type ) return 0 ; Or_singleton = PyType_GenericNew ( Or_type , NULL , NULL ) ; if ( ! Or_singleton ) return 0 ; operator_type = make_type ( ""operator"" , & AST_type , NULL , 0 ) ; if ( ! operator_type ) return 0 ; if ( ! add_attributes ( operator_type , NULL , 0 ) ) return 0 ; Add_type = make_type ( ""Add"" , operator_type , NULL , 0 ) ; if ( ! Add_type ) return 0 ; Add_singleton = PyType_GenericNew ( Add_type , NULL , NULL ) ; if ( ! Add_singleton ) return 0 ; Sub_type = make_type ( ""Sub"" , operator_type , NULL , 0 ) ; if ( ! Sub_type ) return 0 ; Sub_singleton = PyType_GenericNew ( Sub_type , NULL , NULL ) ; if ( ! Sub_singleton ) return 0 ; Mult_type = make_type ( ""Mult"" , operator_type , NULL , 0 ) ; if ( ! Mult_type ) return 0 ; Mult_singleton = PyType_GenericNew ( Mult_type , NULL , NULL ) ; if ( ! Mult_singleton ) return 0 ; MatMult_type = make_type ( ""MatMult"" , operator_type , NULL , 0 ) ; if ( ! MatMult_type ) return 0 ; MatMult_singleton = PyType_GenericNew ( MatMult_type , NULL , NULL ) ; if ( ! MatMult_singleton ) return 0 ; Div_type = make_type ( ""Div"" , operator_type , NULL , 0 ) ; if ( ! Div_type ) return 0 ; Div_singleton = PyType_GenericNew ( Div_type , NULL , NULL ) ; if ( ! Div_singleton ) return 0 ; Mod_type = make_type ( ""Mod"" , operator_type , NULL , 0 ) ; if ( ! Mod_type ) return 0 ; Mod_singleton = PyType_GenericNew ( Mod_type , NULL , NULL ) ; if ( ! Mod_singleton ) return 0 ; Pow_type = make_type ( ""Pow"" , operator_type , NULL , 0 ) ; if ( ! Pow_type ) return 0 ; Pow_singleton = PyType_GenericNew ( Pow_type , NULL , NULL ) ; if ( ! Pow_singleton ) return 0 ; LShift_type = make_type ( ""LShift"" , operator_type , NULL , 0 ) ; if ( ! LShift_type ) return 0 ; LShift_singleton = PyType_GenericNew ( LShift_type , NULL , NULL ) ; if ( ! LShift_singleton ) return 0 ; RShift_type = make_type ( ""RShift"" , operator_type , NULL , 0 ) ; if ( ! RShift_type ) return 0 ; RShift_singleton = PyType_GenericNew ( RShift_type , NULL , NULL ) ; if ( ! RShift_singleton ) return 0 ; BitOr_type = make_type ( ""BitOr"" , operator_type , NULL , 0 ) ; if ( ! BitOr_type ) return 0 ; BitOr_singleton = PyType_GenericNew ( BitOr_type , NULL , NULL ) ; if ( ! BitOr_singleton ) return 0 ; BitXor_type = make_type ( ""BitXor"" , operator_type , NULL , 0 ) ; if ( ! BitXor_type ) return 0 ; BitXor_singleton = PyType_GenericNew ( BitXor_type , NULL , NULL ) ; if ( ! BitXor_singleton ) return 0 ; BitAnd_type = make_type ( ""BitAnd"" , operator_type , NULL , 0 ) ; if ( ! BitAnd_type ) return 0 ; BitAnd_singleton = PyType_GenericNew ( BitAnd_type , NULL , NULL ) ; if ( ! BitAnd_singleton ) return 0 ; FloorDiv_type = make_type ( ""FloorDiv"" , operator_type , NULL , 0 ) ; if ( ! FloorDiv_type ) return 0 ; FloorDiv_singleton = PyType_GenericNew ( FloorDiv_type , NULL , NULL ) ; if ( ! FloorDiv_singleton ) return 0 ; unaryop_type = make_type ( ""unaryop"" , & AST_type , NULL , 0 ) ; if ( ! unaryop_type ) return 0 ; if ( ! add_attributes ( unaryop_type , NULL , 0 ) ) return 0 ; Invert_type = make_type ( ""Invert"" , unaryop_type , NULL , 0 ) ; if ( ! Invert_type ) return 0 ; Invert_singleton = PyType_GenericNew ( Invert_type , NULL , NULL ) ; if ( ! Invert_singleton ) return 0 ; Not_type = make_type ( ""Not"" , unaryop_type , NULL , 0 ) ; if ( ! Not_type ) return 0 ; Not_singleton = PyType_GenericNew ( Not_type , NULL , NULL ) ; if ( ! Not_singleton ) return 0 ; UAdd_type = make_type ( ""UAdd"" , unaryop_type , NULL , 0 ) ; if ( ! UAdd_type ) return 0 ; UAdd_singleton = PyType_GenericNew ( UAdd_type , NULL , NULL ) ; if ( ! UAdd_singleton ) return 0 ; USub_type = make_type ( ""USub"" , unaryop_type , NULL , 0 ) ; if ( ! USub_type ) return 0 ; USub_singleton = PyType_GenericNew ( USub_type , NULL , NULL ) ; if ( ! USub_singleton ) return 0 ; cmpop_type = make_type ( ""cmpop"" , & AST_type , NULL , 0 ) ; if ( ! cmpop_type ) return 0 ; if ( ! add_attributes ( cmpop_type , NULL , 0 ) ) return 0 ; Eq_type = make_type ( ""Eq"" , cmpop_type , NULL , 0 ) ; if ( ! Eq_type ) return 0 ; Eq_singleton = PyType_GenericNew ( Eq_type , NULL , NULL ) ; if ( ! Eq_singleton ) return 0 ; NotEq_type = make_type ( ""NotEq"" , cmpop_type , NULL , 0 ) ; if ( ! NotEq_type ) return 0 ; NotEq_singleton = PyType_GenericNew ( NotEq_type , NULL , NULL ) ; if ( ! NotEq_singleton ) return 0 ; Lt_type = make_type ( ""Lt"" , cmpop_type , NULL , 0 ) ; if ( ! Lt_type ) return 0 ; Lt_singleton = PyType_GenericNew ( Lt_type , NULL , NULL ) ; if ( ! Lt_singleton ) return 0 ; LtE_type = make_type ( ""LtE"" , cmpop_type , NULL , 0 ) ; if ( ! LtE_type ) return 0 ; LtE_singleton = PyType_GenericNew ( LtE_type , NULL , NULL ) ; if ( ! LtE_singleton ) return 0 ; Gt_type = make_type ( ""Gt"" , cmpop_type , NULL , 0 ) ; if ( ! Gt_type ) return 0 ; Gt_singleton = PyType_GenericNew ( Gt_type , NULL , NULL ) ; if ( ! Gt_singleton ) return 0 ; GtE_type = make_type ( ""GtE"" , cmpop_type , NULL , 0 ) ; if ( ! GtE_type ) return 0 ; GtE_singleton = PyType_GenericNew ( GtE_type , NULL , NULL ) ; if ( ! GtE_singleton ) return 0 ; Is_type = make_type ( ""Is"" , cmpop_type , NULL , 0 ) ; if ( ! Is_type ) return 0 ; Is_singleton = PyType_GenericNew ( Is_type , NULL , NULL ) ; if ( ! Is_singleton ) return 0 ; IsNot_type = make_type ( ""IsNot"" , cmpop_type , NULL , 0 ) ; if ( ! IsNot_type ) return 0 ; IsNot_singleton = PyType_GenericNew ( IsNot_type , NULL , NULL ) ; if ( ! IsNot_singleton ) return 0 ; In_type = make_type ( ""In"" , cmpop_type , NULL , 0 ) ; if ( ! In_type ) return 0 ; In_singleton = PyType_GenericNew ( In_type , NULL , NULL ) ; if ( ! In_singleton ) return 0 ; NotIn_type = make_type ( ""NotIn"" , cmpop_type , NULL , 0 ) ; if ( ! NotIn_type ) return 0 ; NotIn_singleton = PyType_GenericNew ( NotIn_type , NULL , NULL ) ; if ( ! NotIn_singleton ) return 0 ; comprehension_type = make_type ( ""comprehension"" , & AST_type , comprehension_fields , 4 ) ; if ( ! comprehension_type ) return 0 ; if ( ! add_attributes ( comprehension_type , NULL , 0 ) ) return 0 ; excepthandler_type = make_type ( ""excepthandler"" , & AST_type , NULL , 0 ) ; if ( ! excepthandler_type ) return 0 ; if ( ! add_attributes ( excepthandler_type , excepthandler_attributes , 4 ) ) return 0 ; ExceptHandler_type = make_type ( ""ExceptHandler"" , excepthandler_type , ExceptHandler_fields , 3 ) ; if ( ! ExceptHandler_type ) return 0 ; arguments_type = make_type ( ""arguments"" , & AST_type , arguments_fields , 6 ) ; if ( ! arguments_type ) return 0 ; if ( ! add_attributes ( arguments_type , NULL , 0 ) ) return 0 ;  arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 2 ) ;  if ( ! arg_type ) return 0 ; if ( ! add_attributes ( arg_type , arg_attributes , 4 ) ) return 0 ; keyword_type = make_type ( ""keyword"" , & AST_type , keyword_fields , 2 ) ; if ( ! keyword_type ) return 0 ; if ( ! add_attributes ( keyword_type , NULL , 0 ) ) return 0 ; alias_type = make_type ( ""alias"" , & AST_type , alias_fields , 2 ) ; if ( ! alias_type ) return 0 ; if ( ! add_attributes ( alias_type , NULL , 0 ) ) return 0 ; withitem_type = make_type ( ""withitem"" , & AST_type , withitem_fields , 2 ) ; if ( ! withitem_type ) return 0 ; if ( ! add_attributes ( withitem_type , NULL , 0 ) ) return 0 ;  initialized = 1 ;  return 1 ; }",initialized = 1 ;return 1 ;,1537
477,"buggy line: logfile_fd = open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ;if ( logfile_fd == INVALID_FD ) {write ( logfile_fd , ""btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea"" , 16 ) ;}cwe id:CWE-284context: static void update_logging ( ) { bool should_log = module_started && ( logging_enabled_via_api || stack_config -> get_btsnoop_turned_on ( ) ) ; if ( should_log == is_logging ) return ; is_logging = should_log ; if ( should_log ) { btsnoop_net_open ( ) ; const char * log_path = stack_config -> get_btsnoop_log_path ( ) ; if ( stack_config -> get_btsnoop_should_save_last ( ) ) { char last_log_path [ PATH_MAX ] ; snprintf ( last_log_path , PATH_MAX , ""%s.%llu"" , log_path , btsnoop_timestamp ( ) ) ; if ( ! rename ( log_path , last_log_path ) && errno != ENOENT ) LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>rename<S2SV_blank>\'%s\'<S2SV_blank>to<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , log_path , last_log_path , strerror ( errno ) ) ; }  logfile_fd = open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ;  if ( logfile_fd == INVALID_FD ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , log_path , strerror ( errno ) ) ; is_logging = false ; return ; }  write ( logfile_fd , ""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea"" , 16 ) ;  } else { if ( logfile_fd != INVALID_FD ) close ( logfile_fd ) ; logfile_fd = INVALID_FD ; btsnoop_net_close ( ) ; } }","logfile_fd = TEMP_FAILURE_RETRY ( open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ) ;if ( logfile_fd == INVALID_FD ) {TEMP_FAILURE_RETRY ( write ( logfile_fd , ""btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea"" , 16 ) ) ;}",1538
478,"buggy line: if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 4 ;}if ( context -> curY >= p -> height ) {context -> pass ++ ;if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 1 ;}break ;}cwe id:CWE-787context: static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ;  if ( context -> curY >= p -> height ) {  context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ;  if ( context -> curY >= p -> height ) {  context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ;  if ( context -> curY >= p -> height ) {  context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ;  break ;  } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } else { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif context -> frbuff_p . p8 ++ ; # ifndef NGIFLIB_INDEXED_ONLY } else { context -> frbuff_p . p32 ++ ; } # endif } }",if ( context -> curY >= p -> height ) {context -> pass ++ ;break ;}while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) {switch ( ++ context -> pass ) {case 2 : context -> curY = i -> posY + 4 ;break ;case 3 : context -> curY = i -> posY + 2 ;break ;case 4 : context -> curY = i -> posY + 1 ;break ;}},1539
479,"buggy line: # endif  ++ x -> ymode_count [ m ] ;cwe id:CWE-119context: static void sum_intra_stats ( VP8_COMP * cpi , MACROBLOCK * x ) { const MACROBLOCKD * xd = & x -> e_mbd ; const MB_PREDICTION_MODE m = xd -> mode_info_context -> mbmi . mode ; const MB_PREDICTION_MODE uvm = xd -> mode_info_context -> mbmi . uv_mode ; # ifdef MODE_STATS const int is_key = cpi -> common . frame_type == KEY_FRAME ; ++ ( is_key ? uv_modes : inter_uv_modes ) [ uvm ] ; if ( m == B_PRED ) { unsigned int * const bct = is_key ? b_modes : inter_b_modes ; int b = 0 ; do { ++ bct [ xd -> block [ b ] . bmi . mode ] ; } while ( ++ b < 16 ) ; }  # endif  ++ x -> ymode_count [ m ] ; ++ x -> uv_mode_count [ uvm ] ; }",# else ( void ) cpi ;# endif ++ x -> ymode_count [ m ] ;,1540
480,"buggy line: if ( sr -> smb_fid != 0xffff ) {smbsr_lookup_file ( sr ) ;if ( sr -> fid_ofile == NULL ) {smbsr_error ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ;smb_flush_file ( sr , sr -> fid_ofile ) ;}smb_flush_file ( sr , file ) ;mutex_exit ( & file -> f_mutex ) ;cwe id:CWE-476context: smb_sdrc_t smb_com_flush ( smb_request_t * sr ) { smb_ofile_t * file ; smb_llist_t * flist ; int rc ; if ( smb_flush_required == 0 ) { rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; } if ( sr -> smb_fid != 0xffff ) { smbsr_lookup_file ( sr ) ; if ( sr -> fid_ofile == NULL ) { smbsr_error ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ; return ( SDRC_ERROR ) ; }  smb_flush_file ( sr , sr -> fid_ofile ) ;  } else { flist = & sr -> tid_tree -> t_ofile_list ; smb_llist_enter ( flist , RW_READER ) ; file = smb_llist_head ( flist ) ; while ( file ) { mutex_enter ( & file -> f_mutex ) ;  smb_flush_file ( sr , file ) ;  mutex_exit ( & file -> f_mutex ) ; file = smb_llist_next ( flist , file ) ; } smb_llist_exit ( flist ) ; } rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; }","smb_ofile_flush ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ;smb_flush_file ( sr , sr -> fid_ofile ) ;}smb_ofile_flush ( sr , file ) ;mutex_exit ( & file -> f_mutex ) ;",1541
481,"buggy line: int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs )  {while ( * s && len > 0 ) {if ( * s & 0x80 ) {if ( u >= PLANE_SIZE ) {u -= PLANE_SIZE ;* op ++ = ( wchar_t ) ( SURROGATE_PAIR |   ( ( u >> 10 ) & SURROGATE_BITS ) ) ;* op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW |  ( u & SURROGATE_BITS ) ) ;}else {* op ++ = ( wchar_t ) u ;}* op ++ = * s ++ ;len -- ;cwe id:CWE-119context:  int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs )  { u16 * op ; int size ; unicode_t u ; op = pwcs ;  while ( * s && len > 0 ) {  if ( * s & 0x80 ) { size = utf8_to_utf32 ( s , len , & u ) ; if ( size < 0 ) return - EINVAL ;  if ( u >= PLANE_SIZE ) {   u -= PLANE_SIZE ;   * op ++ = ( wchar_t ) ( SURROGATE_PAIR |   ( ( u >> 10 ) & SURROGATE_BITS ) ) ;  * op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW |  ( u & SURROGATE_BITS ) ) ;  } else {  * op ++ = ( wchar_t ) u ;  } s += size ; len -= size ; } else {  * op ++ = * s ++ ;  len -- ; } } return op - pwcs ; }","int utf8s_to_utf16s ( const u8 * s , int len , enum utf16_endian endian , wchar_t * pwcs , int maxlen ) {while ( len > 0 && maxlen > 0 && * s ) {if ( * s & 0x80 ) {if ( u >= PLANE_SIZE ) {if ( maxlen < 2 ) break ;u -= PLANE_SIZE ;put_utf16 ( op ++ , SURROGATE_PAIR | ( ( u >> 10 ) & SURROGATE_BITS ) , endian ) ;put_utf16 ( op ++ , SURROGATE_PAIR | SURROGATE_LOW | ( u & SURROGATE_BITS ) , endian ) ;maxlen -= 2 ;}else {put_utf16 ( op ++ , u , endian ) ;maxlen -- ;}* op ++ = * s ++ ;len -- ;",1542
482,"buggy line: if ( ! pflag ) ( void ) umask ( mask ) ;if ( argc != 1 ) {run_err ( ""ambiguous<S2SV_blank>target"" ) ;exit ( 1 ) ;}targ = * argv ;if ( targetshouldbedirectory ) verifydir ( targ ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ;for ( first = 1 ;;first = 0 ) {cp = buf ;if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ;if ( * cp ++ == \'\\\do {if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ;* cp ++ = ch ;}while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != \'\\\* cp = 0 ;if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ;if ( buf [ 0 ] == \'\\\\01\' || buf [ 0 ] == \'\\\\02\' ) {if ( iamremote == 0 ) {( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ;( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ;}if ( buf [ 0 ] == \'\\\\02\' ) exit ( 1 ) ;++ errs ;continue ;}if ( buf [ 0 ] == \'E\' ) {( void ) atomicio ( vwrite , remout , """" , 1 ) ;return ;}if ( ch == \'\\\cp = buf ;if ( * cp == \'T\' ) {setimes ++ ;cp ++ ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;mtime . tv_sec = ull ;mtime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;atime . tv_sec = ull ;atime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'\\\\0\' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;continue ;}if ( * cp != \'C\' && * cp != \'D\' ) {if ( first ) {run_err ( ""%s"" , cp ) ;exit ( 1 ) ;}SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ;}mode = 0 ;for ( ++ cp ;cp < buf + 5 ;cp ++ ) {if ( * cp < \'0\' || * cp > \'7\' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ;mode = ( mode << 3 ) | ( * cp - \'0\' ) ;}if ( ! pflag ) mode &= ~ mask ;if ( * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ;size = ( off_t ) ull ;if ( ( strchr ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;cwe id:CWE-706context: void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( ""Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size"" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguous<S2SV_blank>target"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ; if ( * cp ++ == '\\n' ) SCREWUP ( ""unexpected<S2SV_blank><newline>"" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) { ( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ; ( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ; } if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'E' ) { ( void ) atomicio ( vwrite , remout , """" , 1 ) ; return ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 'T' ) { setimes ++ ; cp ++ ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; mtime . tv_sec = ull ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; atime . tv_sec = ull ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; continue ; } if ( * cp != 'C' && * cp != 'D' ) { if ( first ) { run_err ( ""%s"" , cp ) ; exit ( 1 ) ; } SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( ! pflag ) mode &= ~ mask ; if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ; size = ( off_t ) ull ;  if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {  run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ; exit ( 1 ) ; } if ( targisdir ) { static char * namebuf ; static size_t cursize ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { free ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'D' ) { int mod_flag = pflag ; if ( ! iamrecursive ) SCREWUP ( ""received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r"" ) ; if ( exists ) { if ( ! S_ISDIR ( stb . st_mode ) ) { errno = ENOTDIR ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | S_IRWXU ) < 0 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect ) ; if ( setimes ) { setimes = 0 ; if ( utimes ( vect [ 0 ] , tv ) < 0 ) run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; free ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= S_IWUSR ; if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) < 0 ) { bad : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , COPY_BUFLEN ) ) == NULL ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; wrerr = NO ; statbytes = 0 ; if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; set_nonblock ( remin ) ; for ( count = i = 0 ; i < size ; i += bp -> cnt ) { amt = bp -> cnt ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio6 ( read , remin , cp , amt , scpio , & statbytes ) ; if ( j == 0 ) { run_err ( ""%s"" , j != EPIPE ? strerror ( errno ) : ""dropped<S2SV_blank>connection"" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; } while ( amt > 0 ) ; if ( count == bp -> cnt ) { if ( wrerr == NO ) { if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } } count = 0 ; cp = bp -> buf ; } } unset_nonblock ( remin ) ; if ( count != 0 && wrerr == NO && atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } if ( wrerr == NO && ( ! exists || S_ISREG ( stb . st_mode ) ) && ftruncate ( ofd , size ) != 0 ) { run_err ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } if ( pflag ) { if ( exists || omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } else { if ( ! exists && omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } if ( close ( ofd ) == - 1 ) { wrerr = YES ; wrerrno = errno ; } ( void ) response ( ) ; if ( showprogress ) stop_progress_meter ( ) ; if ( setimes && wrerr == NO ) { setimes = 0 ; if ( utimes ( np , tv ) < 0 ) { run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } switch ( wrerr ) { case YES : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( wrerrno ) ) ; break ; case NO : ( void ) atomicio ( vwrite , remout , """" , 1 ) ; break ; case DISPLAYED : break ; } } screwup : run_err ( ""protocol<S2SV_blank>error:<S2SV_blank>%s"" , why ) ; exit ( 1 ) ; }","+ errs ;if ( * cp == \'\\\\0\' || strchr ( cp , ""."" ) == 0 || strcmp ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;",1543
483,"buggy line: int num , i , num1 , num2 ;char * s , * t , * StartClean ;double * argbuf = 0 ;SetDefaults ( ) ;* t ++ = 0 ;while ( * t == \'<S2SV_blank>\' || * t == \'\\\\t\' || * t == \'\\\outpos = outputbuffer ;outpos += sprintf ( outpos , ""\\\\\\\\axo@setObject{if ( * s == \'0\' && s [ 1 ] == \']\' ) {if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) {outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ;fprintf ( outfile , ""%s"" , outputbuffer ) ;return ( 0 ) ;if ( argbuf ) free ( argbuf ) ;return ( - 1 ) ;StartClean = outpos ;nameobject = t ;while ( * t != \'<S2SV_blank>\' && * t != \'\\\\t\' && * t != \'\\\* t ++ = 0 ;while ( * t == \'<S2SV_blank>\' || * t == \'\\\\t\' || * t == \'\\\if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ;if ( num2 - 1 != 0 ) {free ( argbuf ) ;return ( - 1 ) ;if ( strcmp ( nameobject , ""Curve"" ) == 0 ) {Curve ( argbuf , num1 ) ;}else if ( strcmp ( nameobject , ""Polygon"" ) == 0 ) {Polygon ( argbuf , num1 , 0 ) ;}else if ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) {Polygon ( argbuf , num1 , 1 ) ;}free ( argbuf ) ;}}else if ( strcmp ( nameobject , ""DashCurve"" ) == 0 ) {if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ;if ( num2 != 2 ) {free ( argbuf ) ;return ( - 1 ) ;}}if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ;for ( i = 0 ;cwe id:CWE-20context: int DoOneObject ( char * cinput ) {  int num , i , num1 , num2 ;   char * s , * t , * StartClean ;   double * argbuf = 0 ;  SetDefaults ( ) ; s = cinput ; while ( * s != '[' ) s ++ ; s ++ ; t = s ; while ( * t != ']' ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ;  outpos = outputbuffer ;   outpos += sprintf ( outpos , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ;   if ( * s == '0' && s [ 1 ] == ']' ) {  if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) { identification = 1 ;  outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ;   fprintf ( outfile , ""%s"" , outputbuffer ) ;  return ( 0 ) ; } else { fprintf ( stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" , axohelp , nameobject ) ;  if ( argbuf ) free ( argbuf ) ;  return ( - 1 ) ; } } StartClean = outpos ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; if ( ( strcmp ( nameobject , ""Curve"" ) == 0 ) || ( strcmp ( nameobject , ""Polygon"" ) == 0 ) || ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) ) {  if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ;  if ( num2 - 1 != 0 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>no<S2SV_blank>extra<S2SV_blank>numbers<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ;  free ( argbuf ) ;  return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; if ( strcmp ( nameobject , ""Curve"" ) == 0 ) { Curve ( argbuf , num1 ) ; } else if ( strcmp ( nameobject , ""Polygon"" ) == 0 ) { Polygon ( argbuf , num1 , 0 ) ; } else if ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) { Polygon ( argbuf , num1 , 1 ) ; } free ( argbuf ) ;  }  } else if ( strcmp ( nameobject , ""DashCurve"" ) == 0 ) {  if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ;  if ( num2 != 2 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>two<S2SV_blank>numbers<S2SV_blank>after<S2SV_blank>the<S2SV_blank>coordinates\\n<S2SV_blank><S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ;  free ( argbuf ) ;  return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; DashCurve ( argbuf , num1 ) ; free ( argbuf ) ;  }  } else {  if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ;  for ( i = 0 ; i < sizeof ( commands ) / sizeof ( KEYWORD ) ; i ++ ) { if ( strcmp ( nameobject , commands [ i ] . name ) == 0 ) { if ( num == commands [ i ] . numargs + 1 ) { axolinewidth = argbuf [ num - 1 ] ; SetLineWidth ( axolinewidth ) ; ( * ( commands [ i ] . func ) ) ( argbuf ) ; free ( argbuf ) ;  break ;  } else { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>%d(+1)<S2SV_blank>arguments<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , commands [ i ] . numargs , inname ) ;  free ( argbuf ) ;  return ( - 1 ) ; } } } if ( i >= sizeof ( commands ) / sizeof ( KEYWORD ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>recognized<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ;  free ( argbuf ) ;  return ( - 1 ) ; } } outpos += sprintf ( outpos , ""}\\n"" ) ; CleanupOutput ( StartClean ) ; fprintf ( outfile , ""%s"" , outputbuffer ) ; return ( 0 ) ; }","int num , i , num1 , num2 , retcode ;char * s , * t ;double * argbuf = 0 ;retcode = - 1 ;SetDefaults ( ) ;fprintf ( outfile , ""\\\\\\\\axo@setObject{* t ++ = 0 ;while ( * t == \'<S2SV_blank>\' || * t == \'\\\\t\' || * t == \'\\\outpos = outputbuffer ;nameobject = t ;while ( * t != \'<S2SV_blank>\' && * t != \'\\\\t\' && * t != \'\\\* t ++ = 0 ;while ( * t == \'<S2SV_blank>\' || * t == \'\\\\t\' || * t == \'\\\if ( * s == \'0\' && s [ 1 ] == 0 ) {if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) {fprintf ( outfile , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output."" , VERSION , SUBVERSION ) ;fprintf ( outfile , ""%s"" , outputbuffer ) ;return ( 0 ) ;goto EXIT ;if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ;if ( num2 - 1 != 0 ) {free ( argbuf ) ;return ( - 1 ) ;if ( strcmp ( nameobject , ""Curve"" ) == 0 ) goto EXIT ;if ( num2 != 2 ) {free ( argbuf ) ;return ( - 1 ) ;}}if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ;for ( i = 0 ;",1544
484,"buggy line: break ;}free ( argbuf ) ;return ( - 1 ) ;free ( argbuf ) ;return ( - 1 ) ;cwe id:CWE-20context: int DoOneObject ( char * cinput ) {  int num , i , num1 , num2 ;   char * s , * t , * StartClean ;   double * argbuf = 0 ;  SetDefaults ( ) ; s = cinput ; while ( * s != '[' ) s ++ ; s ++ ; t = s ; while ( * t != ']' ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ;  outpos = outputbuffer ;   outpos += sprintf ( outpos , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ;   if ( * s == '0' && s [ 1 ] == ']' ) {  if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) { identification = 1 ;  outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ;   fprintf ( outfile , ""%s"" , outputbuffer ) ;  return ( 0 ) ; } else { fprintf ( stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" , axohelp , nameobject ) ;  if ( argbuf ) free ( argbuf ) ;  return ( - 1 ) ; } } StartClean = outpos ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; if ( ( strcmp ( nameobject , ""Curve"" ) == 0 ) || ( strcmp ( nameobject , ""Polygon"" ) == 0 ) || ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) ) {  if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ;  if ( num2 - 1 != 0 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>no<S2SV_blank>extra<S2SV_blank>numbers<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ;  free ( argbuf ) ;  return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; if ( strcmp ( nameobject , ""Curve"" ) == 0 ) { Curve ( argbuf , num1 ) ; } else if ( strcmp ( nameobject , ""Polygon"" ) == 0 ) { Polygon ( argbuf , num1 , 0 ) ; } else if ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) { Polygon ( argbuf , num1 , 1 ) ; } free ( argbuf ) ;  }  } else if ( strcmp ( nameobject , ""DashCurve"" ) == 0 ) {  if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ;  if ( num2 != 2 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>two<S2SV_blank>numbers<S2SV_blank>after<S2SV_blank>the<S2SV_blank>coordinates\\n<S2SV_blank><S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ;  free ( argbuf ) ;  return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; DashCurve ( argbuf , num1 ) ; free ( argbuf ) ;  }  } else {  if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ;  for ( i = 0 ; i < sizeof ( commands ) / sizeof ( KEYWORD ) ; i ++ ) { if ( strcmp ( nameobject , commands [ i ] . name ) == 0 ) { if ( num == commands [ i ] . numargs + 1 ) { axolinewidth = argbuf [ num - 1 ] ; SetLineWidth ( axolinewidth ) ; ( * ( commands [ i ] . func ) ) ( argbuf ) ; free ( argbuf ) ;  break ;  } else { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>%d(+1)<S2SV_blank>arguments<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , commands [ i ] . numargs , inname ) ;  free ( argbuf ) ;  return ( - 1 ) ; } } } if ( i >= sizeof ( commands ) / sizeof ( KEYWORD ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>recognized<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ;  free ( argbuf ) ;  return ( - 1 ) ; } } outpos += sprintf ( outpos , ""}\\n"" ) ; CleanupOutput ( StartClean ) ; fprintf ( outfile , ""%s"" , outputbuffer ) ; return ( 0 ) ; }","argbuf = 0 ;break ;}goto EXIT ;goto EXIT ;}}SUCCESS : retcode = 0 ;EXIT : if ( argbuf ) {free ( argbuf ) ;}fprintf ( outfile , ""}\\\return ( retcode ) ;",1544
485,"buggy line: default :  errno = EINVAL ;cwe id:CWE-399context: public int magic_getparam ( struct magic_set * ms , int param , void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : * ( size_t * ) val = ms -> indir_max ; return 0 ; case MAGIC_PARAM_NAME_MAX : * ( size_t * ) val = ms -> name_max ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : * ( size_t * ) val = ms -> elf_phnum_max ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : * ( size_t * ) val = ms -> elf_shnum_max ; return 0 ;  default :  errno = EINVAL ; return - 1 ; } }",case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ;return 0 ;default : errno = EINVAL ;,1545
486,"buggy line: static u32 ip_idents_hashrnd __read_mostly ;u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ;hash = jhash_3words ( ( __force u32 ) iph -> daddr ,  ( __force u32 ) iph -> saddr ,  iph -> protocol ^ net_hash_mix ( net ) ,  ip_idents_hashrnd ) ;cwe id:CWE-326context: void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) {  static u32 ip_idents_hashrnd __read_mostly ;  u32 hash , id ;  net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ;   hash = jhash_3words ( ( __force u32 ) iph -> daddr ,  ( __force u32 ) iph -> saddr ,  iph -> protocol ^ net_hash_mix ( net ) ,  ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }","u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( net -> ipv4 . ip_id_key ) ) ;hash = siphash_3u32 ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , iph -> protocol , & net -> ipv4 . ip_id_key ) ;",1546
487,"buggy line: if ( obj == Py_None ) {* out = NULL ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ;cwe id:CWE-125context: int obj2ast_slice ( PyObject * obj , slice_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty lower ; expr_ty upper ; expr_ty step ;  if ( exists_not_none ( obj , & PyId_lower ) ) {  int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & lower , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ;  } else {  lower = NULL ; } if ( exists_not_none ( obj , & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj , & PyId_step ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_step ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { step = NULL ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( _PyObject_HasAttrId ( obj , & PyId_dims ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_dims ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; dims = _Ta3_asdl_seq_new ( len , arena ) ; if ( dims == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  slice_ty value ;   res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( dims , i , value ) ;  }  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } * out = ExtSlice ( dims , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Index_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ;  if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {  int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ;  return 1 ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","if ( lookup_attr_id ( obj , ( PyObject * ) Slice_type ) ;",1547
488,"buggy line: if ( exists_not_none ( obj , & PyId_lower ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ;if ( tmp == NULL ) goto failed ;}lower = NULL ;if ( exists_not_none ( obj , & PyId_upper ) ) {cwe id:CWE-125context: int obj2ast_slice ( PyObject * obj , slice_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty lower ; expr_ty upper ; expr_ty step ;  if ( exists_not_none ( obj , & PyId_lower ) ) {  int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & lower , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ;  } else {  lower = NULL ; } if ( exists_not_none ( obj , & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj , & PyId_step ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_step ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { step = NULL ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( _PyObject_HasAttrId ( obj , & PyId_dims ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_dims ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; dims = _Ta3_asdl_seq_new ( len , arena ) ; if ( dims == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  slice_ty value ;   res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( dims , i , value ) ;  }  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } * out = ExtSlice ( dims , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Index_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ;  if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {  int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ;  return 1 ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","if ( exists_not_none ( obj , & PyId_lower , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;lower = NULL ;}else {int res ;}if ( lookup_attr_id ( obj , & PyId_upper , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;upper = NULL ;}int res ;res = obj2ast_expr ( tmp , & upper , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , & PyId_step , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;step = NULL ;}else {int res ;res = obj2ast_expr ( tmp , & step , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;* out = Slice ( lower , upper , step , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {asdl_seq * dims ;if ( lookup_attr_id ( obj , & PyId_dims , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""dims\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ;return 1 ;}else {",1547
489,"buggy line: Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_dims ) ;cwe id:CWE-125context: int obj2ast_slice ( PyObject * obj , slice_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty lower ; expr_ty upper ; expr_ty step ;  if ( exists_not_none ( obj , & PyId_lower ) ) {  int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & lower , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ;  } else {  lower = NULL ; } if ( exists_not_none ( obj , & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj , & PyId_step ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_step ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { step = NULL ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( _PyObject_HasAttrId ( obj , & PyId_dims ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_dims ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; dims = _Ta3_asdl_seq_new ( len , arena ) ; if ( dims == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  slice_ty value ;   res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( dims , i , value ) ;  }  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } * out = ExtSlice ( dims , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Index_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ;  if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {  int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ;  return 1 ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }",Py_ssize_t i ;,1547
490,"buggy line: slice_ty value ;res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( dims , i , value ) ;}Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""dims\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ;return 1 ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {expr_ty value ;if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ;return 1 ;cwe id:CWE-125context: int obj2ast_slice ( PyObject * obj , slice_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty lower ; expr_ty upper ; expr_ty step ;  if ( exists_not_none ( obj , & PyId_lower ) ) {  int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & lower , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ;  } else {  lower = NULL ; } if ( exists_not_none ( obj , & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj , & PyId_step ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_step ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { step = NULL ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( _PyObject_HasAttrId ( obj , & PyId_dims ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_dims ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; dims = _Ta3_asdl_seq_new ( len , arena ) ; if ( dims == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  slice_ty value ;   res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( dims , i , value ) ;  }  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } * out = ExtSlice ( dims , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Index_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ;  if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {  int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ;  return 1 ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","slice_ty val ;res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( dims , i , val ) ;}Py_CLEAR ( tmp ) ;if ( lookup_attr_id ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;",1547
491,"buggy line: static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode ,   const vp9_prob * probs ) {vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ;cwe id:CWE-119context:  static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode ,   const vp9_prob * probs ) {  vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }","static void write_intra_mode ( vpx_writer * w , MB_PREDICTION_MODE mode , const vpx_prob * probs ) {vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ;",1548
492,"buggy line: # ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw -> pw_uid , LU_GECOS , gecos ) < 0 ) {if ( setpwnam ( ctl -> pw ) < 0 ) {warn ( ""setpwnam<S2SV_blank>failed"" ) ;cwe id:CWE-000context: static int save_new_data ( struct chfn_control * ctl ) { char * gecos ; int len ; len = xasprintf ( & gecos , ""%s,%s,%s,%s,%s"" , ctl -> newf . full_name , ctl -> newf . office , ctl -> newf . office_phone , ctl -> newf . home_phone , ctl -> newf . other ) ; if ( ! ctl -> newf . other ) { while ( len > 0 && gecos [ len - 1 ] == ',' ) len -- ; gecos [ len ] = 0 ; } # ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw -> pw_uid , LU_GECOS , gecos ) < 0 ) { # else ctl -> pw -> pw_gecos = gecos ;  if ( setpwnam ( ctl -> pw ) < 0 ) {  warn ( ""setpwnam<S2SV_blank>failed"" ) ; # endif printf ( _ ( ""Finger<S2SV_blank>information<S2SV_blank>*NOT*<S2SV_blank>changed.<S2SV_blank><S2SV_blank>Try<S2SV_blank>again<S2SV_blank>later.\\n"" ) ) ; return - 1 ; } free ( gecos ) ; printf ( _ ( ""Finger<S2SV_blank>information<S2SV_blank>changed.\\n"" ) ) ; return 0 ; }","# ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw , "".chfn"" -> pw_uid , LU_GECOS , gecos ) < 0 ) {if ( setpwnam ( ctl -> pw ) < 0 ) {warn ( ""setpwnam<S2SV_blank>failed"" ) ;",1549
493,"buggy line: if ( radiotap_header -> it_version )  return - EINVAL ;iterator -> _rtheader = radiotap_header ;cwe id:CWE-119context: int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) {  if ( radiotap_header -> it_version )  return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg -  ( unsigned long ) iterator -> _rtheader >  ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }",if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ;if ( radiotap_header -> it_version ) return - EINVAL ;iterator -> _rtheader + sizeof ( uint32_t ) = radiotap_header ;,1550
494,"buggy line: if ( ( unsigned long ) iterator -> _arg -  ( unsigned long ) iterator -> _rtheader >  ( unsigned long ) iterator -> _max_length ) return - EINVAL ;cwe id:CWE-119context: int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) {  if ( radiotap_header -> it_version )  return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg -  ( unsigned long ) iterator -> _rtheader >  ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }",if ( ( unsigned long ) iterator -> _arg - ( unsigned long ) iterator -> _rtheader > ( unsigned long ) iterator -> _max_length ) return - EINVAL ;,1550
495,"buggy line: if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) )   goto err_delete ;tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ;cwe id:CWE-401context: static int nfp_abm_u32_knode_replace ( struct nfp_abm_link * alink , struct tc_cls_u32_knode * knode , __be16 proto , struct netlink_ext_ack * extack ) { struct nfp_abm_u32_match * match = NULL , * iter ; unsigned int tos_off ; u8 mask , val ; int err ;  if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) )   goto err_delete ;  tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ; val = be32_to_cpu ( knode -> sel -> keys [ 0 ] . val ) >> tos_off & 0xff ; mask = be32_to_cpu ( knode -> sel -> keys [ 0 ] . mask ) >> tos_off & 0xff ; list_for_each_entry ( iter , & alink -> dscp_map , list ) { u32 cmask ; if ( iter -> handle == knode -> handle ) { match = iter ; continue ; } cmask = iter -> mask & mask ; if ( ( iter -> val & cmask ) == ( val & cmask ) && iter -> band != knode -> res -> classid ) { NL_SET_ERR_MSG_MOD ( extack , ""conflict<S2SV_blank>with<S2SV_blank>already<S2SV_blank>offloaded<S2SV_blank>filter"" ) ;  goto err_delete ;  } } if ( ! match ) { match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match )  return - ENOMEM ;   list_add ( & match -> list , & alink -> dscp_map ) ;  } match -> handle = knode -> handle ; match -> band = knode -> res -> classid ; match -> mask = mask ; match -> val = val ; err = nfp_abm_update_band_map ( alink ) ; if ( err ) goto err_delete ; return 0 ; err_delete : nfp_abm_u32_knode_delete ( alink , knode ) ;  return - EOPNOTSUPP ;  }","if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) {err = - EOPNOTSUPP ;goto err_delete ;}tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ;",1551
496,"buggy line: goto err_delete ;}match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ;if ( ! match )  return - ENOMEM ;list_add ( & match -> list , & alink -> dscp_map ) ;}cwe id:CWE-401context: static int nfp_abm_u32_knode_replace ( struct nfp_abm_link * alink , struct tc_cls_u32_knode * knode , __be16 proto , struct netlink_ext_ack * extack ) { struct nfp_abm_u32_match * match = NULL , * iter ; unsigned int tos_off ; u8 mask , val ; int err ;  if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) )   goto err_delete ;  tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ; val = be32_to_cpu ( knode -> sel -> keys [ 0 ] . val ) >> tos_off & 0xff ; mask = be32_to_cpu ( knode -> sel -> keys [ 0 ] . mask ) >> tos_off & 0xff ; list_for_each_entry ( iter , & alink -> dscp_map , list ) { u32 cmask ; if ( iter -> handle == knode -> handle ) { match = iter ; continue ; } cmask = iter -> mask & mask ; if ( ( iter -> val & cmask ) == ( val & cmask ) && iter -> band != knode -> res -> classid ) { NL_SET_ERR_MSG_MOD ( extack , ""conflict<S2SV_blank>with<S2SV_blank>already<S2SV_blank>offloaded<S2SV_blank>filter"" ) ;  goto err_delete ;  } } if ( ! match ) { match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match )  return - ENOMEM ;   list_add ( & match -> list , & alink -> dscp_map ) ;  } match -> handle = knode -> handle ; match -> band = knode -> res -> classid ; match -> mask = mask ; match -> val = val ; err = nfp_abm_update_band_map ( alink ) ; if ( err ) goto err_delete ; return 0 ; err_delete : nfp_abm_u32_knode_delete ( alink , knode ) ;  return - EOPNOTSUPP ;  }","err = - EOPNOTSUPP ;goto err_delete ;}err = - ENOMEM ;goto err_delete ;}list_add ( & match -> list , & alink -> dscp_map ) ;}",1551
497,"buggy line: return - EOPNOTSUPP ;}cwe id:CWE-401context: static int nfp_abm_u32_knode_replace ( struct nfp_abm_link * alink , struct tc_cls_u32_knode * knode , __be16 proto , struct netlink_ext_ack * extack ) { struct nfp_abm_u32_match * match = NULL , * iter ; unsigned int tos_off ; u8 mask , val ; int err ;  if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) )   goto err_delete ;  tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ; val = be32_to_cpu ( knode -> sel -> keys [ 0 ] . val ) >> tos_off & 0xff ; mask = be32_to_cpu ( knode -> sel -> keys [ 0 ] . mask ) >> tos_off & 0xff ; list_for_each_entry ( iter , & alink -> dscp_map , list ) { u32 cmask ; if ( iter -> handle == knode -> handle ) { match = iter ; continue ; } cmask = iter -> mask & mask ; if ( ( iter -> val & cmask ) == ( val & cmask ) && iter -> band != knode -> res -> classid ) { NL_SET_ERR_MSG_MOD ( extack , ""conflict<S2SV_blank>with<S2SV_blank>already<S2SV_blank>offloaded<S2SV_blank>filter"" ) ;  goto err_delete ;  } } if ( ! match ) { match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match )  return - ENOMEM ;   list_add ( & match -> list , & alink -> dscp_map ) ;  } match -> handle = knode -> handle ; match -> band = knode -> res -> classid ; match -> mask = mask ; match -> val = val ; err = nfp_abm_update_band_map ( alink ) ; if ( err ) goto err_delete ; return 0 ; err_delete : nfp_abm_u32_knode_delete ( alink , knode ) ;  return - EOPNOTSUPP ;  }",return err ;},1551
498,"buggy line: }dst_state -> curframe = src -> curframe ;cwe id:CWE-189context: static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ;  }  dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }",}dst_state -> speculative = src -> speculative ;dst_state -> curframe = src -> curframe ;,1552
499,"buggy line: ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ;if ( gdImageTrueColor ( im ) ) {cwe id:CWE-787context: PHP_FUNCTION ( imagegammacorrect ) { zval * IM ; gdImagePtr im ; int i ; double input , output ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rdd"" , & IM , & input , & output ) == FAILURE ) { return ; }  ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ;  if ( gdImageTrueColor ( im ) ) { int x , y , c ; for ( y = 0 ; y < gdImageSY ( im ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( im ) ; x ++ ) { c = gdImageGetPixel ( im , x , y ) ; gdImageSetPixel ( im , x , y , gdTrueColorAlpha ( ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetRed ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetGreen ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetBlue ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , gdTrueColorGetAlpha ( c ) ) ) ; } } RETURN_TRUE ; } for ( i = 0 ; i < gdImageColorsTotal ( im ) ; i ++ ) { im -> red [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> red [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> green [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> green [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> blue [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> blue [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; } RETURN_TRUE ; }","if ( input <= 0.0 || output <= 0.0 ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ;RETURN_FALSE ;}ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ;if ( gdImageTrueColor ( im ) ) {",1553
500,"buggy line: stream -> config . cfg . g_pass = global -> passes == 2  ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ;if ( pass )  stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ;stream -> cx_time = 0 ;stream -> nbytes = 0 ;cwe id:CWE-119context: static void setup_pass ( struct stream_state * stream , struct VpxEncoderConfig * global , int pass ) { if ( stream -> config . stats_fn ) { if ( ! stats_open_file ( & stream -> stats , stream -> config . stats_fn , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>statistics<S2SV_blank>store"" ) ; } else { if ( ! stats_open_mem ( & stream -> stats , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>statistics<S2SV_blank>store"" ) ; }  stream -> config . cfg . g_pass = global -> passes == 2  ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ;  if ( pass )  stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ;  stream -> cx_time = 0 ;  stream -> nbytes = 0 ; stream -> frames_out = 0 ; }","# if CONFIG_FP_MB_STATS if ( stream -> config . fpmb_stats_fn ) {if ( ! stats_open_file ( & stream -> fpmb_stats , stream -> config . fpmb_stats_fn , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store"" ) ;}if ( ! stats_open_mem ( & stream -> fpmb_stats , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store"" ) ;}# endif else {stream -> config . cfg . g_pass = global -> passes == 2 ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ;if ( pass ) {stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ;# if CONFIG_FP_MB_STATS stream -> config . cfg . rc_firstpass_mb_stats_in = stats_get ( & stream -> fpmb_stats ) ;# endif }stream -> cx_time = 0 ;stream -> nbytes = 0 ;",1554
501,"buggy line: if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun )  sas_eh_defer_cmd ( cmd ) ;}cwe id:CWE-000context: static void sas_scsi_clear_queue_lu ( struct list_head * error_q , struct scsi_cmnd * my_cmd ) { struct scsi_cmnd * cmd , * n ; list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun )  sas_eh_defer_cmd ( cmd ) ;  } }",if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) sas_eh_finish_cmd ( cmd ) ;},1555
502,"buggy line: else  g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ;cwe id:CWE-74context: static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( ""export-desktop-XXXXXX"" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , "".service"" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( "".service"" ) ) ; dbus_name = g_key_file_get_string ( keyfile , ""D-BUS<S2SV_blank>Service"" , ""Name"" , NULL ) ; if ( dbus_name == NULL || strcmp ( dbus_name , expected_dbus_name ) != 0 ) { return flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""D-Bus<S2SV_blank>service<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>name"" ) , name ) ; } } if ( g_str_has_suffix ( name , "".desktop"" ) ) { gsize length ; g_auto ( GStrv ) tags = g_key_file_get_string_list ( metadata , ""Application"" , ""tags"" , & length , NULL ) ; if ( tags != NULL ) { g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak-Tags"" , ( const char * const * ) tags , length ) ; } g_key_file_set_string ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak"" , app ) ; if ( previous_ids != NULL ) { const char * X_FLATPAK_RENAMED_FROM = ""X-Flatpak-RenamedFrom"" ; g_auto ( GStrv ) renamed_from = g_key_file_get_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , NULL , NULL ) ; g_autoptr ( GPtrArray ) merged = g_ptr_array_new_with_free_func ( g_free ) ; g_autoptr ( GHashTable ) seen = g_hash_table_new ( g_str_hash , g_str_equal ) ; const char * new_suffix ; for ( i = 0 ; renamed_from != NULL && renamed_from [ i ] != NULL ; i ++ ) { if ( ! g_hash_table_contains ( seen , renamed_from [ i ] ) ) { gchar * copy = g_strdup ( renamed_from [ i ] ) ; g_hash_table_insert ( seen , copy , copy ) ; g_ptr_array_add ( merged , g_steal_pointer ( & copy ) ) ; } } g_assert ( g_str_has_prefix ( name , app ) ) ; new_suffix = name + strlen ( app ) ; for ( i = 0 ; previous_ids [ i ] != NULL ; i ++ ) { g_autofree gchar * previous_desktop = g_strconcat ( previous_ids [ i ] , new_suffix , NULL ) ; if ( ! g_hash_table_contains ( seen , previous_desktop ) ) { g_hash_table_insert ( seen , previous_desktop , previous_desktop ) ; g_ptr_array_add ( merged , g_steal_pointer ( & previous_desktop ) ) ; } } if ( merged -> len > 0 ) { g_ptr_array_add ( merged , NULL ) ; g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , ( const char * const * ) merged -> pdata , merged -> len - 1 ) ; } } } groups = g_key_file_get_groups ( keyfile , NULL ) ; for ( i = 0 ; groups [ i ] != NULL ; i ++ ) { g_auto ( GStrv ) flatpak_run_opts = g_key_file_get_string_list ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL , NULL ) ; g_autofree char * flatpak_run_args = format_flatpak_run_args_from_run_opts ( flatpak_run_opts ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""TryExec"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-GNOME-Bugzilla-ExtraInfoScript"" , NULL ) ; new_exec = g_string_new ( """" ) ; g_string_append_printf ( new_exec , FLATPAK_BINDIR ""/flatpak<S2SV_blank>run<S2SV_blank>--branch=%s<S2SV_blank>--arch=%s"" , escaped_branch , escaped_arch ) ; if ( flatpak_run_args != NULL ) g_string_append_printf ( new_exec , ""%s"" , flatpak_run_args ) ; old_exec = g_key_file_get_string ( keyfile , groups [ i ] , ""Exec"" , NULL ) ; if ( old_exec && g_shell_parse_argv ( old_exec , & old_argc , & old_argv , NULL ) && old_argc >= 1 ) { int j ; g_autofree char * command = maybe_quote ( old_argv [ 0 ] ) ; g_string_append_printf ( new_exec , ""<S2SV_blank>--command=%s"" , command ) ; for ( j = 1 ; j < old_argc ; j ++ ) { if ( strcasecmp ( old_argv [ j ] , ""%f"" ) == 0 || strcasecmp ( old_argv [ j ] , ""%u"" ) == 0 ) { g_string_append ( new_exec , ""<S2SV_blank>--file-forwarding"" ) ; break ; } } g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; for ( j = 1 ; j < old_argc ; j ++ ) { g_autofree char * arg = maybe_quote ( old_argv [ j ] ) ; if ( strcasecmp ( arg , ""%f"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( strcasecmp ( arg , ""%u"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@u<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ;  else  g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ; } } else { g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; } g_key_file_set_string ( keyfile , groups [ i ] , G_KEY_FILE_DESKTOP_KEY_EXEC , new_exec -> str ) ; } new_data = g_key_file_to_data ( keyfile , & new_data_len , error ) ; if ( new_data == NULL ) goto out ; if ( ! flatpak_open_in_tmpdir_at ( parent_fd , 0755 , tmpfile_name , & out_stream , cancellable , error ) ) goto out ; if ( ! g_output_stream_write_all ( out_stream , new_data , new_data_len , NULL , cancellable , error ) ) goto out ; if ( ! g_output_stream_close ( out_stream , cancellable , error ) ) goto out ; if ( target ) * target = g_steal_pointer ( & tmpfile_name ) ; ret = TRUE ; out : if ( new_exec != NULL ) g_string_free ( new_exec , TRUE ) ; return ret ; }","else if ( strcmp ( arg , ""@@"" ) == 0 || strcmp ( arg , ""@@u"" ) == 0 ) g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\\else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ;",1556
503,"buggy line: VP9_COMMON * const cm = & pbi -> common ;const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ;const uint8_t * end = NULL ;vp9_reader r ;assert ( tile_rows <= 4 ) ;vpx_memset ( cm -> above_context , 0 ,  sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ;vpx_memset ( cm -> above_seg_context , 0 ,   sizeof ( * cm -> above_seg_context ) * aligned_cols ) ;for ( tile_row = 0 ;const int last_tile = tile_row == tile_rows - 1 &&  tile_col == tile_cols - 1 ;const size_t size = get_tile ( data_end , last_tile , & cm -> error , & data ) ;TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ;buf -> data = data ;buf -> size = size ;data += size ;const int col = pbi -> oxcf . inv_tile_order ? tile_cols - tile_col - 1 : tile_col ;const int last_tile = tile_row == tile_rows - 1 && col == tile_cols - 1 ;const TileBuffer * const buf = & tile_buffers [ tile_row ] [ col ] ;TileInfo tile ;vp9_tile_init ( & tile , cm , tile_row , col ) ;setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & r ) ;decode_tile ( pbi , & tile , & r ) ;if ( last_tile ) end = vp9_reader_find_end ( & r ) ;return end ;cwe id:CWE-119context: static const uint8_t * decode_tiles ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) {  VP9_COMMON * const cm = & pbi -> common ;  const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; TileBuffer tile_buffers [ 4 ] [ 1 << 6 ] ; int tile_row , tile_col ;  const uint8_t * end = NULL ;   vp9_reader r ;  assert ( tile_rows <= 4 ) ; assert ( tile_cols <= ( 1 << 6 ) ) ;  vpx_memset ( cm -> above_context , 0 ,  sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ;  vpx_memset ( cm -> above_seg_context , 0 ,   sizeof ( * cm -> above_seg_context ) * aligned_cols ) ;  for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) {  const int last_tile = tile_row == tile_rows - 1 &&  tile_col == tile_cols - 1 ; const size_t size = get_tile ( data_end , last_tile , & cm -> error , & data ) ; TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; buf -> data = data ; buf -> size = size ; data += size ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int col = pbi -> oxcf . inv_tile_order ? tile_cols - tile_col - 1 : tile_col ; const int last_tile = tile_row == tile_rows - 1 && col == tile_cols - 1 ; const TileBuffer * const buf = & tile_buffers [ tile_row ] [ col ] ; TileInfo tile ; vp9_tile_init ( & tile , cm , tile_row , col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & r ) ; decode_tile ( pbi , & tile , & r ) ; if ( last_tile ) end = vp9_reader_find_end ( & r ) ; } } return end ; }","VP9_COMMON * const cm = & pbi -> common ;const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ;const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ;int mi_row , mi_col ;TileData * tile_data = NULL ;if ( cm -> lf . filter_level && ! cm -> skip_loop_filter && pbi -> lf_worker . data1 == NULL ) {CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ;memset ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) {LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ;winterface -> sync ( & pbi -> lf_worker ) ;vp9_loop_filter_data_reset ( lf_data , get_frame_new_buffer ( cm ) , cm , pbi -> mb . plane ) ;}assert ( tile_rows <= 4 ) ;vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ;memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * aligned_cols ) ;get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ;if ( pbi -> tile_data == NULL || ( tile_cols * tile_rows ) != pbi -> total_tiles ) {vpx_free ( pbi -> tile_data ) ;CHECK_MEM_ERROR ( cm , pbi -> tile_data , vpx_memalign ( 32 , tile_cols * tile_rows * ( sizeof ( * pbi -> tile_data ) ) ) ) ;pbi -> total_tiles = tile_rows * tile_cols ;}for ( tile_row = 0 ;const TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ;tile_data = pbi -> tile_data + tile_cols * tile_row + tile_col ;tile_data -> cm = cm ;tile_data -> xd = pbi -> mb ;tile_data -> xd . corrupted = 0 ;tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? NULL : & cm -> counts ;vp9_zero ( tile_data -> dqcoeff ) ;vp9_tile_init ( & tile_data -> xd . tile , tile_data -> cm , tile_row , tile_col ) ;setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ;vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ;TileInfo tile ;vp9_tile_set_row ( & tile , cm , tile_row ) ;for ( mi_row = tile . mi_row_start ;mi_row < tile . mi_row_end ;mi_row += MI_BLOCK_SIZE ) {const int col = pbi -> inv_tile_order ? tile_cols - tile_col - 1 : tile_col ;tile_data = pbi -> tile_data + tile_cols * tile_row + col ;vp9_tile_set_col ( & tile , tile_data -> cm , col ) ;vp9_zero ( tile_data -> xd . left_context ) ;vp9_zero ( tile_data -> xd . left_seg_context ) ;for ( mi_col = tile . mi_col_start ;mi_col < tile . mi_col_end ;mi_col += MI_BLOCK_SIZE ) {decode_partition ( pbi , & tile_data -> xd , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ;}pbi -> mb . corrupted |= tile_data -> xd . corrupted ;if ( pbi -> mb . corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>tile<S2SV_blank>data"" ) ;}if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) {const int lf_start = mi_row - MI_BLOCK_SIZE ;LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ;if ( lf_start < 0 ) continue ;if ( mi_row + MI_BLOCK_SIZE >= cm -> mi_rows ) continue ;winterface -> sync ( & pbi -> lf_worker ) ;lf_data -> start = lf_start ;lf_data -> stop = mi_row ;if ( pbi -> max_threads > 1 ) {winterface -> launch ( & pbi -> lf_worker ) ;}else {winterface -> execute ( & pbi -> lf_worker ) ;}}if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , mi_row << MI_BLOCK_SIZE_LOG2 ) ;}if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) {LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ;winterface -> sync ( & pbi -> lf_worker ) ;lf_data -> start = lf_data -> stop ;lf_data -> stop = cm -> mi_rows ;winterface -> execute ( & pbi -> lf_worker ) ;tile_data = pbi -> tile_data + tile_cols * tile_rows - 1 ;if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , INT_MAX ) ;return vpx_reader_find_end ( & tile_data -> bit_reader ) ;",1557
504,"buggy line: VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) {VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ;VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ;if ( ! cm ) return NULL ;cwe id:CWE-119context:  VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) {   VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ;   VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ;  if ( ! cm ) return NULL ; vp9_zero ( * pbi ) ; if ( setjmp ( cm -> error . jmp ) ) { cm -> error . setjmp = 0 ; vp9_decoder_remove ( pbi ) ; return NULL ; } cm -> error . setjmp = 1 ;  vp9_initialize_dec ( ) ;  vp9_rtcd ( ) ; vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ;  cm -> current_video_frame = 0 ;   pbi -> oxcf = * oxcf ;  pbi -> ready_for_new_data = 1 ;  pbi -> decoded_key_frame = 0 ;   vp9_init_dequantizer ( cm ) ;  vp9_loop_filter_init ( cm ) ; cm -> error . setjmp = 0 ; vp9_worker_init ( & pbi -> lf_worker ) ; return pbi ; }","VP9Decoder * vp9_decoder_create ( BufferPool * const pool ) {VP9Decoder * volatile const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ;VP9_COMMON * volatile const cm = pbi ? & pbi -> common : NULL ;if ( ! cm ) return NULL ;",1558
505,"buggy line: vp9_initialize_dec ( ) ;vp9_rtcd ( ) ;vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ;cm -> current_video_frame = 0 ;pbi -> oxcf = * oxcf ;pbi -> ready_for_new_data = 1 ;pbi -> decoded_key_frame = 0 ;vp9_init_dequantizer ( cm ) ;vp9_loop_filter_init ( cm ) ;cwe id:CWE-119context:  VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) {   VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ;   VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ;  if ( ! cm ) return NULL ; vp9_zero ( * pbi ) ; if ( setjmp ( cm -> error . jmp ) ) { cm -> error . setjmp = 0 ; vp9_decoder_remove ( pbi ) ; return NULL ; } cm -> error . setjmp = 1 ;  vp9_initialize_dec ( ) ;  vp9_rtcd ( ) ; vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ;  cm -> current_video_frame = 0 ;   pbi -> oxcf = * oxcf ;  pbi -> ready_for_new_data = 1 ;  pbi -> decoded_key_frame = 0 ;   vp9_init_dequantizer ( cm ) ;  vp9_loop_filter_init ( cm ) ; cm -> error . setjmp = 0 ; vp9_worker_init ( & pbi -> lf_worker ) ; return pbi ; }","CHECK_MEM_ERROR ( cm , cm -> fc , ( FRAME_CONTEXT * ) vpx_calloc ( 1 , sizeof ( * cm -> fc ) ) ) ;memset ( & cm -> next_ref_frame_map , - 1 , sizeof ( cm -> next_ref_frame_map ) ) ;CHECK_MEM_ERROR ( cm , cm -> frame_contexts , ( FRAME_CONTEXT * ) vpx_calloc ( FRAME_CONTEXTS , sizeof ( * cm -> frame_contexts ) ) ) ;pbi -> ready_for_new_data = 1 ;pbi -> decoded_key_frame = 0 ;vp9_init_dequantizer ( cm ) ;vp9_loop_filter_init ( cm ) ;",1558
506,"buggy line: GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\\( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ;}cwe id:CWE-401context: GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) {  GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n"" ) ) ;   ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ;  } return GF_OK ; }","GF_Box * dref ;GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\\dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ;( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) dref ;gf_isom_box_add_for_dump_mode ( s , dref ) ;}",1559
507,"buggy line: client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 ,  ( GSourceFunc ) _client_protocol_timeout , client ) ;cwe id:CWE-835context: static void setup_connection ( GsmXSMPClient * client ) { GIOChannel * channel ; int fd ; g_debug ( ""GsmXSMPClient:<S2SV_blank>Setting<S2SV_blank>up<S2SV_blank>new<S2SV_blank>connection"" ) ; fd = IceConnectionNumber ( client -> priv -> ice_connection ) ; fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; channel = g_io_channel_unix_new ( fd ) ; client -> priv -> watch_id = g_io_add_watch ( channel , G_IO_IN | G_IO_ERR , ( GIOFunc ) client_iochannel_watch , client ) ; g_io_channel_unref ( channel ) ;  client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 ,  ( GSourceFunc ) _client_protocol_timeout , client ) ; set_description ( client ) ; g_debug ( ""GsmXSMPClient:<S2SV_blank>New<S2SV_blank>client<S2SV_blank>\'%s\'"" , client -> priv -> description ) ; }","
",1560
508,"buggy line: }return new_fpl ;cwe id:CWE-399context: struct scm_fp_list * scm_fp_dup ( struct scm_fp_list * fpl ) { struct scm_fp_list * new_fpl ; int i ; if ( ! fpl ) return NULL ; new_fpl = kmemdup ( fpl , offsetof ( struct scm_fp_list , fp [ fpl -> count ] ) , GFP_KERNEL ) ; if ( new_fpl ) { for ( i = 0 ; i < fpl -> count ; i ++ ) get_file ( fpl -> fp [ i ] ) ; new_fpl -> max = new_fpl -> count ;  }  return new_fpl ; }",new_fpl -> user = get_uid ( fpl -> user ) ;}return new_fpl ;,1561
509,buggy line: struct ip_options * opt ;struct inet_request_sock * req_inet ;if ( opt == NULL || opt -> cipso == 0 )  return ;cwe id:CWE-362context: void cipso_v4_req_delattr ( struct request_sock * req ) {  struct ip_options * opt ;  struct inet_request_sock * req_inet ; req_inet = inet_rsk ( req ) ; opt = req_inet -> opt ;  if ( opt == NULL || opt -> cipso == 0 )  return ; cipso_v4_delopt ( & req_inet -> opt ) ; },struct ip_options_rcu * opt ;struct inet_request_sock * req_inet ;if ( opt == NULL || opt -> opt . cipso == 0 ) return ;,1562
510,"buggy line: static void tree2tok ( struct vp9_token * tokens , const vp9_tree_index * tree ,  int i , int v , int l ) {const vp9_tree_index j = tree [ i ++ ] ;if ( j <= 0 ) {cwe id:CWE-119context:  static void tree2tok ( struct vp9_token * tokens , const vp9_tree_index * tree ,  int i , int v , int l ) { v += v ; ++ l ; do {  const vp9_tree_index j = tree [ i ++ ] ;  if ( j <= 0 ) { tokens [ - j ] . value = v ; tokens [ - j ] . len = l ; } else { tree2tok ( tokens , tree , j , v , l ) ; } } while ( ++ v & 1 ) ; }","static void tree2tok ( struct vp9_token * tokens , const vpx_tree_index * tree , int i , int v , int l ) {const vpx_tree_index j = tree [ i ++ ] ;if ( j <= 0 ) {",1563
511,"buggy line: if ( img )   res = validate_img ( ctx , img ) ;pick_quickcompress_mode ( ctx , duration , deadline ) ;if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF |  VP8_EFLAG_NO_REF_ARF ) ) {int ref = 7 ;if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ;if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ;if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ;vp9_use_as_reference ( ctx -> cpi , ref ) ;}if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) {int upd = 7 ;if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_LAST_FLAG ;if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP9_GOLD_FLAG ;if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP9_ALT_FLAG ;vp9_update_reference ( ctx -> cpi , upd ) ;}if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) {vp9_update_entropy ( ctx -> cpi , 0 ) ;}if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) {unsigned int lib_flags ;YV12_BUFFER_CONFIG sd ;int64_t dst_time_stamp , dst_end_time_stamp ;size_t size , cx_data_sz ;if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR )  ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ;lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ;if ( vp9_receive_raw_frame ( ctx -> cpi , lib_flags ,  & sd , dst_time_stamp , dst_end_time_stamp ) ) {VP9_COMP * cpi = ( VP9_COMP * ) ctx -> cpi ;res = update_error_state ( ctx , & cpi -> common . error ) ;}}cx_data = ctx -> cx_data ;cx_data_sz = ctx -> cx_data_sz ;lib_flags = 0 ;cwe id:CWE-119context: static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ;  if ( img )   res = validate_img ( ctx , img ) ;  pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ; return VPX_CODEC_INVALID_PARAM ; }  if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF |  VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ; vp9_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP9_ALT_FLAG ; vp9_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp9_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { flags |= VPX_EFLAG_FORCE_KF ; ctx -> fixed_kf_cntr = 1 ; } }  if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) {   unsigned int lib_flags ;  YV12_BUFFER_CONFIG sd ;  int64_t dst_time_stamp , dst_end_time_stamp ;  size_t size , cx_data_sz ; unsigned char * cx_data ; if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR )  ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ;  lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; dst_time_stamp = ( pts * 10000000 * ctx -> cfg . g_timebase . num ) / ctx -> cfg . g_timebase . den ; dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; if ( img != NULL ) { res = image2yuvconfig ( img , & sd ) ;  if ( vp9_receive_raw_frame ( ctx -> cpi , lib_flags ,  & sd , dst_time_stamp , dst_end_time_stamp ) ) {  VP9_COMP * cpi = ( VP9_COMP * ) ctx -> cpi ;  res = update_error_state ( ctx , & cpi -> common . error ) ; }  }  cx_data = ctx -> cx_data ;  cx_data_sz = ctx -> cx_data_sz ;  lib_flags = 0 ; if ( ctx -> pending_cx_data ) { memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ; ctx -> pending_cx_data = cx_data ; cx_data += ctx -> pending_cx_data_sz ; cx_data_sz -= ctx -> pending_cx_data_sz ; if ( cx_data_sz < ctx -> cx_data_sz / 2 ) { ctx -> base . err_detail = ""Compressed<S2SV_blank>data<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small"" ; return VPX_CODEC_ERROR ; } } while ( cx_data_sz >= ctx -> cx_data_sz / 2 &&  - 1 != vp9_get_compressed_data ( ctx -> cpi , & lib_flags , & size ,  cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) { if ( size ) {  vpx_codec_pts_t round , delta ;  vpx_codec_cx_pkt_t pkt ;  VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ;   if ( cpi -> common . show_frame == 0 ) {  if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ; ctx -> pending_cx_data_sz += size ; ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; ctx -> pending_frame_magnitude |= size ; cx_data += size ; cx_data_sz -= size ;  continue ;  } round = ( vpx_codec_pts_t ) 1000000 * ctx -> cfg . g_timebase . num / 2 - 1 ; delta = ( dst_end_time_stamp - dst_time_stamp ) ;  pkt . kind = VPX_CODEC_CX_FRAME_PKT ;  pkt . data . frame . pts =  ( dst_time_stamp * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ; pkt . data . frame . duration = ( unsigned long )  ( ( delta * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ) ;  pkt . data . frame . flags = lib_flags << 16 ;  if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; if ( cpi -> common . show_frame == 0 ) { pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; pkt . data . frame . duration = 0 ; } if ( cpi -> droppable ) pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; if ( ctx -> pending_cx_data ) { ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; ctx -> pending_frame_magnitude |= size ; ctx -> pending_cx_data_sz += size ;  size += write_superframe_index ( ctx ) ;  pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = ctx -> pending_cx_data_sz ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; } else { pkt . data . frame . buf = cx_data ; pkt . data . frame . sz = size ; } pkt . data . frame . partition_id = - 1 ;  vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ;  cx_data += size ; cx_data_sz -= size ;  }  } } return res ; }","VP9_COMP * const cpi = ctx -> cpi ;const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ;size_t data_sz ;if ( img != NULL ) {res = validate_img ( ctx , img ) ;if ( res == VPX_CODEC_OK && cpi != NULL ) {data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * ( cpi -> multi_arf_allowed ? 8 : 2 ) ;if ( data_sz < 4096 ) data_sz = 4096 ;if ( ctx -> cx_data == NULL || ctx -> cx_data_sz < data_sz ) {ctx -> cx_data_sz = data_sz ;free ( ctx -> cx_data ) ;ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ;if ( ctx -> cx_data == NULL ) {return VPX_CODEC_MEM_ERROR ;}}}}pick_quickcompress_mode ( ctx , duration , deadline ) ;vp9_apply_encoding_flags ( cpi , flags ) ;if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) {unsigned int lib_flags = 0 ;YV12_BUFFER_CONFIG sd ;int64_t dst_time_stamp , dst_end_time_stamp ;size_t size , cx_data_sz ;if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ;lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ;if ( vp9_receive_raw_frame ( cpi , flags | ctx -> next_frame_flags , & sd , dst_time_stamp , dst_end_time_stamp ) ) {res = update_error_state ( ctx , & cpi -> common . error ) ;}ctx -> next_frame_flags = 0 ;}cx_data = ctx -> cx_data ;cx_data_sz = ctx -> cx_data_sz ;",1564
512,"buggy line: while ( cx_data_sz >= ctx -> cx_data_sz / 2 &&  - 1 != vp9_get_compressed_data ( ctx -> cpi , & lib_flags , & size ,  cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) {vpx_codec_pts_t round , delta ;vpx_codec_cx_pkt_t pkt ;VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ;if ( cpi -> common . show_frame == 0 ) {if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ;continue ;}round = ( vpx_codec_pts_t ) 1000000 * ctx -> cfg . g_timebase . num / 2 - 1 ;delta = ( dst_end_time_stamp - dst_time_stamp ) ;pkt . kind = VPX_CODEC_CX_FRAME_PKT ;pkt . data . frame . pts =  ( dst_time_stamp * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ;pkt . data . frame . duration = ( unsigned long )  ( ( delta * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ) ;pkt . data . frame . flags = lib_flags << 16 ;if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ;cwe id:CWE-119context: static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ;  if ( img )   res = validate_img ( ctx , img ) ;  pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ; return VPX_CODEC_INVALID_PARAM ; }  if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF |  VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ; vp9_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP9_ALT_FLAG ; vp9_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp9_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { flags |= VPX_EFLAG_FORCE_KF ; ctx -> fixed_kf_cntr = 1 ; } }  if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) {   unsigned int lib_flags ;  YV12_BUFFER_CONFIG sd ;  int64_t dst_time_stamp , dst_end_time_stamp ;  size_t size , cx_data_sz ; unsigned char * cx_data ; if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR )  ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ;  lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; dst_time_stamp = ( pts * 10000000 * ctx -> cfg . g_timebase . num ) / ctx -> cfg . g_timebase . den ; dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; if ( img != NULL ) { res = image2yuvconfig ( img , & sd ) ;  if ( vp9_receive_raw_frame ( ctx -> cpi , lib_flags ,  & sd , dst_time_stamp , dst_end_time_stamp ) ) {  VP9_COMP * cpi = ( VP9_COMP * ) ctx -> cpi ;  res = update_error_state ( ctx , & cpi -> common . error ) ; }  }  cx_data = ctx -> cx_data ;  cx_data_sz = ctx -> cx_data_sz ;  lib_flags = 0 ; if ( ctx -> pending_cx_data ) { memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ; ctx -> pending_cx_data = cx_data ; cx_data += ctx -> pending_cx_data_sz ; cx_data_sz -= ctx -> pending_cx_data_sz ; if ( cx_data_sz < ctx -> cx_data_sz / 2 ) { ctx -> base . err_detail = ""Compressed<S2SV_blank>data<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small"" ; return VPX_CODEC_ERROR ; } } while ( cx_data_sz >= ctx -> cx_data_sz / 2 &&  - 1 != vp9_get_compressed_data ( ctx -> cpi , & lib_flags , & size ,  cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) { if ( size ) {  vpx_codec_pts_t round , delta ;  vpx_codec_cx_pkt_t pkt ;  VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ;   if ( cpi -> common . show_frame == 0 ) {  if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ; ctx -> pending_cx_data_sz += size ; ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; ctx -> pending_frame_magnitude |= size ; cx_data += size ; cx_data_sz -= size ;  continue ;  } round = ( vpx_codec_pts_t ) 1000000 * ctx -> cfg . g_timebase . num / 2 - 1 ; delta = ( dst_end_time_stamp - dst_time_stamp ) ;  pkt . kind = VPX_CODEC_CX_FRAME_PKT ;  pkt . data . frame . pts =  ( dst_time_stamp * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ; pkt . data . frame . duration = ( unsigned long )  ( ( delta * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ) ;  pkt . data . frame . flags = lib_flags << 16 ;  if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; if ( cpi -> common . show_frame == 0 ) { pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; pkt . data . frame . duration = 0 ; } if ( cpi -> droppable ) pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; if ( ctx -> pending_cx_data ) { ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; ctx -> pending_frame_magnitude |= size ; ctx -> pending_cx_data_sz += size ;  size += write_superframe_index ( ctx ) ;  pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = ctx -> pending_cx_data_sz ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; } else { pkt . data . frame . buf = cx_data ; pkt . data . frame . sz = size ; } pkt . data . frame . partition_id = - 1 ;  vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ;  cx_data += size ; cx_data_sz -= size ;  }  } } return res ; }","while ( cx_data_sz >= ctx -> cx_data_sz / 2 && - 1 != vp9_get_compressed_data ( cpi , & lib_flags , & size , cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) {vpx_codec_cx_pkt_t pkt ;VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ;if ( cpi -> common . show_frame || ( cpi -> use_svc && cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) ) {if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ;if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) {pkt . kind = VPX_CODEC_CX_FRAME_PKT ;pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ;pkt . data . frame . buf = ctx -> pending_cx_data ;pkt . data . frame . sz = size ;ctx -> pending_cx_data = NULL ;ctx -> pending_cx_data_sz = 0 ;ctx -> pending_frame_count = 0 ;ctx -> pending_frame_magnitude = 0 ;ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ;}continue ;}pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ;pkt . data . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp ) ;pkt . kind = VPX_CODEC_CX_FRAME_PKT ;pkt . data . frame . pts = ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ;pkt . data . frame . duration = ( unsigned long ) ( ( delta * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) ;pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ;if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ;",1564
513,"buggy line: size += write_superframe_index ( ctx ) ;pkt . data . frame . buf = ctx -> pending_cx_data ;cwe id:CWE-119context: static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ;  if ( img )   res = validate_img ( ctx , img ) ;  pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ; return VPX_CODEC_INVALID_PARAM ; }  if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF |  VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ; vp9_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP9_ALT_FLAG ; vp9_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp9_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { flags |= VPX_EFLAG_FORCE_KF ; ctx -> fixed_kf_cntr = 1 ; } }  if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) {   unsigned int lib_flags ;  YV12_BUFFER_CONFIG sd ;  int64_t dst_time_stamp , dst_end_time_stamp ;  size_t size , cx_data_sz ; unsigned char * cx_data ; if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR )  ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ;  lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; dst_time_stamp = ( pts * 10000000 * ctx -> cfg . g_timebase . num ) / ctx -> cfg . g_timebase . den ; dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; if ( img != NULL ) { res = image2yuvconfig ( img , & sd ) ;  if ( vp9_receive_raw_frame ( ctx -> cpi , lib_flags ,  & sd , dst_time_stamp , dst_end_time_stamp ) ) {  VP9_COMP * cpi = ( VP9_COMP * ) ctx -> cpi ;  res = update_error_state ( ctx , & cpi -> common . error ) ; }  }  cx_data = ctx -> cx_data ;  cx_data_sz = ctx -> cx_data_sz ;  lib_flags = 0 ; if ( ctx -> pending_cx_data ) { memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ; ctx -> pending_cx_data = cx_data ; cx_data += ctx -> pending_cx_data_sz ; cx_data_sz -= ctx -> pending_cx_data_sz ; if ( cx_data_sz < ctx -> cx_data_sz / 2 ) { ctx -> base . err_detail = ""Compressed<S2SV_blank>data<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small"" ; return VPX_CODEC_ERROR ; } } while ( cx_data_sz >= ctx -> cx_data_sz / 2 &&  - 1 != vp9_get_compressed_data ( ctx -> cpi , & lib_flags , & size ,  cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) { if ( size ) {  vpx_codec_pts_t round , delta ;  vpx_codec_cx_pkt_t pkt ;  VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ;   if ( cpi -> common . show_frame == 0 ) {  if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ; ctx -> pending_cx_data_sz += size ; ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; ctx -> pending_frame_magnitude |= size ; cx_data += size ; cx_data_sz -= size ;  continue ;  } round = ( vpx_codec_pts_t ) 1000000 * ctx -> cfg . g_timebase . num / 2 - 1 ; delta = ( dst_end_time_stamp - dst_time_stamp ) ;  pkt . kind = VPX_CODEC_CX_FRAME_PKT ;  pkt . data . frame . pts =  ( dst_time_stamp * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ; pkt . data . frame . duration = ( unsigned long )  ( ( delta * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ) ;  pkt . data . frame . flags = lib_flags << 16 ;  if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; if ( cpi -> common . show_frame == 0 ) { pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; pkt . data . frame . duration = 0 ; } if ( cpi -> droppable ) pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; if ( ctx -> pending_cx_data ) { ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; ctx -> pending_frame_magnitude |= size ; ctx -> pending_cx_data_sz += size ;  size += write_superframe_index ( ctx ) ;  pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = ctx -> pending_cx_data_sz ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; } else { pkt . data . frame . buf = cx_data ; pkt . data . frame . sz = size ; } pkt . data . frame . partition_id = - 1 ;  vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ;  cx_data += size ; cx_data_sz -= size ;  }  } } return res ; }",if ( ! ctx -> output_cx_pkt_cb . output_cx_pkt ) size += write_superframe_index ( ctx ) ;pkt . data . frame . buf = ctx -> pending_cx_data ;,1564
514,"buggy line: vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ;cx_data += size ;}}cwe id:CWE-119context: static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ;  if ( img )   res = validate_img ( ctx , img ) ;  pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ; return VPX_CODEC_INVALID_PARAM ; }  if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF |  VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ; vp9_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP9_ALT_FLAG ; vp9_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp9_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { flags |= VPX_EFLAG_FORCE_KF ; ctx -> fixed_kf_cntr = 1 ; } }  if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) {   unsigned int lib_flags ;  YV12_BUFFER_CONFIG sd ;  int64_t dst_time_stamp , dst_end_time_stamp ;  size_t size , cx_data_sz ; unsigned char * cx_data ; if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR )  ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ;  lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; dst_time_stamp = ( pts * 10000000 * ctx -> cfg . g_timebase . num ) / ctx -> cfg . g_timebase . den ; dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; if ( img != NULL ) { res = image2yuvconfig ( img , & sd ) ;  if ( vp9_receive_raw_frame ( ctx -> cpi , lib_flags ,  & sd , dst_time_stamp , dst_end_time_stamp ) ) {  VP9_COMP * cpi = ( VP9_COMP * ) ctx -> cpi ;  res = update_error_state ( ctx , & cpi -> common . error ) ; }  }  cx_data = ctx -> cx_data ;  cx_data_sz = ctx -> cx_data_sz ;  lib_flags = 0 ; if ( ctx -> pending_cx_data ) { memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ; ctx -> pending_cx_data = cx_data ; cx_data += ctx -> pending_cx_data_sz ; cx_data_sz -= ctx -> pending_cx_data_sz ; if ( cx_data_sz < ctx -> cx_data_sz / 2 ) { ctx -> base . err_detail = ""Compressed<S2SV_blank>data<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small"" ; return VPX_CODEC_ERROR ; } } while ( cx_data_sz >= ctx -> cx_data_sz / 2 &&  - 1 != vp9_get_compressed_data ( ctx -> cpi , & lib_flags , & size ,  cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) { if ( size ) {  vpx_codec_pts_t round , delta ;  vpx_codec_cx_pkt_t pkt ;  VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ;   if ( cpi -> common . show_frame == 0 ) {  if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ; ctx -> pending_cx_data_sz += size ; ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; ctx -> pending_frame_magnitude |= size ; cx_data += size ; cx_data_sz -= size ;  continue ;  } round = ( vpx_codec_pts_t ) 1000000 * ctx -> cfg . g_timebase . num / 2 - 1 ; delta = ( dst_end_time_stamp - dst_time_stamp ) ;  pkt . kind = VPX_CODEC_CX_FRAME_PKT ;  pkt . data . frame . pts =  ( dst_time_stamp * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ; pkt . data . frame . duration = ( unsigned long )  ( ( delta * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ) ;  pkt . data . frame . flags = lib_flags << 16 ;  if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; if ( cpi -> common . show_frame == 0 ) { pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; pkt . data . frame . duration = 0 ; } if ( cpi -> droppable ) pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; if ( ctx -> pending_cx_data ) { ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; ctx -> pending_frame_magnitude |= size ; ctx -> pending_cx_data_sz += size ;  size += write_superframe_index ( ctx ) ;  pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = ctx -> pending_cx_data_sz ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; } else { pkt . data . frame . buf = cx_data ; pkt . data . frame . sz = size ; } pkt . data . frame . partition_id = - 1 ;  vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ;  cx_data += size ; cx_data_sz -= size ;  }  } } return res ; }","if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ;else vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ;cx_data += size ;# if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc && ! ctx -> output_cx_pkt_cb . output_cx_pkt ) {vpx_codec_cx_pkt_t pkt_sizes , pkt_psnr ;int sl ;vp9_zero ( pkt_sizes ) ;vp9_zero ( pkt_psnr ) ;pkt_sizes . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ;pkt_psnr . kind = VPX_CODEC_SPATIAL_SVC_LAYER_PSNR ;for ( sl = 0 ;sl < cpi -> svc . number_spatial_layers ;++ sl ) {LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ sl * cpi -> svc . number_temporal_layers ] ;pkt_sizes . data . layer_sizes [ sl ] = lc -> layer_size ;pkt_psnr . data . layer_psnr [ sl ] = lc -> psnr_pkt ;lc -> layer_size = 0 ;}vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_sizes ) ;vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_psnr ) ;}# endif # endif if ( is_one_pass_cbr_svc ( cpi ) && ( cpi -> svc . spatial_layer_id == cpi -> svc . number_spatial_layers - 1 ) ) {break ;}}}",1564
515,"buggy line: ctx -> clockid = clockid ;if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ;cwe id:CWE-416context: SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) { int ufd ; struct timerfd_ctx * ctx ; BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; if ( ( flags & ~ TFD_CREATE_FLAGS ) || ( clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME && clockid != CLOCK_REALTIME_ALARM && clockid != CLOCK_BOOTTIME && clockid != CLOCK_BOOTTIME_ALARM ) ) return - EINVAL ; if ( ! capable ( CAP_WAKE_ALARM ) && ( clockid == CLOCK_REALTIME_ALARM || clockid == CLOCK_BOOTTIME_ALARM ) ) return - EPERM ; ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ;  ctx -> clockid = clockid ;  if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ; else hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; ctx -> moffs = ktime_mono_to_real ( 0 ) ; ufd = anon_inode_getfd ( ""[timerfd]"" , & timerfd_fops , ctx , O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; if ( ufd < 0 ) kfree ( ctx ) ; return ufd ; }","spin_lock_init ( & ctx -> cancel_lock ) ;ctx -> clockid = clockid ;if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ;",1565
516,"buggy line: struct mount * child , * p ;struct hlist_node * n ;if ( IS_MNT_SHARED ( dest_mnt ) ) {err = invent_group_ids ( source_mnt , true ) ;err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;lock_mount_hash ( ) ;cwe id:CWE-400context: static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ;  struct mount * child , * p ;  struct hlist_node * n ; int err ;  if ( IS_MNT_SHARED ( dest_mnt ) ) {  err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ;  err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;  lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ;  umount_tree ( child , UMOUNT_SYNC ) ;  } unlock_mount_hash ( ) ; cleanup_group_ids ( source_mnt , NULL ) ; out :  return err ;  }","struct mnt_namespace * ns = dest_mnt -> mnt_ns ;struct mount * child , * p ;struct hlist_node * n ;if ( ! parent_path ) {err = count_mounts ( ns , source_mnt ) ;}if ( IS_MNT_SHARED ( dest_mnt ) ) {err = invent_group_ids ( source_mnt , true ) ;if ( err ) goto out ;err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;lock_mount_hash ( ) ;",1566
517,"buggy line: cwe id:CWE-400context: static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ;  struct mount * child , * p ;  struct hlist_node * n ; int err ;  if ( IS_MNT_SHARED ( dest_mnt ) ) {  err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ;  err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;  lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ;  umount_tree ( child , UMOUNT_SYNC ) ;  } unlock_mount_hash ( ) ; cleanup_group_ids ( source_mnt , NULL ) ; out :  return err ;  }",child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ;,1566
518,"buggy line: umount_tree ( child , UMOUNT_SYNC ) ;}out :  return err ;}cwe id:CWE-400context: static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ;  struct mount * child , * p ;  struct hlist_node * n ; int err ;  if ( IS_MNT_SHARED ( dest_mnt ) ) {  err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ;  err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;  lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ;  umount_tree ( child , UMOUNT_SYNC ) ;  } unlock_mount_hash ( ) ; cleanup_group_ids ( source_mnt , NULL ) ; out :  return err ;  }","umount_tree ( child , UMOUNT_SYNC ) ;}out : ns -> pending_mounts = 0 ;return err ;}",1566
519,"buggy line: ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ;if ( ret ) goto error ;cwe id:CWE-674context: static krb5_error_code decode_sequence_of ( const uint8_t * asn1 , size_t len , const struct atype_info * elemtype , void * * seq_out , size_t * count_out ) { krb5_error_code ret ; void * seq = NULL , * elem , * newseq ; const uint8_t * contents ; size_t clen , count = 0 ; taginfo t ; * seq_out = NULL ; * count_out = 0 ; while ( len > 0 ) {  ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ;  if ( ret ) goto error ; if ( ! check_atype_tag ( elemtype , & t ) ) { ret = ASN1_BAD_ID ; goto error ; } newseq = realloc ( seq , ( count + 1 ) * elemtype -> size ) ; if ( newseq == NULL ) { ret = ENOMEM ; goto error ; } seq = newseq ; elem = ( char * ) seq + count * elemtype -> size ; memset ( elem , 0 , elemtype -> size ) ; ret = decode_atype ( & t , contents , clen , elemtype , elem ) ; if ( ret ) goto error ; count ++ ; } * seq_out = seq ; * count_out = count ; return 0 ; error : free_sequence_of ( elemtype , seq , count ) ; free ( seq ) ; return ret ; }","ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len , 0 ) ;if ( ret ) goto error ;",1567
520,"buggy line: void fadst16_8col ( __m128i * in ) {__m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ;cwe id:CWE-119context:  void fadst16_8col ( __m128i * in ) {  __m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ; const __m128i k__cospi_p01_p31 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ; const __m128i k__cospi_p31_m01 = pair_set_epi16 ( cospi_31_64 , - cospi_1_64 ) ; const __m128i k__cospi_p05_p27 = pair_set_epi16 ( cospi_5_64 , cospi_27_64 ) ; const __m128i k__cospi_p27_m05 = pair_set_epi16 ( cospi_27_64 , - cospi_5_64 ) ; const __m128i k__cospi_p09_p23 = pair_set_epi16 ( cospi_9_64 , cospi_23_64 ) ; const __m128i k__cospi_p23_m09 = pair_set_epi16 ( cospi_23_64 , - cospi_9_64 ) ; const __m128i k__cospi_p13_p19 = pair_set_epi16 ( cospi_13_64 , cospi_19_64 ) ; const __m128i k__cospi_p19_m13 = pair_set_epi16 ( cospi_19_64 , - cospi_13_64 ) ; const __m128i k__cospi_p17_p15 = pair_set_epi16 ( cospi_17_64 , cospi_15_64 ) ; const __m128i k__cospi_p15_m17 = pair_set_epi16 ( cospi_15_64 , - cospi_17_64 ) ; const __m128i k__cospi_p21_p11 = pair_set_epi16 ( cospi_21_64 , cospi_11_64 ) ; const __m128i k__cospi_p11_m21 = pair_set_epi16 ( cospi_11_64 , - cospi_21_64 ) ; const __m128i k__cospi_p25_p07 = pair_set_epi16 ( cospi_25_64 , cospi_7_64 ) ; const __m128i k__cospi_p07_m25 = pair_set_epi16 ( cospi_7_64 , - cospi_25_64 ) ; const __m128i k__cospi_p29_p03 = pair_set_epi16 ( cospi_29_64 , cospi_3_64 ) ; const __m128i k__cospi_p03_m29 = pair_set_epi16 ( cospi_3_64 , - cospi_29_64 ) ; const __m128i k__cospi_p04_p28 = pair_set_epi16 ( cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p28_m04 = pair_set_epi16 ( cospi_28_64 , - cospi_4_64 ) ; const __m128i k__cospi_p20_p12 = pair_set_epi16 ( cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p12_m20 = pair_set_epi16 ( cospi_12_64 , - cospi_20_64 ) ; const __m128i k__cospi_m28_p04 = pair_set_epi16 ( - cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m12_p20 = pair_set_epi16 ( - cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ;  const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ;   const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;  const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; const __m128i kZero = _mm_set1_epi16 ( 0 ) ; u [ 0 ] = _mm_unpacklo_epi16 ( in [ 15 ] , in [ 0 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( in [ 15 ] , in [ 0 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( in [ 13 ] , in [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( in [ 13 ] , in [ 2 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( in [ 11 ] , in [ 4 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( in [ 11 ] , in [ 4 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( in [ 9 ] , in [ 6 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( in [ 9 ] , in [ 6 ] ) ; u [ 8 ] = _mm_unpacklo_epi16 ( in [ 7 ] , in [ 8 ] ) ; u [ 9 ] = _mm_unpackhi_epi16 ( in [ 7 ] , in [ 8 ] ) ; u [ 10 ] = _mm_unpacklo_epi16 ( in [ 5 ] , in [ 10 ] ) ; u [ 11 ] = _mm_unpackhi_epi16 ( in [ 5 ] , in [ 10 ] ) ; u [ 12 ] = _mm_unpacklo_epi16 ( in [ 3 ] , in [ 12 ] ) ; u [ 13 ] = _mm_unpackhi_epi16 ( in [ 3 ] , in [ 12 ] ) ; u [ 14 ] = _mm_unpacklo_epi16 ( in [ 1 ] , in [ 14 ] ) ; u [ 15 ] = _mm_unpackhi_epi16 ( in [ 1 ] , in [ 14 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p01_p31 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p01_p31 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p31_m01 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p31_m01 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p05_p27 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p05_p27 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p27_m05 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p27_m05 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p09_p23 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p09_p23 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p23_m09 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p23_m09 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p13_p19 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p13_p19 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p19_m13 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p19_m13 ) ; v [ 16 ] = _mm_madd_epi16 ( u [ 8 ] , k__cospi_p17_p15 ) ; v [ 17 ] = _mm_madd_epi16 ( u [ 9 ] , k__cospi_p17_p15 ) ; v [ 18 ] = _mm_madd_epi16 ( u [ 8 ] , k__cospi_p15_m17 ) ; v [ 19 ] = _mm_madd_epi16 ( u [ 9 ] , k__cospi_p15_m17 ) ; v [ 20 ] = _mm_madd_epi16 ( u [ 10 ] , k__cospi_p21_p11 ) ; v [ 21 ] = _mm_madd_epi16 ( u [ 11 ] , k__cospi_p21_p11 ) ; v [ 22 ] = _mm_madd_epi16 ( u [ 10 ] , k__cospi_p11_m21 ) ; v [ 23 ] = _mm_madd_epi16 ( u [ 11 ] , k__cospi_p11_m21 ) ; v [ 24 ] = _mm_madd_epi16 ( u [ 12 ] , k__cospi_p25_p07 ) ; v [ 25 ] = _mm_madd_epi16 ( u [ 13 ] , k__cospi_p25_p07 ) ; v [ 26 ] = _mm_madd_epi16 ( u [ 12 ] , k__cospi_p07_m25 ) ; v [ 27 ] = _mm_madd_epi16 ( u [ 13 ] , k__cospi_p07_m25 ) ; v [ 28 ] = _mm_madd_epi16 ( u [ 14 ] , k__cospi_p29_p03 ) ; v [ 29 ] = _mm_madd_epi16 ( u [ 15 ] , k__cospi_p29_p03 ) ; v [ 30 ] = _mm_madd_epi16 ( u [ 14 ] , k__cospi_p03_m29 ) ; v [ 31 ] = _mm_madd_epi16 ( u [ 15 ] , k__cospi_p03_m29 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 16 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 17 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 18 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 19 ] ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , v [ 20 ] ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , v [ 21 ] ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , v [ 22 ] ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , v [ 23 ] ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , v [ 24 ] ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , v [ 25 ] ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , v [ 26 ] ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , v [ 27 ] ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , v [ 28 ] ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , v [ 29 ] ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , v [ 30 ] ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , v [ 31 ] ) ; u [ 16 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 16 ] ) ; u [ 17 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 17 ] ) ; u [ 18 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 18 ] ) ; u [ 19 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 19 ] ) ; u [ 20 ] = _mm_sub_epi32 ( v [ 4 ] , v [ 20 ] ) ; u [ 21 ] = _mm_sub_epi32 ( v [ 5 ] , v [ 21 ] ) ; u [ 22 ] = _mm_sub_epi32 ( v [ 6 ] , v [ 22 ] ) ; u [ 23 ] = _mm_sub_epi32 ( v [ 7 ] , v [ 23 ] ) ; u [ 24 ] = _mm_sub_epi32 ( v [ 8 ] , v [ 24 ] ) ; u [ 25 ] = _mm_sub_epi32 ( v [ 9 ] , v [ 25 ] ) ; u [ 26 ] = _mm_sub_epi32 ( v [ 10 ] , v [ 26 ] ) ; u [ 27 ] = _mm_sub_epi32 ( v [ 11 ] , v [ 27 ] ) ; u [ 28 ] = _mm_sub_epi32 ( v [ 12 ] , v [ 28 ] ) ; u [ 29 ] = _mm_sub_epi32 ( v [ 13 ] , v [ 29 ] ) ; u [ 30 ] = _mm_sub_epi32 ( v [ 14 ] , v [ 30 ] ) ; u [ 31 ] = _mm_sub_epi32 ( v [ 15 ] , v [ 31 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; v [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; v [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; v [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; v [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; v [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; v [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; v [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 16 ] = _mm_add_epi32 ( u [ 16 ] , k__DCT_CONST_ROUNDING ) ; v [ 17 ] = _mm_add_epi32 ( u [ 17 ] , k__DCT_CONST_ROUNDING ) ; v [ 18 ] = _mm_add_epi32 ( u [ 18 ] , k__DCT_CONST_ROUNDING ) ; v [ 19 ] = _mm_add_epi32 ( u [ 19 ] , k__DCT_CONST_ROUNDING ) ; v [ 20 ] = _mm_add_epi32 ( u [ 20 ] , k__DCT_CONST_ROUNDING ) ; v [ 21 ] = _mm_add_epi32 ( u [ 21 ] , k__DCT_CONST_ROUNDING ) ; v [ 22 ] = _mm_add_epi32 ( u [ 22 ] , k__DCT_CONST_ROUNDING ) ; v [ 23 ] = _mm_add_epi32 ( u [ 23 ] , k__DCT_CONST_ROUNDING ) ; v [ 24 ] = _mm_add_epi32 ( u [ 24 ] , k__DCT_CONST_ROUNDING ) ; v [ 25 ] = _mm_add_epi32 ( u [ 25 ] , k__DCT_CONST_ROUNDING ) ; v [ 26 ] = _mm_add_epi32 ( u [ 26 ] , k__DCT_CONST_ROUNDING ) ; v [ 27 ] = _mm_add_epi32 ( u [ 27 ] , k__DCT_CONST_ROUNDING ) ; v [ 28 ] = _mm_add_epi32 ( u [ 28 ] , k__DCT_CONST_ROUNDING ) ; v [ 29 ] = _mm_add_epi32 ( u [ 29 ] , k__DCT_CONST_ROUNDING ) ; v [ 30 ] = _mm_add_epi32 ( u [ 30 ] , k__DCT_CONST_ROUNDING ) ; v [ 31 ] = _mm_add_epi32 ( u [ 31 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; u [ 8 ] = _mm_srai_epi32 ( v [ 8 ] , DCT_CONST_BITS ) ; u [ 9 ] = _mm_srai_epi32 ( v [ 9 ] , DCT_CONST_BITS ) ; u [ 10 ] = _mm_srai_epi32 ( v [ 10 ] , DCT_CONST_BITS ) ; u [ 11 ] = _mm_srai_epi32 ( v [ 11 ] , DCT_CONST_BITS ) ; u [ 12 ] = _mm_srai_epi32 ( v [ 12 ] , DCT_CONST_BITS ) ; u [ 13 ] = _mm_srai_epi32 ( v [ 13 ] , DCT_CONST_BITS ) ; u [ 14 ] = _mm_srai_epi32 ( v [ 14 ] , DCT_CONST_BITS ) ; u [ 15 ] = _mm_srai_epi32 ( v [ 15 ] , DCT_CONST_BITS ) ; u [ 16 ] = _mm_srai_epi32 ( v [ 16 ] , DCT_CONST_BITS ) ; u [ 17 ] = _mm_srai_epi32 ( v [ 17 ] , DCT_CONST_BITS ) ; u [ 18 ] = _mm_srai_epi32 ( v [ 18 ] , DCT_CONST_BITS ) ; u [ 19 ] = _mm_srai_epi32 ( v [ 19 ] , DCT_CONST_BITS ) ; u [ 20 ] = _mm_srai_epi32 ( v [ 20 ] , DCT_CONST_BITS ) ; u [ 21 ] = _mm_srai_epi32 ( v [ 21 ] , DCT_CONST_BITS ) ; u [ 22 ] = _mm_srai_epi32 ( v [ 22 ] , DCT_CONST_BITS ) ; u [ 23 ] = _mm_srai_epi32 ( v [ 23 ] , DCT_CONST_BITS ) ; u [ 24 ] = _mm_srai_epi32 ( v [ 24 ] , DCT_CONST_BITS ) ; u [ 25 ] = _mm_srai_epi32 ( v [ 25 ] , DCT_CONST_BITS ) ; u [ 26 ] = _mm_srai_epi32 ( v [ 26 ] , DCT_CONST_BITS ) ; u [ 27 ] = _mm_srai_epi32 ( v [ 27 ] , DCT_CONST_BITS ) ; u [ 28 ] = _mm_srai_epi32 ( v [ 28 ] , DCT_CONST_BITS ) ; u [ 29 ] = _mm_srai_epi32 ( v [ 29 ] , DCT_CONST_BITS ) ; u [ 30 ] = _mm_srai_epi32 ( v [ 30 ] , DCT_CONST_BITS ) ; u [ 31 ] = _mm_srai_epi32 ( v [ 31 ] , DCT_CONST_BITS ) ; s [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; s [ 1 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; s [ 2 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; s [ 3 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; s [ 4 ] = _mm_packs_epi32 ( u [ 8 ] , u [ 9 ] ) ; s [ 5 ] = _mm_packs_epi32 ( u [ 10 ] , u [ 11 ] ) ; s [ 6 ] = _mm_packs_epi32 ( u [ 12 ] , u [ 13 ] ) ; s [ 7 ] = _mm_packs_epi32 ( u [ 14 ] , u [ 15 ] ) ; s [ 8 ] = _mm_packs_epi32 ( u [ 16 ] , u [ 17 ] ) ; s [ 9 ] = _mm_packs_epi32 ( u [ 18 ] , u [ 19 ] ) ; s [ 10 ] = _mm_packs_epi32 ( u [ 20 ] , u [ 21 ] ) ; s [ 11 ] = _mm_packs_epi32 ( u [ 22 ] , u [ 23 ] ) ; s [ 12 ] = _mm_packs_epi32 ( u [ 24 ] , u [ 25 ] ) ; s [ 13 ] = _mm_packs_epi32 ( u [ 26 ] , u [ 27 ] ) ; s [ 14 ] = _mm_packs_epi32 ( u [ 28 ] , u [ 29 ] ) ; s [ 15 ] = _mm_packs_epi32 ( u [ 30 ] , u [ 31 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 8 ] , s [ 9 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 8 ] , s [ 9 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 12 ] , s [ 13 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 12 ] , s [ 13 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 14 ] , s [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 14 ] , s [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p04_p28 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p04_p28 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_m04 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_m04 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_m20 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_m20 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m28_p04 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m28_p04 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p04_p28 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p04_p28 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m12_p20 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m12_p20 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p20_p12 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p20_p12 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 8 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 9 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 10 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 11 ] ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , v [ 12 ] ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , v [ 13 ] ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , v [ 14 ] ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , v [ 15 ] ) ; u [ 8 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 8 ] ) ; u [ 9 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 9 ] ) ; u [ 10 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 10 ] ) ; u [ 11 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 11 ] ) ; u [ 12 ] = _mm_sub_epi32 ( v [ 4 ] , v [ 12 ] ) ; u [ 13 ] = _mm_sub_epi32 ( v [ 5 ] , v [ 13 ] ) ; u [ 14 ] = _mm_sub_epi32 ( v [ 6 ] , v [ 14 ] ) ; u [ 15 ] = _mm_sub_epi32 ( v [ 7 ] , v [ 15 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; v [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; v [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; v [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; v [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; v [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; v [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; v [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; u [ 8 ] = _mm_srai_epi32 ( v [ 8 ] , DCT_CONST_BITS ) ; u [ 9 ] = _mm_srai_epi32 ( v [ 9 ] , DCT_CONST_BITS ) ; u [ 10 ] = _mm_srai_epi32 ( v [ 10 ] , DCT_CONST_BITS ) ; u [ 11 ] = _mm_srai_epi32 ( v [ 11 ] , DCT_CONST_BITS ) ; u [ 12 ] = _mm_srai_epi32 ( v [ 12 ] , DCT_CONST_BITS ) ; u [ 13 ] = _mm_srai_epi32 ( v [ 13 ] , DCT_CONST_BITS ) ; u [ 14 ] = _mm_srai_epi32 ( v [ 14 ] , DCT_CONST_BITS ) ; u [ 15 ] = _mm_srai_epi32 ( v [ 15 ] , DCT_CONST_BITS ) ; x [ 0 ] = _mm_add_epi16 ( s [ 0 ] , s [ 4 ] ) ; x [ 1 ] = _mm_add_epi16 ( s [ 1 ] , s [ 5 ] ) ; x [ 2 ] = _mm_add_epi16 ( s [ 2 ] , s [ 6 ] ) ; x [ 3 ] = _mm_add_epi16 ( s [ 3 ] , s [ 7 ] ) ; x [ 4 ] = _mm_sub_epi16 ( s [ 0 ] , s [ 4 ] ) ; x [ 5 ] = _mm_sub_epi16 ( s [ 1 ] , s [ 5 ] ) ; x [ 6 ] = _mm_sub_epi16 ( s [ 2 ] , s [ 6 ] ) ; x [ 7 ] = _mm_sub_epi16 ( s [ 3 ] , s [ 7 ] ) ; x [ 8 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; x [ 9 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; x [ 10 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; x [ 11 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; x [ 12 ] = _mm_packs_epi32 ( u [ 8 ] , u [ 9 ] ) ; x [ 13 ] = _mm_packs_epi32 ( u [ 10 ] , u [ 11 ] ) ; x [ 14 ] = _mm_packs_epi32 ( u [ 12 ] , u [ 13 ] ) ; x [ 15 ] = _mm_packs_epi32 ( u [ 14 ] , u [ 15 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( x [ 4 ] , x [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( x [ 4 ] , x [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( x [ 6 ] , x [ 7 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( x [ 6 ] , x [ 7 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( x [ 12 ] , x [ 13 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( x [ 12 ] , x [ 13 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( x [ 14 ] , x [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( x [ 14 ] , x [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p08_p24 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_m08 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_p08 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_p08 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_p24 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_p24 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p08_p24 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p08_p24 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p24_m08 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p24_m08 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m24_p08 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m24_p08 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p08_p24 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p08_p24 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 4 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 5 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 7 ] ) ; u [ 4 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 4 ] ) ; u [ 5 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 5 ] ) ; u [ 6 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 7 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 7 ] ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , v [ 12 ] ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , v [ 13 ] ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , v [ 14 ] ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , v [ 15 ] ) ; u [ 12 ] = _mm_sub_epi32 ( v [ 8 ] , v [ 12 ] ) ; u [ 13 ] = _mm_sub_epi32 ( v [ 9 ] , v [ 13 ] ) ; u [ 14 ] = _mm_sub_epi32 ( v [ 10 ] , v [ 14 ] ) ; u [ 15 ] = _mm_sub_epi32 ( v [ 11 ] , v [ 15 ] ) ; u [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; s [ 0 ] = _mm_add_epi16 ( x [ 0 ] , x [ 2 ] ) ; s [ 1 ] = _mm_add_epi16 ( x [ 1 ] , x [ 3 ] ) ; s [ 2 ] = _mm_sub_epi16 ( x [ 0 ] , x [ 2 ] ) ; s [ 3 ] = _mm_sub_epi16 ( x [ 1 ] , x [ 3 ] ) ; s [ 4 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; s [ 5 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; s [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; s [ 7 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 8 ] = _mm_add_epi16 ( x [ 8 ] , x [ 10 ] ) ; s [ 9 ] = _mm_add_epi16 ( x [ 9 ] , x [ 11 ] ) ; s [ 10 ] = _mm_sub_epi16 ( x [ 8 ] , x [ 10 ] ) ; s [ 11 ] = _mm_sub_epi16 ( x [ 9 ] , x [ 11 ] ) ; s [ 12 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; s [ 13 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; s [ 14 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; s [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 6 ] , s [ 7 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 6 ] , s [ 7 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 14 ] , s [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 14 ] , s [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_m16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_m16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_m16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_m16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p16_p16 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p16_p16 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m16_p16 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m16_p16 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m16_m16 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m16_m16 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p16_m16 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p16_m16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 0 ] = s [ 0 ] ; in [ 1 ] = _mm_sub_epi16 ( kZero , s [ 8 ] ) ; in [ 2 ] = s [ 12 ] ; in [ 3 ] = _mm_sub_epi16 ( kZero , s [ 4 ] ) ; in [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 8 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 12 ] = s [ 5 ] ; in [ 13 ] = _mm_sub_epi16 ( kZero , s [ 13 ] ) ; in [ 14 ] = s [ 9 ] ; in [ 15 ] = _mm_sub_epi16 ( kZero , s [ 1 ] ) ; }","static void fadst16_8col ( __m128i * in ) {__m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ;",1568
521,"buggy line: const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ;const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;cwe id:CWE-119context:  void fadst16_8col ( __m128i * in ) {  __m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ; const __m128i k__cospi_p01_p31 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ; const __m128i k__cospi_p31_m01 = pair_set_epi16 ( cospi_31_64 , - cospi_1_64 ) ; const __m128i k__cospi_p05_p27 = pair_set_epi16 ( cospi_5_64 , cospi_27_64 ) ; const __m128i k__cospi_p27_m05 = pair_set_epi16 ( cospi_27_64 , - cospi_5_64 ) ; const __m128i k__cospi_p09_p23 = pair_set_epi16 ( cospi_9_64 , cospi_23_64 ) ; const __m128i k__cospi_p23_m09 = pair_set_epi16 ( cospi_23_64 , - cospi_9_64 ) ; const __m128i k__cospi_p13_p19 = pair_set_epi16 ( cospi_13_64 , cospi_19_64 ) ; const __m128i k__cospi_p19_m13 = pair_set_epi16 ( cospi_19_64 , - cospi_13_64 ) ; const __m128i k__cospi_p17_p15 = pair_set_epi16 ( cospi_17_64 , cospi_15_64 ) ; const __m128i k__cospi_p15_m17 = pair_set_epi16 ( cospi_15_64 , - cospi_17_64 ) ; const __m128i k__cospi_p21_p11 = pair_set_epi16 ( cospi_21_64 , cospi_11_64 ) ; const __m128i k__cospi_p11_m21 = pair_set_epi16 ( cospi_11_64 , - cospi_21_64 ) ; const __m128i k__cospi_p25_p07 = pair_set_epi16 ( cospi_25_64 , cospi_7_64 ) ; const __m128i k__cospi_p07_m25 = pair_set_epi16 ( cospi_7_64 , - cospi_25_64 ) ; const __m128i k__cospi_p29_p03 = pair_set_epi16 ( cospi_29_64 , cospi_3_64 ) ; const __m128i k__cospi_p03_m29 = pair_set_epi16 ( cospi_3_64 , - cospi_29_64 ) ; const __m128i k__cospi_p04_p28 = pair_set_epi16 ( cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p28_m04 = pair_set_epi16 ( cospi_28_64 , - cospi_4_64 ) ; const __m128i k__cospi_p20_p12 = pair_set_epi16 ( cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p12_m20 = pair_set_epi16 ( cospi_12_64 , - cospi_20_64 ) ; const __m128i k__cospi_m28_p04 = pair_set_epi16 ( - cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m12_p20 = pair_set_epi16 ( - cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ;  const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ;   const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;  const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; const __m128i kZero = _mm_set1_epi16 ( 0 ) ; u [ 0 ] = _mm_unpacklo_epi16 ( in [ 15 ] , in [ 0 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( in [ 15 ] , in [ 0 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( in [ 13 ] , in [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( in [ 13 ] , in [ 2 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( in [ 11 ] , in [ 4 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( in [ 11 ] , in [ 4 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( in [ 9 ] , in [ 6 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( in [ 9 ] , in [ 6 ] ) ; u [ 8 ] = _mm_unpacklo_epi16 ( in [ 7 ] , in [ 8 ] ) ; u [ 9 ] = _mm_unpackhi_epi16 ( in [ 7 ] , in [ 8 ] ) ; u [ 10 ] = _mm_unpacklo_epi16 ( in [ 5 ] , in [ 10 ] ) ; u [ 11 ] = _mm_unpackhi_epi16 ( in [ 5 ] , in [ 10 ] ) ; u [ 12 ] = _mm_unpacklo_epi16 ( in [ 3 ] , in [ 12 ] ) ; u [ 13 ] = _mm_unpackhi_epi16 ( in [ 3 ] , in [ 12 ] ) ; u [ 14 ] = _mm_unpacklo_epi16 ( in [ 1 ] , in [ 14 ] ) ; u [ 15 ] = _mm_unpackhi_epi16 ( in [ 1 ] , in [ 14 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p01_p31 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p01_p31 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p31_m01 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p31_m01 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p05_p27 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p05_p27 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p27_m05 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p27_m05 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p09_p23 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p09_p23 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p23_m09 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p23_m09 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p13_p19 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p13_p19 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p19_m13 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p19_m13 ) ; v [ 16 ] = _mm_madd_epi16 ( u [ 8 ] , k__cospi_p17_p15 ) ; v [ 17 ] = _mm_madd_epi16 ( u [ 9 ] , k__cospi_p17_p15 ) ; v [ 18 ] = _mm_madd_epi16 ( u [ 8 ] , k__cospi_p15_m17 ) ; v [ 19 ] = _mm_madd_epi16 ( u [ 9 ] , k__cospi_p15_m17 ) ; v [ 20 ] = _mm_madd_epi16 ( u [ 10 ] , k__cospi_p21_p11 ) ; v [ 21 ] = _mm_madd_epi16 ( u [ 11 ] , k__cospi_p21_p11 ) ; v [ 22 ] = _mm_madd_epi16 ( u [ 10 ] , k__cospi_p11_m21 ) ; v [ 23 ] = _mm_madd_epi16 ( u [ 11 ] , k__cospi_p11_m21 ) ; v [ 24 ] = _mm_madd_epi16 ( u [ 12 ] , k__cospi_p25_p07 ) ; v [ 25 ] = _mm_madd_epi16 ( u [ 13 ] , k__cospi_p25_p07 ) ; v [ 26 ] = _mm_madd_epi16 ( u [ 12 ] , k__cospi_p07_m25 ) ; v [ 27 ] = _mm_madd_epi16 ( u [ 13 ] , k__cospi_p07_m25 ) ; v [ 28 ] = _mm_madd_epi16 ( u [ 14 ] , k__cospi_p29_p03 ) ; v [ 29 ] = _mm_madd_epi16 ( u [ 15 ] , k__cospi_p29_p03 ) ; v [ 30 ] = _mm_madd_epi16 ( u [ 14 ] , k__cospi_p03_m29 ) ; v [ 31 ] = _mm_madd_epi16 ( u [ 15 ] , k__cospi_p03_m29 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 16 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 17 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 18 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 19 ] ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , v [ 20 ] ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , v [ 21 ] ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , v [ 22 ] ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , v [ 23 ] ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , v [ 24 ] ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , v [ 25 ] ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , v [ 26 ] ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , v [ 27 ] ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , v [ 28 ] ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , v [ 29 ] ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , v [ 30 ] ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , v [ 31 ] ) ; u [ 16 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 16 ] ) ; u [ 17 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 17 ] ) ; u [ 18 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 18 ] ) ; u [ 19 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 19 ] ) ; u [ 20 ] = _mm_sub_epi32 ( v [ 4 ] , v [ 20 ] ) ; u [ 21 ] = _mm_sub_epi32 ( v [ 5 ] , v [ 21 ] ) ; u [ 22 ] = _mm_sub_epi32 ( v [ 6 ] , v [ 22 ] ) ; u [ 23 ] = _mm_sub_epi32 ( v [ 7 ] , v [ 23 ] ) ; u [ 24 ] = _mm_sub_epi32 ( v [ 8 ] , v [ 24 ] ) ; u [ 25 ] = _mm_sub_epi32 ( v [ 9 ] , v [ 25 ] ) ; u [ 26 ] = _mm_sub_epi32 ( v [ 10 ] , v [ 26 ] ) ; u [ 27 ] = _mm_sub_epi32 ( v [ 11 ] , v [ 27 ] ) ; u [ 28 ] = _mm_sub_epi32 ( v [ 12 ] , v [ 28 ] ) ; u [ 29 ] = _mm_sub_epi32 ( v [ 13 ] , v [ 29 ] ) ; u [ 30 ] = _mm_sub_epi32 ( v [ 14 ] , v [ 30 ] ) ; u [ 31 ] = _mm_sub_epi32 ( v [ 15 ] , v [ 31 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; v [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; v [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; v [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; v [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; v [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; v [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; v [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 16 ] = _mm_add_epi32 ( u [ 16 ] , k__DCT_CONST_ROUNDING ) ; v [ 17 ] = _mm_add_epi32 ( u [ 17 ] , k__DCT_CONST_ROUNDING ) ; v [ 18 ] = _mm_add_epi32 ( u [ 18 ] , k__DCT_CONST_ROUNDING ) ; v [ 19 ] = _mm_add_epi32 ( u [ 19 ] , k__DCT_CONST_ROUNDING ) ; v [ 20 ] = _mm_add_epi32 ( u [ 20 ] , k__DCT_CONST_ROUNDING ) ; v [ 21 ] = _mm_add_epi32 ( u [ 21 ] , k__DCT_CONST_ROUNDING ) ; v [ 22 ] = _mm_add_epi32 ( u [ 22 ] , k__DCT_CONST_ROUNDING ) ; v [ 23 ] = _mm_add_epi32 ( u [ 23 ] , k__DCT_CONST_ROUNDING ) ; v [ 24 ] = _mm_add_epi32 ( u [ 24 ] , k__DCT_CONST_ROUNDING ) ; v [ 25 ] = _mm_add_epi32 ( u [ 25 ] , k__DCT_CONST_ROUNDING ) ; v [ 26 ] = _mm_add_epi32 ( u [ 26 ] , k__DCT_CONST_ROUNDING ) ; v [ 27 ] = _mm_add_epi32 ( u [ 27 ] , k__DCT_CONST_ROUNDING ) ; v [ 28 ] = _mm_add_epi32 ( u [ 28 ] , k__DCT_CONST_ROUNDING ) ; v [ 29 ] = _mm_add_epi32 ( u [ 29 ] , k__DCT_CONST_ROUNDING ) ; v [ 30 ] = _mm_add_epi32 ( u [ 30 ] , k__DCT_CONST_ROUNDING ) ; v [ 31 ] = _mm_add_epi32 ( u [ 31 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; u [ 8 ] = _mm_srai_epi32 ( v [ 8 ] , DCT_CONST_BITS ) ; u [ 9 ] = _mm_srai_epi32 ( v [ 9 ] , DCT_CONST_BITS ) ; u [ 10 ] = _mm_srai_epi32 ( v [ 10 ] , DCT_CONST_BITS ) ; u [ 11 ] = _mm_srai_epi32 ( v [ 11 ] , DCT_CONST_BITS ) ; u [ 12 ] = _mm_srai_epi32 ( v [ 12 ] , DCT_CONST_BITS ) ; u [ 13 ] = _mm_srai_epi32 ( v [ 13 ] , DCT_CONST_BITS ) ; u [ 14 ] = _mm_srai_epi32 ( v [ 14 ] , DCT_CONST_BITS ) ; u [ 15 ] = _mm_srai_epi32 ( v [ 15 ] , DCT_CONST_BITS ) ; u [ 16 ] = _mm_srai_epi32 ( v [ 16 ] , DCT_CONST_BITS ) ; u [ 17 ] = _mm_srai_epi32 ( v [ 17 ] , DCT_CONST_BITS ) ; u [ 18 ] = _mm_srai_epi32 ( v [ 18 ] , DCT_CONST_BITS ) ; u [ 19 ] = _mm_srai_epi32 ( v [ 19 ] , DCT_CONST_BITS ) ; u [ 20 ] = _mm_srai_epi32 ( v [ 20 ] , DCT_CONST_BITS ) ; u [ 21 ] = _mm_srai_epi32 ( v [ 21 ] , DCT_CONST_BITS ) ; u [ 22 ] = _mm_srai_epi32 ( v [ 22 ] , DCT_CONST_BITS ) ; u [ 23 ] = _mm_srai_epi32 ( v [ 23 ] , DCT_CONST_BITS ) ; u [ 24 ] = _mm_srai_epi32 ( v [ 24 ] , DCT_CONST_BITS ) ; u [ 25 ] = _mm_srai_epi32 ( v [ 25 ] , DCT_CONST_BITS ) ; u [ 26 ] = _mm_srai_epi32 ( v [ 26 ] , DCT_CONST_BITS ) ; u [ 27 ] = _mm_srai_epi32 ( v [ 27 ] , DCT_CONST_BITS ) ; u [ 28 ] = _mm_srai_epi32 ( v [ 28 ] , DCT_CONST_BITS ) ; u [ 29 ] = _mm_srai_epi32 ( v [ 29 ] , DCT_CONST_BITS ) ; u [ 30 ] = _mm_srai_epi32 ( v [ 30 ] , DCT_CONST_BITS ) ; u [ 31 ] = _mm_srai_epi32 ( v [ 31 ] , DCT_CONST_BITS ) ; s [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; s [ 1 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; s [ 2 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; s [ 3 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; s [ 4 ] = _mm_packs_epi32 ( u [ 8 ] , u [ 9 ] ) ; s [ 5 ] = _mm_packs_epi32 ( u [ 10 ] , u [ 11 ] ) ; s [ 6 ] = _mm_packs_epi32 ( u [ 12 ] , u [ 13 ] ) ; s [ 7 ] = _mm_packs_epi32 ( u [ 14 ] , u [ 15 ] ) ; s [ 8 ] = _mm_packs_epi32 ( u [ 16 ] , u [ 17 ] ) ; s [ 9 ] = _mm_packs_epi32 ( u [ 18 ] , u [ 19 ] ) ; s [ 10 ] = _mm_packs_epi32 ( u [ 20 ] , u [ 21 ] ) ; s [ 11 ] = _mm_packs_epi32 ( u [ 22 ] , u [ 23 ] ) ; s [ 12 ] = _mm_packs_epi32 ( u [ 24 ] , u [ 25 ] ) ; s [ 13 ] = _mm_packs_epi32 ( u [ 26 ] , u [ 27 ] ) ; s [ 14 ] = _mm_packs_epi32 ( u [ 28 ] , u [ 29 ] ) ; s [ 15 ] = _mm_packs_epi32 ( u [ 30 ] , u [ 31 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 8 ] , s [ 9 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 8 ] , s [ 9 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 12 ] , s [ 13 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 12 ] , s [ 13 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 14 ] , s [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 14 ] , s [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p04_p28 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p04_p28 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_m04 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_m04 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_m20 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_m20 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m28_p04 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m28_p04 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p04_p28 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p04_p28 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m12_p20 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m12_p20 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p20_p12 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p20_p12 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 8 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 9 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 10 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 11 ] ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , v [ 12 ] ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , v [ 13 ] ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , v [ 14 ] ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , v [ 15 ] ) ; u [ 8 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 8 ] ) ; u [ 9 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 9 ] ) ; u [ 10 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 10 ] ) ; u [ 11 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 11 ] ) ; u [ 12 ] = _mm_sub_epi32 ( v [ 4 ] , v [ 12 ] ) ; u [ 13 ] = _mm_sub_epi32 ( v [ 5 ] , v [ 13 ] ) ; u [ 14 ] = _mm_sub_epi32 ( v [ 6 ] , v [ 14 ] ) ; u [ 15 ] = _mm_sub_epi32 ( v [ 7 ] , v [ 15 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; v [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; v [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; v [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; v [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; v [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; v [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; v [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; u [ 8 ] = _mm_srai_epi32 ( v [ 8 ] , DCT_CONST_BITS ) ; u [ 9 ] = _mm_srai_epi32 ( v [ 9 ] , DCT_CONST_BITS ) ; u [ 10 ] = _mm_srai_epi32 ( v [ 10 ] , DCT_CONST_BITS ) ; u [ 11 ] = _mm_srai_epi32 ( v [ 11 ] , DCT_CONST_BITS ) ; u [ 12 ] = _mm_srai_epi32 ( v [ 12 ] , DCT_CONST_BITS ) ; u [ 13 ] = _mm_srai_epi32 ( v [ 13 ] , DCT_CONST_BITS ) ; u [ 14 ] = _mm_srai_epi32 ( v [ 14 ] , DCT_CONST_BITS ) ; u [ 15 ] = _mm_srai_epi32 ( v [ 15 ] , DCT_CONST_BITS ) ; x [ 0 ] = _mm_add_epi16 ( s [ 0 ] , s [ 4 ] ) ; x [ 1 ] = _mm_add_epi16 ( s [ 1 ] , s [ 5 ] ) ; x [ 2 ] = _mm_add_epi16 ( s [ 2 ] , s [ 6 ] ) ; x [ 3 ] = _mm_add_epi16 ( s [ 3 ] , s [ 7 ] ) ; x [ 4 ] = _mm_sub_epi16 ( s [ 0 ] , s [ 4 ] ) ; x [ 5 ] = _mm_sub_epi16 ( s [ 1 ] , s [ 5 ] ) ; x [ 6 ] = _mm_sub_epi16 ( s [ 2 ] , s [ 6 ] ) ; x [ 7 ] = _mm_sub_epi16 ( s [ 3 ] , s [ 7 ] ) ; x [ 8 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; x [ 9 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; x [ 10 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; x [ 11 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; x [ 12 ] = _mm_packs_epi32 ( u [ 8 ] , u [ 9 ] ) ; x [ 13 ] = _mm_packs_epi32 ( u [ 10 ] , u [ 11 ] ) ; x [ 14 ] = _mm_packs_epi32 ( u [ 12 ] , u [ 13 ] ) ; x [ 15 ] = _mm_packs_epi32 ( u [ 14 ] , u [ 15 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( x [ 4 ] , x [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( x [ 4 ] , x [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( x [ 6 ] , x [ 7 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( x [ 6 ] , x [ 7 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( x [ 12 ] , x [ 13 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( x [ 12 ] , x [ 13 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( x [ 14 ] , x [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( x [ 14 ] , x [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p08_p24 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_m08 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_p08 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_p08 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_p24 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_p24 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p08_p24 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p08_p24 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p24_m08 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p24_m08 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m24_p08 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m24_p08 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p08_p24 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p08_p24 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 4 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 5 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 7 ] ) ; u [ 4 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 4 ] ) ; u [ 5 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 5 ] ) ; u [ 6 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 7 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 7 ] ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , v [ 12 ] ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , v [ 13 ] ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , v [ 14 ] ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , v [ 15 ] ) ; u [ 12 ] = _mm_sub_epi32 ( v [ 8 ] , v [ 12 ] ) ; u [ 13 ] = _mm_sub_epi32 ( v [ 9 ] , v [ 13 ] ) ; u [ 14 ] = _mm_sub_epi32 ( v [ 10 ] , v [ 14 ] ) ; u [ 15 ] = _mm_sub_epi32 ( v [ 11 ] , v [ 15 ] ) ; u [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; s [ 0 ] = _mm_add_epi16 ( x [ 0 ] , x [ 2 ] ) ; s [ 1 ] = _mm_add_epi16 ( x [ 1 ] , x [ 3 ] ) ; s [ 2 ] = _mm_sub_epi16 ( x [ 0 ] , x [ 2 ] ) ; s [ 3 ] = _mm_sub_epi16 ( x [ 1 ] , x [ 3 ] ) ; s [ 4 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; s [ 5 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; s [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; s [ 7 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 8 ] = _mm_add_epi16 ( x [ 8 ] , x [ 10 ] ) ; s [ 9 ] = _mm_add_epi16 ( x [ 9 ] , x [ 11 ] ) ; s [ 10 ] = _mm_sub_epi16 ( x [ 8 ] , x [ 10 ] ) ; s [ 11 ] = _mm_sub_epi16 ( x [ 9 ] , x [ 11 ] ) ; s [ 12 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; s [ 13 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; s [ 14 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; s [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 6 ] , s [ 7 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 6 ] , s [ 7 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 14 ] , s [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 14 ] , s [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_m16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_m16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_m16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_m16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p16_p16 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p16_p16 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m16_p16 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m16_p16 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m16_m16 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m16_m16 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p16_m16 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p16_m16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 0 ] = s [ 0 ] ; in [ 1 ] = _mm_sub_epi16 ( kZero , s [ 8 ] ) ; in [ 2 ] = s [ 12 ] ; in [ 3 ] = _mm_sub_epi16 ( kZero , s [ 4 ] ) ; in [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 8 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 12 ] = s [ 5 ] ; in [ 13 ] = _mm_sub_epi16 ( kZero , s [ 13 ] ) ; in [ 14 ] = s [ 9 ] ; in [ 15 ] = _mm_sub_epi16 ( kZero , s [ 1 ] ) ; }","const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( ( int16_t ) - cospi_16_64 ) ;const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;",1568
522,"buggy line: static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) {int64_t max_bits = ( ( int64_t ) rc -> av_per_frame_bandwidth *  ( int64_t ) oxcf -> two_pass_vbrmax_section ) / 100 ;cwe id:CWE-119context:  static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) {   int64_t max_bits = ( ( int64_t ) rc -> av_per_frame_bandwidth *  ( int64_t ) oxcf -> two_pass_vbrmax_section ) / 100 ; if ( max_bits < 0 ) max_bits = 0 ; else if ( max_bits > rc -> max_frame_bandwidth ) max_bits = rc -> max_frame_bandwidth ; return ( int ) max_bits ; }","static int frame_max_bits ( const RATE_CONTROL * rc , const VP9EncoderConfig * oxcf ) {int64_t max_bits = ( ( int64_t ) rc -> avg_frame_bandwidth * ( int64_t ) oxcf -> two_pass_vbrmax_section ) / 100 ;",1569
523,"buggy line: uchar magicbuf [ MIF_MAGICLEN ] ;char buf [ 4096 ] ;cwe id:CWE-190context: static mif_hdr_t * mif_hdr_get ( jas_stream_t * in ) {  uchar magicbuf [ MIF_MAGICLEN ] ;  char buf [ 4096 ] ; mif_hdr_t * hdr ; bool done ; jas_tvparser_t * tvp ; int id ; hdr = 0 ; tvp = 0 ; if ( jas_stream_read ( in , magicbuf , MIF_MAGICLEN ) != MIF_MAGICLEN ) { goto error ; } if ( magicbuf [ 0 ] != ( MIF_MAGIC >> 24 ) || magicbuf [ 1 ] != ( ( MIF_MAGIC >> 16 ) & 0xff ) || magicbuf [ 2 ] != ( ( MIF_MAGIC >> 8 ) & 0xff ) || magicbuf [ 3 ] != ( MIF_MAGIC & 0xff ) ) { jas_eprintf ( ""error:<S2SV_blank>bad<S2SV_blank>signature\\n"" ) ; goto error ; } if ( ! ( hdr = mif_hdr_create ( 0 ) ) ) { goto error ; } done = false ; do { if ( ! mif_getline ( in , buf , sizeof ( buf ) ) ) { jas_eprintf ( ""mif_getline<S2SV_blank>failed\\n"" ) ; goto error ; } if ( buf [ 0 ] == '\\0' ) { continue ; } JAS_DBGLOG ( 10 , ( ""header<S2SV_blank>line:<S2SV_blank>len=%d;<S2SV_blank>%s\\n"" , strlen ( buf ) , buf ) ) ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { jas_eprintf ( ""jas_tvparser_create<S2SV_blank>failed\\n"" ) ; goto error ; } if ( jas_tvparser_next ( tvp ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>record<S2SV_blank>type\\n"" ) ; goto error ; } id = jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags2 , jas_tvparser_gettag ( tvp ) ) ) -> id ; jas_tvparser_destroy ( tvp ) ; tvp = 0 ; switch ( id ) { case MIF_CMPT : if ( mif_process_cmpt ( hdr , buf ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>component<S2SV_blank>information\\n"" ) ; goto error ; } break ; case MIF_END : done = 1 ; break ; default : jas_eprintf ( ""invalid<S2SV_blank>header<S2SV_blank>information:<S2SV_blank>%s\\n"" , buf ) ; goto error ; break ; } } while ( ! done ) ; return hdr ; error : if ( hdr ) { mif_hdr_destroy ( hdr ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return 0 ; }",jas_uchar magicbuf [ MIF_MAGICLEN ] ;char buf [ 4096 ] ;,1570
524,"buggy line: void Huff_transmit ( huff_t * huff , int ch , byte * fout ) {int i ;Huff_transmit ( huff , NYT , fout ) ;for ( i = 7 ;send ( huff -> loc [ ch ] , NULL , fout ) ;}cwe id:CWE-119context:  void Huff_transmit ( huff_t * huff , int ch , byte * fout ) {  int i ; if ( huff -> loc [ ch ] == NULL ) {  Huff_transmit ( huff , NYT , fout ) ;  for ( i = 7 ; i >= 0 ; i -- ) { add_bit ( ( char ) ( ( ch >> i ) & 0x1 ) , fout ) ; } } else {  send ( huff -> loc [ ch ] , NULL , fout ) ;  } }","void Huff_transmit ( huff_t * huff , int ch , byte * fout , int maxoffset ) {int i ;Huff_transmit ( huff , NYT , fout , maxoffset ) ;for ( i = 7 ;send ( huff -> loc [ ch ] , NULL , fout , maxoffset ) ;}",1571
525,"buggy line: static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled ,   int mi_row , int mi_col , BLOCK_SIZE bsize ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;unsigned int segment_id = mbmi -> segment_id ;x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 &&  cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ;x -> skip_optimize = ctx -> is_coded ;ctx -> is_coded = 1 ;x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ;x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ) ;if ( x -> skip_encode ) return ;if ( cm -> frame_type == KEY_FRAME ) {if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) {adjust_act_zbin ( cpi , x ) ;vp9_update_zbin_extra ( cpi , x ) ;}}else {set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ;if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) {adjust_act_zbin ( cpi , x ) ;}cpi -> zbin_mode_boost = get_zbin_mode_boost ( mbmi , cpi -> zbin_mode_boost_enabled ) ;vp9_update_zbin_extra ( cpi , x ) ;}if ( output_enabled ) sum_intra_stats ( & cm -> counts , mi ) ;vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;for ( ref = 0 ;ref < 1 + is_compound ;++ ref ) {YV12_BUFFER_CONFIG * cfg = get_ref_frame_buffer ( cpi , mbmi -> ref_frame [ ref ] ) ;vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col ,  & xd -> block_refs [ ref ] -> sf ) ;vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ;if ( ! x -> skip ) {mbmi -> skip = 1 ;vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;}mbmi -> skip = 1 ;if ( cm -> tx_mode == TX_MODE_SELECT && mbmi -> sb_type >= BLOCK_8X8 && ! ( is_inter_block ( mbmi ) && ( mbmi -> skip ||  vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) ) ) {++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) ,   & cm -> counts . tx ) [ mbmi -> tx_size ] ;}cwe id:CWE-119context:  static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled ,   int mi_row , int mi_col , BLOCK_SIZE bsize ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * * mi_8x8 = xd -> mi ; MODE_INFO * mi = mi_8x8 [ 0 ] ; MB_MODE_INFO * mbmi = & mi -> mbmi ;  PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;  unsigned int segment_id = mbmi -> segment_id ; const int mis = cm -> mi_stride ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ;  x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 &&  cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ;  x -> skip_optimize = ctx -> is_coded ;  ctx -> is_coded = 1 ; x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ; x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ) ; if ( x -> skip_encode ) return ;  if ( cm -> frame_type == KEY_FRAME ) {  if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; vp9_update_zbin_extra ( cpi , x ) ; } } else {  set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ;  if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; } cpi -> zbin_mode_boost = get_zbin_mode_boost ( mbmi , cpi -> zbin_mode_boost_enabled ) ; vp9_update_zbin_extra ( cpi , x ) ; } if ( ! is_inter_block ( mbmi ) ) { int plane ; mbmi -> skip = 1 ; for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; if ( output_enabled ) sum_intra_stats ( & cm -> counts , mi ) ; vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; } else { int ref ; const int is_compound = has_second_ref ( mbmi ) ; for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { YV12_BUFFER_CONFIG * cfg = get_ref_frame_buffer ( cpi , mbmi -> ref_frame [ ref ] ) ;  vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col ,  & xd -> block_refs [ ref ] -> sf ) ; }  vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ;   if ( ! x -> skip ) {  mbmi -> skip = 1 ; vp9_encode_sb ( x , MAX ( bsize , BLOCK_8X8 ) ) ;  vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;   } else {  mbmi -> skip = 1 ; if ( output_enabled ) cm -> counts . skip [ vp9_get_skip_context ( xd ) ] [ 1 ] ++ ; reset_skip_context ( xd , MAX ( bsize , BLOCK_8X8 ) ) ; } } if ( output_enabled ) { if ( cm -> tx_mode == TX_MODE_SELECT && mbmi -> sb_type >= BLOCK_8X8 && ! ( is_inter_block ( mbmi ) && ( mbmi -> skip ||  vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) ) ) {   ++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) ,   & cm -> counts . tx ) [ mbmi -> tx_size ] ;  } else { int x , y ; TX_SIZE tx_size ; if ( is_inter_block ( & mi -> mbmi ) ) { tx_size = MIN ( tx_mode_to_biggest_tx_size [ cm -> tx_mode ] , max_txsize_lookup [ bsize ] ) ; } else { tx_size = ( bsize >= BLOCK_8X8 ) ? mbmi -> tx_size : TX_4X4 ; } for ( y = 0 ; y < mi_height ; y ++ ) for ( x = 0 ; x < mi_width ; x ++ ) if ( mi_col + x < cm -> mi_cols && mi_row + y < cm -> mi_rows ) mi_8x8 [ mis * y + x ] -> mbmi . tx_size = tx_size ; }  }  }","static void encode_superblock ( VP9_COMP * cpi , ThreadData * td , TOKENEXTRA * * t , int output_enabled , int mi_row , int mi_col , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int seg_skip = segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ;x -> skip_recode = ! x -> select_tx_size && mbmi -> sb_type >= BLOCK_8X8 && cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ;if ( output_enabled ) sum_intra_stats ( td -> counts , mi ) ;vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;+ ref ) {set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ;if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) {adjust_act_zbin ( cpi , x ) ;if ( ! ( cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ) || seg_skip ) vp9_build_inter_predictors_sby ( xd , ref , cfg , mi_row , mi_col , & xd -> block_refs [ ref ] -> sf ) ;}vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ;if ( ! x -> skip ) {mbmi -> skip = 1 ;vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;}mbmi -> skip = 1 ;+ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) ,   & cm -> counts . tx ) [ mbmi -> tx_size ] ;if ( cm -> tx_mode == TX_MODE_SELECT && mbmi -> sb_type >= BLOCK_8X8 && ! ( is_inter_block ( mbmi ) && ( mbmi -> skip || seg_skip ) ) ) ) {++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) , & td -> counts -> tx ) [ mbmi -> tx_size ] ;}assert ( cfg != NULL ) ;",1572
526,"buggy line: }}cwe id:CWE-119context:  static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled ,   int mi_row , int mi_col , BLOCK_SIZE bsize ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * * mi_8x8 = xd -> mi ; MODE_INFO * mi = mi_8x8 [ 0 ] ; MB_MODE_INFO * mbmi = & mi -> mbmi ;  PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;  unsigned int segment_id = mbmi -> segment_id ; const int mis = cm -> mi_stride ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ;  x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 &&  cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ;  x -> skip_optimize = ctx -> is_coded ;  ctx -> is_coded = 1 ; x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ; x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ) ; if ( x -> skip_encode ) return ;  if ( cm -> frame_type == KEY_FRAME ) {  if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; vp9_update_zbin_extra ( cpi , x ) ; } } else {  set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ;  if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; } cpi -> zbin_mode_boost = get_zbin_mode_boost ( mbmi , cpi -> zbin_mode_boost_enabled ) ; vp9_update_zbin_extra ( cpi , x ) ; } if ( ! is_inter_block ( mbmi ) ) { int plane ; mbmi -> skip = 1 ; for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; if ( output_enabled ) sum_intra_stats ( & cm -> counts , mi ) ; vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; } else { int ref ; const int is_compound = has_second_ref ( mbmi ) ; for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { YV12_BUFFER_CONFIG * cfg = get_ref_frame_buffer ( cpi , mbmi -> ref_frame [ ref ] ) ;  vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col ,  & xd -> block_refs [ ref ] -> sf ) ; }  vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ;   if ( ! x -> skip ) {  mbmi -> skip = 1 ; vp9_encode_sb ( x , MAX ( bsize , BLOCK_8X8 ) ) ;  vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;   } else {  mbmi -> skip = 1 ; if ( output_enabled ) cm -> counts . skip [ vp9_get_skip_context ( xd ) ] [ 1 ] ++ ; reset_skip_context ( xd , MAX ( bsize , BLOCK_8X8 ) ) ; } } if ( output_enabled ) { if ( cm -> tx_mode == TX_MODE_SELECT && mbmi -> sb_type >= BLOCK_8X8 && ! ( is_inter_block ( mbmi ) && ( mbmi -> skip ||  vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) ) ) {   ++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) ,   & cm -> counts . tx ) [ mbmi -> tx_size ] ;  } else { int x , y ; TX_SIZE tx_size ; if ( is_inter_block ( & mi -> mbmi ) ) { tx_size = MIN ( tx_mode_to_biggest_tx_size [ cm -> tx_mode ] , max_txsize_lookup [ bsize ] ) ; } else { tx_size = ( bsize >= BLOCK_8X8 ) ? mbmi -> tx_size : TX_4X4 ; } for ( y = 0 ; y < mi_height ; y ++ ) for ( x = 0 ; x < mi_width ; x ++ ) if ( mi_col + x < cm -> mi_cols && mi_row + y < cm -> mi_rows ) mi_8x8 [ mis * y + x ] -> mbmi . tx_size = tx_size ; }  }  }","++ td -> counts -> tx . tx_totals [ mbmi -> tx_size ] ;++ td -> counts -> tx . tx_totals [ get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ] ;}}",1572
527,"buggy line: if ( iad_num == USB_MAXIADS ) {dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\\config -> intf_assoc [ iad_num ] =  ( struct usb_interface_assoc_descriptor  * ) header ;cwe id:CWE-119context: static int usb_parse_configuration ( struct usb_device * dev , int cfgidx , struct usb_host_config * config , unsigned char * buffer , int size ) { struct device * ddev = & dev -> dev ; unsigned char * buffer0 = buffer ; int cfgno ; int nintf , nintf_orig ; int i , j , n ; struct usb_interface_cache * intfc ; unsigned char * buffer2 ; int size2 ; struct usb_descriptor_header * header ; int len , retval ; u8 inums [ USB_MAXINTERFACES ] , nalts [ USB_MAXINTERFACES ] ; unsigned iad_num = 0 ; memcpy ( & config -> desc , buffer , USB_DT_CONFIG_SIZE ) ; if ( config -> desc . bDescriptorType != USB_DT_CONFIG || config -> desc . bLength < USB_DT_CONFIG_SIZE || config -> desc . bLength > size ) { dev_err ( ddev , ""invalid<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>config<S2SV_blank>index<S2SV_blank>%d:<S2SV_blank>"" ""type<S2SV_blank>=<S2SV_blank>0x%X,<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%d\\n"" , cfgidx , config -> desc . bDescriptorType , config -> desc . bLength ) ; return - EINVAL ; } cfgno = config -> desc . bConfigurationValue ; buffer += config -> desc . bLength ; size -= config -> desc . bLength ; nintf = nintf_orig = config -> desc . bNumInterfaces ; if ( nintf > USB_MAXINTERFACES ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>interfaces:<S2SV_blank>%d,<S2SV_blank>"" ""using<S2SV_blank>maximum<S2SV_blank>allowed:<S2SV_blank>%d\\n"" , cfgno , nintf , USB_MAXINTERFACES ) ; nintf = USB_MAXINTERFACES ; } n = 0 ; for ( ( buffer2 = buffer , size2 = size ) ; size2 > 0 ; ( buffer2 += header -> bLength , size2 -= header -> bLength ) ) { if ( size2 < sizeof ( struct usb_descriptor_header ) ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>descriptor<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>excess<S2SV_blank>"" ""byte%s,<S2SV_blank>ignoring\\n"" , cfgno , size2 , plural ( size2 ) ) ; break ; } header = ( struct usb_descriptor_header * ) buffer2 ; if ( ( header -> bLength > size2 ) || ( header -> bLength < 2 ) ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>descriptor<S2SV_blank>"" ""of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping<S2SV_blank>remainder<S2SV_blank>of<S2SV_blank>the<S2SV_blank>config\\n"" , cfgno , header -> bLength ) ; break ; } if ( header -> bDescriptorType == USB_DT_INTERFACE ) { struct usb_interface_descriptor * d ; int inum ; d = ( struct usb_interface_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_SIZE ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>"" ""interface<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>"" ""skipping\\n"" , cfgno , d -> bLength ) ; continue ; } inum = d -> bInterfaceNumber ; if ( ( dev -> quirks & USB_QUIRK_HONOR_BNUMINTERFACES ) && n >= nintf_orig ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>more<S2SV_blank>interface<S2SV_blank>"" ""descriptors,<S2SV_blank>than<S2SV_blank>it<S2SV_blank>declares<S2SV_blank>in<S2SV_blank>"" ""bNumInterfaces,<S2SV_blank>ignoring<S2SV_blank>interface<S2SV_blank>"" ""number:<S2SV_blank>%d\\n"" , cfgno , inum ) ; continue ; } if ( inum >= nintf_orig ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>"" ""interface<S2SV_blank>number:<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n"" , cfgno , inum , nintf_orig - 1 ) ; for ( i = 0 ; i < n ; ++ i ) { if ( inums [ i ] == inum ) break ; } if ( i < n ) { if ( nalts [ i ] < 255 ) ++ nalts [ i ] ; } else if ( n < USB_MAXINTERFACES ) { inums [ n ] = inum ; nalts [ n ] = 1 ; ++ n ; } } else if ( header -> bDescriptorType == USB_DT_INTERFACE_ASSOCIATION ) {  if ( iad_num == USB_MAXIADS ) {  dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\n"" , cfgno ) ; } else { config -> intf_assoc [ iad_num ] =  ( struct usb_interface_assoc_descriptor  * ) header ; iad_num ++ ; } } else if ( header -> bDescriptorType == USB_DT_DEVICE || header -> bDescriptorType == USB_DT_CONFIG ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>contains<S2SV_blank>an<S2SV_blank>unexpected<S2SV_blank>"" ""descriptor<S2SV_blank>of<S2SV_blank>type<S2SV_blank>0x%X,<S2SV_blank>skipping\\n"" , cfgno , header -> bDescriptorType ) ; } size = buffer2 - buffer ; config -> desc . wTotalLength = cpu_to_le16 ( buffer2 - buffer0 ) ; if ( n != nintf ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>interface%s,<S2SV_blank>different<S2SV_blank>from<S2SV_blank>"" ""the<S2SV_blank>descriptor\'s<S2SV_blank>value:<S2SV_blank>%d\\n"" , cfgno , n , plural ( n ) , nintf_orig ) ; else if ( n == 0 ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>interfaces?\\n"" , cfgno ) ; config -> desc . bNumInterfaces = nintf = n ; for ( i = 0 ; i < nintf ; ++ i ) { for ( j = 0 ; j < nintf ; ++ j ) { if ( inums [ j ] == i ) break ; } if ( j >= nintf ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>interface<S2SV_blank>number<S2SV_blank>"" ""%d\\n"" , cfgno , i ) ; } for ( i = 0 ; i < nintf ; ++ i ) { j = nalts [ i ] ; if ( j > USB_MAXALTSETTING ) { dev_warn ( ddev , ""too<S2SV_blank>many<S2SV_blank>alternate<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>"" ""config<S2SV_blank>%d<S2SV_blank>interface<S2SV_blank>%d:<S2SV_blank>%d,<S2SV_blank>"" ""using<S2SV_blank>maximum<S2SV_blank>allowed:<S2SV_blank>%d\\n"" , cfgno , inums [ i ] , j , USB_MAXALTSETTING ) ; nalts [ i ] = j = USB_MAXALTSETTING ; } len = sizeof ( * intfc ) + sizeof ( struct usb_host_interface ) * j ; config -> intf_cache [ i ] = intfc = kzalloc ( len , GFP_KERNEL ) ; if ( ! intfc ) return - ENOMEM ; kref_init ( & intfc -> ref ) ; } config -> extra = buffer ; i = find_next_descriptor ( buffer , size , USB_DT_INTERFACE , USB_DT_INTERFACE , & n ) ; config -> extralen = i ; if ( n > 0 ) dev_dbg ( ddev , ""skipped<S2SV_blank>%d<S2SV_blank>descriptor%s<S2SV_blank>after<S2SV_blank>%s\\n"" , n , plural ( n ) , ""configuration"" ) ; buffer += i ; size -= i ; while ( size > 0 ) { retval = usb_parse_interface ( ddev , cfgno , config , buffer , size , inums , nalts ) ; if ( retval < 0 ) return retval ; buffer += retval ; size -= retval ; } for ( i = 0 ; i < nintf ; ++ i ) { intfc = config -> intf_cache [ i ] ; for ( j = 0 ; j < intfc -> num_altsetting ; ++ j ) { for ( n = 0 ; n < intfc -> num_altsetting ; ++ n ) { if ( intfc -> altsetting [ n ] . desc . bAlternateSetting == j ) break ; } if ( n >= intfc -> num_altsetting ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>interface<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>"" ""altsetting<S2SV_blank>%d\\n"" , cfgno , inums [ i ] , j ) ; } } return 0 ; }","struct usb_interface_assoc_descriptor * d ;d = ( struct usb_interface_assoc_descriptor * ) header ;if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) {dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\\continue ;}if ( iad_num == USB_MAXIADS ) {dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\\config -> intf_assoc [ iad_num ] = d ;",1573
528,"buggy line: int rc ;unsigned char key2 [ 8 ] ;struct crypto_skcipher * tfm_des ;struct scatterlist sgin , sgout ;tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ;if ( IS_ERR ( tfm_des ) ) {rc = PTR_ERR ( tfm_des ) ;cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\\goto smbhash_err ;}cwe id:CWE-119context: static int smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) {  int rc ;  unsigned char key2 [ 8 ] ;  struct crypto_skcipher * tfm_des ;  struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ;  tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ;  if ( IS_ERR ( tfm_des ) ) {  rc = PTR_ERR ( tfm_des ) ;  cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ;  goto smbhash_err ;  } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ;  sg_init_one ( & sgin , in , 8 ) ;  sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>encrypt<S2SV_blank>crypt<S2SV_blank>key<S2SV_blank>rc:<S2SV_blank>%d\\n"" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ;  smbhash_err :  return rc ; }","unsigned char key2 [ 8 ] ;struct crypto_skcipher * tfm_des ;struct scatterlist sgin , sgout ;tfm_des = crypto_alloc_cipher ( ""des"" , 0 , CRYPTO_ALG_ASYNC ) ;if ( IS_ERR ( tfm_des ) ) {rc = PTR_ERR ( tfm_des ) ;cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\\goto smbhash_err ;}",1574
529,"buggy line: sg_init_one ( & sgin , in , 8 ) ;sg_init_one ( & sgout , out , 8 ) ;skcipher_request_set_callback ( req , 0 , NULL , NULL ) ;skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ;rc = crypto_skcipher_encrypt ( req ) ;smbhash_err :  return rc ;cwe id:CWE-119context: static int smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) {  int rc ;  unsigned char key2 [ 8 ] ;  struct crypto_skcipher * tfm_des ;  struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ;  tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ;  if ( IS_ERR ( tfm_des ) ) {  rc = PTR_ERR ( tfm_des ) ;  cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ;  goto smbhash_err ;  } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ;  sg_init_one ( & sgin , in , 8 ) ;  sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>encrypt<S2SV_blank>crypt<S2SV_blank>key<S2SV_blank>rc:<S2SV_blank>%d\\n"" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ;  smbhash_err :  return rc ; }","sg_init_one ( & sgin , in , 8 ) ;sg_init_one ( & sgout , out , 8 ) ;skcipher_request_set_callback ( req , 0 , 0 ) ;return 0 ;",1574
530,"buggy line: static inline void header_put_be_int ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 )   {psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ;psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;psf -> header [ psf -> headindex ++ ] = x ;};}cwe id:CWE-119context: static inline void header_put_be_int ( SF_PRIVATE * psf , int x )  { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 )   { psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ;   psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ;   psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;   psf -> header [ psf -> headindex ++ ] = x ;   } ;  }","static inline void header_put_be_int ( SF_PRIVATE * psf , int x ) {psf -> header ) - 4 ) {psf -> header . ptr [ psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;psf -> header . indx ++ ] = x ;}",1575
531,"buggy line: uint32_t value ;int position , zeroes , i , j ;char bits [ 65 ] ;zeroes = i = 0 ;while ( 1 ) {if ( get_bits_left ( gbc ) < zeroes + 1 ) {av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\\if ( get_bits1 ( gbc ) ) {bits [ i ++ ] = \'1\' ;break ;}else {bits [ i ++ ] = \'0\' ;}value = get_bits_long ( gbc , zeroes ) ;j ++ )  bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? \'1\' : \'0\' ;value += ( 1 << zeroes ) - 1 ;}cwe id:CWE-129context: static int cbs_av1_read_uvlc ( CodedBitstreamContext * ctx , GetBitContext * gbc , const char * name , uint32_t * write_to , uint32_t range_min , uint32_t range_max ) {  uint32_t value ;   int position , zeroes , i , j ;  char bits [ 65 ] ; if ( ctx -> trace_enable ) position = get_bits_count ( gbc ) ;  zeroes = i = 0 ;  while ( 1 ) {  if ( get_bits_left ( gbc ) < zeroes + 1 ) {  av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\n"" , name ) ; return AVERROR_INVALIDDATA ; }  if ( get_bits1 ( gbc ) ) {  bits [ i ++ ] = '1' ;  break ;  } else { bits [ i ++ ] = '0' ; ++ zeroes ; } } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { value = get_bits_long ( gbc , zeroes ) ; for ( j = 0 ; j < zeroes ; j ++ )  bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? '1' : '0' ;   value += ( 1 << zeroes ) - 1 ;  } if ( ctx -> trace_enable ) { bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , value ) ; } if ( value < range_min || value > range_max ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""%s<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>"" ""%"" PRIu32 "",<S2SV_blank>but<S2SV_blank>must<S2SV_blank>be<S2SV_blank>in<S2SV_blank>[%"" PRIu32 "",%"" PRIu32 ""].\\n"" , name , value , range_min , range_max ) ; return AVERROR_INVALIDDATA ; } * write_to = value ; return 0 ; }","uint32_t zeroes , bits_value , value ;int position ;zeroes = i = 0 ;while ( 1 ) {if ( get_bits_left ( gbc ) < 1 ) {av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\\if ( get_bits1 ( gbc ) ) break ;if ( get_bits_left ( gbc ) < zeroes ) {av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\\return AVERROR_INVALIDDATA ;}bits_value = get_bits_long ( gbc , zeroes ) ;value = bits_value + ( UINT32_C ( 1 ) << zeroes ) - 1 ;}if ( ctx -> trace_enable ) {char bits [ 65 ] ;int i , j , k ;if ( zeroes >= 32 ) {while ( zeroes > 32 ) {k = FFMIN ( zeroes - 32 , 32 ) ;for ( i = 0 ;i < k ;i ++ ) bits [ i ] = \'0\' ;bits [ i ] = 0 ;ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , 0 ) ;zeroes -= k ;position += k ;}}for ( i = 0 ;i < zeroes ;i ++ ) bits [ i ] = \'0\' ;bits [ i ++ ] = \'1\' ;if ( zeroes < 32 ) {j ++ ) bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? \'1\' : \'0\' ;value += ( 1 << zeroes ) - 1 ;}",1576
532,"buggy line: if ( i < pos && i + insn -> off + 1 > pos ) insn -> off += delta ;else if ( i > pos && i + insn -> off + 1 < pos )  insn -> off -= delta ;cwe id:CWE-200context: static void adjust_branches ( struct bpf_prog * prog , int pos , int delta ) { struct bpf_insn * insn = prog -> insnsi ; int insn_cnt = prog -> len ; int i ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) != BPF_JMP || BPF_OP ( insn -> code ) == BPF_CALL || BPF_OP ( insn -> code ) == BPF_EXIT ) continue ; if ( i < pos && i + insn -> off + 1 > pos ) insn -> off += delta ;  else if ( i > pos && i + insn -> off + 1 < pos )  insn -> off -= delta ; } }",if ( i < pos && i + insn -> off + 1 <= pos + delta ) insn -> off += delta ;else if ( i > pos + delta && i + insn -> off + 1 < pos ) insn -> off -= delta ;,1577
533,"buggy line: case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON :  case EXIT_REASON_INVEPT :  return 1 ;cwe id:CWE-000context: static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return 0 ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return 0 ; return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON :  case EXIT_REASON_INVEPT :  return 1 ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : return 0 ; case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }",case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID : return 1 ;,1578
534,"buggy line: else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 )  {param -> name = p + i ;}else {error = ERROR_INVALID_SYNTAX ;}}else if ( param -> nameLen == 0 ) {if ( c == \'\\\\0\' || c == \',\' || c == \';\' ) {param -> nameLen = p + i - param -> name ;error = NO_ERROR ;}else if ( c == \'<S2SV_blank>\' || c == \'\\\\t\' ) {param -> nameLen = p + i - param -> name ;}else if ( c == \'=\' ) {separatorFound = TRUE ;param -> nameLen = p + i - param -> name ;}else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 )  {cwe id:CWE-20context: error_t httpParseParam ( const char_t * * pos , HttpParam * param ) { error_t error ; size_t i ; uint8_t c ; bool_t escapeFlag ; bool_t separatorFound ; const char_t * p ; if ( pos == NULL || param == NULL ) return ERROR_INVALID_PARAMETER ; param -> name = NULL ; param -> nameLen = 0 ; param -> value = NULL ; param -> valueLen = 0 ; escapeFlag = FALSE ; separatorFound = FALSE ; error = ERROR_IN_PROGRESS ; i = 0 ; p = * pos ; while ( error == ERROR_IN_PROGRESS ) { c = ( uint8_t ) p [ i ] ; if ( param -> name == NULL ) { if ( c == '\\0' ) { error = ERROR_NOT_FOUND ; } else if ( c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { param -> name = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> nameLen == 0 ) { if ( c == '\\0' || c == ',' || c == ';' ) { param -> nameLen = p + i - param -> name ; error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { param -> nameLen = p + i - param -> name ; } else if ( c == '=' ) { separatorFound = TRUE ; param -> nameLen = p + i - param -> name ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { } else { error = ERROR_INVALID_SYNTAX ; } } else if ( ! separatorFound ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == '=' ) { separatorFound = TRUE ; } else if ( c == \'\\""\' ) { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> value == NULL ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == \'\\""\' ) { param -> value = p + i ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { param -> value = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( param -> value [ 0 ] == \'\\""\' ) { if ( c == '\\0' ) { error = ERROR_INVALID_SYNTAX ; } else if ( escapeFlag ) { escapeFlag = FALSE ; } else if ( c == '\\\\' ) { escapeFlag = TRUE ; } else if ( c == \'\\""\' ) { i ++ ; param -> valueLen = p + i - param -> value ; error = NO_ERROR ; } else if ( isprint ( c ) || c == '\\t' || c >= 128 ) { } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( c == '\\0' || c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { param -> valueLen = p + i - param -> value ; error = NO_ERROR ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { } else { error = ERROR_INVALID_SYNTAX ; } } } if ( error == ERROR_IN_PROGRESS ) i ++ ; } if ( param -> valueLen >= 2 && param -> value [ 0 ] == \'\\""\' ) { param -> value ++ ; param -> valueLen -= 2 ; } * pos = p + i ; return error ; }","else if ( isalnum ( c ) || osStrchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || osStrchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 ) {",1579
535,"buggy line: else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 )  {cwe id:CWE-20context: error_t httpParseParam ( const char_t * * pos , HttpParam * param ) { error_t error ; size_t i ; uint8_t c ; bool_t escapeFlag ; bool_t separatorFound ; const char_t * p ; if ( pos == NULL || param == NULL ) return ERROR_INVALID_PARAMETER ; param -> name = NULL ; param -> nameLen = 0 ; param -> value = NULL ; param -> valueLen = 0 ; escapeFlag = FALSE ; separatorFound = FALSE ; error = ERROR_IN_PROGRESS ; i = 0 ; p = * pos ; while ( error == ERROR_IN_PROGRESS ) { c = ( uint8_t ) p [ i ] ; if ( param -> name == NULL ) { if ( c == '\\0' ) { error = ERROR_NOT_FOUND ; } else if ( c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { param -> name = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> nameLen == 0 ) { if ( c == '\\0' || c == ',' || c == ';' ) { param -> nameLen = p + i - param -> name ; error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { param -> nameLen = p + i - param -> name ; } else if ( c == '=' ) { separatorFound = TRUE ; param -> nameLen = p + i - param -> name ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { } else { error = ERROR_INVALID_SYNTAX ; } } else if ( ! separatorFound ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == '=' ) { separatorFound = TRUE ; } else if ( c == \'\\""\' ) { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> value == NULL ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == \'\\""\' ) { param -> value = p + i ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { param -> value = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( param -> value [ 0 ] == \'\\""\' ) { if ( c == '\\0' ) { error = ERROR_INVALID_SYNTAX ; } else if ( escapeFlag ) { escapeFlag = FALSE ; } else if ( c == '\\\\' ) { escapeFlag = TRUE ; } else if ( c == \'\\""\' ) { i ++ ; param -> valueLen = p + i - param -> value ; error = NO_ERROR ; } else if ( isprint ( c ) || c == '\\t' || c >= 128 ) { } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( c == '\\0' || c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { param -> valueLen = p + i - param -> value ; error = NO_ERROR ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { } else { error = ERROR_INVALID_SYNTAX ; } } } if ( error == ERROR_IN_PROGRESS ) i ++ ; } if ( param -> valueLen >= 2 && param -> value [ 0 ] == \'\\""\' ) { param -> value ++ ; param -> valueLen -= 2 ; } * pos = p + i ; return error ; }","else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 ) {",1579
536,"buggy line: else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 )  {param -> value = p + i ;}else {error = ERROR_INVALID_SYNTAX ;}}else {if ( param -> value [ 0 ] == \\\'\\\\""\\\' ) {if ( c == \'\\\\0\' ) {error = ERROR_INVALID_SYNTAX ;}else if ( escapeFlag ) {escapeFlag = FALSE ;}else if ( c == \'\\\\\\\\\' ) {escapeFlag = TRUE ;}else if ( c == \\\'\\\\""\\\' ) {i ++ ;param -> valueLen = p + i - param -> value ;error = NO_ERROR ;}else if ( isprint ( c ) || c == \'\\\\t\' || c >= 128 ) {}else {error = ERROR_INVALID_SYNTAX ;}}else {if ( c == \'\\\\0\' || c == \'<S2SV_blank>\' || c == \'\\\\t\' || c == \',\' || c == \';\' ) {param -> valueLen = p + i - param -> value ;error = NO_ERROR ;}else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 )  {cwe id:CWE-20context: error_t httpParseParam ( const char_t * * pos , HttpParam * param ) { error_t error ; size_t i ; uint8_t c ; bool_t escapeFlag ; bool_t separatorFound ; const char_t * p ; if ( pos == NULL || param == NULL ) return ERROR_INVALID_PARAMETER ; param -> name = NULL ; param -> nameLen = 0 ; param -> value = NULL ; param -> valueLen = 0 ; escapeFlag = FALSE ; separatorFound = FALSE ; error = ERROR_IN_PROGRESS ; i = 0 ; p = * pos ; while ( error == ERROR_IN_PROGRESS ) { c = ( uint8_t ) p [ i ] ; if ( param -> name == NULL ) { if ( c == '\\0' ) { error = ERROR_NOT_FOUND ; } else if ( c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { param -> name = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> nameLen == 0 ) { if ( c == '\\0' || c == ',' || c == ';' ) { param -> nameLen = p + i - param -> name ; error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { param -> nameLen = p + i - param -> name ; } else if ( c == '=' ) { separatorFound = TRUE ; param -> nameLen = p + i - param -> name ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { } else { error = ERROR_INVALID_SYNTAX ; } } else if ( ! separatorFound ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == '=' ) { separatorFound = TRUE ; } else if ( c == \'\\""\' ) { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> value == NULL ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == \'\\""\' ) { param -> value = p + i ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { param -> value = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( param -> value [ 0 ] == \'\\""\' ) { if ( c == '\\0' ) { error = ERROR_INVALID_SYNTAX ; } else if ( escapeFlag ) { escapeFlag = FALSE ; } else if ( c == '\\\\' ) { escapeFlag = TRUE ; } else if ( c == \'\\""\' ) { i ++ ; param -> valueLen = p + i - param -> value ; error = NO_ERROR ; } else if ( isprint ( c ) || c == '\\t' || c >= 128 ) { } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( c == '\\0' || c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { param -> valueLen = p + i - param -> value ; error = NO_ERROR ; }  else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 )  { } else { error = ERROR_INVALID_SYNTAX ; } } } if ( error == ERROR_IN_PROGRESS ) i ++ ; } if ( param -> valueLen >= 2 && param -> value [ 0 ] == \'\\""\' ) { param -> value ++ ; param -> valueLen -= 2 ; } * pos = p + i ; return error ; }","else if ( isalnum ( c ) || osStrchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || osStrchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 ) {",1579
537,"buggy line: packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 ,  packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL ,  packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ;cwe id:CWE-416context: static void ndpi_reset_packet_line_info ( struct ndpi_packet_struct * packet ) { packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 ,  packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL ,  packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ; }","packet -> parsed_lines = 0 , packet -> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 , packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ;",1580
538,"buggy line: if ( ! proc_fd_access_allowed ( inode ) ) goto out ;error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ;nd -> last_type = LAST_BIND ;out : return ERR_PTR ( error ) ;cwe id:CWE-20context: static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd ) { struct inode * inode = dentry -> d_inode ; int error = - EACCES ; path_put ( & nd -> path ) ; if ( ! proc_fd_access_allowed ( inode ) ) goto out ; error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ;  nd -> last_type = LAST_BIND ;  out : return ERR_PTR ( error ) ; }",out : return ERR_PTR ( error ) ;,1581
539,"buggy line: assert ( pow ( ( float ) r + 1 , dim ) > entries ) ;assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ;return r ;cwe id:CWE-617context: static int lookup1_values ( int entries , int dim ) { int r = ( int ) floor ( exp ( ( float ) log ( ( float ) entries ) / dim ) ) ; if ( ( int ) floor ( pow ( ( float ) r + 1 , dim ) ) <= entries ) ++ r ;  assert ( pow ( ( float ) r + 1 , dim ) > entries ) ;   assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ;  return r ; }","if ( pow ( ( float ) r + 1 , dim ) <= entries ) return - 1 ;if ( ( int ) floor ( pow ( ( float ) r , dim ) ) > entries ) return - 1 ;return r ;",1582
540,"buggy line: q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) ,   Min ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;cwe id:CWE-20context: static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; PixelPacket * q ; register ssize_t i , x ; size_t bits ; ssize_t j , y ; unsigned char code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) {  q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) ,   Min ( 4 , dds_info -> height - y ) , exception ) ;  if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; SetPixelOpacity ( q , ScaleCharToQuantum ( colors . a [ code ] ) ) ; if ( colors . a [ code ] && image -> matte == MagickFalse ) image -> matte = MagickTrue ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } }  SkipDXTMipmaps ( image , dds_info , 8 ) ;  return MagickTrue ; }","q = QueueAuthenticPixels ( image , x , y , MagickMin ( 4 , dds_info -> width - x ) , MagickMin ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;",1583
541,"buggy line: }SkipDXTMipmaps ( image , dds_info , 8 ) ;return MagickTrue ;cwe id:CWE-20context: static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; PixelPacket * q ; register ssize_t i , x ; size_t bits ; ssize_t j , y ; unsigned char code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) {  q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) ,   Min ( 4 , dds_info -> height - y ) , exception ) ;  if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; SetPixelOpacity ( q , ScaleCharToQuantum ( colors . a [ code ] ) ) ; if ( colors . a [ code ] && image -> matte == MagickFalse ) image -> matte = MagickTrue ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } }  SkipDXTMipmaps ( image , dds_info , 8 ) ;  return MagickTrue ; }","return ( }SkipDXTMipmaps ( image , dds_info , 8 , exception ) ) ;",1583
542,"buggy line: if ( iph -> ihl == 5 ) {memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ;return 0 ;}opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ;cwe id:CWE-665context: static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( IPCB ( skb ) -> opt ) ; if ( iph -> ihl < 5 || iph -> version != 4 ) goto inhdr_error ; if ( ! pskb_may_pull ( skb , iph -> ihl * 4 ) ) goto inhdr_error ; iph = ip_hdr ( skb ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INTRUNCATEDPKTS ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INDISCARDS ) ; goto drop ; }  if ( iph -> ihl == 5 ) {  memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ;  }  opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev = __in_dev_get_rcu ( dev ) ; if ( in_dev && ! IN_DEV_SOURCE_ROUTE ( in_dev ) ) goto drop ; if ( ip_options_rcv_srr ( skb ) ) goto drop ; } return 0 ; inhdr_error : IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INHDRERRORS ) ; drop : return - 1 ; }","memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ;if ( iph -> ihl == 5 ) return 0 ;}opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ;",1584
543,"buggy line: if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) {if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) {if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) {cwe id:CWE-704context: static void merge_param ( HashTable * params , zval * zdata , zval * * * current_param , zval * * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , ""params<S2SV_blank>=<S2SV_blank>"" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , ""\\n"" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( ""value"" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , ""arguments"" , sizeof ( ""arguments"" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args ; if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_update ( params , hkey . str , hkey . len , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_index_update ( params , hkey . num , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } } else { if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_find ( params , hkey . str , hkey . len , ( void * ) & ptr ) ; } else { zend_hash_index_find ( params , hkey . num , ( void * ) & ptr ) ; } zdata_ptr = & zdata ; if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) { zval * * test_ptr ; while ( Z_TYPE_PP ( zdata_ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & test_ptr ) ) {  if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) {  if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { if ( SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } else { if ( SUCCESS == zend_hash_index_find ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else if ( hkey . num ) { Z_ADDREF_PP ( test_ptr ) ; zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } } else { Z_ADDREF_PP ( test_ptr ) ; if ( Z_TYPE_PP ( ptr ) != IS_ARRAY ) { zval_dtor ( * ptr ) ; array_init ( * ptr ) ; } if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else if ( hkey . num ) { zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } break ; } } } } while ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( ptr ) , ( void * ) & ptr ) ) ; * current_param = ptr ; }","if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) {if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) {if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) {",1585
544,"buggy line: int ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ;if ( ret < 0 ) {ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ;if ( ret < 0 ) {cwe id:CWE-284context: static int a2dp_ctrl_receive ( struct a2dp_stream_common * common , void * buffer , int length ) {  int ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ;  if ( ret < 0 ) { ERROR ( ""ack<S2SV_blank>failed<S2SV_blank>(%s)"" , strerror ( errno ) ) ; if ( errno == EINTR ) {  ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ;  if ( ret < 0 ) { ERROR ( ""ack<S2SV_blank>failed<S2SV_blank>(%s)"" , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } else { skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } return ret ; }","int ret = TEMP_FAILURE_RETRY ( recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ) ;if ( ret < 0 ) {ret = TEMP_FAILURE_RETRY ( recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ) ;if ( ret < 0 ) {",1586
545,"buggy line: void BezierOval ( double w , double h , char * action )  {outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\\}cwe id:CWE-20context: void BezierOval ( double w , double h , char * action )  {  outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , - w , - w , h * BzK , - w * BzK , h , h ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c\\n"" , w * BzK , h , w , h * BzK , w ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , w , - h * BzK , w * BzK , - h , - h ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c<S2SV_blank>%s\\n"" , - w * BzK , - h , - w , - h * BzK , - w , action ) ;  } ","void BezierOval ( double w , double h , char * action ) {char * outpos = outputbuffer ;outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\\sendClean ( outputbuffer ) ;}",1587
546,"buggy line: int i ;memset ( cfg , 0 , sizeof ( cfg_t ) ) ;cwe id:CWE-200context: static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) {  int i ;  memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , ""max_devices="" , 12 ) == 0 ) sscanf ( argv [ i ] , ""max_devices=%u"" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , ""manual"" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , ""debug"" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , ""nouserok"" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , ""openasuser"" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , ""alwaysok"" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , ""interactive"" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , ""cue"" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , ""nodetect"" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , ""authfile="" , 9 ) == 0 ) cfg -> auth_file = argv [ i ] + 9 ; if ( strncmp ( argv [ i ] , ""authpending_file="" , 17 ) == 0 ) cfg -> authpending_file = argv [ i ] + 17 ; if ( strncmp ( argv [ i ] , ""origin="" , 7 ) == 0 ) cfg -> origin = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""appid="" , 6 ) == 0 ) cfg -> appid = argv [ i ] + 6 ; if ( strncmp ( argv [ i ] , ""prompt="" , 7 ) == 0 ) cfg -> prompt = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""debug_file="" , 11 ) == 0 ) { const char * filename = argv [ i ] + 11 ; if ( strncmp ( filename , ""stdout"" , 6 ) == 0 ) { cfg -> debug_file = stdout ; } else if ( strncmp ( filename , ""stderr"" , 6 ) == 0 ) { cfg -> debug_file = stderr ; } else if ( strncmp ( filename , ""syslog"" , 6 ) == 0 ) { cfg -> debug_file = ( FILE * ) - 1 ; } else {  struct stat st ;  FILE * file ;  if ( lstat ( filename , & st ) == 0 ) {  if ( S_ISREG ( st . st_mode ) ) {  file = fopen ( filename , ""a"" ) ;  if ( file != NULL ) { cfg -> debug_file = file ;  }  } } } } } if ( cfg -> debug ) { D ( cfg -> debug_file , ""called."" ) ; D ( cfg -> debug_file , ""flags<S2SV_blank>%d<S2SV_blank>argc<S2SV_blank>%d"" , flags , argc ) ; for ( i = 0 ; i < argc ; i ++ ) { D ( cfg -> debug_file , ""argv[%d]=%s"" , i , argv [ i ] ) ; } D ( cfg -> debug_file , ""max_devices=%d"" , cfg -> max_devs ) ; D ( cfg -> debug_file , ""debug=%d"" , cfg -> debug ) ; D ( cfg -> debug_file , ""interactive=%d"" , cfg -> interactive ) ; D ( cfg -> debug_file , ""cue=%d"" , cfg -> cue ) ; D ( cfg -> debug_file , ""nodetect=%d"" , cfg -> nodetect ) ; D ( cfg -> debug_file , ""manual=%d"" , cfg -> manual ) ; D ( cfg -> debug_file , ""nouserok=%d"" , cfg -> nouserok ) ; D ( cfg -> debug_file , ""openasuser=%d"" , cfg -> openasuser ) ; D ( cfg -> debug_file , ""alwaysok=%d"" , cfg -> alwaysok ) ; D ( cfg -> debug_file , ""authfile=%s"" , cfg -> auth_file ? cfg -> auth_file : ""(null)"" ) ; D ( cfg -> debug_file , ""authpending_file=%s"" , cfg -> authpending_file ? cfg -> authpending_file : ""(null)"" ) ; D ( cfg -> debug_file , ""origin=%s"" , cfg -> origin ? cfg -> origin : ""(null)"" ) ; D ( cfg -> debug_file , ""appid=%s"" , cfg -> appid ? cfg -> appid : ""(null)"" ) ; D ( cfg -> debug_file , ""prompt=%s"" , cfg -> prompt ? cfg -> prompt : ""(null)"" ) ; }  } ","struct stat st ;FILE * file = NULL ;int fd = - 1 ;int i ;memset ( cfg , 0 , sizeof ( cfg_t ) ) ;",1588
547,"buggy line: struct stat st ;FILE * file ;if ( lstat ( filename , & st ) == 0 ) {if ( S_ISREG ( st . st_mode ) ) {file = fopen ( filename , ""a"" ) ;if ( file != NULL ) {}}cwe id:CWE-200context: static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) {  int i ;  memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , ""max_devices="" , 12 ) == 0 ) sscanf ( argv [ i ] , ""max_devices=%u"" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , ""manual"" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , ""debug"" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , ""nouserok"" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , ""openasuser"" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , ""alwaysok"" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , ""interactive"" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , ""cue"" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , ""nodetect"" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , ""authfile="" , 9 ) == 0 ) cfg -> auth_file = argv [ i ] + 9 ; if ( strncmp ( argv [ i ] , ""authpending_file="" , 17 ) == 0 ) cfg -> authpending_file = argv [ i ] + 17 ; if ( strncmp ( argv [ i ] , ""origin="" , 7 ) == 0 ) cfg -> origin = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""appid="" , 6 ) == 0 ) cfg -> appid = argv [ i ] + 6 ; if ( strncmp ( argv [ i ] , ""prompt="" , 7 ) == 0 ) cfg -> prompt = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""debug_file="" , 11 ) == 0 ) { const char * filename = argv [ i ] + 11 ; if ( strncmp ( filename , ""stdout"" , 6 ) == 0 ) { cfg -> debug_file = stdout ; } else if ( strncmp ( filename , ""stderr"" , 6 ) == 0 ) { cfg -> debug_file = stderr ; } else if ( strncmp ( filename , ""syslog"" , 6 ) == 0 ) { cfg -> debug_file = ( FILE * ) - 1 ; } else {  struct stat st ;  FILE * file ;  if ( lstat ( filename , & st ) == 0 ) {  if ( S_ISREG ( st . st_mode ) ) {  file = fopen ( filename , ""a"" ) ;  if ( file != NULL ) { cfg -> debug_file = file ;  }  } } } } } if ( cfg -> debug ) { D ( cfg -> debug_file , ""called."" ) ; D ( cfg -> debug_file , ""flags<S2SV_blank>%d<S2SV_blank>argc<S2SV_blank>%d"" , flags , argc ) ; for ( i = 0 ; i < argc ; i ++ ) { D ( cfg -> debug_file , ""argv[%d]=%s"" , i , argv [ i ] ) ; } D ( cfg -> debug_file , ""max_devices=%d"" , cfg -> max_devs ) ; D ( cfg -> debug_file , ""debug=%d"" , cfg -> debug ) ; D ( cfg -> debug_file , ""interactive=%d"" , cfg -> interactive ) ; D ( cfg -> debug_file , ""cue=%d"" , cfg -> cue ) ; D ( cfg -> debug_file , ""nodetect=%d"" , cfg -> nodetect ) ; D ( cfg -> debug_file , ""manual=%d"" , cfg -> manual ) ; D ( cfg -> debug_file , ""nouserok=%d"" , cfg -> nouserok ) ; D ( cfg -> debug_file , ""openasuser=%d"" , cfg -> openasuser ) ; D ( cfg -> debug_file , ""alwaysok=%d"" , cfg -> alwaysok ) ; D ( cfg -> debug_file , ""authfile=%s"" , cfg -> auth_file ? cfg -> auth_file : ""(null)"" ) ; D ( cfg -> debug_file , ""authpending_file=%s"" , cfg -> authpending_file ? cfg -> authpending_file : ""(null)"" ) ; D ( cfg -> debug_file , ""origin=%s"" , cfg -> origin ? cfg -> origin : ""(null)"" ) ; D ( cfg -> debug_file , ""appid=%s"" , cfg -> appid ? cfg -> appid : ""(null)"" ) ; D ( cfg -> debug_file , ""prompt=%s"" , cfg -> prompt ? cfg -> prompt : ""(null)"" ) ; }  } ","fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ;if ( fd >= 0 && ( fstat ( fd , & st ) == 0 ) && S_ISREG ( st . st_mode ) ) {file = fdopen ( fd , ""a"" ) ;if ( file != NULL ) {cfg -> is_custom_debug_file = 1 ;file = NULL ;fd = - 1 ;}}",1588
548,"buggy line: cwe id:CWE-200context: static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) {  int i ;  memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , ""max_devices="" , 12 ) == 0 ) sscanf ( argv [ i ] , ""max_devices=%u"" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , ""manual"" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , ""debug"" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , ""nouserok"" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , ""openasuser"" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , ""alwaysok"" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , ""interactive"" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , ""cue"" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , ""nodetect"" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , ""authfile="" , 9 ) == 0 ) cfg -> auth_file = argv [ i ] + 9 ; if ( strncmp ( argv [ i ] , ""authpending_file="" , 17 ) == 0 ) cfg -> authpending_file = argv [ i ] + 17 ; if ( strncmp ( argv [ i ] , ""origin="" , 7 ) == 0 ) cfg -> origin = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""appid="" , 6 ) == 0 ) cfg -> appid = argv [ i ] + 6 ; if ( strncmp ( argv [ i ] , ""prompt="" , 7 ) == 0 ) cfg -> prompt = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""debug_file="" , 11 ) == 0 ) { const char * filename = argv [ i ] + 11 ; if ( strncmp ( filename , ""stdout"" , 6 ) == 0 ) { cfg -> debug_file = stdout ; } else if ( strncmp ( filename , ""stderr"" , 6 ) == 0 ) { cfg -> debug_file = stderr ; } else if ( strncmp ( filename , ""syslog"" , 6 ) == 0 ) { cfg -> debug_file = ( FILE * ) - 1 ; } else {  struct stat st ;  FILE * file ;  if ( lstat ( filename , & st ) == 0 ) {  if ( S_ISREG ( st . st_mode ) ) {  file = fopen ( filename , ""a"" ) ;  if ( file != NULL ) { cfg -> debug_file = file ;  }  } } } } } if ( cfg -> debug ) { D ( cfg -> debug_file , ""called."" ) ; D ( cfg -> debug_file , ""flags<S2SV_blank>%d<S2SV_blank>argc<S2SV_blank>%d"" , flags , argc ) ; for ( i = 0 ; i < argc ; i ++ ) { D ( cfg -> debug_file , ""argv[%d]=%s"" , i , argv [ i ] ) ; } D ( cfg -> debug_file , ""max_devices=%d"" , cfg -> max_devs ) ; D ( cfg -> debug_file , ""debug=%d"" , cfg -> debug ) ; D ( cfg -> debug_file , ""interactive=%d"" , cfg -> interactive ) ; D ( cfg -> debug_file , ""cue=%d"" , cfg -> cue ) ; D ( cfg -> debug_file , ""nodetect=%d"" , cfg -> nodetect ) ; D ( cfg -> debug_file , ""manual=%d"" , cfg -> manual ) ; D ( cfg -> debug_file , ""nouserok=%d"" , cfg -> nouserok ) ; D ( cfg -> debug_file , ""openasuser=%d"" , cfg -> openasuser ) ; D ( cfg -> debug_file , ""alwaysok=%d"" , cfg -> alwaysok ) ; D ( cfg -> debug_file , ""authfile=%s"" , cfg -> auth_file ? cfg -> auth_file : ""(null)"" ) ; D ( cfg -> debug_file , ""authpending_file=%s"" , cfg -> authpending_file ? cfg -> authpending_file : ""(null)"" ) ; D ( cfg -> debug_file , ""origin=%s"" , cfg -> origin ? cfg -> origin : ""(null)"" ) ; D ( cfg -> debug_file , ""appid=%s"" , cfg -> appid ? cfg -> appid : ""(null)"" ) ; D ( cfg -> debug_file , ""prompt=%s"" , cfg -> prompt ? cfg -> prompt : ""(null)"" ) ; }  } ",if ( fd != - 1 ) close ( fd ) ;if ( file != NULL ) fclose ( file ) ;,1588
549,"buggy line: }cwe id:CWE-200context: static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) {  int i ;  memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , ""max_devices="" , 12 ) == 0 ) sscanf ( argv [ i ] , ""max_devices=%u"" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , ""manual"" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , ""debug"" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , ""nouserok"" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , ""openasuser"" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , ""alwaysok"" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , ""interactive"" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , ""cue"" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , ""nodetect"" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , ""authfile="" , 9 ) == 0 ) cfg -> auth_file = argv [ i ] + 9 ; if ( strncmp ( argv [ i ] , ""authpending_file="" , 17 ) == 0 ) cfg -> authpending_file = argv [ i ] + 17 ; if ( strncmp ( argv [ i ] , ""origin="" , 7 ) == 0 ) cfg -> origin = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""appid="" , 6 ) == 0 ) cfg -> appid = argv [ i ] + 6 ; if ( strncmp ( argv [ i ] , ""prompt="" , 7 ) == 0 ) cfg -> prompt = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""debug_file="" , 11 ) == 0 ) { const char * filename = argv [ i ] + 11 ; if ( strncmp ( filename , ""stdout"" , 6 ) == 0 ) { cfg -> debug_file = stdout ; } else if ( strncmp ( filename , ""stderr"" , 6 ) == 0 ) { cfg -> debug_file = stderr ; } else if ( strncmp ( filename , ""syslog"" , 6 ) == 0 ) { cfg -> debug_file = ( FILE * ) - 1 ; } else {  struct stat st ;  FILE * file ;  if ( lstat ( filename , & st ) == 0 ) {  if ( S_ISREG ( st . st_mode ) ) {  file = fopen ( filename , ""a"" ) ;  if ( file != NULL ) { cfg -> debug_file = file ;  }  } } } } } if ( cfg -> debug ) { D ( cfg -> debug_file , ""called."" ) ; D ( cfg -> debug_file , ""flags<S2SV_blank>%d<S2SV_blank>argc<S2SV_blank>%d"" , flags , argc ) ; for ( i = 0 ; i < argc ; i ++ ) { D ( cfg -> debug_file , ""argv[%d]=%s"" , i , argv [ i ] ) ; } D ( cfg -> debug_file , ""max_devices=%d"" , cfg -> max_devs ) ; D ( cfg -> debug_file , ""debug=%d"" , cfg -> debug ) ; D ( cfg -> debug_file , ""interactive=%d"" , cfg -> interactive ) ; D ( cfg -> debug_file , ""cue=%d"" , cfg -> cue ) ; D ( cfg -> debug_file , ""nodetect=%d"" , cfg -> nodetect ) ; D ( cfg -> debug_file , ""manual=%d"" , cfg -> manual ) ; D ( cfg -> debug_file , ""nouserok=%d"" , cfg -> nouserok ) ; D ( cfg -> debug_file , ""openasuser=%d"" , cfg -> openasuser ) ; D ( cfg -> debug_file , ""alwaysok=%d"" , cfg -> alwaysok ) ; D ( cfg -> debug_file , ""authfile=%s"" , cfg -> auth_file ? cfg -> auth_file : ""(null)"" ) ; D ( cfg -> debug_file , ""authpending_file=%s"" , cfg -> authpending_file ? cfg -> authpending_file : ""(null)"" ) ; D ( cfg -> debug_file , ""origin=%s"" , cfg -> origin ? cfg -> origin : ""(null)"" ) ; D ( cfg -> debug_file , ""appid=%s"" , cfg -> appid ? cfg -> appid : ""(null)"" ) ; D ( cfg -> debug_file , ""prompt=%s"" , cfg -> prompt ? cfg -> prompt : ""(null)"" ) ; }  } ",},1588
550,"buggy line: if ( ! sm_info ) return - ENOMEM ;sbi -> sm_info = sm_info ;sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ;sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ;sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ;sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ;sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ;sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ;sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ;sm_info -> rec_prefree_segments = sm_info -> main_segments * DEF_RECLAIM_PREFREE_SEGMENTS / 100 ;if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ;if ( ! test_opt ( sbi , LFS ) ) sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ;sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ;sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ;sm_info -> min_hot_blocks = DEF_MIN_HOT_BLOCKS ;sm_info -> trim_sections = DEF_BATCHED_TRIM_SECTIONS ;INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ;if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) {err = create_flush_cmd_control ( sbi ) ;cwe id:CWE-476context: int build_segment_manager ( struct f2fs_sb_info * sbi ) { struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; struct f2fs_sm_info * sm_info ; int err ; sm_info = kzalloc ( sizeof ( struct f2fs_sm_info ) , GFP_KERNEL ) ; if ( ! sm_info ) return - ENOMEM ; sbi -> sm_info = sm_info ; sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ; sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ; sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ; sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ; sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ; sm_info -> rec_prefree_segments = sm_info -> main_segments * DEF_RECLAIM_PREFREE_SEGMENTS / 100 ; if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ; if ( ! test_opt ( sbi , LFS ) ) sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ; sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ; sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ; sm_info -> min_hot_blocks = DEF_MIN_HOT_BLOCKS ; sm_info -> trim_sections = DEF_BATCHED_TRIM_SECTIONS ; INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ;  if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) {  err = create_flush_cmd_control ( sbi ) ; if ( err ) return err ; } err = create_discard_cmd_control ( sbi ) ; if ( err ) return err ; err = build_sit_info ( sbi ) ; if ( err ) return err ; err = build_free_segmap ( sbi ) ; if ( err ) return err ; err = build_curseg ( sbi ) ; if ( err ) return err ; build_sit_entries ( sbi ) ; init_free_segmap ( sbi ) ; err = build_dirty_segmap ( sbi ) ; if ( err ) return err ; init_min_max_mtime ( sbi ) ; return 0 ; }",if ( ! f2fs_readonly ( sbi -> sb ) ) {err = create_flush_cmd_control ( sbi ) ;,1589
551,"buggy line: if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ;if ( sun_info . depth < 24 ) {size_t one ;image -> colors = sun_info . maplength ;one = 1 ;if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ;if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}case RMT_RAW : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ;if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ;image -> columns = sun_info . width ;image -> rows = sun_info . height ;if ( image_info -> ping != MagickFalse ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) &&   ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;cwe id:CWE-125context: static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;  if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) &&   ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ;  length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ;  if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> depth = sun_info . depth ) > ( 8 * sun_info . length ) * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",1590
552,"buggy line: length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;cwe id:CWE-125context: static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;  if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) &&   ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ;  length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ;  if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;",1590
553,"buggy line: outpos +=  sprintf ( outpos , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\\}}cwe id:CWE-20context: void SetTransferMatrix ( double x11 , double x12 , double x21 , double x22 , double x , double y ) { if ( ( fabs ( x11 - 1. ) > 0.001 ) || ( fabs ( x22 - 1. ) > 0.001 ) || ( fabs ( x12 ) > 0.001 ) || ( fabs ( x21 ) > 0.001 ) || ( fabs ( x ) > 0.001 ) || ( fabs ( y ) > 0.001 ) ) {  outpos +=  sprintf ( outpos , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , x11 , x12 , x21 , x22 , x , y ) ;  }  }","sprintf ( outputbuffer , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\\sendClean ( outputbuffer ) ;}}",1591
554,"buggy line: WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ;Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ;cwe id:CWE-125context: static BOOL autodetect_recv_bandwidth_measure_results ( rdpRdp * rdp , wStream * s , AUTODETECT_RSP_PDU * autodetectRspPdu ) { BOOL success = TRUE ; if ( autodetectRspPdu -> headerLength != 0x0E ) return FALSE ;  WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ;  Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ; Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureByteCount ) ; if ( rdp -> autodetect -> bandwidthMeasureTimeDelta > 0 ) rdp -> autodetect -> netCharBandwidth = rdp -> autodetect -> bandwidthMeasureByteCount * 8 / rdp -> autodetect -> bandwidthMeasureTimeDelta ; else rdp -> autodetect -> netCharBandwidth = 0 ; IFCALLRET ( rdp -> autodetect -> BandwidthMeasureResults , success , rdp -> context , autodetectRspPdu -> sequenceNumber ) ; return success ; }","WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ;if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1 ;Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ;",1592
555,"buggy line: _ipmi_destroy_user ( user ) ;cleanup_srcu_struct ( & user -> release_barrier ) ;cwe id:CWE-416context: int ipmi_destroy_user ( struct ipmi_user * user ) {  _ipmi_destroy_user ( user ) ;  cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }",_ipmi_destroy_user ( user ) ;,1593
556,"buggy line: # endif if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) vp8_activity_masking ( cpi , x ) ;if ( xd -> segmentation_enabled ) {if ( cpi -> segmentation_map [ map_index + mb_col ] <= 3 ) xd -> mode_info_context -> mbmi . segment_id = cpi -> segmentation_map [ map_index + mb_col ] ;else xd -> mode_info_context -> mbmi . segment_id = 0 ;vp8cx_mb_init_quantizer ( cpi , x , 1 ) ;else xd -> mode_info_context -> mbmi . segment_id = 0 ;x -> active_ptr = cpi -> active_map + map_index + mb_col ;if ( cm -> frame_type == KEY_FRAME ) {* totalrate += vp8cx_encode_intra_macroblock ( cpi , x , tp ) ;# ifdef MODE_STATS y_modes [ xd -> mbmi . mode ] ++ ;# endif }* totalrate += vp8cx_encode_inter_macroblock ( cpi , x , tp , recon_yoffset , recon_uvoffset , mb_row , mb_col ) ;# ifdef MODE_STATS inter_y_modes [ xd -> mbmi . mode ] ++ ;if ( xd -> mbmi . mode == SPLITMV ) {int b ;for ( b = 0 ;b < xd -> mbmi . partition_count ;b ++ ) {inter_b_modes [ x -> partition -> bmi [ b ] . mode ] ++ ;# endif  if ( ( cpi -> current_layer == 0 ) &&  ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) {else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) )  {cwe id:CWE-119context: static void encode_mb_row ( VP8_COMP * cpi , VP8_COMMON * cm , int mb_row , MACROBLOCK * x , MACROBLOCKD * xd , TOKENEXTRA * * tp , int * segment_counts , int * totalrate ) { int recon_yoffset , recon_uvoffset ; int mb_col ; int ref_fb_idx = cm -> lst_fb_idx ; int dst_fb_idx = cm -> new_fb_idx ; int recon_y_stride = cm -> yv12_fb [ ref_fb_idx ] . y_stride ; int recon_uv_stride = cm -> yv12_fb [ ref_fb_idx ] . uv_stride ; int map_index = ( mb_row * cpi -> common . mb_cols ) ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) const int num_part = ( 1 << cm -> multi_token_partition ) ; TOKENEXTRA * tp_start = cpi -> tok ; vp8_writer * w ; # endif # if CONFIG_MULTITHREAD const int nsync = cpi -> mt_sync_range ; const int rightmost_col = cm -> mb_cols + nsync ; volatile const int * last_row_current_mb_col ; volatile int * current_mb_col = & cpi -> mt_current_mb_col [ mb_row ] ; if ( ( cpi -> b_multi_threaded != 0 ) && ( mb_row != 0 ) ) last_row_current_mb_col = & cpi -> mt_current_mb_col [ mb_row - 1 ] ; else last_row_current_mb_col = & rightmost_col ; # endif # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( num_part > 1 ) w = & cpi -> bc [ 1 + ( mb_row % num_part ) ] ; else w = & cpi -> bc [ 1 ] ; # endif xd -> above_context = cm -> above_context ; xd -> up_available = ( mb_row != 0 ) ; recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; recon_uvoffset = ( mb_row * recon_uv_stride * 8 ) ; cpi -> tplist [ mb_row ] . start = * tp ; xd -> mb_to_top_edge = - ( ( mb_row * 16 ) << 3 ) ; xd -> mb_to_bottom_edge = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) << 3 ; x -> mv_row_min = - ( ( mb_row * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; x -> mb_activity_ptr = & cpi -> mb_activity_map [ map_index ] ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) * tp = cpi -> tok ; # endif xd -> mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; xd -> mb_to_right_edge = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) << 3 ; x -> mv_col_min = - ( ( mb_col * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; xd -> dst . y_buffer = cm -> yv12_fb [ dst_fb_idx ] . y_buffer + recon_yoffset ; xd -> dst . u_buffer = cm -> yv12_fb [ dst_fb_idx ] . u_buffer + recon_uvoffset ; xd -> dst . v_buffer = cm -> yv12_fb [ dst_fb_idx ] . v_buffer + recon_uvoffset ; xd -> left_available = ( mb_col != 0 ) ; x -> rddiv = cpi -> RDDIV ; x -> rdmult = cpi -> RDMULT ; vp8_copy_mem16x16 ( x -> src . y_buffer , x -> src . y_stride , x -> thismb , 16 ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded != 0 ) { * current_mb_col = mb_col - 1 ; if ( ( mb_col & ( nsync - 1 ) ) == 0 ) { while ( mb_col > ( * last_row_current_mb_col - nsync ) ) { x86_pause_hint ( ) ; thread_sleep ( 0 ) ; } } } # endif if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) vp8_activity_masking ( cpi , x ) ; if ( xd -> segmentation_enabled ) { if ( cpi -> segmentation_map [ map_index + mb_col ] <= 3 ) xd -> mode_info_context -> mbmi . segment_id = cpi -> segmentation_map [ map_index + mb_col ] ; else xd -> mode_info_context -> mbmi . segment_id = 0 ; vp8cx_mb_init_quantizer ( cpi , x , 1 ) ; } else xd -> mode_info_context -> mbmi . segment_id = 0 ; x -> active_ptr = cpi -> active_map + map_index + mb_col ; if ( cm -> frame_type == KEY_FRAME ) { * totalrate += vp8cx_encode_intra_macroblock ( cpi , x , tp ) ; # ifdef MODE_STATS y_modes [ xd -> mbmi . mode ] ++ ; # endif } else { * totalrate += vp8cx_encode_inter_macroblock ( cpi , x , tp , recon_yoffset , recon_uvoffset , mb_row , mb_col ) ; # ifdef MODE_STATS inter_y_modes [ xd -> mbmi . mode ] ++ ; if ( xd -> mbmi . mode == SPLITMV ) { int b ; for ( b = 0 ; b < xd -> mbmi . partition_count ; b ++ ) { inter_b_modes [ x -> partition -> bmi [ b ] . mode ] ++ ; } } # endif  if ( ( cpi -> current_layer == 0 ) &&  ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ;  else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) )  { if ( cpi -> cyclic_refresh_map [ map_index + mb_col ] == 1 ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = 0 ; } else cpi -> cyclic_refresh_map [ map_index + mb_col ] = 1 ; } } cpi -> tplist [ mb_row ] . stop = * tp ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int tok_count = * tp - tp_start ;  pack_tokens ( w , tp_start , tok_count ) ;  } # endif x -> gf_active_ptr ++ ; x -> mb_activity_ptr ++ ; x -> src . y_buffer += 16 ; x -> src . u_buffer += 8 ; x -> src . v_buffer += 8 ; recon_yoffset += 16 ; recon_uvoffset += 8 ; segment_counts [ xd -> mode_info_context -> mbmi . segment_id ] ++ ; xd -> mode_info_context ++ ; x -> partition_info ++ ; xd -> above_context ++ ; } vp8_extend_mb_row ( & cm -> yv12_fb [ dst_fb_idx ] , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded != 0 ) * current_mb_col = rightmost_col ; # endif xd -> mode_info_context ++ ; x -> partition_info ++ ; }",# endif if ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) {cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ;if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ;else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) {if ( cpi -> consec_zero_last [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last [ map_index + mb_col ] += 1 ;if ( cpi -> consec_zero_last_mvbias [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] += 1 ;cpi -> consec_zero_last [ map_index + mb_col ] = 0 ;cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ;if ( x -> zero_last_dot_suppress ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ;if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) {else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) ) {,1594
557,"buggy line: pack_tokens ( w , tp_start , tok_count ) ;}cwe id:CWE-119context: static void encode_mb_row ( VP8_COMP * cpi , VP8_COMMON * cm , int mb_row , MACROBLOCK * x , MACROBLOCKD * xd , TOKENEXTRA * * tp , int * segment_counts , int * totalrate ) { int recon_yoffset , recon_uvoffset ; int mb_col ; int ref_fb_idx = cm -> lst_fb_idx ; int dst_fb_idx = cm -> new_fb_idx ; int recon_y_stride = cm -> yv12_fb [ ref_fb_idx ] . y_stride ; int recon_uv_stride = cm -> yv12_fb [ ref_fb_idx ] . uv_stride ; int map_index = ( mb_row * cpi -> common . mb_cols ) ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) const int num_part = ( 1 << cm -> multi_token_partition ) ; TOKENEXTRA * tp_start = cpi -> tok ; vp8_writer * w ; # endif # if CONFIG_MULTITHREAD const int nsync = cpi -> mt_sync_range ; const int rightmost_col = cm -> mb_cols + nsync ; volatile const int * last_row_current_mb_col ; volatile int * current_mb_col = & cpi -> mt_current_mb_col [ mb_row ] ; if ( ( cpi -> b_multi_threaded != 0 ) && ( mb_row != 0 ) ) last_row_current_mb_col = & cpi -> mt_current_mb_col [ mb_row - 1 ] ; else last_row_current_mb_col = & rightmost_col ; # endif # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( num_part > 1 ) w = & cpi -> bc [ 1 + ( mb_row % num_part ) ] ; else w = & cpi -> bc [ 1 ] ; # endif xd -> above_context = cm -> above_context ; xd -> up_available = ( mb_row != 0 ) ; recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; recon_uvoffset = ( mb_row * recon_uv_stride * 8 ) ; cpi -> tplist [ mb_row ] . start = * tp ; xd -> mb_to_top_edge = - ( ( mb_row * 16 ) << 3 ) ; xd -> mb_to_bottom_edge = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) << 3 ; x -> mv_row_min = - ( ( mb_row * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; x -> mb_activity_ptr = & cpi -> mb_activity_map [ map_index ] ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) * tp = cpi -> tok ; # endif xd -> mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; xd -> mb_to_right_edge = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) << 3 ; x -> mv_col_min = - ( ( mb_col * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; xd -> dst . y_buffer = cm -> yv12_fb [ dst_fb_idx ] . y_buffer + recon_yoffset ; xd -> dst . u_buffer = cm -> yv12_fb [ dst_fb_idx ] . u_buffer + recon_uvoffset ; xd -> dst . v_buffer = cm -> yv12_fb [ dst_fb_idx ] . v_buffer + recon_uvoffset ; xd -> left_available = ( mb_col != 0 ) ; x -> rddiv = cpi -> RDDIV ; x -> rdmult = cpi -> RDMULT ; vp8_copy_mem16x16 ( x -> src . y_buffer , x -> src . y_stride , x -> thismb , 16 ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded != 0 ) { * current_mb_col = mb_col - 1 ; if ( ( mb_col & ( nsync - 1 ) ) == 0 ) { while ( mb_col > ( * last_row_current_mb_col - nsync ) ) { x86_pause_hint ( ) ; thread_sleep ( 0 ) ; } } } # endif if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) vp8_activity_masking ( cpi , x ) ; if ( xd -> segmentation_enabled ) { if ( cpi -> segmentation_map [ map_index + mb_col ] <= 3 ) xd -> mode_info_context -> mbmi . segment_id = cpi -> segmentation_map [ map_index + mb_col ] ; else xd -> mode_info_context -> mbmi . segment_id = 0 ; vp8cx_mb_init_quantizer ( cpi , x , 1 ) ; } else xd -> mode_info_context -> mbmi . segment_id = 0 ; x -> active_ptr = cpi -> active_map + map_index + mb_col ; if ( cm -> frame_type == KEY_FRAME ) { * totalrate += vp8cx_encode_intra_macroblock ( cpi , x , tp ) ; # ifdef MODE_STATS y_modes [ xd -> mbmi . mode ] ++ ; # endif } else { * totalrate += vp8cx_encode_inter_macroblock ( cpi , x , tp , recon_yoffset , recon_uvoffset , mb_row , mb_col ) ; # ifdef MODE_STATS inter_y_modes [ xd -> mbmi . mode ] ++ ; if ( xd -> mbmi . mode == SPLITMV ) { int b ; for ( b = 0 ; b < xd -> mbmi . partition_count ; b ++ ) { inter_b_modes [ x -> partition -> bmi [ b ] . mode ] ++ ; } } # endif  if ( ( cpi -> current_layer == 0 ) &&  ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ;  else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) )  { if ( cpi -> cyclic_refresh_map [ map_index + mb_col ] == 1 ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = 0 ; } else cpi -> cyclic_refresh_map [ map_index + mb_col ] = 1 ; } } cpi -> tplist [ mb_row ] . stop = * tp ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int tok_count = * tp - tp_start ;  pack_tokens ( w , tp_start , tok_count ) ;  } # endif x -> gf_active_ptr ++ ; x -> mb_activity_ptr ++ ; x -> src . y_buffer += 16 ; x -> src . u_buffer += 8 ; x -> src . v_buffer += 8 ; recon_yoffset += 16 ; recon_uvoffset += 8 ; segment_counts [ xd -> mode_info_context -> mbmi . segment_id ] ++ ; xd -> mode_info_context ++ ; x -> partition_info ++ ; xd -> above_context ++ ; } vp8_extend_mb_row ( & cm -> yv12_fb [ dst_fb_idx ] , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded != 0 ) * current_mb_col = rightmost_col ; # endif xd -> mode_info_context ++ ; x -> partition_info ++ ; }","vp8_pack_tokens ( w , tp_start , tok_count ) ;}",1594
558,"buggy line: if ( type == ARPHRD_ETHER )  dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ;else  dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ;cwe id:CWE-000context: static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( ( pvc = add_pvc ( frad , dlci ) ) == NULL ) { netdev_warn ( frad , ""Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_add_pvc()\\n"" ) ; return - ENOBUFS ; } if ( * get_dev_p ( pvc , type ) ) return - EEXIST ; used = pvc_is_used ( pvc ) ;  if ( type == ARPHRD_ETHER )  dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ;  else  dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , ""Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_pvc()\\n"" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } if ( type == ARPHRD_ETHER ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = HDLC_MAX_MTU ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - EIO ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) -> dce_changed = 1 ; state ( hdlc ) -> dce_pvc_count ++ ; } return 0 ; }","if ( type == ARPHRD_ETHER ) {dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ;dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;}else dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ;",1595
559,"buggy line: in_uint16_le ( s , type ) ;in_uint16_le ( s , status ) ;if ( status == CLIPRDR_ERROR )  {cwe id:CWE-119context: static void cliprdr_process ( STREAM s ) { uint16 type , status ; uint32 length , format ; uint8 * data ;  in_uint16_le ( s , type ) ;  in_uint16_le ( s , status ) ; in_uint32_le ( s , length ) ; data = s -> p ; logger ( Clipboard , Debug , ""cliprdr_process(),<S2SV_blank>type=%d,<S2SV_blank>status=%d,<S2SV_blank>length=%d"" , type , status , length ) ;  if ( status == CLIPRDR_ERROR )  { switch ( type ) { case CLIPRDR_FORMAT_ACK : cliprdr_send_native_format_announce ( last_formats , last_formats_length ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_request_failed ( ) ; break ; default : logger ( Clipboard , Warning , ""cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>error<S2SV_blank>(type=%d)"" , type ) ; } return ; } switch ( type ) { case CLIPRDR_CONNECT : ui_clip_sync ( ) ; break ; case CLIPRDR_FORMAT_ANNOUNCE : ui_clip_format_announce ( data , length ) ; cliprdr_send_packet ( CLIPRDR_FORMAT_ACK , CLIPRDR_RESPONSE , NULL , 0 ) ; return ; case CLIPRDR_FORMAT_ACK : break ; case CLIPRDR_DATA_REQUEST : in_uint32_le ( s , format ) ; ui_clip_request_data ( format ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_handle_data ( data , length ) ; break ; case 7 : break ; default : logger ( Clipboard , Warning , ""cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>%d"" , type ) ; } }","struct stream packet = * s ;in_uint16_le ( s , type ) ;in_uint16_le ( s , status ) ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}if ( status == CLIPRDR_ERROR ) {",1596
560,"buggy line: # if CONFIG_MULTITHREAD  if ( pbi -> b_multithreaded_rd )  vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ;vp8_decoder_remove_threads ( pbi ) ;cwe id:CWE-000context: int vp8_remove_decoder_instances ( struct frame_buffers * fb ) { if ( ! fb -> use_frame_threads ) { VP8D_COMP * pbi = fb -> pbi [ 0 ] ; if ( ! pbi ) return VPX_CODEC_ERROR ; # if CONFIG_MULTITHREAD  if ( pbi -> b_multithreaded_rd )  vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ; vp8_decoder_remove_threads ( pbi ) ; # endif remove_decompressor ( pbi ) ; } else { } return VPX_CODEC_OK ; }",# if CONFIG_MULTITHREAD vp8_decoder_remove_threads ( pbi ) ;,1597
561,"buggy line: cwe id:CWE-476context: void formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : # ifdef MENU_SELECT case FORM_SELECT : # endif spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : if ( buf -> currentLine == NULL || spos >= buf -> currentLine -> len || spos < 0 ) break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = '<S2SV_blank>' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : # ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else # endif { if ( ! form -> value ) break ; p = form -> value -> ptr ; } l = buf -> currentLine ; if ( ! l ) break ; if ( form -> type == FORM_TEXTAREA ) { int n = a -> y - buf -> currentLine -> linenumber ; if ( n > 0 ) for ( ; l && n ; l = l -> prev , n -- ) ; else if ( n < 0 ) for ( ; l && n ; l = l -> prev , n ++ ) ; if ( ! l ) break ; } rows = form -> rows ? form -> rows : 1 ; col = COLPOS ( l , a -> start . pos ) ; for ( c_rows = 0 ; c_rows < rows ; c_rows ++ , l = l -> next ) {  if ( rows > 1 ) {  pos = columnPos ( l , col ) ; a = retrieveAnchor ( buf -> formitem , l -> linenumber , pos ) ; if ( a == NULL ) break ; spos = a -> start . pos ; epos = a -> end . pos ; } if ( a -> start . line != a -> end . line || spos > epos || epos >= l -> len || spos < 0 || epos < 0 || COLPOS ( l , epos ) < col ) break ; pos = form_update_line ( l , & p , spos , epos , COLPOS ( l , epos ) - col , rows > 1 , form -> type == FORM_INPUT_PASSWORD ) ; if ( pos != epos ) { shiftAnchorPosition ( buf -> href , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> name , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> img , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> formitem , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; } } break ; } copyBuffer ( buf , & save ) ; arrangeLine ( buf ) ; }",if ( l == NULL ) break ;,1598
562,"buggy line: if ( rows > 1 ) {pos = columnPos ( l , col ) ;cwe id:CWE-476context: void formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : # ifdef MENU_SELECT case FORM_SELECT : # endif spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : if ( buf -> currentLine == NULL || spos >= buf -> currentLine -> len || spos < 0 ) break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = '<S2SV_blank>' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : # ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else # endif { if ( ! form -> value ) break ; p = form -> value -> ptr ; } l = buf -> currentLine ; if ( ! l ) break ; if ( form -> type == FORM_TEXTAREA ) { int n = a -> y - buf -> currentLine -> linenumber ; if ( n > 0 ) for ( ; l && n ; l = l -> prev , n -- ) ; else if ( n < 0 ) for ( ; l && n ; l = l -> prev , n ++ ) ; if ( ! l ) break ; } rows = form -> rows ? form -> rows : 1 ; col = COLPOS ( l , a -> start . pos ) ; for ( c_rows = 0 ; c_rows < rows ; c_rows ++ , l = l -> next ) {  if ( rows > 1 ) {  pos = columnPos ( l , col ) ; a = retrieveAnchor ( buf -> formitem , l -> linenumber , pos ) ; if ( a == NULL ) break ; spos = a -> start . pos ; epos = a -> end . pos ; } if ( a -> start . line != a -> end . line || spos > epos || epos >= l -> len || spos < 0 || epos < 0 || COLPOS ( l , epos ) < col ) break ; pos = form_update_line ( l , & p , spos , epos , COLPOS ( l , epos ) - col , rows > 1 , form -> type == FORM_INPUT_PASSWORD ) ; if ( pos != epos ) { shiftAnchorPosition ( buf -> href , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> name , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> img , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> formitem , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; } } break ; } copyBuffer ( buf , & save ) ; arrangeLine ( buf ) ; }","if ( rows > 1 ) {pos = columnPos ( l , col ) ;",1598
563,"buggy line: if ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) {if ( xWantedSize > 0 )  {xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;}mtCOVERAGE_TEST_MARKER ( ) ;cwe id:CWE-119context: void * pvPortMalloc ( size_t xWantedSize ) { BlockLink_t * pxBlock , * pxPreviousBlock , * pxNewBlockLink ; void * pvReturn = NULL ; configASSERT ( pxEnd ) ; vTaskSuspendAll ( ) ; { if ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) {  if ( xWantedSize > 0 )  { xWantedSize += xHeapStructSize ; if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 ) {  xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;  } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) ) { pxPreviousBlock = & xStart ; pxBlock = xStart . pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock != NULL ) ) { pxPreviousBlock = pxBlock ; pxBlock = pxBlock -> pxNextFreeBlock ; } if ( pxBlock != pxEnd ) { pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock -> pxNextFreeBlock ) + xHeapStructSize ) ; pxPreviousBlock -> pxNextFreeBlock = pxBlock -> pxNextFreeBlock ; if ( ( pxBlock -> xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; pxNewBlockLink -> xBlockSize = pxBlock -> xBlockSize - xWantedSize ; pxBlock -> xBlockSize = xWantedSize ; prvInsertBlockIntoFreeList ( ( pxNewBlockLink ) ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } xFreeBytesRemaining -= pxBlock -> xBlockSize ; if ( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining ) { xMinimumEverFreeBytesRemaining = xFreeBytesRemaining ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } pxBlock -> xBlockSize |= xBlockAllocatedBit ; pxBlock -> pxNextFreeBlock = NULL ; xNumberOfSuccessfulAllocations ++ ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } traceMALLOC ( pvReturn , xWantedSize ) ; } ( void ) xTaskResumeAll ( ) ; # if ( configUSE_MALLOC_FAILED_HOOK == 1 ) { if ( pvReturn == NULL ) { extern void vApplicationMallocFailedHook ( void ) ; vApplicationMallocFailedHook ( ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } # endif return pvReturn ; }",if ( ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) {if ( xWantedSize > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) ) {if ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) {xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;}xWantedSize = 0 ;}else {xWantedSize = 0 ;},1599
564,"buggy line: void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest ,  int stride , int eob ) {cwe id:CWE-119context:  void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest ,  int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct8x8_add ( input , dest , stride , eob ) ; } else { vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ; } }","void vp9_iht8x8_add ( TX_TYPE tx_type , const tran_low_t * input , uint8_t * dest , int stride , int eob ) {",1600
565,"buggy line: perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;cwe id:CWE-400context: static int misaligned_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; }  perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;  srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } switch ( width_shift ) { case 1 : * ( __u16 * ) & buffer = ( __u16 ) regs -> regs [ srcreg ] ; break ; case 2 : * ( __u32 * ) & buffer = ( __u32 ) regs -> regs [ srcreg ] ; break ; case 3 : buffer = regs -> regs [ srcreg ] ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_store,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } } else { __u64 val = regs -> regs [ srcreg ] ; switch ( width_shift ) { case 1 : misaligned_kernel_word_store ( address , val ) ; break ; case 2 : asm ( ""stlo.l<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; asm ( ""sthi.l<S2SV_blank>%1,<S2SV_blank>3,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; break ; case 3 : asm ( ""stlo.q<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; asm ( ""sthi.q<S2SV_blank>%1,<S2SV_blank>7,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_store,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;",1601
566,"buggy line: static void  fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( bps * stride ) ) == 0 ) ;if ( ! tmp )  return ;_TIFFmemcpy ( tmp , cp0 , cc ) ;cwe id:CWE-119context:  static void  fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;  assert ( ( cc % ( bps * stride ) ) == 0 ) ;  if ( ! tmp )  return ;  _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- )  } ","static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( bps * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ;return 0 ;}if ( ! tmp ) return 0 ;_TIFFmemcpy ( tmp , cp0 , cc ) ;",1602
567,"buggy line: cp -- )  }cwe id:CWE-119context:  static void  fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;  assert ( ( cc % ( bps * stride ) ) == 0 ) ;  if ( ! tmp )  return ;  _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- )  } ",cp -- ) return 1 ;},1602
568,"buggy line: uint16 num_updates ;uint16 left , top , right , bottom , width , height ;uint16 cx , cy , bpp , Bpp , compress , bufsize , size ;uint8 * data , * bmpdata ;logger ( Protocol , Debug , ""%s()"" , __func__ ) ;in_uint16_le ( s , num_updates ) ;in_uint16_le ( s , left ) ;in_uint16_le ( s , top ) ;cwe id:CWE-787context: void process_bitmap_updates ( STREAM s ) {  uint16 num_updates ;  uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , Bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ;  logger ( Protocol , Debug , ""%s()"" , __func__ ) ;  in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) {  in_uint16_le ( s , left ) ;  in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; Bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( Graphics , Debug , ""process_bitmap_updates(),<S2SV_blank>[%d,%d,%d,%d],<S2SV_blank>[%d,%d],<S2SV_blank>bpp=%d,<S2SV_blank>compression=%d"" , left , top , right , bottom , width , height , Bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width * Bpp ) ; } ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; xfree ( bmpdata ) ; continue ; } if ( compress & 0x400 ) { size = bufsize ; } else { in_uint8s ( s , 2 ) ; in_uint16_le ( s , size ) ; in_uint8s ( s , 4 ) ; } in_uint8p ( s , data , size ) ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; if ( bitmap_decompress ( bmpdata , width , height , data , size , Bpp ) ) { ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; } else { logger ( Graphics , Warning , ""process_bitmap_updates(),<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>bitmap"" ) ; } xfree ( bmpdata ) ; } }","logger ( Protocol , Debug , ""%s()"" , __func__ ) ;in_uint16_le ( s , num_updates ) ;in_uint16_le ( s , left ) ;in_uint16_le ( s , top ) ;",1603
569,"buggy line: in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width * Bpp ) ;cwe id:CWE-787context: void process_bitmap_updates ( STREAM s ) {  uint16 num_updates ;  uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , Bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ;  logger ( Protocol , Debug , ""%s()"" , __func__ ) ;  in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) {  in_uint16_le ( s , left ) ;  in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; Bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( Graphics , Debug , ""process_bitmap_updates(),<S2SV_blank>[%d,%d,%d,%d],<S2SV_blank>[%d,%d],<S2SV_blank>bpp=%d,<S2SV_blank>compression=%d"" , left , top , right , bottom , width , height , Bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width * Bpp ) ; } ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; xfree ( bmpdata ) ; continue ; } if ( compress & 0x400 ) { size = bufsize ; } else { in_uint8s ( s , 2 ) ; in_uint16_le ( s , size ) ; in_uint8s ( s , 4 ) ; } in_uint8p ( s , data , size ) ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; if ( bitmap_decompress ( bmpdata , width , height , data , size , Bpp ) ) { ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; } else { logger ( Graphics , Warning , ""process_bitmap_updates(),<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>bitmap"" ) ; } xfree ( bmpdata ) ; } }",process_bitmap_data ( s ) ;,1603
570,"buggy line: if ( error ) return error ;cwe id:CWE-400context: int xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) { attrlist_cursor_kern_t * cursor ; xfs_attr_sf_sort_t * sbuf , * sbp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_inode_t * dp ; int sbsize , nsbuf , count , i ; int error ; ASSERT ( context != NULL ) ; dp = context -> dp ; ASSERT ( dp != NULL ) ; ASSERT ( dp -> i_afp != NULL ) ; sf = ( xfs_attr_shortform_t * ) dp -> i_afp -> if_u1 . if_data ; ASSERT ( sf != NULL ) ; if ( ! sf -> hdr . count ) return 0 ; cursor = context -> cursor ; ASSERT ( cursor != NULL ) ; trace_xfs_attr_list_sf ( context ) ; if ( context -> bufsize == 0 || ( XFS_ISRESET_CURSOR ( cursor ) && ( dp -> i_afp -> if_bytes + sf -> hdr . count * 16 ) < context -> bufsize ) ) { for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { error = context -> put_listent ( context , sfe -> flags , sfe -> nameval , ( int ) sfe -> namelen , ( int ) sfe -> valuelen , & sfe -> nameval [ sfe -> namelen ] ) ; if ( context -> seen_enough ) break ; if ( error ) return error ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } trace_xfs_attr_list_sf_all ( context ) ; return 0 ; } if ( context -> bufsize == 0 ) return 0 ; sbsize = sf -> hdr . count * sizeof ( * sbuf ) ; sbp = sbuf = kmem_alloc ( sbsize , KM_SLEEP | KM_NOFS ) ; nsbuf = 0 ; for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { if ( unlikely ( ( ( char * ) sfe < ( char * ) sf ) || ( ( char * ) sfe >= ( ( char * ) sf + dp -> i_afp -> if_bytes ) ) ) ) { XFS_CORRUPTION_ERROR ( ""xfs_attr_shortform_list"" , XFS_ERRLEVEL_LOW , context -> dp -> i_mount , sfe ) ; kmem_free ( sbuf ) ; return - EFSCORRUPTED ; } sbp -> entno = i ; sbp -> hash = xfs_da_hashname ( sfe -> nameval , sfe -> namelen ) ; sbp -> name = sfe -> nameval ; sbp -> namelen = sfe -> namelen ; sbp -> valuelen = sfe -> valuelen ; sbp -> flags = sfe -> flags ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; sbp ++ ; nsbuf ++ ; } xfs_sort ( sbuf , nsbuf , sizeof ( * sbuf ) , xfs_attr_shortform_compare ) ; count = 0 ; cursor -> initted = 1 ; cursor -> blkno = 0 ; for ( sbp = sbuf , i = 0 ; i < nsbuf ; i ++ , sbp ++ ) { if ( sbp -> hash == cursor -> hashval ) { if ( cursor -> offset == count ) { break ; } count ++ ; } else if ( sbp -> hash > cursor -> hashval ) { break ; } } if ( i == nsbuf ) { kmem_free ( sbuf ) ; return 0 ; } for ( ; i < nsbuf ; i ++ , sbp ++ ) { if ( cursor -> hashval != sbp -> hash ) { cursor -> hashval = sbp -> hash ; cursor -> offset = 0 ; } error = context -> put_listent ( context , sbp -> flags , sbp -> name , sbp -> namelen , sbp -> valuelen , & sbp -> name [ sbp -> namelen ] ) ;  if ( error )  return error ;  if ( context -> seen_enough )  break ; cursor -> offset ++ ; } kmem_free ( sbuf ) ; return 0 ; }",if ( error ) {kmem_free ( sbuf ) ;return error ;},1604
571,"buggy line: if ( error )  return error ;if ( context -> seen_enough )  break ;cwe id:CWE-400context: int xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) { attrlist_cursor_kern_t * cursor ; xfs_attr_sf_sort_t * sbuf , * sbp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_inode_t * dp ; int sbsize , nsbuf , count , i ; int error ; ASSERT ( context != NULL ) ; dp = context -> dp ; ASSERT ( dp != NULL ) ; ASSERT ( dp -> i_afp != NULL ) ; sf = ( xfs_attr_shortform_t * ) dp -> i_afp -> if_u1 . if_data ; ASSERT ( sf != NULL ) ; if ( ! sf -> hdr . count ) return 0 ; cursor = context -> cursor ; ASSERT ( cursor != NULL ) ; trace_xfs_attr_list_sf ( context ) ; if ( context -> bufsize == 0 || ( XFS_ISRESET_CURSOR ( cursor ) && ( dp -> i_afp -> if_bytes + sf -> hdr . count * 16 ) < context -> bufsize ) ) { for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { error = context -> put_listent ( context , sfe -> flags , sfe -> nameval , ( int ) sfe -> namelen , ( int ) sfe -> valuelen , & sfe -> nameval [ sfe -> namelen ] ) ; if ( context -> seen_enough ) break ; if ( error ) return error ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } trace_xfs_attr_list_sf_all ( context ) ; return 0 ; } if ( context -> bufsize == 0 ) return 0 ; sbsize = sf -> hdr . count * sizeof ( * sbuf ) ; sbp = sbuf = kmem_alloc ( sbsize , KM_SLEEP | KM_NOFS ) ; nsbuf = 0 ; for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { if ( unlikely ( ( ( char * ) sfe < ( char * ) sf ) || ( ( char * ) sfe >= ( ( char * ) sf + dp -> i_afp -> if_bytes ) ) ) ) { XFS_CORRUPTION_ERROR ( ""xfs_attr_shortform_list"" , XFS_ERRLEVEL_LOW , context -> dp -> i_mount , sfe ) ; kmem_free ( sbuf ) ; return - EFSCORRUPTED ; } sbp -> entno = i ; sbp -> hash = xfs_da_hashname ( sfe -> nameval , sfe -> namelen ) ; sbp -> name = sfe -> nameval ; sbp -> namelen = sfe -> namelen ; sbp -> valuelen = sfe -> valuelen ; sbp -> flags = sfe -> flags ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; sbp ++ ; nsbuf ++ ; } xfs_sort ( sbuf , nsbuf , sizeof ( * sbuf ) , xfs_attr_shortform_compare ) ; count = 0 ; cursor -> initted = 1 ; cursor -> blkno = 0 ; for ( sbp = sbuf , i = 0 ; i < nsbuf ; i ++ , sbp ++ ) { if ( sbp -> hash == cursor -> hashval ) { if ( cursor -> offset == count ) { break ; } count ++ ; } else if ( sbp -> hash > cursor -> hashval ) { break ; } } if ( i == nsbuf ) { kmem_free ( sbuf ) ; return 0 ; } for ( ; i < nsbuf ; i ++ , sbp ++ ) { if ( cursor -> hashval != sbp -> hash ) { cursor -> hashval = sbp -> hash ; cursor -> offset = 0 ; } error = context -> put_listent ( context , sbp -> flags , sbp -> name , sbp -> namelen , sbp -> valuelen , & sbp -> name [ sbp -> namelen ] ) ;  if ( error )  return error ;  if ( context -> seen_enough )  break ; cursor -> offset ++ ; } kmem_free ( sbuf ) ; return 0 ; }",if ( error ) return error ;if ( context -> seen_enough ) break ;,1604
572,"buggy line: if ( length < sizeof ( struct olsr_common ) ) {goto trunc ;}ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ;ptr . common = ( const struct olsr_common * ) tptr ;length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ;ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ;tptr += sizeof ( struct olsr_common ) ;if ( ndo -> ndo_vflag < 1 ) {return ;}while ( tptr < ( pptr + length ) ) {union {const struct olsr_msg4 * v4 ;const struct olsr_msg6 * v6 ;}msgptr ;int msg_len_valid = 0 ;ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;if ( is_ipv6 ) {cwe id:CWE-125context: void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ;  ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;  if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; msg_type = msgptr . v6 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg6 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ip6addr_string ( ndo , msgptr . v6 -> originator ) , msgptr . v6 -> ttl , msgptr . v6 -> hopcount , ME_TO_DOUBLE ( msgptr . v6 -> vtime ) , EXTRACT_16BITS ( msgptr . v6 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg6 ) ; msg_data = tptr + sizeof ( struct olsr_msg6 ) ; } else  {  msgptr . v4 = ( const struct olsr_msg4 * ) tptr ; msg_type = msgptr . v4 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v4 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg4 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ipaddr_string ( ndo , msgptr . v4 -> originator ) , msgptr . v4 -> ttl , msgptr . v4 -> hopcount , ME_TO_DOUBLE ( msgptr . v4 -> vtime ) , EXTRACT_16BITS ( msgptr . v4 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg4 ) ; msg_data = tptr + sizeof ( struct olsr_msg4 ) ; } switch ( msg_type ) { case OLSR_HELLO_MSG : case OLSR_HELLO_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_hello ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello ) ) ; ptr . hello = ( const struct olsr_hello * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>hello-time<S2SV_blank>%.3fs,<S2SV_blank>MPR<S2SV_blank>willingness<S2SV_blank>%u"" , ME_TO_DOUBLE ( ptr . hello -> htime ) , ptr . hello -> will ) ) ; msg_data += sizeof ( struct olsr_hello ) ; msg_tlen -= sizeof ( struct olsr_hello ) ; while ( msg_tlen >= sizeof ( struct olsr_hello_link ) ) { int hello_len_valid = 0 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello_link ) ) ; ptr . hello_link = ( const struct olsr_hello_link * ) msg_data ; hello_len = EXTRACT_16BITS ( ptr . hello_link -> len ) ; link_type = OLSR_EXTRACT_LINK_TYPE ( ptr . hello_link -> link_code ) ; neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE ( ptr . hello_link -> link_code ) ; if ( ( hello_len <= msg_tlen ) && ( hello_len >= sizeof ( struct olsr_hello_link ) ) ) hello_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>link-type<S2SV_blank>%s,<S2SV_blank>neighbor-type<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%u%s"" , tok2str ( olsr_link_type_values , ""Unknown"" , link_type ) , tok2str ( olsr_neighbor_type_values , ""Unknown"" , neighbor_type ) , hello_len , ( hello_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( hello_len_valid == 0 ) break ; msg_data += sizeof ( struct olsr_hello_link ) ; msg_tlen -= sizeof ( struct olsr_hello_link ) ; hello_len -= sizeof ( struct olsr_hello_link ) ; ND_TCHECK2 ( * msg_data , hello_len ) ; if ( msg_type == OLSR_HELLO_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } } msg_data += hello_len ; msg_tlen -= hello_len ; } break ; case OLSR_TC_MSG : case OLSR_TC_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_tc ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_tc ) ) ; ptr . tc = ( const struct olsr_tc * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>advertised<S2SV_blank>neighbor<S2SV_blank>seq<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( ptr . tc -> ans_seq ) ) ) ; msg_data += sizeof ( struct olsr_tc ) ; msg_tlen -= sizeof ( struct olsr_tc ) ; if ( msg_type == OLSR_TC_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } } break ; case OLSR_MID_MSG : { size_t addr_size = sizeof ( struct in_addr ) ; if ( is_ipv6 ) addr_size = sizeof ( struct in6_addr ) ; while ( msg_tlen >= addr_size ) { ND_TCHECK2 ( * msg_data , addr_size ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>interface<S2SV_blank>address<S2SV_blank>%s"" , is_ipv6 ? ip6addr_string ( ndo , msg_data ) : ipaddr_string ( ndo , msg_data ) ) ) ; msg_data += addr_size ; msg_tlen -= addr_size ; } break ; } case OLSR_HNA_MSG : if ( is_ipv6 ) { int i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna6 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna6 ) ) { const struct olsr_hna6 * hna6 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna6 ) ) ; hna6 = ( const struct olsr_hna6 * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%i:<S2SV_blank>%s/%u"" , i , ip6addr_string ( ndo , hna6 -> network ) , mask62plen ( hna6 -> mask ) ) ) ; msg_data += sizeof ( struct olsr_hna6 ) ; msg_tlen -= sizeof ( struct olsr_hna6 ) ; } } else { int col = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna4 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna4 ) ) { ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna4 ) ) ; ptr . hna = ( const struct olsr_hna4 * ) msg_data ; if ( ! ptr . hna -> network [ 0 ] && ! ptr . hna -> network [ 1 ] && ! ptr . hna -> network [ 2 ] && ! ptr . hna -> network [ 3 ] && ! ptr . hna -> mask [ GW_HNA_PAD ] && ptr . hna -> mask [ GW_HNA_FLAGS ] ) { ND_PRINT ( ( ndo , ""%sSmart-Gateway:%s%s%s%s%s<S2SV_blank>%u/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? ""<S2SV_blank>LINKSPEED"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4 ) ? ""<S2SV_blank>IPV4"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4_NAT ) ? ""<S2SV_blank>IPV4-NAT"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6 ) ? ""<S2SV_blank>IPV6"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6PREFIX ) ? ""<S2SV_blank>IPv6-PREFIX"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_UPLINK ] ) : 0 , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_DOWNLINK ] ) : 0 ) ) ; } else { ND_PRINT ( ( ndo , ""%s%s/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ipaddr_string ( ndo , ptr . hna -> network ) , mask2plen ( EXTRACT_32BITS ( ptr . hna -> mask ) ) ) ) ; } msg_data += sizeof ( struct olsr_hna4 ) ; msg_tlen -= sizeof ( struct olsr_hna4 ) ; col = ( col + 1 ) % 4 ; } } break ; case OLSR_NAMESERVICE_MSG : {  u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;   u_int addr_size = 4 ;   int name_entries_valid = 0 ;  u_int i ; if ( is_ipv6 ) addr_size = 16 ; if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) )  name_entries_valid = 1 ;  if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s"" , EXTRACT_16BITS ( msg_data ) , name_entries , ( name_entries_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entries_valid == 0 ) break ; msg_data += 4 ; msg_tlen -= 4 ; for ( i = 0 ; i < name_entries ; i ++ ) { int name_entry_len_valid = 0 ; if ( msg_tlen < 4 ) break ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entry_type = EXTRACT_16BITS ( msg_data ) ; name_entry_len = EXTRACT_16BITS ( msg_data + 2 ) ; msg_data += 4 ; msg_tlen -= 4 ; if ( ( name_entry_len > 0 ) && ( ( addr_size + name_entry_len ) <= msg_tlen ) ) name_entry_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%u:<S2SV_blank>type<S2SV_blank>%#06x,<S2SV_blank>length<S2SV_blank>%u%s"" , ( unsigned int ) i , name_entry_type , name_entry_len , ( name_entry_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entry_len_valid == 0 ) break ; name_entry_padding = 0 ; if ( name_entry_len % 4 != 0 ) name_entry_padding = 4 - ( name_entry_len % 4 ) ; if ( msg_tlen < addr_size + name_entry_len + name_entry_padding ) goto trunc ; ND_TCHECK2 ( * msg_data , addr_size + name_entry_len + name_entry_padding ) ; if ( is_ipv6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ip6addr_string ( ndo , msg_data ) ) ) ; else ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ipaddr_string ( ndo , msg_data ) ) ) ; ( void ) fn_printn ( ndo , msg_data + addr_size , name_entry_len , NULL ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; msg_data += addr_size + name_entry_len + name_entry_padding ; msg_tlen -= addr_size + name_entry_len + name_entry_padding ; } break ; } case OLSR_POWERINFO_MSG : default : print_unknown_data ( ndo , msg_data , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } tptr += msg_len ; } return ; trunc : ND_PRINT ( ( ndo , ""[|olsr]"" ) ) ; }",if ( length < sizeof ( struct olsr_msg6 ) ) ;,1605
573,"buggy line: else  {msgptr . v4 = ( const struct olsr_msg4 * ) tptr ;cwe id:CWE-125context: void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ;  ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;  if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; msg_type = msgptr . v6 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg6 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ip6addr_string ( ndo , msgptr . v6 -> originator ) , msgptr . v6 -> ttl , msgptr . v6 -> hopcount , ME_TO_DOUBLE ( msgptr . v6 -> vtime ) , EXTRACT_16BITS ( msgptr . v6 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg6 ) ; msg_data = tptr + sizeof ( struct olsr_msg6 ) ; } else  {  msgptr . v4 = ( const struct olsr_msg4 * ) tptr ; msg_type = msgptr . v4 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v4 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg4 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ipaddr_string ( ndo , msgptr . v4 -> originator ) , msgptr . v4 -> ttl , msgptr . v4 -> hopcount , ME_TO_DOUBLE ( msgptr . v4 -> vtime ) , EXTRACT_16BITS ( msgptr . v4 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg4 ) ; msg_data = tptr + sizeof ( struct olsr_msg4 ) ; } switch ( msg_type ) { case OLSR_HELLO_MSG : case OLSR_HELLO_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_hello ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello ) ) ; ptr . hello = ( const struct olsr_hello * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>hello-time<S2SV_blank>%.3fs,<S2SV_blank>MPR<S2SV_blank>willingness<S2SV_blank>%u"" , ME_TO_DOUBLE ( ptr . hello -> htime ) , ptr . hello -> will ) ) ; msg_data += sizeof ( struct olsr_hello ) ; msg_tlen -= sizeof ( struct olsr_hello ) ; while ( msg_tlen >= sizeof ( struct olsr_hello_link ) ) { int hello_len_valid = 0 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello_link ) ) ; ptr . hello_link = ( const struct olsr_hello_link * ) msg_data ; hello_len = EXTRACT_16BITS ( ptr . hello_link -> len ) ; link_type = OLSR_EXTRACT_LINK_TYPE ( ptr . hello_link -> link_code ) ; neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE ( ptr . hello_link -> link_code ) ; if ( ( hello_len <= msg_tlen ) && ( hello_len >= sizeof ( struct olsr_hello_link ) ) ) hello_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>link-type<S2SV_blank>%s,<S2SV_blank>neighbor-type<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%u%s"" , tok2str ( olsr_link_type_values , ""Unknown"" , link_type ) , tok2str ( olsr_neighbor_type_values , ""Unknown"" , neighbor_type ) , hello_len , ( hello_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( hello_len_valid == 0 ) break ; msg_data += sizeof ( struct olsr_hello_link ) ; msg_tlen -= sizeof ( struct olsr_hello_link ) ; hello_len -= sizeof ( struct olsr_hello_link ) ; ND_TCHECK2 ( * msg_data , hello_len ) ; if ( msg_type == OLSR_HELLO_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } } msg_data += hello_len ; msg_tlen -= hello_len ; } break ; case OLSR_TC_MSG : case OLSR_TC_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_tc ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_tc ) ) ; ptr . tc = ( const struct olsr_tc * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>advertised<S2SV_blank>neighbor<S2SV_blank>seq<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( ptr . tc -> ans_seq ) ) ) ; msg_data += sizeof ( struct olsr_tc ) ; msg_tlen -= sizeof ( struct olsr_tc ) ; if ( msg_type == OLSR_TC_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } } break ; case OLSR_MID_MSG : { size_t addr_size = sizeof ( struct in_addr ) ; if ( is_ipv6 ) addr_size = sizeof ( struct in6_addr ) ; while ( msg_tlen >= addr_size ) { ND_TCHECK2 ( * msg_data , addr_size ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>interface<S2SV_blank>address<S2SV_blank>%s"" , is_ipv6 ? ip6addr_string ( ndo , msg_data ) : ipaddr_string ( ndo , msg_data ) ) ) ; msg_data += addr_size ; msg_tlen -= addr_size ; } break ; } case OLSR_HNA_MSG : if ( is_ipv6 ) { int i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna6 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna6 ) ) { const struct olsr_hna6 * hna6 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna6 ) ) ; hna6 = ( const struct olsr_hna6 * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%i:<S2SV_blank>%s/%u"" , i , ip6addr_string ( ndo , hna6 -> network ) , mask62plen ( hna6 -> mask ) ) ) ; msg_data += sizeof ( struct olsr_hna6 ) ; msg_tlen -= sizeof ( struct olsr_hna6 ) ; } } else { int col = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna4 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna4 ) ) { ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna4 ) ) ; ptr . hna = ( const struct olsr_hna4 * ) msg_data ; if ( ! ptr . hna -> network [ 0 ] && ! ptr . hna -> network [ 1 ] && ! ptr . hna -> network [ 2 ] && ! ptr . hna -> network [ 3 ] && ! ptr . hna -> mask [ GW_HNA_PAD ] && ptr . hna -> mask [ GW_HNA_FLAGS ] ) { ND_PRINT ( ( ndo , ""%sSmart-Gateway:%s%s%s%s%s<S2SV_blank>%u/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? ""<S2SV_blank>LINKSPEED"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4 ) ? ""<S2SV_blank>IPV4"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4_NAT ) ? ""<S2SV_blank>IPV4-NAT"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6 ) ? ""<S2SV_blank>IPV6"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6PREFIX ) ? ""<S2SV_blank>IPv6-PREFIX"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_UPLINK ] ) : 0 , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_DOWNLINK ] ) : 0 ) ) ; } else { ND_PRINT ( ( ndo , ""%s%s/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ipaddr_string ( ndo , ptr . hna -> network ) , mask2plen ( EXTRACT_32BITS ( ptr . hna -> mask ) ) ) ) ; } msg_data += sizeof ( struct olsr_hna4 ) ; msg_tlen -= sizeof ( struct olsr_hna4 ) ; col = ( col + 1 ) % 4 ; } } break ; case OLSR_NAMESERVICE_MSG : {  u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;   u_int addr_size = 4 ;   int name_entries_valid = 0 ;  u_int i ; if ( is_ipv6 ) addr_size = 16 ; if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) )  name_entries_valid = 1 ;  if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s"" , EXTRACT_16BITS ( msg_data ) , name_entries , ( name_entries_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entries_valid == 0 ) break ; msg_data += 4 ; msg_tlen -= 4 ; for ( i = 0 ; i < name_entries ; i ++ ) { int name_entry_len_valid = 0 ; if ( msg_tlen < 4 ) break ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entry_type = EXTRACT_16BITS ( msg_data ) ; name_entry_len = EXTRACT_16BITS ( msg_data + 2 ) ; msg_data += 4 ; msg_tlen -= 4 ; if ( ( name_entry_len > 0 ) && ( ( addr_size + name_entry_len ) <= msg_tlen ) ) name_entry_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%u:<S2SV_blank>type<S2SV_blank>%#06x,<S2SV_blank>length<S2SV_blank>%u%s"" , ( unsigned int ) i , name_entry_type , name_entry_len , ( name_entry_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entry_len_valid == 0 ) break ; name_entry_padding = 0 ; if ( name_entry_len % 4 != 0 ) name_entry_padding = 4 - ( name_entry_len % 4 ) ; if ( msg_tlen < addr_size + name_entry_len + name_entry_padding ) goto trunc ; ND_TCHECK2 ( * msg_data , addr_size + name_entry_len + name_entry_padding ) ; if ( is_ipv6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ip6addr_string ( ndo , msg_data ) ) ) ; else ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ipaddr_string ( ndo , msg_data ) ) ) ; ( void ) fn_printn ( ndo , msg_data + addr_size , name_entry_len , NULL ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; msg_data += addr_size + name_entry_len + name_entry_padding ; msg_tlen -= addr_size + name_entry_len + name_entry_padding ; } break ; } case OLSR_POWERINFO_MSG : default : print_unknown_data ( ndo , msg_data , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } tptr += msg_len ; } return ; trunc : ND_PRINT ( ( ndo , ""[|olsr]"" ) ) ; }","else {ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;msgptr . v4 = ( const struct olsr_msg4 * ) tptr ;",1605
574,"buggy line: u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;u_int addr_size = 4 ;int name_entries_valid = 0 ;u_int i ;if ( is_ipv6 ) addr_size = 16 ;if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) )  name_entries_valid = 1 ;if ( msg_tlen < 4 ) goto trunc ;cwe id:CWE-125context: void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ;  ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;  if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; msg_type = msgptr . v6 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg6 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ip6addr_string ( ndo , msgptr . v6 -> originator ) , msgptr . v6 -> ttl , msgptr . v6 -> hopcount , ME_TO_DOUBLE ( msgptr . v6 -> vtime ) , EXTRACT_16BITS ( msgptr . v6 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg6 ) ; msg_data = tptr + sizeof ( struct olsr_msg6 ) ; } else  {  msgptr . v4 = ( const struct olsr_msg4 * ) tptr ; msg_type = msgptr . v4 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v4 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg4 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ipaddr_string ( ndo , msgptr . v4 -> originator ) , msgptr . v4 -> ttl , msgptr . v4 -> hopcount , ME_TO_DOUBLE ( msgptr . v4 -> vtime ) , EXTRACT_16BITS ( msgptr . v4 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg4 ) ; msg_data = tptr + sizeof ( struct olsr_msg4 ) ; } switch ( msg_type ) { case OLSR_HELLO_MSG : case OLSR_HELLO_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_hello ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello ) ) ; ptr . hello = ( const struct olsr_hello * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>hello-time<S2SV_blank>%.3fs,<S2SV_blank>MPR<S2SV_blank>willingness<S2SV_blank>%u"" , ME_TO_DOUBLE ( ptr . hello -> htime ) , ptr . hello -> will ) ) ; msg_data += sizeof ( struct olsr_hello ) ; msg_tlen -= sizeof ( struct olsr_hello ) ; while ( msg_tlen >= sizeof ( struct olsr_hello_link ) ) { int hello_len_valid = 0 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello_link ) ) ; ptr . hello_link = ( const struct olsr_hello_link * ) msg_data ; hello_len = EXTRACT_16BITS ( ptr . hello_link -> len ) ; link_type = OLSR_EXTRACT_LINK_TYPE ( ptr . hello_link -> link_code ) ; neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE ( ptr . hello_link -> link_code ) ; if ( ( hello_len <= msg_tlen ) && ( hello_len >= sizeof ( struct olsr_hello_link ) ) ) hello_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>link-type<S2SV_blank>%s,<S2SV_blank>neighbor-type<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%u%s"" , tok2str ( olsr_link_type_values , ""Unknown"" , link_type ) , tok2str ( olsr_neighbor_type_values , ""Unknown"" , neighbor_type ) , hello_len , ( hello_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( hello_len_valid == 0 ) break ; msg_data += sizeof ( struct olsr_hello_link ) ; msg_tlen -= sizeof ( struct olsr_hello_link ) ; hello_len -= sizeof ( struct olsr_hello_link ) ; ND_TCHECK2 ( * msg_data , hello_len ) ; if ( msg_type == OLSR_HELLO_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } } msg_data += hello_len ; msg_tlen -= hello_len ; } break ; case OLSR_TC_MSG : case OLSR_TC_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_tc ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_tc ) ) ; ptr . tc = ( const struct olsr_tc * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>advertised<S2SV_blank>neighbor<S2SV_blank>seq<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( ptr . tc -> ans_seq ) ) ) ; msg_data += sizeof ( struct olsr_tc ) ; msg_tlen -= sizeof ( struct olsr_tc ) ; if ( msg_type == OLSR_TC_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } } break ; case OLSR_MID_MSG : { size_t addr_size = sizeof ( struct in_addr ) ; if ( is_ipv6 ) addr_size = sizeof ( struct in6_addr ) ; while ( msg_tlen >= addr_size ) { ND_TCHECK2 ( * msg_data , addr_size ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>interface<S2SV_blank>address<S2SV_blank>%s"" , is_ipv6 ? ip6addr_string ( ndo , msg_data ) : ipaddr_string ( ndo , msg_data ) ) ) ; msg_data += addr_size ; msg_tlen -= addr_size ; } break ; } case OLSR_HNA_MSG : if ( is_ipv6 ) { int i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna6 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna6 ) ) { const struct olsr_hna6 * hna6 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna6 ) ) ; hna6 = ( const struct olsr_hna6 * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%i:<S2SV_blank>%s/%u"" , i , ip6addr_string ( ndo , hna6 -> network ) , mask62plen ( hna6 -> mask ) ) ) ; msg_data += sizeof ( struct olsr_hna6 ) ; msg_tlen -= sizeof ( struct olsr_hna6 ) ; } } else { int col = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna4 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna4 ) ) { ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna4 ) ) ; ptr . hna = ( const struct olsr_hna4 * ) msg_data ; if ( ! ptr . hna -> network [ 0 ] && ! ptr . hna -> network [ 1 ] && ! ptr . hna -> network [ 2 ] && ! ptr . hna -> network [ 3 ] && ! ptr . hna -> mask [ GW_HNA_PAD ] && ptr . hna -> mask [ GW_HNA_FLAGS ] ) { ND_PRINT ( ( ndo , ""%sSmart-Gateway:%s%s%s%s%s<S2SV_blank>%u/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? ""<S2SV_blank>LINKSPEED"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4 ) ? ""<S2SV_blank>IPV4"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4_NAT ) ? ""<S2SV_blank>IPV4-NAT"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6 ) ? ""<S2SV_blank>IPV6"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6PREFIX ) ? ""<S2SV_blank>IPv6-PREFIX"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_UPLINK ] ) : 0 , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_DOWNLINK ] ) : 0 ) ) ; } else { ND_PRINT ( ( ndo , ""%s%s/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ipaddr_string ( ndo , ptr . hna -> network ) , mask2plen ( EXTRACT_32BITS ( ptr . hna -> mask ) ) ) ) ; } msg_data += sizeof ( struct olsr_hna4 ) ; msg_tlen -= sizeof ( struct olsr_hna4 ) ; col = ( col + 1 ) % 4 ; } } break ; case OLSR_NAMESERVICE_MSG : {  u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;   u_int addr_size = 4 ;   int name_entries_valid = 0 ;  u_int i ; if ( is_ipv6 ) addr_size = 16 ; if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) )  name_entries_valid = 1 ;  if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s"" , EXTRACT_16BITS ( msg_data ) , name_entries , ( name_entries_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entries_valid == 0 ) break ; msg_data += 4 ; msg_tlen -= 4 ; for ( i = 0 ; i < name_entries ; i ++ ) { int name_entry_len_valid = 0 ; if ( msg_tlen < 4 ) break ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entry_type = EXTRACT_16BITS ( msg_data ) ; name_entry_len = EXTRACT_16BITS ( msg_data + 2 ) ; msg_data += 4 ; msg_tlen -= 4 ; if ( ( name_entry_len > 0 ) && ( ( addr_size + name_entry_len ) <= msg_tlen ) ) name_entry_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%u:<S2SV_blank>type<S2SV_blank>%#06x,<S2SV_blank>length<S2SV_blank>%u%s"" , ( unsigned int ) i , name_entry_type , name_entry_len , ( name_entry_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entry_len_valid == 0 ) break ; name_entry_padding = 0 ; if ( name_entry_len % 4 != 0 ) name_entry_padding = 4 - ( name_entry_len % 4 ) ; if ( msg_tlen < addr_size + name_entry_len + name_entry_padding ) goto trunc ; ND_TCHECK2 ( * msg_data , addr_size + name_entry_len + name_entry_padding ) ; if ( is_ipv6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ip6addr_string ( ndo , msg_data ) ) ) ; else ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ipaddr_string ( ndo , msg_data ) ) ) ; ( void ) fn_printn ( ndo , msg_data + addr_size , name_entry_len , NULL ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; msg_data += addr_size + name_entry_len + name_entry_padding ; msg_tlen -= addr_size + name_entry_len + name_entry_padding ; } break ; } case OLSR_POWERINFO_MSG : default : print_unknown_data ( ndo , msg_data , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } tptr += msg_len ; } return ; trunc : ND_PRINT ( ( ndo , ""[|olsr]"" ) ) ; }",u_int name_entries ;u_int addr_size ;int name_entries_valid ;u_int i ;if ( msg_tlen < 4 ) goto trunc ;name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;addr_size = 4 ;int name_entries_valid = 0 ;if ( is_ipv6 ) addr_size = 16 ;if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) name_entries_valid = 1 ;,1605
575,"buggy line: uint16 bitspersample , samplesperpixel ;uint16 input_compression , input_photometric ;copyFunc cf ;cwe id:CWE-190context: static int tiffcp ( TIFF * in , TIFF * out ) {  uint16 bitspersample , samplesperpixel ;   uint16 input_compression , input_photometric ;  copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel == 3 ) { TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_RGB ) ; } else CopyTag ( TIFFTAG_PHOTOMETRIC , 1 , TIFF_SHORT ) ; if ( fillorder != 0 ) TIFFSetField ( out , TIFFTAG_FILLORDER , fillorder ) ; else CopyTag ( TIFFTAG_FILLORDER , 1 , TIFF_SHORT ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; switch ( orientation ) { case ORIENTATION_BOTRIGHT : case ORIENTATION_RIGHTBOT : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>bottom-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_BOTLEFT ; case ORIENTATION_LEFTBOT : case ORIENTATION_BOTLEFT : break ; case ORIENTATION_TOPRIGHT : case ORIENTATION_RIGHTTOP : default : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>top-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_TOPLEFT ; case ORIENTATION_LEFTTOP : case ORIENTATION_TOPLEFT : break ; } TIFFSetField ( out , TIFFTAG_ORIENTATION , orientation ) ; if ( outtiled == - 1 ) outtiled = TIFFIsTiled ( in ) ; if ( outtiled ) { if ( tilewidth == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tilewidth ) ; if ( tilelength == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tilelength ) ; TIFFDefaultTileSize ( out , & tilewidth , & tilelength ) ; TIFFSetField ( out , TIFFTAG_TILEWIDTH , tilewidth ) ; TIFFSetField ( out , TIFFTAG_TILELENGTH , tilelength ) ; } else { if ( rowsperstrip == ( uint32 ) 0 ) { if ( ! TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ) { rowsperstrip = TIFFDefaultStripSize ( out , rowsperstrip ) ; } if ( rowsperstrip > length && rowsperstrip != ( uint32 ) - 1 ) rowsperstrip = length ; } else if ( rowsperstrip == ( uint32 ) - 1 ) rowsperstrip = length ; TIFFSetField ( out , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; } if ( config != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PLANARCONFIG , config ) ; else CopyField ( TIFFTAG_PLANARCONFIG , config ) ; if ( samplesperpixel <= 4 ) CopyTag ( TIFFTAG_TRANSFERFUNCTION , 4 , TIFF_SHORT ) ; CopyTag ( TIFFTAG_COLORMAP , 4 , TIFF_SHORT ) ; switch ( compression ) { case COMPRESSION_JPEG : TIFFSetField ( out , TIFFTAG_JPEGQUALITY , quality ) ; TIFFSetField ( out , TIFFTAG_JPEGCOLORMODE , jpegcolormode ) ; break ; case COMPRESSION_JBIG : CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; CopyTag ( TIFFTAG_FAXDCS , 1 , TIFF_ASCII ) ; break ; case COMPRESSION_LZW : case COMPRESSION_ADOBE_DEFLATE : case COMPRESSION_DEFLATE : case COMPRESSION_LZMA : if ( predictor != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PREDICTOR , predictor ) ; else CopyField ( TIFFTAG_PREDICTOR , predictor ) ; if ( preset != - 1 ) { if ( compression == COMPRESSION_ADOBE_DEFLATE || compression == COMPRESSION_DEFLATE ) TIFFSetField ( out , TIFFTAG_ZIPQUALITY , preset ) ; else if ( compression == COMPRESSION_LZMA ) TIFFSetField ( out , TIFFTAG_LZMAPRESET , preset ) ; } break ; case COMPRESSION_CCITTFAX3 : case COMPRESSION_CCITTFAX4 : if ( compression == COMPRESSION_CCITTFAX3 ) { if ( g3opts != ( uint32 ) - 1 ) TIFFSetField ( out , TIFFTAG_GROUP3OPTIONS , g3opts ) ; else CopyField ( TIFFTAG_GROUP3OPTIONS , g3opts ) ; } else CopyTag ( TIFFTAG_GROUP4OPTIONS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_BADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CLEANFAXDATA , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CONSECUTIVEBADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; break ; } { uint32 len32 ; void * * data ; if ( TIFFGetField ( in , TIFFTAG_ICCPROFILE , & len32 , & data ) ) TIFFSetField ( out , TIFFTAG_ICCPROFILE , len32 , data ) ; } { uint16 ninks ; const char * inknames ; if ( TIFFGetField ( in , TIFFTAG_NUMBEROFINKS , & ninks ) ) { TIFFSetField ( out , TIFFTAG_NUMBEROFINKS , ninks ) ; if ( TIFFGetField ( in , TIFFTAG_INKNAMES , & inknames ) ) { int inknameslen = strlen ( inknames ) + 1 ; const char * cp = inknames ; while ( ninks > 1 ) { cp = strchr ( cp , '\\0' ) ; cp ++ ; inknameslen += ( strlen ( cp ) + 1 ) ; ninks -- ; } TIFFSetField ( out , TIFFTAG_INKNAMES , inknameslen , inknames ) ; } } } { unsigned short pg0 , pg1 ; if ( pageInSeq == 1 ) { if ( pageNum < 0 ) { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; } else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } else { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) { if ( pageNum < 0 ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } } } for ( p = tags ; p < & tags [ NTAGS ] ; p ++ ) CopyTag ( p -> tag , p -> count , p -> type ) ; cf = pickCopyFunc ( in , out , bitspersample , samplesperpixel ) ; return ( cf ? ( * cf ) ( in , out , length , width , samplesperpixel ) : FALSE ) ; }","uint16 bitspersample , samplesperpixel = 1 ;uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ;copyFunc cf ;",1606
576,"buggy line: option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;cwe id:CWE-000context: static int errorLogDirective ( MaState * state , cchar * key , cchar * value ) { MprTicks stamp ; char * option , * ovalue , * tok , * path ; ssize size ; int level , flags , backup ; if ( mprGetCmdlineLogging ( ) ) { mprLog ( ""info<S2SV_blank>appweb<S2SV_blank>config"" , 4 , ""Already<S2SV_blank>logging.<S2SV_blank>Ignoring<S2SV_blank>ErrorLog<S2SV_blank>directive"" ) ; return 0 ; } size = MAXINT ; stamp = 0 ; level = 0 ; backup = 0 ; path = 0 ; flags = 0 ; for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { if ( ! path ) { path = mprJoinPath ( httpGetRouteVar ( state -> route , ""LOG_DIR"" ) , httpExpandRouteVars ( state -> route , option ) ) ; } else {  option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ;  ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( smatch ( option , ""size"" ) ) { size = ( ssize ) getnum ( ovalue ) ; } else if ( smatch ( option , ""level"" ) ) { level = atoi ( ovalue ) ; } else if ( smatch ( option , ""backup"" ) ) { backup = atoi ( ovalue ) ; } else if ( smatch ( option , ""anew"" ) ) { flags |= MPR_LOG_ANEW ; } else if ( smatch ( option , ""stamp"" ) ) { stamp = httpGetTicks ( ovalue ) ; } else { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unknown<S2SV_blank>ErrorLog<S2SV_blank>option<S2SV_blank>%s"" , option ) ; } } } if ( size < ( 10 * 1000 ) ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small.<S2SV_blank>Must<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>10K"" ) ; return MPR_ERR_BAD_SYNTAX ; } if ( path == 0 ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Missing<S2SV_blank>filename"" ) ; return MPR_ERR_BAD_SYNTAX ; } mprSetLogBackup ( size , backup , flags ) ; if ( ! smatch ( path , ""stdout"" ) && ! smatch ( path , ""stderr"" ) ) { path = httpMakePath ( state -> route , state -> configDir , path ) ; } if ( mprStartLogging ( path , MPR_LOG_DETAILED ) < 0 ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Cannot<S2SV_blank>write<S2SV_blank>to<S2SV_blank>ErrorLog:<S2SV_blank>%s"" , path ) ; return MPR_ERR_BAD_SYNTAX ; } mprSetLogLevel ( level ) ; mprLogHeader ( ) ; if ( stamp ) { httpSetTimestamp ( stamp ) ; } return 0 ; }","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",1607
577,"buggy line: static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size ,  vp9_coeff_stats * coef_branch_ct ) {vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ;vp9_coeff_count * coef_counts = cpi -> coef_counts [ tx_size ] ;cwe id:CWE-119context: static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size ,  vp9_coeff_stats * coef_branch_ct ) {   vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ;  vp9_coeff_count * coef_counts = cpi -> coef_counts [ tx_size ] ; unsigned int ( * eob_branch_ct ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = cpi -> common . counts . eob_branch [ tx_size ] ; int i , j , k , l , m ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { vp9_tree_probs_from_distribution ( vp9_coef_tree , coef_branch_ct [ i ] [ j ] [ k ] [ l ] , coef_counts [ i ] [ j ] [ k ] [ l ] ) ; coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 1 ] = eob_branch_ct [ i ] [ j ] [ k ] [ l ] - coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 0 ] ; for ( m = 0 ; m < UNCONSTRAINED_NODES ; ++ m ) coef_probs [ i ] [ j ] [ k ] [ l ] [ m ] = get_binary_prob ( coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ m ] [ 0 ] , coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ m ] [ 1 ] ) ; } } } } }","static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size , vp9_coeff_stats * coef_branch_ct , vp9_coeff_probs_model * coef_probs ) {vp9_coeff_count * coef_counts = cpi -> td . rd_counts . coef_counts [ tx_size ] ;",1608
578,"buggy line: assert ( name ) ;r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ;cwe id:CWE-255context: static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { int r ; struct termios tc = { } ;  assert ( name ) ;  r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ; if ( r < 0 ) return log_warning_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , enable_disable ( utf8 ) , name ) ; r = loop_write ( fd , utf8 ? ""\\033%G"" : ""\\033%@"" , 3 , false ) ; if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>term<S2SV_blank>processing<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , enable_disable ( utf8 ) , name ) ; r = tcgetattr ( fd , & tc ) ; if ( r >= 0 ) { SET_FLAG ( tc . c_iflag , IUTF8 , utf8 ) ; r = tcsetattr ( fd , TCSANOW , & tc ) ; } if ( r < 0 ) return log_warning_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>iutf8<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , enable_disable ( utf8 ) , name ) ; log_debug ( ""UTF-8<S2SV_blank>kbdmode<S2SV_blank>%sd<S2SV_blank>on<S2SV_blank>%s"" , enable_disable ( utf8 ) , name ) ; return 0 ; }","assert ( name ) ;r = vt_verify_kbmode ( fd ) ;if ( r == - EBUSY ) {log_warning_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , name ) ;return 0 ;}else if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , name ) ;r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ;",1609
579,"buggy line: static int su3000_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ 3 ] = {0xe , 0x80 , 0 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x02 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config ,   & d -> dev -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ;cwe id:CWE-119context:  static int su3000_frontend_attach ( struct dvb_usb_adapter * d )  { u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ;  if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  obuf [ 0 ] = 0xe ;   obuf [ 1 ] = 0x02 ;   obuf [ 2 ] = 1 ;   if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  msleep ( 300 ) ;  obuf [ 0 ] = 0xe ;  obuf [ 1 ] = 0x83 ;   obuf [ 2 ] = 0 ;   if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  obuf [ 0 ] = 0xe ;  obuf [ 1 ] = 0x83 ; obuf [ 2 ] = 1 ;  if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config ,   & d -> dev -> i2c_adap ) ;   if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;  if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {  info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ; return 0 ; } info ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>DS3000/TS2020!"" ) ; return - EIO ; }","static int su3000_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x02 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x83 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x83 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config , & d -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ;if ( adap -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ;",1610
580,"buggy line: sock_release ( SOCKET_I ( inode ) ) ;return 0 ;cwe id:CWE-362context: static int sock_close ( struct inode * inode , struct file * filp ) {  sock_release ( SOCKET_I ( inode ) ) ;  return 0 ; }","__sock_release ( SOCKET_I ( inode ) , inode ) ;return 0 ;",1611
581,"buggy line: vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface ,  vpx_codec_enc_cfg_t * cfg ,  vpx_codec_flags_t flags , int ver ) {else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ;cwe id:CWE-119context: vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface ,  vpx_codec_enc_cfg_t * cfg ,  vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ;  else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; }  if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ; } return SAVE_STATUS ( ctx , res ) ; }","vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , const vpx_codec_enc_cfg_t * cfg , vpx_codec_flags_t flags , int ver ) {",1612
582,"buggy line: if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ;cwe id:CWE-119context: vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface ,  vpx_codec_enc_cfg_t * cfg ,  vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ;  else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; }  if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ; } return SAVE_STATUS ( ctx , res ) ; }","
",1612
583,"buggy line: static void temporal_filter_predictors_mb_c ( MACROBLOCKD * xd , uint8_t * y_mb_ptr , uint8_t * u_mb_ptr , uint8_t * v_mb_ptr , int stride ,  int uv_block_size ,  int mv_row , int mv_col , uint8_t * pred , struct scale_factors * scale , int x , int y ) {const InterpKernel * const kernel =  vp9_get_interp_kernel ( xd -> mi [ 0 ] -> mbmi . interp_filter ) ;enum mv_precision mv_precision_uv ;if ( uv_block_size == 8 ) {uv_stride = ( stride + 1 ) >> 1 ;vp9_build_inter_predictor ( y_mb_ptr , stride ,  & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y ) ;vp9_build_inter_predictor ( u_mb_ptr , uv_stride ,  & pred [ 256 ] , uv_block_size ,  & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ;vp9_build_inter_predictor ( v_mb_ptr , uv_stride ,  & pred [ 512 ] , uv_block_size ,  & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ;cwe id:CWE-119context: static void temporal_filter_predictors_mb_c ( MACROBLOCKD * xd , uint8_t * y_mb_ptr , uint8_t * u_mb_ptr , uint8_t * v_mb_ptr , int stride ,  int uv_block_size ,  int mv_row , int mv_col , uint8_t * pred , struct scale_factors * scale , int x , int y ) { const int which_mv = 0 ; const MV mv = { mv_row , mv_col } ; const InterpKernel * const kernel =  vp9_get_interp_kernel ( xd -> mi [ 0 ] -> mbmi . interp_filter ) ;  enum mv_precision mv_precision_uv ; int uv_stride ;  if ( uv_block_size == 8 ) {  uv_stride = ( stride + 1 ) >> 1 ; mv_precision_uv = MV_PRECISION_Q4 ; } else { uv_stride = stride ; mv_precision_uv = MV_PRECISION_Q3 ; }  vp9_build_inter_predictor ( y_mb_ptr , stride ,  & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y ) ; vp9_build_inter_predictor ( u_mb_ptr , uv_stride ,  & pred [ 256 ] , uv_block_size ,  & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; vp9_build_inter_predictor ( v_mb_ptr , uv_stride ,  & pred [ 512 ] , uv_block_size ,  & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; }","static void temporal_filter_predictors_mb_c ( MACROBLOCKD * xd , uint8_t * y_mb_ptr , uint8_t * u_mb_ptr , uint8_t * v_mb_ptr , int stride , int uv_block_width , int uv_block_height , int mv_row , int mv_col , uint8_t * pred , struct scale_factors * scale , int x , int y ) {const InterpKernel * const kernel = vp9_filter_kernels [ xd -> mi [ 0 ] -> mbmi . interp_filter ] ;enum mv_precision mv_precision_uv ;if ( uv_block_width == 8 ) {uv_stride = ( stride + 1 ) >> 1 ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {vp9_highbd_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y , xd -> bd ) ;vp9_highbd_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ;vp9_highbd_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ;return ;}# endif vp9_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y ) ;vp9_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_size , & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ;vp9_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_size , & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ;",1613
584,"buggy line: mungspaces ( strcpy ( buf , origbuf ) ) ;bufp = find_optparam ( buf ) ;cwe id:CWE-120context: boolean parse_config_line ( origbuf ) char * origbuf ; { # if defined ( MICRO ) && ! defined ( NOCWD_ASSUMPTIONS ) static boolean ramdisk_specified = FALSE ; # endif # ifdef SYSCF int n , src = iflags . parse_config_file_src ; # endif char * bufp , buf [ 4 * BUFSZ ] ; uchar translate [ MAXPCHARS ] ; int len ; boolean retval = TRUE ;  mungspaces ( strcpy ( buf , origbuf ) ) ;  bufp = find_optparam ( buf ) ; if ( ! bufp ) { config_error_add ( ""Not<S2SV_blank>a<S2SV_blank>config<S2SV_blank>statement,<S2SV_blank>missing<S2SV_blank>\'=\'"" ) ; return FALSE ; } ++ bufp ; if ( * bufp == '<S2SV_blank>' ) ++ bufp ; if ( match_varname ( buf , ""OPTIONS"" , 4 ) ) { bufp = find_optparam ( origbuf ) ; ++ bufp ; if ( ! parseoptions ( bufp , TRUE , TRUE ) ) retval = FALSE ; } else if ( match_varname ( buf , ""AUTOPICKUP_EXCEPTION"" , 5 ) ) { add_autopickup_exception ( bufp ) ; } else if ( match_varname ( buf , ""BINDINGS"" , 4 ) ) { if ( ! parsebindings ( bufp ) ) retval = FALSE ; } else if ( match_varname ( buf , ""AUTOCOMPLETE"" , 5 ) ) { parseautocomplete ( bufp , TRUE ) ; } else if ( match_varname ( buf , ""MSGTYPE"" , 7 ) ) { if ( ! msgtype_parse_add ( bufp ) ) retval = FALSE ; # ifdef NOCWD_ASSUMPTIONS } else if ( match_varname ( buf , ""HACKDIR"" , 4 ) ) { adjust_prefix ( bufp , HACKPREFIX ) ; } else if ( match_varname ( buf , ""LEVELDIR"" , 4 ) || match_varname ( buf , ""LEVELS"" , 4 ) ) { adjust_prefix ( bufp , LEVELPREFIX ) ; } else if ( match_varname ( buf , ""SAVEDIR"" , 4 ) ) { adjust_prefix ( bufp , SAVEPREFIX ) ; } else if ( match_varname ( buf , ""BONESDIR"" , 5 ) ) { adjust_prefix ( bufp , BONESPREFIX ) ; } else if ( match_varname ( buf , ""DATADIR"" , 4 ) ) { adjust_prefix ( bufp , DATAPREFIX ) ; } else if ( match_varname ( buf , ""SCOREDIR"" , 4 ) ) { adjust_prefix ( bufp , SCOREPREFIX ) ; } else if ( match_varname ( buf , ""LOCKDIR"" , 4 ) ) { adjust_prefix ( bufp , LOCKPREFIX ) ; } else if ( match_varname ( buf , ""CONFIGDIR"" , 4 ) ) { adjust_prefix ( bufp , CONFIGPREFIX ) ; } else if ( match_varname ( buf , ""TROUBLEDIR"" , 4 ) ) { adjust_prefix ( bufp , TROUBLEPREFIX ) ; # else # ifdef MICRO } else if ( match_varname ( buf , ""HACKDIR"" , 4 ) ) { ( void ) strncpy ( hackdir , bufp , PATHLEN - 1 ) ; # ifdef MFLOPPY } else if ( match_varname ( buf , ""RAMDISK"" , 3 ) ) { # ifndef AMIGA if ( strlen ( bufp ) >= PATHLEN ) bufp [ PATHLEN - 1 ] = '\\0' ; Strcpy ( levels , bufp ) ; ramdisk = ( strcmp ( permbones , levels ) != 0 ) ; ramdisk_specified = TRUE ; # endif # endif } else if ( match_varname ( buf , ""LEVELS"" , 4 ) ) { if ( strlen ( bufp ) >= PATHLEN ) bufp [ PATHLEN - 1 ] = '\\0' ; Strcpy ( permbones , bufp ) ; if ( ! ramdisk_specified || ! * levels ) Strcpy ( levels , bufp ) ; ramdisk = ( strcmp ( permbones , levels ) != 0 ) ; } else if ( match_varname ( buf , ""SAVE"" , 4 ) ) { # ifdef MFLOPPY extern int saveprompt ; # endif char * ptr ; if ( ( ptr = index ( bufp , ';' ) ) != 0 ) { * ptr = '\\0' ; # ifdef MFLOPPY if ( * ( ptr + 1 ) == 'n' || * ( ptr + 1 ) == 'N' ) { saveprompt = FALSE ; } # endif } # if defined ( SYSFLAGS ) && defined ( MFLOPPY ) else saveprompt = sysflags . asksavedisk ; # endif ( void ) strncpy ( SAVEP , bufp , SAVESIZE - 1 ) ; append_slash ( SAVEP ) ; # endif # endif } else if ( match_varname ( buf , ""NAME"" , 4 ) ) { ( void ) strncpy ( plname , bufp , PL_NSIZ - 1 ) ; } else if ( match_varname ( buf , ""ROLE"" , 4 ) || match_varname ( buf , ""CHARACTER"" , 4 ) ) { if ( ( len = str2role ( bufp ) ) >= 0 ) flags . initrole = len ; } else if ( match_varname ( buf , ""DOGNAME"" , 3 ) ) { ( void ) strncpy ( dogname , bufp , PL_PSIZ - 1 ) ; } else if ( match_varname ( buf , ""CATNAME"" , 3 ) ) { ( void ) strncpy ( catname , bufp , PL_PSIZ - 1 ) ; # ifdef SYSCF } else if ( src == SET_IN_SYS && match_varname ( buf , ""WIZARDS"" , 7 ) ) { if ( sysopt . wizards ) free ( ( genericptr_t ) sysopt . wizards ) ; sysopt . wizards = dupstr ( bufp ) ; if ( strlen ( sysopt . wizards ) && strcmp ( sysopt . wizards , ""*"" ) ) { if ( sysopt . fmtd_wizard_list ) free ( ( genericptr_t ) sysopt . fmtd_wizard_list ) ; sysopt . fmtd_wizard_list = build_english_list ( sysopt . wizards ) ; } } else if ( src == SET_IN_SYS && match_varname ( buf , ""SHELLERS"" , 8 ) ) { if ( sysopt . shellers ) free ( ( genericptr_t ) sysopt . shellers ) ; sysopt . shellers = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""EXPLORERS"" , 7 ) ) { if ( sysopt . explorers ) free ( ( genericptr_t ) sysopt . explorers ) ; sysopt . explorers = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""DEBUGFILES"" , 5 ) ) { if ( sysopt . env_dbgfl <= 0 ) { if ( sysopt . debugfiles ) free ( ( genericptr_t ) sysopt . debugfiles ) ; sysopt . debugfiles = dupstr ( bufp ) ; } } else if ( src == SET_IN_SYS && match_varname ( buf , ""DUMPLOGFILE"" , 7 ) ) { # ifdef DUMPLOG if ( sysopt . dumplogfile ) free ( ( genericptr_t ) sysopt . dumplogfile ) ; sysopt . dumplogfile = dupstr ( bufp ) ; # endif # ifdef WIN32 } else if ( src == SET_IN_SYS && match_varname ( buf , ""portable_device_top"" , 8 ) ) { if ( sysopt . portable_device_top ) free ( ( genericptr_t ) sysopt . portable_device_top ) ; sysopt . portable_device_top = dupstr ( bufp ) ; # endif } else if ( src == SET_IN_SYS && match_varname ( buf , ""GENERICUSERS"" , 12 ) ) { if ( sysopt . genericusers ) free ( ( genericptr_t ) sysopt . genericusers ) ; sysopt . genericusers = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""BONES_POOLS"" , 10 ) ) { n = atoi ( bufp ) ; sysopt . bones_pools = ( n <= 0 ) ? 0 : min ( n , 10 ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""SUPPORT"" , 7 ) ) { if ( sysopt . support ) free ( ( genericptr_t ) sysopt . support ) ; sysopt . support = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""RECOVER"" , 7 ) ) { if ( sysopt . recover ) free ( ( genericptr_t ) sysopt . recover ) ; sysopt . recover = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""CHECK_SAVE_UID"" , 14 ) ) { n = atoi ( bufp ) ; sysopt . check_save_uid = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""CHECK_PLNAME"" , 12 ) ) { n = atoi ( bufp ) ; sysopt . check_plname = n ; } else if ( match_varname ( buf , ""SEDUCE"" , 6 ) ) { n = ! ! atoi ( bufp ) ; if ( src != SET_IN_SYS && n != 0 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>SEDUCE"" ) ; return FALSE ; } sysopt . seduce = n ; sysopt_seduce_set ( sysopt . seduce ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""MAXPLAYERS"" , 10 ) ) { n = atoi ( bufp ) ; if ( n < 0 || n > 25 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>MAXPLAYERS<S2SV_blank>(maximum<S2SV_blank>is<S2SV_blank>25)."" ) ; return FALSE ; } sysopt . maxplayers = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""PERSMAX"" , 7 ) ) { n = atoi ( bufp ) ; if ( n < 1 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>PERSMAX<S2SV_blank>(minimum<S2SV_blank>is<S2SV_blank>1)."" ) ; return FALSE ; } sysopt . persmax = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""PERS_IS_UID"" , 11 ) ) { n = atoi ( bufp ) ; if ( n != 0 && n != 1 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>PERS_IS_UID<S2SV_blank>(must<S2SV_blank>be<S2SV_blank>0<S2SV_blank>or<S2SV_blank>1)."" ) ; return FALSE ; } sysopt . pers_is_uid = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""ENTRYMAX"" , 8 ) ) { n = atoi ( bufp ) ; if ( n < 10 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>ENTRYMAX<S2SV_blank>(minimum<S2SV_blank>is<S2SV_blank>10)."" ) ; return FALSE ; } sysopt . entrymax = n ; } else if ( ( src == SET_IN_SYS ) && match_varname ( buf , ""POINTSMIN"" , 9 ) ) { n = atoi ( bufp ) ; if ( n < 1 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>POINTSMIN<S2SV_blank>(minimum<S2SV_blank>is<S2SV_blank>1)."" ) ; return FALSE ; } sysopt . pointsmin = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""MAX_STATUENAME_RANK"" , 10 ) ) { n = atoi ( bufp ) ; if ( n < 1 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>MAX_STATUENAME_RANK<S2SV_blank>(minimum<S2SV_blank>is<S2SV_blank>1)."" ) ; return FALSE ; } sysopt . tt_oname_maxrank = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""PANICTRACE_LIBC"" , 15 ) ) { n = atoi ( bufp ) ; # if defined ( PANICTRACE ) && defined ( PANICTRACE_LIBC ) if ( n < 0 || n > 2 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>PANICTRACE_LIBC<S2SV_blank>(not<S2SV_blank>0,1,2)."" ) ; return FALSE ; } # endif sysopt . panictrace_libc = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""PANICTRACE_GDB"" , 14 ) ) { n = atoi ( bufp ) ; # if defined ( PANICTRACE ) if ( n < 0 || n > 2 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>PANICTRACE_GDB<S2SV_blank>(not<S2SV_blank>0,1,2)."" ) ; return FALSE ; } # endif sysopt . panictrace_gdb = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""GDBPATH"" , 7 ) ) { # if defined ( PANICTRACE ) && ! defined ( VMS ) if ( ! file_exists ( bufp ) ) { config_error_add ( ""File<S2SV_blank>specified<S2SV_blank>in<S2SV_blank>GDBPATH<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist."" ) ; return FALSE ; } # endif if ( sysopt . gdbpath ) free ( ( genericptr_t ) sysopt . gdbpath ) ; sysopt . gdbpath = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""GREPPATH"" , 7 ) ) { # if defined ( PANICTRACE ) && ! defined ( VMS ) if ( ! file_exists ( bufp ) ) { config_error_add ( ""File<S2SV_blank>specified<S2SV_blank>in<S2SV_blank>GREPPATH<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist."" ) ; return FALSE ; } # endif if ( sysopt . greppath ) free ( ( genericptr_t ) sysopt . greppath ) ; sysopt . greppath = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""ACCESSIBILITY"" , 13 ) ) { n = atoi ( bufp ) ; if ( n < 0 || n > 1 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>ACCESSIBILITY<S2SV_blank>(not<S2SV_blank>0,1)."" ) ; return FALSE ; } sysopt . accessibility = n ; # endif } else if ( match_varname ( buf , ""BOULDER"" , 3 ) ) { ( void ) get_uchars ( bufp , & ov_primary_syms [ SYM_BOULDER + SYM_OFF_X ] , TRUE , 1 , ""BOULDER"" ) ; } else if ( match_varname ( buf , ""MENUCOLOR"" , 9 ) ) { if ( ! add_menu_coloring ( bufp ) ) retval = FALSE ; } else if ( match_varname ( buf , ""HILITE_STATUS"" , 6 ) ) { # ifdef STATUS_HILITES if ( ! parse_status_hl1 ( bufp , TRUE ) ) retval = FALSE ; # endif } else if ( match_varname ( buf , ""WARNINGS"" , 5 ) ) { ( void ) get_uchars ( bufp , translate , FALSE , WARNCOUNT , ""WARNINGS"" ) ; assign_warnings ( translate ) ; } else if ( match_varname ( buf , ""ROGUESYMBOLS"" , 4 ) ) { if ( ! parsesymbols ( bufp , ROGUESET ) ) { config_error_add ( ""Error<S2SV_blank>in<S2SV_blank>ROGUESYMBOLS<S2SV_blank>definition<S2SV_blank>\'%s\'"" , bufp ) ; retval = FALSE ; } switch_symbols ( TRUE ) ; } else if ( match_varname ( buf , ""SYMBOLS"" , 4 ) ) { if ( ! parsesymbols ( bufp , PRIMARY ) ) { config_error_add ( ""Error<S2SV_blank>in<S2SV_blank>SYMBOLS<S2SV_blank>definition<S2SV_blank>\'%s\'"" , bufp ) ; retval = FALSE ; } switch_symbols ( TRUE ) ; } else if ( match_varname ( buf , ""WIZKIT"" , 6 ) ) { ( void ) strncpy ( wizkit , bufp , WIZKIT_MAX - 1 ) ; # ifdef AMIGA } else if ( match_varname ( buf , ""FONT"" , 4 ) ) { char * t ; if ( t = strchr ( buf + 5 , ':' ) ) { * t = 0 ; amii_set_text_font ( buf + 5 , atoi ( t + 1 ) ) ; * t = ':' ; } } else if ( match_varname ( buf , ""PATH"" , 4 ) ) { ( void ) strncpy ( PATH , bufp , PATHLEN - 1 ) ; } else if ( match_varname ( buf , ""DEPTH"" , 5 ) ) { extern int amii_numcolors ; int val = atoi ( bufp ) ; amii_numcolors = 1L << min ( DEPTH , val ) ; # ifdef SYSFLAGS } else if ( match_varname ( buf , ""DRIPENS"" , 7 ) ) { int i , val ; char * t ; for ( i = 0 , t = strtok ( bufp , "",/"" ) ; t != ( char * ) 0 ; i < 20 && ( t = strtok ( ( char * ) 0 , "",/"" ) ) , ++ i ) { sscanf ( t , ""%d"" , & val ) ; sysflags . amii_dripens [ i ] = val ; } # endif } else if ( match_varname ( buf , ""SCREENMODE"" , 10 ) ) { extern long amii_scrnmode ; if ( ! stricmp ( bufp , ""req"" ) ) amii_scrnmode = 0xffffffff ; else if ( sscanf ( bufp , ""%x"" , & amii_scrnmode ) != 1 ) amii_scrnmode = 0 ; } else if ( match_varname ( buf , ""MSGPENS"" , 7 ) ) { extern int amii_msgAPen , amii_msgBPen ; char * t = strtok ( bufp , "",/"" ) ; if ( t ) { sscanf ( t , ""%d"" , & amii_msgAPen ) ; if ( t = strtok ( ( char * ) 0 , "",/"" ) ) sscanf ( t , ""%d"" , & amii_msgBPen ) ; } } else if ( match_varname ( buf , ""TEXTPENS"" , 8 ) ) { extern int amii_textAPen , amii_textBPen ; char * t = strtok ( bufp , "",/"" ) ; if ( t ) { sscanf ( t , ""%d"" , & amii_textAPen ) ; if ( t = strtok ( ( char * ) 0 , "",/"" ) ) sscanf ( t , ""%d"" , & amii_textBPen ) ; } } else if ( match_varname ( buf , ""MENUPENS"" , 8 ) ) { extern int amii_menuAPen , amii_menuBPen ; char * t = strtok ( bufp , "",/"" ) ; if ( t ) { sscanf ( t , ""%d"" , & amii_menuAPen ) ; if ( t = strtok ( ( char * ) 0 , "",/"" ) ) sscanf ( t , ""%d"" , & amii_menuBPen ) ; } } else if ( match_varname ( buf , ""STATUSPENS"" , 10 ) ) { extern int amii_statAPen , amii_statBPen ; char * t = strtok ( bufp , "",/"" ) ; if ( t ) { sscanf ( t , ""%d"" , & amii_statAPen ) ; if ( t = strtok ( ( char * ) 0 , "",/"" ) ) sscanf ( t , ""%d"" , & amii_statBPen ) ; } } else if ( match_varname ( buf , ""OTHERPENS"" , 9 ) ) { extern int amii_otherAPen , amii_otherBPen ; char * t = strtok ( bufp , "",/"" ) ; if ( t ) { sscanf ( t , ""%d"" , & amii_otherAPen ) ; if ( t = strtok ( ( char * ) 0 , "",/"" ) ) sscanf ( t , ""%d"" , & amii_otherBPen ) ; } } else if ( match_varname ( buf , ""PENS"" , 4 ) ) { extern unsigned short amii_init_map [ AMII_MAXCOLORS ] ; int i ; char * t ; for ( i = 0 , t = strtok ( bufp , "",/"" ) ; i < AMII_MAXCOLORS && t != ( char * ) 0 ; t = strtok ( ( char * ) 0 , "",/"" ) , ++ i ) { sscanf ( t , ""%hx"" , & amii_init_map [ i ] ) ; } amii_setpens ( amii_numcolors = i ) ; } else if ( match_varname ( buf , ""FGPENS"" , 6 ) ) { extern int foreg [ AMII_MAXCOLORS ] ; int i ; char * t ; for ( i = 0 , t = strtok ( bufp , "",/"" ) ; i < AMII_MAXCOLORS && t != ( char * ) 0 ; t = strtok ( ( char * ) 0 , "",/"" ) , ++ i ) { sscanf ( t , ""%d"" , & foreg [ i ] ) ; } } else if ( match_varname ( buf , ""BGPENS"" , 6 ) ) { extern int backg [ AMII_MAXCOLORS ] ; int i ; char * t ; for ( i = 0 , t = strtok ( bufp , "",/"" ) ; i < AMII_MAXCOLORS && t != ( char * ) 0 ; t = strtok ( ( char * ) 0 , "",/"" ) , ++ i ) { sscanf ( t , ""%d"" , & backg [ i ] ) ; } # endif # ifdef USER_SOUNDS } else if ( match_varname ( buf , ""SOUNDDIR"" , 8 ) ) { sounddir = dupstr ( bufp ) ; } else if ( match_varname ( buf , ""SOUND"" , 5 ) ) { add_sound_mapping ( bufp ) ; # endif } else if ( match_varname ( buf , ""QT_TILEWIDTH"" , 12 ) ) { # ifdef QT_GRAPHICS extern char * qt_tilewidth ; if ( qt_tilewidth == NULL ) qt_tilewidth = dupstr ( bufp ) ; # endif } else if ( match_varname ( buf , ""QT_TILEHEIGHT"" , 13 ) ) { # ifdef QT_GRAPHICS extern char * qt_tileheight ; if ( qt_tileheight == NULL ) qt_tileheight = dupstr ( bufp ) ; # endif } else if ( match_varname ( buf , ""QT_FONTSIZE"" , 11 ) ) { # ifdef QT_GRAPHICS extern char * qt_fontsize ; if ( qt_fontsize == NULL ) qt_fontsize = dupstr ( bufp ) ; # endif } else if ( match_varname ( buf , ""QT_COMPACT"" , 10 ) ) { # ifdef QT_GRAPHICS extern int qt_compact_mode ; qt_compact_mode = atoi ( bufp ) ; # endif } else { config_error_add ( ""Unknown<S2SV_blank>config<S2SV_blank>statement"" ) ; return FALSE ; } return retval ; }","while ( * origbuf == \'<S2SV_blank>\' || * origbuf == \'\\\\t\' ) ++ origbuf ;( void ) strncpy ( buf , origbuf , sizeof buf - 1 ) ;buf [ sizeof buf - 1 ] = \'\\\\0\' ;mungspaces ( buf ) ;bufp = find_optparam ( buf ) ;",1614
585,"buggy line: cJSON * cJSON_CreateFloatArray ( double * numbers , int count )  {for ( i = 0 ;++ i ) {n = cJSON_CreateFloat ( numbers [ i ] ) ;if ( ! i )  a -> child = n ;cwe id:CWE-119context:  cJSON * cJSON_CreateFloatArray ( double * numbers , int count )  { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ;  for ( i = 0 ; a && i < count ; ++ i ) {   n = cJSON_CreateFloat ( numbers [ i ] ) ;   if ( ! i )  a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }","cJSON * cJSON_CreateFloatArray ( const float * numbers , int count ) {for ( i = 0 ;+ i ) {i ++ ) {n = cJSON_CreateFloat ( numbers [ i ] ) ;if ( ! n ) {cJSON_Delete ( a ) ;return 0 ;}if ( ! i ) a -> child = n ;",1615
586,"buggy line: goto retry_rebind ;}cwe id:CWE-400context: static void nlmclnt_unlock_callback ( struct rpc_task * task , void * data ) { struct nlm_rqst * req = data ; u32 status = ntohl ( req -> a_res . status ) ; if ( RPC_ASSASSINATED ( task ) ) goto die ; if ( task -> tk_status < 0 ) { dprintk ( ""lockd:<S2SV_blank>unlock<S2SV_blank>failed<S2SV_blank>(err<S2SV_blank>=<S2SV_blank>%d)\\n"" , - task -> tk_status ) ;  goto retry_rebind ;  } if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { rpc_delay ( task , NLMCLNT_GRACE_WAIT ) ; goto retry_unlock ; } if ( status != NLM_LCK_GRANTED ) printk ( KERN_WARNING ""lockd:<S2SV_blank>unexpected<S2SV_blank>unlock<S2SV_blank>status:<S2SV_blank>%d\\n"" , status ) ; die : return ; retry_rebind : nlm_rebind_host ( req -> a_host ) ; retry_unlock : rpc_restart_call ( task ) ; }",switch ( task -> tk_status ) {case - EACCES : case - EIO : goto die ;default : goto retry_rebind ;}},1616
587,"buggy line: struct buffer_head * bh = NULL ;struct fileEntry * fe ;struct extendedFileEntry * efe ;uint16_t ident ;struct udf_inode_info * iinfo = UDF_I ( inode ) ;struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ;unsigned int link_count ;bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ;if ( ! bh ) {udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\\make_bad_inode ( inode ) ;return ;}if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) {udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\\brelse ( bh ) ;make_bad_inode ( inode ) ;return ;}fe = ( struct fileEntry * ) bh -> b_data ;efe = ( struct extendedFileEntry * ) bh -> b_data ;if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) {struct buffer_head * ibh ;ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ;if ( ident == TAG_IDENT_IE && ibh ) {struct buffer_head * nbh = NULL ;struct kernel_lb_addr loc ;if ( ie -> indirectICB . extLength &&   ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 ,  & ident ) ) ) {cwe id:CWE-399context: static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ;  unsigned int link_count ;  bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; make_bad_inode ( inode ) ; return ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) {  struct buffer_head * nbh = NULL ;  struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ;  if ( ie -> indirectICB . extLength &&   ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 ,  & ident ) ) ) { if ( ident == TAG_IDENT_FE || ident == TAG_IDENT_EFE ) { memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; brelse ( bh ) ; brelse ( ibh ) ; brelse ( nbh ) ; __udf_read_inode ( inode ) ; return ; }  brelse ( nbh ) ;  } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; return ; } read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) link_count = 1 ; set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } switch ( fe -> icbTag . fileType ) { case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; make_bad_inode ( inode ) ; return ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else make_bad_inode ( inode ) ; } brelse ( bh ) ; }","struct kernel_lb_addr loc ;if ( ie -> indirectICB . extLength && ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , & ident ) ) ) {",1617
588,"buggy line: brelse ( nbh ) ;}cwe id:CWE-399context: static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ;  unsigned int link_count ;  bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; make_bad_inode ( inode ) ; return ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) {  struct buffer_head * nbh = NULL ;  struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ;  if ( ie -> indirectICB . extLength &&   ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 ,  & ident ) ) ) { if ( ident == TAG_IDENT_FE || ident == TAG_IDENT_EFE ) { memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; brelse ( bh ) ; brelse ( ibh ) ; brelse ( nbh ) ; __udf_read_inode ( inode ) ; return ; }  brelse ( nbh ) ;  } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; return ; } read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) link_count = 1 ; set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } switch ( fe -> icbTag . fileType ) { case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; make_bad_inode ( inode ) ; return ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else make_bad_inode ( inode ) ; } brelse ( bh ) ; }",brelse ( nbh ) ;},1617
589,"buggy line: float * w = get_window ( f , n ) ;for ( i = 0 ;cwe id:CWE-119context: static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ;  float * w = get_window ( f , n ) ;  for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }","float * w = get_window ( f , n ) ;if ( w == NULL ) return 0 ;for ( i = 0 ;",1618
590,"buggy line: uint32 num_properties = GETINT32 ( buf + idx ) ;MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ;cwe id:CWE-787context: MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ;  uint32 num_properties = GETINT32 ( buf + idx ) ;  MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ;  for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ )  a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ;  if ( a -> type == szMAPI_UNICODE_STRING )  {  v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;  } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }","uint32 num_properties = GETINT32 ( buf + idx ) ;assert ( ( num_properties + 1 ) != 0 ) ;MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ;",1619
591,"buggy line: cwe id:CWE-787context: MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ;  uint32 num_properties = GETINT32 ( buf + idx ) ;  MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ;  for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ )  a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ;  if ( a -> type == szMAPI_UNICODE_STRING )  {  v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;  } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }",assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ;,1619
592,"buggy line: cwe id:CWE-787context: MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ;  uint32 num_properties = GETINT32 ( buf + idx ) ;  MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ;  for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ )  a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ;  if ( a -> type == szMAPI_UNICODE_STRING )  {  v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;  } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }",assert ( v -> len + idx <= len ) ;,1619
593,"buggy line: for ( j = 0 ;j ++ )  a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ;cwe id:CWE-787context: MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ;  uint32 num_properties = GETINT32 ( buf + idx ) ;  MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ;  for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ )  a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ;  if ( a -> type == szMAPI_UNICODE_STRING )  {  v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;  } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }",for ( j = 0 ;j ++ ) a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ;,1619
594,"buggy line: if ( a -> type == szMAPI_UNICODE_STRING )  {v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;}cwe id:CWE-787context: MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ;  uint32 num_properties = GETINT32 ( buf + idx ) ;  MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ;  for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ )  a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ;  if ( a -> type == szMAPI_UNICODE_STRING )  {  v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;  } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }","if ( a -> type == szMAPI_UNICODE_STRING ) {assert ( v -> len != 0 ) ;v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;}",1619
595,"buggy line: VP9_COMMON * const cm = & pbi -> common ;const uint8_t * bit_reader_end = NULL ;const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ;TileBuffer tile_buffers [ 1 << 6 ] ;int n ;const int num_threads = pbi -> oxcf . max_threads & ~ 1 ;int i ;CHECK_MEM_ERROR ( cm , pbi -> tile_workers ,  vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ;for ( i = 0 ;VP9Worker * const worker = & pbi -> tile_workers [ i ] ;++ pbi -> num_tile_workers ;vp9_worker_init ( worker ) ;CHECK_MEM_ERROR ( cm , worker -> data1 , vpx_memalign ( 32 , sizeof ( TileWorkerData ) ) ) ;CHECK_MEM_ERROR ( cm , worker -> data2 , vpx_malloc ( sizeof ( TileInfo ) ) ) ;if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) {vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Tile<S2SV_blank>decoder<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ;pbi -> tile_workers [ n ] . hook = ( VP9WorkerHook ) tile_worker_hook ;}vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ;vpx_memset ( cm -> above_seg_context , 0 ,  sizeof ( * cm -> above_seg_context ) * aligned_mi_cols ) ;for ( n = 0 ;n < tile_cols ;++ n ) {const size_t size =  get_tile ( data_end , n == tile_cols - 1 , & cm -> error , & data ) ;TileBuffer * const buf = & tile_buffers [ n ] ;buf -> data = data ;buf -> size = size ;buf -> col = n ;data += size ;}qsort ( tile_buffers , tile_cols , sizeof ( tile_buffers [ 0 ] ) , compare_tile_buffers ) ;const TileBuffer largest = tile_buffers [ group_start ] ;memmove ( tile_buffers + group_start , tile_buffers + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] ) ) ;tile_buffers [ group_end ] = largest ;VP9Worker * const worker = & pbi -> tile_workers [ i ] ;TileBuffer * const buf = & tile_buffers [ n ] ;tile_data -> cm = cm ;vp9_tile_init ( tile , tile_data -> cm , 0 , buf -> col ) ;setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader ) ;init_macroblockd ( cm , & tile_data -> xd ) ;vp9_zero ( tile_data -> xd . dqcoeff ) ;vp9_worker_execute ( worker ) ;vp9_worker_launch ( worker ) ;}cwe id:CWE-119context: static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) {  VP9_COMMON * const cm = & pbi -> common ;  const uint8_t * bit_reader_end = NULL ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ;  const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ;   TileBuffer tile_buffers [ 1 << 6 ] ;  int n ; int final_worker = - 1 ; assert ( tile_cols <= ( 1 << 6 ) ) ; assert ( tile_rows == 1 ) ; ( void ) tile_rows ; if ( pbi -> num_tile_workers == 0 ) {  const int num_threads = pbi -> oxcf . max_threads & ~ 1 ;  int i ; CHECK_MEM_ERROR ( cm , pbi -> tile_workers ,  vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ;  for ( i = 0 ; i < num_threads ; ++ i ) {  VP9Worker * const worker = & pbi -> tile_workers [ i ] ;  ++ pbi -> num_tile_workers ;  vp9_worker_init ( worker ) ;  CHECK_MEM_ERROR ( cm , worker -> data1 , vpx_memalign ( 32 , sizeof ( TileWorkerData ) ) ) ; CHECK_MEM_ERROR ( cm , worker -> data2 , vpx_malloc ( sizeof ( TileInfo ) ) ) ;  if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) {  vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Tile<S2SV_blank>decoder<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ; } } } for ( n = 0 ; n < num_workers ; ++ n ) {  pbi -> tile_workers [ n ] . hook = ( VP9WorkerHook ) tile_worker_hook ;   }  vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ;  vpx_memset ( cm -> above_seg_context , 0 ,  sizeof ( * cm -> above_seg_context ) * aligned_mi_cols ) ;  for ( n = 0 ; n < tile_cols ; ++ n ) {  const size_t size =  get_tile ( data_end , n == tile_cols - 1 , & cm -> error , & data ) ;  TileBuffer * const buf = & tile_buffers [ n ] ; buf -> data = data ; buf -> size = size ; buf -> col = n ; data += size ; } qsort ( tile_buffers , tile_cols , sizeof ( tile_buffers [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start < tile_cols ) { const TileBuffer largest = tile_buffers [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers + group_start , tile_buffers + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] ) ) ; tile_buffers [ group_end ] = largest ; group_start = group_end + 1 ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VP9Worker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ n ] ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; vp9_tile_init ( tile , tile_data -> cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader ) ; init_macroblockd ( cm , & tile_data -> xd ) ; vp9_zero ( tile_data -> xd . dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || n == tile_cols - 1 ) { vp9_worker_execute ( worker ) ; } else {  vp9_worker_launch ( worker ) ;  } if ( buf -> col == tile_cols - 1 ) { final_worker = i ; } ++ n ; } for ( ; i > 0 ; -- i ) {  VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ;   pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ;  } if ( final_worker > - 1 ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ final_worker ] . data1 ;  bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ;   final_worker = - 1 ;  } } return bit_reader_end ; }","VP9_COMMON * const cm = & pbi -> common ;const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ;const uint8_t * bit_reader_end = NULL ;const int num_workers = MIN ( pbi -> max_threads & ~ 1 , tile_cols ) ;TileBuffer tile_buffers [ 1 ] [ 1 << 6 ] ;int n ;const int num_threads = pbi -> max_threads & ~ 1 ;int i ;CHECK_MEM_ERROR ( cm , pbi -> tile_workers ) ) ) ;assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ;CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , vpx_memalign ( 32 , num_threads * sizeof ( * pbi -> tile_worker_data ) ) ) ;CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ;for ( i = 0 ;+ pbi -> num_tile_workers ;VPxWorker * const worker = & pbi -> tile_workers [ i ] ;++ pbi -> num_tile_workers ;winterface -> init ( worker ) ;if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) {vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Tile<S2SV_blank>decoder<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ;+ n ) {VPxWorker * const worker = & pbi -> tile_workers [ n ] ;winterface -> sync ( worker ) ;worker -> hook = ( VPxWorkerHook ) tile_worker_hook ;}vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ;memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * aligned_mi_cols ) ;get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ;qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ;const TileBuffer largest = tile_buffers [ 0 ] [ group_start ] ;memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ;tile_buffers [ 0 ] [ group_end ] = largest ;if ( ! cm -> frame_parallel_decoding_mode ) {int i ;for ( i = 0 ;i < num_workers ;++ i ) {TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ;vp9_zero ( tile_data -> counts ) ;}}VPxWorker * const worker = & pbi -> tile_workers [ i ] ;TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ;tile_data -> pbi = pbi ;tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? 0 : & tile_data -> counts ;vp9_zero ( tile_data -> dqcoeff ) ;vp9_tile_init ( tile , cm , 0 , buf -> col ) ;vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ;setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ;vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ;winterface -> execute ( worker ) ;vp9_worker_launch ( worker ) ;}",1620
596,"buggy line: VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ;pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ;}bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ;final_worker = - 1 ;}cwe id:CWE-119context: static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) {  VP9_COMMON * const cm = & pbi -> common ;  const uint8_t * bit_reader_end = NULL ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ;  const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ;   TileBuffer tile_buffers [ 1 << 6 ] ;  int n ; int final_worker = - 1 ; assert ( tile_cols <= ( 1 << 6 ) ) ; assert ( tile_rows == 1 ) ; ( void ) tile_rows ; if ( pbi -> num_tile_workers == 0 ) {  const int num_threads = pbi -> oxcf . max_threads & ~ 1 ;  int i ; CHECK_MEM_ERROR ( cm , pbi -> tile_workers ,  vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ;  for ( i = 0 ; i < num_threads ; ++ i ) {  VP9Worker * const worker = & pbi -> tile_workers [ i ] ;  ++ pbi -> num_tile_workers ;  vp9_worker_init ( worker ) ;  CHECK_MEM_ERROR ( cm , worker -> data1 , vpx_memalign ( 32 , sizeof ( TileWorkerData ) ) ) ; CHECK_MEM_ERROR ( cm , worker -> data2 , vpx_malloc ( sizeof ( TileInfo ) ) ) ;  if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) {  vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Tile<S2SV_blank>decoder<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ; } } } for ( n = 0 ; n < num_workers ; ++ n ) {  pbi -> tile_workers [ n ] . hook = ( VP9WorkerHook ) tile_worker_hook ;   }  vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ;  vpx_memset ( cm -> above_seg_context , 0 ,  sizeof ( * cm -> above_seg_context ) * aligned_mi_cols ) ;  for ( n = 0 ; n < tile_cols ; ++ n ) {  const size_t size =  get_tile ( data_end , n == tile_cols - 1 , & cm -> error , & data ) ;  TileBuffer * const buf = & tile_buffers [ n ] ; buf -> data = data ; buf -> size = size ; buf -> col = n ; data += size ; } qsort ( tile_buffers , tile_cols , sizeof ( tile_buffers [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start < tile_cols ) { const TileBuffer largest = tile_buffers [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers + group_start , tile_buffers + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] ) ) ; tile_buffers [ group_end ] = largest ; group_start = group_end + 1 ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VP9Worker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ n ] ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; vp9_tile_init ( tile , tile_data -> cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader ) ; init_macroblockd ( cm , & tile_data -> xd ) ; vp9_zero ( tile_data -> xd . dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || n == tile_cols - 1 ) { vp9_worker_execute ( worker ) ; } else {  vp9_worker_launch ( worker ) ;  } if ( buf -> col == tile_cols - 1 ) { final_worker = i ; } ++ n ; } for ( ; i > 0 ; -- i ) {  VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ;   pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ;  } if ( final_worker > - 1 ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ final_worker ] . data1 ;  bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ;   final_worker = - 1 ;  } } return bit_reader_end ; }","VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ;pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ;}bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ;final_worker = - 1 ;}if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) {for ( i = 0 ;i < num_workers ;++ i ) {TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ;vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ;}}",1620
597,"buggy line: offset = base + get4 ( ) + 8 ;while ( ( save = ftell ( ifp ) ) < offset ) {switch ( tag )  {cwe id:CWE-835context: void CLASS parse_minolta ( int base ) { int save , tag , len , offset , high = 0 , wide = 0 , i , c ; short sorder = order ; fseek ( ifp , base , SEEK_SET ) ; if ( fgetc ( ifp ) || fgetc ( ifp ) - 'M' || fgetc ( ifp ) - 'R' ) return ; order = fgetc ( ifp ) * 0x101 ;  offset = base + get4 ( ) + 8 ;  while ( ( save = ftell ( ifp ) ) < offset ) { for ( tag = i = 0 ; i < 4 ; i ++ ) tag = tag << 8 | fgetc ( ifp ) ; len = get4 ( ) ;  switch ( tag )  { case 0x505244 : fseek ( ifp , 8 , SEEK_CUR ) ; high = get2 ( ) ; wide = get2 ( ) ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . makernotes . sony . prd_ImageHeight = get2 ( ) ; imgdata . makernotes . sony . prd_ImageWidth = get2 ( ) ; fseek ( ifp , 1L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_RawBitDepth = ( ushort ) fgetc ( ifp ) ; imgdata . makernotes . sony . prd_StorageMethod = ( ushort ) fgetc ( ifp ) ; fseek ( ifp , 4L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_BayerPattern = ( ushort ) fgetc ( ifp ) ; # endif break ; # ifdef LIBRAW_LIBRARY_BUILD case 0x524946 : if ( ! strncasecmp ( model , ""DSLR-A100"" , 9 ) ) { fseek ( ifp , 8 , SEEK_CUR ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 2 ] = get2 ( ) ; get4 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 3 ] = 0x100 ; } break ; # endif case 0x574247 : get4 ( ) ; i = strcmp ( model , ""DiMAGE<S2SV_blank>A200"" ) ? 0 : 3 ; FORC4 cam_mul [ c ^ ( c >> 1 ) ^ i ] = get2 ( ) ; break ; case 0x545457 : parse_tiff ( ftell ( ifp ) ) ; data_offset = offset ; } fseek ( ifp , save + len + 8 , SEEK_SET ) ; } raw_height = high ; raw_width = wide ; order = sorder ; }",offset = base + get4 ( ) + 8 ;# ifdef LIBRAW_LIBRARY_BUILD if ( offset > ifp -> size ( ) - 8 ) offset = ifp -> size ( ) - 8 ;# endif while ( ( save = ftell ( ifp ) ) < offset ) {if ( len < 0 ) return ;switch ( tag ) {,1621
598,"buggy line: err = - EINVAL ;if ( ! po -> running ) goto out ;cwe id:CWE-362context: static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ;  err = - EINVAL ;  if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; refcount_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ;  if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( refcount_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; refcount_set ( & match -> sk_ref , refcount_read ( & match -> sk_ref ) + 1 ) ; __fanout_link ( sk , po ) ; err = 0 ; } }  out :  if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }","
",1622
599,"buggy line: goto out ;}if ( ! fanout_find_new_id ( sk , & id ) ) {err = - ENOMEM ;goto out ;}flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ;}match = NULL ;list_for_each_entry ( f , & fanout_list , list ) {if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) {match = f ;break ;}}err = - EINVAL ;if ( match && match -> flags != flags ) goto out ;if ( ! match ) {err = - ENOMEM ;match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ;if ( ! match ) goto out ;write_pnet ( & match -> net , sock_net ( sk ) ) ;match -> id = id ;match -> type = type ;cwe id:CWE-362context: static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ;  err = - EINVAL ;  if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; refcount_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ;  if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( refcount_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; refcount_set ( & match -> sk_ref , refcount_read ( & match -> sk_ref ) + 1 ) ; __fanout_link ( sk , po ) ; err = 0 ; } }  out :  if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }",spin_lock ( & po -> bind_lock ) ;if ( po -> running && match -> type = type ;,1622
600,"buggy line: if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {cwe id:CWE-362context: static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ;  err = - EINVAL ;  if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; refcount_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ;  if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( refcount_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; refcount_set ( & match -> sk_ref , refcount_read ( & match -> sk_ref ) + 1 ) ; __fanout_link ( sk , po ) ; err = 0 ; } }  out :  if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }",if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {,1622
601,"buggy line: out :  if ( err && rollover ) {cwe id:CWE-362context: static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ;  err = - EINVAL ;  if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; refcount_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ;  if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( refcount_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; refcount_set ( & match -> sk_ref , refcount_read ( & match -> sk_ref ) + 1 ) ; __fanout_link ( sk , po ) ; err = 0 ; } }  out :  if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }",spin_unlock ( & po -> bind_lock ) ;if ( err && ! refcount_read ( & match -> sk_ref ) ) {list_del ( & match -> list ) ;kfree ( match ) ;}out : if ( err && rollover ) {,1622
602,"buggy line: struct segmentation * seg = & cm -> seg ;const double base_q = vp9_convert_qindex_to_q ( cm -> base_qindex ) ;const int base_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + cm -> y_dc_delta_q ) ;vp9_clear_system_state ( ) ;for ( i = ENERGY_MIN ;i <= ENERGY_MAX ;i ++ ) {int qindex_delta , segment_rdmult ;if ( Q_RATIO ( i ) == 1 ) {RDMULT_RATIO ( i ) = 1 ;qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ;vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ;vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ;segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta +  cm -> y_dc_delta_q ) ;RDMULT_RATIO ( i ) = ( double ) segment_rdmult / base_rdmult ;cwe id:CWE-119context: void vp9_vaq_frame_setup ( VP9_COMP * cpi ) { VP9_COMMON * cm = & cpi -> common ;  struct segmentation * seg = & cm -> seg ;  const double base_q = vp9_convert_qindex_to_q ( cm -> base_qindex ) ; const int base_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + cm -> y_dc_delta_q ) ; int i ; if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ;  vp9_clear_system_state ( ) ;   for ( i = ENERGY_MIN ; i <= ENERGY_MAX ; i ++ ) {   int qindex_delta , segment_rdmult ;   if ( Q_RATIO ( i ) == 1 ) {  RDMULT_RATIO ( i ) = 1 ; continue ; }  qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ;   vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ;   vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ;   segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta +  cm -> y_dc_delta_q ) ; RDMULT_RATIO ( i ) = ( double ) segment_rdmult / base_rdmult ; } } }","struct segmentation * seg = & cm -> seg ;vpx_clear_system_state ( ) ;for ( i = 0 ;i < MAX_SEGMENTS ;++ i ) {int qindex_delta , segment_rdmult ;if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) {qindex_delta = - cm -> base_qindex + 1 ;}if ( rate_ratio [ i ] == 1.0 ) {vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ;vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ;",1623
603,"buggy line: if ( ! net_eq ( net , & init_net ) )  return - EAFNOSUPPORT ;cwe id:CWE-000context: static int ax25_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; ax25_cb * ax25 ;  if ( ! net_eq ( net , & init_net ) )  return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_DGRAM : if ( protocol == 0 || protocol == PF_AX25 ) protocol = AX25_P_TEXT ; break ; case SOCK_SEQPACKET : switch ( protocol ) { case 0 : case PF_AX25 : protocol = AX25_P_TEXT ; break ; case AX25_P_SEGMENT : # ifdef CONFIG_INET case AX25_P_ARP : case AX25_P_IP : # endif # ifdef CONFIG_NETROM case AX25_P_NETROM : # endif # ifdef CONFIG_ROSE case AX25_P_ROSE : # endif return - ESOCKTNOSUPPORT ; # ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM : if ( ax25_protocol_is_registered ( AX25_P_NETROM ) ) return - ESOCKTNOSUPPORT ; break ; # endif # ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE : if ( ax25_protocol_is_registered ( AX25_P_ROSE ) ) return - ESOCKTNOSUPPORT ; # endif default : break ; } break ; case SOCK_RAW : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_AX25 , GFP_ATOMIC , & ax25_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; if ( ! ax25 ) { sk_free ( sk ) ; return - ENOMEM ; } sock_init_data ( sock , sk ) ; sk -> sk_destruct = ax25_free_sock ; sock -> ops = & ax25_proto_ops ; sk -> sk_protocol = protocol ; ax25 -> sk = sk ; return 0 ; }","if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;",1624
604,"buggy line: ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ;if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) {cwe id:CWE-119context: static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ;  ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ;  if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>different<S2SV_blank>planar<S2SV_blank>configuration<S2SV_blank>w/<S2SV_blank>bits/sample<S2SV_blank>!=<S2SV_blank>8\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & l ) ; if ( ! ( TIFFIsTiled ( out ) || TIFFIsTiled ( in ) ) ) { uint32 irps = ( uint32 ) - 1L ; TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & irps ) ; bychunk = ! bias && ( rowsperstrip == irps ) ; } else { if ( bias ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>tiled<S2SV_blank>configuration<S2SV_blank>w/bias<S2SV_blank>image\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } if ( TIFFIsTiled ( out ) ) { if ( ! TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ) tw = w ; if ( ! TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ) tl = l ; bychunk = ( tw == tilewidth && tl == tilelength ) ; } else { TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; bychunk = ( tw == w && tl == rowsperstrip ) ; } } # define T 1 # define F 0 # define pack ( a , b , c , d , e ) ( ( long ) ( ( ( a ) << 11 ) | ( ( b ) << 3 ) | ( ( c ) << 2 ) | ( ( d ) << 1 ) | ( e ) ) ) switch ( pack ( shortv , config , TIFFIsTiled ( in ) , TIFFIsTiled ( out ) , bychunk ) ) { case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , T ) : return cpContigStrips2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , T ) : return cpContigStrips2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , T ) : return cpSeparateStrips2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , T ) : return cpSeparateStrips2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , T ) : return cpContigTiles2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , T ) : return cpContigTiles2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , T ) : return cpSeparateTiles2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , T ) : return cpSeparateTiles2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , T ) : return cpContigTiles2ContigStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , T ) : return cpContigTiles2SeparateStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , T ) : return cpSeparateTiles2ContigStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , T ) : return cpSeparateTiles2SeparateStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , F ) : return bias ? cpBiasedContig2Contig : cpContig2ContigByRow ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , T ) : return cpDecodedStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , T ) : return cpContig2SeparateByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , T ) : return cpSeparate2ContigByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , T ) : return cpSeparate2SeparateByRow ; } # undef pack # undef F # undef T fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>copy/convert<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; }","( void ) TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & shortv ) ;if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) {",1625
605,"buggy line: if ( error -> error_code )  ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ;return error -> error_code ;cwe id:CWE-119context: static vpx_codec_err_t update_error_state ( vpx_codec_alg_priv_t * ctx , const struct vpx_internal_error_info * error ) { if ( error -> error_code )  ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ;  return error -> error_code ; }","if ( error -> error_code ) set_error_detail ( ctx , error -> has_detail ? error -> detail : NULL ) ;return error -> error_code ;",1626
606,"buggy line: for ( i = j = 0 ;i < sizeof ( buf ) - 1 && str [ i ] ;if ( str [ j ] == '#' ) {cwe id:CWE-125context: ut32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ;  for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) {  if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }",for ( i = j = 0 ;i < sizeof ( buf ) - 1 && str [ j ] ;if ( str [ j ] == '#' ) {,1627
607,"buggy line: perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;cwe id:CWE-399context: static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; }  perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ;  destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = bufhi ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = buflo ; # else current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; # endif } break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_fpu_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } return 0 ; } else { die ( ""Misaligned<S2SV_blank>FPU<S2SV_blank>load<S2SV_blank>inside<S2SV_blank>kernel"" , regs , 0 ) ; return - 1 ; } }","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;",1628
608,"buggy line: cwe id:CWE-125context: static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , ""test%u.bson"" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( ""codewscope.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( ""empty_key.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( ""overflow2.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""trailingnull.bson"" , BSON_VALIDATE_NONE , 14 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""dollarquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$query\\"""" ) ; VALIDATE_TEST ( ""dotquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOT_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\"".\\"":<S2SV_blank>\\""abc.def\\"""" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_UTF8 , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""overflow4.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""empty_key.bson"" , BSON_VALIDATE_EMPTY_KEYS , 4 , BSON_VALIDATE_EMPTY_KEYS , ""empty<S2SV_blank>key"" ) ; VALIDATE_TEST ( ""test40.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test41.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test42.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test43.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test44.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test45.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test46.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test47.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test48.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test49.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test50.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>code-with-scope"" ) ; VALIDATE_TEST ( ""test51.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>code-with-scope"" ) ; VALIDATE_TEST ( ""test52.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test53.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test54.bson"" , BSON_VALIDATE_NONE , 12 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ;  b = BCON_NEW ( ""my_dbref"" ,  ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$id\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$ref\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""extra"" , BCON_INT32 ( 2 ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""invalid<S2SV_blank>key<S2SV_blank>within<S2SV_blank>DBRef<S2SV_blank>subdocument:<S2SV_blank>\\""extra\\"""" ) ; bson_destroy ( b ) ; # undef VALIDATE_TEST }","VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ;",1629
609,"buggy line: b = BCON_NEW ( ""my_dbref"" ,  ""{cwe id:CWE-125context: static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , ""test%u.bson"" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( ""codewscope.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( ""empty_key.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( ""overflow2.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""trailingnull.bson"" , BSON_VALIDATE_NONE , 14 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""dollarquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$query\\"""" ) ; VALIDATE_TEST ( ""dotquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOT_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\"".\\"":<S2SV_blank>\\""abc.def\\"""" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_UTF8 , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""overflow4.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""empty_key.bson"" , BSON_VALIDATE_EMPTY_KEYS , 4 , BSON_VALIDATE_EMPTY_KEYS , ""empty<S2SV_blank>key"" ) ; VALIDATE_TEST ( ""test40.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test41.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test42.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test43.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test44.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test45.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test46.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test47.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test48.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test49.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test50.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>code-with-scope"" ) ; VALIDATE_TEST ( ""test51.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>code-with-scope"" ) ; VALIDATE_TEST ( ""test52.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test53.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test54.bson"" , BSON_VALIDATE_NONE , 12 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ;  b = BCON_NEW ( ""my_dbref"" ,  ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$id\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$ref\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""extra"" , BCON_INT32 ( 2 ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""invalid<S2SV_blank>key<S2SV_blank>within<S2SV_blank>DBRef<S2SV_blank>subdocument:<S2SV_blank>\\""extra\\"""" ) ; bson_destroy ( b ) ; # undef VALIDATE_TEST }","b = BCON_NEW ( ""my_dbref"" , ""{",1629
610,"buggy line: x86_pmu . extra_regs = intel_snb_extra_regs ;x86_pmu . er_flags |= ERF_HAS_RSP_1 ;cwe id:CWE-20context: __init int intel_pmu_init ( void ) { union cpuid10_edx edx ; union cpuid10_eax eax ; union cpuid10_ebx ebx ; struct event_constraint * c ; unsigned int unused ; int version ; if ( ! cpu_has ( & boot_cpu_data , X86_FEATURE_ARCH_PERFMON ) ) { switch ( boot_cpu_data . x86 ) { case 0x6 : return p6_pmu_init ( ) ; case 0xb : return knc_pmu_init ( ) ; case 0xf : return p4_pmu_init ( ) ; } return - ENODEV ; } cpuid ( 10 , & eax . full , & ebx . full , & unused , & edx . full ) ; if ( eax . split . mask_length < ARCH_PERFMON_EVENTS_COUNT ) return - ENODEV ; version = eax . split . version_id ; if ( version < 2 ) x86_pmu = core_pmu ; else x86_pmu = intel_pmu ; x86_pmu . version = version ; x86_pmu . num_counters = eax . split . num_counters ; x86_pmu . cntval_bits = eax . split . bit_width ; x86_pmu . cntval_mask = ( 1ULL << eax . split . bit_width ) - 1 ; x86_pmu . events_maskl = ebx . full ; x86_pmu . events_mask_len = eax . split . mask_length ; x86_pmu . max_pebs_events = min_t ( unsigned , MAX_PEBS_EVENTS , x86_pmu . num_counters ) ; if ( version > 1 ) x86_pmu . num_counters_fixed = max ( ( int ) edx . split . num_counters_fixed , 3 ) ; if ( version > 1 ) { u64 capabilities ; rdmsrl ( MSR_IA32_PERF_CAPABILITIES , capabilities ) ; x86_pmu . intel_cap . capabilities = capabilities ; } intel_ds_init ( ) ; x86_add_quirk ( intel_arch_events_quirk ) ; switch ( boot_cpu_data . x86_model ) { case 14 : pr_cont ( ""Core<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 15 : x86_add_quirk ( intel_clovertown_quirk ) ; case 22 : case 23 : case 29 : memcpy ( hw_cache_event_ids , core2_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_core ( ) ; x86_pmu . event_constraints = intel_core2_event_constraints ; x86_pmu . pebs_constraints = intel_core2_pebs_event_constraints ; pr_cont ( ""Core2<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 26 : case 30 : case 46 : memcpy ( hw_cache_event_ids , nehalem_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_nehalem_event_constraints ; x86_pmu . pebs_constraints = intel_nehalem_pebs_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . extra_regs = intel_nehalem_extra_regs ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; x86_add_quirk ( intel_nehalem_quirk ) ; pr_cont ( ""Nehalem<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 28 : case 38 : case 39 : case 53 : case 54 : memcpy ( hw_cache_event_ids , atom_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_atom ( ) ; x86_pmu . event_constraints = intel_gen_event_constraints ; x86_pmu . pebs_constraints = intel_atom_pebs_event_constraints ; pr_cont ( ""Atom<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 37 : case 44 : case 47 : memcpy ( hw_cache_event_ids , westmere_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_westmere_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . pebs_constraints = intel_westmere_pebs_event_constraints ; x86_pmu . extra_regs = intel_westmere_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""Westmere<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 42 : case 45 : x86_add_quirk ( intel_sandybridge_quirk ) ; memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_snb_event_constraints ; x86_pmu . pebs_constraints = intel_snb_pebs_event_constraints ; x86_pmu . pebs_aliases = intel_pebs_aliases_snb ;  x86_pmu . extra_regs = intel_snb_extra_regs ;  x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""SandyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 58 : case 62 : memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_ivb_event_constraints ; x86_pmu . pebs_constraints = intel_ivb_pebs_event_constraints ;  x86_pmu . pebs_aliases = intel_pebs_aliases_snb ;  x86_pmu . extra_regs = intel_snb_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""IvyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; default : switch ( x86_pmu . version ) { case 1 : x86_pmu . event_constraints = intel_v1_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon<S2SV_blank>v1,<S2SV_blank>"" ) ; break ; default : x86_pmu . event_constraints = intel_gen_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon,<S2SV_blank>"" ) ; break ; } } if ( x86_pmu . num_counters > INTEL_PMC_MAX_GENERIC ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters , INTEL_PMC_MAX_GENERIC ) ; x86_pmu . num_counters = INTEL_PMC_MAX_GENERIC ; } x86_pmu . intel_ctrl = ( 1 << x86_pmu . num_counters ) - 1 ; if ( x86_pmu . num_counters_fixed > INTEL_PMC_MAX_FIXED ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>fixed<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters_fixed , INTEL_PMC_MAX_FIXED ) ; x86_pmu . num_counters_fixed = INTEL_PMC_MAX_FIXED ; } x86_pmu . intel_ctrl |= ( ( 1LL << x86_pmu . num_counters_fixed ) - 1 ) << INTEL_PMC_IDX_FIXED ; if ( x86_pmu . event_constraints ) { for_each_event_constraint ( c , x86_pmu . event_constraints ) { if ( c -> cmask != X86_RAW_EVENT_MASK || c -> idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES ) { continue ; } c -> idxmsk64 |= ( 1ULL << x86_pmu . num_counters ) - 1 ; c -> weight += x86_pmu . num_counters ; } } return 0 ; }",if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ;else x86_pmu . extra_regs = intel_snb_extra_regs ;x86_pmu . er_flags |= ERF_HAS_RSP_1 ;,1630
611,"buggy line: x86_pmu . pebs_aliases = intel_pebs_aliases_snb ;x86_pmu . extra_regs = intel_snb_extra_regs ;cwe id:CWE-20context: __init int intel_pmu_init ( void ) { union cpuid10_edx edx ; union cpuid10_eax eax ; union cpuid10_ebx ebx ; struct event_constraint * c ; unsigned int unused ; int version ; if ( ! cpu_has ( & boot_cpu_data , X86_FEATURE_ARCH_PERFMON ) ) { switch ( boot_cpu_data . x86 ) { case 0x6 : return p6_pmu_init ( ) ; case 0xb : return knc_pmu_init ( ) ; case 0xf : return p4_pmu_init ( ) ; } return - ENODEV ; } cpuid ( 10 , & eax . full , & ebx . full , & unused , & edx . full ) ; if ( eax . split . mask_length < ARCH_PERFMON_EVENTS_COUNT ) return - ENODEV ; version = eax . split . version_id ; if ( version < 2 ) x86_pmu = core_pmu ; else x86_pmu = intel_pmu ; x86_pmu . version = version ; x86_pmu . num_counters = eax . split . num_counters ; x86_pmu . cntval_bits = eax . split . bit_width ; x86_pmu . cntval_mask = ( 1ULL << eax . split . bit_width ) - 1 ; x86_pmu . events_maskl = ebx . full ; x86_pmu . events_mask_len = eax . split . mask_length ; x86_pmu . max_pebs_events = min_t ( unsigned , MAX_PEBS_EVENTS , x86_pmu . num_counters ) ; if ( version > 1 ) x86_pmu . num_counters_fixed = max ( ( int ) edx . split . num_counters_fixed , 3 ) ; if ( version > 1 ) { u64 capabilities ; rdmsrl ( MSR_IA32_PERF_CAPABILITIES , capabilities ) ; x86_pmu . intel_cap . capabilities = capabilities ; } intel_ds_init ( ) ; x86_add_quirk ( intel_arch_events_quirk ) ; switch ( boot_cpu_data . x86_model ) { case 14 : pr_cont ( ""Core<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 15 : x86_add_quirk ( intel_clovertown_quirk ) ; case 22 : case 23 : case 29 : memcpy ( hw_cache_event_ids , core2_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_core ( ) ; x86_pmu . event_constraints = intel_core2_event_constraints ; x86_pmu . pebs_constraints = intel_core2_pebs_event_constraints ; pr_cont ( ""Core2<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 26 : case 30 : case 46 : memcpy ( hw_cache_event_ids , nehalem_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_nehalem_event_constraints ; x86_pmu . pebs_constraints = intel_nehalem_pebs_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . extra_regs = intel_nehalem_extra_regs ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; x86_add_quirk ( intel_nehalem_quirk ) ; pr_cont ( ""Nehalem<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 28 : case 38 : case 39 : case 53 : case 54 : memcpy ( hw_cache_event_ids , atom_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_atom ( ) ; x86_pmu . event_constraints = intel_gen_event_constraints ; x86_pmu . pebs_constraints = intel_atom_pebs_event_constraints ; pr_cont ( ""Atom<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 37 : case 44 : case 47 : memcpy ( hw_cache_event_ids , westmere_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_westmere_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . pebs_constraints = intel_westmere_pebs_event_constraints ; x86_pmu . extra_regs = intel_westmere_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""Westmere<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 42 : case 45 : x86_add_quirk ( intel_sandybridge_quirk ) ; memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_snb_event_constraints ; x86_pmu . pebs_constraints = intel_snb_pebs_event_constraints ; x86_pmu . pebs_aliases = intel_pebs_aliases_snb ;  x86_pmu . extra_regs = intel_snb_extra_regs ;  x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""SandyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 58 : case 62 : memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_ivb_event_constraints ; x86_pmu . pebs_constraints = intel_ivb_pebs_event_constraints ;  x86_pmu . pebs_aliases = intel_pebs_aliases_snb ;  x86_pmu . extra_regs = intel_snb_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""IvyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; default : switch ( x86_pmu . version ) { case 1 : x86_pmu . event_constraints = intel_v1_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon<S2SV_blank>v1,<S2SV_blank>"" ) ; break ; default : x86_pmu . event_constraints = intel_gen_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon,<S2SV_blank>"" ) ; break ; } } if ( x86_pmu . num_counters > INTEL_PMC_MAX_GENERIC ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters , INTEL_PMC_MAX_GENERIC ) ; x86_pmu . num_counters = INTEL_PMC_MAX_GENERIC ; } x86_pmu . intel_ctrl = ( 1 << x86_pmu . num_counters ) - 1 ; if ( x86_pmu . num_counters_fixed > INTEL_PMC_MAX_FIXED ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>fixed<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters_fixed , INTEL_PMC_MAX_FIXED ) ; x86_pmu . num_counters_fixed = INTEL_PMC_MAX_FIXED ; } x86_pmu . intel_ctrl |= ( ( 1LL << x86_pmu . num_counters_fixed ) - 1 ) << INTEL_PMC_IDX_FIXED ; if ( x86_pmu . event_constraints ) { for_each_event_constraint ( c , x86_pmu . event_constraints ) { if ( c -> cmask != X86_RAW_EVENT_MASK || c -> idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES ) { continue ; } c -> idxmsk64 |= ( 1ULL << x86_pmu . num_counters ) - 1 ; c -> weight += x86_pmu . num_counters ; } } return 0 ; }",x86_pmu . pebs_aliases = intel_pebs_aliases_snb ;if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ;else x86_pmu . extra_regs = intel_snb_extra_regs ;,1630
612,"buggy line: pocstruct_t * ps_prev_poc , * ps_cur_poc ;ih264d_free_dynamic_bufs ( ps_dec ) ;cwe id:CWE-20context: void ih264d_init_decoder ( void * ps_dec_params ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ps_dec_params ; dec_slice_params_t * ps_cur_slice ;  pocstruct_t * ps_prev_poc , * ps_cur_poc ;  ih264d_free_dynamic_bufs ( ps_dec ) ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_dec -> init_done = 0 ; ps_dec -> u4_num_cores = 1 ; ps_dec -> u2_pic_ht = ps_dec -> u2_pic_wd = 0 ; ps_dec -> u1_separate_parse = DEFAULT_SEPARATE_PARSE ; ps_dec -> u4_app_disable_deblk_frm = 0 ; ps_dec -> i4_degrade_type = 0 ; ps_dec -> i4_degrade_pics = 0 ; ps_dec -> i4_app_skip_mode = IVD_SKIP_NONE ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; memset ( ps_dec -> ps_pps , 0 , ( ( sizeof ( dec_pic_params_t ) ) * MAX_NUM_PIC_PARAMS ) ) ; memset ( ps_dec -> ps_sps , 0 , ( ( sizeof ( dec_seq_params_t ) ) * MAX_NUM_SEQ_PARAMS ) ) ; ps_dec -> p_DeblockPicture [ 0 ] = ih264d_deblock_picture_non_mbaff ; ps_dec -> p_DeblockPicture [ 1 ] = ih264d_deblock_picture_mbaff ; ps_dec -> s_cab_dec_env . pv_codec_handle = ps_dec ; ps_dec -> u4_num_fld_in_frm = 0 ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ps_dec ; ps_dec -> ps_sei -> u1_is_valid = 0 ; ps_dec -> ps_cur_pps = NULL ; ps_dec -> ps_cur_sps = NULL ; ps_dec -> u1_init_dec_flag = 0 ; ps_dec -> u1_first_slice_in_stream = 1 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u4_app_disp_width = 0 ; ps_dec -> i4_header_decoded = 0 ; ps_dec -> u4_total_frames_decoded = 0 ; ps_dec -> i4_error_code = 0 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag = 0 ; ps_dec -> ps_dec_err_status -> u1_err_flag = ACCEPT_ALL_PICS ; ps_dec -> ps_dec_err_status -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; ps_dec -> ps_dec_err_status -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; ps_dec -> ps_dec_err_status -> u4_cur_frm = INIT_FRAME ; ps_dec -> ps_dec_err_status -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; ps_dec -> u1_pr_sl_type = 0xFF ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_prev_poc = & ps_dec -> s_prev_pic_poc ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb = 0 ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] = 0 ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_poc -> u1_mmco_equalto5 = 0 ; ps_prev_poc -> i4_top_field_order_count = ps_cur_poc -> i4_top_field_order_count = 0 ; ps_prev_poc -> i4_bottom_field_order_count = ps_cur_poc -> i4_bottom_field_order_count = 0 ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field = 0 ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_poc -> u1_mmco_equalto5 = 0 ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst = 0 ; ps_cur_slice -> u1_mmco_equalto5 = 0 ; ps_cur_slice -> u2_frame_num = 0 ; ps_dec -> i4_max_poc = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> u1_recon_mb_grp = 4 ; ps_dec -> u1_second_field = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; ps_dec -> u2_crop_offset_y = 0 ; ps_dec -> u2_crop_offset_uv = 0 ; ps_dec -> i4_vui_frame_rate = - 1 ; ps_dec -> i4_pic_type = - 1 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> u1_res_changed = 0 ; ps_dec -> u1_frame_decoded_flag = 0 ; ps_dec -> u4_skip_frm_mask = SKIP_NONE ; ps_dec -> pf_cavlc_4x4res_block [ 0 ] = ih264d_cavlc_4x4res_block_totalcoeff_1 ; ps_dec -> pf_cavlc_4x4res_block [ 1 ] = ih264d_cavlc_4x4res_block_totalcoeff_2to10 ; ps_dec -> pf_cavlc_4x4res_block [ 2 ] = ih264d_cavlc_4x4res_block_totalcoeff_11to16 ; ps_dec -> pf_cavlc_parse4x4coeff [ 0 ] = ih264d_cavlc_parse4x4coeff_n0to7 ; ps_dec -> pf_cavlc_parse4x4coeff [ 1 ] = ih264d_cavlc_parse4x4coeff_n8 ; ps_dec -> pf_cavlc_parse_8x8block [ 0 ] = ih264d_cavlc_parse_8x8block_none_available ; ps_dec -> pf_cavlc_parse_8x8block [ 1 ] = ih264d_cavlc_parse_8x8block_left_available ; ps_dec -> pf_cavlc_parse_8x8block [ 2 ] = ih264d_cavlc_parse_8x8block_top_available ; ps_dec -> pf_cavlc_parse_8x8block [ 3 ] = ih264d_cavlc_parse_8x8block_both_available ; ps_dec -> pf_fill_bs1 [ 0 ] [ 0 ] = ih264d_fill_bs1_16x16mb_pslice ; ps_dec -> pf_fill_bs1 [ 0 ] [ 1 ] = ih264d_fill_bs1_non16x16mb_pslice ; ps_dec -> pf_fill_bs1 [ 1 ] [ 0 ] = ih264d_fill_bs1_16x16mb_bslice ; ps_dec -> pf_fill_bs1 [ 1 ] [ 1 ] = ih264d_fill_bs1_non16x16mb_bslice ; ps_dec -> pf_fill_bs_xtra_left_edge [ 0 ] = ih264d_fill_bs_xtra_left_edge_cur_frm ; ps_dec -> pf_fill_bs_xtra_left_edge [ 1 ] = ih264d_fill_bs_xtra_left_edge_cur_fld ; ih264d_init_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_dec -> u2_prv_frame_num = 0 ; ps_dec -> u1_top_bottom_decoded = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> s_cab_dec_env . cabac_table = gau4_ih264d_cabac_table ; ps_dec -> pu1_left_mv_ctxt_inc = ps_dec -> u1_left_mv_ctxt_inc_arr [ 0 ] ; ps_dec -> pi1_left_ref_idx_ctxt_inc = & ps_dec -> i1_left_ref_idx_ctx_inc_arr [ 0 ] [ 0 ] ; ps_dec -> pu1_left_yuv_dc_csbp = & ps_dec -> u1_yuv_dc_csbp_topmb ; ps_dec -> u1_flushfrm = 0 ; { ps_dec -> s_cab_dec_env . pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_bitstrm -> pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_cur_slice -> pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ( void * ) ps_dec ; } memset ( ps_dec -> disp_bufs , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( disp_buf_t ) ) ; memset ( ps_dec -> u4_disp_buf_mapping , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; memset ( ps_dec -> u4_disp_buf_to_be_freed , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; ih264d_init_arch ( ps_dec ) ; ih264d_init_function_ptr ( ps_dec ) ; ps_dec -> e_frm_out_mode = IVD_DISPLAY_FRAME_OUT ; ps_dec -> init_done = 1 ; }","pocstruct_t * ps_prev_poc , * ps_cur_poc ;WORD32 size ;size = sizeof ( pred_info_t ) * 2 * 32 ;memset ( ps_dec -> ps_pred , 0 , size ) ;size = sizeof ( disp_mgr_t ) ;memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ;size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ;memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ;size = sizeof ( dec_err_status_t ) ;memset ( ps_dec -> ps_dec_err_status , 0 , size ) ;size = sizeof ( sei ) ;memset ( ps_dec -> ps_sei , 0 , size ) ;size = sizeof ( dpb_commands_t ) ;memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ;size = sizeof ( dec_bit_stream_t ) ;memset ( ps_dec -> ps_bitstrm , 0 , size ) ;size = sizeof ( dec_slice_params_t ) ;memset ( ps_dec -> ps_cur_slice , 0 , size ) ;size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ;memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ;size = sizeof ( ctxt_inc_mb_info_t ) ;memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ;size = ( sizeof ( neighbouradd_t ) << 2 ) ;memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ;size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ;memset ( ps_dec -> pv_mv_buf_mgr , 0 , size ) ;ih264d_free_dynamic_bufs ( ps_dec ) ;",1631
613,"buggy line: cwe id:CWE-000context: static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ;  if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end &&  end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx &&  vma -> vm_userfaultfd_ctx . ctx != ctx ) ;  if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }",ret = - EPERM ;if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ;,1632
614,"buggy line: if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end &&  end > cur -> vm_start ) {if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ;cwe id:CWE-000context: static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ;  if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end &&  end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx &&  vma -> vm_userfaultfd_ctx . ctx != ctx ) ;  if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }",if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) {if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) ;WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) goto out_unlock ;,1632
615,"buggy line: BUG_ON ( vma -> vm_userfaultfd_ctx . ctx &&  vma -> vm_userfaultfd_ctx . ctx != ctx ) ;if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ;cwe id:CWE-000context: static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ;  if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end &&  end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx &&  vma -> vm_userfaultfd_ctx . ctx != ctx ) ;  if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }",BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ;if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ;,1632
616,"buggy line: krb5_key_data * key_data ;if ( n_key_data <= 0 ) return NULL ;if ( key_data_in == NULL )  goto cleanup ;i < n_key_data ;i ++ ) {if ( key_data [ i ] . key_data_ver == 1 ) {key_data [ i ] . key_data_ver = 2 ;key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ;key_data [ i ] . key_data_length [ 1 ] = 0 ;key_data [ i ] . key_data_contents [ 1 ] = NULL ;}}for ( i = 0 ;i < n_key_data - 1 ;i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ;ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ;if ( ret == NULL ) {err = ENOMEM ;goto cleanup ;}for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ;i < n_key_data ;i ++ ) {krb5_data * code ;if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) {ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ;if ( ret [ j ] == NULL ) goto cleanup ;err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ;if ( err ) goto cleanup ;ret [ j ] -> bv_len = code -> length ;ret [ j ] -> bv_val = code -> data ;free ( code ) ;j ++ ;last = i + 1 ;if ( i < n_key_data - 1 ) currkvno = key_data [ i + 1 ] . key_data_kvno ;}}ret [ num_versions ] = NULL ;cleanup : free ( key_data ) ;if ( err != 0 ) {if ( ret != NULL ) {for ( i = 0 ;i <= num_versions ;i ++ )   if ( ret [ i ] != NULL )  free ( ret [ i ] ) ;cwe id:CWE-000context: static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ;  krb5_key_data * key_data ;  if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ;  if ( key_data_in == NULL )  goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) { ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ; if ( ret [ j ] == NULL ) goto cleanup ; err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ; if ( err ) goto cleanup ; ret [ j ] -> bv_len = code -> length ; ret [ j ] -> bv_val = code -> data ; free ( code ) ; j ++ ; last = i + 1 ; if ( i < n_key_data - 1 ) currkvno = key_data [ i + 1 ] . key_data_kvno ; } } ret [ num_versions ] = NULL ; cleanup : free ( key_data ) ; if ( err != 0 ) { if ( ret != NULL ) {  for ( i = 0 ; i <= num_versions ; i ++ )   if ( ret [ i ] != NULL )  free ( ret [ i ] ) ; free ( ret ) ; ret = NULL ; } } return ret ; }",krb5_key_data * key_data = NULL ;if ( n_key_data < 0 ) return NULL ;if ( key_data == NULL ) goto cleanup ;ret [ i ] != NULL ;i ++ ) free ( ret [ i ] ) ;,1633
617,"buggy line: ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ;switch ( ret ) {cwe id:CWE-284context: static void btu_exec_tap_fd_read ( void * p_param ) { struct pollfd ufd ; int fd = ( int ) p_param ; if ( fd == INVALID_FD || fd != btpan_cb . tap_fd ) return ; for ( int i = 0 ; i < PAN_POOL_MAX && btif_is_enabled ( ) && btpan_cb . flow ; i ++ ) { BT_HDR * buffer = ( BT_HDR * ) GKI_getpoolbuf ( PAN_POOL_ID ) ; if ( ! buffer ) { BTIF_TRACE_WARNING ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>packet."" , __func__ ) ; break ; } buffer -> offset = PAN_MINIMUM_OFFSET ; buffer -> len = GKI_get_buf_size ( buffer ) - sizeof ( BT_HDR ) - buffer -> offset ; UINT8 * packet = ( UINT8 * ) buffer + sizeof ( BT_HDR ) + buffer -> offset ; if ( ! btpan_cb . congest_packet_size ) {  ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ;  switch ( ret ) { case - 1 : BTIF_TRACE_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>driver:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; case 0 : BTIF_TRACE_WARNING ( ""%s<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>reached."" , __func__ ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; default : btpan_cb . congest_packet_size = ret ; break ; } } memcpy ( packet , btpan_cb . congest_packet , MIN ( btpan_cb . congest_packet_size , buffer -> len ) ) ; buffer -> len = MIN ( btpan_cb . congest_packet_size , buffer -> len ) ; if ( buffer -> len > sizeof ( tETH_HDR ) && should_forward ( ( tETH_HDR * ) packet ) ) { tETH_HDR hdr ; memcpy ( & hdr , packet , sizeof ( tETH_HDR ) ) ; buffer -> len -= sizeof ( tETH_HDR ) ; buffer -> offset += sizeof ( tETH_HDR ) ; if ( forward_bnep ( & hdr , buffer ) != FORWARD_CONGEST ) btpan_cb . congest_packet_size = 0 ; } else { BTIF_TRACE_WARNING ( ""%s<S2SV_blank>dropping<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d"" , __func__ , buffer -> len ) ; btpan_cb . congest_packet_size = 0 ; GKI_freebuf ( buffer ) ; } ufd . fd = fd ; ufd . events = POLLIN ; ufd . revents = 0 ;  if ( poll ( & ufd , 1 , 0 ) <= 0 || IS_EXCEPTION ( ufd . revents ) )  break ; } btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; }","ssize_t ret = TEMP_FAILURE_RETRY ( read ( fd , btpan_cb . congest_packet ) , sizeof ( btpan_cb . congest_packet ) ) ;switch ( ret ) {",1634
618,"buggy line: if ( buffer -> len > sizeof ( tETH_HDR ) && should_forward ( ( tETH_HDR * ) packet ) ) {cwe id:CWE-284context: static void btu_exec_tap_fd_read ( void * p_param ) { struct pollfd ufd ; int fd = ( int ) p_param ; if ( fd == INVALID_FD || fd != btpan_cb . tap_fd ) return ; for ( int i = 0 ; i < PAN_POOL_MAX && btif_is_enabled ( ) && btpan_cb . flow ; i ++ ) { BT_HDR * buffer = ( BT_HDR * ) GKI_getpoolbuf ( PAN_POOL_ID ) ; if ( ! buffer ) { BTIF_TRACE_WARNING ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>packet."" , __func__ ) ; break ; } buffer -> offset = PAN_MINIMUM_OFFSET ; buffer -> len = GKI_get_buf_size ( buffer ) - sizeof ( BT_HDR ) - buffer -> offset ; UINT8 * packet = ( UINT8 * ) buffer + sizeof ( BT_HDR ) + buffer -> offset ; if ( ! btpan_cb . congest_packet_size ) {  ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ;  switch ( ret ) { case - 1 : BTIF_TRACE_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>driver:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; case 0 : BTIF_TRACE_WARNING ( ""%s<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>reached."" , __func__ ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; default : btpan_cb . congest_packet_size = ret ; break ; } } memcpy ( packet , btpan_cb . congest_packet , MIN ( btpan_cb . congest_packet_size , buffer -> len ) ) ; buffer -> len = MIN ( btpan_cb . congest_packet_size , buffer -> len ) ; if ( buffer -> len > sizeof ( tETH_HDR ) && should_forward ( ( tETH_HDR * ) packet ) ) { tETH_HDR hdr ; memcpy ( & hdr , packet , sizeof ( tETH_HDR ) ) ; buffer -> len -= sizeof ( tETH_HDR ) ; buffer -> offset += sizeof ( tETH_HDR ) ; if ( forward_bnep ( & hdr , buffer ) != FORWARD_CONGEST ) btpan_cb . congest_packet_size = 0 ; } else { BTIF_TRACE_WARNING ( ""%s<S2SV_blank>dropping<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d"" , __func__ , buffer -> len ) ; btpan_cb . congest_packet_size = 0 ; GKI_freebuf ( buffer ) ; } ufd . fd = fd ; ufd . events = POLLIN ; ufd . revents = 0 ;  if ( poll ( & ufd , 1 , 0 ) <= 0 || IS_EXCEPTION ( ufd . revents ) )  break ; } btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; }",if ( TEMP_FAILURE_RETRY ( buffer -> len > sizeof ( tETH_HDR ) && should_forward ( ( tETH_HDR * ) packet ) ) {,1634
619,"buggy line: if ( poll ( & ufd , 1 , 0 ) <= 0 || IS_EXCEPTION ( ufd . revents ) )  break ;cwe id:CWE-284context: static void btu_exec_tap_fd_read ( void * p_param ) { struct pollfd ufd ; int fd = ( int ) p_param ; if ( fd == INVALID_FD || fd != btpan_cb . tap_fd ) return ; for ( int i = 0 ; i < PAN_POOL_MAX && btif_is_enabled ( ) && btpan_cb . flow ; i ++ ) { BT_HDR * buffer = ( BT_HDR * ) GKI_getpoolbuf ( PAN_POOL_ID ) ; if ( ! buffer ) { BTIF_TRACE_WARNING ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>packet."" , __func__ ) ; break ; } buffer -> offset = PAN_MINIMUM_OFFSET ; buffer -> len = GKI_get_buf_size ( buffer ) - sizeof ( BT_HDR ) - buffer -> offset ; UINT8 * packet = ( UINT8 * ) buffer + sizeof ( BT_HDR ) + buffer -> offset ; if ( ! btpan_cb . congest_packet_size ) {  ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ;  switch ( ret ) { case - 1 : BTIF_TRACE_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>driver:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; case 0 : BTIF_TRACE_WARNING ( ""%s<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>reached."" , __func__ ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; default : btpan_cb . congest_packet_size = ret ; break ; } } memcpy ( packet , btpan_cb . congest_packet , MIN ( btpan_cb . congest_packet_size , buffer -> len ) ) ; buffer -> len = MIN ( btpan_cb . congest_packet_size , buffer -> len ) ; if ( buffer -> len > sizeof ( tETH_HDR ) && should_forward ( ( tETH_HDR * ) packet ) ) { tETH_HDR hdr ; memcpy ( & hdr , packet , sizeof ( tETH_HDR ) ) ; buffer -> len -= sizeof ( tETH_HDR ) ; buffer -> offset += sizeof ( tETH_HDR ) ; if ( forward_bnep ( & hdr , buffer ) != FORWARD_CONGEST ) btpan_cb . congest_packet_size = 0 ; } else { BTIF_TRACE_WARNING ( ""%s<S2SV_blank>dropping<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d"" , __func__ , buffer -> len ) ; btpan_cb . congest_packet_size = 0 ; GKI_freebuf ( buffer ) ; } ufd . fd = fd ; ufd . events = POLLIN ; ufd . revents = 0 ;  if ( poll ( & ufd , 1 , 0 ) <= 0 || IS_EXCEPTION ( ufd . revents ) )  break ; } btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; }","if ( poll ( & ufd , 1 , 0 ) ) <= 0 || IS_EXCEPTION ( ufd . revents ) ) break ;",1634
620,"buggy line: if ( same_thread_group ( task , current ) ) return 0 ;rcu_read_lock ( ) ;tcred = __task_cred ( task ) ;if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ;if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ;ok : rcu_read_unlock ( ) ;smp_rmb ( ) ;if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ;rcu_read_lock ( ) ;if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {rcu_read_unlock ( ) ;return - EPERM ;cwe id:CWE-264context: static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ;  if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {  rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }","if ( dumpable != SUID_DUMP_USER && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {",1635
621,"buggy line: static int su3000_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ 3 ] = {0xe , 0x80 , 0 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x02 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config ,   & d -> dev -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ;cwe id:CWE-119context:  static int su3000_frontend_attach ( struct dvb_usb_adapter * d )  { u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ;  if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  obuf [ 0 ] = 0xe ;   obuf [ 1 ] = 0x02 ;   obuf [ 2 ] = 1 ;   if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  msleep ( 300 ) ;  obuf [ 0 ] = 0xe ;  obuf [ 1 ] = 0x83 ;   obuf [ 2 ] = 0 ;   if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  obuf [ 0 ] = 0xe ;  obuf [ 1 ] = 0x83 ; obuf [ 2 ] = 1 ;  if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config ,   & d -> dev -> i2c_adap ) ;   if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;  if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {  info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ; return 0 ; } info ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>DS3000/TS2020!"" ) ; return - EIO ; }","static int su3000_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x02 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x83 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x83 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config , & d -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ;if ( adap -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ;",1636
622,"buggy line: static int getnum ( const char * * fmt , int df ) {if ( ! isdigit ( * * fmt ) ) return df ;do {a = a * 10 + * ( ( * fmt ) ++ ) - \'0\' ;cwe id:CWE-190context:  static int getnum ( const char * * fmt , int df ) {  if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ;  do {  a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }","static int getnum ( lua_State * L , const char * * fmt , int df ) {if ( ! isdigit ( * * fmt ) ) return df ;do {if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - \'0\' ) ) ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>overflow"" ) ;a = a * 10 + * ( ( * fmt ) ++ ) - \'0\' ;",1637
623,"buggy line: markold ( g , g -> survival , g -> reallyold ) ;markold ( g , g -> finobj , g -> finobjrold ) ;cwe id:CWE-125context: static void youngcollection ( lua_State * L , global_State * g ) { GCObject * * psurvival ; lua_assert ( g -> gcstate == GCSpropagate ) ;  markold ( g , g -> survival , g -> reallyold ) ;  markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( L ) ; psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; sweepgen ( L , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( L , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( L , g , & g -> tobefnz , NULL ) ; finishgencycle ( L , g ) ; }","markold ( g , g -> allgc , g -> reallyold ) ;markold ( g , g -> finobj , g -> finobjrold ) ;",1638
624,"buggy line: else  return - EIO ;deb_info ( ""Identify<S2SV_blank>state<S2SV_blank>cold<S2SV_blank>=<S2SV_blank>%d\\\cwe id:CWE-401context: static int af9005_identify_state ( struct usb_device * udev , struct dvb_usb_device_properties * props , struct dvb_usb_device_description * * desc , int * cold ) { int ret ; u8 reply , * buf ; buf = kmalloc ( FW_BULKOUT_SIZE + 2 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; ret = af9005_boot_packet ( udev , FW_CONFIG , & reply , buf , FW_BULKOUT_SIZE + 2 ) ; if ( ret ) goto err ; deb_info ( ""result<S2SV_blank>of<S2SV_blank>FW_CONFIG<S2SV_blank>in<S2SV_blank>identify<S2SV_blank>state<S2SV_blank>%d\\n"" , reply ) ; if ( reply == 0x01 ) * cold = 1 ; else if ( reply == 0x02 ) * cold = 0 ; else  return - EIO ;  deb_info ( ""Identify<S2SV_blank>state<S2SV_blank>cold<S2SV_blank>=<S2SV_blank>%d\\n"" , * cold ) ; err : kfree ( buf ) ; return ret ; }","else ret = - EIO ;if ( ! ret ) deb_info ( ""Identify<S2SV_blank>state<S2SV_blank>cold<S2SV_blank>=<S2SV_blank>%d\\\",1639
625,"buggy line: ( void ) opt ;if ( phase != PROTOCOL_EARLY )  return NULL ;memset ( buffer , 0 , sizeof buffer ) ;s_read ( c , c -> local_rfd . fd , buffer , sizeof buffer ) ;if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) {s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ;throw_exception ( c , 1 ) ;}s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ;return NULL ;cwe id:CWE-295context: NOEXPORT char * pgsql_server ( CLI * c , SERVICE_OPTIONS * opt , const PHASE phase ) { uint8_t buffer [ 8 ] , ssl_ok [ 1 ] = { 'S' } ;  ( void ) opt ;  if ( phase != PROTOCOL_EARLY )  return NULL ;  memset ( buffer , 0 , sizeof buffer ) ; s_read ( c , c -> local_rfd . fd , buffer , sizeof buffer ) ;  if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) {   s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ;  throw_exception ( c , 1 ) ; }  s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ;  return NULL ; }","static const uint8_t gss_request [ 8 ] = {0 , 0 , 0 , 8 , 0x04 , 0xd2 , 0x16 , 0x30 };static const uint8_t gss_response [ 62 ] = {\'E\' , 0 , 0 , 0 , 61 , \'S\' , \'E\' , \'R\' , \'R\' , \'O\' , \'R\' , 0 , \'C\' , \'X\' , \'X\' , \'0\' , \'0\' , \'0\' , 0 , \'M\' , \'S\' , \'S\' , \'L\' , \'<S2SV_blank>\' , \'e\' , \'x\' , \'p\' , \'e\' , \'c\' , \'t\' , \'e\' , \'d\' , \'<S2SV_blank>\' , \'b\' , \'u\' , \'t\' , \'<S2SV_blank>\' , \'n\' , \'o\' , \'t\' , \'<S2SV_blank>\' , \'r\' , \'e\' , \'q\' , \'u\' , \'e\' , \'s\' , \'t\' , \'e\' , \'d\' , \'<S2SV_blank>\' , \'b\' , \'y\' , \'<S2SV_blank>\' , \'c\' , \'l\' , \'i\' , \'e\' , \'n\' , \'t\' , 0 , 0 };( void ) opt ;if ( phase != PROTOCOL_EARLY ) return NULL ;s_log ( LOG_DEBUG , ""Started<S2SV_blank>server-side<S2SV_blank>psql<S2SV_blank>protcol<S2SV_blank>negotiation"" ) ;memset ( buffer , gss_request , sizeof gss_request ) ) {s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ;throw_exception ( c , 1 ) ;}s_write ( c , c -> local_wfd . fd , gss_response , sizeof gss_response ) ;throw_exception ( c , 2 ) ;}if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) {s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ;throw_exception ( c , 1 ) ;}s_log ( LOG_DEBUG , ""SSLRequest<S2SV_blank>received"" ) ;s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ;return NULL ;",1640
626,"buggy line: static int  cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection )  {struct sockaddr_in addr ;int rc = 0 ;char * server = private -> server ;int ret_ga ;static struct mainloop_fd_callbacks cib_fd_callbacks =  {. dispatch = cib_remote_dispatch ,   . destroy = cib_remote_connection_destroy ,  }sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ;if ( sock == - 1 ) {crm_perror ( LOG_ERR , ""Socket<S2SV_blank>creation<S2SV_blank>failed"" ) ;return - 1 ;}bzero ( & hints , sizeof ( struct addrinfo ) ) ;hints . ai_flags = AI_CANONNAME ;hints . ai_family = AF_INET ;hints . ai_socktype = SOCK_RAW ;if ( hints . ai_family == AF_INET6 ) {hints . ai_protocol = IPPROTO_ICMPV6 ;}else {hints . ai_protocol = IPPROTO_ICMP ;}crm_debug ( ""Looking<S2SV_blank>up<S2SV_blank>%s"" , server ) ;ret_ga = getaddrinfo ( server , NULL , & hints , & res ) ;if ( ret_ga ) {crm_err ( ""getaddrinfo:<S2SV_blank>%s"" , gai_strerror ( ret_ga ) ) ;close ( sock ) ;return - 1 ;}if ( res -> ai_canonname ) {server = res -> ai_canonname ;}crm_debug ( ""Got<S2SV_blank>address<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , server , private -> server ) ;if ( ! res -> ai_addr ) {fprintf ( stderr , ""getaddrinfo<S2SV_blank>failed"" ) ;crm_exit ( 1 ) ;}# if 1 memcpy ( & addr , res -> ai_addr , res -> ai_addrlen ) ;# else memset ( & addr , 0 , sizeof ( addr ) ) ;addr . sin_family = AF_INET ;addr . sin_addr . s_addr = inet_addr ( server ) ;# endif addr . sin_port = htons ( private -> port ) ;if ( connect ( sock , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) {crm_perror ( LOG_ERR , ""Connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ;close ( sock ) ;return - 1 ;# ifdef HAVE_GNUTLS_GNUTLS_H  gnutls_global_init ( ) ;gnutls_anon_allocate_client_credentials ( & anon_cred_c ) ;connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ;if ( connection -> session == NULL ) {close ( sock ) ;cib_tls_close ( cib ) ;cwe id:CWE-399context: static int  cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection )  { int sock ; cib_remote_opaque_t * private = cib -> variant_opaque ;  struct sockaddr_in addr ;  int rc = 0 ;  char * server = private -> server ;  int ret_ga ; struct addrinfo * res ; struct addrinfo hints ; xmlNode * answer = NULL ; xmlNode * login = NULL ; static struct mainloop_fd_callbacks cib_fd_callbacks =  {   . dispatch = cib_remote_dispatch ,   . destroy = cib_remote_connection_destroy ,  } ; connection -> socket = 0 ; connection -> session = NULL ;  sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ;  if ( sock == - 1 ) { crm_perror ( LOG_ERR , ""Socket<S2SV_blank>creation<S2SV_blank>failed"" ) ; return - 1 ; } bzero ( & hints , sizeof ( struct addrinfo ) ) ; hints . ai_flags = AI_CANONNAME ; hints . ai_family = AF_INET ; hints . ai_socktype = SOCK_RAW ; if ( hints . ai_family == AF_INET6 ) { hints . ai_protocol = IPPROTO_ICMPV6 ; } else { hints . ai_protocol = IPPROTO_ICMP ; } crm_debug ( ""Looking<S2SV_blank>up<S2SV_blank>%s"" , server ) ; ret_ga = getaddrinfo ( server , NULL , & hints , & res ) ; if ( ret_ga ) { crm_err ( ""getaddrinfo:<S2SV_blank>%s"" , gai_strerror ( ret_ga ) ) ; close ( sock ) ; return - 1 ; } if ( res -> ai_canonname ) { server = res -> ai_canonname ; } crm_debug ( ""Got<S2SV_blank>address<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , server , private -> server ) ; if ( ! res -> ai_addr ) { fprintf ( stderr , ""getaddrinfo<S2SV_blank>failed"" ) ; crm_exit ( 1 ) ; } # if 1 memcpy ( & addr , res -> ai_addr , res -> ai_addrlen ) ; # else memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = inet_addr ( server ) ; # endif addr . sin_port = htons ( private -> port ) ; if ( connect ( sock , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) { crm_perror ( LOG_ERR , ""Connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ; close ( sock ) ; return - 1 ; } if ( connection -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H  gnutls_global_init ( ) ;  gnutls_anon_allocate_client_credentials ( & anon_cred_c ) ;  connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ;  if ( connection -> session == NULL ) { crm_perror ( LOG_ERR , ""Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ;  close ( sock ) ;  cib_tls_close ( cib ) ; return - 1 ; } # else return - EPROTONOSUPPORT ; # endif } else { connection -> session = GUINT_TO_POINTER ( sock ) ; } login = create_xml_node ( NULL , ""cib_command"" ) ; crm_xml_add ( login , ""op"" , ""authenticate"" ) ; crm_xml_add ( login , ""user"" , private -> user ) ; crm_xml_add ( login , ""password"" , private -> passwd ) ; crm_xml_add ( login , ""hidden"" , ""password"" ) ; crm_send_remote_msg ( connection -> session , login , connection -> encrypted ) ; free_xml ( login ) ;  answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ;  crm_log_xml_trace ( answer , ""Reply"" ) ; if ( answer == NULL ) { rc = - EPROTO ; } else { const char * msg_type = crm_element_value ( answer , F_CIB_OPERATION ) ; const char * tmp_ticket = crm_element_value ( answer , F_CIB_CLIENTID ) ; if ( safe_str_neq ( msg_type , CRM_OP_REGISTER ) ) { crm_err ( ""Invalid<S2SV_blank>registration<S2SV_blank>message:<S2SV_blank>%s"" , msg_type ) ; rc = - EPROTO ; } else if ( tmp_ticket == NULL ) { rc = - EPROTO ; } else { connection -> token = strdup ( tmp_ticket ) ; } }  if ( rc != 0 ) {  cib_tls_close ( cib ) ;  }  connection -> socket = sock ; connection -> source = mainloop_add_fd ( ""cib-remote"" , G_PRIORITY_HIGH , connection -> socket , cib , & cib_fd_callbacks ) ; return rc ; }","static int cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection , gboolean event_channel ) {int rc = 0 ;char * server = private -> server ;int ret_ga ;static struct mainloop_fd_callbacks cib_fd_callbacks = {0 , }cib_fd_callbacks . dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch ;cib_fd_callbacks . destroy = cib_remote_connection_destroy ;sock = crm_remote_tcp_connect ( private -> server , private -> port ) ;if ( sock <= 0 ) {crm_perror ( LOG_ERR , ""remote<S2SV_blank>tcp<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> server , private -> port ) ;connection -> socket = sock ;# ifdef HAVE_GNUTLS_GNUTLS_H if ( remote_gnutls_credentials_init == FALSE ) {gnutls_global_init ( ) ;gnutls_anon_allocate_client_credentials ( & anon_cred_c ) ;connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ;if ( connection -> session == NULL ) {close ( sock ) ;cib_tls_close ( cib ) ;",1641
627,"buggy line: crm_send_remote_msg ( connection -> session , login , connection -> encrypted ) ;answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ;crm_log_xml_trace ( answer , ""Reply"" ) ;cwe id:CWE-399context: static int  cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection )  { int sock ; cib_remote_opaque_t * private = cib -> variant_opaque ;  struct sockaddr_in addr ;  int rc = 0 ;  char * server = private -> server ;  int ret_ga ; struct addrinfo * res ; struct addrinfo hints ; xmlNode * answer = NULL ; xmlNode * login = NULL ; static struct mainloop_fd_callbacks cib_fd_callbacks =  {   . dispatch = cib_remote_dispatch ,   . destroy = cib_remote_connection_destroy ,  } ; connection -> socket = 0 ; connection -> session = NULL ;  sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ;  if ( sock == - 1 ) { crm_perror ( LOG_ERR , ""Socket<S2SV_blank>creation<S2SV_blank>failed"" ) ; return - 1 ; } bzero ( & hints , sizeof ( struct addrinfo ) ) ; hints . ai_flags = AI_CANONNAME ; hints . ai_family = AF_INET ; hints . ai_socktype = SOCK_RAW ; if ( hints . ai_family == AF_INET6 ) { hints . ai_protocol = IPPROTO_ICMPV6 ; } else { hints . ai_protocol = IPPROTO_ICMP ; } crm_debug ( ""Looking<S2SV_blank>up<S2SV_blank>%s"" , server ) ; ret_ga = getaddrinfo ( server , NULL , & hints , & res ) ; if ( ret_ga ) { crm_err ( ""getaddrinfo:<S2SV_blank>%s"" , gai_strerror ( ret_ga ) ) ; close ( sock ) ; return - 1 ; } if ( res -> ai_canonname ) { server = res -> ai_canonname ; } crm_debug ( ""Got<S2SV_blank>address<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , server , private -> server ) ; if ( ! res -> ai_addr ) { fprintf ( stderr , ""getaddrinfo<S2SV_blank>failed"" ) ; crm_exit ( 1 ) ; } # if 1 memcpy ( & addr , res -> ai_addr , res -> ai_addrlen ) ; # else memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = inet_addr ( server ) ; # endif addr . sin_port = htons ( private -> port ) ; if ( connect ( sock , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) { crm_perror ( LOG_ERR , ""Connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ; close ( sock ) ; return - 1 ; } if ( connection -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H  gnutls_global_init ( ) ;  gnutls_anon_allocate_client_credentials ( & anon_cred_c ) ;  connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ;  if ( connection -> session == NULL ) { crm_perror ( LOG_ERR , ""Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ;  close ( sock ) ;  cib_tls_close ( cib ) ; return - 1 ; } # else return - EPROTONOSUPPORT ; # endif } else { connection -> session = GUINT_TO_POINTER ( sock ) ; } login = create_xml_node ( NULL , ""cib_command"" ) ; crm_xml_add ( login , ""op"" , ""authenticate"" ) ; crm_xml_add ( login , ""user"" , private -> user ) ; crm_xml_add ( login , ""password"" , private -> passwd ) ; crm_xml_add ( login , ""hidden"" , ""password"" ) ; crm_send_remote_msg ( connection -> session , login , connection -> encrypted ) ; free_xml ( login ) ;  answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ;  crm_log_xml_trace ( answer , ""Reply"" ) ; if ( answer == NULL ) { rc = - EPROTO ; } else { const char * msg_type = crm_element_value ( answer , F_CIB_OPERATION ) ; const char * tmp_ticket = crm_element_value ( answer , F_CIB_CLIENTID ) ; if ( safe_str_neq ( msg_type , CRM_OP_REGISTER ) ) { crm_err ( ""Invalid<S2SV_blank>registration<S2SV_blank>message:<S2SV_blank>%s"" , msg_type ) ; rc = - EPROTO ; } else if ( tmp_ticket == NULL ) { rc = - EPROTO ; } else { connection -> token = strdup ( tmp_ticket ) ; } }  if ( rc != 0 ) {  cib_tls_close ( cib ) ;  }  connection -> socket = sock ; connection -> source = mainloop_add_fd ( ""cib-remote"" , G_PRIORITY_HIGH , connection -> socket , cib , & cib_fd_callbacks ) ; return rc ; }","crm_send_remote_msg ( connection -> session , & connection -> recv_buf , login , connection -> encrypted , - 1 , & disconnected ) ;if ( disconnected ) {rc = - ENOTCONN ;}answer = crm_parse_remote_buffer ( & connection -> recv_buf ) ;answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ;crm_log_xml_trace ( answer , ""Reply"" ) ;",1641
628,"buggy line: if ( rc != 0 ) {cib_tls_close ( cib ) ;}connection -> socket = sock ;cwe id:CWE-399context: static int  cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection )  { int sock ; cib_remote_opaque_t * private = cib -> variant_opaque ;  struct sockaddr_in addr ;  int rc = 0 ;  char * server = private -> server ;  int ret_ga ; struct addrinfo * res ; struct addrinfo hints ; xmlNode * answer = NULL ; xmlNode * login = NULL ; static struct mainloop_fd_callbacks cib_fd_callbacks =  {   . dispatch = cib_remote_dispatch ,   . destroy = cib_remote_connection_destroy ,  } ; connection -> socket = 0 ; connection -> session = NULL ;  sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ;  if ( sock == - 1 ) { crm_perror ( LOG_ERR , ""Socket<S2SV_blank>creation<S2SV_blank>failed"" ) ; return - 1 ; } bzero ( & hints , sizeof ( struct addrinfo ) ) ; hints . ai_flags = AI_CANONNAME ; hints . ai_family = AF_INET ; hints . ai_socktype = SOCK_RAW ; if ( hints . ai_family == AF_INET6 ) { hints . ai_protocol = IPPROTO_ICMPV6 ; } else { hints . ai_protocol = IPPROTO_ICMP ; } crm_debug ( ""Looking<S2SV_blank>up<S2SV_blank>%s"" , server ) ; ret_ga = getaddrinfo ( server , NULL , & hints , & res ) ; if ( ret_ga ) { crm_err ( ""getaddrinfo:<S2SV_blank>%s"" , gai_strerror ( ret_ga ) ) ; close ( sock ) ; return - 1 ; } if ( res -> ai_canonname ) { server = res -> ai_canonname ; } crm_debug ( ""Got<S2SV_blank>address<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , server , private -> server ) ; if ( ! res -> ai_addr ) { fprintf ( stderr , ""getaddrinfo<S2SV_blank>failed"" ) ; crm_exit ( 1 ) ; } # if 1 memcpy ( & addr , res -> ai_addr , res -> ai_addrlen ) ; # else memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = inet_addr ( server ) ; # endif addr . sin_port = htons ( private -> port ) ; if ( connect ( sock , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) { crm_perror ( LOG_ERR , ""Connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ; close ( sock ) ; return - 1 ; } if ( connection -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H  gnutls_global_init ( ) ;  gnutls_anon_allocate_client_credentials ( & anon_cred_c ) ;  connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ;  if ( connection -> session == NULL ) { crm_perror ( LOG_ERR , ""Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ;  close ( sock ) ;  cib_tls_close ( cib ) ; return - 1 ; } # else return - EPROTONOSUPPORT ; # endif } else { connection -> session = GUINT_TO_POINTER ( sock ) ; } login = create_xml_node ( NULL , ""cib_command"" ) ; crm_xml_add ( login , ""op"" , ""authenticate"" ) ; crm_xml_add ( login , ""user"" , private -> user ) ; crm_xml_add ( login , ""password"" , private -> passwd ) ; crm_xml_add ( login , ""hidden"" , ""password"" ) ; crm_send_remote_msg ( connection -> session , login , connection -> encrypted ) ; free_xml ( login ) ;  answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ;  crm_log_xml_trace ( answer , ""Reply"" ) ; if ( answer == NULL ) { rc = - EPROTO ; } else { const char * msg_type = crm_element_value ( answer , F_CIB_OPERATION ) ; const char * tmp_ticket = crm_element_value ( answer , F_CIB_CLIENTID ) ; if ( safe_str_neq ( msg_type , CRM_OP_REGISTER ) ) { crm_err ( ""Invalid<S2SV_blank>registration<S2SV_blank>message:<S2SV_blank>%s"" , msg_type ) ; rc = - EPROTO ; } else if ( tmp_ticket == NULL ) { rc = - EPROTO ; } else { connection -> token = strdup ( tmp_ticket ) ; } }  if ( rc != 0 ) {  cib_tls_close ( cib ) ;  }  connection -> socket = sock ; connection -> source = mainloop_add_fd ( ""cib-remote"" , G_PRIORITY_HIGH , connection -> socket , cib , & cib_fd_callbacks ) ; return rc ; }","free_xml ( answer ) ;answer = NULL ;if ( rc != 0 ) {cib_tls_close ( cib ) ;return rc ;}crm_trace ( ""remote<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>established"" ) ;",1641
629,"buggy line: vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ;if ( setjmp ( cm -> error . jmp ) ) {cwe id:CWE-119context: struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ;  vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ;  if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ;  cpi -> kf_overspend_bits = 0 ;  cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; cpi -> twopass . gf_decay_rate = 0 ; cpi -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; cpi -> gold_is_last = 0 ; cpi -> alt_is_last = 0 ; cpi -> gold_is_alt = 0 ; cpi -> active_map_enabled = 0 ; # if 0 if ( cpi -> pass == 0 ) { cpi -> one_pass_frame_index = 0 ; for ( i = 0 ; i < MAX_LAG_BUFFERS ; i ++ ) { cpi -> one_pass_frame_stats [ i ] . frames_so_far = 0 ; cpi -> one_pass_frame_stats [ i ] . frame_intra_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_coded_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_inter = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_motion = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr_abs = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc_abs = 0.0 ; } } # endif  cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ;   cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ;  cpi -> cyclic_refresh_mode_index = 0 ; cpi -> cyclic_refresh_q = 32 ; if ( cpi -> cyclic_refresh_mode_enabled ) { CHECK_MEM_ERROR ( cpi -> cyclic_refresh_map , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; } else cpi -> cyclic_refresh_map = ( signed char * ) NULL ;  # ifdef VP8_ENTROPY_STATS  init_context_counters ( ) ; # endif cpi -> activity_avg = 90 << 12 ; cpi -> frames_since_key = 8 ; cpi -> key_frame_frequency = cpi -> oxcf . key_freq ; cpi -> this_key_frame_forced = 0 ; cpi -> next_key_frame_forced = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 0 ; cpi -> common . refresh_alt_ref_frame = 0 ;  cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ;  # if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ; cpi -> count = 0 ; cpi -> bytes = 0 ; if ( cpi -> b_calculate_psnr ) { cpi -> total_sq_error = 0.0 ; cpi -> total_sq_error2 = 0.0 ; cpi -> total_y = 0.0 ; cpi -> total_u = 0.0 ; cpi -> total_v = 0.0 ; cpi -> total = 0.0 ; cpi -> totalp_y = 0.0 ; cpi -> totalp_u = 0.0 ; cpi -> totalp_v = 0.0 ; cpi -> totalp = 0.0 ; cpi -> tot_recode_hits = 0 ; cpi -> summed_quality = 0 ; cpi -> summed_weights = 0 ; } if ( cpi -> b_calculate_ssimg ) { cpi -> total_ssimg_y = 0 ; cpi -> total_ssimg_u = 0 ; cpi -> total_ssimg_v = 0 ; cpi -> total_ssimg_all = 0 ; } # endif cpi -> first_time_stamp_ever = 0x7FFFFFFF ; cpi -> frames_till_gf_update_due = 0 ; cpi -> key_frame_count = 1 ; cpi -> ni_av_qi = cpi -> oxcf . worst_allowed_q ; cpi -> ni_tot_qi = 0 ; cpi -> ni_frames = 0 ; cpi -> total_byte_count = 0 ; cpi -> drop_frame = 0 ; cpi -> rate_correction_factor = 1.0 ; cpi -> key_frame_rate_correction_factor = 1.0 ; cpi -> gf_rate_correction_factor = 1.0 ; cpi -> twopass . est_max_qcorrection_factor = 1.0 ; for ( i = 0 ; i < KEY_FRAME_CONTEXT ; i ++ ) { cpi -> prior_key_frame_distance [ i ] = ( int ) cpi -> output_framerate ; } # ifdef OUTPUT_YUV_SRC yuv_file = fopen ( ""bd.yuv"" , ""ab"" ) ; # endif  # if 0  framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ; kf_list = fopen ( ""kf_list.stt"" , ""w"" ) ; # endif cpi -> output_pkt_list = oxcf -> output_pkt_list ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { vp8_init_first_pass ( cpi ) ; } else if ( cpi -> pass == 2 ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int packets = ( int ) ( oxcf -> two_pass_stats_in . sz / packet_sz ) ; cpi -> twopass . stats_in_start = oxcf -> two_pass_stats_in . buf ; cpi -> twopass . stats_in = cpi -> twopass . stats_in_start ; cpi -> twopass . stats_in_end = ( void * ) ( ( char * ) cpi -> twopass . stats_in + ( packets - 1 ) * packet_sz ) ; vp8_init_second_pass ( cpi ) ; } # endif if ( cpi -> compressor_speed == 2 ) { cpi -> avg_encode_time = 0 ; cpi -> avg_pick_mode_time = 0 ; } vp8_set_speed_features ( cpi ) ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mb . rd_thresh_mult [ i ] = 128 ; } # ifdef VP8_ENTROPY_STATS init_mv_ref_counts ( ) ; # endif # if CONFIG_MULTITHREAD if ( vp8cx_create_encoder_threads ( cpi ) ) { vp8_remove_compressor ( & cpi ) ; return 0 ; } # endif  cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ;  cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ;  cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ;  cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ;  cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ;  # if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_16X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_4X4 ] . copymem = vp8_copy32xn ; # endif cpi -> full_search_sad = vp8_full_search_sad ; cpi -> diamond_search_sad = vp8_diamond_search_sad ; cpi -> refining_search_sad = vp8_refining_search_sad ; cpi -> mb . error_bins [ 0 ] = cpi -> common . MBs ; vp8cx_init_quantizer ( cpi ) ; vp8_loop_filter_init ( cm ) ; cpi -> common . error . setjmp = 0 ; # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id > 0 ) vp8_cal_low_res_mb_cols ( cpi ) ; # endif cpi -> mb . mvcost [ 0 ] = & cpi -> rd_costs . mvcosts [ 0 ] [ mv_max + 1 ] ; cpi -> mb . mvcost [ 1 ] = & cpi -> rd_costs . mvcosts [ 1 ] [ mv_max + 1 ] ; cpi -> mb . mvsadcost [ 0 ] = & cpi -> rd_costs . mvsadcosts [ 0 ] [ mvfp_max + 1 ] ; cpi -> mb . mvsadcost [ 1 ] = & cpi -> rd_costs . mvsadcosts [ 1 ] [ mvfp_max + 1 ] ; cal_mvsadcosts ( cpi -> mb . mvsadcost ) ; cpi -> mb . mbmode_cost = cpi -> rd_costs . mbmode_cost ; cpi -> mb . intra_uv_mode_cost = cpi -> rd_costs . intra_uv_mode_cost ; cpi -> mb . bmode_costs = cpi -> rd_costs . bmode_costs ; cpi -> mb . inter_bmode_costs = cpi -> rd_costs . inter_bmode_costs ; cpi -> mb . token_costs = cpi -> rd_costs . token_costs ; vp8_setup_block_ptrs ( & cpi -> mb ) ; vp8_setup_block_dptrs ( & cpi -> mb . e_mbd ) ; return cpi ; }","memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ;if ( setjmp ( cm -> error . jmp ) ) {",1642
630,"buggy line: cpi -> kf_overspend_bits = 0 ;cpi -> kf_bitrate_adjustment = 0 ;cwe id:CWE-119context: struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ;  vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ;  if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ;  cpi -> kf_overspend_bits = 0 ;  cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; cpi -> twopass . gf_decay_rate = 0 ; cpi -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; cpi -> gold_is_last = 0 ; cpi -> alt_is_last = 0 ; cpi -> gold_is_alt = 0 ; cpi -> active_map_enabled = 0 ; # if 0 if ( cpi -> pass == 0 ) { cpi -> one_pass_frame_index = 0 ; for ( i = 0 ; i < MAX_LAG_BUFFERS ; i ++ ) { cpi -> one_pass_frame_stats [ i ] . frames_so_far = 0 ; cpi -> one_pass_frame_stats [ i ] . frame_intra_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_coded_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_inter = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_motion = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr_abs = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc_abs = 0.0 ; } } # endif  cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ;   cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ;  cpi -> cyclic_refresh_mode_index = 0 ; cpi -> cyclic_refresh_q = 32 ; if ( cpi -> cyclic_refresh_mode_enabled ) { CHECK_MEM_ERROR ( cpi -> cyclic_refresh_map , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; } else cpi -> cyclic_refresh_map = ( signed char * ) NULL ;  # ifdef VP8_ENTROPY_STATS  init_context_counters ( ) ; # endif cpi -> activity_avg = 90 << 12 ; cpi -> frames_since_key = 8 ; cpi -> key_frame_frequency = cpi -> oxcf . key_freq ; cpi -> this_key_frame_forced = 0 ; cpi -> next_key_frame_forced = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 0 ; cpi -> common . refresh_alt_ref_frame = 0 ;  cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ;  # if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ; cpi -> count = 0 ; cpi -> bytes = 0 ; if ( cpi -> b_calculate_psnr ) { cpi -> total_sq_error = 0.0 ; cpi -> total_sq_error2 = 0.0 ; cpi -> total_y = 0.0 ; cpi -> total_u = 0.0 ; cpi -> total_v = 0.0 ; cpi -> total = 0.0 ; cpi -> totalp_y = 0.0 ; cpi -> totalp_u = 0.0 ; cpi -> totalp_v = 0.0 ; cpi -> totalp = 0.0 ; cpi -> tot_recode_hits = 0 ; cpi -> summed_quality = 0 ; cpi -> summed_weights = 0 ; } if ( cpi -> b_calculate_ssimg ) { cpi -> total_ssimg_y = 0 ; cpi -> total_ssimg_u = 0 ; cpi -> total_ssimg_v = 0 ; cpi -> total_ssimg_all = 0 ; } # endif cpi -> first_time_stamp_ever = 0x7FFFFFFF ; cpi -> frames_till_gf_update_due = 0 ; cpi -> key_frame_count = 1 ; cpi -> ni_av_qi = cpi -> oxcf . worst_allowed_q ; cpi -> ni_tot_qi = 0 ; cpi -> ni_frames = 0 ; cpi -> total_byte_count = 0 ; cpi -> drop_frame = 0 ; cpi -> rate_correction_factor = 1.0 ; cpi -> key_frame_rate_correction_factor = 1.0 ; cpi -> gf_rate_correction_factor = 1.0 ; cpi -> twopass . est_max_qcorrection_factor = 1.0 ; for ( i = 0 ; i < KEY_FRAME_CONTEXT ; i ++ ) { cpi -> prior_key_frame_distance [ i ] = ( int ) cpi -> output_framerate ; } # ifdef OUTPUT_YUV_SRC yuv_file = fopen ( ""bd.yuv"" , ""ab"" ) ; # endif  # if 0  framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ; kf_list = fopen ( ""kf_list.stt"" , ""w"" ) ; # endif cpi -> output_pkt_list = oxcf -> output_pkt_list ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { vp8_init_first_pass ( cpi ) ; } else if ( cpi -> pass == 2 ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int packets = ( int ) ( oxcf -> two_pass_stats_in . sz / packet_sz ) ; cpi -> twopass . stats_in_start = oxcf -> two_pass_stats_in . buf ; cpi -> twopass . stats_in = cpi -> twopass . stats_in_start ; cpi -> twopass . stats_in_end = ( void * ) ( ( char * ) cpi -> twopass . stats_in + ( packets - 1 ) * packet_sz ) ; vp8_init_second_pass ( cpi ) ; } # endif if ( cpi -> compressor_speed == 2 ) { cpi -> avg_encode_time = 0 ; cpi -> avg_pick_mode_time = 0 ; } vp8_set_speed_features ( cpi ) ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mb . rd_thresh_mult [ i ] = 128 ; } # ifdef VP8_ENTROPY_STATS init_mv_ref_counts ( ) ; # endif # if CONFIG_MULTITHREAD if ( vp8cx_create_encoder_threads ( cpi ) ) { vp8_remove_compressor ( & cpi ) ; return 0 ; } # endif  cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ;  cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ;  cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ;  cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ;  cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ;  # if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_16X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_4X4 ] . copymem = vp8_copy32xn ; # endif cpi -> full_search_sad = vp8_full_search_sad ; cpi -> diamond_search_sad = vp8_diamond_search_sad ; cpi -> refining_search_sad = vp8_refining_search_sad ; cpi -> mb . error_bins [ 0 ] = cpi -> common . MBs ; vp8cx_init_quantizer ( cpi ) ; vp8_loop_filter_init ( cm ) ; cpi -> common . error . setjmp = 0 ; # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id > 0 ) vp8_cal_low_res_mb_cols ( cpi ) ; # endif cpi -> mb . mvcost [ 0 ] = & cpi -> rd_costs . mvcosts [ 0 ] [ mv_max + 1 ] ; cpi -> mb . mvcost [ 1 ] = & cpi -> rd_costs . mvcosts [ 1 ] [ mv_max + 1 ] ; cpi -> mb . mvsadcost [ 0 ] = & cpi -> rd_costs . mvsadcosts [ 0 ] [ mvfp_max + 1 ] ; cpi -> mb . mvsadcost [ 1 ] = & cpi -> rd_costs . mvsadcosts [ 1 ] [ mvfp_max + 1 ] ; cal_mvsadcosts ( cpi -> mb . mvsadcost ) ; cpi -> mb . mbmode_cost = cpi -> rd_costs . mbmode_cost ; cpi -> mb . intra_uv_mode_cost = cpi -> rd_costs . intra_uv_mode_cost ; cpi -> mb . bmode_costs = cpi -> rd_costs . bmode_costs ; cpi -> mb . inter_bmode_costs = cpi -> rd_costs . inter_bmode_costs ; cpi -> mb . token_costs = cpi -> rd_costs . token_costs ; vp8_setup_block_ptrs ( & cpi -> mb ) ; vp8_setup_block_dptrs ( & cpi -> mb . e_mbd ) ; return cpi ; }",cpi -> temporal_layer_id = - 1 ;cpi -> kf_overspend_bits = 0 ;cpi -> kf_bitrate_adjustment = 0 ;,1642
631,"buggy line: # endif  cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ;cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ;cpi -> cyclic_refresh_mode_index = 0 ;# ifdef VP8_ENTROPY_STATS  init_context_counters ( ) ;cwe id:CWE-119context: struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ;  vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ;  if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ;  cpi -> kf_overspend_bits = 0 ;  cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; cpi -> twopass . gf_decay_rate = 0 ; cpi -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; cpi -> gold_is_last = 0 ; cpi -> alt_is_last = 0 ; cpi -> gold_is_alt = 0 ; cpi -> active_map_enabled = 0 ; # if 0 if ( cpi -> pass == 0 ) { cpi -> one_pass_frame_index = 0 ; for ( i = 0 ; i < MAX_LAG_BUFFERS ; i ++ ) { cpi -> one_pass_frame_stats [ i ] . frames_so_far = 0 ; cpi -> one_pass_frame_stats [ i ] . frame_intra_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_coded_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_inter = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_motion = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr_abs = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc_abs = 0.0 ; } } # endif  cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ;   cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ;  cpi -> cyclic_refresh_mode_index = 0 ; cpi -> cyclic_refresh_q = 32 ; if ( cpi -> cyclic_refresh_mode_enabled ) { CHECK_MEM_ERROR ( cpi -> cyclic_refresh_map , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; } else cpi -> cyclic_refresh_map = ( signed char * ) NULL ;  # ifdef VP8_ENTROPY_STATS  init_context_counters ( ) ; # endif cpi -> activity_avg = 90 << 12 ; cpi -> frames_since_key = 8 ; cpi -> key_frame_frequency = cpi -> oxcf . key_freq ; cpi -> this_key_frame_forced = 0 ; cpi -> next_key_frame_forced = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 0 ; cpi -> common . refresh_alt_ref_frame = 0 ;  cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ;  # if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ; cpi -> count = 0 ; cpi -> bytes = 0 ; if ( cpi -> b_calculate_psnr ) { cpi -> total_sq_error = 0.0 ; cpi -> total_sq_error2 = 0.0 ; cpi -> total_y = 0.0 ; cpi -> total_u = 0.0 ; cpi -> total_v = 0.0 ; cpi -> total = 0.0 ; cpi -> totalp_y = 0.0 ; cpi -> totalp_u = 0.0 ; cpi -> totalp_v = 0.0 ; cpi -> totalp = 0.0 ; cpi -> tot_recode_hits = 0 ; cpi -> summed_quality = 0 ; cpi -> summed_weights = 0 ; } if ( cpi -> b_calculate_ssimg ) { cpi -> total_ssimg_y = 0 ; cpi -> total_ssimg_u = 0 ; cpi -> total_ssimg_v = 0 ; cpi -> total_ssimg_all = 0 ; } # endif cpi -> first_time_stamp_ever = 0x7FFFFFFF ; cpi -> frames_till_gf_update_due = 0 ; cpi -> key_frame_count = 1 ; cpi -> ni_av_qi = cpi -> oxcf . worst_allowed_q ; cpi -> ni_tot_qi = 0 ; cpi -> ni_frames = 0 ; cpi -> total_byte_count = 0 ; cpi -> drop_frame = 0 ; cpi -> rate_correction_factor = 1.0 ; cpi -> key_frame_rate_correction_factor = 1.0 ; cpi -> gf_rate_correction_factor = 1.0 ; cpi -> twopass . est_max_qcorrection_factor = 1.0 ; for ( i = 0 ; i < KEY_FRAME_CONTEXT ; i ++ ) { cpi -> prior_key_frame_distance [ i ] = ( int ) cpi -> output_framerate ; } # ifdef OUTPUT_YUV_SRC yuv_file = fopen ( ""bd.yuv"" , ""ab"" ) ; # endif  # if 0  framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ; kf_list = fopen ( ""kf_list.stt"" , ""w"" ) ; # endif cpi -> output_pkt_list = oxcf -> output_pkt_list ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { vp8_init_first_pass ( cpi ) ; } else if ( cpi -> pass == 2 ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int packets = ( int ) ( oxcf -> two_pass_stats_in . sz / packet_sz ) ; cpi -> twopass . stats_in_start = oxcf -> two_pass_stats_in . buf ; cpi -> twopass . stats_in = cpi -> twopass . stats_in_start ; cpi -> twopass . stats_in_end = ( void * ) ( ( char * ) cpi -> twopass . stats_in + ( packets - 1 ) * packet_sz ) ; vp8_init_second_pass ( cpi ) ; } # endif if ( cpi -> compressor_speed == 2 ) { cpi -> avg_encode_time = 0 ; cpi -> avg_pick_mode_time = 0 ; } vp8_set_speed_features ( cpi ) ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mb . rd_thresh_mult [ i ] = 128 ; } # ifdef VP8_ENTROPY_STATS init_mv_ref_counts ( ) ; # endif # if CONFIG_MULTITHREAD if ( vp8cx_create_encoder_threads ( cpi ) ) { vp8_remove_compressor ( & cpi ) ; return 0 ; } # endif  cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ;  cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ;  cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ;  cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ;  cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ;  # if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_16X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_4X4 ] . copymem = vp8_copy32xn ; # endif cpi -> full_search_sad = vp8_full_search_sad ; cpi -> diamond_search_sad = vp8_diamond_search_sad ; cpi -> refining_search_sad = vp8_refining_search_sad ; cpi -> mb . error_bins [ 0 ] = cpi -> common . MBs ; vp8cx_init_quantizer ( cpi ) ; vp8_loop_filter_init ( cm ) ; cpi -> common . error . setjmp = 0 ; # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id > 0 ) vp8_cal_low_res_mb_cols ( cpi ) ; # endif cpi -> mb . mvcost [ 0 ] = & cpi -> rd_costs . mvcosts [ 0 ] [ mv_max + 1 ] ; cpi -> mb . mvcost [ 1 ] = & cpi -> rd_costs . mvcosts [ 1 ] [ mv_max + 1 ] ; cpi -> mb . mvsadcost [ 0 ] = & cpi -> rd_costs . mvsadcosts [ 0 ] [ mvfp_max + 1 ] ; cpi -> mb . mvsadcost [ 1 ] = & cpi -> rd_costs . mvsadcosts [ 1 ] [ mvfp_max + 1 ] ; cal_mvsadcosts ( cpi -> mb . mvsadcost ) ; cpi -> mb . mbmode_cost = cpi -> rd_costs . mbmode_cost ; cpi -> mb . intra_uv_mode_cost = cpi -> rd_costs . intra_uv_mode_cost ; cpi -> mb . bmode_costs = cpi -> rd_costs . bmode_costs ; cpi -> mb . inter_bmode_costs = cpi -> rd_costs . inter_bmode_costs ; cpi -> mb . token_costs = cpi -> rd_costs . token_costs ; vp8_setup_block_ptrs ( & cpi -> mb ) ; vp8_setup_block_dptrs ( & cpi -> mb . e_mbd ) ; return cpi ; }","# endif cpi -> mse_source_denoised = 0 ;cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ;cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ;if ( cpi -> oxcf . number_of_layers == 1 ) {cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ;}else if ( cpi -> oxcf . number_of_layers == 2 ) {cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ;}cpi -> cyclic_refresh_mode_index = 0 ;CHECK_MEM_ERROR ( cpi -> consec_zero_last , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , 1 ) ) ;CHECK_MEM_ERROR ( cpi -> consec_zero_last_mvbias , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ;# ifdef VP8_ENTROPY_STATS init_context_counters ( ) ;cpi -> force_maxqp = 0 ;",1642
632,"buggy line: cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ;# if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ;cwe id:CWE-119context: struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ;  vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ;  if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ;  cpi -> kf_overspend_bits = 0 ;  cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; cpi -> twopass . gf_decay_rate = 0 ; cpi -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; cpi -> gold_is_last = 0 ; cpi -> alt_is_last = 0 ; cpi -> gold_is_alt = 0 ; cpi -> active_map_enabled = 0 ; # if 0 if ( cpi -> pass == 0 ) { cpi -> one_pass_frame_index = 0 ; for ( i = 0 ; i < MAX_LAG_BUFFERS ; i ++ ) { cpi -> one_pass_frame_stats [ i ] . frames_so_far = 0 ; cpi -> one_pass_frame_stats [ i ] . frame_intra_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_coded_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_inter = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_motion = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr_abs = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc_abs = 0.0 ; } } # endif  cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ;   cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ;  cpi -> cyclic_refresh_mode_index = 0 ; cpi -> cyclic_refresh_q = 32 ; if ( cpi -> cyclic_refresh_mode_enabled ) { CHECK_MEM_ERROR ( cpi -> cyclic_refresh_map , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; } else cpi -> cyclic_refresh_map = ( signed char * ) NULL ;  # ifdef VP8_ENTROPY_STATS  init_context_counters ( ) ; # endif cpi -> activity_avg = 90 << 12 ; cpi -> frames_since_key = 8 ; cpi -> key_frame_frequency = cpi -> oxcf . key_freq ; cpi -> this_key_frame_forced = 0 ; cpi -> next_key_frame_forced = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 0 ; cpi -> common . refresh_alt_ref_frame = 0 ;  cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ;  # if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ; cpi -> count = 0 ; cpi -> bytes = 0 ; if ( cpi -> b_calculate_psnr ) { cpi -> total_sq_error = 0.0 ; cpi -> total_sq_error2 = 0.0 ; cpi -> total_y = 0.0 ; cpi -> total_u = 0.0 ; cpi -> total_v = 0.0 ; cpi -> total = 0.0 ; cpi -> totalp_y = 0.0 ; cpi -> totalp_u = 0.0 ; cpi -> totalp_v = 0.0 ; cpi -> totalp = 0.0 ; cpi -> tot_recode_hits = 0 ; cpi -> summed_quality = 0 ; cpi -> summed_weights = 0 ; } if ( cpi -> b_calculate_ssimg ) { cpi -> total_ssimg_y = 0 ; cpi -> total_ssimg_u = 0 ; cpi -> total_ssimg_v = 0 ; cpi -> total_ssimg_all = 0 ; } # endif cpi -> first_time_stamp_ever = 0x7FFFFFFF ; cpi -> frames_till_gf_update_due = 0 ; cpi -> key_frame_count = 1 ; cpi -> ni_av_qi = cpi -> oxcf . worst_allowed_q ; cpi -> ni_tot_qi = 0 ; cpi -> ni_frames = 0 ; cpi -> total_byte_count = 0 ; cpi -> drop_frame = 0 ; cpi -> rate_correction_factor = 1.0 ; cpi -> key_frame_rate_correction_factor = 1.0 ; cpi -> gf_rate_correction_factor = 1.0 ; cpi -> twopass . est_max_qcorrection_factor = 1.0 ; for ( i = 0 ; i < KEY_FRAME_CONTEXT ; i ++ ) { cpi -> prior_key_frame_distance [ i ] = ( int ) cpi -> output_framerate ; } # ifdef OUTPUT_YUV_SRC yuv_file = fopen ( ""bd.yuv"" , ""ab"" ) ; # endif  # if 0  framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ; kf_list = fopen ( ""kf_list.stt"" , ""w"" ) ; # endif cpi -> output_pkt_list = oxcf -> output_pkt_list ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { vp8_init_first_pass ( cpi ) ; } else if ( cpi -> pass == 2 ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int packets = ( int ) ( oxcf -> two_pass_stats_in . sz / packet_sz ) ; cpi -> twopass . stats_in_start = oxcf -> two_pass_stats_in . buf ; cpi -> twopass . stats_in = cpi -> twopass . stats_in_start ; cpi -> twopass . stats_in_end = ( void * ) ( ( char * ) cpi -> twopass . stats_in + ( packets - 1 ) * packet_sz ) ; vp8_init_second_pass ( cpi ) ; } # endif if ( cpi -> compressor_speed == 2 ) { cpi -> avg_encode_time = 0 ; cpi -> avg_pick_mode_time = 0 ; } vp8_set_speed_features ( cpi ) ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mb . rd_thresh_mult [ i ] = 128 ; } # ifdef VP8_ENTROPY_STATS init_mv_ref_counts ( ) ; # endif # if CONFIG_MULTITHREAD if ( vp8cx_create_encoder_threads ( cpi ) ) { vp8_remove_compressor ( & cpi ) ; return 0 ; } # endif  cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ;  cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ;  cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ;  cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ;  cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ;  # if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_16X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_4X4 ] . copymem = vp8_copy32xn ; # endif cpi -> full_search_sad = vp8_full_search_sad ; cpi -> diamond_search_sad = vp8_diamond_search_sad ; cpi -> refining_search_sad = vp8_refining_search_sad ; cpi -> mb . error_bins [ 0 ] = cpi -> common . MBs ; vp8cx_init_quantizer ( cpi ) ; vp8_loop_filter_init ( cm ) ; cpi -> common . error . setjmp = 0 ; # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id > 0 ) vp8_cal_low_res_mb_cols ( cpi ) ; # endif cpi -> mb . mvcost [ 0 ] = & cpi -> rd_costs . mvcosts [ 0 ] [ mv_max + 1 ] ; cpi -> mb . mvcost [ 1 ] = & cpi -> rd_costs . mvcosts [ 1 ] [ mv_max + 1 ] ; cpi -> mb . mvsadcost [ 0 ] = & cpi -> rd_costs . mvsadcosts [ 0 ] [ mvfp_max + 1 ] ; cpi -> mb . mvsadcost [ 1 ] = & cpi -> rd_costs . mvsadcosts [ 1 ] [ mvfp_max + 1 ] ; cal_mvsadcosts ( cpi -> mb . mvsadcost ) ; cpi -> mb . mbmode_cost = cpi -> rd_costs . mbmode_cost ; cpi -> mb . intra_uv_mode_cost = cpi -> rd_costs . intra_uv_mode_cost ; cpi -> mb . bmode_costs = cpi -> rd_costs . bmode_costs ; cpi -> mb . inter_bmode_costs = cpi -> rd_costs . inter_bmode_costs ; cpi -> mb . token_costs = cpi -> rd_costs . token_costs ; vp8_setup_block_ptrs ( & cpi -> mb ) ; vp8_setup_block_dptrs ( & cpi -> mb . e_mbd ) ; return cpi ; }",cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ;# if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ;,1642
633,"buggy line: # endif  # if 0  framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ;cwe id:CWE-119context: struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ;  vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ;  if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ;  cpi -> kf_overspend_bits = 0 ;  cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; cpi -> twopass . gf_decay_rate = 0 ; cpi -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; cpi -> gold_is_last = 0 ; cpi -> alt_is_last = 0 ; cpi -> gold_is_alt = 0 ; cpi -> active_map_enabled = 0 ; # if 0 if ( cpi -> pass == 0 ) { cpi -> one_pass_frame_index = 0 ; for ( i = 0 ; i < MAX_LAG_BUFFERS ; i ++ ) { cpi -> one_pass_frame_stats [ i ] . frames_so_far = 0 ; cpi -> one_pass_frame_stats [ i ] . frame_intra_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_coded_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_inter = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_motion = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr_abs = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc_abs = 0.0 ; } } # endif  cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ;   cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ;  cpi -> cyclic_refresh_mode_index = 0 ; cpi -> cyclic_refresh_q = 32 ; if ( cpi -> cyclic_refresh_mode_enabled ) { CHECK_MEM_ERROR ( cpi -> cyclic_refresh_map , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; } else cpi -> cyclic_refresh_map = ( signed char * ) NULL ;  # ifdef VP8_ENTROPY_STATS  init_context_counters ( ) ; # endif cpi -> activity_avg = 90 << 12 ; cpi -> frames_since_key = 8 ; cpi -> key_frame_frequency = cpi -> oxcf . key_freq ; cpi -> this_key_frame_forced = 0 ; cpi -> next_key_frame_forced = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 0 ; cpi -> common . refresh_alt_ref_frame = 0 ;  cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ;  # if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ; cpi -> count = 0 ; cpi -> bytes = 0 ; if ( cpi -> b_calculate_psnr ) { cpi -> total_sq_error = 0.0 ; cpi -> total_sq_error2 = 0.0 ; cpi -> total_y = 0.0 ; cpi -> total_u = 0.0 ; cpi -> total_v = 0.0 ; cpi -> total = 0.0 ; cpi -> totalp_y = 0.0 ; cpi -> totalp_u = 0.0 ; cpi -> totalp_v = 0.0 ; cpi -> totalp = 0.0 ; cpi -> tot_recode_hits = 0 ; cpi -> summed_quality = 0 ; cpi -> summed_weights = 0 ; } if ( cpi -> b_calculate_ssimg ) { cpi -> total_ssimg_y = 0 ; cpi -> total_ssimg_u = 0 ; cpi -> total_ssimg_v = 0 ; cpi -> total_ssimg_all = 0 ; } # endif cpi -> first_time_stamp_ever = 0x7FFFFFFF ; cpi -> frames_till_gf_update_due = 0 ; cpi -> key_frame_count = 1 ; cpi -> ni_av_qi = cpi -> oxcf . worst_allowed_q ; cpi -> ni_tot_qi = 0 ; cpi -> ni_frames = 0 ; cpi -> total_byte_count = 0 ; cpi -> drop_frame = 0 ; cpi -> rate_correction_factor = 1.0 ; cpi -> key_frame_rate_correction_factor = 1.0 ; cpi -> gf_rate_correction_factor = 1.0 ; cpi -> twopass . est_max_qcorrection_factor = 1.0 ; for ( i = 0 ; i < KEY_FRAME_CONTEXT ; i ++ ) { cpi -> prior_key_frame_distance [ i ] = ( int ) cpi -> output_framerate ; } # ifdef OUTPUT_YUV_SRC yuv_file = fopen ( ""bd.yuv"" , ""ab"" ) ; # endif  # if 0  framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ; kf_list = fopen ( ""kf_list.stt"" , ""w"" ) ; # endif cpi -> output_pkt_list = oxcf -> output_pkt_list ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { vp8_init_first_pass ( cpi ) ; } else if ( cpi -> pass == 2 ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int packets = ( int ) ( oxcf -> two_pass_stats_in . sz / packet_sz ) ; cpi -> twopass . stats_in_start = oxcf -> two_pass_stats_in . buf ; cpi -> twopass . stats_in = cpi -> twopass . stats_in_start ; cpi -> twopass . stats_in_end = ( void * ) ( ( char * ) cpi -> twopass . stats_in + ( packets - 1 ) * packet_sz ) ; vp8_init_second_pass ( cpi ) ; } # endif if ( cpi -> compressor_speed == 2 ) { cpi -> avg_encode_time = 0 ; cpi -> avg_pick_mode_time = 0 ; } vp8_set_speed_features ( cpi ) ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mb . rd_thresh_mult [ i ] = 128 ; } # ifdef VP8_ENTROPY_STATS init_mv_ref_counts ( ) ; # endif # if CONFIG_MULTITHREAD if ( vp8cx_create_encoder_threads ( cpi ) ) { vp8_remove_compressor ( & cpi ) ; return 0 ; } # endif  cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ;  cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ;  cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ;  cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ;  cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ;  # if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_16X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_4X4 ] . copymem = vp8_copy32xn ; # endif cpi -> full_search_sad = vp8_full_search_sad ; cpi -> diamond_search_sad = vp8_diamond_search_sad ; cpi -> refining_search_sad = vp8_refining_search_sad ; cpi -> mb . error_bins [ 0 ] = cpi -> common . MBs ; vp8cx_init_quantizer ( cpi ) ; vp8_loop_filter_init ( cm ) ; cpi -> common . error . setjmp = 0 ; # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id > 0 ) vp8_cal_low_res_mb_cols ( cpi ) ; # endif cpi -> mb . mvcost [ 0 ] = & cpi -> rd_costs . mvcosts [ 0 ] [ mv_max + 1 ] ; cpi -> mb . mvcost [ 1 ] = & cpi -> rd_costs . mvcosts [ 1 ] [ mv_max + 1 ] ; cpi -> mb . mvsadcost [ 0 ] = & cpi -> rd_costs . mvsadcosts [ 0 ] [ mvfp_max + 1 ] ; cpi -> mb . mvsadcost [ 1 ] = & cpi -> rd_costs . mvsadcosts [ 1 ] [ mvfp_max + 1 ] ; cal_mvsadcosts ( cpi -> mb . mvsadcost ) ; cpi -> mb . mbmode_cost = cpi -> rd_costs . mbmode_cost ; cpi -> mb . intra_uv_mode_cost = cpi -> rd_costs . intra_uv_mode_cost ; cpi -> mb . bmode_costs = cpi -> rd_costs . bmode_costs ; cpi -> mb . inter_bmode_costs = cpi -> rd_costs . inter_bmode_costs ; cpi -> mb . token_costs = cpi -> rd_costs . token_costs ; vp8_setup_block_ptrs ( & cpi -> mb ) ; vp8_setup_block_dptrs ( & cpi -> mb . e_mbd ) ; return cpi ; }","# endif # ifdef OUTPUT_YUV_DENOISED yuv_denoised_file = fopen ( ""denoised.yuv"" , ""ab"" ) ;# endif # if 0 framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ;",1642
634,"buggy line: # endif  cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ;# if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ;cwe id:CWE-119context: struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ;  vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ;  if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ;  cpi -> kf_overspend_bits = 0 ;  cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; cpi -> twopass . gf_decay_rate = 0 ; cpi -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; cpi -> gold_is_last = 0 ; cpi -> alt_is_last = 0 ; cpi -> gold_is_alt = 0 ; cpi -> active_map_enabled = 0 ; # if 0 if ( cpi -> pass == 0 ) { cpi -> one_pass_frame_index = 0 ; for ( i = 0 ; i < MAX_LAG_BUFFERS ; i ++ ) { cpi -> one_pass_frame_stats [ i ] . frames_so_far = 0 ; cpi -> one_pass_frame_stats [ i ] . frame_intra_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_coded_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_inter = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_motion = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr_abs = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc_abs = 0.0 ; } } # endif  cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ;   cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ;  cpi -> cyclic_refresh_mode_index = 0 ; cpi -> cyclic_refresh_q = 32 ; if ( cpi -> cyclic_refresh_mode_enabled ) { CHECK_MEM_ERROR ( cpi -> cyclic_refresh_map , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; } else cpi -> cyclic_refresh_map = ( signed char * ) NULL ;  # ifdef VP8_ENTROPY_STATS  init_context_counters ( ) ; # endif cpi -> activity_avg = 90 << 12 ; cpi -> frames_since_key = 8 ; cpi -> key_frame_frequency = cpi -> oxcf . key_freq ; cpi -> this_key_frame_forced = 0 ; cpi -> next_key_frame_forced = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 0 ; cpi -> common . refresh_alt_ref_frame = 0 ;  cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ;  # if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ; cpi -> count = 0 ; cpi -> bytes = 0 ; if ( cpi -> b_calculate_psnr ) { cpi -> total_sq_error = 0.0 ; cpi -> total_sq_error2 = 0.0 ; cpi -> total_y = 0.0 ; cpi -> total_u = 0.0 ; cpi -> total_v = 0.0 ; cpi -> total = 0.0 ; cpi -> totalp_y = 0.0 ; cpi -> totalp_u = 0.0 ; cpi -> totalp_v = 0.0 ; cpi -> totalp = 0.0 ; cpi -> tot_recode_hits = 0 ; cpi -> summed_quality = 0 ; cpi -> summed_weights = 0 ; } if ( cpi -> b_calculate_ssimg ) { cpi -> total_ssimg_y = 0 ; cpi -> total_ssimg_u = 0 ; cpi -> total_ssimg_v = 0 ; cpi -> total_ssimg_all = 0 ; } # endif cpi -> first_time_stamp_ever = 0x7FFFFFFF ; cpi -> frames_till_gf_update_due = 0 ; cpi -> key_frame_count = 1 ; cpi -> ni_av_qi = cpi -> oxcf . worst_allowed_q ; cpi -> ni_tot_qi = 0 ; cpi -> ni_frames = 0 ; cpi -> total_byte_count = 0 ; cpi -> drop_frame = 0 ; cpi -> rate_correction_factor = 1.0 ; cpi -> key_frame_rate_correction_factor = 1.0 ; cpi -> gf_rate_correction_factor = 1.0 ; cpi -> twopass . est_max_qcorrection_factor = 1.0 ; for ( i = 0 ; i < KEY_FRAME_CONTEXT ; i ++ ) { cpi -> prior_key_frame_distance [ i ] = ( int ) cpi -> output_framerate ; } # ifdef OUTPUT_YUV_SRC yuv_file = fopen ( ""bd.yuv"" , ""ab"" ) ; # endif  # if 0  framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ; kf_list = fopen ( ""kf_list.stt"" , ""w"" ) ; # endif cpi -> output_pkt_list = oxcf -> output_pkt_list ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { vp8_init_first_pass ( cpi ) ; } else if ( cpi -> pass == 2 ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int packets = ( int ) ( oxcf -> two_pass_stats_in . sz / packet_sz ) ; cpi -> twopass . stats_in_start = oxcf -> two_pass_stats_in . buf ; cpi -> twopass . stats_in = cpi -> twopass . stats_in_start ; cpi -> twopass . stats_in_end = ( void * ) ( ( char * ) cpi -> twopass . stats_in + ( packets - 1 ) * packet_sz ) ; vp8_init_second_pass ( cpi ) ; } # endif if ( cpi -> compressor_speed == 2 ) { cpi -> avg_encode_time = 0 ; cpi -> avg_pick_mode_time = 0 ; } vp8_set_speed_features ( cpi ) ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mb . rd_thresh_mult [ i ] = 128 ; } # ifdef VP8_ENTROPY_STATS init_mv_ref_counts ( ) ; # endif # if CONFIG_MULTITHREAD if ( vp8cx_create_encoder_threads ( cpi ) ) { vp8_remove_compressor ( & cpi ) ; return 0 ; } # endif  cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ;   cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ;   cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ;  cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ;   cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ;  cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ;   cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ;  cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ;   cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ;  cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_hv = NULL ;  cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ;   cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ;  # if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_16X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_4X4 ] . copymem = vp8_copy32xn ; # endif cpi -> full_search_sad = vp8_full_search_sad ; cpi -> diamond_search_sad = vp8_diamond_search_sad ; cpi -> refining_search_sad = vp8_refining_search_sad ; cpi -> mb . error_bins [ 0 ] = cpi -> common . MBs ; vp8cx_init_quantizer ( cpi ) ; vp8_loop_filter_init ( cm ) ; cpi -> common . error . setjmp = 0 ; # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id > 0 ) vp8_cal_low_res_mb_cols ( cpi ) ; # endif cpi -> mb . mvcost [ 0 ] = & cpi -> rd_costs . mvcosts [ 0 ] [ mv_max + 1 ] ; cpi -> mb . mvcost [ 1 ] = & cpi -> rd_costs . mvcosts [ 1 ] [ mv_max + 1 ] ; cpi -> mb . mvsadcost [ 0 ] = & cpi -> rd_costs . mvsadcosts [ 0 ] [ mvfp_max + 1 ] ; cpi -> mb . mvsadcost [ 1 ] = & cpi -> rd_costs . mvsadcosts [ 1 ] [ mvfp_max + 1 ] ; cal_mvsadcosts ( cpi -> mb . mvsadcost ) ; cpi -> mb . mbmode_cost = cpi -> rd_costs . mbmode_cost ; cpi -> mb . intra_uv_mode_cost = cpi -> rd_costs . intra_uv_mode_cost ; cpi -> mb . bmode_costs = cpi -> rd_costs . bmode_costs ; cpi -> mb . inter_bmode_costs = cpi -> rd_costs . inter_bmode_costs ; cpi -> mb . token_costs = cpi -> rd_costs . token_costs ; vp8_setup_block_ptrs ( & cpi -> mb ) ; vp8_setup_block_dptrs ( & cpi -> mb . e_mbd ) ; return cpi ; }",# endif cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vpx_sad16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vpx_variance16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vpx_sub_pixel_variance16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vpx_variance_halfpixvar16x16_h ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vpx_variance_halfpixvar16x16_v ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vpx_variance_halfpixvar16x16_hv ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vpx_sad16x16x3 ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vpx_sad16x16x8 ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vpx_sad16x16x4d ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vpx_sad16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vpx_variance16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vpx_sub_pixel_variance16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vpx_sad16x8x3 ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vpx_sad16x8x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vpx_sad16x8x4d ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vpx_sad8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vpx_variance8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vpx_sub_pixel_variance8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vpx_sad8x16x3 ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vpx_sad8x16x8 ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vpx_sad8x16x4d ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vpx_sad8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vpx_variance8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vpx_sub_pixel_variance8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vpx_sad8x8x3 ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vpx_sad8x8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vpx_sad8x8x4d ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vpx_sad4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vpx_variance4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vpx_sub_pixel_variance4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vpx_sad4x4x3 ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vpx_sad4x4x8 ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vpx_sad4x4x4d ;# if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ;,1642
635,"buggy line: dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;BUG_ON ( dh == NULL ) ;cwe id:CWE-20context: static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ;  dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;  BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = ""nf_ct_dccp:<S2SV_blank>not<S2SV_blank>picking<S2SV_blank>up<S2SV_blank>existing<S2SV_blank>connection<S2SV_blank>"" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return false ; }","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;BUG_ON ( dh == NULL ) ;",1643
636,"buggy line: perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ;flags = FAULT_FLAG_ALLOW_RETRY ;cwe id:CWE-399context: static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ;  perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ;  flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY ) { if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ;  perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 ,  regs , address ) ; } else { tsk -> min_flt ++ ;  perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 ,  regs , address ) ; } if ( fault & VM_FAULT_RETRY ) { flags &= ~ FAULT_FLAG_ALLOW_RETRY ; goto retry ; } } clear_tsk_thread_flag ( tsk , TIF_PER_TRAP ) ; fault = 0 ; out_up : up_read ( & mm -> mmap_sem ) ; out : return fault ; }","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ;flags = FAULT_FLAG_ALLOW_RETRY ;",1644
637,"buggy line: perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 ,  regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 ,  regs , address ) ;cwe id:CWE-399context: static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ;  perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ;  flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY ) { if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ;  perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 ,  regs , address ) ; } else { tsk -> min_flt ++ ;  perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 ,  regs , address ) ; } if ( fault & VM_FAULT_RETRY ) { flags &= ~ FAULT_FLAG_ALLOW_RETRY ; goto retry ; } } clear_tsk_thread_flag ( tsk , TIF_PER_TRAP ) ; fault = 0 ; out_up : up_read ( & mm -> mmap_sem ) ; out : return fault ; }","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , regs , address ) ;",1644
638,"buggy line: ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]"" , len ) ) ;cwe id:CWE-125context: static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]"" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[max<S2SV_blank>resp<S2SV_blank>delay=%d]"" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[gaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>sflag"" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>robustness=%d"" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 ) { qqi = bp [ 25 ] ; } else { qqi = ( ( bp [ 25 ] & 0x0f ) | 0x10 ) << ( ( ( bp [ 25 ] & 0x70 ) >> 4 ) + 3 ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>qqi=%d"" , qqi ) ) ; } ND_TCHECK2 ( bp [ 26 ] , 2 ) ; nsrcs = EXTRACT_16BITS ( & bp [ 26 ] ) ; if ( nsrcs > 0 ) { if ( len < 28 + nsrcs * sizeof ( struct in6_addr ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources]"" ) ) ; else if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>{"" ) ) ; for ( i = 0 ; i < nsrcs ; i ++ ) { ND_TCHECK2 ( bp [ 28 + i * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 28 + i * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>}"" ) ) ; } else ND_PRINT ( ( ndo , "",<S2SV_blank>%d<S2SV_blank>source(s)"" , nsrcs ) ) ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; trunc :  ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;  return ; }","ND_PRINT ( ( ndo , ""%s"" , mldv2_tstr ) ) ;",1645
639,"buggy line: trunc :  ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;return ;cwe id:CWE-125context: static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]"" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[max<S2SV_blank>resp<S2SV_blank>delay=%d]"" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[gaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>sflag"" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>robustness=%d"" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 ) { qqi = bp [ 25 ] ; } else { qqi = ( ( bp [ 25 ] & 0x0f ) | 0x10 ) << ( ( ( bp [ 25 ] & 0x70 ) >> 4 ) + 3 ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>qqi=%d"" , qqi ) ) ; } ND_TCHECK2 ( bp [ 26 ] , 2 ) ; nsrcs = EXTRACT_16BITS ( & bp [ 26 ] ) ; if ( nsrcs > 0 ) { if ( len < 28 + nsrcs * sizeof ( struct in6_addr ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources]"" ) ) ; else if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>{"" ) ) ; for ( i = 0 ; i < nsrcs ; i ++ ) { ND_TCHECK2 ( bp [ 28 + i * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 28 + i * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>}"" ) ) ; } else ND_PRINT ( ( ndo , "",<S2SV_blank>%d<S2SV_blank>source(s)"" , nsrcs ) ) ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; trunc :  ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;  return ; }","trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;return ;",1645
640,"buggy line: case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ;cwe id:CWE-400context: bool ExprResolveBoolean ( struct xkb_context * ctx , const ExprDef * expr , bool * set_rtrn ) { bool ok = false ; const char * ident ; switch ( expr -> expr . op ) { case EXPR_VALUE : if ( expr -> expr . value_type != EXPR_TYPE_BOOLEAN ) { log_err ( ctx , ""Found<S2SV_blank>constant<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>where<S2SV_blank>boolean<S2SV_blank>was<S2SV_blank>expected\\n"" , expr_value_type_to_string ( expr -> expr . value_type ) ) ; return false ; } * set_rtrn = expr -> boolean . set ; return true ; case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ; if ( ident ) { if ( istreq ( ident , ""true"" ) || istreq ( ident , ""yes"" ) || istreq ( ident , ""on"" ) ) { * set_rtrn = true ; return true ; } else if ( istreq ( ident , ""false"" ) || istreq ( ident , ""no"" ) || istreq ( ident , ""off"" ) ) { * set_rtrn = false ; return true ; } } log_err ( ctx , ""Identifier<S2SV_blank>\\""%s\\""<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n"" , ident ) ; return false ; case EXPR_FIELD_REF : log_err ( ctx , ""Default<S2SV_blank>\\""%s.%s\\""<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n"" , xkb_atom_text ( ctx , expr -> field_ref . element ) , xkb_atom_text ( ctx , expr -> field_ref . field ) ) ; return false ; case EXPR_INVERT : case EXPR_NOT :  ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ;  if ( ok ) * set_rtrn = ! * set_rtrn ; return ok ; case EXPR_ADD : case EXPR_SUBTRACT : case EXPR_MULTIPLY : case EXPR_DIVIDE : case EXPR_ASSIGN : case EXPR_NEGATE : case EXPR_UNARY_PLUS : log_err ( ctx , ""%s<S2SV_blank>of<S2SV_blank>boolean<S2SV_blank>values<S2SV_blank>not<S2SV_blank>permitted\\n"" , expr_op_type_to_string ( expr -> expr . op ) ) ; break ; default : log_wsgo ( ctx , ""Unknown<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveBoolean\\n"" , expr -> expr . op ) ; break ; } return false ; }","case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> unary . child -> ident . ident ) ;",1646
641,"buggy line: case EXPR_INVERT : case EXPR_NOT :  ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ;if ( ok ) * set_rtrn = ! * set_rtrn ;cwe id:CWE-400context: bool ExprResolveBoolean ( struct xkb_context * ctx , const ExprDef * expr , bool * set_rtrn ) { bool ok = false ; const char * ident ; switch ( expr -> expr . op ) { case EXPR_VALUE : if ( expr -> expr . value_type != EXPR_TYPE_BOOLEAN ) { log_err ( ctx , ""Found<S2SV_blank>constant<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>where<S2SV_blank>boolean<S2SV_blank>was<S2SV_blank>expected\\n"" , expr_value_type_to_string ( expr -> expr . value_type ) ) ; return false ; } * set_rtrn = expr -> boolean . set ; return true ; case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ; if ( ident ) { if ( istreq ( ident , ""true"" ) || istreq ( ident , ""yes"" ) || istreq ( ident , ""on"" ) ) { * set_rtrn = true ; return true ; } else if ( istreq ( ident , ""false"" ) || istreq ( ident , ""no"" ) || istreq ( ident , ""off"" ) ) { * set_rtrn = false ; return true ; } } log_err ( ctx , ""Identifier<S2SV_blank>\\""%s\\""<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n"" , ident ) ; return false ; case EXPR_FIELD_REF : log_err ( ctx , ""Default<S2SV_blank>\\""%s.%s\\""<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n"" , xkb_atom_text ( ctx , expr -> field_ref . element ) , xkb_atom_text ( ctx , expr -> field_ref . field ) ) ; return false ; case EXPR_INVERT : case EXPR_NOT :  ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ;  if ( ok ) * set_rtrn = ! * set_rtrn ; return ok ; case EXPR_ADD : case EXPR_SUBTRACT : case EXPR_MULTIPLY : case EXPR_DIVIDE : case EXPR_ASSIGN : case EXPR_NEGATE : case EXPR_UNARY_PLUS : log_err ( ctx , ""%s<S2SV_blank>of<S2SV_blank>boolean<S2SV_blank>values<S2SV_blank>not<S2SV_blank>permitted\\n"" , expr_op_type_to_string ( expr -> expr . op ) ) ; break ; default : log_wsgo ( ctx , ""Unknown<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveBoolean\\n"" , expr -> expr . op ) ; break ; } return false ; }","case EXPR_INVERT : case EXPR_NOT : ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ;if ( ok ) * set_rtrn = ! * set_rtrn ;",1646
642,"buggy line: while ( ( c != \'\\\cwe id:CWE-835context: static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { if ( c == ( int ) '#' ) { char * comment ; register char * p ; size_t length ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( ( c == EOF ) || ( c == ( int ) '\\n' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) == MagickFalse ) c = ReadBlobByte ( image ) ; else { register char * p ; p = keyword ; do { if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } while ( isalnum ( c ) || ( c == '_' ) ) ; * p = '\\0' ; value_expected = MagickFalse ; while ( ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) || ( c == '=' ) ) { if ( c == '=' ) value_expected = MagickTrue ; c = ReadBlobByte ( image ) ; } if ( LocaleCompare ( keyword , ""Y"" ) == 0 ) value_expected = MagickTrue ; if ( value_expected == MagickFalse ) continue ; p = value ;  while ( ( c != '\\n' ) && ( c != '\\0' ) )  { if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; switch ( * keyword ) { case 'F' : case 'f' : { if ( LocaleCompare ( keyword , ""format"" ) == 0 ) { ( void ) CopyMagickString ( format , value , MaxTextExtent ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'G' : case 'g' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'P' : case 'p' : { if ( LocaleCompare ( keyword , ""primaries"" ) == 0 ) { float chromaticity [ 6 ] , white_point [ 2 ] ;  ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" ,  & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] ,  & white_point [ 0 ] , & white_point [ 1 ] ) ;  image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; image -> chromaticity . white_point . x = white_point [ 0 ] , image -> chromaticity . white_point . y = white_point [ 1 ] ;  break ;  } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'Y' : case 'y' : { char target [ ] = ""Y"" ; if ( strcmp ( keyword , target ) == 0 ) { int height , width ;  ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ;  image -> columns = ( size_t ) width ;  image -> rows = ( size_t ) height ;  break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } default : { ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } } } if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } if ( ( LocaleCompare ( format , ""32-bit_rle_rgbe"" ) != 0 ) && ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) SetImageColorspace ( image , RGBColorspace , exception ) ; if ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) == 0 ) ( void ) SetImageColorspace ( image , XYZColorspace , exception ) ; image -> compression = ( image -> columns < 8 ) || ( image -> columns > 0x7ffff ) ? NoCompression : RLECompression ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( image -> compression != RLECompression ) { count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ; if ( count != ( ssize_t ) ( 4 * image -> columns * sizeof ( * pixels ) ) ) break ; } else { count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ; if ( count != 4 ) break ; if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) { ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ; count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ; image -> compression = NoCompression ; } else { p = pixels ; for ( i = 0 ; i < 4 ; i ++ ) { end = & pixels [ ( i + 1 ) * image -> columns ] ; while ( p < end ) { count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ; if ( count < 1 ) break ; if ( pixel [ 0 ] > 128 ) { count = ( ssize_t ) pixel [ 0 ] - 128 ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; while ( count -- > 0 ) * p ++ = pixel [ 1 ] ; } else { count = ( ssize_t ) pixel [ 0 ] ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; * p ++ = pixel [ 1 ] ; if ( -- count > 0 ) { count = ReadBlob ( image , ( size_t ) count * sizeof ( * p ) , p ) ; if ( count < 1 ) break ; p += count ; } } } } } } q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; i = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> compression == RLECompression ) { pixel [ 0 ] = pixels [ x ] ; pixel [ 1 ] = pixels [ x + image -> columns ] ; pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ; pixel [ 3 ] = pixels [ x + 3 * image -> columns ] ; } else { pixel [ 0 ] = pixels [ i ++ ] ; pixel [ 1 ] = pixels [ i ++ ] ; pixel [ 2 ] = pixels [ i ++ ] ; pixel [ 3 ] = pixels [ i ++ ] ; } SetPixelRed ( image , 0 , q ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( pixel [ 3 ] != 0 ) { gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ; SetPixelRed ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",while ( ( c != \'\\\,1647
643,"buggy line: ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" ,  & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] ,  & white_point [ 0 ] , & white_point [ 1 ] ) ;image -> chromaticity . red_primary . x = chromaticity [ 0 ] ;break ;}cwe id:CWE-835context: static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { if ( c == ( int ) '#' ) { char * comment ; register char * p ; size_t length ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( ( c == EOF ) || ( c == ( int ) '\\n' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) == MagickFalse ) c = ReadBlobByte ( image ) ; else { register char * p ; p = keyword ; do { if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } while ( isalnum ( c ) || ( c == '_' ) ) ; * p = '\\0' ; value_expected = MagickFalse ; while ( ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) || ( c == '=' ) ) { if ( c == '=' ) value_expected = MagickTrue ; c = ReadBlobByte ( image ) ; } if ( LocaleCompare ( keyword , ""Y"" ) == 0 ) value_expected = MagickTrue ; if ( value_expected == MagickFalse ) continue ; p = value ;  while ( ( c != '\\n' ) && ( c != '\\0' ) )  { if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; switch ( * keyword ) { case 'F' : case 'f' : { if ( LocaleCompare ( keyword , ""format"" ) == 0 ) { ( void ) CopyMagickString ( format , value , MaxTextExtent ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'G' : case 'g' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'P' : case 'p' : { if ( LocaleCompare ( keyword , ""primaries"" ) == 0 ) { float chromaticity [ 6 ] , white_point [ 2 ] ;  ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" ,  & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] ,  & white_point [ 0 ] , & white_point [ 1 ] ) ;  image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; image -> chromaticity . white_point . x = white_point [ 0 ] , image -> chromaticity . white_point . y = white_point [ 1 ] ;  break ;  } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'Y' : case 'y' : { char target [ ] = ""Y"" ; if ( strcmp ( keyword , target ) == 0 ) { int height , width ;  ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ;  image -> columns = ( size_t ) width ;  image -> rows = ( size_t ) height ;  break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } default : { ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } } } if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } if ( ( LocaleCompare ( format , ""32-bit_rle_rgbe"" ) != 0 ) && ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) SetImageColorspace ( image , RGBColorspace , exception ) ; if ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) == 0 ) ( void ) SetImageColorspace ( image , XYZColorspace , exception ) ; image -> compression = ( image -> columns < 8 ) || ( image -> columns > 0x7ffff ) ? NoCompression : RLECompression ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( image -> compression != RLECompression ) { count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ; if ( count != ( ssize_t ) ( 4 * image -> columns * sizeof ( * pixels ) ) ) break ; } else { count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ; if ( count != 4 ) break ; if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) { ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ; count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ; image -> compression = NoCompression ; } else { p = pixels ; for ( i = 0 ; i < 4 ; i ++ ) { end = & pixels [ ( i + 1 ) * image -> columns ] ; while ( p < end ) { count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ; if ( count < 1 ) break ; if ( pixel [ 0 ] > 128 ) { count = ( ssize_t ) pixel [ 0 ] - 128 ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; while ( count -- > 0 ) * p ++ = pixel [ 1 ] ; } else { count = ( ssize_t ) pixel [ 0 ] ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; * p ++ = pixel [ 1 ] ; if ( -- count > 0 ) { count = ReadBlob ( image , ( size_t ) count * sizeof ( * p ) , p ) ; if ( count < 1 ) break ; p += count ; } } } } } } q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; i = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> compression == RLECompression ) { pixel [ 0 ] = pixels [ x ] ; pixel [ 1 ] = pixels [ x + image -> columns ] ; pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ; pixel [ 3 ] = pixels [ x + 3 * image -> columns ] ; } else { pixel [ 0 ] = pixels [ i ++ ] ; pixel [ 1 ] = pixels [ i ++ ] ; pixel [ 2 ] = pixels [ i ++ ] ; pixel [ 3 ] = pixels [ i ++ ] ; } SetPixelRed ( image , 0 , q ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( pixel [ 3 ] != 0 ) { gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ; SetPixelRed ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , & white_point [ 0 ] , & white_point [ 1 ] ) == 8 ) {image -> chromaticity . red_primary . x = chromaticity [ 0 ] ;}break ;}",1647
644,"buggy line: ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ;image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;break ;cwe id:CWE-835context: static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { if ( c == ( int ) '#' ) { char * comment ; register char * p ; size_t length ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( ( c == EOF ) || ( c == ( int ) '\\n' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) == MagickFalse ) c = ReadBlobByte ( image ) ; else { register char * p ; p = keyword ; do { if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } while ( isalnum ( c ) || ( c == '_' ) ) ; * p = '\\0' ; value_expected = MagickFalse ; while ( ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) || ( c == '=' ) ) { if ( c == '=' ) value_expected = MagickTrue ; c = ReadBlobByte ( image ) ; } if ( LocaleCompare ( keyword , ""Y"" ) == 0 ) value_expected = MagickTrue ; if ( value_expected == MagickFalse ) continue ; p = value ;  while ( ( c != '\\n' ) && ( c != '\\0' ) )  { if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; switch ( * keyword ) { case 'F' : case 'f' : { if ( LocaleCompare ( keyword , ""format"" ) == 0 ) { ( void ) CopyMagickString ( format , value , MaxTextExtent ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'G' : case 'g' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'P' : case 'p' : { if ( LocaleCompare ( keyword , ""primaries"" ) == 0 ) { float chromaticity [ 6 ] , white_point [ 2 ] ;  ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" ,  & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] ,  & white_point [ 0 ] , & white_point [ 1 ] ) ;  image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; image -> chromaticity . white_point . x = white_point [ 0 ] , image -> chromaticity . white_point . y = white_point [ 1 ] ;  break ;  } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'Y' : case 'y' : { char target [ ] = ""Y"" ; if ( strcmp ( keyword , target ) == 0 ) { int height , width ;  ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ;  image -> columns = ( size_t ) width ;  image -> rows = ( size_t ) height ;  break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } default : { ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } } } if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } if ( ( LocaleCompare ( format , ""32-bit_rle_rgbe"" ) != 0 ) && ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) SetImageColorspace ( image , RGBColorspace , exception ) ; if ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) == 0 ) ( void ) SetImageColorspace ( image , XYZColorspace , exception ) ; image -> compression = ( image -> columns < 8 ) || ( image -> columns > 0x7ffff ) ? NoCompression : RLECompression ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( image -> compression != RLECompression ) { count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ; if ( count != ( ssize_t ) ( 4 * image -> columns * sizeof ( * pixels ) ) ) break ; } else { count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ; if ( count != 4 ) break ; if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) { ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ; count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ; image -> compression = NoCompression ; } else { p = pixels ; for ( i = 0 ; i < 4 ; i ++ ) { end = & pixels [ ( i + 1 ) * image -> columns ] ; while ( p < end ) { count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ; if ( count < 1 ) break ; if ( pixel [ 0 ] > 128 ) { count = ( ssize_t ) pixel [ 0 ] - 128 ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; while ( count -- > 0 ) * p ++ = pixel [ 1 ] ; } else { count = ( ssize_t ) pixel [ 0 ] ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; * p ++ = pixel [ 1 ] ; if ( -- count > 0 ) { count = ReadBlob ( image , ( size_t ) count * sizeof ( * p ) , p ) ; if ( count < 1 ) break ; p += count ; } } } } } } q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; i = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> compression == RLECompression ) { pixel [ 0 ] = pixels [ x ] ; pixel [ 1 ] = pixels [ x + image -> columns ] ; pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ; pixel [ 3 ] = pixels [ x + 3 * image -> columns ] ; } else { pixel [ 0 ] = pixels [ i ++ ] ; pixel [ 1 ] = pixels [ i ++ ] ; pixel [ 2 ] = pixels [ i ++ ] ; pixel [ 3 ] = pixels [ i ++ ] ; } SetPixelRed ( image , 0 , q ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( pixel [ 3 ] != 0 ) { gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ; SetPixelRed ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) == 2 ) {image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;}break ;",1647
645,"buggy line: static int  mptctl_mpt_command ( unsigned long arg )  {struct mpt_ioctl_command karg ;MPT_ADAPTER * ioc ;int iocnum ;if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||  ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_mpt_command()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;}rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ;return rc ;cwe id:CWE-362context: static int  mptctl_mpt_command ( unsigned long arg )  { struct mpt_ioctl_command __user * uarg = ( void __user * ) arg ;  struct mpt_ioctl_command karg ;  MPT_ADAPTER * ioc ; int iocnum ; int rc ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_command ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_command<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; }  if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||  ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_mpt_command()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; }  rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ;  return rc ; }","static int mptctl_mpt_command ( MPT_ADAPTER * ioc , unsigned long arg ) {struct mpt_ioctl_command karg ;rc = mptctl_do_mpt_command ( ioc , karg , & uarg -> MF ) ;return rc ;",1648
646,"buggy line: Image  * image ;MagickBooleanType status ;cwe id:CWE-834context: static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MaxTextExtent ] , name [ MaxTextExtent ] ; Image  * image ;  MagickBooleanType status ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length ,  padding ,  value , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , ""static<S2SV_blank>short<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) {  value = XBMInteger ( image , hex_digits ) ;   * p ++ = ( unsigned char ) value ;  if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) )  * p ++ = ( unsigned char ) ( value >> 8 ) ;  } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { value = XBMInteger ( image , hex_digits ) ;  * p ++ = ( unsigned char ) value ;  } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 )  byte = ( size_t ) ( * p ++ ) ;  SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",Image * image ;int c ;MagickBooleanType status ;,1649
647,"buggy line: unsigned int bit , byte , bytes_per_line , height , length ,  padding ,  value , version , width ;cwe id:CWE-834context: static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MaxTextExtent ] , name [ MaxTextExtent ] ; Image  * image ;  MagickBooleanType status ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length ,  padding ,  value , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , ""static<S2SV_blank>short<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) {  value = XBMInteger ( image , hex_digits ) ;   * p ++ = ( unsigned char ) value ;  if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) )  * p ++ = ( unsigned char ) ( value >> 8 ) ;  } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { value = XBMInteger ( image , hex_digits ) ;  * p ++ = ( unsigned char ) value ;  } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 )  byte = ( size_t ) ( * p ++ ) ;  SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","unsigned int bit , byte , bytes_per_line , height , length , padding , version , width ;",1649
648,"buggy line: value = XBMInteger ( image , hex_digits ) ;* p ++ = ( unsigned char ) value ;if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) )  * p ++ = ( unsigned char ) ( value >> 8 ) ;}* p ++ = ( unsigned char ) value ;}cwe id:CWE-834context: static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MaxTextExtent ] , name [ MaxTextExtent ] ; Image  * image ;  MagickBooleanType status ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length ,  padding ,  value , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , ""static<S2SV_blank>short<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) {  value = XBMInteger ( image , hex_digits ) ;   * p ++ = ( unsigned char ) value ;  if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) )  * p ++ = ( unsigned char ) ( value >> 8 ) ;  } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { value = XBMInteger ( image , hex_digits ) ;  * p ++ = ( unsigned char ) value ;  } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 )  byte = ( size_t ) ( * p ++ ) ;  SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","c = XBMInteger ( image , hex_digits ) ;if ( c < 0 ) break ;* p ++ = ( unsigned char ) c ;if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) * p ++ = ( unsigned char ) ( c >> 8 ) ;}if ( c < 0 ) break ;* p ++ = ( unsigned char ) c ;}if ( EOFBlob ( image ) != MagickFalse ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}",1649
649,"buggy line: if ( bit == 0 )  byte = ( size_t ) ( * p ++ ) ;SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ;cwe id:CWE-834context: static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MaxTextExtent ] , name [ MaxTextExtent ] ; Image  * image ;  MagickBooleanType status ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length ,  padding ,  value , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , ""static<S2SV_blank>short<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) {  value = XBMInteger ( image , hex_digits ) ;   * p ++ = ( unsigned char ) value ;  if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) )  * p ++ = ( unsigned char ) ( value >> 8 ) ;  } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { value = XBMInteger ( image , hex_digits ) ;  * p ++ = ( unsigned char ) value ;  } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 )  byte = ( size_t ) ( * p ++ ) ;  SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( bit == 0 ) byte = ( unsigned int ) ( * p ++ ) ;SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ;",1649
650,"buggy line: com -> len = JAS_CAST ( uint_fast16_t , strlen ( buf ) ) ;com -> regid = JPC_COM_LATIN ;if ( ! ( com -> data = JAS_CAST ( uchar * , jas_strdup ( buf ) ) ) ) {abort ( ) ;cwe id:CWE-190context: static int jpc_enc_encodemainhdr ( jpc_enc_t * enc ) { jpc_siz_t * siz ; jpc_cod_t * cod ; jpc_qcd_t * qcd ; int i ; long startoff ; long mainhdrlen ; jpc_enc_cp_t * cp ; jpc_qcc_t * qcc ; jpc_enc_tccp_t * tccp ; uint_fast16_t cmptno ; jpc_tsfb_band_t bandinfos [ JPC_MAXBANDS ] ; jpc_fix_t mctsynweight ; jpc_enc_tcp_t * tcp ; jpc_tsfb_t * tsfb ; jpc_tsfb_band_t * bandinfo ; uint_fast16_t numbands ; uint_fast16_t bandno ; uint_fast16_t rlvlno ; uint_fast16_t analgain ; jpc_fix_t absstepsize ; char buf [ 1024 ] ; jpc_com_t * com ; cp = enc -> cp ; startoff = jas_stream_getrwcount ( enc -> out ) ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SOC ) ) ) { return - 1 ; } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannot<S2SV_blank>write<S2SV_blank>SOC<S2SV_blank>marker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SIZ ) ) ) { return - 1 ; } siz = & enc -> mrk -> parms . siz ; siz -> caps = 0 ; siz -> xoff = cp -> imgareatlx ; siz -> yoff = cp -> imgareatly ; siz -> width = cp -> refgrdwidth ; siz -> height = cp -> refgrdheight ; siz -> tilexoff = cp -> tilegrdoffx ; siz -> tileyoff = cp -> tilegrdoffy ; siz -> tilewidth = cp -> tilewidth ; siz -> tileheight = cp -> tileheight ; siz -> numcomps = cp -> numcmpts ; siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ; assert ( siz -> comps ) ; for ( i = 0 ; i < JAS_CAST ( int , cp -> numcmpts ) ; ++ i ) { siz -> comps [ i ] . prec = cp -> ccps [ i ] . prec ; siz -> comps [ i ] . sgnd = cp -> ccps [ i ] . sgnd ; siz -> comps [ i ] . hsamp = cp -> ccps [ i ] . sampgrdstepx ; siz -> comps [ i ] . vsamp = cp -> ccps [ i ] . sampgrdstepy ; } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannot<S2SV_blank>write<S2SV_blank>SIZ<S2SV_blank>marker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_COM ) ) ) { return - 1 ; } sprintf ( buf , ""Creator:<S2SV_blank>JasPer<S2SV_blank>Version<S2SV_blank>%s"" , jas_getversion ( ) ) ; com = & enc -> mrk -> parms . com ; com -> len = JAS_CAST ( uint_fast16_t , strlen ( buf ) ) ; com -> regid = JPC_COM_LATIN ;  if ( ! ( com -> data = JAS_CAST ( uchar * , jas_strdup ( buf ) ) ) ) {  abort ( ) ; } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannot<S2SV_blank>write<S2SV_blank>COM<S2SV_blank>marker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; # if 0 if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_CRG ) ) ) { return - 1 ; } crg = & enc -> mrk -> parms . crg ; crg -> comps = jas_alloc2 ( crg -> numcomps , sizeof ( jpc_crgcomp_t ) ) ; if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannot<S2SV_blank>write<S2SV_blank>CRG<S2SV_blank>marker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; # endif tcp = & cp -> tcp ; tccp = & cp -> tccp ; for ( cmptno = 0 ; cmptno < cp -> numcmpts ; ++ cmptno ) { tsfb = jpc_cod_gettsfb ( tccp -> qmfbid , tccp -> maxrlvls - 1 ) ; jpc_tsfb_getbands ( tsfb , 0 , 0 , 1 << tccp -> maxrlvls , 1 << tccp -> maxrlvls , bandinfos ) ; jpc_tsfb_destroy ( tsfb ) ; mctsynweight = jpc_mct_getsynweight ( tcp -> mctid , cmptno ) ; numbands = 3 * tccp -> maxrlvls - 2 ; for ( bandno = 0 , bandinfo = bandinfos ; bandno < numbands ; ++ bandno , ++ bandinfo ) { rlvlno = ( bandno ) ? ( ( bandno - 1 ) / 3 + 1 ) : 0 ; analgain = JPC_NOMINALGAIN ( tccp -> qmfbid , tccp -> maxrlvls , rlvlno , bandinfo -> orient ) ; if ( ! tcp -> intmode ) { absstepsize = jpc_fix_div ( jpc_inttofix ( 1 << ( analgain + 1 ) ) , bandinfo -> synenergywt ) ; } else { absstepsize = jpc_inttofix ( 1 ) ; } cp -> ccps [ cmptno ] . stepsizes [ bandno ] = jpc_abstorelstepsize ( absstepsize , cp -> ccps [ cmptno ] . prec + analgain ) ; } cp -> ccps [ cmptno ] . numstepsizes = numbands ; } if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_COD ) ) ) { return - 1 ; } cod = & enc -> mrk -> parms . cod ; cod -> csty = cp -> tccp . csty | cp -> tcp . csty ; cod -> compparms . csty = cp -> tccp . csty | cp -> tcp . csty ; cod -> compparms . numdlvls = cp -> tccp . maxrlvls - 1 ; cod -> compparms . numrlvls = cp -> tccp . maxrlvls ; cod -> prg = cp -> tcp . prg ; cod -> numlyrs = cp -> tcp . numlyrs ; cod -> compparms . cblkwidthval = JPC_COX_CBLKSIZEEXPN ( cp -> tccp . cblkwidthexpn ) ; cod -> compparms . cblkheightval = JPC_COX_CBLKSIZEEXPN ( cp -> tccp . cblkheightexpn ) ; cod -> compparms . cblksty = cp -> tccp . cblksty ; cod -> compparms . qmfbid = cp -> tccp . qmfbid ; cod -> mctrans = ( cp -> tcp . mctid != JPC_MCT_NONE ) ; if ( tccp -> csty & JPC_COX_PRT ) { for ( rlvlno = 0 ; rlvlno < tccp -> maxrlvls ; ++ rlvlno ) { cod -> compparms . rlvls [ rlvlno ] . parwidthval = tccp -> prcwidthexpns [ rlvlno ] ; cod -> compparms . rlvls [ rlvlno ] . parheightval = tccp -> prcheightexpns [ rlvlno ] ; } } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannot<S2SV_blank>write<S2SV_blank>COD<S2SV_blank>marker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_QCD ) ) ) { return - 1 ; } qcd = & enc -> mrk -> parms . qcd ; qcd -> compparms . qntsty = ( tccp -> qmfbid == JPC_COX_INS ) ? JPC_QCX_SEQNT : JPC_QCX_NOQNT ; qcd -> compparms . numstepsizes = cp -> ccps [ 0 ] . numstepsizes ; qcd -> compparms . numguard = cp -> tccp . numgbits ; qcd -> compparms . stepsizes = cp -> ccps [ 0 ] . stepsizes ; if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { return - 1 ; } qcd -> compparms . stepsizes = 0 ; jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; tccp = & cp -> tccp ; for ( cmptno = 1 ; cmptno < cp -> numcmpts ; ++ cmptno ) { if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_QCC ) ) ) { return - 1 ; } qcc = & enc -> mrk -> parms . qcc ; qcc -> compno = cmptno ; qcc -> compparms . qntsty = ( tccp -> qmfbid == JPC_COX_INS ) ? JPC_QCX_SEQNT : JPC_QCX_NOQNT ; qcc -> compparms . numstepsizes = cp -> ccps [ cmptno ] . numstepsizes ; qcc -> compparms . numguard = cp -> tccp . numgbits ; qcc -> compparms . stepsizes = cp -> ccps [ cmptno ] . stepsizes ; if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { return - 1 ; } qcc -> compparms . stepsizes = 0 ; jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; } # define MAINTLRLEN 2 mainhdrlen = jas_stream_getrwcount ( enc -> out ) - startoff ; enc -> len += mainhdrlen ; if ( enc -> cp -> totalsize != UINT_FAST32_MAX ) { uint_fast32_t overhead ; overhead = mainhdrlen + MAINTLRLEN ; enc -> mainbodysize = ( enc -> cp -> totalsize >= overhead ) ? ( enc -> cp -> totalsize - overhead ) : 0 ; } else { enc -> mainbodysize = UINT_FAST32_MAX ; } return 0 ; }","com -> len = JAS_CAST ( jas_uchar * , jas_strdup ( buf ) ) ) ) {abort ( ) ;",1650
651,"buggy line: chanmode_found = 1 ;if ( set_flag == '+' ) {cwe id:CWE-120context: void irc_mode_channel_update ( struct t_irc_server * server , struct t_irc_channel * channel , char set_flag , char chanmode , const char * argument ) { char * pos_args , * str_modes , * * argv , * pos , * ptr_arg ; char * new_modes , * new_args , str_mode [ 2 ] , * str_temp ; int argc , current_arg , chanmode_found , length ; if ( ! channel -> modes ) channel -> modes = strdup ( ""+"" ) ; if ( ! channel -> modes ) return ; argc = 0 ; argv = NULL ; pos_args = strchr ( channel -> modes , '<S2SV_blank>' ) ; if ( pos_args ) { str_modes = weechat_strndup ( channel -> modes , pos_args - channel -> modes ) ; if ( ! str_modes ) return ; pos_args ++ ; while ( pos_args [ 0 ] == '<S2SV_blank>' ) pos_args ++ ; argv = weechat_string_split ( pos_args , ""<S2SV_blank>"" , NULL , WEECHAT_STRING_SPLIT_STRIP_LEFT | WEECHAT_STRING_SPLIT_STRIP_RIGHT | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS , 0 , & argc ) ; } else { str_modes = strdup ( channel -> modes ) ; if ( ! str_modes ) return ; } new_modes = malloc ( strlen ( channel -> modes ) + 1 + 1 ) ; new_args = malloc ( ( ( pos_args ) ? strlen ( pos_args ) : 0 ) + ( ( argument ) ? 1 + strlen ( argument ) : 0 ) + 1 ) ; if ( new_modes && new_args ) { new_modes [ 0 ] = '\\0' ; new_args [ 0 ] = '\\0' ; current_arg = 0 ; chanmode_found = 0 ; pos = str_modes ; while ( pos && pos [ 0 ] ) { if ( ( pos [ 0 ] == '+' ) || ( pos [ 0 ] == '-' ) ) { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; } else { ptr_arg = NULL ; switch ( irc_mode_get_chanmode_type ( server , pos [ 0 ] ) ) { case 'A' : case 'B' : case 'C' : ptr_arg = ( current_arg < argc ) ? argv [ current_arg ] : NULL ; break ; case 'D' : break ; } if ( ptr_arg ) current_arg ++ ; if ( pos [ 0 ] == chanmode ) {  chanmode_found = 1 ;  if ( set_flag == '+' ) { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; if ( argument ) { if ( new_args [ 0 ] ) strcat ( new_args , ""<S2SV_blank>"" ) ; strcat ( new_args , argument ) ; } } }  else  { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; if ( ptr_arg ) { if ( new_args [ 0 ] ) strcat ( new_args , ""<S2SV_blank>"" ) ; strcat ( new_args , ptr_arg ) ; } } } pos ++ ; } if ( ! chanmode_found ) { if ( set_flag == '+' ) { if ( argument ) { str_mode [ 0 ] = chanmode ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; if ( new_args [ 0 ] ) strcat ( new_args , ""<S2SV_blank>"" ) ; strcat ( new_args , argument ) ; } else { pos = new_modes ; while ( pos [ 0 ] == '+' ) pos ++ ; memmove ( pos + 1 , pos , strlen ( pos ) + 1 ) ; pos [ 0 ] = chanmode ; } } } if ( new_args [ 0 ] ) { length = strlen ( new_modes ) + 1 + strlen ( new_args ) + 1 ; str_temp = malloc ( length ) ; if ( str_temp ) { snprintf ( str_temp , length , ""%s<S2SV_blank>%s"" , new_modes , new_args ) ; if ( channel -> modes ) free ( channel -> modes ) ; channel -> modes = str_temp ; } } else { if ( channel -> modes ) free ( channel -> modes ) ; channel -> modes = strdup ( new_modes ) ; } } if ( new_modes ) free ( new_modes ) ; if ( new_args ) free ( new_args ) ; if ( str_modes ) free ( str_modes ) ; if ( argv ) weechat_string_free_split ( argv ) ; }",if ( ! chanmode_found ) {chanmode_found = 1 ;if ( set_flag == '+' ) {,1651
652,"buggy line: else  {cwe id:CWE-120context: void irc_mode_channel_update ( struct t_irc_server * server , struct t_irc_channel * channel , char set_flag , char chanmode , const char * argument ) { char * pos_args , * str_modes , * * argv , * pos , * ptr_arg ; char * new_modes , * new_args , str_mode [ 2 ] , * str_temp ; int argc , current_arg , chanmode_found , length ; if ( ! channel -> modes ) channel -> modes = strdup ( ""+"" ) ; if ( ! channel -> modes ) return ; argc = 0 ; argv = NULL ; pos_args = strchr ( channel -> modes , '<S2SV_blank>' ) ; if ( pos_args ) { str_modes = weechat_strndup ( channel -> modes , pos_args - channel -> modes ) ; if ( ! str_modes ) return ; pos_args ++ ; while ( pos_args [ 0 ] == '<S2SV_blank>' ) pos_args ++ ; argv = weechat_string_split ( pos_args , ""<S2SV_blank>"" , NULL , WEECHAT_STRING_SPLIT_STRIP_LEFT | WEECHAT_STRING_SPLIT_STRIP_RIGHT | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS , 0 , & argc ) ; } else { str_modes = strdup ( channel -> modes ) ; if ( ! str_modes ) return ; } new_modes = malloc ( strlen ( channel -> modes ) + 1 + 1 ) ; new_args = malloc ( ( ( pos_args ) ? strlen ( pos_args ) : 0 ) + ( ( argument ) ? 1 + strlen ( argument ) : 0 ) + 1 ) ; if ( new_modes && new_args ) { new_modes [ 0 ] = '\\0' ; new_args [ 0 ] = '\\0' ; current_arg = 0 ; chanmode_found = 0 ; pos = str_modes ; while ( pos && pos [ 0 ] ) { if ( ( pos [ 0 ] == '+' ) || ( pos [ 0 ] == '-' ) ) { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; } else { ptr_arg = NULL ; switch ( irc_mode_get_chanmode_type ( server , pos [ 0 ] ) ) { case 'A' : case 'B' : case 'C' : ptr_arg = ( current_arg < argc ) ? argv [ current_arg ] : NULL ; break ; case 'D' : break ; } if ( ptr_arg ) current_arg ++ ; if ( pos [ 0 ] == chanmode ) {  chanmode_found = 1 ;  if ( set_flag == '+' ) { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; if ( argument ) { if ( new_args [ 0 ] ) strcat ( new_args , ""<S2SV_blank>"" ) ; strcat ( new_args , argument ) ; } } }  else  { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; if ( ptr_arg ) { if ( new_args [ 0 ] ) strcat ( new_args , ""<S2SV_blank>"" ) ; strcat ( new_args , ptr_arg ) ; } } } pos ++ ; } if ( ! chanmode_found ) { if ( set_flag == '+' ) { if ( argument ) { str_mode [ 0 ] = chanmode ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; if ( new_args [ 0 ] ) strcat ( new_args , ""<S2SV_blank>"" ) ; strcat ( new_args , argument ) ; } else { pos = new_modes ; while ( pos [ 0 ] == '+' ) pos ++ ; memmove ( pos + 1 , pos , strlen ( pos ) + 1 ) ; pos [ 0 ] = chanmode ; } } } if ( new_args [ 0 ] ) { length = strlen ( new_modes ) + 1 + strlen ( new_args ) + 1 ; str_temp = malloc ( length ) ; if ( str_temp ) { snprintf ( str_temp , length , ""%s<S2SV_blank>%s"" , new_modes , new_args ) ; if ( channel -> modes ) free ( channel -> modes ) ; channel -> modes = str_temp ; } } else { if ( channel -> modes ) free ( channel -> modes ) ; channel -> modes = strdup ( new_modes ) ; } } if ( new_modes ) free ( new_modes ) ; if ( new_args ) free ( new_args ) ; if ( str_modes ) free ( str_modes ) ; if ( argv ) weechat_string_free_split ( argv ) ; }",}else {,1651
653,"buggy line: static int decode_uniform ( vp9_reader * r ) {const int l = 8 ;const int v = vp9_read_literal ( r , l - 1 ) ;return v < m ? v : ( v << 1 ) - m + vp9_read_bit ( r ) ;}cwe id:CWE-119context:  static int decode_uniform ( vp9_reader * r ) {  const int l = 8 ; const int m = ( 1 << l ) - 191 ;  const int v = vp9_read_literal ( r , l - 1 ) ;   return v < m ? v : ( v << 1 ) - m + vp9_read_bit ( r ) ;  }","static int decode_uniform ( vpx_reader * r ) {const int l = 8 ;const int v = vpx_read_literal ( r , l - 1 ) ;return v < m ? v : ( v << 1 ) - m + vpx_read_bit ( r ) ;}",1652
654,"buggy line: int is_valid ;if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ;giterr_clear ( ) ;is_valid = error != GIT_ECERTIFICATE ;cwe id:CWE-284context: static int http_connect ( http_subtransport * t ) { int error ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , ""git_stream"" ) ; apply_proxy_config ( t ) ; error = git_stream_connect ( t -> io ) ; if ( ( ! error || error == GIT_ECERTIFICATE ) && t -> owner -> certificate_check_cb != NULL && git_stream_is_encrypted ( t -> io ) ) { git_cert * cert ;  int is_valid ;  if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ;  giterr_clear ( ) ;  is_valid = error != GIT_ECERTIFICATE ; error = t -> owner -> certificate_check_cb ( cert , is_valid , t -> connection_data . host , t -> owner -> message_cb_payload ) ; if ( error < 0 ) { if ( ! giterr_last ( ) ) giterr_set ( GITERR_NET , ""user<S2SV_blank>cancelled<S2SV_blank>certificate<S2SV_blank>check"" ) ; return error ; } } if ( error < 0 ) return error ; t -> connected = 1 ; return 0 ; }","int is_valid = ( error == GIT_OK ) ;if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ;giterr_clear ( ) ;",1653
655,"buggy line: void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) {assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ;cwe id:CWE-119context:  void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) {  assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }","void vp9_cost_tokens_skip ( int * costs , const vpx_prob * probs , vp9_tree tree ) {assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ;",1654
656,"buggy line: static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd ,  vp9_reader * r ) {if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {const REFERENCE_MODE mode =  ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ cm -> counts . comp_inter [ ctx ] [ mode ] ;cwe id:CWE-119context: static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd ,  vp9_reader * r ) {  if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { const int ctx = vp9_get_reference_mode_context ( cm , xd ) ; const REFERENCE_MODE mode =  ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ;   if ( ! cm -> frame_parallel_decoding_mode )  ++ cm -> counts . comp_inter [ ctx ] [ mode ] ; return mode ; } else { return cm -> reference_mode ; } }","static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_reader * r ) {if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {const REFERENCE_MODE mode = ( REFERENCE_MODE ) vpx_read ( r , cm -> fc -> comp_inter_prob [ ctx ] ) ;FRAME_COUNTS * counts = xd -> counts ;if ( counts ) ++ counts -> comp_inter [ ctx ] [ mode ] ;",1655
657,"buggy line: }cwe id:CWE-787context: static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , ""vCont;c;s"" ) ; } if ( ! ( action = strtok ( g -> data , "";"" ) ) ) { return send_msg ( g , ""E01"" ) ; } while ( action = strtok ( NULL , "";"" ) ) { eprintf ( ""action:<S2SV_blank>%s\\n"" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , ""ds"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; case 'c' : if ( cmd_cb ( core_ptr , ""dc"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; default : return send_msg ( g , ""E01"" ) ; } }  } ",return - 1 ;},1656
658,"buggy line: if ( ! stream )   fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ;if ( prev ) {res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) ,  & stream -> config . cfg , global -> usage ) ;stream -> config . cfg . g_timebase . den = 1000 ;stream -> config . cfg . g_w = 0 ;stream -> config . cfg . g_h = 0 ;stream -> config . stereo_fmt = STEREO_FORMAT_MONO ;stream -> config . write_webm = 1 ;# if CONFIG_WEBM_IO  stream -> ebml . last_pts_ms = - 1 ;# endif stream -> ebml . debug = global -> debug ;cwe id:CWE-119context: static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) { struct stream_state * stream ; stream = calloc ( 1 , sizeof ( * stream ) ) ;  if ( ! stream )   fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ;  if ( prev ) { memcpy ( stream , prev , sizeof ( * stream ) ) ; stream -> index ++ ; prev -> next = stream ; } else { vpx_codec_err_t res ;  res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) ,  & stream -> config . cfg , global -> usage ) ; if ( res ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n"" , vpx_codec_err_to_string ( res ) ) ; stream -> config . cfg . g_timebase . den = 1000 ; stream -> config . cfg . g_w = 0 ; stream -> config . cfg . g_h = 0 ;  stream -> config . stereo_fmt = STEREO_FORMAT_MONO ;   stream -> config . write_webm = 1 ;  # if CONFIG_WEBM_IO  stream -> ebml . last_pts_ms = - 1 ;  # endif stream -> ebml . debug = global -> debug ; if ( global -> deadline == VPX_DL_REALTIME ) stream -> config . cfg . g_lag_in_frames = 0 ; } stream -> config . out_fn = NULL ; stream -> next = NULL ; return stream ; }","if ( stream == NULL ) {fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ;}if ( prev ) {res = vpx_codec_enc_config_default ( global -> codec -> codec_interface ( ) , & stream -> config . write_webm = 1 ;# if CONFIG_WEBM_IO stream -> config . cfg , global -> usage ) ;stream -> ebml . last_pts_ns = - 1 ;stream -> ebml . writer = NULL ;stream -> ebml . segment = NULL ;# endif stream -> ebml . debug = global -> debug ;",1657
659,"buggy line: ND_PRINT ( ( ndo , ""\\\cwe id:CWE-125context: static void icmp6_opt_print ( netdissect_options * ndo , const u_char * bp , int resid ) { const struct nd_opt_hdr * op ; const struct nd_opt_prefix_info * opp ; const struct nd_opt_mtu * opm ; const struct nd_opt_rdnss * oprd ; const struct nd_opt_dnssl * opds ; const struct nd_opt_advinterval * opa ; const struct nd_opt_homeagent_info * oph ; const struct nd_opt_route_info * opri ; const u_char * cp , * ep , * domp ; struct in6_addr in6 ; const struct in6_addr * in6p ; size_t l ; u_int i ; # define ECHECK ( var ) if ( ( const u_char * ) & ( var ) > ep - sizeof ( var ) ) return cp = bp ; ep = ndo -> ndo_snapend ; while ( cp < ep ) { op = ( const struct nd_opt_hdr * ) cp ; ECHECK ( op -> nd_opt_len ) ; if ( resid <= 0 ) return ; if ( op -> nd_opt_len == 0 ) goto trunc ; if ( cp + ( op -> nd_opt_len << 3 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(%u):<S2SV_blank>"" , tok2str ( icmp6_opt_values , ""unknown"" , op -> nd_opt_type ) , op -> nd_opt_type , op -> nd_opt_len << 3 , op -> nd_opt_len ) ) ; switch ( op -> nd_opt_type ) { case ND_OPT_SOURCE_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_TARGET_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_PREFIX_INFORMATION : opp = ( const struct nd_opt_prefix_info * ) op ; ND_TCHECK ( opp -> nd_opt_pi_prefix ) ; ND_PRINT ( ( ndo , ""%s/%u%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>valid<S2SV_blank>time<S2SV_blank>%s"" , ip6addr_string ( ndo , & opp -> nd_opt_pi_prefix ) , opp -> nd_opt_pi_prefix_len , ( op -> nd_opt_len != 4 ) ? ""badlen"" : """" , bittok2str ( icmp6_opt_pi_flag_values , ""none"" , opp -> nd_opt_pi_flags_reserved ) , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_valid_time ) ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>pref.<S2SV_blank>time<S2SV_blank>%s"" , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_preferred_time ) ) ) ) ; break ; case ND_OPT_REDIRECTED_HEADER : print_unknown_data ( ndo , bp , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , op -> nd_opt_len << 3 ) ; break ; case ND_OPT_MTU : opm = ( const struct nd_opt_mtu * ) op ; ND_TCHECK ( opm -> nd_opt_mtu_mtu ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u%s"" , EXTRACT_32BITS ( & opm -> nd_opt_mtu_mtu ) , ( op -> nd_opt_len != 1 ) ? ""bad<S2SV_blank>option<S2SV_blank>length"" : """" ) ) ; break ; case ND_OPT_RDNSS : oprd = ( const struct nd_opt_rdnss * ) op ; l = ( op -> nd_opt_len - 1 ) / 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime<S2SV_blank>%us,"" , EXTRACT_32BITS ( & oprd -> nd_opt_rdnss_lifetime ) ) ) ; for ( i = 0 ; i < l ; i ++ ) { ND_TCHECK ( oprd -> nd_opt_rdnss_addr [ i ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>addr:<S2SV_blank>%s"" , ip6addr_string ( ndo , & oprd -> nd_opt_rdnss_addr [ i ] ) ) ) ; } break ; case ND_OPT_DNSSL : opds = ( const struct nd_opt_dnssl * ) op ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>domain(s):"" , EXTRACT_32BITS ( & opds -> nd_opt_dnssl_lifetime ) ) ) ; domp = cp + 8 ; while ( domp < cp + ( op -> nd_opt_len << 3 ) && * domp != '\\0' ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( domp = ns_nprint ( ndo , domp , bp ) ) == NULL ) goto trunc ; } break ; case ND_OPT_ADVINTERVAL : opa = ( const struct nd_opt_advinterval * ) op ; ND_TCHECK ( opa -> nd_opt_adv_interval ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%ums"" , EXTRACT_32BITS ( & opa -> nd_opt_adv_interval ) ) ) ; break ; case ND_OPT_HOMEAGENT_INFO : oph = ( const struct nd_opt_homeagent_info * ) op ; ND_TCHECK ( oph -> nd_opt_hai_lifetime ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>preference<S2SV_blank>%u,<S2SV_blank>lifetime<S2SV_blank>%u"" , EXTRACT_16BITS ( & oph -> nd_opt_hai_preference ) , EXTRACT_16BITS ( & oph -> nd_opt_hai_lifetime ) ) ) ; break ; case ND_OPT_ROUTE_INFO : opri = ( const struct nd_opt_route_info * ) op ; ND_TCHECK ( opri -> nd_opt_rti_lifetime ) ; memset ( & in6 , 0 , sizeof ( in6 ) ) ; in6p = ( const struct in6_addr * ) ( opri + 1 ) ; switch ( op -> nd_opt_len ) { case 1 : break ; case 2 : ND_TCHECK2 ( * in6p , 8 ) ; memcpy ( & in6 , opri + 1 , 8 ) ; break ; case 3 : ND_TCHECK ( * in6p ) ; memcpy ( & in6 , opri + 1 , sizeof ( in6 ) ) ; break ; default : goto trunc ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s/%u"" , ip6addr_string ( ndo , & in6 ) , opri -> nd_opt_rti_prefixlen ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>pref=%s"" , get_rtpref ( opri -> nd_opt_rti_flags ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>lifetime=%s"" , get_lifetime ( EXTRACT_32BITS ( & opri -> nd_opt_rti_lifetime ) ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , cp + 2 , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ( op -> nd_opt_len << 3 ) - 2 ) ; return ; } break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , cp + 2 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , ( op -> nd_opt_len << 3 ) - 2 ) ; cp += op -> nd_opt_len << 3 ; resid -= op -> nd_opt_len << 3 ; } return ; trunc :  ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ;  return ; # undef ECHECK }","ND_PRINT ( ( ndo , ""%s"" , icmp6_tstr ) ) ;",1658
660,"buggy line: trunc :  ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ;return ;cwe id:CWE-125context: static void icmp6_opt_print ( netdissect_options * ndo , const u_char * bp , int resid ) { const struct nd_opt_hdr * op ; const struct nd_opt_prefix_info * opp ; const struct nd_opt_mtu * opm ; const struct nd_opt_rdnss * oprd ; const struct nd_opt_dnssl * opds ; const struct nd_opt_advinterval * opa ; const struct nd_opt_homeagent_info * oph ; const struct nd_opt_route_info * opri ; const u_char * cp , * ep , * domp ; struct in6_addr in6 ; const struct in6_addr * in6p ; size_t l ; u_int i ; # define ECHECK ( var ) if ( ( const u_char * ) & ( var ) > ep - sizeof ( var ) ) return cp = bp ; ep = ndo -> ndo_snapend ; while ( cp < ep ) { op = ( const struct nd_opt_hdr * ) cp ; ECHECK ( op -> nd_opt_len ) ; if ( resid <= 0 ) return ; if ( op -> nd_opt_len == 0 ) goto trunc ; if ( cp + ( op -> nd_opt_len << 3 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(%u):<S2SV_blank>"" , tok2str ( icmp6_opt_values , ""unknown"" , op -> nd_opt_type ) , op -> nd_opt_type , op -> nd_opt_len << 3 , op -> nd_opt_len ) ) ; switch ( op -> nd_opt_type ) { case ND_OPT_SOURCE_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_TARGET_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_PREFIX_INFORMATION : opp = ( const struct nd_opt_prefix_info * ) op ; ND_TCHECK ( opp -> nd_opt_pi_prefix ) ; ND_PRINT ( ( ndo , ""%s/%u%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>valid<S2SV_blank>time<S2SV_blank>%s"" , ip6addr_string ( ndo , & opp -> nd_opt_pi_prefix ) , opp -> nd_opt_pi_prefix_len , ( op -> nd_opt_len != 4 ) ? ""badlen"" : """" , bittok2str ( icmp6_opt_pi_flag_values , ""none"" , opp -> nd_opt_pi_flags_reserved ) , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_valid_time ) ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>pref.<S2SV_blank>time<S2SV_blank>%s"" , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_preferred_time ) ) ) ) ; break ; case ND_OPT_REDIRECTED_HEADER : print_unknown_data ( ndo , bp , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , op -> nd_opt_len << 3 ) ; break ; case ND_OPT_MTU : opm = ( const struct nd_opt_mtu * ) op ; ND_TCHECK ( opm -> nd_opt_mtu_mtu ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u%s"" , EXTRACT_32BITS ( & opm -> nd_opt_mtu_mtu ) , ( op -> nd_opt_len != 1 ) ? ""bad<S2SV_blank>option<S2SV_blank>length"" : """" ) ) ; break ; case ND_OPT_RDNSS : oprd = ( const struct nd_opt_rdnss * ) op ; l = ( op -> nd_opt_len - 1 ) / 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime<S2SV_blank>%us,"" , EXTRACT_32BITS ( & oprd -> nd_opt_rdnss_lifetime ) ) ) ; for ( i = 0 ; i < l ; i ++ ) { ND_TCHECK ( oprd -> nd_opt_rdnss_addr [ i ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>addr:<S2SV_blank>%s"" , ip6addr_string ( ndo , & oprd -> nd_opt_rdnss_addr [ i ] ) ) ) ; } break ; case ND_OPT_DNSSL : opds = ( const struct nd_opt_dnssl * ) op ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>domain(s):"" , EXTRACT_32BITS ( & opds -> nd_opt_dnssl_lifetime ) ) ) ; domp = cp + 8 ; while ( domp < cp + ( op -> nd_opt_len << 3 ) && * domp != '\\0' ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( domp = ns_nprint ( ndo , domp , bp ) ) == NULL ) goto trunc ; } break ; case ND_OPT_ADVINTERVAL : opa = ( const struct nd_opt_advinterval * ) op ; ND_TCHECK ( opa -> nd_opt_adv_interval ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%ums"" , EXTRACT_32BITS ( & opa -> nd_opt_adv_interval ) ) ) ; break ; case ND_OPT_HOMEAGENT_INFO : oph = ( const struct nd_opt_homeagent_info * ) op ; ND_TCHECK ( oph -> nd_opt_hai_lifetime ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>preference<S2SV_blank>%u,<S2SV_blank>lifetime<S2SV_blank>%u"" , EXTRACT_16BITS ( & oph -> nd_opt_hai_preference ) , EXTRACT_16BITS ( & oph -> nd_opt_hai_lifetime ) ) ) ; break ; case ND_OPT_ROUTE_INFO : opri = ( const struct nd_opt_route_info * ) op ; ND_TCHECK ( opri -> nd_opt_rti_lifetime ) ; memset ( & in6 , 0 , sizeof ( in6 ) ) ; in6p = ( const struct in6_addr * ) ( opri + 1 ) ; switch ( op -> nd_opt_len ) { case 1 : break ; case 2 : ND_TCHECK2 ( * in6p , 8 ) ; memcpy ( & in6 , opri + 1 , 8 ) ; break ; case 3 : ND_TCHECK ( * in6p ) ; memcpy ( & in6 , opri + 1 , sizeof ( in6 ) ) ; break ; default : goto trunc ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s/%u"" , ip6addr_string ( ndo , & in6 ) , opri -> nd_opt_rti_prefixlen ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>pref=%s"" , get_rtpref ( opri -> nd_opt_rti_flags ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>lifetime=%s"" , get_lifetime ( EXTRACT_32BITS ( & opri -> nd_opt_rti_lifetime ) ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , cp + 2 , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ( op -> nd_opt_len << 3 ) - 2 ) ; return ; } break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , cp + 2 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , ( op -> nd_opt_len << 3 ) - 2 ) ; cp += op -> nd_opt_len << 3 ; resid -= op -> nd_opt_len << 3 ; } return ; trunc :  ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ;  return ; # undef ECHECK }","trunc : ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ;return ;",1658
661,buggy line: ( * re_ast ) -> root_node = NULL ;return ERROR_SUCCESS ;cwe id:CWE-674context: int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ;  ( * re_ast ) -> root_node = NULL ;  return ERROR_SUCCESS ; },( * re_ast ) -> levels = 0 ;( * re_ast ) -> root_node = NULL ;return ERROR_SUCCESS ;,1659
662,"buggy line: other = unix_peer_get ( sk ) ;if ( other ) {if ( unix_peer ( other ) != sk ) {sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ;if ( unix_recvq_full ( other ) )  writable = 0 ;}sock_put ( other ) ;cwe id:CWE-000context: static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , poll_table * wait ) { struct sock * sk = sock -> sk , * other ; unsigned int mask , writable ; sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; mask = 0 ; if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) mask |= POLLERR | ( sock_flag ( sk , SOCK_SELECT_ERR_QUEUE ) ? POLLPRI : 0 ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) mask |= POLLRDHUP | POLLIN | POLLRDNORM ; if ( sk -> sk_shutdown == SHUTDOWN_MASK ) mask |= POLLHUP ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) mask |= POLLIN | POLLRDNORM ; if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( sk -> sk_state == TCP_CLOSE ) mask |= POLLHUP ; if ( sk -> sk_state == TCP_SYN_SENT ) return mask ; } if ( ! ( poll_requested_events ( wait ) & ( POLLWRBAND | POLLWRNORM | POLLOUT ) ) ) return mask ; writable = unix_writable ( sk ) ;  other = unix_peer_get ( sk ) ;  if ( other ) {  if ( unix_peer ( other ) != sk ) {  sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ;  if ( unix_recvq_full ( other ) )  writable = 0 ;  }  sock_put ( other ) ; } if ( writable ) mask |= POLLOUT | POLLWRNORM | POLLWRBAND ; else set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; return mask ; }","if ( writable ) {unix_state_lock ( sk ) ;other = unix_peer ( sk ) ;if ( other && unix_peer ( other ) != sk && unix_recvq_full ( other ) && unix_dgram_peer_wake_me ( sk , other ) ) writable = 0 ;}sock_put ( other ) ;",1660
663,"buggy line: ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ;if ( ret <= 0 ) {auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB ,   ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ;return - 1 ;ret = dict_lookup ( iter -> conn -> dict , iter -> pool ,  str_c ( path ) , & key -> value , & error ) ;cwe id:CWE-20context: static int db_dict_iter_lookup_key_values ( struct db_dict_value_iter * iter ) { struct db_dict_iter_key * key ; string_t * path ; const char * error ; int ret ; array_sort ( & iter -> keys , db_dict_iter_key_cmp ) ; path = t_str_new ( 128 ) ; str_append ( path , DICT_PATH_SHARED ) ; array_foreach_modifiable ( & iter -> keys , key ) { if ( ! key -> used ) continue ; str_truncate ( path , strlen ( DICT_PATH_SHARED ) ) ;  ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ;   if ( ret <= 0 ) {   auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB ,   ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ;  return - 1 ; }  ret = dict_lookup ( iter -> conn -> dict , iter -> pool ,  str_c ( path ) , & key -> value , & error ) ; if ( ret > 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) , error ) ; return - 1 ; } else if ( key -> key -> default_value != NULL ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>%s"" , str_c ( path ) , key -> key -> default_value ) ; key -> value = key -> key -> default_value ; } else { return 0 ; } } return 1 ; }","str_append ( path , key -> key -> key ) ;ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value , & error ) ;if ( ret > 0 ) {auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) , error ) ;return - 1 ;ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value , & error ) ;",1661
664,"buggy line: if ( A > skb -> len - sizeof ( struct nlattr ) )  return 0 ;if ( nla -> nla_len > A - skb -> len )  return 0 ;cwe id:CWE-189context: static u64 __skb_get_nlattr_nest ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; if ( skb_is_nonlinear ( skb ) ) return 0 ;  if ( A > skb -> len - sizeof ( struct nlattr ) )  return 0 ; nla = ( struct nlattr * ) & skb -> data [ A ] ;  if ( nla -> nla_len > A - skb -> len )  return 0 ; nla = nla_find_nested ( nla , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }",if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ;if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ;if ( nla -> nla_len > skb -> len - A ) return 0 ;,1662
665,"buggy line: icon_file . directory [ i ] . size = ReadBlobLSBLong ( image ) ;cwe id:CWE-189context: static Image * ReadICONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { IconFile icon_file ; IconInfo icon_info ; Image * image ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bit , byte , bytes_per_line , one , scanline_pad ; ssize_t count , offset , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } icon_file . reserved = ( short ) ReadBlobLSBShort ( image ) ; icon_file . resource_type = ( short ) ReadBlobLSBShort ( image ) ; icon_file . count = ( short ) ReadBlobLSBShort ( image ) ; if ( ( icon_file . reserved != 0 ) || ( ( icon_file . resource_type != 1 ) && ( icon_file . resource_type != 2 ) ) || ( icon_file . count > MaxIcons ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; for ( i = 0 ; i < icon_file . count ; i ++ ) { icon_file . directory [ i ] . width = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . height = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . colors = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . reserved = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . planes = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ] . bits_per_pixel = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ] . size = ReadBlobLSBLong ( image ) ; icon_file . directory [ i ] . offset = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } one = 1 ; for ( i = 0 ; i < icon_file . count ; i ++ ) { offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) icon_file . directory [ i ] . offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; icon_info . size = ReadBlobLSBLong ( image ) ; icon_info . width = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) ) ; icon_info . height = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) / 2 ) ; icon_info . planes = ReadBlobLSBShort ( image ) ; icon_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( ( icon_info . planes == 18505 ) && ( icon_info . bits_per_pixel == 21060 ) ) || ( icon_info . size == 0x474e5089 ) ) { Image * icon_image ; ImageInfo * read_info ; size_t length ; unsigned char * png ;  length = icon_file . directory [ i ] . size ;  png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ; if ( png == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) CopyMagickMemory ( png , ""\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015"" , 12 ) ; png [ 12 ] = ( unsigned char ) icon_info . planes ; png [ 13 ] = ( unsigned char ) ( icon_info . planes >> 8 ) ; png [ 14 ] = ( unsigned char ) icon_info . bits_per_pixel ; png [ 15 ] = ( unsigned char ) ( icon_info . bits_per_pixel >> 8 ) ; count = ReadBlob ( image , length - 16 , png + 16 ) ; icon_image = ( Image * ) NULL ; if ( count > 0 ) { read_info = CloneImageInfo ( image_info ) ; ( void ) CopyMagickString ( read_info -> magick , ""PNG"" , MagickPathExtent ) ; icon_image = BlobToImage ( read_info , png , length + 16 , exception ) ; read_info = DestroyImageInfo ( read_info ) ; } png = ( unsigned char * ) RelinquishMagickMemory ( png ) ; if ( icon_image == ( Image * ) NULL ) { if ( count != ( ssize_t ) ( length - 16 ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } DestroyBlob ( icon_image ) ; icon_image -> blob = ReferenceBlob ( image -> blob ) ; ReplaceImageInList ( & image , icon_image ) ; } else { if ( icon_info . bits_per_pixel > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; icon_info . compression = ReadBlobLSBLong ( image ) ; icon_info . image_size = ReadBlobLSBLong ( image ) ; icon_info . x_pixels = ReadBlobLSBLong ( image ) ; icon_info . y_pixels = ReadBlobLSBLong ( image ) ; icon_info . number_colors = ReadBlobLSBLong ( image ) ; icon_info . colors_important = ReadBlobLSBLong ( image ) ; image -> alpha_trait = BlendPixelTrait ; image -> columns = ( size_t ) icon_file . directory [ i ] . width ; if ( ( ssize_t ) image -> columns > icon_info . width ) image -> columns = ( size_t ) icon_info . width ; if ( image -> columns == 0 ) image -> columns = 256 ; image -> rows = ( size_t ) icon_file . directory [ i ] . height ; if ( ( ssize_t ) image -> rows > icon_info . height ) image -> rows = ( size_t ) icon_info . height ; if ( image -> rows == 0 ) image -> rows = 256 ; image -> depth = icon_info . bits_per_pixel ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank>scene<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) i ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>size<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . size ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>width<S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_file . directory [ i ] . width ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>height<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_file . directory [ i ] . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>colors<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . number_colors ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>planes<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . planes ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>bpp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . bits_per_pixel ) ; } if ( ( icon_info . number_colors != 0 ) || ( icon_info . bits_per_pixel <= 16U ) ) { image -> storage_class = PseudoClass ; image -> colors = icon_info . number_colors ; if ( image -> colors == 0 ) image -> colors = one << icon_info . bits_per_pixel ; } if ( image -> storage_class == PseudoClass ) { register ssize_t i ; unsigned char * icon_colormap ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; icon_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4UL * sizeof ( * icon_colormap ) ) ; if ( icon_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) ( 4 * image -> colors ) , icon_colormap ) ; if ( count != ( ssize_t ) ( 4 * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = icon_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; p ++ ; } icon_colormap = ( unsigned char * ) RelinquishMagickMemory ( icon_colormap ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_line = ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) >> 3 ; ( void ) bytes_per_line ; scanline_pad = ( ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) - ( image -> columns * icon_info . bits_per_pixel ) ) >> 3 ; switch ( icon_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 8 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) , q ) ; q += GetPixelChannels ( image ) ; } } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelIndex ( image , ( ( byte ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 8 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , byte , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 16 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte = ( size_t ) ReadBlobByte ( image ) ; byte |= ( size_t ) ( ReadBlobByte ( image ) << 8 ) ; SetPixelIndex ( image , byte , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : case 32 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; if ( icon_info . bits_per_pixel == 32 ) SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( icon_info . bits_per_pixel == 24 ) for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( image_info -> ping == MagickFalse ) ( void ) SyncImage ( image , exception ) ; if ( icon_info . bits_per_pixel != 32 ) { image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? TransparentAlpha : OpaqueAlpha ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 8 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? TransparentAlpha : OpaqueAlpha ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 32 ) != 0 ) for ( x = 0 ; x < ( ssize_t ) ( ( 32 - ( image -> columns % 32 ) ) / 8 ) ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( i < ( ssize_t ) ( icon_file . count - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","icon_file . directory [ i ] . size ;if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) = ReadBlobLSBLong ( image ) ;",1663
666,"buggy line: length = icon_file . directory [ i ] . size ;png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ;cwe id:CWE-189context: static Image * ReadICONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { IconFile icon_file ; IconInfo icon_info ; Image * image ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bit , byte , bytes_per_line , one , scanline_pad ; ssize_t count , offset , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } icon_file . reserved = ( short ) ReadBlobLSBShort ( image ) ; icon_file . resource_type = ( short ) ReadBlobLSBShort ( image ) ; icon_file . count = ( short ) ReadBlobLSBShort ( image ) ; if ( ( icon_file . reserved != 0 ) || ( ( icon_file . resource_type != 1 ) && ( icon_file . resource_type != 2 ) ) || ( icon_file . count > MaxIcons ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; for ( i = 0 ; i < icon_file . count ; i ++ ) { icon_file . directory [ i ] . width = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . height = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . colors = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . reserved = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . planes = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ] . bits_per_pixel = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ] . size = ReadBlobLSBLong ( image ) ; icon_file . directory [ i ] . offset = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } one = 1 ; for ( i = 0 ; i < icon_file . count ; i ++ ) { offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) icon_file . directory [ i ] . offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; icon_info . size = ReadBlobLSBLong ( image ) ; icon_info . width = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) ) ; icon_info . height = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) / 2 ) ; icon_info . planes = ReadBlobLSBShort ( image ) ; icon_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( ( icon_info . planes == 18505 ) && ( icon_info . bits_per_pixel == 21060 ) ) || ( icon_info . size == 0x474e5089 ) ) { Image * icon_image ; ImageInfo * read_info ; size_t length ; unsigned char * png ;  length = icon_file . directory [ i ] . size ;  png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ; if ( png == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) CopyMagickMemory ( png , ""\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015"" , 12 ) ; png [ 12 ] = ( unsigned char ) icon_info . planes ; png [ 13 ] = ( unsigned char ) ( icon_info . planes >> 8 ) ; png [ 14 ] = ( unsigned char ) icon_info . bits_per_pixel ; png [ 15 ] = ( unsigned char ) ( icon_info . bits_per_pixel >> 8 ) ; count = ReadBlob ( image , length - 16 , png + 16 ) ; icon_image = ( Image * ) NULL ; if ( count > 0 ) { read_info = CloneImageInfo ( image_info ) ; ( void ) CopyMagickString ( read_info -> magick , ""PNG"" , MagickPathExtent ) ; icon_image = BlobToImage ( read_info , png , length + 16 , exception ) ; read_info = DestroyImageInfo ( read_info ) ; } png = ( unsigned char * ) RelinquishMagickMemory ( png ) ; if ( icon_image == ( Image * ) NULL ) { if ( count != ( ssize_t ) ( length - 16 ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } DestroyBlob ( icon_image ) ; icon_image -> blob = ReferenceBlob ( image -> blob ) ; ReplaceImageInList ( & image , icon_image ) ; } else { if ( icon_info . bits_per_pixel > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; icon_info . compression = ReadBlobLSBLong ( image ) ; icon_info . image_size = ReadBlobLSBLong ( image ) ; icon_info . x_pixels = ReadBlobLSBLong ( image ) ; icon_info . y_pixels = ReadBlobLSBLong ( image ) ; icon_info . number_colors = ReadBlobLSBLong ( image ) ; icon_info . colors_important = ReadBlobLSBLong ( image ) ; image -> alpha_trait = BlendPixelTrait ; image -> columns = ( size_t ) icon_file . directory [ i ] . width ; if ( ( ssize_t ) image -> columns > icon_info . width ) image -> columns = ( size_t ) icon_info . width ; if ( image -> columns == 0 ) image -> columns = 256 ; image -> rows = ( size_t ) icon_file . directory [ i ] . height ; if ( ( ssize_t ) image -> rows > icon_info . height ) image -> rows = ( size_t ) icon_info . height ; if ( image -> rows == 0 ) image -> rows = 256 ; image -> depth = icon_info . bits_per_pixel ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank>scene<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) i ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>size<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . size ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>width<S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_file . directory [ i ] . width ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>height<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_file . directory [ i ] . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>colors<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . number_colors ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>planes<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . planes ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>bpp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . bits_per_pixel ) ; } if ( ( icon_info . number_colors != 0 ) || ( icon_info . bits_per_pixel <= 16U ) ) { image -> storage_class = PseudoClass ; image -> colors = icon_info . number_colors ; if ( image -> colors == 0 ) image -> colors = one << icon_info . bits_per_pixel ; } if ( image -> storage_class == PseudoClass ) { register ssize_t i ; unsigned char * icon_colormap ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; icon_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4UL * sizeof ( * icon_colormap ) ) ; if ( icon_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) ( 4 * image -> colors ) , icon_colormap ) ; if ( count != ( ssize_t ) ( 4 * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = icon_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; p ++ ; } icon_colormap = ( unsigned char * ) RelinquishMagickMemory ( icon_colormap ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_line = ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) >> 3 ; ( void ) bytes_per_line ; scanline_pad = ( ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) - ( image -> columns * icon_info . bits_per_pixel ) ) >> 3 ; switch ( icon_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 8 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) , q ) ; q += GetPixelChannels ( image ) ; } } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelIndex ( image , ( ( byte ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 8 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , byte , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 16 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte = ( size_t ) ReadBlobByte ( image ) ; byte |= ( size_t ) ( ReadBlobByte ( image ) << 8 ) ; SetPixelIndex ( image , byte , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : case 32 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; if ( icon_info . bits_per_pixel == 32 ) SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( icon_info . bits_per_pixel == 24 ) for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( image_info -> ping == MagickFalse ) ( void ) SyncImage ( image , exception ) ; if ( icon_info . bits_per_pixel != 32 ) { image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? TransparentAlpha : OpaqueAlpha ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 8 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? TransparentAlpha : OpaqueAlpha ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 32 ) != 0 ) for ( x = 0 ; x < ( ssize_t ) ( ( 32 - ( image -> columns % 32 ) ) / 8 ) ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( i < ( ssize_t ) ( icon_file . count - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","length = icon_file . directory [ i ] . size ;png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ;",1663
667,"buggy line: stbbr_send ( ""<presence<S2SV_blank>to=\\\'stabber@localhost\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ;assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\\\""On<S2SV_blank>my<S2SV_blank>mobile\\\\"""" ) ) ;prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ;assert_true ( prof_output_exact ( ""unencrypted"" ) ) ;stbbr_send (  ""<message<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost\\\'>""  ""<received<S2SV_blank>xmlns=\\\'urn:xmpp:carbons:2\\\'>"" ""<forwarded<S2SV_blank>xmlns=\\\'urn:xmpp:forward:0\\\'>"" ""<message<S2SV_blank>id=\\\'prof_msg_7\\\'<S2SV_blank>xmlns=\\\'jabber:client\\\'<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>lang=\\\'en\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ;cwe id:CWE-20context: void receive_carbon ( void * * state ) { prof_input ( ""/carbons<S2SV_blank>on"" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( ""<iq<S2SV_blank>id=\'*\'<S2SV_blank>type=\'set\'><enable<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'/></iq>"" ) ) ; stbbr_send ( ""<presence<S2SV_blank>to=\'stabber@localhost\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ; assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\""On<S2SV_blank>my<S2SV_blank>mobile\\"""" ) ) ; prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ; assert_true ( prof_output_exact ( ""unencrypted"" ) ) ; stbbr_send (  ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>""  ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ; assert_true ( prof_output_regex ( ""Buddy1/mobile:<S2SV_blank>.+test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient"" ) ) ; }","stbbr_send ( ""<message<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'stabber@localhost\\\'>"" ""<received<S2SV_blank>xmlns=\\\'urn:xmpp:carbons:2\\\'>"" ""<forwarded<S2SV_blank>xmlns=\\\'urn:xmpp:forward:0\\\'>"" ""<message<S2SV_blank>id=\\\'prof_msg_7\\\'<S2SV_blank>xmlns=\\\'jabber:client\\\'<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>lang=\\\'en\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ;",1664
668,"buggy line: memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ;SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ;cwe id:CWE-415context: static int cac_get_serial_nr_from_CUID ( sc_card_t * card , sc_serial_number_t * serial ) { cac_private_data_t * priv = CAC_DATA ( card ) ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_NORMAL ) ; if ( card -> serialnr . len ) { * serial = card -> serialnr ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ;  memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ;  SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ; }","memcpy ( serial -> value , priv -> cac_id , serial -> len ) ;SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ;",1665
669,buggy line: tok -> level = 0 ;tok -> altwarning = 1 ;cwe id:CWE-125context: static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ;  tok -> level = 0 ;  tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ;  return tok ;  },tok -> level = 0 ;tok -> altwarning = 1 ;tok -> async_always = 0 ;,1666
670,buggy line: return tok ;}cwe id:CWE-125context: static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ;  tok -> level = 0 ;  tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ;  return tok ;  },return tok ;},1666
671,"buggy line: if ( av1 -> av1_config ) {GF_AV1Config * av1_cfg = AV1_DuplicateConfig ( av1 -> av1_config -> config ) ;cwe id:CWE-476context: void AV1_RewriteESDescriptorEx ( GF_MPEGVisualSampleEntryBox * av1 , GF_MediaBox * mdia ) { GF_BitRateBox * btrt = gf_isom_sample_entry_get_bitrate ( ( GF_SampleEntryBox * ) av1 , GF_FALSE ) ; if ( av1 -> emul_esd ) gf_odf_desc_del ( ( GF_Descriptor * ) av1 -> emul_esd ) ; av1 -> emul_esd = gf_odf_desc_esd_new ( 2 ) ; av1 -> emul_esd -> decoderConfig -> streamType = GF_STREAM_VISUAL ; av1 -> emul_esd -> decoderConfig -> objectTypeIndication = GF_CODECID_AV1 ; if ( btrt ) { av1 -> emul_esd -> decoderConfig -> bufferSizeDB = btrt -> bufferSizeDB ; av1 -> emul_esd -> decoderConfig -> avgBitrate = btrt -> avgBitrate ; av1 -> emul_esd -> decoderConfig -> maxBitrate = btrt -> maxBitrate ; }  if ( av1 -> av1_config ) {  GF_AV1Config * av1_cfg = AV1_DuplicateConfig ( av1 -> av1_config -> config ) ; if ( av1_cfg ) { gf_odf_av1_cfg_write ( av1_cfg , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> data , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> dataLength ) ; gf_odf_av1_cfg_del ( av1_cfg ) ; } } }",if ( av1 -> av1_config && av1 -> av1_config -> config ) {GF_AV1Config * av1_cfg = AV1_DuplicateConfig ( av1 -> av1_config -> config ) ;,1667
672,"buggy line: GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\\( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ;}cwe id:CWE-400context: GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) {  GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n"" ) ) ;   ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ;  } return GF_OK ; }","GF_Box * dref ;GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\\dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ;( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) dref ;gf_isom_box_add_for_dump_mode ( s , dref ) ;}",1668
673,"buggy line: buff [ r ] = \'\\\\0\' ;set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ;cwe id:CWE-415context: static int sc_pkcs15emu_esteid_init ( sc_pkcs15_card_t * p15card ) { sc_card_t * card = p15card -> card ; unsigned char buff [ 128 ] ; int r , i ; size_t field_length = 0 , modulus_length = 0 ; sc_path_t tmppath ; set_string ( & p15card -> tokeninfo -> label , ""ID-kaart"" ) ; set_string ( & p15card -> tokeninfo -> manufacturer_id , ""AS<S2SV_blank>Sertifitseerimiskeskus"" ) ; sc_format_path ( ""3f00eeee5044"" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , ""select<S2SV_blank>esteid<S2SV_blank>PD<S2SV_blank>failed"" ) ; r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , ""read<S2SV_blank>document<S2SV_blank>number<S2SV_blank>failed"" ) ;  buff [ r ] = '\\0' ;  set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ; p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION | SC_PKCS15_TOKEN_EID_COMPLIANT | SC_PKCS15_TOKEN_READONLY ; for ( i = 0 ; i < 2 ; i ++ ) { static const char * esteid_cert_names [ 2 ] = { ""Isikutuvastus"" , ""Allkirjastamine"" } ; static char const * esteid_cert_paths [ 2 ] = { ""3f00eeeeaace"" , ""3f00eeeeddce"" } ; static int esteid_cert_ids [ 2 ] = { 1 , 2 } ; struct sc_pkcs15_cert_info cert_info ; struct sc_pkcs15_object cert_obj ; memset ( & cert_info , 0 , sizeof ( cert_info ) ) ; memset ( & cert_obj , 0 , sizeof ( cert_obj ) ) ; cert_info . id . value [ 0 ] = esteid_cert_ids [ i ] ; cert_info . id . len = 1 ; sc_format_path ( esteid_cert_paths [ i ] , & cert_info . path ) ; strlcpy ( cert_obj . label , esteid_cert_names [ i ] , sizeof ( cert_obj . label ) ) ; r = sc_pkcs15emu_add_x509_cert ( p15card , & cert_obj , & cert_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; if ( i == 0 ) { sc_pkcs15_cert_t * cert = NULL ; r = sc_pkcs15_read_certificate ( p15card , & cert_info , & cert ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; if ( cert -> key -> algorithm == SC_ALGORITHM_EC ) field_length = cert -> key -> u . ec . params . field_length ; else modulus_length = cert -> key -> u . rsa . modulus . len * 8 ; if ( r == SC_SUCCESS ) { static const struct sc_object_id cn_oid = { { 2 , 5 , 4 , 3 , - 1 } } ; u8 * cn_name = NULL ; size_t cn_len = 0 ; sc_pkcs15_get_name_from_dn ( card -> ctx , cert -> subject , cert -> subject_len , & cn_oid , & cn_name , & cn_len ) ; if ( cn_len > 0 ) { char * token_name = malloc ( cn_len + 1 ) ; if ( token_name ) { memcpy ( token_name , cn_name , cn_len ) ; token_name [ cn_len ] = '\\0' ; set_string ( & p15card -> tokeninfo -> label , ( const char * ) token_name ) ; free ( token_name ) ; } } free ( cn_name ) ; sc_pkcs15_free_certificate ( cert ) ; } } } sc_format_path ( ""3f000016"" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; for ( i = 0 ; i < 3 ; i ++ ) { unsigned char tries_left ; static const char * esteid_pin_names [ 3 ] = { ""PIN1"" , ""PIN2"" , ""PUK"" } ; static const int esteid_pin_min [ 3 ] = { 4 , 5 , 8 } ; static const int esteid_pin_ref [ 3 ] = { 1 , 2 , 0 } ; static const int esteid_pin_authid [ 3 ] = { 1 , 2 , 3 } ; static const int esteid_pin_flags [ 3 ] = { 0 , 0 , SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN } ; struct sc_pkcs15_auth_info pin_info ; struct sc_pkcs15_object pin_obj ; memset ( & pin_info , 0 , sizeof ( pin_info ) ) ; memset ( & pin_obj , 0 , sizeof ( pin_obj ) ) ; r = sc_read_record ( card , i + 1 , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; tries_left = buff [ 5 ] ; pin_info . auth_id . len = 1 ; pin_info . auth_id . value [ 0 ] = esteid_pin_authid [ i ] ; pin_info . auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN ; pin_info . attrs . pin . reference = esteid_pin_ref [ i ] ; pin_info . attrs . pin . flags = esteid_pin_flags [ i ] ; pin_info . attrs . pin . type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC ; pin_info . attrs . pin . min_length = esteid_pin_min [ i ] ; pin_info . attrs . pin . stored_length = 12 ; pin_info . attrs . pin . max_length = 12 ; pin_info . attrs . pin . pad_char = '\\0' ; pin_info . tries_left = ( int ) tries_left ; pin_info . max_tries = 3 ; strlcpy ( pin_obj . label , esteid_pin_names [ i ] , sizeof ( pin_obj . label ) ) ; pin_obj . flags = esteid_pin_flags [ i ] ; if ( i < 2 ) { pin_obj . auth_id . len = 1 ; pin_obj . auth_id . value [ 0 ] = 3 ; } r = sc_pkcs15emu_add_pin_obj ( p15card , & pin_obj , & pin_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; } for ( i = 0 ; i < 2 ; i ++ ) { static int prkey_pin [ 2 ] = { 1 , 2 } ; static const char * prkey_name [ 2 ] = { ""Isikutuvastus"" , ""Allkirjastamine"" } ; struct sc_pkcs15_prkey_info prkey_info ; struct sc_pkcs15_object prkey_obj ; memset ( & prkey_info , 0 , sizeof ( prkey_info ) ) ; memset ( & prkey_obj , 0 , sizeof ( prkey_obj ) ) ; prkey_info . id . len = 1 ; prkey_info . id . value [ 0 ] = prkey_pin [ i ] ; prkey_info . native = 1 ; prkey_info . key_reference = i + 1 ; prkey_info . field_length = field_length ; prkey_info . modulus_length = modulus_length ; if ( i == 1 ) prkey_info . usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION ; else if ( field_length > 0 ) prkey_info . usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE ; else prkey_info . usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT ; strlcpy ( prkey_obj . label , prkey_name [ i ] , sizeof ( prkey_obj . label ) ) ; prkey_obj . auth_id . len = 1 ; prkey_obj . auth_id . value [ 0 ] = prkey_pin [ i ] ; prkey_obj . user_consent = 0 ; prkey_obj . flags = SC_PKCS15_CO_FLAG_PRIVATE ; if ( field_length > 0 ) r = sc_pkcs15emu_add_ec_prkey ( p15card , & prkey_obj , & prkey_info ) ; else r = sc_pkcs15emu_add_rsa_prkey ( p15card , & prkey_obj , & prkey_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; } return SC_SUCCESS ; }","buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) ] = \'\\\\0\' ;set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ;",1669
674,"buggy line: ASSERT ( dpbSize ) ;dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ;cwe id:CWE-119context: u32 h264bsdInitDpb ( dpbStorage_t * dpb , u32 picSizeInMbs , u32 dpbSize , u32 maxRefFrames , u32 maxFrameNum , u32 noReordering ) { u32 i ; ASSERT ( picSizeInMbs ) ; ASSERT ( maxRefFrames <= MAX_NUM_REF_PICS ) ; ASSERT ( maxRefFrames <= dpbSize ) ; ASSERT ( maxFrameNum ) ;  ASSERT ( dpbSize ) ;  dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ; dpb -> maxRefFrames = MAX ( maxRefFrames , 1 ) ; if ( noReordering ) dpb -> dpbSize = dpb -> maxRefFrames ; else dpb -> dpbSize = dpbSize ; dpb -> maxFrameNum = maxFrameNum ; dpb -> noReordering = noReordering ; dpb -> fullness = 0 ; dpb -> numRefFrames = 0 ; dpb -> prevRefFrameNum = 0 ; ALLOCATE ( dpb -> buffer , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t ) ; if ( dpb -> buffer == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> buffer , 0 , ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t ) ) ; for ( i = 0 ; i < dpb -> dpbSize + 1 ; i ++ ) { ALLOCATE ( dpb -> buffer [ i ] . pAllocatedData , ( picSizeInMbs * 384 + 32 + 15 ) , u8 ) ; if ( dpb -> buffer [ i ] . pAllocatedData == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; dpb -> buffer [ i ] . data = ALIGN ( dpb -> buffer [ i ] . pAllocatedData , 16 ) ; } ALLOCATE ( dpb -> list , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t * ) ; ALLOCATE ( dpb -> outBuf , dpb -> dpbSize + 1 , dpbOutPicture_t ) ; if ( dpb -> list == NULL || dpb -> outBuf == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> list , 0 , ( ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t * ) ) ) ; dpb -> numOut = dpb -> outIndex = 0 ; return ( HANTRO_OK ) ; }","if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) {ALOGE ( ""b/28533562"" ) ;android_errorWriteLog ( 0x534e4554 , ""28533562"" ) ;return ( MEMORY_ALLOCATION_ERROR ) ;}ASSERT ( dpbSize ) ;dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ;",1670
675,"buggy line: oe_errno = 0 ;if ( ! sock )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( addrlen )   addrlen_in = * addrlen ;if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in ,  addrlen ) != OE_OK )  {done :  return ret ;cwe id:CWE-552context: static int _hostsock_getpeername ( oe_fd_t * sock_ , struct oe_sockaddr * addr , oe_socklen_t * addrlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t addrlen_in = 0 ;  oe_errno = 0 ;   if ( ! sock )  OE_RAISE_ERRNO ( OE_EINVAL ) ;  if ( addrlen )   addrlen_in = * addrlen ;  if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in ,  addrlen ) != OE_OK )  { OE_RAISE_ERRNO ( OE_EINVAL ) ; }  done :  return ret ; }","oe_socklen_t addrlen_out = 0 ;oe_errno = 0 ;if ( ! sock || ! addr || ! addrlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ;addrlen_in = * addrlen ;if ( addrlen_in < 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , & addrlen_out ) != OE_OK ) {if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ;* addrlen = addrlen_out ;done : return ret ;",1671
676,"buggy line: if ( ! nego_read_request_token_or_cookie ( nego , s ) ) {cwe id:CWE-125context: BOOL nego_read_request ( rdpNego * nego , wStream * s ) { BYTE li ; BYTE type ; UINT16 length ; if ( ! tpkt_read_header ( s , & length ) ) return FALSE ; if ( ! tpdu_read_connection_request ( s , & li , length ) ) return FALSE ; if ( li != Stream_GetRemainingLength ( s ) + 6 ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>TPDU<S2SV_blank>length<S2SV_blank>indicator."" ) ; return FALSE ; } if ( ! nego_read_request_token_or_cookie ( nego , s ) ) { WLog_ERR ( TAG , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>routing<S2SV_blank>token<S2SV_blank>or<S2SV_blank>cookie."" ) ; return FALSE ; } if ( Stream_GetRemainingLength ( s ) >= 8 ) { Stream_Read_UINT8 ( s , type ) ; if ( type != TYPE_RDP_NEG_REQ ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>negotiation<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%"" PRIu8 """" , type ) ; return FALSE ; }  nego_process_negotiation_request ( nego , s ) ;  } return tpkt_ensure_stream_consumed ( s , length ) ; }","if ( ! if ( ! nego_read_request_token_or_cookie ( nego , s ) ) return FALSE ) {",1672
677,"buggy line: nego_process_negotiation_request ( nego , s ) ;}cwe id:CWE-125context: BOOL nego_read_request ( rdpNego * nego , wStream * s ) { BYTE li ; BYTE type ; UINT16 length ; if ( ! tpkt_read_header ( s , & length ) ) return FALSE ; if ( ! tpdu_read_connection_request ( s , & li , length ) ) return FALSE ; if ( li != Stream_GetRemainingLength ( s ) + 6 ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>TPDU<S2SV_blank>length<S2SV_blank>indicator."" ) ; return FALSE ; } if ( ! nego_read_request_token_or_cookie ( nego , s ) ) { WLog_ERR ( TAG , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>routing<S2SV_blank>token<S2SV_blank>or<S2SV_blank>cookie."" ) ; return FALSE ; } if ( Stream_GetRemainingLength ( s ) >= 8 ) { Stream_Read_UINT8 ( s , type ) ; if ( type != TYPE_RDP_NEG_REQ ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>negotiation<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%"" PRIu8 """" , type ) ; return FALSE ; }  nego_process_negotiation_request ( nego , s ) ;  } return tpkt_ensure_stream_consumed ( s , length ) ; }","nego_process_negotiation_request ( nego , s ) ;}",1672
678,"buggy line: struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6_txoptions * opt = NULL ;cwe id:CWE-264context: static int l2tp_ip6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_l2tpip6 * , lsa , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ;  struct ipv6_pinfo * np = inet6_sk ( sk ) ;  struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int transhdrlen = 4 ; int ulen = len + transhdrlen ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( lsa ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( lsa -> l2tp_family && lsa -> l2tp_family != AF_INET6 ) return - EAFNOSUPPORT ; daddr = & lsa -> l2tp_addr ; if ( np -> sndflow ) { fl6 . flowlabel = lsa -> l2tp_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && lsa -> l2tp_scope_id && ipv6_addr_type ( daddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = lsa -> l2tp_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; }  if ( opt == NULL )  opt = np -> opt ; if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = sk -> sk_protocol ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : lock_sock ( sk ) ; err = ip6_append_data ( sk , ip_generic_getfrag , msg , ulen , transhdrlen , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = l2tp_ip6_push_pending_frames ( sk ) ; release_sock ( sk ) ; done : dst_release ( dst ) ; out :  fl6_sock_release ( flowlabel ) ;  return err < 0 ? err : len ; do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }",struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6_txoptions * opt_to_free = NULL ;struct ipv6_txoptions * opt = NULL ;,1673
679,"buggy line: if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ;if ( addr_len >= sizeof ( struct sockaddr_in6 ) && lsa -> l2tp_scope_id && ipv6_addr_type ( daddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = lsa -> l2tp_scope_id ;else {if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ;daddr = & sk -> sk_v6_daddr ;fl6 . flowlabel = np -> flow_label ;}if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ;if ( msg -> msg_controllen ) {opt = & opt_space ;memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ;opt -> tot_len = sizeof ( struct ipv6_txoptions ) ;err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ;if ( err < 0 ) {fl6_sock_release ( flowlabel ) ;return err ;}if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) {flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ;if ( opt == NULL )  opt = np -> opt ;cwe id:CWE-264context: static int l2tp_ip6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_l2tpip6 * , lsa , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ;  struct ipv6_pinfo * np = inet6_sk ( sk ) ;  struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int transhdrlen = 4 ; int ulen = len + transhdrlen ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( lsa ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( lsa -> l2tp_family && lsa -> l2tp_family != AF_INET6 ) return - EAFNOSUPPORT ; daddr = & lsa -> l2tp_addr ; if ( np -> sndflow ) { fl6 . flowlabel = lsa -> l2tp_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && lsa -> l2tp_scope_id && ipv6_addr_type ( daddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = lsa -> l2tp_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; }  if ( opt == NULL )  opt = np -> opt ; if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = sk -> sk_protocol ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : lock_sock ( sk ) ; err = ip6_append_data ( sk , ip_generic_getfrag , msg , ulen , transhdrlen , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = l2tp_ip6_push_pending_frames ( sk ) ; release_sock ( sk ) ; done : dst_release ( dst ) ; out :  fl6_sock_release ( flowlabel ) ;  return err < 0 ? err : len ; do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }",if ( ! opt ) {opt = txopt_get ( np ) ;opt_to_free = opt ;if ( opt == NULL ) opt = np -> opt ;,1673
680,"buggy line: out :  fl6_sock_release ( flowlabel ) ;return err < 0 ? err : len ;cwe id:CWE-264context: static int l2tp_ip6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_l2tpip6 * , lsa , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ;  struct ipv6_pinfo * np = inet6_sk ( sk ) ;  struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int transhdrlen = 4 ; int ulen = len + transhdrlen ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( lsa ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( lsa -> l2tp_family && lsa -> l2tp_family != AF_INET6 ) return - EAFNOSUPPORT ; daddr = & lsa -> l2tp_addr ; if ( np -> sndflow ) { fl6 . flowlabel = lsa -> l2tp_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && lsa -> l2tp_scope_id && ipv6_addr_type ( daddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = lsa -> l2tp_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; }  if ( opt == NULL )  opt = np -> opt ; if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = sk -> sk_protocol ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : lock_sock ( sk ) ; err = ip6_append_data ( sk , ip_generic_getfrag , msg , ulen , transhdrlen , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = l2tp_ip6_push_pending_frames ( sk ) ; release_sock ( sk ) ; done : dst_release ( dst ) ; out :  fl6_sock_release ( flowlabel ) ;  return err < 0 ? err : len ; do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }",out : fl6_sock_release ( flowlabel ) ;txopt_put ( opt_to_free ) ;return err < 0 ? err : len ;,1673
681,"buggy line: unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ;unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ;uint32_t valign , falign , hdr_size , j ;struct cli_exe_section * exe_sections ;# endif const char * archtype = NULL , * subsystem = NULL ;cwe id:CWE-119context: int cli_scanpe ( cli_ctx * ctx ) { uint16_t e_magic ; uint16_t nsections ; uint32_t e_lfanew ; uint32_t ep , vep ; uint8_t polipos = 0 ; time_t timestamp ; struct pe_image_file_hdr file_hdr ; union { struct pe_image_optional_hdr64 opt64 ; struct pe_image_optional_hdr32 opt32 ; } pe_opt ; struct pe_image_section_hdr * section_hdr ; char sname [ 9 ] , epbuff [ 4096 ] , * tempfile ; uint32_t epsize ; ssize_t bytes , at ;  unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ;  unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ; int ( * upxfn ) ( const char * , uint32_t , char * , uint32_t * , uint32_t , uint32_t , uint32_t ) = NULL ; const char * src = NULL ; char * dest = NULL ; int ndesc , ret = CL_CLEAN , upack = 0 , native = 0 ; size_t fsize ;  uint32_t valign , falign , hdr_size , j ;  struct cli_exe_section * exe_sections ; char timestr [ 32 ] ; struct pe_image_data_dir * dirs ; struct cli_bc_ctx * bc_ctx ; fmap_t * map ; struct cli_pe_hook_data pedata ; # ifdef HAVE__INTERNAL__SHA_COLLECT int sha_collect = ctx -> sha_collect ; # endif const char * archtype = NULL , * subsystem = NULL ; uint32_t viruses_found = 0 ; # if HAVE_JSON int toval = 0 ; struct json_object * pe_json = NULL ; char jsonbuf [ 128 ] ; # endif if ( ! ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>ctx<S2SV_blank>==<S2SV_blank>NULL\\n"" ) ; return CL_ENULLARG ; } # if HAVE_JSON if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } if ( ctx -> options & CL_SCAN_FILE_PROPERTIES ) { pe_json = get_pe_property ( ctx ) ; } # endif map = * ctx -> fmap ; if ( fmap_readn ( map , & e_magic , 0 , sizeof ( e_magic ) ) != sizeof ( e_magic ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>DOS<S2SV_blank>signature\\n"" ) ; return CL_CLEAN ; } if ( EC16 ( e_magic ) != PE_IMAGE_DOS_SIGNATURE && EC16 ( e_magic ) != PE_IMAGE_DOS_SIGNATURE_OLD ) { cli_dbgmsg ( ""Invalid<S2SV_blank>DOS<S2SV_blank>signature\\n"" ) ; return CL_CLEAN ; } if ( fmap_readn ( map , & e_lfanew , 58 + sizeof ( e_magic ) , sizeof ( e_lfanew ) ) != sizeof ( e_lfanew ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>new<S2SV_blank>header<S2SV_blank>address\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } e_lfanew = EC32 ( e_lfanew ) ; cli_dbgmsg ( ""e_lfanew<S2SV_blank>==<S2SV_blank>%d\\n"" , e_lfanew ) ; if ( ! e_lfanew ) { cli_dbgmsg ( ""Not<S2SV_blank>a<S2SV_blank>PE<S2SV_blank>file\\n"" ) ; return CL_CLEAN ; } if ( fmap_readn ( map , & file_hdr , e_lfanew , sizeof ( struct pe_image_file_hdr ) ) != sizeof ( struct pe_image_file_hdr ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>file<S2SV_blank>header\\n"" ) ; return CL_CLEAN ; } if ( EC32 ( file_hdr . Magic ) != PE_IMAGE_NT_SIGNATURE ) { cli_dbgmsg ( ""Invalid<S2SV_blank>PE<S2SV_blank>signature<S2SV_blank>(probably<S2SV_blank>NE<S2SV_blank>file)\\n"" ) ; return CL_CLEAN ; } if ( EC16 ( file_hdr . Characteristics ) & 0x2000 ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json , ""Type"" , ""DLL"" ) ; # endif cli_dbgmsg ( ""File<S2SV_blank>type:<S2SV_blank>DLL\\n"" ) ; dll = 1 ; } else if ( EC16 ( file_hdr . Characteristics ) & 0x01 ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json , ""Type"" , ""EXE"" ) ; # endif cli_dbgmsg ( ""File<S2SV_blank>type:<S2SV_blank>Executable\\n"" ) ; } switch ( EC16 ( file_hdr . Machine ) ) { case 0x0 : archtype = ""Unknown"" ; break ; case 0x14c : archtype = ""80386"" ; break ; case 0x14d : archtype = ""80486"" ; break ; case 0x14e : archtype = ""80586"" ; break ; case 0x160 : archtype = ""R30000<S2SV_blank>(big-endian)"" ; break ; case 0x162 : archtype = ""R3000"" ; break ; case 0x166 : archtype = ""R4000"" ; break ; case 0x168 : archtype = ""R10000"" ; break ; case 0x184 : archtype = ""DEC<S2SV_blank>Alpha<S2SV_blank>AXP"" ; break ; case 0x284 : archtype = ""DEC<S2SV_blank>Alpha<S2SV_blank>AXP<S2SV_blank>64bit"" ; break ; case 0x1f0 : archtype = ""PowerPC"" ; break ; case 0x200 : archtype = ""IA64"" ; break ; case 0x268 : archtype = ""M68k"" ; break ; case 0x266 : archtype = ""MIPS16"" ; break ; case 0x366 : archtype = ""MIPS+FPU"" ; break ; case 0x466 : archtype = ""MIPS16+FPU"" ; break ; case 0x1a2 : archtype = ""Hitachi<S2SV_blank>SH3"" ; break ; case 0x1a3 : archtype = ""Hitachi<S2SV_blank>SH3-DSP"" ; break ; case 0x1a4 : archtype = ""Hitachi<S2SV_blank>SH3-E"" ; break ; case 0x1a6 : archtype = ""Hitachi<S2SV_blank>SH4"" ; break ; case 0x1a8 : archtype = ""Hitachi<S2SV_blank>SH5"" ; break ; case 0x1c0 : archtype = ""ARM"" ; break ; case 0x1c2 : archtype = ""THUMB"" ; break ; case 0x1d3 : archtype = ""AM33"" ; break ; case 0x520 : archtype = ""Infineon<S2SV_blank>TriCore"" ; break ; case 0xcef : archtype = ""CEF"" ; break ; case 0xebc : archtype = ""EFI<S2SV_blank>Byte<S2SV_blank>Code"" ; break ; case 0x9041 : archtype = ""M32R"" ; break ; case 0xc0ee : archtype = ""CEEE"" ; break ; case 0x8664 : archtype = ""AMD64"" ; break ; default : archtype = ""Unknown"" ; } if ( ( archtype ) ) { cli_dbgmsg ( ""Machine<S2SV_blank>type:<S2SV_blank>%s\\n"" , archtype ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""ArchType"" , archtype ) ; # endif } nsections = EC16 ( file_hdr . NumberOfSections ) ; if ( nsections < 1 || nsections > 96 ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadNumberOfSections"" ) ; # endif if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } if ( ! ctx -> corrupted_input ) { if ( nsections ) cli_warnmsg ( ""PE<S2SV_blank>file<S2SV_blank>contains<S2SV_blank>%d<S2SV_blank>sections\\n"" , nsections ) ; else cli_warnmsg ( ""PE<S2SV_blank>file<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>sections\\n"" ) ; } return CL_CLEAN ; } cli_dbgmsg ( ""NumberOfSections:<S2SV_blank>%d\\n"" , nsections ) ; timestamp = ( time_t ) EC32 ( file_hdr . TimeDateStamp ) ; cli_dbgmsg ( ""TimeDateStamp:<S2SV_blank>%s"" , cli_ctime ( & timestamp , timestr , sizeof ( timestr ) ) ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""TimeDateStamp"" , cli_ctime ( & timestamp , timestr , sizeof ( timestr ) ) ) ; # endif cli_dbgmsg ( ""SizeOfOptionalHeader:<S2SV_blank>%x\\n"" , EC16 ( file_hdr . SizeOfOptionalHeader ) ) ; # if HAVE_JSON cli_jsonint ( pe_json , ""SizeOfOptionalHeader"" , EC16 ( file_hdr . SizeOfOptionalHeader ) ) ; # endif if ( EC16 ( file_hdr . SizeOfOptionalHeader ) < sizeof ( struct pe_image_optional_hdr32 ) ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadOptionalHeaderSize"" ) ; # endif cli_dbgmsg ( ""SizeOfOptionalHeader<S2SV_blank>too<S2SV_blank>small\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at = e_lfanew + sizeof ( struct pe_image_file_hdr ) ; if ( fmap_readn ( map , & optional_hdr32 , at , sizeof ( struct pe_image_optional_hdr32 ) ) != sizeof ( struct pe_image_optional_hdr32 ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>optional<S2SV_blank>file<S2SV_blank>header\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_optional_hdr32 ) ; if ( EC16 ( optional_hdr64 . Magic ) == PE32P_SIGNATURE ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadOptionalHeaderSizePE32Plus"" ) ; # endif if ( EC16 ( file_hdr . SizeOfOptionalHeader ) != sizeof ( struct pe_image_optional_hdr64 ) ) { cli_dbgmsg ( ""Incorrect<S2SV_blank>SizeOfOptionalHeader<S2SV_blank>for<S2SV_blank>PE32+\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } pe_plus = 1 ; } if ( ! pe_plus ) { if ( EC16 ( file_hdr . SizeOfOptionalHeader ) != sizeof ( struct pe_image_optional_hdr32 ) ) { at += EC16 ( file_hdr . SizeOfOptionalHeader ) - sizeof ( struct pe_image_optional_hdr32 ) ; } if ( DCONF & PE_CONF_UPACK ) upack = ( EC16 ( file_hdr . SizeOfOptionalHeader ) == 0x148 ) ; vep = EC32 ( optional_hdr32 . AddressOfEntryPoint ) ; hdr_size = EC32 ( optional_hdr32 . SizeOfHeaders ) ; cli_dbgmsg ( ""File<S2SV_blank>format:<S2SV_blank>PE\\n"" ) ; cli_dbgmsg ( ""MajorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr32 . MajorLinkerVersion ) ; cli_dbgmsg ( ""MinorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr32 . MinorLinkerVersion ) ; cli_dbgmsg ( ""SizeOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfCode ) ) ; cli_dbgmsg ( ""SizeOfInitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfInitializedData ) ) ; cli_dbgmsg ( ""SizeOfUninitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfUninitializedData ) ) ; cli_dbgmsg ( ""AddressOfEntryPoint:<S2SV_blank>0x%x\\n"" , vep ) ; cli_dbgmsg ( ""BaseOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . BaseOfCode ) ) ; cli_dbgmsg ( ""SectionAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SectionAlignment ) ) ; cli_dbgmsg ( ""FileAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . FileAlignment ) ) ; cli_dbgmsg ( ""MajorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr32 . MajorSubsystemVersion ) ) ; cli_dbgmsg ( ""MinorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr32 . MinorSubsystemVersion ) ) ; cli_dbgmsg ( ""SizeOfImage:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfImage ) ) ; cli_dbgmsg ( ""SizeOfHeaders:<S2SV_blank>0x%x\\n"" , hdr_size ) ; cli_dbgmsg ( ""NumberOfRvaAndSizes:<S2SV_blank>%d\\n"" , EC32 ( optional_hdr32 . NumberOfRvaAndSizes ) ) ; dirs = optional_hdr32 . DataDirectory ; # if HAVE_JSON cli_jsonint ( pe_json , ""MajorLinkerVersion"" , optional_hdr32 . MajorLinkerVersion ) ; cli_jsonint ( pe_json , ""MinorLinkerVersion"" , optional_hdr32 . MinorLinkerVersion ) ; cli_jsonint ( pe_json , ""SizeOfCode"" , EC32 ( optional_hdr32 . SizeOfCode ) ) ; cli_jsonint ( pe_json , ""SizeOfInitializedData"" , EC32 ( optional_hdr32 . SizeOfInitializedData ) ) ; cli_jsonint ( pe_json , ""SizeOfUninitializedData"" , EC32 ( optional_hdr32 . SizeOfUninitializedData ) ) ; cli_jsonint ( pe_json , ""NumberOfRvaAndSizes"" , EC32 ( optional_hdr32 . NumberOfRvaAndSizes ) ) ; cli_jsonint ( pe_json , ""MajorSubsystemVersion"" , EC16 ( optional_hdr32 . MajorSubsystemVersion ) ) ; cli_jsonint ( pe_json , ""MinorSubsystemVersion"" , EC16 ( optional_hdr32 . MinorSubsystemVersion ) ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . BaseOfCode ) ) ; cli_jsonstr ( pe_json , ""BaseOfCode"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . SectionAlignment ) ) ; cli_jsonstr ( pe_json , ""SectionAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . FileAlignment ) ) ; cli_jsonstr ( pe_json , ""FileAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . SizeOfImage ) ) ; cli_jsonstr ( pe_json , ""SizeOfImage"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , hdr_size ) ; cli_jsonstr ( pe_json , ""SizeOfHeaders"" , jsonbuf ) ; # endif } else { if ( fmap_readn ( map , & optional_hdr32 + 1 , at , sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ) != sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>optional<S2SV_blank>file<S2SV_blank>header\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ; vep = EC32 ( optional_hdr64 . AddressOfEntryPoint ) ; hdr_size = EC32 ( optional_hdr64 . SizeOfHeaders ) ; cli_dbgmsg ( ""File<S2SV_blank>format:<S2SV_blank>PE32+\\n"" ) ; cli_dbgmsg ( ""MajorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr64 . MajorLinkerVersion ) ; cli_dbgmsg ( ""MinorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr64 . MinorLinkerVersion ) ; cli_dbgmsg ( ""SizeOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfCode ) ) ; cli_dbgmsg ( ""SizeOfInitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfInitializedData ) ) ; cli_dbgmsg ( ""SizeOfUninitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfUninitializedData ) ) ; cli_dbgmsg ( ""AddressOfEntryPoint:<S2SV_blank>0x%x\\n"" , vep ) ; cli_dbgmsg ( ""BaseOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . BaseOfCode ) ) ; cli_dbgmsg ( ""SectionAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SectionAlignment ) ) ; cli_dbgmsg ( ""FileAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . FileAlignment ) ) ; cli_dbgmsg ( ""MajorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr64 . MajorSubsystemVersion ) ) ; cli_dbgmsg ( ""MinorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr64 . MinorSubsystemVersion ) ) ; cli_dbgmsg ( ""SizeOfImage:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfImage ) ) ; cli_dbgmsg ( ""SizeOfHeaders:<S2SV_blank>0x%x\\n"" , hdr_size ) ; cli_dbgmsg ( ""NumberOfRvaAndSizes:<S2SV_blank>%d\\n"" , EC32 ( optional_hdr64 . NumberOfRvaAndSizes ) ) ; dirs = optional_hdr64 . DataDirectory ; # if HAVE_JSON cli_jsonint ( pe_json , ""MajorLinkerVersion"" , optional_hdr64 . MajorLinkerVersion ) ; cli_jsonint ( pe_json , ""MinorLinkerVersion"" , optional_hdr64 . MinorLinkerVersion ) ; cli_jsonint ( pe_json , ""SizeOfCode"" , EC32 ( optional_hdr64 . SizeOfCode ) ) ; cli_jsonint ( pe_json , ""SizeOfInitializedData"" , EC32 ( optional_hdr64 . SizeOfInitializedData ) ) ; cli_jsonint ( pe_json , ""SizeOfUninitializedData"" , EC32 ( optional_hdr64 . SizeOfUninitializedData ) ) ; cli_jsonint ( pe_json , ""NumberOfRvaAndSizes"" , EC32 ( optional_hdr64 . NumberOfRvaAndSizes ) ) ; cli_jsonint ( pe_json , ""MajorSubsystemVersion"" , EC16 ( optional_hdr64 . MajorSubsystemVersion ) ) ; cli_jsonint ( pe_json , ""MinorSubsystemVersion"" , EC16 ( optional_hdr64 . MinorSubsystemVersion ) ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . BaseOfCode ) ) ; cli_jsonstr ( pe_json , ""BaseOfCode"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . SectionAlignment ) ) ; cli_jsonstr ( pe_json , ""SectionAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . FileAlignment ) ) ; cli_jsonstr ( pe_json , ""FileAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . SizeOfImage ) ) ; cli_jsonstr ( pe_json , ""SizeOfImage"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , hdr_size ) ; cli_jsonstr ( pe_json , ""SizeOfHeaders"" , jsonbuf ) ; # endif } # if HAVE_JSON if ( ctx -> options & CL_SCAN_FILE_PROPERTIES ) { snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , vep ) ; cli_jsonstr ( pe_json , ""EntryPoint"" , jsonbuf ) ; } # endif switch ( pe_plus ? EC16 ( optional_hdr64 . Subsystem ) : EC16 ( optional_hdr32 . Subsystem ) ) { case 0 : subsystem = ""Unknown"" ; break ; case 1 : subsystem = ""Native<S2SV_blank>(svc)"" ; native = 1 ; break ; case 2 : subsystem = ""Win32<S2SV_blank>GUI"" ; break ; case 3 : subsystem = ""Win32<S2SV_blank>console"" ; break ; case 5 : subsystem = ""OS/2<S2SV_blank>console"" ; break ; case 7 : subsystem = ""POSIX<S2SV_blank>console"" ; break ; case 8 : subsystem = ""Native<S2SV_blank>Win9x<S2SV_blank>driver"" ; break ; case 9 : subsystem = ""WinCE<S2SV_blank>GUI"" ; break ; case 10 : subsystem = ""EFI<S2SV_blank>application"" ; break ; case 11 : subsystem = ""EFI<S2SV_blank>driver"" ; break ; case 12 : subsystem = ""EFI<S2SV_blank>runtime<S2SV_blank>driver"" ; break ; case 13 : subsystem = ""EFI<S2SV_blank>ROM<S2SV_blank>image"" ; break ; case 14 : subsystem = ""Xbox"" ; break ; case 16 : subsystem = ""Boot<S2SV_blank>application"" ; break ; default : subsystem = ""Unknown"" ; } cli_dbgmsg ( ""Subsystem:<S2SV_blank>%s\\n"" , subsystem ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Subsystem"" , subsystem ) ; # endif cli_dbgmsg ( ""------------------------------------\\n"" ) ; if ( DETECT_BROKEN_PE && ! native && ( ! ( pe_plus ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ) || ( pe_plus ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ) % 0x1000 ) ) { cli_dbgmsg ( ""Bad<S2SV_blank>virtual<S2SV_blank>alignemnt\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } if ( DETECT_BROKEN_PE && ! native && ( ! ( pe_plus ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ) || ( pe_plus ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ) % 0x200 ) ) { cli_dbgmsg ( ""Bad<S2SV_blank>file<S2SV_blank>alignemnt\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } fsize = map -> len ; section_hdr = ( struct pe_image_section_hdr * ) cli_calloc ( nsections , sizeof ( struct pe_image_section_hdr ) ) ; if ( ! section_hdr ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>section<S2SV_blank>headers\\n"" ) ; return CL_EMEM ; } exe_sections = ( struct cli_exe_section * ) cli_calloc ( nsections , sizeof ( struct cli_exe_section ) ) ; if ( ! exe_sections ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>section<S2SV_blank>headers\\n"" ) ; free ( section_hdr ) ; return CL_EMEM ; } valign = ( pe_plus ) ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ; falign = ( pe_plus ) ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ; if ( fmap_readn ( map , section_hdr , at , sizeof ( struct pe_image_section_hdr ) * nsections ) != ( int ) ( nsections * sizeof ( struct pe_image_section_hdr ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>section<S2SV_blank>header\\n"" ) ; cli_dbgmsg ( ""Possibly<S2SV_blank>broken<S2SV_blank>PE<S2SV_blank>file\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_section_hdr ) * nsections ; for ( i = 0 ; falign != 0x200 && i < nsections ; i ++ ) { if ( falign && section_hdr [ i ] . SizeOfRawData && EC32 ( section_hdr [ i ] . PointerToRawData ) % falign && ! ( EC32 ( section_hdr [ i ] . PointerToRawData ) % 0x200 ) ) { cli_dbgmsg ( ""Found<S2SV_blank>misaligned<S2SV_blank>section,<S2SV_blank>using<S2SV_blank>0x200\\n"" ) ; falign = 0x200 ; } } hdr_size = PESALIGN ( hdr_size , valign ) ; # if HAVE_JSON cli_jsonint ( pe_json , ""NumberOfSections"" , nsections ) ; # endif  for ( i = 0 ; i < nsections ; i ++ ) {   strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ;   sname [ 8 ] = 0 ;  exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; # if HAVE_JSON add_section_info ( ctx , & exe_sections [ i ] ) ; if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { free ( section_hdr ) ; free ( exe_sections ) ; return CL_ETIMEOUT ; } # endif if ( ! exe_sections [ i ] . vsz && exe_sections [ i ] . rsz ) exe_sections [ i ] . vsz = PESALIGN ( exe_sections [ i ] . ursz , valign ) ; if ( exe_sections [ i ] . rsz && fsize > exe_sections [ i ] . raw && ! CLI_ISCONTAINED ( 0 , ( uint32_t ) fsize , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) ) exe_sections [ i ] . rsz = fsize - exe_sections [ i ] . raw ; cli_dbgmsg ( ""Section<S2SV_blank>%d\\n"" , i ) ; cli_dbgmsg ( ""Section<S2SV_blank>name:<S2SV_blank>%s\\n"" , sname ) ; cli_dbgmsg ( ""Section<S2SV_blank>data<S2SV_blank>(from<S2SV_blank>headers<S2SV_blank>-<S2SV_blank>in<S2SV_blank>memory)\\n"" ) ; cli_dbgmsg ( ""VirtualSize:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . uvsz , exe_sections [ i ] . vsz ) ; cli_dbgmsg ( ""VirtualAddress:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . urva , exe_sections [ i ] . rva ) ; cli_dbgmsg ( ""SizeOfRawData:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . ursz , exe_sections [ i ] . rsz ) ; cli_dbgmsg ( ""PointerToRawData:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . uraw , exe_sections [ i ] . raw ) ; if ( exe_sections [ i ] . chr & 0x20 ) { cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>executable<S2SV_blank>code\\n"" ) ; if ( exe_sections [ i ] . vsz < exe_sections [ i ] . rsz ) { cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>free<S2SV_blank>space\\n"" ) ; } } if ( exe_sections [ i ] . chr & 0x20000000 ) cli_dbgmsg ( ""Section\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>executable\\n"" ) ; if ( exe_sections [ i ] . chr & 0x80000000 ) cli_dbgmsg ( ""Section\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>writeable\\n"" ) ; if ( DETECT_BROKEN_PE && ( ! valign || ( exe_sections [ i ] . urva % valign ) ) ) { cli_dbgmsg ( ""VirtualAddress<S2SV_blank>is<S2SV_blank>misaligned\\n"" ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } if ( exe_sections [ i ] . rsz ) {  if ( exe_sections [ i ] . raw >= fsize ) {  cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\n"" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } if ( SCAN_ALGO && ( DCONF & PE_CONF_POLIPOS ) && ! * sname && exe_sections [ i ] . vsz > 40000 && exe_sections [ i ] . vsz < 70000 && exe_sections [ i ] . chr == 0xe0000060 ) polipos = i ; if ( ( DCONF & PE_CONF_MD5SECT ) && ctx -> engine -> hm_mdb ) { ret = scan_pe_mdb ( ctx , & exe_sections [ i ] ) ; if ( ret != CL_CLEAN ) { if ( ret != CL_VIRUS ) cli_errmsg ( ""scan_pe:<S2SV_blank>scan_pe_mdb<S2SV_blank>failed:<S2SV_blank>%s!\\n"" , cl_strerror ( ret ) ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return ret ; } } } cli_dbgmsg ( ""------------------------------------\\n"" ) ; if ( exe_sections [ i ] . urva >> 31 || exe_sections [ i ] . uvsz >> 31 || ( exe_sections [ i ] . rsz && exe_sections [ i ] . uraw >> 31 ) || exe_sections [ i ] . ursz >> 31 ) { cli_dbgmsg ( ""Found<S2SV_blank>PE<S2SV_blank>values<S2SV_blank>with<S2SV_blank>sign<S2SV_blank>bit<S2SV_blank>set\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } if ( ! i ) { if ( DETECT_BROKEN_PE && exe_sections [ i ] . urva != hdr_size ) { cli_dbgmsg ( ""First<S2SV_blank>section<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>place\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } min = exe_sections [ i ] . rva ; max = exe_sections [ i ] . rva + exe_sections [ i ] . rsz ; } else { if ( DETECT_BROKEN_PE && exe_sections [ i ] . urva - exe_sections [ i - 1 ] . urva != exe_sections [ i - 1 ] . vsz ) { cli_dbgmsg ( ""Virtually<S2SV_blank>misplaced<S2SV_blank>section<S2SV_blank>(wrong<S2SV_blank>order,<S2SV_blank>overlapping,<S2SV_blank>non<S2SV_blank>contiguous)\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } if ( exe_sections [ i ] . rva < min ) min = exe_sections [ i ] . rva ; if ( exe_sections [ i ] . rva + exe_sections [ i ] . rsz > max ) { max = exe_sections [ i ] . rva + exe_sections [ i ] . rsz ; overlays = exe_sections [ i ] . raw + exe_sections [ i ] . rsz ; } } } free ( section_hdr ) ; if ( ! ( ep = cli_rawaddr ( vep , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) { cli_dbgmsg ( ""EntryPoint<S2SV_blank>out<S2SV_blank>of<S2SV_blank>file\\n"" ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } # if HAVE_JSON cli_jsonint ( pe_json , ""EntryPointOffset"" , ep ) ; if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } # endif cli_dbgmsg ( ""EntryPoint<S2SV_blank>offset:<S2SV_blank>0x%x<S2SV_blank>(%d)\\n"" , ep , ep ) ; if ( pe_plus ) { free ( exe_sections ) ; return CL_CLEAN ; } epsize = fmap_readn ( map , epbuff , ep , 4096 ) ; if ( overlays ) { int overlays_sz = fsize - overlays ; if ( overlays_sz > 0 ) { ret = cli_scanishield ( ctx , overlays , overlays_sz ) ; if ( ret != CL_CLEAN ) { free ( exe_sections ) ; return ret ; } } } pedata . nsections = nsections ; pedata . ep = ep ; pedata . offset = 0 ; memcpy ( & pedata . file_hdr , & file_hdr , sizeof ( file_hdr ) ) ; memcpy ( & pedata . opt32 , & pe_opt . opt32 , sizeof ( pe_opt . opt32 ) ) ; memcpy ( & pedata . opt64 , & pe_opt . opt64 , sizeof ( pe_opt . opt64 ) ) ; memcpy ( & pedata . dirs , dirs , sizeof ( pedata . dirs ) ) ; pedata . e_lfanew = e_lfanew ; pedata . overlays = overlays ; pedata . overlays_sz = fsize - overlays ; pedata . hdr_size = hdr_size ; bc_ctx = cli_bytecode_context_alloc ( ) ; if ( ! bc_ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>bc_ctx\\n"" ) ; free ( exe_sections ) ; return CL_EMEM ; } cli_bytecode_context_setpe ( bc_ctx , & pedata , exe_sections ) ; cli_bytecode_context_setctx ( bc_ctx , ctx ) ; ret = cli_bytecode_runhook ( ctx , ctx -> engine , bc_ctx , BC_PE_ALL , map ) ; switch ( ret ) { case CL_ENULLARG : cli_warnmsg ( ""cli_scanpe:<S2SV_blank>NULL<S2SV_blank>argument<S2SV_blank>supplied\\n"" ) ; break ; case CL_VIRUS : case CL_BREAK : free ( exe_sections ) ; cli_bytecode_context_destroy ( bc_ctx ) ; return ret == CL_VIRUS ? CL_VIRUS : CL_CLEAN ; } cli_bytecode_context_destroy ( bc_ctx ) ; if ( SCAN_ALGO && ( DCONF & PE_CONF_PARITE ) && ! dll && epsize == 4096 && ep == exe_sections [ nsections - 1 ] . raw ) { const char * pt = cli_memstr ( epbuff , 4040 , ""\\x47\\x65\\x74\\x50\\x72\\x6f\\x63\\x41\\x64\\x64\\x72\\x65\\x73\\x73\\x00"" , 15 ) ; if ( pt ) { pt += 15 ; if ( ( ( ( uint32_t ) cli_readint32 ( pt ) ^ ( uint32_t ) cli_readint32 ( pt + 4 ) ) == 0x505a4f ) && ( ( ( uint32_t ) cli_readint32 ( pt + 8 ) ^ ( uint32_t ) cli_readint32 ( pt + 12 ) ) == 0xffffb ) && ( ( ( uint32_t ) cli_readint32 ( pt + 16 ) ^ ( uint32_t ) cli_readint32 ( pt + 20 ) ) == 0xb8 ) ) { cli_append_virus ( ctx , ""Heuristics.W32.Parite.B"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } if ( SCAN_ALGO && ( DCONF & PE_CONF_KRIZ ) && epsize >= 200 && CLI_ISCONTAINED ( exe_sections [ nsections - 1 ] . raw , exe_sections [ nsections - 1 ] . rsz , ep , 0x0fd2 ) && epbuff [ 1 ] == '\\x9c' && epbuff [ 2 ] == '\\x60' ) { enum { KZSTRASH , KZSCDELTA , KZSPDELTA , KZSGETSIZE , KZSXORPRFX , KZSXOR , KZSDDELTA , KZSLOOP , KZSTOP } ; uint8_t kzs [ ] = { KZSTRASH , KZSCDELTA , KZSPDELTA , KZSGETSIZE , KZSTRASH , KZSXORPRFX , KZSXOR , KZSTRASH , KZSDDELTA , KZSTRASH , KZSLOOP , KZSTOP } ; uint8_t * kzstate = kzs ; uint8_t * kzcode = ( uint8_t * ) epbuff + 3 ; uint8_t kzdptr = 0xff , kzdsize = 0xff ; int kzlen = 197 , kzinitlen = 0xffff , kzxorlen = - 1 ; cli_dbgmsg ( ""in<S2SV_blank>kriz\\n"" ) ; while ( * kzstate != KZSTOP ) { uint8_t op ; if ( kzlen <= 6 ) break ; op = * kzcode ++ ; kzlen -- ; switch ( * kzstate ) { case KZSTRASH : case KZSGETSIZE : { int opsz = 0 ; switch ( op ) { case 0x81 : kzcode += 5 ; kzlen -= 5 ; break ; case 0xb8 : case 0xb9 : case 0xba : case 0xbb : case 0xbd : case 0xbe : case 0xbf : if ( * kzstate == KZSGETSIZE && cli_readint32 ( kzcode ) == 0x0fd2 ) { kzinitlen = kzlen - 5 ; kzdsize = op - 0xb8 ; kzstate ++ ; op = 4 ; cli_dbgmsg ( ""kriz:<S2SV_blank>using<S2SV_blank>#%d<S2SV_blank>as<S2SV_blank>size<S2SV_blank>counter\\n"" , kzdsize ) ; } opsz = 4 ; case 0x48 : case 0x49 : case 0x4a : case 0x4b : case 0x4d : case 0x4e : case 0x4f : op &= 7 ; if ( op != kzdptr && op != kzdsize ) { kzcode += opsz ; kzlen -= opsz ; break ; } default : kzcode -- ; kzlen ++ ; kzstate ++ ; } break ; } case KZSCDELTA : if ( op == 0xe8 && ( uint32_t ) cli_readint32 ( kzcode ) < 0xff ) { kzlen -= * kzcode + 4 ; kzcode += * kzcode + 4 ; kzstate ++ ; } else * kzstate = KZSTOP ; break ; case KZSPDELTA : if ( ( op & 0xf8 ) == 0x58 && ( kzdptr = op - 0x58 ) != 4 ) { kzstate ++ ; cli_dbgmsg ( ""kriz:<S2SV_blank>using<S2SV_blank>#%d<S2SV_blank>as<S2SV_blank>pointer\\n"" , kzdptr ) ; } else * kzstate = KZSTOP ; break ; case KZSXORPRFX : kzstate ++ ; if ( op == 0x3e ) break ; case KZSXOR : if ( op == 0x80 && * kzcode == kzdptr + 0xb0 ) { kzxorlen = kzlen ; kzcode += + 6 ; kzlen -= + 6 ; kzstate ++ ; } else * kzstate = KZSTOP ; break ; case KZSDDELTA : if ( op == kzdptr + 0x48 ) kzstate ++ ; else * kzstate = KZSTOP ; break ; case KZSLOOP : if ( op == kzdsize + 0x48 && * kzcode == 0x75 && kzlen - ( int8_t ) kzcode [ 1 ] - 3 <= kzinitlen && kzlen - ( int8_t ) kzcode [ 1 ] >= kzxorlen ) { cli_append_virus ( ctx , ""Heuristics.W32.Kriz"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } cli_dbgmsg ( ""kriz:<S2SV_blank>loop<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds,<S2SV_blank>corrupted<S2SV_blank>sample?\\n"" ) ; kzstate ++ ; } } } if ( SCAN_ALGO && ( DCONF & PE_CONF_MAGISTR ) && ! dll && ( nsections > 1 ) && ( exe_sections [ nsections - 1 ] . chr & 0x80000000 ) ) { uint32_t rsize , vsize , dam = 0 ; vsize = exe_sections [ nsections - 1 ] . uvsz ; rsize = exe_sections [ nsections - 1 ] . rsz ; if ( rsize < exe_sections [ nsections - 1 ] . ursz ) { rsize = exe_sections [ nsections - 1 ] . ursz ; dam = 1 ; } if ( vsize >= 0x612c && rsize >= 0x612c && ( ( vsize & 0xff ) == 0xec ) ) { int bw = rsize < 0x7000 ? rsize : 0x7000 ; const char * tbuff ; if ( ( tbuff = fmap_need_off_once ( map , exe_sections [ nsections - 1 ] . raw + rsize - bw , 4096 ) ) ) { if ( cli_memstr ( tbuff , 4091 , ""\\xe8\\x2c\\x61\\x00\\x00"" , 5 ) ) { cli_append_virus ( ctx , dam ? ""Heuristics.W32.Magistr.A.dam"" : ""Heuristics.W32.Magistr.A"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } else if ( rsize >= 0x7000 && vsize >= 0x7000 && ( ( vsize & 0xff ) == 0xed ) ) { int bw = rsize < 0x8000 ? rsize : 0x8000 ; const char * tbuff ; if ( ( tbuff = fmap_need_off_once ( map , exe_sections [ nsections - 1 ] . raw + rsize - bw , 4096 ) ) ) { if ( cli_memstr ( tbuff , 4091 , ""\\xe8\\x04\\x72\\x00\\x00"" , 5 ) ) { cli_append_virus ( ctx , dam ? ""Heuristics.W32.Magistr.B.dam"" : ""Heuristics.W32.Magistr.B"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } } while ( polipos && ! dll && nsections > 2 && nsections < 13 && e_lfanew <= 0x800 && ( EC16 ( optional_hdr32 . Subsystem ) == 2 || EC16 ( optional_hdr32 . Subsystem ) == 3 ) && EC16 ( file_hdr . Machine ) == 0x14c && optional_hdr32 . SizeOfStackReserve >= 0x80000 ) { uint32_t jump , jold , * jumps = NULL ; const uint8_t * code ; unsigned int xsjs = 0 ; if ( exe_sections [ 0 ] . rsz > CLI_MAX_ALLOCATION ) break ; if ( ! exe_sections [ 0 ] . rsz ) break ; if ( ! ( code = fmap_need_off_once ( map , exe_sections [ 0 ] . raw , exe_sections [ 0 ] . rsz ) ) ) break ; for ( i = 0 ; i < exe_sections [ 0 ] . rsz - 5 ; i ++ ) { if ( ( uint8_t ) ( code [ i ] - 0xe8 ) > 1 ) continue ; jump = cli_rawaddr ( exe_sections [ 0 ] . rva + i + 5 + cli_readint32 ( & code [ i + 1 ] ) , exe_sections , nsections , & err , fsize , hdr_size ) ; if ( err || ! CLI_ISCONTAINED ( exe_sections [ polipos ] . raw , exe_sections [ polipos ] . rsz , jump , 9 ) ) continue ; if ( xsjs % 128 == 0 ) { if ( xsjs == 1280 ) break ; if ( ! ( jumps = ( uint32_t * ) cli_realloc2 ( jumps , ( xsjs + 128 ) * sizeof ( uint32_t ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } } j = 0 ; for ( ; j < xsjs ; j ++ ) { if ( jumps [ j ] < jump ) continue ; if ( jumps [ j ] == jump ) { xsjs -- ; break ; } jold = jumps [ j ] ; jumps [ j ] = jump ; jump = jold ; } jumps [ j ] = jump ; xsjs ++ ; } if ( ! xsjs ) break ; cli_dbgmsg ( ""Polipos:<S2SV_blank>Checking<S2SV_blank>%d<S2SV_blank>xsect<S2SV_blank>jump(s)\\n"" , xsjs ) ; for ( i = 0 ; i < xsjs ; i ++ ) { if ( ! ( code = fmap_need_off_once ( map , jumps [ i ] , 9 ) ) ) continue ; if ( ( jump = cli_readint32 ( code ) ) == 0x60ec8b55 || ( code [ 4 ] == 0x0ec && ( ( jump == 0x83ec8b55 && code [ 6 ] == 0x60 ) || ( jump == 0x81ec8b55 && ! code [ 7 ] && ! code [ 8 ] ) ) ) ) { cli_append_virus ( ctx , ""Heuristics.W32.Polipos.A"" ) ; if ( ! SCAN_ALL ) { free ( jumps ) ; free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } free ( jumps ) ; break ; } if ( SCAN_ALGO && ( DCONF & PE_CONF_SWIZZOR ) && nsections > 1 && fsize > 64 * 1024 && fsize < 4 * 1024 * 1024 ) { if ( dirs [ 2 ] . Size ) { struct swizz_stats * stats = cli_calloc ( 1 , sizeof ( * stats ) ) ; unsigned int m = 1000 ; ret = CL_CLEAN ; if ( ! stats ) ret = CL_EMEM ; else { cli_parseres_special ( EC32 ( dirs [ 2 ] . VirtualAddress ) , EC32 ( dirs [ 2 ] . VirtualAddress ) , map , exe_sections , nsections , fsize , hdr_size , 0 , 0 , & m , stats ) ; if ( ( ret = cli_detect_swizz ( stats ) ) == CL_VIRUS ) { cli_append_virus ( ctx , ""Heuristics.Trojan.Swizzor.Gen"" ) ; } free ( stats ) ; } if ( ret != CL_CLEAN ) { if ( ! ( ret == CL_VIRUS && SCAN_ALL ) ) { free ( exe_sections ) ; return ret ; } viruses_found ++ ; } } } corrupted_cur = ctx -> corrupted_input ; ctx -> corrupted_input = 2 ; found = 0 ; if ( DCONF & ( PE_CONF_UPX | PE_CONF_FSG | PE_CONF_MEW ) ) { for ( i = 0 ; i < ( unsigned int ) nsections - 1 ; i ++ ) { if ( ! exe_sections [ i ] . rsz && exe_sections [ i ] . vsz && exe_sections [ i + 1 ] . rsz && exe_sections [ i + 1 ] . vsz ) { found = 1 ; cli_dbgmsg ( ""UPX/FSG/MEW:<S2SV_blank>empty<S2SV_blank>section<S2SV_blank>found<S2SV_blank>-<S2SV_blank>assuming<S2SV_blank>compression\\n"" ) ; # if HAVE_JSON cli_jsonbool ( pe_json , ""HasEmptySection"" , 1 ) ; # endif break ; } } } if ( found && ( DCONF & PE_CONF_MEW ) && epsize >= 16 && epbuff [ 0 ] == '\\xe9' ) { uint32_t fileoffset ; const char * tbuff ; fileoffset = ( vep + cli_readint32 ( epbuff + 1 ) + 5 ) ; while ( fileoffset == 0x154 || fileoffset == 0x158 ) { char * src ; uint32_t offdiff , uselzma ; cli_dbgmsg ( ""MEW:<S2SV_blank>found<S2SV_blank>MEW<S2SV_blank>characteristics<S2SV_blank>%08X<S2SV_blank>+<S2SV_blank>%08X<S2SV_blank>+<S2SV_blank>5<S2SV_blank>=<S2SV_blank>%08X\\n"" , cli_readint32 ( epbuff + 1 ) , vep , cli_readint32 ( epbuff + 1 ) + vep + 5 ) ; if ( ! ( tbuff = fmap_need_off_once ( map , fileoffset , 0xb0 ) ) ) break ; if ( fileoffset == 0x154 ) cli_dbgmsg ( ""MEW:<S2SV_blank>Win9x<S2SV_blank>compatibility<S2SV_blank>was<S2SV_blank>set!\\n"" ) ; else cli_dbgmsg ( ""MEW:<S2SV_blank>Win9x<S2SV_blank>compatibility<S2SV_blank>was<S2SV_blank>NOT<S2SV_blank>set!\\n"" ) ; if ( ( offdiff = cli_readint32 ( tbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) ) <= exe_sections [ i + 1 ] . rva || offdiff >= exe_sections [ i + 1 ] . rva + exe_sections [ i + 1 ] . raw - 4 ) { cli_dbgmsg ( ""MEW:<S2SV_blank>ESI<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>proper<S2SV_blank>section\\n"" ) ; break ; } offdiff -= exe_sections [ i + 1 ] . rva ; if ( ! exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""MEW:<S2SV_blank>mew<S2SV_blank>section<S2SV_blank>is<S2SV_blank>empty\\n"" ) ; break ; } ssize = exe_sections [ i + 1 ] . vsz ; dsize = exe_sections [ i ] . vsz ; cli_dbgmsg ( ""MEW:<S2SV_blank>ssize<S2SV_blank>%08x<S2SV_blank>dsize<S2SV_blank>%08x<S2SV_blank>offdiff:<S2SV_blank>%08x\\n"" , ssize , dsize , offdiff ) ; CLI_UNPSIZELIMITS ( ""MEW"" , MAX ( ssize , dsize ) ) ; CLI_UNPSIZELIMITS ( ""MEW"" , MAX ( ssize + dsize , exe_sections [ i + 1 ] . rsz ) ) ; if ( exe_sections [ i + 1 ] . rsz < offdiff + 12 || exe_sections [ i + 1 ] . rsz > ssize ) { cli_dbgmsg ( ""MEW:<S2SV_blank>Size<S2SV_blank>mismatch:<S2SV_blank>%08x\\n"" , exe_sections [ i + 1 ] . rsz ) ; break ; } if ( ! ( src = cli_calloc ( ssize + dsize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( bytes = fmap_readn ( map , src + dsize , exe_sections [ i + 1 ] . raw , exe_sections [ i + 1 ] . rsz ) ) != exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""MEW:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>[read:<S2SV_blank>%lu]\\n"" , exe_sections [ i + 1 ] . rsz , ( unsigned long ) bytes ) ; free ( exe_sections ) ; free ( src ) ; return CL_EREAD ; } cli_dbgmsg ( ""MEW:<S2SV_blank>%u<S2SV_blank>(%08x)<S2SV_blank>bytes<S2SV_blank>read\\n"" , ( unsigned int ) bytes , ( unsigned int ) bytes ) ; if ( tbuff [ 0x7b ] == '\\xe8' ) { if ( ! CLI_ISCONTAINED ( exe_sections [ 1 ] . rva , exe_sections [ 1 ] . vsz , cli_readint32 ( tbuff + 0x7c ) + fileoffset + 0x80 , 4 ) ) { cli_dbgmsg ( ""MEW:<S2SV_blank>lzma<S2SV_blank>proc<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds!\\n"" ) ; free ( src ) ; break ; } uselzma = cli_readint32 ( tbuff + 0x7c ) - ( exe_sections [ 0 ] . rva - fileoffset - 0x80 ) ; } else { uselzma = 0 ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""MEW"" ) ; # endif CLI_UNPTEMP ( ""MEW"" , ( src , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""MEW"" , ( unmew11 ( src , offdiff , ssize , dsize , EC32 ( optional_hdr32 . ImageBase ) , exe_sections [ 0 ] . rva , uselzma , ndesc ) ) , 1 , ( src , 0 ) ) ; break ; } } if ( epsize < 168 ) { free ( exe_sections ) ; return CL_CLEAN ; } if ( found || upack ) { while ( ( ( upack && nsections == 3 ) && ( ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > min && epbuff [ 5 ] == '\\xad' && epbuff [ 6 ] == '\\x50' ) || ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > min && epbuff [ 5 ] == '\\xff' && epbuff [ 6 ] == '\\x36' ) ) ) || ( ( ! upack && nsections == 2 ) && ( ( epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xe8' && cli_readint32 ( epbuff + 2 ) == 0x9 ) || ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > 0 && epbuff [ 5 ] == '\\xad' && epbuff [ 6 ] == '\\x8b' && epbuff [ 7 ] == '\\xf8' ) ) ) ) { uint32_t vma , off ; int a , b , c ; cli_dbgmsg ( ""Upack<S2SV_blank>characteristics<S2SV_blank>found.\\n"" ) ; a = exe_sections [ 0 ] . vsz ; b = exe_sections [ 1 ] . vsz ; if ( upack ) { cli_dbgmsg ( ""Upack:<S2SV_blank>var<S2SV_blank>set\\n"" ) ; c = exe_sections [ 2 ] . vsz ; ssize = exe_sections [ 0 ] . ursz + exe_sections [ 0 ] . uraw ; off = exe_sections [ 0 ] . rva ; vma = EC32 ( optional_hdr32 . ImageBase ) + exe_sections [ 0 ] . rva ; } else { cli_dbgmsg ( ""Upack:<S2SV_blank>var<S2SV_blank>NOT<S2SV_blank>set\\n"" ) ; c = exe_sections [ 1 ] . rva ; ssize = exe_sections [ 1 ] . uraw ; off = 0 ; vma = exe_sections [ 1 ] . rva - exe_sections [ 1 ] . uraw ; } dsize = a + b + c ; CLI_UNPSIZELIMITS ( ""Upack"" , MAX ( MAX ( dsize , ssize ) , exe_sections [ 1 ] . ursz ) ) ; if ( ! CLI_ISCONTAINED ( 0 , dsize , exe_sections [ 1 ] . rva - off , exe_sections [ 1 ] . ursz ) || ( upack && ! CLI_ISCONTAINED ( 0 , dsize , exe_sections [ 2 ] . rva - exe_sections [ 0 ] . rva , ssize ) ) || ssize > dsize ) { cli_dbgmsg ( ""Upack:<S2SV_blank>probably<S2SV_blank>malformed<S2SV_blank>pe-header,<S2SV_blank>skipping<S2SV_blank>to<S2SV_blank>next<S2SV_blank>unpacker\\n"" ) ; break ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( unsigned int ) fmap_readn ( map , dest , 0 , ssize ) != ssize ) { cli_dbgmsg ( ""Upack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>0\\n"" ) ; free ( dest ) ; break ; } if ( upack ) memmove ( dest + exe_sections [ 2 ] . rva - exe_sections [ 0 ] . rva , dest , ssize ) ; if ( ( unsigned int ) fmap_readn ( map , dest + exe_sections [ 1 ] . rva - off , exe_sections [ 1 ] . uraw , exe_sections [ 1 ] . ursz ) != exe_sections [ 1 ] . ursz ) { cli_dbgmsg ( ""Upack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>1\\n"" ) ; free ( dest ) ; break ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Upack"" ) ; # endif CLI_UNPTEMP ( ""Upack"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Upack"" , ( unupack ( upack , dest , dsize , epbuff , vma , ep , EC32 ( optional_hdr32 . ImageBase ) , exe_sections [ 0 ] . rva , ndesc ) ) , 1 , ( dest , 0 ) ) ; break ; } } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\x87' && epbuff [ 1 ] == '\\x25' ) { const char * dst ; uint32_t newesi , newedi , newebx , newedx ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } newedx = cli_readint32 ( epbuff + 2 ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newedx , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>xchg<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>(%x),<S2SV_blank>giving<S2SV_blank>up\\n"" , newedx ) ; break ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i + 1 ) ; free ( exe_sections ) ; return CL_ESEEK ; } dst = src + newedx - exe_sections [ i + 1 ] . rva ; if ( newedx < exe_sections [ i + 1 ] . rva || ! CLI_ISCONTAINED ( src , ssize , dst , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>ESP<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedx = cli_readint32 ( dst ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newedx , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>ESP<S2SV_blank>(%x)<S2SV_blank>is<S2SV_blank>wrong\\n"" , newedx ) ; break ; } dst = src + newedx - exe_sections [ i + 1 ] . rva ; if ( ! CLI_ISCONTAINED ( src , ssize , dst , 32 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>stack<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedi = cli_readint32 ( dst ) - EC32 ( optional_hdr32 . ImageBase ) ; newesi = cli_readint32 ( dst + 4 ) - EC32 ( optional_hdr32 . ImageBase ) ; newebx = cli_readint32 ( dst + 16 ) - EC32 ( optional_hdr32 . ImageBase ) ; newedx = cli_readint32 ( dst + 20 ) ; if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>buffer<S2SV_blank>(edi<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newebx , 16 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Array<S2SV_blank>of<S2SV_blank>functions<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedx = cli_readint32 ( newebx + 12 - exe_sections [ i + 1 ] . rva + src ) - EC32 ( optional_hdr32 . ImageBase ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , newedx ) ; if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG2 ( ""FSG"" , ( unfsg_200 ( newesi - exe_sections [ i + 1 ] . rva + src , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , newedi , EC32 ( optional_hdr32 . ImageBase ) , newedx , ndesc ) ) , 1 , ( dest , 0 ) ) ; break ; } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min ) { int sectcnt = 0 ; const char * support ; uint32_t newesi , newedi , oldep , gp , t ; struct cli_exe_section * sections ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } if ( ! ( t = cli_rawaddr ( cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) , NULL , 0 , & err , fsize , hdr_size ) ) && err ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Support<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>padding<S2SV_blank>area\\n"" ) ; break ; } gp = exe_sections [ i + 1 ] . raw - t ; CLI_UNPSIZELIMITS ( ""FSG"" , gp ) ; if ( ! ( support = fmap_need_off_once ( map , t , gp ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>padding<S2SV_blank>area\\n"" , gp ) ; free ( exe_sections ) ; return CL_EREAD ; } newedi = cli_readint32 ( support + 4 ) - EC32 ( optional_hdr32 . ImageBase ) ; newesi = cli_readint32 ( support + 8 ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>(is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } for ( t = 12 ; t < gp - 4 ; t += 4 ) { uint32_t rva = cli_readint32 ( support + t ) ; if ( ! rva ) break ; rva -= EC32 ( optional_hdr32 . ImageBase ) + 1 ; sectcnt ++ ; if ( rva % 0x1000 ) cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>misaligned\\n"" , sectcnt ) ; if ( rva < exe_sections [ i ] . rva || rva - exe_sections [ i ] . rva >= exe_sections [ i ] . vsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" , sectcnt ) ; break ; } } if ( t >= gp - 4 || cli_readint32 ( support + t ) ) { break ; } if ( ( sections = ( struct cli_exe_section * ) cli_malloc ( ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ) == NULL ) { cli_errmsg ( ""FSG:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>sections<S2SV_blank>%lu\\n"" , ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ; free ( exe_sections ) ; return CL_EMEM ; } sections [ 0 ] . rva = newedi ; for ( t = 1 ; t <= ( uint32_t ) sectcnt ; t ++ ) sections [ t ] . rva = cli_readint32 ( support + 8 + t * 4 ) - 1 - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i ) ; free ( exe_sections ) ; free ( sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; free ( sections ) ; return CL_EMEM ; } oldep = vep + 161 + 6 + cli_readint32 ( epbuff + 163 ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , oldep ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , sections , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG1 ( ""FSG"" , ( unfsg_133 ( src + newesi - exe_sections [ i + 1 ] . rva , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , sections , sectcnt , EC32 ( optional_hdr32 . ImageBase ) , oldep , ndesc ) ) , 1 , ( dest , sections , 0 ) ) ; break ; } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\xbb' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min && epbuff [ 5 ] == '\\xbf' && epbuff [ 10 ] == '\\xbe' && vep >= exe_sections [ i + 1 ] . rva && vep - exe_sections [ i + 1 ] . rva > exe_sections [ i + 1 ] . rva - 0xe0 ) { int sectcnt = 0 ; uint32_t gp , t = cli_rawaddr ( cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) , NULL , 0 , & err , fsize , hdr_size ) ; const char * support ; uint32_t newesi = cli_readint32 ( epbuff + 11 ) - EC32 ( optional_hdr32 . ImageBase ) ; uint32_t newedi = cli_readint32 ( epbuff + 6 ) - EC32 ( optional_hdr32 . ImageBase ) ; uint32_t oldep = vep - exe_sections [ i + 1 ] . rva ; struct cli_exe_section * sections ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; if ( err ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Support<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>padding<S2SV_blank>area\\n"" ) ; break ; } if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . raw ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>(is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } gp = exe_sections [ i + 1 ] . raw - t ; CLI_UNPSIZELIMITS ( ""FSG"" , gp ) if ( ! ( support = fmap_need_off_once ( map , t , gp ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>padding<S2SV_blank>area\\n"" , gp ) ; free ( exe_sections ) ; return CL_EREAD ; } for ( t = 0 ; t < gp - 2 ; t += 2 ) { uint32_t rva = support [ t ] | ( support [ t + 1 ] << 8 ) ; if ( rva == 2 || rva == 1 ) break ; rva = ( ( rva - 2 ) << 12 ) - EC32 ( optional_hdr32 . ImageBase ) ; sectcnt ++ ; if ( rva < exe_sections [ i ] . rva || rva - exe_sections [ i ] . rva >= exe_sections [ i ] . vsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" , sectcnt ) ; break ; } } if ( t >= gp - 10 || cli_readint32 ( support + t + 6 ) != 2 ) { break ; } if ( ( sections = ( struct cli_exe_section * ) cli_malloc ( ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ) == NULL ) { cli_errmsg ( ""FSG:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>sections<S2SV_blank>%lu\\n"" , ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ; free ( exe_sections ) ; return CL_EMEM ; } sections [ 0 ] . rva = newedi ; for ( t = 0 ; t <= ( uint32_t ) sectcnt - 1 ; t ++ ) { sections [ t + 1 ] . rva = ( ( ( support [ t * 2 ] | ( support [ t * 2 + 1 ] << 8 ) ) - 2 ) << 12 ) - EC32 ( optional_hdr32 . ImageBase ) ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i ) ; free ( exe_sections ) ; free ( sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; free ( sections ) ; return CL_EMEM ; } gp = 0xda + 6 * ( epbuff [ 16 ] == '\\xe8' ) ; oldep = vep + gp + 6 + cli_readint32 ( src + gp + 2 + oldep ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , oldep ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , sections , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG1 ( ""FSG"" , ( unfsg_133 ( src + newesi - exe_sections [ i + 1 ] . rva , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , sections , sectcnt , EC32 ( optional_hdr32 . ImageBase ) , oldep , ndesc ) ) , 1 , ( dest , sections , 0 ) ) ; break ; } if ( found && ( DCONF & PE_CONF_UPX ) ) { ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz + exe_sections [ i + 1 ] . vsz ; CLI_UNPSIZELIMITS ( ""UPX"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>or<S2SV_blank>dsize<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i + 1 ) ; free ( exe_sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize + 8192 , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } if ( cli_memstr ( UPX_NRV2B , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2B , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2B<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2b ; } else if ( cli_memstr ( UPX_NRV2D , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2D , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2D<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2d ; } else if ( cli_memstr ( UPX_NRV2E , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2E , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2E<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2e ; } if ( upxfn ) { int skew = cli_readint32 ( epbuff + 2 ) - EC32 ( optional_hdr32 . ImageBase ) - exe_sections [ i + 1 ] . rva ; if ( epbuff [ 1 ] != '\\xbe' || skew <= 0 || skew > 0xfff ) { skew = 0 ; } else if ( ( unsigned int ) skew > ssize ) { skew = 0 ; } else { cli_dbgmsg ( ""UPX:<S2SV_blank>UPX1<S2SV_blank>seems<S2SV_blank>skewed<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>bytes\\n"" , skew ) ; } if ( upxfn ( src + skew , ssize - skew , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - skew ) >= 0 ) { upx_success = 1 ; } else if ( skew && ( upxfn ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ) ) { upx_success = 1 ; } if ( upx_success ) cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed\\n"" ) ; else cli_dbgmsg ( ""UPX:<S2SV_blank>Preferred<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } if ( ! upx_success && upxfn != upx_inflate2b ) { if ( upx_inflate2b ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2b ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2B<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2B\\n"" ) ; } } if ( ! upx_success && upxfn != upx_inflate2d ) { if ( upx_inflate2d ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2d ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2D<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2D\\n"" ) ; } } if ( ! upx_success && upxfn != upx_inflate2e ) { if ( upx_inflate2e ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2e ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2E<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2E\\n"" ) ; } } if ( cli_memstr ( UPX_LZMA2 , 20 , epbuff + 0x2f , 20 ) ) { uint32_t strictdsize = cli_readint32 ( epbuff + 0x21 ) , skew = 0 ; if ( ssize > 0x15 && epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xbe' ) { skew = cli_readint32 ( epbuff + 2 ) - exe_sections [ i + 1 ] . rva - optional_hdr32 . ImageBase ; if ( skew != 0x15 ) skew = 0 ; } if ( strictdsize <= dsize ) upx_success = upx_inflatelzma ( src + skew , ssize - skew , dest , & strictdsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ; } else if ( cli_memstr ( UPX_LZMA1 , 20 , epbuff + 0x39 , 20 ) ) { uint32_t strictdsize = cli_readint32 ( epbuff + 0x2b ) , skew = 0 ; if ( ssize > 0x15 && epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xbe' ) { skew = cli_readint32 ( epbuff + 2 ) - exe_sections [ i + 1 ] . rva - optional_hdr32 . ImageBase ; if ( skew != 0x15 ) skew = 0 ; } if ( strictdsize <= dsize ) upx_success = upx_inflatelzma ( src + skew , ssize - skew , dest , & strictdsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ; } if ( ! upx_success ) { cli_dbgmsg ( ""UPX:<S2SV_blank>All<S2SV_blank>decompressors<S2SV_blank>failed\\n"" ) ; free ( dest ) ; } } if ( upx_success ) { free ( exe_sections ) ; CLI_UNPTEMP ( ""UPX/FSG"" , ( dest , 0 ) ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""UPX"" ) ; # endif if ( ( unsigned int ) write ( ndesc , dest , dsize ) != dsize ) { cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>Can\'t<S2SV_blank>write<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dsize ) ; free ( tempfile ) ; free ( dest ) ; close ( ndesc ) ; return CL_EWRITE ; } free ( dest ) ; if ( lseek ( ndesc , 0 , SEEK_SET ) == - 1 ) { cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>lseek()<S2SV_blank>failed\\n"" ) ; close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; SHA_RESET ; return CL_ESEEK ; } if ( ctx -> engine -> keeptmp ) cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>Decompressed<S2SV_blank>data<S2SV_blank>saved<S2SV_blank>in<S2SV_blank>%s\\n"" , tempfile ) ; cli_dbgmsg ( ""*****<S2SV_blank>Scanning<S2SV_blank>decompressed<S2SV_blank>file<S2SV_blank>*****\\n"" ) ; SHA_OFF ; if ( ( ret = cli_magic_scandesc ( ndesc , ctx ) ) == CL_VIRUS ) { close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; SHA_RESET ; return CL_VIRUS ; } SHA_RESET ; close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; return ret ; } if ( epsize < 200 ) { free ( exe_sections ) ; return CL_CLEAN ; } found = 2 ; if ( epbuff [ 0 ] != '\\xb8' || ( uint32_t ) cli_readint32 ( epbuff + 1 ) != exe_sections [ nsections - 1 ] . rva + EC32 ( optional_hdr32 . ImageBase ) ) { if ( nsections < 2 || epbuff [ 0 ] != '\\xb8' || ( uint32_t ) cli_readint32 ( epbuff + 1 ) != exe_sections [ nsections - 2 ] . rva + EC32 ( optional_hdr32 . ImageBase ) ) found = 0 ; else found = 1 ; } if ( found && ( DCONF & PE_CONF_PETITE ) ) { cli_dbgmsg ( ""Petite:<S2SV_blank>v2.%d<S2SV_blank>compression<S2SV_blank>detected\\n"" , found ) ; if ( cli_readint32 ( epbuff + 0x80 ) == 0x163c988d ) { cli_dbgmsg ( ""Petite:<S2SV_blank>level<S2SV_blank>zero<S2SV_blank>compression<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet\\n"" ) ; } else { dsize = max - min ; CLI_UNPSIZELIMITS ( ""Petite"" , dsize ) ; if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { cli_dbgmsg ( ""Petite:<S2SV_blank>Can\'t<S2SV_blank>allocate<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dsize ) ; free ( exe_sections ) ; return CL_EMEM ; } for ( i = 0 ; i < nsections ; i ++ ) { if ( exe_sections [ i ] . raw ) { if ( ! exe_sections [ i ] . rsz || ( unsigned int ) fmap_readn ( map , dest + exe_sections [ i ] . rva - min , exe_sections [ i ] . raw , exe_sections [ i ] . ursz ) != exe_sections [ i ] . ursz ) { free ( exe_sections ) ; free ( dest ) ; return CL_CLEAN ; } } } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Petite"" ) ; # endif CLI_UNPTEMP ( ""Petite"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Petite"" , ( petite_inflate2x_1to9 ( dest , min , max - min , exe_sections , nsections - ( found == 1 ? 1 : 0 ) , EC32 ( optional_hdr32 . ImageBase ) , vep , ndesc , found , EC32 ( optional_hdr32 . DataDirectory [ 2 ] . VirtualAddress ) , EC32 ( optional_hdr32 . DataDirectory [ 2 ] . Size ) ) ) , 0 , ( dest , 0 ) ) ; } } if ( ( DCONF & PE_CONF_PESPIN ) && nsections > 1 && vep >= exe_sections [ nsections - 1 ] . rva && vep < exe_sections [ nsections - 1 ] . rva + exe_sections [ nsections - 1 ] . rsz - 0x3217 - 4 && memcmp ( epbuff + 4 , ""\\xe8\\x00\\x00\\x00\\x00\\x8b\\x1c\\x24\\x83\\xc3"" , 10 ) == 0 ) { char * spinned ; CLI_UNPSIZELIMITS ( ""PEspin"" , fsize ) ; if ( ( spinned = ( char * ) cli_malloc ( fsize ) ) == NULL ) { cli_errmsg ( ""PESping:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>spinned<S2SV_blank>%lu\\n"" , ( unsigned long ) fsize ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , spinned , 0 , fsize ) != fsize ) { cli_dbgmsg ( ""PESpin:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) fsize ) ; free ( spinned ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""PEspin"" ) ; # endif CLI_UNPTEMP ( ""PESpin"" , ( spinned , exe_sections , 0 ) ) ; CLI_UNPRESULTS_ ( ""PEspin"" , SPINCASE ( ) , ( unspin ( spinned , fsize , exe_sections , nsections - 1 , vep , ndesc , ctx ) ) , 0 , ( spinned , 0 ) ) ; } if ( ( DCONF & PE_CONF_YC ) && nsections > 1 && ( EC32 ( optional_hdr32 . AddressOfEntryPoint ) == exe_sections [ nsections - 1 ] . rva + 0x60 ) ) { uint32_t ecx = 0 ; int16_t offset ; if ( ! memcmp ( epbuff , ""\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED"" , 15 ) && ! memcmp ( epbuff + 0x26 , ""\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC"" , 13 ) && ( ( uint8_t ) epbuff [ 0x13 ] == 0xB9 ) && ( ( uint16_t ) ( cli_readint16 ( epbuff + 0x18 ) ) == 0xE981 ) && ! memcmp ( epbuff + 0x1e , ""\\x8B\\xD5\\x81\\xC2"" , 4 ) ) { offset = 0 ; if ( 0x6c - cli_readint32 ( epbuff + 0xf ) + cli_readint32 ( epbuff + 0x22 ) == 0xC6 ) ecx = cli_readint32 ( epbuff + 0x14 ) - cli_readint32 ( epbuff + 0x1a ) ; } if ( ! ecx && ! memcmp ( epbuff , ""\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57"" , 9 ) && ! memcmp ( epbuff + 0x17 , ""\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed"" , 8 ) && ( ( uint8_t ) epbuff [ 0x23 ] == 0xB9 ) ) { offset = 0x10 ; if ( 0x6c - cli_readint32 ( epbuff + 0x1f ) + cli_readint32 ( epbuff + 0x32 ) == 0xC6 ) ecx = cli_readint32 ( epbuff + 0x24 ) - cli_readint32 ( epbuff + 0x2a ) ; } if ( ! ecx && ! memcmp ( epbuff , ""\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed"" , 9 ) && ( ( uint8_t ) epbuff [ 0xd ] == 0xb9 ) && ( ( uint16_t ) cli_readint16 ( epbuff + 0x12 ) == 0xbd8d ) && ! memcmp ( epbuff + 0x18 , ""\\x8b\\xf7\\xac"" , 3 ) ) { offset = - 0x18 ; if ( 0x66 - cli_readint32 ( epbuff + 0x9 ) + cli_readint32 ( epbuff + 0x14 ) == 0xae ) ecx = cli_readint32 ( epbuff + 0xe ) ; } if ( ecx > 0x800 && ecx < 0x2000 && ! memcmp ( epbuff + 0x63 + offset , ""\\xaa\\xe2\\xcc"" , 3 ) && ( fsize >= exe_sections [ nsections - 1 ] . raw + 0xC6 + ecx + offset ) ) { char * spinned ; if ( ( spinned = ( char * ) cli_malloc ( fsize ) ) == NULL ) { cli_errmsg ( ""yC:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>spinned<S2SV_blank>%lu\\n"" , ( unsigned long ) fsize ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , spinned , 0 , fsize ) != fsize ) { cli_dbgmsg ( ""yC:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) fsize ) ; free ( spinned ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""yC"" ) ; # endif cli_dbgmsg ( ""%d,%d,%d,%d\\n"" , nsections - 1 , e_lfanew , ecx , offset ) ; CLI_UNPTEMP ( ""yC"" , ( spinned , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""yC"" , ( yc_decrypt ( spinned , fsize , exe_sections , nsections - 1 , e_lfanew , ndesc , ecx , offset ) ) , 0 , ( spinned , 0 ) ) ; } } while ( ( DCONF & PE_CONF_WWPACK ) && nsections > 1 && vep == exe_sections [ nsections - 1 ] . rva && memcmp ( epbuff , ""\\x53\\x55\\x8b\\xe8\\x33\\xdb\\xeb"" , 7 ) == 0 && memcmp ( epbuff + 0x68 , ""\\xe8\\x00\\x00\\x00\\x00\\x58\\x2d\\x6d\\x00\\x00\\x00\\x50\\x60\\x33\\xc9\\x50\\x58\\x50\\x50"" , 19 ) == 0 ) { uint32_t head = exe_sections [ nsections - 1 ] . raw ; uint8_t * packer ; char * src ; ssize = 0 ; for ( i = 0 ; ; i ++ ) { if ( exe_sections [ i ] . raw < head ) head = exe_sections [ i ] . raw ; if ( i + 1 == nsections ) break ; if ( ssize < exe_sections [ i ] . rva + exe_sections [ i ] . vsz ) ssize = exe_sections [ i ] . rva + exe_sections [ i ] . vsz ; } if ( ! head || ! ssize || head > ssize ) break ; CLI_UNPSIZELIMITS ( ""WWPack"" , ssize ) ; if ( ! ( src = ( char * ) cli_calloc ( ssize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , src , 0 , head ) != head ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>headers\\n"" , head ) ; free ( src ) ; free ( exe_sections ) ; return CL_EREAD ; } for ( i = 0 ; i < ( unsigned int ) nsections - 1 ; i ++ ) { if ( ! exe_sections [ i ] . rsz ) continue ; if ( ! CLI_ISCONTAINED ( src , ssize , src + exe_sections [ i ] . rva , exe_sections [ i ] . rsz ) ) break ; if ( ( unsigned int ) fmap_readn ( map , src + exe_sections [ i ] . rva , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) != exe_sections [ i ] . rsz ) break ; } if ( i + 1 != nsections ) { cli_dbgmsg ( ""WWpack:<S2SV_blank>Probably<S2SV_blank>hacked/damaged<S2SV_blank>file.\\n"" ) ; free ( src ) ; break ; } if ( ( packer = ( uint8_t * ) cli_calloc ( exe_sections [ nsections - 1 ] . rsz , sizeof ( char ) ) ) == NULL ) { free ( src ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ! exe_sections [ nsections - 1 ] . rsz || ( size_t ) fmap_readn ( map , packer , exe_sections [ nsections - 1 ] . raw , exe_sections [ nsections - 1 ] . rsz ) != exe_sections [ nsections - 1 ] . rsz ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>wwpack<S2SV_blank>sect\\n"" , exe_sections [ nsections - 1 ] . rsz ) ; free ( src ) ; free ( packer ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""WWPack"" ) ; # endif CLI_UNPTEMP ( ""WWPack"" , ( src , packer , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""WWPack"" , ( wwunpack ( ( uint8_t * ) src , ssize , packer , exe_sections , nsections - 1 , e_lfanew , ndesc ) ) , 0 , ( src , packer , 0 ) ) ; break ; } while ( ( DCONF & PE_CONF_ASPACK ) && ep + 58 + 0x70e < fsize && ! memcmp ( epbuff , ""\\x60\\xe8\\x03\\x00\\x00\\x00\\xe9\\xeb"" , 8 ) ) { char * src ; if ( epsize < 0x3bf || memcmp ( epbuff + 0x3b9 , ""\\x68\\x00\\x00\\x00\\x00\\xc3"" , 6 ) ) break ; ssize = 0 ; for ( i = 0 ; i < nsections ; i ++ ) if ( ssize < exe_sections [ i ] . rva + exe_sections [ i ] . vsz ) ssize = exe_sections [ i ] . rva + exe_sections [ i ] . vsz ; if ( ! ssize ) break ; CLI_UNPSIZELIMITS ( ""Aspack"" , ssize ) ; if ( ! ( src = ( char * ) cli_calloc ( ssize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } for ( i = 0 ; i < ( unsigned int ) nsections ; i ++ ) { if ( ! exe_sections [ i ] . rsz ) continue ; if ( ! CLI_ISCONTAINED ( src , ssize , src + exe_sections [ i ] . rva , exe_sections [ i ] . rsz ) ) break ; if ( ( unsigned int ) fmap_readn ( map , src + exe_sections [ i ] . rva , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) != exe_sections [ i ] . rsz ) break ; } if ( i != nsections ) { cli_dbgmsg ( ""Aspack:<S2SV_blank>Probably<S2SV_blank>hacked/damaged<S2SV_blank>Aspack<S2SV_blank>file.\\n"" ) ; free ( src ) ; break ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Aspack"" ) ; # endif CLI_UNPTEMP ( ""Aspack"" , ( src , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Aspack"" , ( unaspack212 ( ( uint8_t * ) src , ssize , exe_sections , nsections , vep - 1 , EC32 ( optional_hdr32 . ImageBase ) , ndesc ) ) , 1 , ( src , 0 ) ) ; break ; } while ( DCONF & PE_CONF_NSPACK ) { uint32_t eprva = vep ; uint32_t start_of_stuff , rep = ep ; unsigned int nowinldr ; const char * nbuff ; src = epbuff ; if ( * epbuff == '\\xe9' ) { eprva = cli_readint32 ( epbuff + 1 ) + vep + 5 ; if ( ! ( rep = cli_rawaddr ( eprva , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) break ; if ( ! ( nbuff = fmap_need_off_once ( map , rep , 24 ) ) ) break ; src = nbuff ; } if ( memcmp ( src , ""\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00"" , 13 ) ) break ; nowinldr = 0x54 - cli_readint32 ( src + 17 ) ; cli_dbgmsg ( ""NsPack:<S2SV_blank>Found<S2SV_blank>*start_of_stuff<S2SV_blank>@delta-%x\\n"" , nowinldr ) ; if ( ! ( nbuff = fmap_need_off_once ( map , rep - nowinldr , 4 ) ) ) break ; start_of_stuff = rep + cli_readint32 ( nbuff ) ; if ( ! ( nbuff = fmap_need_off_once ( map , start_of_stuff , 20 ) ) ) break ; src = nbuff ; if ( ! cli_readint32 ( nbuff ) ) { start_of_stuff += 4 ; src += 4 ; } ssize = cli_readint32 ( src + 5 ) | 0xff ; dsize = cli_readint32 ( src + 9 ) ; CLI_UNPSIZELIMITS ( ""NsPack"" , MAX ( ssize , dsize ) ) ; if ( ! ssize || ! dsize || dsize != exe_sections [ 0 ] . vsz ) break ; if ( ! ( dest = cli_malloc ( dsize ) ) ) { cli_errmsg ( ""NsPack:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>dest<S2SV_blank>%u\\n"" , dsize ) ; break ; } if ( ! ( src = fmap_need_off ( map , start_of_stuff , ssize ) ) ) { free ( dest ) ; break ; } eprva += 0x27a ; if ( ! ( rep = cli_rawaddr ( eprva , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) { free ( dest ) ; break ; } if ( ! ( nbuff = fmap_need_off_once ( map , rep , 5 ) ) ) { free ( dest ) ; break ; } fmap_unneed_off ( map , start_of_stuff , ssize ) ; eprva = eprva + 5 + cli_readint32 ( nbuff + 1 ) ; cli_dbgmsg ( ""NsPack:<S2SV_blank>OEP<S2SV_blank>=<S2SV_blank>%08x\\n"" , eprva ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""NsPack"" ) ; # endif CLI_UNPTEMP ( ""NsPack"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""NsPack"" , ( unspack ( src , dest , ctx , exe_sections [ 0 ] . rva , EC32 ( optional_hdr32 . ImageBase ) , eprva , ndesc ) ) , 0 , ( dest , 0 ) ) ; break ; } ctx -> corrupted_input = corrupted_cur ; bc_ctx = cli_bytecode_context_alloc ( ) ; if ( ! bc_ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>bc_ctx\\n"" ) ; return CL_EMEM ; } cli_bytecode_context_setpe ( bc_ctx , & pedata , exe_sections ) ; cli_bytecode_context_setctx ( bc_ctx , ctx ) ; ret = cli_bytecode_runhook ( ctx , ctx -> engine , bc_ctx , BC_PE_UNPACKER , map ) ; switch ( ret ) { case CL_VIRUS : free ( exe_sections ) ; cli_bytecode_context_destroy ( bc_ctx ) ; return CL_VIRUS ; case CL_SUCCESS : ndesc = cli_bytecode_context_getresult_file ( bc_ctx , & tempfile ) ; cli_bytecode_context_destroy ( bc_ctx ) ; if ( ndesc != - 1 && tempfile ) { CLI_UNPRESULTS ( ""bytecode<S2SV_blank>PE<S2SV_blank>hook"" , 1 , 1 , ( 0 ) ) ; } break ; default : cli_bytecode_context_destroy ( bc_ctx ) ; } free ( exe_sections ) ; # if HAVE_JSON if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } # endif if ( SCAN_ALL && viruses_found ) return CL_VIRUS ; return CL_CLEAN ; }","unsigned int i , j , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 , rescan = 1 ;unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ;uint32_t valign , falign , hdr_size ;struct cli_exe_section * exe_sections ;# endif while ( rescan == 1 ) {rescan = 0 ;const char * archtype = NULL , * subsystem = NULL ;",1674
682,"buggy line: cwe id:CWE-119context: int cli_scanpe ( cli_ctx * ctx ) { uint16_t e_magic ; uint16_t nsections ; uint32_t e_lfanew ; uint32_t ep , vep ; uint8_t polipos = 0 ; time_t timestamp ; struct pe_image_file_hdr file_hdr ; union { struct pe_image_optional_hdr64 opt64 ; struct pe_image_optional_hdr32 opt32 ; } pe_opt ; struct pe_image_section_hdr * section_hdr ; char sname [ 9 ] , epbuff [ 4096 ] , * tempfile ; uint32_t epsize ; ssize_t bytes , at ;  unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ;  unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ; int ( * upxfn ) ( const char * , uint32_t , char * , uint32_t * , uint32_t , uint32_t , uint32_t ) = NULL ; const char * src = NULL ; char * dest = NULL ; int ndesc , ret = CL_CLEAN , upack = 0 , native = 0 ; size_t fsize ;  uint32_t valign , falign , hdr_size , j ;  struct cli_exe_section * exe_sections ; char timestr [ 32 ] ; struct pe_image_data_dir * dirs ; struct cli_bc_ctx * bc_ctx ; fmap_t * map ; struct cli_pe_hook_data pedata ; # ifdef HAVE__INTERNAL__SHA_COLLECT int sha_collect = ctx -> sha_collect ; # endif const char * archtype = NULL , * subsystem = NULL ; uint32_t viruses_found = 0 ; # if HAVE_JSON int toval = 0 ; struct json_object * pe_json = NULL ; char jsonbuf [ 128 ] ; # endif if ( ! ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>ctx<S2SV_blank>==<S2SV_blank>NULL\\n"" ) ; return CL_ENULLARG ; } # if HAVE_JSON if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } if ( ctx -> options & CL_SCAN_FILE_PROPERTIES ) { pe_json = get_pe_property ( ctx ) ; } # endif map = * ctx -> fmap ; if ( fmap_readn ( map , & e_magic , 0 , sizeof ( e_magic ) ) != sizeof ( e_magic ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>DOS<S2SV_blank>signature\\n"" ) ; return CL_CLEAN ; } if ( EC16 ( e_magic ) != PE_IMAGE_DOS_SIGNATURE && EC16 ( e_magic ) != PE_IMAGE_DOS_SIGNATURE_OLD ) { cli_dbgmsg ( ""Invalid<S2SV_blank>DOS<S2SV_blank>signature\\n"" ) ; return CL_CLEAN ; } if ( fmap_readn ( map , & e_lfanew , 58 + sizeof ( e_magic ) , sizeof ( e_lfanew ) ) != sizeof ( e_lfanew ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>new<S2SV_blank>header<S2SV_blank>address\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } e_lfanew = EC32 ( e_lfanew ) ; cli_dbgmsg ( ""e_lfanew<S2SV_blank>==<S2SV_blank>%d\\n"" , e_lfanew ) ; if ( ! e_lfanew ) { cli_dbgmsg ( ""Not<S2SV_blank>a<S2SV_blank>PE<S2SV_blank>file\\n"" ) ; return CL_CLEAN ; } if ( fmap_readn ( map , & file_hdr , e_lfanew , sizeof ( struct pe_image_file_hdr ) ) != sizeof ( struct pe_image_file_hdr ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>file<S2SV_blank>header\\n"" ) ; return CL_CLEAN ; } if ( EC32 ( file_hdr . Magic ) != PE_IMAGE_NT_SIGNATURE ) { cli_dbgmsg ( ""Invalid<S2SV_blank>PE<S2SV_blank>signature<S2SV_blank>(probably<S2SV_blank>NE<S2SV_blank>file)\\n"" ) ; return CL_CLEAN ; } if ( EC16 ( file_hdr . Characteristics ) & 0x2000 ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json , ""Type"" , ""DLL"" ) ; # endif cli_dbgmsg ( ""File<S2SV_blank>type:<S2SV_blank>DLL\\n"" ) ; dll = 1 ; } else if ( EC16 ( file_hdr . Characteristics ) & 0x01 ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json , ""Type"" , ""EXE"" ) ; # endif cli_dbgmsg ( ""File<S2SV_blank>type:<S2SV_blank>Executable\\n"" ) ; } switch ( EC16 ( file_hdr . Machine ) ) { case 0x0 : archtype = ""Unknown"" ; break ; case 0x14c : archtype = ""80386"" ; break ; case 0x14d : archtype = ""80486"" ; break ; case 0x14e : archtype = ""80586"" ; break ; case 0x160 : archtype = ""R30000<S2SV_blank>(big-endian)"" ; break ; case 0x162 : archtype = ""R3000"" ; break ; case 0x166 : archtype = ""R4000"" ; break ; case 0x168 : archtype = ""R10000"" ; break ; case 0x184 : archtype = ""DEC<S2SV_blank>Alpha<S2SV_blank>AXP"" ; break ; case 0x284 : archtype = ""DEC<S2SV_blank>Alpha<S2SV_blank>AXP<S2SV_blank>64bit"" ; break ; case 0x1f0 : archtype = ""PowerPC"" ; break ; case 0x200 : archtype = ""IA64"" ; break ; case 0x268 : archtype = ""M68k"" ; break ; case 0x266 : archtype = ""MIPS16"" ; break ; case 0x366 : archtype = ""MIPS+FPU"" ; break ; case 0x466 : archtype = ""MIPS16+FPU"" ; break ; case 0x1a2 : archtype = ""Hitachi<S2SV_blank>SH3"" ; break ; case 0x1a3 : archtype = ""Hitachi<S2SV_blank>SH3-DSP"" ; break ; case 0x1a4 : archtype = ""Hitachi<S2SV_blank>SH3-E"" ; break ; case 0x1a6 : archtype = ""Hitachi<S2SV_blank>SH4"" ; break ; case 0x1a8 : archtype = ""Hitachi<S2SV_blank>SH5"" ; break ; case 0x1c0 : archtype = ""ARM"" ; break ; case 0x1c2 : archtype = ""THUMB"" ; break ; case 0x1d3 : archtype = ""AM33"" ; break ; case 0x520 : archtype = ""Infineon<S2SV_blank>TriCore"" ; break ; case 0xcef : archtype = ""CEF"" ; break ; case 0xebc : archtype = ""EFI<S2SV_blank>Byte<S2SV_blank>Code"" ; break ; case 0x9041 : archtype = ""M32R"" ; break ; case 0xc0ee : archtype = ""CEEE"" ; break ; case 0x8664 : archtype = ""AMD64"" ; break ; default : archtype = ""Unknown"" ; } if ( ( archtype ) ) { cli_dbgmsg ( ""Machine<S2SV_blank>type:<S2SV_blank>%s\\n"" , archtype ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""ArchType"" , archtype ) ; # endif } nsections = EC16 ( file_hdr . NumberOfSections ) ; if ( nsections < 1 || nsections > 96 ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadNumberOfSections"" ) ; # endif if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } if ( ! ctx -> corrupted_input ) { if ( nsections ) cli_warnmsg ( ""PE<S2SV_blank>file<S2SV_blank>contains<S2SV_blank>%d<S2SV_blank>sections\\n"" , nsections ) ; else cli_warnmsg ( ""PE<S2SV_blank>file<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>sections\\n"" ) ; } return CL_CLEAN ; } cli_dbgmsg ( ""NumberOfSections:<S2SV_blank>%d\\n"" , nsections ) ; timestamp = ( time_t ) EC32 ( file_hdr . TimeDateStamp ) ; cli_dbgmsg ( ""TimeDateStamp:<S2SV_blank>%s"" , cli_ctime ( & timestamp , timestr , sizeof ( timestr ) ) ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""TimeDateStamp"" , cli_ctime ( & timestamp , timestr , sizeof ( timestr ) ) ) ; # endif cli_dbgmsg ( ""SizeOfOptionalHeader:<S2SV_blank>%x\\n"" , EC16 ( file_hdr . SizeOfOptionalHeader ) ) ; # if HAVE_JSON cli_jsonint ( pe_json , ""SizeOfOptionalHeader"" , EC16 ( file_hdr . SizeOfOptionalHeader ) ) ; # endif if ( EC16 ( file_hdr . SizeOfOptionalHeader ) < sizeof ( struct pe_image_optional_hdr32 ) ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadOptionalHeaderSize"" ) ; # endif cli_dbgmsg ( ""SizeOfOptionalHeader<S2SV_blank>too<S2SV_blank>small\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at = e_lfanew + sizeof ( struct pe_image_file_hdr ) ; if ( fmap_readn ( map , & optional_hdr32 , at , sizeof ( struct pe_image_optional_hdr32 ) ) != sizeof ( struct pe_image_optional_hdr32 ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>optional<S2SV_blank>file<S2SV_blank>header\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_optional_hdr32 ) ; if ( EC16 ( optional_hdr64 . Magic ) == PE32P_SIGNATURE ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadOptionalHeaderSizePE32Plus"" ) ; # endif if ( EC16 ( file_hdr . SizeOfOptionalHeader ) != sizeof ( struct pe_image_optional_hdr64 ) ) { cli_dbgmsg ( ""Incorrect<S2SV_blank>SizeOfOptionalHeader<S2SV_blank>for<S2SV_blank>PE32+\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } pe_plus = 1 ; } if ( ! pe_plus ) { if ( EC16 ( file_hdr . SizeOfOptionalHeader ) != sizeof ( struct pe_image_optional_hdr32 ) ) { at += EC16 ( file_hdr . SizeOfOptionalHeader ) - sizeof ( struct pe_image_optional_hdr32 ) ; } if ( DCONF & PE_CONF_UPACK ) upack = ( EC16 ( file_hdr . SizeOfOptionalHeader ) == 0x148 ) ; vep = EC32 ( optional_hdr32 . AddressOfEntryPoint ) ; hdr_size = EC32 ( optional_hdr32 . SizeOfHeaders ) ; cli_dbgmsg ( ""File<S2SV_blank>format:<S2SV_blank>PE\\n"" ) ; cli_dbgmsg ( ""MajorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr32 . MajorLinkerVersion ) ; cli_dbgmsg ( ""MinorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr32 . MinorLinkerVersion ) ; cli_dbgmsg ( ""SizeOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfCode ) ) ; cli_dbgmsg ( ""SizeOfInitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfInitializedData ) ) ; cli_dbgmsg ( ""SizeOfUninitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfUninitializedData ) ) ; cli_dbgmsg ( ""AddressOfEntryPoint:<S2SV_blank>0x%x\\n"" , vep ) ; cli_dbgmsg ( ""BaseOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . BaseOfCode ) ) ; cli_dbgmsg ( ""SectionAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SectionAlignment ) ) ; cli_dbgmsg ( ""FileAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . FileAlignment ) ) ; cli_dbgmsg ( ""MajorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr32 . MajorSubsystemVersion ) ) ; cli_dbgmsg ( ""MinorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr32 . MinorSubsystemVersion ) ) ; cli_dbgmsg ( ""SizeOfImage:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfImage ) ) ; cli_dbgmsg ( ""SizeOfHeaders:<S2SV_blank>0x%x\\n"" , hdr_size ) ; cli_dbgmsg ( ""NumberOfRvaAndSizes:<S2SV_blank>%d\\n"" , EC32 ( optional_hdr32 . NumberOfRvaAndSizes ) ) ; dirs = optional_hdr32 . DataDirectory ; # if HAVE_JSON cli_jsonint ( pe_json , ""MajorLinkerVersion"" , optional_hdr32 . MajorLinkerVersion ) ; cli_jsonint ( pe_json , ""MinorLinkerVersion"" , optional_hdr32 . MinorLinkerVersion ) ; cli_jsonint ( pe_json , ""SizeOfCode"" , EC32 ( optional_hdr32 . SizeOfCode ) ) ; cli_jsonint ( pe_json , ""SizeOfInitializedData"" , EC32 ( optional_hdr32 . SizeOfInitializedData ) ) ; cli_jsonint ( pe_json , ""SizeOfUninitializedData"" , EC32 ( optional_hdr32 . SizeOfUninitializedData ) ) ; cli_jsonint ( pe_json , ""NumberOfRvaAndSizes"" , EC32 ( optional_hdr32 . NumberOfRvaAndSizes ) ) ; cli_jsonint ( pe_json , ""MajorSubsystemVersion"" , EC16 ( optional_hdr32 . MajorSubsystemVersion ) ) ; cli_jsonint ( pe_json , ""MinorSubsystemVersion"" , EC16 ( optional_hdr32 . MinorSubsystemVersion ) ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . BaseOfCode ) ) ; cli_jsonstr ( pe_json , ""BaseOfCode"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . SectionAlignment ) ) ; cli_jsonstr ( pe_json , ""SectionAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . FileAlignment ) ) ; cli_jsonstr ( pe_json , ""FileAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . SizeOfImage ) ) ; cli_jsonstr ( pe_json , ""SizeOfImage"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , hdr_size ) ; cli_jsonstr ( pe_json , ""SizeOfHeaders"" , jsonbuf ) ; # endif } else { if ( fmap_readn ( map , & optional_hdr32 + 1 , at , sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ) != sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>optional<S2SV_blank>file<S2SV_blank>header\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ; vep = EC32 ( optional_hdr64 . AddressOfEntryPoint ) ; hdr_size = EC32 ( optional_hdr64 . SizeOfHeaders ) ; cli_dbgmsg ( ""File<S2SV_blank>format:<S2SV_blank>PE32+\\n"" ) ; cli_dbgmsg ( ""MajorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr64 . MajorLinkerVersion ) ; cli_dbgmsg ( ""MinorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr64 . MinorLinkerVersion ) ; cli_dbgmsg ( ""SizeOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfCode ) ) ; cli_dbgmsg ( ""SizeOfInitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfInitializedData ) ) ; cli_dbgmsg ( ""SizeOfUninitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfUninitializedData ) ) ; cli_dbgmsg ( ""AddressOfEntryPoint:<S2SV_blank>0x%x\\n"" , vep ) ; cli_dbgmsg ( ""BaseOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . BaseOfCode ) ) ; cli_dbgmsg ( ""SectionAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SectionAlignment ) ) ; cli_dbgmsg ( ""FileAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . FileAlignment ) ) ; cli_dbgmsg ( ""MajorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr64 . MajorSubsystemVersion ) ) ; cli_dbgmsg ( ""MinorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr64 . MinorSubsystemVersion ) ) ; cli_dbgmsg ( ""SizeOfImage:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfImage ) ) ; cli_dbgmsg ( ""SizeOfHeaders:<S2SV_blank>0x%x\\n"" , hdr_size ) ; cli_dbgmsg ( ""NumberOfRvaAndSizes:<S2SV_blank>%d\\n"" , EC32 ( optional_hdr64 . NumberOfRvaAndSizes ) ) ; dirs = optional_hdr64 . DataDirectory ; # if HAVE_JSON cli_jsonint ( pe_json , ""MajorLinkerVersion"" , optional_hdr64 . MajorLinkerVersion ) ; cli_jsonint ( pe_json , ""MinorLinkerVersion"" , optional_hdr64 . MinorLinkerVersion ) ; cli_jsonint ( pe_json , ""SizeOfCode"" , EC32 ( optional_hdr64 . SizeOfCode ) ) ; cli_jsonint ( pe_json , ""SizeOfInitializedData"" , EC32 ( optional_hdr64 . SizeOfInitializedData ) ) ; cli_jsonint ( pe_json , ""SizeOfUninitializedData"" , EC32 ( optional_hdr64 . SizeOfUninitializedData ) ) ; cli_jsonint ( pe_json , ""NumberOfRvaAndSizes"" , EC32 ( optional_hdr64 . NumberOfRvaAndSizes ) ) ; cli_jsonint ( pe_json , ""MajorSubsystemVersion"" , EC16 ( optional_hdr64 . MajorSubsystemVersion ) ) ; cli_jsonint ( pe_json , ""MinorSubsystemVersion"" , EC16 ( optional_hdr64 . MinorSubsystemVersion ) ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . BaseOfCode ) ) ; cli_jsonstr ( pe_json , ""BaseOfCode"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . SectionAlignment ) ) ; cli_jsonstr ( pe_json , ""SectionAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . FileAlignment ) ) ; cli_jsonstr ( pe_json , ""FileAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . SizeOfImage ) ) ; cli_jsonstr ( pe_json , ""SizeOfImage"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , hdr_size ) ; cli_jsonstr ( pe_json , ""SizeOfHeaders"" , jsonbuf ) ; # endif } # if HAVE_JSON if ( ctx -> options & CL_SCAN_FILE_PROPERTIES ) { snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , vep ) ; cli_jsonstr ( pe_json , ""EntryPoint"" , jsonbuf ) ; } # endif switch ( pe_plus ? EC16 ( optional_hdr64 . Subsystem ) : EC16 ( optional_hdr32 . Subsystem ) ) { case 0 : subsystem = ""Unknown"" ; break ; case 1 : subsystem = ""Native<S2SV_blank>(svc)"" ; native = 1 ; break ; case 2 : subsystem = ""Win32<S2SV_blank>GUI"" ; break ; case 3 : subsystem = ""Win32<S2SV_blank>console"" ; break ; case 5 : subsystem = ""OS/2<S2SV_blank>console"" ; break ; case 7 : subsystem = ""POSIX<S2SV_blank>console"" ; break ; case 8 : subsystem = ""Native<S2SV_blank>Win9x<S2SV_blank>driver"" ; break ; case 9 : subsystem = ""WinCE<S2SV_blank>GUI"" ; break ; case 10 : subsystem = ""EFI<S2SV_blank>application"" ; break ; case 11 : subsystem = ""EFI<S2SV_blank>driver"" ; break ; case 12 : subsystem = ""EFI<S2SV_blank>runtime<S2SV_blank>driver"" ; break ; case 13 : subsystem = ""EFI<S2SV_blank>ROM<S2SV_blank>image"" ; break ; case 14 : subsystem = ""Xbox"" ; break ; case 16 : subsystem = ""Boot<S2SV_blank>application"" ; break ; default : subsystem = ""Unknown"" ; } cli_dbgmsg ( ""Subsystem:<S2SV_blank>%s\\n"" , subsystem ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Subsystem"" , subsystem ) ; # endif cli_dbgmsg ( ""------------------------------------\\n"" ) ; if ( DETECT_BROKEN_PE && ! native && ( ! ( pe_plus ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ) || ( pe_plus ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ) % 0x1000 ) ) { cli_dbgmsg ( ""Bad<S2SV_blank>virtual<S2SV_blank>alignemnt\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } if ( DETECT_BROKEN_PE && ! native && ( ! ( pe_plus ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ) || ( pe_plus ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ) % 0x200 ) ) { cli_dbgmsg ( ""Bad<S2SV_blank>file<S2SV_blank>alignemnt\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } fsize = map -> len ; section_hdr = ( struct pe_image_section_hdr * ) cli_calloc ( nsections , sizeof ( struct pe_image_section_hdr ) ) ; if ( ! section_hdr ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>section<S2SV_blank>headers\\n"" ) ; return CL_EMEM ; } exe_sections = ( struct cli_exe_section * ) cli_calloc ( nsections , sizeof ( struct cli_exe_section ) ) ; if ( ! exe_sections ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>section<S2SV_blank>headers\\n"" ) ; free ( section_hdr ) ; return CL_EMEM ; } valign = ( pe_plus ) ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ; falign = ( pe_plus ) ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ; if ( fmap_readn ( map , section_hdr , at , sizeof ( struct pe_image_section_hdr ) * nsections ) != ( int ) ( nsections * sizeof ( struct pe_image_section_hdr ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>section<S2SV_blank>header\\n"" ) ; cli_dbgmsg ( ""Possibly<S2SV_blank>broken<S2SV_blank>PE<S2SV_blank>file\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_section_hdr ) * nsections ; for ( i = 0 ; falign != 0x200 && i < nsections ; i ++ ) { if ( falign && section_hdr [ i ] . SizeOfRawData && EC32 ( section_hdr [ i ] . PointerToRawData ) % falign && ! ( EC32 ( section_hdr [ i ] . PointerToRawData ) % 0x200 ) ) { cli_dbgmsg ( ""Found<S2SV_blank>misaligned<S2SV_blank>section,<S2SV_blank>using<S2SV_blank>0x200\\n"" ) ; falign = 0x200 ; } } hdr_size = PESALIGN ( hdr_size , valign ) ; # if HAVE_JSON cli_jsonint ( pe_json , ""NumberOfSections"" , nsections ) ; # endif  for ( i = 0 ; i < nsections ; i ++ ) {   strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ;   sname [ 8 ] = 0 ;  exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; # if HAVE_JSON add_section_info ( ctx , & exe_sections [ i ] ) ; if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { free ( section_hdr ) ; free ( exe_sections ) ; return CL_ETIMEOUT ; } # endif if ( ! exe_sections [ i ] . vsz && exe_sections [ i ] . rsz ) exe_sections [ i ] . vsz = PESALIGN ( exe_sections [ i ] . ursz , valign ) ; if ( exe_sections [ i ] . rsz && fsize > exe_sections [ i ] . raw && ! CLI_ISCONTAINED ( 0 , ( uint32_t ) fsize , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) ) exe_sections [ i ] . rsz = fsize - exe_sections [ i ] . raw ; cli_dbgmsg ( ""Section<S2SV_blank>%d\\n"" , i ) ; cli_dbgmsg ( ""Section<S2SV_blank>name:<S2SV_blank>%s\\n"" , sname ) ; cli_dbgmsg ( ""Section<S2SV_blank>data<S2SV_blank>(from<S2SV_blank>headers<S2SV_blank>-<S2SV_blank>in<S2SV_blank>memory)\\n"" ) ; cli_dbgmsg ( ""VirtualSize:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . uvsz , exe_sections [ i ] . vsz ) ; cli_dbgmsg ( ""VirtualAddress:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . urva , exe_sections [ i ] . rva ) ; cli_dbgmsg ( ""SizeOfRawData:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . ursz , exe_sections [ i ] . rsz ) ; cli_dbgmsg ( ""PointerToRawData:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . uraw , exe_sections [ i ] . raw ) ; if ( exe_sections [ i ] . chr & 0x20 ) { cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>executable<S2SV_blank>code\\n"" ) ; if ( exe_sections [ i ] . vsz < exe_sections [ i ] . rsz ) { cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>free<S2SV_blank>space\\n"" ) ; } } if ( exe_sections [ i ] . chr & 0x20000000 ) cli_dbgmsg ( ""Section\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>executable\\n"" ) ; if ( exe_sections [ i ] . chr & 0x80000000 ) cli_dbgmsg ( ""Section\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>writeable\\n"" ) ; if ( DETECT_BROKEN_PE && ( ! valign || ( exe_sections [ i ] . urva % valign ) ) ) { cli_dbgmsg ( ""VirtualAddress<S2SV_blank>is<S2SV_blank>misaligned\\n"" ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } if ( exe_sections [ i ] . rsz ) {  if ( exe_sections [ i ] . raw >= fsize ) {  cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\n"" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } if ( SCAN_ALGO && ( DCONF & PE_CONF_POLIPOS ) && ! * sname && exe_sections [ i ] . vsz > 40000 && exe_sections [ i ] . vsz < 70000 && exe_sections [ i ] . chr == 0xe0000060 ) polipos = i ; if ( ( DCONF & PE_CONF_MD5SECT ) && ctx -> engine -> hm_mdb ) { ret = scan_pe_mdb ( ctx , & exe_sections [ i ] ) ; if ( ret != CL_CLEAN ) { if ( ret != CL_VIRUS ) cli_errmsg ( ""scan_pe:<S2SV_blank>scan_pe_mdb<S2SV_blank>failed:<S2SV_blank>%s!\\n"" , cl_strerror ( ret ) ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return ret ; } } } cli_dbgmsg ( ""------------------------------------\\n"" ) ; if ( exe_sections [ i ] . urva >> 31 || exe_sections [ i ] . uvsz >> 31 || ( exe_sections [ i ] . rsz && exe_sections [ i ] . uraw >> 31 ) || exe_sections [ i ] . ursz >> 31 ) { cli_dbgmsg ( ""Found<S2SV_blank>PE<S2SV_blank>values<S2SV_blank>with<S2SV_blank>sign<S2SV_blank>bit<S2SV_blank>set\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } if ( ! i ) { if ( DETECT_BROKEN_PE && exe_sections [ i ] . urva != hdr_size ) { cli_dbgmsg ( ""First<S2SV_blank>section<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>place\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } min = exe_sections [ i ] . rva ; max = exe_sections [ i ] . rva + exe_sections [ i ] . rsz ; } else { if ( DETECT_BROKEN_PE && exe_sections [ i ] . urva - exe_sections [ i - 1 ] . urva != exe_sections [ i - 1 ] . vsz ) { cli_dbgmsg ( ""Virtually<S2SV_blank>misplaced<S2SV_blank>section<S2SV_blank>(wrong<S2SV_blank>order,<S2SV_blank>overlapping,<S2SV_blank>non<S2SV_blank>contiguous)\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } if ( exe_sections [ i ] . rva < min ) min = exe_sections [ i ] . rva ; if ( exe_sections [ i ] . rva + exe_sections [ i ] . rsz > max ) { max = exe_sections [ i ] . rva + exe_sections [ i ] . rsz ; overlays = exe_sections [ i ] . raw + exe_sections [ i ] . rsz ; } } } free ( section_hdr ) ; if ( ! ( ep = cli_rawaddr ( vep , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) { cli_dbgmsg ( ""EntryPoint<S2SV_blank>out<S2SV_blank>of<S2SV_blank>file\\n"" ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } # if HAVE_JSON cli_jsonint ( pe_json , ""EntryPointOffset"" , ep ) ; if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } # endif cli_dbgmsg ( ""EntryPoint<S2SV_blank>offset:<S2SV_blank>0x%x<S2SV_blank>(%d)\\n"" , ep , ep ) ; if ( pe_plus ) { free ( exe_sections ) ; return CL_CLEAN ; } epsize = fmap_readn ( map , epbuff , ep , 4096 ) ; if ( overlays ) { int overlays_sz = fsize - overlays ; if ( overlays_sz > 0 ) { ret = cli_scanishield ( ctx , overlays , overlays_sz ) ; if ( ret != CL_CLEAN ) { free ( exe_sections ) ; return ret ; } } } pedata . nsections = nsections ; pedata . ep = ep ; pedata . offset = 0 ; memcpy ( & pedata . file_hdr , & file_hdr , sizeof ( file_hdr ) ) ; memcpy ( & pedata . opt32 , & pe_opt . opt32 , sizeof ( pe_opt . opt32 ) ) ; memcpy ( & pedata . opt64 , & pe_opt . opt64 , sizeof ( pe_opt . opt64 ) ) ; memcpy ( & pedata . dirs , dirs , sizeof ( pedata . dirs ) ) ; pedata . e_lfanew = e_lfanew ; pedata . overlays = overlays ; pedata . overlays_sz = fsize - overlays ; pedata . hdr_size = hdr_size ; bc_ctx = cli_bytecode_context_alloc ( ) ; if ( ! bc_ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>bc_ctx\\n"" ) ; free ( exe_sections ) ; return CL_EMEM ; } cli_bytecode_context_setpe ( bc_ctx , & pedata , exe_sections ) ; cli_bytecode_context_setctx ( bc_ctx , ctx ) ; ret = cli_bytecode_runhook ( ctx , ctx -> engine , bc_ctx , BC_PE_ALL , map ) ; switch ( ret ) { case CL_ENULLARG : cli_warnmsg ( ""cli_scanpe:<S2SV_blank>NULL<S2SV_blank>argument<S2SV_blank>supplied\\n"" ) ; break ; case CL_VIRUS : case CL_BREAK : free ( exe_sections ) ; cli_bytecode_context_destroy ( bc_ctx ) ; return ret == CL_VIRUS ? CL_VIRUS : CL_CLEAN ; } cli_bytecode_context_destroy ( bc_ctx ) ; if ( SCAN_ALGO && ( DCONF & PE_CONF_PARITE ) && ! dll && epsize == 4096 && ep == exe_sections [ nsections - 1 ] . raw ) { const char * pt = cli_memstr ( epbuff , 4040 , ""\\x47\\x65\\x74\\x50\\x72\\x6f\\x63\\x41\\x64\\x64\\x72\\x65\\x73\\x73\\x00"" , 15 ) ; if ( pt ) { pt += 15 ; if ( ( ( ( uint32_t ) cli_readint32 ( pt ) ^ ( uint32_t ) cli_readint32 ( pt + 4 ) ) == 0x505a4f ) && ( ( ( uint32_t ) cli_readint32 ( pt + 8 ) ^ ( uint32_t ) cli_readint32 ( pt + 12 ) ) == 0xffffb ) && ( ( ( uint32_t ) cli_readint32 ( pt + 16 ) ^ ( uint32_t ) cli_readint32 ( pt + 20 ) ) == 0xb8 ) ) { cli_append_virus ( ctx , ""Heuristics.W32.Parite.B"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } if ( SCAN_ALGO && ( DCONF & PE_CONF_KRIZ ) && epsize >= 200 && CLI_ISCONTAINED ( exe_sections [ nsections - 1 ] . raw , exe_sections [ nsections - 1 ] . rsz , ep , 0x0fd2 ) && epbuff [ 1 ] == '\\x9c' && epbuff [ 2 ] == '\\x60' ) { enum { KZSTRASH , KZSCDELTA , KZSPDELTA , KZSGETSIZE , KZSXORPRFX , KZSXOR , KZSDDELTA , KZSLOOP , KZSTOP } ; uint8_t kzs [ ] = { KZSTRASH , KZSCDELTA , KZSPDELTA , KZSGETSIZE , KZSTRASH , KZSXORPRFX , KZSXOR , KZSTRASH , KZSDDELTA , KZSTRASH , KZSLOOP , KZSTOP } ; uint8_t * kzstate = kzs ; uint8_t * kzcode = ( uint8_t * ) epbuff + 3 ; uint8_t kzdptr = 0xff , kzdsize = 0xff ; int kzlen = 197 , kzinitlen = 0xffff , kzxorlen = - 1 ; cli_dbgmsg ( ""in<S2SV_blank>kriz\\n"" ) ; while ( * kzstate != KZSTOP ) { uint8_t op ; if ( kzlen <= 6 ) break ; op = * kzcode ++ ; kzlen -- ; switch ( * kzstate ) { case KZSTRASH : case KZSGETSIZE : { int opsz = 0 ; switch ( op ) { case 0x81 : kzcode += 5 ; kzlen -= 5 ; break ; case 0xb8 : case 0xb9 : case 0xba : case 0xbb : case 0xbd : case 0xbe : case 0xbf : if ( * kzstate == KZSGETSIZE && cli_readint32 ( kzcode ) == 0x0fd2 ) { kzinitlen = kzlen - 5 ; kzdsize = op - 0xb8 ; kzstate ++ ; op = 4 ; cli_dbgmsg ( ""kriz:<S2SV_blank>using<S2SV_blank>#%d<S2SV_blank>as<S2SV_blank>size<S2SV_blank>counter\\n"" , kzdsize ) ; } opsz = 4 ; case 0x48 : case 0x49 : case 0x4a : case 0x4b : case 0x4d : case 0x4e : case 0x4f : op &= 7 ; if ( op != kzdptr && op != kzdsize ) { kzcode += opsz ; kzlen -= opsz ; break ; } default : kzcode -- ; kzlen ++ ; kzstate ++ ; } break ; } case KZSCDELTA : if ( op == 0xe8 && ( uint32_t ) cli_readint32 ( kzcode ) < 0xff ) { kzlen -= * kzcode + 4 ; kzcode += * kzcode + 4 ; kzstate ++ ; } else * kzstate = KZSTOP ; break ; case KZSPDELTA : if ( ( op & 0xf8 ) == 0x58 && ( kzdptr = op - 0x58 ) != 4 ) { kzstate ++ ; cli_dbgmsg ( ""kriz:<S2SV_blank>using<S2SV_blank>#%d<S2SV_blank>as<S2SV_blank>pointer\\n"" , kzdptr ) ; } else * kzstate = KZSTOP ; break ; case KZSXORPRFX : kzstate ++ ; if ( op == 0x3e ) break ; case KZSXOR : if ( op == 0x80 && * kzcode == kzdptr + 0xb0 ) { kzxorlen = kzlen ; kzcode += + 6 ; kzlen -= + 6 ; kzstate ++ ; } else * kzstate = KZSTOP ; break ; case KZSDDELTA : if ( op == kzdptr + 0x48 ) kzstate ++ ; else * kzstate = KZSTOP ; break ; case KZSLOOP : if ( op == kzdsize + 0x48 && * kzcode == 0x75 && kzlen - ( int8_t ) kzcode [ 1 ] - 3 <= kzinitlen && kzlen - ( int8_t ) kzcode [ 1 ] >= kzxorlen ) { cli_append_virus ( ctx , ""Heuristics.W32.Kriz"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } cli_dbgmsg ( ""kriz:<S2SV_blank>loop<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds,<S2SV_blank>corrupted<S2SV_blank>sample?\\n"" ) ; kzstate ++ ; } } } if ( SCAN_ALGO && ( DCONF & PE_CONF_MAGISTR ) && ! dll && ( nsections > 1 ) && ( exe_sections [ nsections - 1 ] . chr & 0x80000000 ) ) { uint32_t rsize , vsize , dam = 0 ; vsize = exe_sections [ nsections - 1 ] . uvsz ; rsize = exe_sections [ nsections - 1 ] . rsz ; if ( rsize < exe_sections [ nsections - 1 ] . ursz ) { rsize = exe_sections [ nsections - 1 ] . ursz ; dam = 1 ; } if ( vsize >= 0x612c && rsize >= 0x612c && ( ( vsize & 0xff ) == 0xec ) ) { int bw = rsize < 0x7000 ? rsize : 0x7000 ; const char * tbuff ; if ( ( tbuff = fmap_need_off_once ( map , exe_sections [ nsections - 1 ] . raw + rsize - bw , 4096 ) ) ) { if ( cli_memstr ( tbuff , 4091 , ""\\xe8\\x2c\\x61\\x00\\x00"" , 5 ) ) { cli_append_virus ( ctx , dam ? ""Heuristics.W32.Magistr.A.dam"" : ""Heuristics.W32.Magistr.A"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } else if ( rsize >= 0x7000 && vsize >= 0x7000 && ( ( vsize & 0xff ) == 0xed ) ) { int bw = rsize < 0x8000 ? rsize : 0x8000 ; const char * tbuff ; if ( ( tbuff = fmap_need_off_once ( map , exe_sections [ nsections - 1 ] . raw + rsize - bw , 4096 ) ) ) { if ( cli_memstr ( tbuff , 4091 , ""\\xe8\\x04\\x72\\x00\\x00"" , 5 ) ) { cli_append_virus ( ctx , dam ? ""Heuristics.W32.Magistr.B.dam"" : ""Heuristics.W32.Magistr.B"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } } while ( polipos && ! dll && nsections > 2 && nsections < 13 && e_lfanew <= 0x800 && ( EC16 ( optional_hdr32 . Subsystem ) == 2 || EC16 ( optional_hdr32 . Subsystem ) == 3 ) && EC16 ( file_hdr . Machine ) == 0x14c && optional_hdr32 . SizeOfStackReserve >= 0x80000 ) { uint32_t jump , jold , * jumps = NULL ; const uint8_t * code ; unsigned int xsjs = 0 ; if ( exe_sections [ 0 ] . rsz > CLI_MAX_ALLOCATION ) break ; if ( ! exe_sections [ 0 ] . rsz ) break ; if ( ! ( code = fmap_need_off_once ( map , exe_sections [ 0 ] . raw , exe_sections [ 0 ] . rsz ) ) ) break ; for ( i = 0 ; i < exe_sections [ 0 ] . rsz - 5 ; i ++ ) { if ( ( uint8_t ) ( code [ i ] - 0xe8 ) > 1 ) continue ; jump = cli_rawaddr ( exe_sections [ 0 ] . rva + i + 5 + cli_readint32 ( & code [ i + 1 ] ) , exe_sections , nsections , & err , fsize , hdr_size ) ; if ( err || ! CLI_ISCONTAINED ( exe_sections [ polipos ] . raw , exe_sections [ polipos ] . rsz , jump , 9 ) ) continue ; if ( xsjs % 128 == 0 ) { if ( xsjs == 1280 ) break ; if ( ! ( jumps = ( uint32_t * ) cli_realloc2 ( jumps , ( xsjs + 128 ) * sizeof ( uint32_t ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } } j = 0 ; for ( ; j < xsjs ; j ++ ) { if ( jumps [ j ] < jump ) continue ; if ( jumps [ j ] == jump ) { xsjs -- ; break ; } jold = jumps [ j ] ; jumps [ j ] = jump ; jump = jold ; } jumps [ j ] = jump ; xsjs ++ ; } if ( ! xsjs ) break ; cli_dbgmsg ( ""Polipos:<S2SV_blank>Checking<S2SV_blank>%d<S2SV_blank>xsect<S2SV_blank>jump(s)\\n"" , xsjs ) ; for ( i = 0 ; i < xsjs ; i ++ ) { if ( ! ( code = fmap_need_off_once ( map , jumps [ i ] , 9 ) ) ) continue ; if ( ( jump = cli_readint32 ( code ) ) == 0x60ec8b55 || ( code [ 4 ] == 0x0ec && ( ( jump == 0x83ec8b55 && code [ 6 ] == 0x60 ) || ( jump == 0x81ec8b55 && ! code [ 7 ] && ! code [ 8 ] ) ) ) ) { cli_append_virus ( ctx , ""Heuristics.W32.Polipos.A"" ) ; if ( ! SCAN_ALL ) { free ( jumps ) ; free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } free ( jumps ) ; break ; } if ( SCAN_ALGO && ( DCONF & PE_CONF_SWIZZOR ) && nsections > 1 && fsize > 64 * 1024 && fsize < 4 * 1024 * 1024 ) { if ( dirs [ 2 ] . Size ) { struct swizz_stats * stats = cli_calloc ( 1 , sizeof ( * stats ) ) ; unsigned int m = 1000 ; ret = CL_CLEAN ; if ( ! stats ) ret = CL_EMEM ; else { cli_parseres_special ( EC32 ( dirs [ 2 ] . VirtualAddress ) , EC32 ( dirs [ 2 ] . VirtualAddress ) , map , exe_sections , nsections , fsize , hdr_size , 0 , 0 , & m , stats ) ; if ( ( ret = cli_detect_swizz ( stats ) ) == CL_VIRUS ) { cli_append_virus ( ctx , ""Heuristics.Trojan.Swizzor.Gen"" ) ; } free ( stats ) ; } if ( ret != CL_CLEAN ) { if ( ! ( ret == CL_VIRUS && SCAN_ALL ) ) { free ( exe_sections ) ; return ret ; } viruses_found ++ ; } } } corrupted_cur = ctx -> corrupted_input ; ctx -> corrupted_input = 2 ; found = 0 ; if ( DCONF & ( PE_CONF_UPX | PE_CONF_FSG | PE_CONF_MEW ) ) { for ( i = 0 ; i < ( unsigned int ) nsections - 1 ; i ++ ) { if ( ! exe_sections [ i ] . rsz && exe_sections [ i ] . vsz && exe_sections [ i + 1 ] . rsz && exe_sections [ i + 1 ] . vsz ) { found = 1 ; cli_dbgmsg ( ""UPX/FSG/MEW:<S2SV_blank>empty<S2SV_blank>section<S2SV_blank>found<S2SV_blank>-<S2SV_blank>assuming<S2SV_blank>compression\\n"" ) ; # if HAVE_JSON cli_jsonbool ( pe_json , ""HasEmptySection"" , 1 ) ; # endif break ; } } } if ( found && ( DCONF & PE_CONF_MEW ) && epsize >= 16 && epbuff [ 0 ] == '\\xe9' ) { uint32_t fileoffset ; const char * tbuff ; fileoffset = ( vep + cli_readint32 ( epbuff + 1 ) + 5 ) ; while ( fileoffset == 0x154 || fileoffset == 0x158 ) { char * src ; uint32_t offdiff , uselzma ; cli_dbgmsg ( ""MEW:<S2SV_blank>found<S2SV_blank>MEW<S2SV_blank>characteristics<S2SV_blank>%08X<S2SV_blank>+<S2SV_blank>%08X<S2SV_blank>+<S2SV_blank>5<S2SV_blank>=<S2SV_blank>%08X\\n"" , cli_readint32 ( epbuff + 1 ) , vep , cli_readint32 ( epbuff + 1 ) + vep + 5 ) ; if ( ! ( tbuff = fmap_need_off_once ( map , fileoffset , 0xb0 ) ) ) break ; if ( fileoffset == 0x154 ) cli_dbgmsg ( ""MEW:<S2SV_blank>Win9x<S2SV_blank>compatibility<S2SV_blank>was<S2SV_blank>set!\\n"" ) ; else cli_dbgmsg ( ""MEW:<S2SV_blank>Win9x<S2SV_blank>compatibility<S2SV_blank>was<S2SV_blank>NOT<S2SV_blank>set!\\n"" ) ; if ( ( offdiff = cli_readint32 ( tbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) ) <= exe_sections [ i + 1 ] . rva || offdiff >= exe_sections [ i + 1 ] . rva + exe_sections [ i + 1 ] . raw - 4 ) { cli_dbgmsg ( ""MEW:<S2SV_blank>ESI<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>proper<S2SV_blank>section\\n"" ) ; break ; } offdiff -= exe_sections [ i + 1 ] . rva ; if ( ! exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""MEW:<S2SV_blank>mew<S2SV_blank>section<S2SV_blank>is<S2SV_blank>empty\\n"" ) ; break ; } ssize = exe_sections [ i + 1 ] . vsz ; dsize = exe_sections [ i ] . vsz ; cli_dbgmsg ( ""MEW:<S2SV_blank>ssize<S2SV_blank>%08x<S2SV_blank>dsize<S2SV_blank>%08x<S2SV_blank>offdiff:<S2SV_blank>%08x\\n"" , ssize , dsize , offdiff ) ; CLI_UNPSIZELIMITS ( ""MEW"" , MAX ( ssize , dsize ) ) ; CLI_UNPSIZELIMITS ( ""MEW"" , MAX ( ssize + dsize , exe_sections [ i + 1 ] . rsz ) ) ; if ( exe_sections [ i + 1 ] . rsz < offdiff + 12 || exe_sections [ i + 1 ] . rsz > ssize ) { cli_dbgmsg ( ""MEW:<S2SV_blank>Size<S2SV_blank>mismatch:<S2SV_blank>%08x\\n"" , exe_sections [ i + 1 ] . rsz ) ; break ; } if ( ! ( src = cli_calloc ( ssize + dsize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( bytes = fmap_readn ( map , src + dsize , exe_sections [ i + 1 ] . raw , exe_sections [ i + 1 ] . rsz ) ) != exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""MEW:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>[read:<S2SV_blank>%lu]\\n"" , exe_sections [ i + 1 ] . rsz , ( unsigned long ) bytes ) ; free ( exe_sections ) ; free ( src ) ; return CL_EREAD ; } cli_dbgmsg ( ""MEW:<S2SV_blank>%u<S2SV_blank>(%08x)<S2SV_blank>bytes<S2SV_blank>read\\n"" , ( unsigned int ) bytes , ( unsigned int ) bytes ) ; if ( tbuff [ 0x7b ] == '\\xe8' ) { if ( ! CLI_ISCONTAINED ( exe_sections [ 1 ] . rva , exe_sections [ 1 ] . vsz , cli_readint32 ( tbuff + 0x7c ) + fileoffset + 0x80 , 4 ) ) { cli_dbgmsg ( ""MEW:<S2SV_blank>lzma<S2SV_blank>proc<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds!\\n"" ) ; free ( src ) ; break ; } uselzma = cli_readint32 ( tbuff + 0x7c ) - ( exe_sections [ 0 ] . rva - fileoffset - 0x80 ) ; } else { uselzma = 0 ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""MEW"" ) ; # endif CLI_UNPTEMP ( ""MEW"" , ( src , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""MEW"" , ( unmew11 ( src , offdiff , ssize , dsize , EC32 ( optional_hdr32 . ImageBase ) , exe_sections [ 0 ] . rva , uselzma , ndesc ) ) , 1 , ( src , 0 ) ) ; break ; } } if ( epsize < 168 ) { free ( exe_sections ) ; return CL_CLEAN ; } if ( found || upack ) { while ( ( ( upack && nsections == 3 ) && ( ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > min && epbuff [ 5 ] == '\\xad' && epbuff [ 6 ] == '\\x50' ) || ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > min && epbuff [ 5 ] == '\\xff' && epbuff [ 6 ] == '\\x36' ) ) ) || ( ( ! upack && nsections == 2 ) && ( ( epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xe8' && cli_readint32 ( epbuff + 2 ) == 0x9 ) || ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > 0 && epbuff [ 5 ] == '\\xad' && epbuff [ 6 ] == '\\x8b' && epbuff [ 7 ] == '\\xf8' ) ) ) ) { uint32_t vma , off ; int a , b , c ; cli_dbgmsg ( ""Upack<S2SV_blank>characteristics<S2SV_blank>found.\\n"" ) ; a = exe_sections [ 0 ] . vsz ; b = exe_sections [ 1 ] . vsz ; if ( upack ) { cli_dbgmsg ( ""Upack:<S2SV_blank>var<S2SV_blank>set\\n"" ) ; c = exe_sections [ 2 ] . vsz ; ssize = exe_sections [ 0 ] . ursz + exe_sections [ 0 ] . uraw ; off = exe_sections [ 0 ] . rva ; vma = EC32 ( optional_hdr32 . ImageBase ) + exe_sections [ 0 ] . rva ; } else { cli_dbgmsg ( ""Upack:<S2SV_blank>var<S2SV_blank>NOT<S2SV_blank>set\\n"" ) ; c = exe_sections [ 1 ] . rva ; ssize = exe_sections [ 1 ] . uraw ; off = 0 ; vma = exe_sections [ 1 ] . rva - exe_sections [ 1 ] . uraw ; } dsize = a + b + c ; CLI_UNPSIZELIMITS ( ""Upack"" , MAX ( MAX ( dsize , ssize ) , exe_sections [ 1 ] . ursz ) ) ; if ( ! CLI_ISCONTAINED ( 0 , dsize , exe_sections [ 1 ] . rva - off , exe_sections [ 1 ] . ursz ) || ( upack && ! CLI_ISCONTAINED ( 0 , dsize , exe_sections [ 2 ] . rva - exe_sections [ 0 ] . rva , ssize ) ) || ssize > dsize ) { cli_dbgmsg ( ""Upack:<S2SV_blank>probably<S2SV_blank>malformed<S2SV_blank>pe-header,<S2SV_blank>skipping<S2SV_blank>to<S2SV_blank>next<S2SV_blank>unpacker\\n"" ) ; break ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( unsigned int ) fmap_readn ( map , dest , 0 , ssize ) != ssize ) { cli_dbgmsg ( ""Upack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>0\\n"" ) ; free ( dest ) ; break ; } if ( upack ) memmove ( dest + exe_sections [ 2 ] . rva - exe_sections [ 0 ] . rva , dest , ssize ) ; if ( ( unsigned int ) fmap_readn ( map , dest + exe_sections [ 1 ] . rva - off , exe_sections [ 1 ] . uraw , exe_sections [ 1 ] . ursz ) != exe_sections [ 1 ] . ursz ) { cli_dbgmsg ( ""Upack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>1\\n"" ) ; free ( dest ) ; break ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Upack"" ) ; # endif CLI_UNPTEMP ( ""Upack"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Upack"" , ( unupack ( upack , dest , dsize , epbuff , vma , ep , EC32 ( optional_hdr32 . ImageBase ) , exe_sections [ 0 ] . rva , ndesc ) ) , 1 , ( dest , 0 ) ) ; break ; } } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\x87' && epbuff [ 1 ] == '\\x25' ) { const char * dst ; uint32_t newesi , newedi , newebx , newedx ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } newedx = cli_readint32 ( epbuff + 2 ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newedx , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>xchg<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>(%x),<S2SV_blank>giving<S2SV_blank>up\\n"" , newedx ) ; break ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i + 1 ) ; free ( exe_sections ) ; return CL_ESEEK ; } dst = src + newedx - exe_sections [ i + 1 ] . rva ; if ( newedx < exe_sections [ i + 1 ] . rva || ! CLI_ISCONTAINED ( src , ssize , dst , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>ESP<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedx = cli_readint32 ( dst ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newedx , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>ESP<S2SV_blank>(%x)<S2SV_blank>is<S2SV_blank>wrong\\n"" , newedx ) ; break ; } dst = src + newedx - exe_sections [ i + 1 ] . rva ; if ( ! CLI_ISCONTAINED ( src , ssize , dst , 32 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>stack<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedi = cli_readint32 ( dst ) - EC32 ( optional_hdr32 . ImageBase ) ; newesi = cli_readint32 ( dst + 4 ) - EC32 ( optional_hdr32 . ImageBase ) ; newebx = cli_readint32 ( dst + 16 ) - EC32 ( optional_hdr32 . ImageBase ) ; newedx = cli_readint32 ( dst + 20 ) ; if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>buffer<S2SV_blank>(edi<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newebx , 16 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Array<S2SV_blank>of<S2SV_blank>functions<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedx = cli_readint32 ( newebx + 12 - exe_sections [ i + 1 ] . rva + src ) - EC32 ( optional_hdr32 . ImageBase ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , newedx ) ; if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG2 ( ""FSG"" , ( unfsg_200 ( newesi - exe_sections [ i + 1 ] . rva + src , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , newedi , EC32 ( optional_hdr32 . ImageBase ) , newedx , ndesc ) ) , 1 , ( dest , 0 ) ) ; break ; } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min ) { int sectcnt = 0 ; const char * support ; uint32_t newesi , newedi , oldep , gp , t ; struct cli_exe_section * sections ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } if ( ! ( t = cli_rawaddr ( cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) , NULL , 0 , & err , fsize , hdr_size ) ) && err ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Support<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>padding<S2SV_blank>area\\n"" ) ; break ; } gp = exe_sections [ i + 1 ] . raw - t ; CLI_UNPSIZELIMITS ( ""FSG"" , gp ) ; if ( ! ( support = fmap_need_off_once ( map , t , gp ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>padding<S2SV_blank>area\\n"" , gp ) ; free ( exe_sections ) ; return CL_EREAD ; } newedi = cli_readint32 ( support + 4 ) - EC32 ( optional_hdr32 . ImageBase ) ; newesi = cli_readint32 ( support + 8 ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>(is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } for ( t = 12 ; t < gp - 4 ; t += 4 ) { uint32_t rva = cli_readint32 ( support + t ) ; if ( ! rva ) break ; rva -= EC32 ( optional_hdr32 . ImageBase ) + 1 ; sectcnt ++ ; if ( rva % 0x1000 ) cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>misaligned\\n"" , sectcnt ) ; if ( rva < exe_sections [ i ] . rva || rva - exe_sections [ i ] . rva >= exe_sections [ i ] . vsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" , sectcnt ) ; break ; } } if ( t >= gp - 4 || cli_readint32 ( support + t ) ) { break ; } if ( ( sections = ( struct cli_exe_section * ) cli_malloc ( ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ) == NULL ) { cli_errmsg ( ""FSG:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>sections<S2SV_blank>%lu\\n"" , ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ; free ( exe_sections ) ; return CL_EMEM ; } sections [ 0 ] . rva = newedi ; for ( t = 1 ; t <= ( uint32_t ) sectcnt ; t ++ ) sections [ t ] . rva = cli_readint32 ( support + 8 + t * 4 ) - 1 - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i ) ; free ( exe_sections ) ; free ( sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; free ( sections ) ; return CL_EMEM ; } oldep = vep + 161 + 6 + cli_readint32 ( epbuff + 163 ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , oldep ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , sections , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG1 ( ""FSG"" , ( unfsg_133 ( src + newesi - exe_sections [ i + 1 ] . rva , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , sections , sectcnt , EC32 ( optional_hdr32 . ImageBase ) , oldep , ndesc ) ) , 1 , ( dest , sections , 0 ) ) ; break ; } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\xbb' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min && epbuff [ 5 ] == '\\xbf' && epbuff [ 10 ] == '\\xbe' && vep >= exe_sections [ i + 1 ] . rva && vep - exe_sections [ i + 1 ] . rva > exe_sections [ i + 1 ] . rva - 0xe0 ) { int sectcnt = 0 ; uint32_t gp , t = cli_rawaddr ( cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) , NULL , 0 , & err , fsize , hdr_size ) ; const char * support ; uint32_t newesi = cli_readint32 ( epbuff + 11 ) - EC32 ( optional_hdr32 . ImageBase ) ; uint32_t newedi = cli_readint32 ( epbuff + 6 ) - EC32 ( optional_hdr32 . ImageBase ) ; uint32_t oldep = vep - exe_sections [ i + 1 ] . rva ; struct cli_exe_section * sections ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; if ( err ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Support<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>padding<S2SV_blank>area\\n"" ) ; break ; } if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . raw ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>(is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } gp = exe_sections [ i + 1 ] . raw - t ; CLI_UNPSIZELIMITS ( ""FSG"" , gp ) if ( ! ( support = fmap_need_off_once ( map , t , gp ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>padding<S2SV_blank>area\\n"" , gp ) ; free ( exe_sections ) ; return CL_EREAD ; } for ( t = 0 ; t < gp - 2 ; t += 2 ) { uint32_t rva = support [ t ] | ( support [ t + 1 ] << 8 ) ; if ( rva == 2 || rva == 1 ) break ; rva = ( ( rva - 2 ) << 12 ) - EC32 ( optional_hdr32 . ImageBase ) ; sectcnt ++ ; if ( rva < exe_sections [ i ] . rva || rva - exe_sections [ i ] . rva >= exe_sections [ i ] . vsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" , sectcnt ) ; break ; } } if ( t >= gp - 10 || cli_readint32 ( support + t + 6 ) != 2 ) { break ; } if ( ( sections = ( struct cli_exe_section * ) cli_malloc ( ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ) == NULL ) { cli_errmsg ( ""FSG:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>sections<S2SV_blank>%lu\\n"" , ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ; free ( exe_sections ) ; return CL_EMEM ; } sections [ 0 ] . rva = newedi ; for ( t = 0 ; t <= ( uint32_t ) sectcnt - 1 ; t ++ ) { sections [ t + 1 ] . rva = ( ( ( support [ t * 2 ] | ( support [ t * 2 + 1 ] << 8 ) ) - 2 ) << 12 ) - EC32 ( optional_hdr32 . ImageBase ) ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i ) ; free ( exe_sections ) ; free ( sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; free ( sections ) ; return CL_EMEM ; } gp = 0xda + 6 * ( epbuff [ 16 ] == '\\xe8' ) ; oldep = vep + gp + 6 + cli_readint32 ( src + gp + 2 + oldep ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , oldep ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , sections , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG1 ( ""FSG"" , ( unfsg_133 ( src + newesi - exe_sections [ i + 1 ] . rva , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , sections , sectcnt , EC32 ( optional_hdr32 . ImageBase ) , oldep , ndesc ) ) , 1 , ( dest , sections , 0 ) ) ; break ; } if ( found && ( DCONF & PE_CONF_UPX ) ) { ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz + exe_sections [ i + 1 ] . vsz ; CLI_UNPSIZELIMITS ( ""UPX"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>or<S2SV_blank>dsize<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i + 1 ) ; free ( exe_sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize + 8192 , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } if ( cli_memstr ( UPX_NRV2B , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2B , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2B<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2b ; } else if ( cli_memstr ( UPX_NRV2D , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2D , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2D<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2d ; } else if ( cli_memstr ( UPX_NRV2E , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2E , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2E<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2e ; } if ( upxfn ) { int skew = cli_readint32 ( epbuff + 2 ) - EC32 ( optional_hdr32 . ImageBase ) - exe_sections [ i + 1 ] . rva ; if ( epbuff [ 1 ] != '\\xbe' || skew <= 0 || skew > 0xfff ) { skew = 0 ; } else if ( ( unsigned int ) skew > ssize ) { skew = 0 ; } else { cli_dbgmsg ( ""UPX:<S2SV_blank>UPX1<S2SV_blank>seems<S2SV_blank>skewed<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>bytes\\n"" , skew ) ; } if ( upxfn ( src + skew , ssize - skew , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - skew ) >= 0 ) { upx_success = 1 ; } else if ( skew && ( upxfn ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ) ) { upx_success = 1 ; } if ( upx_success ) cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed\\n"" ) ; else cli_dbgmsg ( ""UPX:<S2SV_blank>Preferred<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } if ( ! upx_success && upxfn != upx_inflate2b ) { if ( upx_inflate2b ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2b ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2B<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2B\\n"" ) ; } } if ( ! upx_success && upxfn != upx_inflate2d ) { if ( upx_inflate2d ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2d ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2D<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2D\\n"" ) ; } } if ( ! upx_success && upxfn != upx_inflate2e ) { if ( upx_inflate2e ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2e ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2E<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2E\\n"" ) ; } } if ( cli_memstr ( UPX_LZMA2 , 20 , epbuff + 0x2f , 20 ) ) { uint32_t strictdsize = cli_readint32 ( epbuff + 0x21 ) , skew = 0 ; if ( ssize > 0x15 && epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xbe' ) { skew = cli_readint32 ( epbuff + 2 ) - exe_sections [ i + 1 ] . rva - optional_hdr32 . ImageBase ; if ( skew != 0x15 ) skew = 0 ; } if ( strictdsize <= dsize ) upx_success = upx_inflatelzma ( src + skew , ssize - skew , dest , & strictdsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ; } else if ( cli_memstr ( UPX_LZMA1 , 20 , epbuff + 0x39 , 20 ) ) { uint32_t strictdsize = cli_readint32 ( epbuff + 0x2b ) , skew = 0 ; if ( ssize > 0x15 && epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xbe' ) { skew = cli_readint32 ( epbuff + 2 ) - exe_sections [ i + 1 ] . rva - optional_hdr32 . ImageBase ; if ( skew != 0x15 ) skew = 0 ; } if ( strictdsize <= dsize ) upx_success = upx_inflatelzma ( src + skew , ssize - skew , dest , & strictdsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ; } if ( ! upx_success ) { cli_dbgmsg ( ""UPX:<S2SV_blank>All<S2SV_blank>decompressors<S2SV_blank>failed\\n"" ) ; free ( dest ) ; } } if ( upx_success ) { free ( exe_sections ) ; CLI_UNPTEMP ( ""UPX/FSG"" , ( dest , 0 ) ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""UPX"" ) ; # endif if ( ( unsigned int ) write ( ndesc , dest , dsize ) != dsize ) { cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>Can\'t<S2SV_blank>write<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dsize ) ; free ( tempfile ) ; free ( dest ) ; close ( ndesc ) ; return CL_EWRITE ; } free ( dest ) ; if ( lseek ( ndesc , 0 , SEEK_SET ) == - 1 ) { cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>lseek()<S2SV_blank>failed\\n"" ) ; close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; SHA_RESET ; return CL_ESEEK ; } if ( ctx -> engine -> keeptmp ) cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>Decompressed<S2SV_blank>data<S2SV_blank>saved<S2SV_blank>in<S2SV_blank>%s\\n"" , tempfile ) ; cli_dbgmsg ( ""*****<S2SV_blank>Scanning<S2SV_blank>decompressed<S2SV_blank>file<S2SV_blank>*****\\n"" ) ; SHA_OFF ; if ( ( ret = cli_magic_scandesc ( ndesc , ctx ) ) == CL_VIRUS ) { close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; SHA_RESET ; return CL_VIRUS ; } SHA_RESET ; close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; return ret ; } if ( epsize < 200 ) { free ( exe_sections ) ; return CL_CLEAN ; } found = 2 ; if ( epbuff [ 0 ] != '\\xb8' || ( uint32_t ) cli_readint32 ( epbuff + 1 ) != exe_sections [ nsections - 1 ] . rva + EC32 ( optional_hdr32 . ImageBase ) ) { if ( nsections < 2 || epbuff [ 0 ] != '\\xb8' || ( uint32_t ) cli_readint32 ( epbuff + 1 ) != exe_sections [ nsections - 2 ] . rva + EC32 ( optional_hdr32 . ImageBase ) ) found = 0 ; else found = 1 ; } if ( found && ( DCONF & PE_CONF_PETITE ) ) { cli_dbgmsg ( ""Petite:<S2SV_blank>v2.%d<S2SV_blank>compression<S2SV_blank>detected\\n"" , found ) ; if ( cli_readint32 ( epbuff + 0x80 ) == 0x163c988d ) { cli_dbgmsg ( ""Petite:<S2SV_blank>level<S2SV_blank>zero<S2SV_blank>compression<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet\\n"" ) ; } else { dsize = max - min ; CLI_UNPSIZELIMITS ( ""Petite"" , dsize ) ; if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { cli_dbgmsg ( ""Petite:<S2SV_blank>Can\'t<S2SV_blank>allocate<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dsize ) ; free ( exe_sections ) ; return CL_EMEM ; } for ( i = 0 ; i < nsections ; i ++ ) { if ( exe_sections [ i ] . raw ) { if ( ! exe_sections [ i ] . rsz || ( unsigned int ) fmap_readn ( map , dest + exe_sections [ i ] . rva - min , exe_sections [ i ] . raw , exe_sections [ i ] . ursz ) != exe_sections [ i ] . ursz ) { free ( exe_sections ) ; free ( dest ) ; return CL_CLEAN ; } } } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Petite"" ) ; # endif CLI_UNPTEMP ( ""Petite"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Petite"" , ( petite_inflate2x_1to9 ( dest , min , max - min , exe_sections , nsections - ( found == 1 ? 1 : 0 ) , EC32 ( optional_hdr32 . ImageBase ) , vep , ndesc , found , EC32 ( optional_hdr32 . DataDirectory [ 2 ] . VirtualAddress ) , EC32 ( optional_hdr32 . DataDirectory [ 2 ] . Size ) ) ) , 0 , ( dest , 0 ) ) ; } } if ( ( DCONF & PE_CONF_PESPIN ) && nsections > 1 && vep >= exe_sections [ nsections - 1 ] . rva && vep < exe_sections [ nsections - 1 ] . rva + exe_sections [ nsections - 1 ] . rsz - 0x3217 - 4 && memcmp ( epbuff + 4 , ""\\xe8\\x00\\x00\\x00\\x00\\x8b\\x1c\\x24\\x83\\xc3"" , 10 ) == 0 ) { char * spinned ; CLI_UNPSIZELIMITS ( ""PEspin"" , fsize ) ; if ( ( spinned = ( char * ) cli_malloc ( fsize ) ) == NULL ) { cli_errmsg ( ""PESping:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>spinned<S2SV_blank>%lu\\n"" , ( unsigned long ) fsize ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , spinned , 0 , fsize ) != fsize ) { cli_dbgmsg ( ""PESpin:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) fsize ) ; free ( spinned ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""PEspin"" ) ; # endif CLI_UNPTEMP ( ""PESpin"" , ( spinned , exe_sections , 0 ) ) ; CLI_UNPRESULTS_ ( ""PEspin"" , SPINCASE ( ) , ( unspin ( spinned , fsize , exe_sections , nsections - 1 , vep , ndesc , ctx ) ) , 0 , ( spinned , 0 ) ) ; } if ( ( DCONF & PE_CONF_YC ) && nsections > 1 && ( EC32 ( optional_hdr32 . AddressOfEntryPoint ) == exe_sections [ nsections - 1 ] . rva + 0x60 ) ) { uint32_t ecx = 0 ; int16_t offset ; if ( ! memcmp ( epbuff , ""\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED"" , 15 ) && ! memcmp ( epbuff + 0x26 , ""\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC"" , 13 ) && ( ( uint8_t ) epbuff [ 0x13 ] == 0xB9 ) && ( ( uint16_t ) ( cli_readint16 ( epbuff + 0x18 ) ) == 0xE981 ) && ! memcmp ( epbuff + 0x1e , ""\\x8B\\xD5\\x81\\xC2"" , 4 ) ) { offset = 0 ; if ( 0x6c - cli_readint32 ( epbuff + 0xf ) + cli_readint32 ( epbuff + 0x22 ) == 0xC6 ) ecx = cli_readint32 ( epbuff + 0x14 ) - cli_readint32 ( epbuff + 0x1a ) ; } if ( ! ecx && ! memcmp ( epbuff , ""\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57"" , 9 ) && ! memcmp ( epbuff + 0x17 , ""\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed"" , 8 ) && ( ( uint8_t ) epbuff [ 0x23 ] == 0xB9 ) ) { offset = 0x10 ; if ( 0x6c - cli_readint32 ( epbuff + 0x1f ) + cli_readint32 ( epbuff + 0x32 ) == 0xC6 ) ecx = cli_readint32 ( epbuff + 0x24 ) - cli_readint32 ( epbuff + 0x2a ) ; } if ( ! ecx && ! memcmp ( epbuff , ""\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed"" , 9 ) && ( ( uint8_t ) epbuff [ 0xd ] == 0xb9 ) && ( ( uint16_t ) cli_readint16 ( epbuff + 0x12 ) == 0xbd8d ) && ! memcmp ( epbuff + 0x18 , ""\\x8b\\xf7\\xac"" , 3 ) ) { offset = - 0x18 ; if ( 0x66 - cli_readint32 ( epbuff + 0x9 ) + cli_readint32 ( epbuff + 0x14 ) == 0xae ) ecx = cli_readint32 ( epbuff + 0xe ) ; } if ( ecx > 0x800 && ecx < 0x2000 && ! memcmp ( epbuff + 0x63 + offset , ""\\xaa\\xe2\\xcc"" , 3 ) && ( fsize >= exe_sections [ nsections - 1 ] . raw + 0xC6 + ecx + offset ) ) { char * spinned ; if ( ( spinned = ( char * ) cli_malloc ( fsize ) ) == NULL ) { cli_errmsg ( ""yC:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>spinned<S2SV_blank>%lu\\n"" , ( unsigned long ) fsize ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , spinned , 0 , fsize ) != fsize ) { cli_dbgmsg ( ""yC:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) fsize ) ; free ( spinned ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""yC"" ) ; # endif cli_dbgmsg ( ""%d,%d,%d,%d\\n"" , nsections - 1 , e_lfanew , ecx , offset ) ; CLI_UNPTEMP ( ""yC"" , ( spinned , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""yC"" , ( yc_decrypt ( spinned , fsize , exe_sections , nsections - 1 , e_lfanew , ndesc , ecx , offset ) ) , 0 , ( spinned , 0 ) ) ; } } while ( ( DCONF & PE_CONF_WWPACK ) && nsections > 1 && vep == exe_sections [ nsections - 1 ] . rva && memcmp ( epbuff , ""\\x53\\x55\\x8b\\xe8\\x33\\xdb\\xeb"" , 7 ) == 0 && memcmp ( epbuff + 0x68 , ""\\xe8\\x00\\x00\\x00\\x00\\x58\\x2d\\x6d\\x00\\x00\\x00\\x50\\x60\\x33\\xc9\\x50\\x58\\x50\\x50"" , 19 ) == 0 ) { uint32_t head = exe_sections [ nsections - 1 ] . raw ; uint8_t * packer ; char * src ; ssize = 0 ; for ( i = 0 ; ; i ++ ) { if ( exe_sections [ i ] . raw < head ) head = exe_sections [ i ] . raw ; if ( i + 1 == nsections ) break ; if ( ssize < exe_sections [ i ] . rva + exe_sections [ i ] . vsz ) ssize = exe_sections [ i ] . rva + exe_sections [ i ] . vsz ; } if ( ! head || ! ssize || head > ssize ) break ; CLI_UNPSIZELIMITS ( ""WWPack"" , ssize ) ; if ( ! ( src = ( char * ) cli_calloc ( ssize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , src , 0 , head ) != head ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>headers\\n"" , head ) ; free ( src ) ; free ( exe_sections ) ; return CL_EREAD ; } for ( i = 0 ; i < ( unsigned int ) nsections - 1 ; i ++ ) { if ( ! exe_sections [ i ] . rsz ) continue ; if ( ! CLI_ISCONTAINED ( src , ssize , src + exe_sections [ i ] . rva , exe_sections [ i ] . rsz ) ) break ; if ( ( unsigned int ) fmap_readn ( map , src + exe_sections [ i ] . rva , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) != exe_sections [ i ] . rsz ) break ; } if ( i + 1 != nsections ) { cli_dbgmsg ( ""WWpack:<S2SV_blank>Probably<S2SV_blank>hacked/damaged<S2SV_blank>file.\\n"" ) ; free ( src ) ; break ; } if ( ( packer = ( uint8_t * ) cli_calloc ( exe_sections [ nsections - 1 ] . rsz , sizeof ( char ) ) ) == NULL ) { free ( src ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ! exe_sections [ nsections - 1 ] . rsz || ( size_t ) fmap_readn ( map , packer , exe_sections [ nsections - 1 ] . raw , exe_sections [ nsections - 1 ] . rsz ) != exe_sections [ nsections - 1 ] . rsz ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>wwpack<S2SV_blank>sect\\n"" , exe_sections [ nsections - 1 ] . rsz ) ; free ( src ) ; free ( packer ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""WWPack"" ) ; # endif CLI_UNPTEMP ( ""WWPack"" , ( src , packer , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""WWPack"" , ( wwunpack ( ( uint8_t * ) src , ssize , packer , exe_sections , nsections - 1 , e_lfanew , ndesc ) ) , 0 , ( src , packer , 0 ) ) ; break ; } while ( ( DCONF & PE_CONF_ASPACK ) && ep + 58 + 0x70e < fsize && ! memcmp ( epbuff , ""\\x60\\xe8\\x03\\x00\\x00\\x00\\xe9\\xeb"" , 8 ) ) { char * src ; if ( epsize < 0x3bf || memcmp ( epbuff + 0x3b9 , ""\\x68\\x00\\x00\\x00\\x00\\xc3"" , 6 ) ) break ; ssize = 0 ; for ( i = 0 ; i < nsections ; i ++ ) if ( ssize < exe_sections [ i ] . rva + exe_sections [ i ] . vsz ) ssize = exe_sections [ i ] . rva + exe_sections [ i ] . vsz ; if ( ! ssize ) break ; CLI_UNPSIZELIMITS ( ""Aspack"" , ssize ) ; if ( ! ( src = ( char * ) cli_calloc ( ssize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } for ( i = 0 ; i < ( unsigned int ) nsections ; i ++ ) { if ( ! exe_sections [ i ] . rsz ) continue ; if ( ! CLI_ISCONTAINED ( src , ssize , src + exe_sections [ i ] . rva , exe_sections [ i ] . rsz ) ) break ; if ( ( unsigned int ) fmap_readn ( map , src + exe_sections [ i ] . rva , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) != exe_sections [ i ] . rsz ) break ; } if ( i != nsections ) { cli_dbgmsg ( ""Aspack:<S2SV_blank>Probably<S2SV_blank>hacked/damaged<S2SV_blank>Aspack<S2SV_blank>file.\\n"" ) ; free ( src ) ; break ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Aspack"" ) ; # endif CLI_UNPTEMP ( ""Aspack"" , ( src , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Aspack"" , ( unaspack212 ( ( uint8_t * ) src , ssize , exe_sections , nsections , vep - 1 , EC32 ( optional_hdr32 . ImageBase ) , ndesc ) ) , 1 , ( src , 0 ) ) ; break ; } while ( DCONF & PE_CONF_NSPACK ) { uint32_t eprva = vep ; uint32_t start_of_stuff , rep = ep ; unsigned int nowinldr ; const char * nbuff ; src = epbuff ; if ( * epbuff == '\\xe9' ) { eprva = cli_readint32 ( epbuff + 1 ) + vep + 5 ; if ( ! ( rep = cli_rawaddr ( eprva , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) break ; if ( ! ( nbuff = fmap_need_off_once ( map , rep , 24 ) ) ) break ; src = nbuff ; } if ( memcmp ( src , ""\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00"" , 13 ) ) break ; nowinldr = 0x54 - cli_readint32 ( src + 17 ) ; cli_dbgmsg ( ""NsPack:<S2SV_blank>Found<S2SV_blank>*start_of_stuff<S2SV_blank>@delta-%x\\n"" , nowinldr ) ; if ( ! ( nbuff = fmap_need_off_once ( map , rep - nowinldr , 4 ) ) ) break ; start_of_stuff = rep + cli_readint32 ( nbuff ) ; if ( ! ( nbuff = fmap_need_off_once ( map , start_of_stuff , 20 ) ) ) break ; src = nbuff ; if ( ! cli_readint32 ( nbuff ) ) { start_of_stuff += 4 ; src += 4 ; } ssize = cli_readint32 ( src + 5 ) | 0xff ; dsize = cli_readint32 ( src + 9 ) ; CLI_UNPSIZELIMITS ( ""NsPack"" , MAX ( ssize , dsize ) ) ; if ( ! ssize || ! dsize || dsize != exe_sections [ 0 ] . vsz ) break ; if ( ! ( dest = cli_malloc ( dsize ) ) ) { cli_errmsg ( ""NsPack:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>dest<S2SV_blank>%u\\n"" , dsize ) ; break ; } if ( ! ( src = fmap_need_off ( map , start_of_stuff , ssize ) ) ) { free ( dest ) ; break ; } eprva += 0x27a ; if ( ! ( rep = cli_rawaddr ( eprva , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) { free ( dest ) ; break ; } if ( ! ( nbuff = fmap_need_off_once ( map , rep , 5 ) ) ) { free ( dest ) ; break ; } fmap_unneed_off ( map , start_of_stuff , ssize ) ; eprva = eprva + 5 + cli_readint32 ( nbuff + 1 ) ; cli_dbgmsg ( ""NsPack:<S2SV_blank>OEP<S2SV_blank>=<S2SV_blank>%08x\\n"" , eprva ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""NsPack"" ) ; # endif CLI_UNPTEMP ( ""NsPack"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""NsPack"" , ( unspack ( src , dest , ctx , exe_sections [ 0 ] . rva , EC32 ( optional_hdr32 . ImageBase ) , eprva , ndesc ) ) , 0 , ( dest , 0 ) ) ; break ; } ctx -> corrupted_input = corrupted_cur ; bc_ctx = cli_bytecode_context_alloc ( ) ; if ( ! bc_ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>bc_ctx\\n"" ) ; return CL_EMEM ; } cli_bytecode_context_setpe ( bc_ctx , & pedata , exe_sections ) ; cli_bytecode_context_setctx ( bc_ctx , ctx ) ; ret = cli_bytecode_runhook ( ctx , ctx -> engine , bc_ctx , BC_PE_UNPACKER , map ) ; switch ( ret ) { case CL_VIRUS : free ( exe_sections ) ; cli_bytecode_context_destroy ( bc_ctx ) ; return CL_VIRUS ; case CL_SUCCESS : ndesc = cli_bytecode_context_getresult_file ( bc_ctx , & tempfile ) ; cli_bytecode_context_destroy ( bc_ctx ) ; if ( ndesc != - 1 && tempfile ) { CLI_UNPRESULTS ( ""bytecode<S2SV_blank>PE<S2SV_blank>hook"" , 1 , 1 , ( 0 ) ) ; } break ; default : cli_bytecode_context_destroy ( bc_ctx ) ; } free ( exe_sections ) ; # if HAVE_JSON if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } # endif if ( SCAN_ALL && viruses_found ) return CL_VIRUS ; return CL_CLEAN ; }","exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ;exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ;exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ;exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ;exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ;exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ;exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ;exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ;exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ;if ( exe_sections [ i ] . rsz ) {if ( ! CLI_ISCONTAINED ( 0 , fsize , exe_sections [ i ] . uraw , exe_sections [ i ] . ursz ) || exe_sections [ i ] . raw >= fsize ) {cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>or<S2SV_blank>exists<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\\if ( nsections == 1 ) {free ( section_hdr ) ;free ( exe_sections ) ;if ( DETECT_BROKEN_PE ) {cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ;return CL_VIRUS ;}return CL_CLEAN ;}for ( j = i ;j < nsections - 1 ;j ++ ) memcpy ( & exe_sections [ j ] , & exe_sections [ j + 1 ] , sizeof ( struct cli_exe_section ) ) ;for ( j = i ;j < nsections - 1 ;j ++ ) memcpy ( & section_hdr [ j ] , & section_hdr [ j + 1 ] , sizeof ( struct pe_image_section_hdr ) ) ;nsections -- ;rescan = 1 ;break ;}}}}for ( i = 0 ;i < nsections ;i ++ ) {",1674
683,"buggy line: # endif  for ( i = 0 ;strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ;sname [ 8 ] = 0 ;exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ;exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ;exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ;exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ;exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ;exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ;exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ;exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ;exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ;cwe id:CWE-119context: int cli_scanpe ( cli_ctx * ctx ) { uint16_t e_magic ; uint16_t nsections ; uint32_t e_lfanew ; uint32_t ep , vep ; uint8_t polipos = 0 ; time_t timestamp ; struct pe_image_file_hdr file_hdr ; union { struct pe_image_optional_hdr64 opt64 ; struct pe_image_optional_hdr32 opt32 ; } pe_opt ; struct pe_image_section_hdr * section_hdr ; char sname [ 9 ] , epbuff [ 4096 ] , * tempfile ; uint32_t epsize ; ssize_t bytes , at ;  unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ;  unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ; int ( * upxfn ) ( const char * , uint32_t , char * , uint32_t * , uint32_t , uint32_t , uint32_t ) = NULL ; const char * src = NULL ; char * dest = NULL ; int ndesc , ret = CL_CLEAN , upack = 0 , native = 0 ; size_t fsize ;  uint32_t valign , falign , hdr_size , j ;  struct cli_exe_section * exe_sections ; char timestr [ 32 ] ; struct pe_image_data_dir * dirs ; struct cli_bc_ctx * bc_ctx ; fmap_t * map ; struct cli_pe_hook_data pedata ; # ifdef HAVE__INTERNAL__SHA_COLLECT int sha_collect = ctx -> sha_collect ; # endif const char * archtype = NULL , * subsystem = NULL ; uint32_t viruses_found = 0 ; # if HAVE_JSON int toval = 0 ; struct json_object * pe_json = NULL ; char jsonbuf [ 128 ] ; # endif if ( ! ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>ctx<S2SV_blank>==<S2SV_blank>NULL\\n"" ) ; return CL_ENULLARG ; } # if HAVE_JSON if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } if ( ctx -> options & CL_SCAN_FILE_PROPERTIES ) { pe_json = get_pe_property ( ctx ) ; } # endif map = * ctx -> fmap ; if ( fmap_readn ( map , & e_magic , 0 , sizeof ( e_magic ) ) != sizeof ( e_magic ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>DOS<S2SV_blank>signature\\n"" ) ; return CL_CLEAN ; } if ( EC16 ( e_magic ) != PE_IMAGE_DOS_SIGNATURE && EC16 ( e_magic ) != PE_IMAGE_DOS_SIGNATURE_OLD ) { cli_dbgmsg ( ""Invalid<S2SV_blank>DOS<S2SV_blank>signature\\n"" ) ; return CL_CLEAN ; } if ( fmap_readn ( map , & e_lfanew , 58 + sizeof ( e_magic ) , sizeof ( e_lfanew ) ) != sizeof ( e_lfanew ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>new<S2SV_blank>header<S2SV_blank>address\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } e_lfanew = EC32 ( e_lfanew ) ; cli_dbgmsg ( ""e_lfanew<S2SV_blank>==<S2SV_blank>%d\\n"" , e_lfanew ) ; if ( ! e_lfanew ) { cli_dbgmsg ( ""Not<S2SV_blank>a<S2SV_blank>PE<S2SV_blank>file\\n"" ) ; return CL_CLEAN ; } if ( fmap_readn ( map , & file_hdr , e_lfanew , sizeof ( struct pe_image_file_hdr ) ) != sizeof ( struct pe_image_file_hdr ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>file<S2SV_blank>header\\n"" ) ; return CL_CLEAN ; } if ( EC32 ( file_hdr . Magic ) != PE_IMAGE_NT_SIGNATURE ) { cli_dbgmsg ( ""Invalid<S2SV_blank>PE<S2SV_blank>signature<S2SV_blank>(probably<S2SV_blank>NE<S2SV_blank>file)\\n"" ) ; return CL_CLEAN ; } if ( EC16 ( file_hdr . Characteristics ) & 0x2000 ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json , ""Type"" , ""DLL"" ) ; # endif cli_dbgmsg ( ""File<S2SV_blank>type:<S2SV_blank>DLL\\n"" ) ; dll = 1 ; } else if ( EC16 ( file_hdr . Characteristics ) & 0x01 ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json , ""Type"" , ""EXE"" ) ; # endif cli_dbgmsg ( ""File<S2SV_blank>type:<S2SV_blank>Executable\\n"" ) ; } switch ( EC16 ( file_hdr . Machine ) ) { case 0x0 : archtype = ""Unknown"" ; break ; case 0x14c : archtype = ""80386"" ; break ; case 0x14d : archtype = ""80486"" ; break ; case 0x14e : archtype = ""80586"" ; break ; case 0x160 : archtype = ""R30000<S2SV_blank>(big-endian)"" ; break ; case 0x162 : archtype = ""R3000"" ; break ; case 0x166 : archtype = ""R4000"" ; break ; case 0x168 : archtype = ""R10000"" ; break ; case 0x184 : archtype = ""DEC<S2SV_blank>Alpha<S2SV_blank>AXP"" ; break ; case 0x284 : archtype = ""DEC<S2SV_blank>Alpha<S2SV_blank>AXP<S2SV_blank>64bit"" ; break ; case 0x1f0 : archtype = ""PowerPC"" ; break ; case 0x200 : archtype = ""IA64"" ; break ; case 0x268 : archtype = ""M68k"" ; break ; case 0x266 : archtype = ""MIPS16"" ; break ; case 0x366 : archtype = ""MIPS+FPU"" ; break ; case 0x466 : archtype = ""MIPS16+FPU"" ; break ; case 0x1a2 : archtype = ""Hitachi<S2SV_blank>SH3"" ; break ; case 0x1a3 : archtype = ""Hitachi<S2SV_blank>SH3-DSP"" ; break ; case 0x1a4 : archtype = ""Hitachi<S2SV_blank>SH3-E"" ; break ; case 0x1a6 : archtype = ""Hitachi<S2SV_blank>SH4"" ; break ; case 0x1a8 : archtype = ""Hitachi<S2SV_blank>SH5"" ; break ; case 0x1c0 : archtype = ""ARM"" ; break ; case 0x1c2 : archtype = ""THUMB"" ; break ; case 0x1d3 : archtype = ""AM33"" ; break ; case 0x520 : archtype = ""Infineon<S2SV_blank>TriCore"" ; break ; case 0xcef : archtype = ""CEF"" ; break ; case 0xebc : archtype = ""EFI<S2SV_blank>Byte<S2SV_blank>Code"" ; break ; case 0x9041 : archtype = ""M32R"" ; break ; case 0xc0ee : archtype = ""CEEE"" ; break ; case 0x8664 : archtype = ""AMD64"" ; break ; default : archtype = ""Unknown"" ; } if ( ( archtype ) ) { cli_dbgmsg ( ""Machine<S2SV_blank>type:<S2SV_blank>%s\\n"" , archtype ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""ArchType"" , archtype ) ; # endif } nsections = EC16 ( file_hdr . NumberOfSections ) ; if ( nsections < 1 || nsections > 96 ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadNumberOfSections"" ) ; # endif if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } if ( ! ctx -> corrupted_input ) { if ( nsections ) cli_warnmsg ( ""PE<S2SV_blank>file<S2SV_blank>contains<S2SV_blank>%d<S2SV_blank>sections\\n"" , nsections ) ; else cli_warnmsg ( ""PE<S2SV_blank>file<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>sections\\n"" ) ; } return CL_CLEAN ; } cli_dbgmsg ( ""NumberOfSections:<S2SV_blank>%d\\n"" , nsections ) ; timestamp = ( time_t ) EC32 ( file_hdr . TimeDateStamp ) ; cli_dbgmsg ( ""TimeDateStamp:<S2SV_blank>%s"" , cli_ctime ( & timestamp , timestr , sizeof ( timestr ) ) ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""TimeDateStamp"" , cli_ctime ( & timestamp , timestr , sizeof ( timestr ) ) ) ; # endif cli_dbgmsg ( ""SizeOfOptionalHeader:<S2SV_blank>%x\\n"" , EC16 ( file_hdr . SizeOfOptionalHeader ) ) ; # if HAVE_JSON cli_jsonint ( pe_json , ""SizeOfOptionalHeader"" , EC16 ( file_hdr . SizeOfOptionalHeader ) ) ; # endif if ( EC16 ( file_hdr . SizeOfOptionalHeader ) < sizeof ( struct pe_image_optional_hdr32 ) ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadOptionalHeaderSize"" ) ; # endif cli_dbgmsg ( ""SizeOfOptionalHeader<S2SV_blank>too<S2SV_blank>small\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at = e_lfanew + sizeof ( struct pe_image_file_hdr ) ; if ( fmap_readn ( map , & optional_hdr32 , at , sizeof ( struct pe_image_optional_hdr32 ) ) != sizeof ( struct pe_image_optional_hdr32 ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>optional<S2SV_blank>file<S2SV_blank>header\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_optional_hdr32 ) ; if ( EC16 ( optional_hdr64 . Magic ) == PE32P_SIGNATURE ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadOptionalHeaderSizePE32Plus"" ) ; # endif if ( EC16 ( file_hdr . SizeOfOptionalHeader ) != sizeof ( struct pe_image_optional_hdr64 ) ) { cli_dbgmsg ( ""Incorrect<S2SV_blank>SizeOfOptionalHeader<S2SV_blank>for<S2SV_blank>PE32+\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } pe_plus = 1 ; } if ( ! pe_plus ) { if ( EC16 ( file_hdr . SizeOfOptionalHeader ) != sizeof ( struct pe_image_optional_hdr32 ) ) { at += EC16 ( file_hdr . SizeOfOptionalHeader ) - sizeof ( struct pe_image_optional_hdr32 ) ; } if ( DCONF & PE_CONF_UPACK ) upack = ( EC16 ( file_hdr . SizeOfOptionalHeader ) == 0x148 ) ; vep = EC32 ( optional_hdr32 . AddressOfEntryPoint ) ; hdr_size = EC32 ( optional_hdr32 . SizeOfHeaders ) ; cli_dbgmsg ( ""File<S2SV_blank>format:<S2SV_blank>PE\\n"" ) ; cli_dbgmsg ( ""MajorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr32 . MajorLinkerVersion ) ; cli_dbgmsg ( ""MinorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr32 . MinorLinkerVersion ) ; cli_dbgmsg ( ""SizeOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfCode ) ) ; cli_dbgmsg ( ""SizeOfInitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfInitializedData ) ) ; cli_dbgmsg ( ""SizeOfUninitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfUninitializedData ) ) ; cli_dbgmsg ( ""AddressOfEntryPoint:<S2SV_blank>0x%x\\n"" , vep ) ; cli_dbgmsg ( ""BaseOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . BaseOfCode ) ) ; cli_dbgmsg ( ""SectionAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SectionAlignment ) ) ; cli_dbgmsg ( ""FileAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . FileAlignment ) ) ; cli_dbgmsg ( ""MajorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr32 . MajorSubsystemVersion ) ) ; cli_dbgmsg ( ""MinorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr32 . MinorSubsystemVersion ) ) ; cli_dbgmsg ( ""SizeOfImage:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfImage ) ) ; cli_dbgmsg ( ""SizeOfHeaders:<S2SV_blank>0x%x\\n"" , hdr_size ) ; cli_dbgmsg ( ""NumberOfRvaAndSizes:<S2SV_blank>%d\\n"" , EC32 ( optional_hdr32 . NumberOfRvaAndSizes ) ) ; dirs = optional_hdr32 . DataDirectory ; # if HAVE_JSON cli_jsonint ( pe_json , ""MajorLinkerVersion"" , optional_hdr32 . MajorLinkerVersion ) ; cli_jsonint ( pe_json , ""MinorLinkerVersion"" , optional_hdr32 . MinorLinkerVersion ) ; cli_jsonint ( pe_json , ""SizeOfCode"" , EC32 ( optional_hdr32 . SizeOfCode ) ) ; cli_jsonint ( pe_json , ""SizeOfInitializedData"" , EC32 ( optional_hdr32 . SizeOfInitializedData ) ) ; cli_jsonint ( pe_json , ""SizeOfUninitializedData"" , EC32 ( optional_hdr32 . SizeOfUninitializedData ) ) ; cli_jsonint ( pe_json , ""NumberOfRvaAndSizes"" , EC32 ( optional_hdr32 . NumberOfRvaAndSizes ) ) ; cli_jsonint ( pe_json , ""MajorSubsystemVersion"" , EC16 ( optional_hdr32 . MajorSubsystemVersion ) ) ; cli_jsonint ( pe_json , ""MinorSubsystemVersion"" , EC16 ( optional_hdr32 . MinorSubsystemVersion ) ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . BaseOfCode ) ) ; cli_jsonstr ( pe_json , ""BaseOfCode"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . SectionAlignment ) ) ; cli_jsonstr ( pe_json , ""SectionAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . FileAlignment ) ) ; cli_jsonstr ( pe_json , ""FileAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . SizeOfImage ) ) ; cli_jsonstr ( pe_json , ""SizeOfImage"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , hdr_size ) ; cli_jsonstr ( pe_json , ""SizeOfHeaders"" , jsonbuf ) ; # endif } else { if ( fmap_readn ( map , & optional_hdr32 + 1 , at , sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ) != sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>optional<S2SV_blank>file<S2SV_blank>header\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ; vep = EC32 ( optional_hdr64 . AddressOfEntryPoint ) ; hdr_size = EC32 ( optional_hdr64 . SizeOfHeaders ) ; cli_dbgmsg ( ""File<S2SV_blank>format:<S2SV_blank>PE32+\\n"" ) ; cli_dbgmsg ( ""MajorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr64 . MajorLinkerVersion ) ; cli_dbgmsg ( ""MinorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr64 . MinorLinkerVersion ) ; cli_dbgmsg ( ""SizeOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfCode ) ) ; cli_dbgmsg ( ""SizeOfInitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfInitializedData ) ) ; cli_dbgmsg ( ""SizeOfUninitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfUninitializedData ) ) ; cli_dbgmsg ( ""AddressOfEntryPoint:<S2SV_blank>0x%x\\n"" , vep ) ; cli_dbgmsg ( ""BaseOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . BaseOfCode ) ) ; cli_dbgmsg ( ""SectionAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SectionAlignment ) ) ; cli_dbgmsg ( ""FileAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . FileAlignment ) ) ; cli_dbgmsg ( ""MajorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr64 . MajorSubsystemVersion ) ) ; cli_dbgmsg ( ""MinorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr64 . MinorSubsystemVersion ) ) ; cli_dbgmsg ( ""SizeOfImage:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfImage ) ) ; cli_dbgmsg ( ""SizeOfHeaders:<S2SV_blank>0x%x\\n"" , hdr_size ) ; cli_dbgmsg ( ""NumberOfRvaAndSizes:<S2SV_blank>%d\\n"" , EC32 ( optional_hdr64 . NumberOfRvaAndSizes ) ) ; dirs = optional_hdr64 . DataDirectory ; # if HAVE_JSON cli_jsonint ( pe_json , ""MajorLinkerVersion"" , optional_hdr64 . MajorLinkerVersion ) ; cli_jsonint ( pe_json , ""MinorLinkerVersion"" , optional_hdr64 . MinorLinkerVersion ) ; cli_jsonint ( pe_json , ""SizeOfCode"" , EC32 ( optional_hdr64 . SizeOfCode ) ) ; cli_jsonint ( pe_json , ""SizeOfInitializedData"" , EC32 ( optional_hdr64 . SizeOfInitializedData ) ) ; cli_jsonint ( pe_json , ""SizeOfUninitializedData"" , EC32 ( optional_hdr64 . SizeOfUninitializedData ) ) ; cli_jsonint ( pe_json , ""NumberOfRvaAndSizes"" , EC32 ( optional_hdr64 . NumberOfRvaAndSizes ) ) ; cli_jsonint ( pe_json , ""MajorSubsystemVersion"" , EC16 ( optional_hdr64 . MajorSubsystemVersion ) ) ; cli_jsonint ( pe_json , ""MinorSubsystemVersion"" , EC16 ( optional_hdr64 . MinorSubsystemVersion ) ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . BaseOfCode ) ) ; cli_jsonstr ( pe_json , ""BaseOfCode"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . SectionAlignment ) ) ; cli_jsonstr ( pe_json , ""SectionAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . FileAlignment ) ) ; cli_jsonstr ( pe_json , ""FileAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . SizeOfImage ) ) ; cli_jsonstr ( pe_json , ""SizeOfImage"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , hdr_size ) ; cli_jsonstr ( pe_json , ""SizeOfHeaders"" , jsonbuf ) ; # endif } # if HAVE_JSON if ( ctx -> options & CL_SCAN_FILE_PROPERTIES ) { snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , vep ) ; cli_jsonstr ( pe_json , ""EntryPoint"" , jsonbuf ) ; } # endif switch ( pe_plus ? EC16 ( optional_hdr64 . Subsystem ) : EC16 ( optional_hdr32 . Subsystem ) ) { case 0 : subsystem = ""Unknown"" ; break ; case 1 : subsystem = ""Native<S2SV_blank>(svc)"" ; native = 1 ; break ; case 2 : subsystem = ""Win32<S2SV_blank>GUI"" ; break ; case 3 : subsystem = ""Win32<S2SV_blank>console"" ; break ; case 5 : subsystem = ""OS/2<S2SV_blank>console"" ; break ; case 7 : subsystem = ""POSIX<S2SV_blank>console"" ; break ; case 8 : subsystem = ""Native<S2SV_blank>Win9x<S2SV_blank>driver"" ; break ; case 9 : subsystem = ""WinCE<S2SV_blank>GUI"" ; break ; case 10 : subsystem = ""EFI<S2SV_blank>application"" ; break ; case 11 : subsystem = ""EFI<S2SV_blank>driver"" ; break ; case 12 : subsystem = ""EFI<S2SV_blank>runtime<S2SV_blank>driver"" ; break ; case 13 : subsystem = ""EFI<S2SV_blank>ROM<S2SV_blank>image"" ; break ; case 14 : subsystem = ""Xbox"" ; break ; case 16 : subsystem = ""Boot<S2SV_blank>application"" ; break ; default : subsystem = ""Unknown"" ; } cli_dbgmsg ( ""Subsystem:<S2SV_blank>%s\\n"" , subsystem ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Subsystem"" , subsystem ) ; # endif cli_dbgmsg ( ""------------------------------------\\n"" ) ; if ( DETECT_BROKEN_PE && ! native && ( ! ( pe_plus ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ) || ( pe_plus ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ) % 0x1000 ) ) { cli_dbgmsg ( ""Bad<S2SV_blank>virtual<S2SV_blank>alignemnt\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } if ( DETECT_BROKEN_PE && ! native && ( ! ( pe_plus ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ) || ( pe_plus ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ) % 0x200 ) ) { cli_dbgmsg ( ""Bad<S2SV_blank>file<S2SV_blank>alignemnt\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } fsize = map -> len ; section_hdr = ( struct pe_image_section_hdr * ) cli_calloc ( nsections , sizeof ( struct pe_image_section_hdr ) ) ; if ( ! section_hdr ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>section<S2SV_blank>headers\\n"" ) ; return CL_EMEM ; } exe_sections = ( struct cli_exe_section * ) cli_calloc ( nsections , sizeof ( struct cli_exe_section ) ) ; if ( ! exe_sections ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>section<S2SV_blank>headers\\n"" ) ; free ( section_hdr ) ; return CL_EMEM ; } valign = ( pe_plus ) ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ; falign = ( pe_plus ) ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ; if ( fmap_readn ( map , section_hdr , at , sizeof ( struct pe_image_section_hdr ) * nsections ) != ( int ) ( nsections * sizeof ( struct pe_image_section_hdr ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>section<S2SV_blank>header\\n"" ) ; cli_dbgmsg ( ""Possibly<S2SV_blank>broken<S2SV_blank>PE<S2SV_blank>file\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_section_hdr ) * nsections ; for ( i = 0 ; falign != 0x200 && i < nsections ; i ++ ) { if ( falign && section_hdr [ i ] . SizeOfRawData && EC32 ( section_hdr [ i ] . PointerToRawData ) % falign && ! ( EC32 ( section_hdr [ i ] . PointerToRawData ) % 0x200 ) ) { cli_dbgmsg ( ""Found<S2SV_blank>misaligned<S2SV_blank>section,<S2SV_blank>using<S2SV_blank>0x200\\n"" ) ; falign = 0x200 ; } } hdr_size = PESALIGN ( hdr_size , valign ) ; # if HAVE_JSON cli_jsonint ( pe_json , ""NumberOfSections"" , nsections ) ; # endif  for ( i = 0 ; i < nsections ; i ++ ) {   strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ;   sname [ 8 ] = 0 ;  exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; # if HAVE_JSON add_section_info ( ctx , & exe_sections [ i ] ) ; if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { free ( section_hdr ) ; free ( exe_sections ) ; return CL_ETIMEOUT ; } # endif if ( ! exe_sections [ i ] . vsz && exe_sections [ i ] . rsz ) exe_sections [ i ] . vsz = PESALIGN ( exe_sections [ i ] . ursz , valign ) ; if ( exe_sections [ i ] . rsz && fsize > exe_sections [ i ] . raw && ! CLI_ISCONTAINED ( 0 , ( uint32_t ) fsize , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) ) exe_sections [ i ] . rsz = fsize - exe_sections [ i ] . raw ; cli_dbgmsg ( ""Section<S2SV_blank>%d\\n"" , i ) ; cli_dbgmsg ( ""Section<S2SV_blank>name:<S2SV_blank>%s\\n"" , sname ) ; cli_dbgmsg ( ""Section<S2SV_blank>data<S2SV_blank>(from<S2SV_blank>headers<S2SV_blank>-<S2SV_blank>in<S2SV_blank>memory)\\n"" ) ; cli_dbgmsg ( ""VirtualSize:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . uvsz , exe_sections [ i ] . vsz ) ; cli_dbgmsg ( ""VirtualAddress:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . urva , exe_sections [ i ] . rva ) ; cli_dbgmsg ( ""SizeOfRawData:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . ursz , exe_sections [ i ] . rsz ) ; cli_dbgmsg ( ""PointerToRawData:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . uraw , exe_sections [ i ] . raw ) ; if ( exe_sections [ i ] . chr & 0x20 ) { cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>executable<S2SV_blank>code\\n"" ) ; if ( exe_sections [ i ] . vsz < exe_sections [ i ] . rsz ) { cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>free<S2SV_blank>space\\n"" ) ; } } if ( exe_sections [ i ] . chr & 0x20000000 ) cli_dbgmsg ( ""Section\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>executable\\n"" ) ; if ( exe_sections [ i ] . chr & 0x80000000 ) cli_dbgmsg ( ""Section\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>writeable\\n"" ) ; if ( DETECT_BROKEN_PE && ( ! valign || ( exe_sections [ i ] . urva % valign ) ) ) { cli_dbgmsg ( ""VirtualAddress<S2SV_blank>is<S2SV_blank>misaligned\\n"" ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } if ( exe_sections [ i ] . rsz ) {  if ( exe_sections [ i ] . raw >= fsize ) {  cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\n"" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } if ( SCAN_ALGO && ( DCONF & PE_CONF_POLIPOS ) && ! * sname && exe_sections [ i ] . vsz > 40000 && exe_sections [ i ] . vsz < 70000 && exe_sections [ i ] . chr == 0xe0000060 ) polipos = i ; if ( ( DCONF & PE_CONF_MD5SECT ) && ctx -> engine -> hm_mdb ) { ret = scan_pe_mdb ( ctx , & exe_sections [ i ] ) ; if ( ret != CL_CLEAN ) { if ( ret != CL_VIRUS ) cli_errmsg ( ""scan_pe:<S2SV_blank>scan_pe_mdb<S2SV_blank>failed:<S2SV_blank>%s!\\n"" , cl_strerror ( ret ) ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return ret ; } } } cli_dbgmsg ( ""------------------------------------\\n"" ) ; if ( exe_sections [ i ] . urva >> 31 || exe_sections [ i ] . uvsz >> 31 || ( exe_sections [ i ] . rsz && exe_sections [ i ] . uraw >> 31 ) || exe_sections [ i ] . ursz >> 31 ) { cli_dbgmsg ( ""Found<S2SV_blank>PE<S2SV_blank>values<S2SV_blank>with<S2SV_blank>sign<S2SV_blank>bit<S2SV_blank>set\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } if ( ! i ) { if ( DETECT_BROKEN_PE && exe_sections [ i ] . urva != hdr_size ) { cli_dbgmsg ( ""First<S2SV_blank>section<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>place\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } min = exe_sections [ i ] . rva ; max = exe_sections [ i ] . rva + exe_sections [ i ] . rsz ; } else { if ( DETECT_BROKEN_PE && exe_sections [ i ] . urva - exe_sections [ i - 1 ] . urva != exe_sections [ i - 1 ] . vsz ) { cli_dbgmsg ( ""Virtually<S2SV_blank>misplaced<S2SV_blank>section<S2SV_blank>(wrong<S2SV_blank>order,<S2SV_blank>overlapping,<S2SV_blank>non<S2SV_blank>contiguous)\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } if ( exe_sections [ i ] . rva < min ) min = exe_sections [ i ] . rva ; if ( exe_sections [ i ] . rva + exe_sections [ i ] . rsz > max ) { max = exe_sections [ i ] . rva + exe_sections [ i ] . rsz ; overlays = exe_sections [ i ] . raw + exe_sections [ i ] . rsz ; } } } free ( section_hdr ) ; if ( ! ( ep = cli_rawaddr ( vep , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) { cli_dbgmsg ( ""EntryPoint<S2SV_blank>out<S2SV_blank>of<S2SV_blank>file\\n"" ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } # if HAVE_JSON cli_jsonint ( pe_json , ""EntryPointOffset"" , ep ) ; if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } # endif cli_dbgmsg ( ""EntryPoint<S2SV_blank>offset:<S2SV_blank>0x%x<S2SV_blank>(%d)\\n"" , ep , ep ) ; if ( pe_plus ) { free ( exe_sections ) ; return CL_CLEAN ; } epsize = fmap_readn ( map , epbuff , ep , 4096 ) ; if ( overlays ) { int overlays_sz = fsize - overlays ; if ( overlays_sz > 0 ) { ret = cli_scanishield ( ctx , overlays , overlays_sz ) ; if ( ret != CL_CLEAN ) { free ( exe_sections ) ; return ret ; } } } pedata . nsections = nsections ; pedata . ep = ep ; pedata . offset = 0 ; memcpy ( & pedata . file_hdr , & file_hdr , sizeof ( file_hdr ) ) ; memcpy ( & pedata . opt32 , & pe_opt . opt32 , sizeof ( pe_opt . opt32 ) ) ; memcpy ( & pedata . opt64 , & pe_opt . opt64 , sizeof ( pe_opt . opt64 ) ) ; memcpy ( & pedata . dirs , dirs , sizeof ( pedata . dirs ) ) ; pedata . e_lfanew = e_lfanew ; pedata . overlays = overlays ; pedata . overlays_sz = fsize - overlays ; pedata . hdr_size = hdr_size ; bc_ctx = cli_bytecode_context_alloc ( ) ; if ( ! bc_ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>bc_ctx\\n"" ) ; free ( exe_sections ) ; return CL_EMEM ; } cli_bytecode_context_setpe ( bc_ctx , & pedata , exe_sections ) ; cli_bytecode_context_setctx ( bc_ctx , ctx ) ; ret = cli_bytecode_runhook ( ctx , ctx -> engine , bc_ctx , BC_PE_ALL , map ) ; switch ( ret ) { case CL_ENULLARG : cli_warnmsg ( ""cli_scanpe:<S2SV_blank>NULL<S2SV_blank>argument<S2SV_blank>supplied\\n"" ) ; break ; case CL_VIRUS : case CL_BREAK : free ( exe_sections ) ; cli_bytecode_context_destroy ( bc_ctx ) ; return ret == CL_VIRUS ? CL_VIRUS : CL_CLEAN ; } cli_bytecode_context_destroy ( bc_ctx ) ; if ( SCAN_ALGO && ( DCONF & PE_CONF_PARITE ) && ! dll && epsize == 4096 && ep == exe_sections [ nsections - 1 ] . raw ) { const char * pt = cli_memstr ( epbuff , 4040 , ""\\x47\\x65\\x74\\x50\\x72\\x6f\\x63\\x41\\x64\\x64\\x72\\x65\\x73\\x73\\x00"" , 15 ) ; if ( pt ) { pt += 15 ; if ( ( ( ( uint32_t ) cli_readint32 ( pt ) ^ ( uint32_t ) cli_readint32 ( pt + 4 ) ) == 0x505a4f ) && ( ( ( uint32_t ) cli_readint32 ( pt + 8 ) ^ ( uint32_t ) cli_readint32 ( pt + 12 ) ) == 0xffffb ) && ( ( ( uint32_t ) cli_readint32 ( pt + 16 ) ^ ( uint32_t ) cli_readint32 ( pt + 20 ) ) == 0xb8 ) ) { cli_append_virus ( ctx , ""Heuristics.W32.Parite.B"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } if ( SCAN_ALGO && ( DCONF & PE_CONF_KRIZ ) && epsize >= 200 && CLI_ISCONTAINED ( exe_sections [ nsections - 1 ] . raw , exe_sections [ nsections - 1 ] . rsz , ep , 0x0fd2 ) && epbuff [ 1 ] == '\\x9c' && epbuff [ 2 ] == '\\x60' ) { enum { KZSTRASH , KZSCDELTA , KZSPDELTA , KZSGETSIZE , KZSXORPRFX , KZSXOR , KZSDDELTA , KZSLOOP , KZSTOP } ; uint8_t kzs [ ] = { KZSTRASH , KZSCDELTA , KZSPDELTA , KZSGETSIZE , KZSTRASH , KZSXORPRFX , KZSXOR , KZSTRASH , KZSDDELTA , KZSTRASH , KZSLOOP , KZSTOP } ; uint8_t * kzstate = kzs ; uint8_t * kzcode = ( uint8_t * ) epbuff + 3 ; uint8_t kzdptr = 0xff , kzdsize = 0xff ; int kzlen = 197 , kzinitlen = 0xffff , kzxorlen = - 1 ; cli_dbgmsg ( ""in<S2SV_blank>kriz\\n"" ) ; while ( * kzstate != KZSTOP ) { uint8_t op ; if ( kzlen <= 6 ) break ; op = * kzcode ++ ; kzlen -- ; switch ( * kzstate ) { case KZSTRASH : case KZSGETSIZE : { int opsz = 0 ; switch ( op ) { case 0x81 : kzcode += 5 ; kzlen -= 5 ; break ; case 0xb8 : case 0xb9 : case 0xba : case 0xbb : case 0xbd : case 0xbe : case 0xbf : if ( * kzstate == KZSGETSIZE && cli_readint32 ( kzcode ) == 0x0fd2 ) { kzinitlen = kzlen - 5 ; kzdsize = op - 0xb8 ; kzstate ++ ; op = 4 ; cli_dbgmsg ( ""kriz:<S2SV_blank>using<S2SV_blank>#%d<S2SV_blank>as<S2SV_blank>size<S2SV_blank>counter\\n"" , kzdsize ) ; } opsz = 4 ; case 0x48 : case 0x49 : case 0x4a : case 0x4b : case 0x4d : case 0x4e : case 0x4f : op &= 7 ; if ( op != kzdptr && op != kzdsize ) { kzcode += opsz ; kzlen -= opsz ; break ; } default : kzcode -- ; kzlen ++ ; kzstate ++ ; } break ; } case KZSCDELTA : if ( op == 0xe8 && ( uint32_t ) cli_readint32 ( kzcode ) < 0xff ) { kzlen -= * kzcode + 4 ; kzcode += * kzcode + 4 ; kzstate ++ ; } else * kzstate = KZSTOP ; break ; case KZSPDELTA : if ( ( op & 0xf8 ) == 0x58 && ( kzdptr = op - 0x58 ) != 4 ) { kzstate ++ ; cli_dbgmsg ( ""kriz:<S2SV_blank>using<S2SV_blank>#%d<S2SV_blank>as<S2SV_blank>pointer\\n"" , kzdptr ) ; } else * kzstate = KZSTOP ; break ; case KZSXORPRFX : kzstate ++ ; if ( op == 0x3e ) break ; case KZSXOR : if ( op == 0x80 && * kzcode == kzdptr + 0xb0 ) { kzxorlen = kzlen ; kzcode += + 6 ; kzlen -= + 6 ; kzstate ++ ; } else * kzstate = KZSTOP ; break ; case KZSDDELTA : if ( op == kzdptr + 0x48 ) kzstate ++ ; else * kzstate = KZSTOP ; break ; case KZSLOOP : if ( op == kzdsize + 0x48 && * kzcode == 0x75 && kzlen - ( int8_t ) kzcode [ 1 ] - 3 <= kzinitlen && kzlen - ( int8_t ) kzcode [ 1 ] >= kzxorlen ) { cli_append_virus ( ctx , ""Heuristics.W32.Kriz"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } cli_dbgmsg ( ""kriz:<S2SV_blank>loop<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds,<S2SV_blank>corrupted<S2SV_blank>sample?\\n"" ) ; kzstate ++ ; } } } if ( SCAN_ALGO && ( DCONF & PE_CONF_MAGISTR ) && ! dll && ( nsections > 1 ) && ( exe_sections [ nsections - 1 ] . chr & 0x80000000 ) ) { uint32_t rsize , vsize , dam = 0 ; vsize = exe_sections [ nsections - 1 ] . uvsz ; rsize = exe_sections [ nsections - 1 ] . rsz ; if ( rsize < exe_sections [ nsections - 1 ] . ursz ) { rsize = exe_sections [ nsections - 1 ] . ursz ; dam = 1 ; } if ( vsize >= 0x612c && rsize >= 0x612c && ( ( vsize & 0xff ) == 0xec ) ) { int bw = rsize < 0x7000 ? rsize : 0x7000 ; const char * tbuff ; if ( ( tbuff = fmap_need_off_once ( map , exe_sections [ nsections - 1 ] . raw + rsize - bw , 4096 ) ) ) { if ( cli_memstr ( tbuff , 4091 , ""\\xe8\\x2c\\x61\\x00\\x00"" , 5 ) ) { cli_append_virus ( ctx , dam ? ""Heuristics.W32.Magistr.A.dam"" : ""Heuristics.W32.Magistr.A"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } else if ( rsize >= 0x7000 && vsize >= 0x7000 && ( ( vsize & 0xff ) == 0xed ) ) { int bw = rsize < 0x8000 ? rsize : 0x8000 ; const char * tbuff ; if ( ( tbuff = fmap_need_off_once ( map , exe_sections [ nsections - 1 ] . raw + rsize - bw , 4096 ) ) ) { if ( cli_memstr ( tbuff , 4091 , ""\\xe8\\x04\\x72\\x00\\x00"" , 5 ) ) { cli_append_virus ( ctx , dam ? ""Heuristics.W32.Magistr.B.dam"" : ""Heuristics.W32.Magistr.B"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } } while ( polipos && ! dll && nsections > 2 && nsections < 13 && e_lfanew <= 0x800 && ( EC16 ( optional_hdr32 . Subsystem ) == 2 || EC16 ( optional_hdr32 . Subsystem ) == 3 ) && EC16 ( file_hdr . Machine ) == 0x14c && optional_hdr32 . SizeOfStackReserve >= 0x80000 ) { uint32_t jump , jold , * jumps = NULL ; const uint8_t * code ; unsigned int xsjs = 0 ; if ( exe_sections [ 0 ] . rsz > CLI_MAX_ALLOCATION ) break ; if ( ! exe_sections [ 0 ] . rsz ) break ; if ( ! ( code = fmap_need_off_once ( map , exe_sections [ 0 ] . raw , exe_sections [ 0 ] . rsz ) ) ) break ; for ( i = 0 ; i < exe_sections [ 0 ] . rsz - 5 ; i ++ ) { if ( ( uint8_t ) ( code [ i ] - 0xe8 ) > 1 ) continue ; jump = cli_rawaddr ( exe_sections [ 0 ] . rva + i + 5 + cli_readint32 ( & code [ i + 1 ] ) , exe_sections , nsections , & err , fsize , hdr_size ) ; if ( err || ! CLI_ISCONTAINED ( exe_sections [ polipos ] . raw , exe_sections [ polipos ] . rsz , jump , 9 ) ) continue ; if ( xsjs % 128 == 0 ) { if ( xsjs == 1280 ) break ; if ( ! ( jumps = ( uint32_t * ) cli_realloc2 ( jumps , ( xsjs + 128 ) * sizeof ( uint32_t ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } } j = 0 ; for ( ; j < xsjs ; j ++ ) { if ( jumps [ j ] < jump ) continue ; if ( jumps [ j ] == jump ) { xsjs -- ; break ; } jold = jumps [ j ] ; jumps [ j ] = jump ; jump = jold ; } jumps [ j ] = jump ; xsjs ++ ; } if ( ! xsjs ) break ; cli_dbgmsg ( ""Polipos:<S2SV_blank>Checking<S2SV_blank>%d<S2SV_blank>xsect<S2SV_blank>jump(s)\\n"" , xsjs ) ; for ( i = 0 ; i < xsjs ; i ++ ) { if ( ! ( code = fmap_need_off_once ( map , jumps [ i ] , 9 ) ) ) continue ; if ( ( jump = cli_readint32 ( code ) ) == 0x60ec8b55 || ( code [ 4 ] == 0x0ec && ( ( jump == 0x83ec8b55 && code [ 6 ] == 0x60 ) || ( jump == 0x81ec8b55 && ! code [ 7 ] && ! code [ 8 ] ) ) ) ) { cli_append_virus ( ctx , ""Heuristics.W32.Polipos.A"" ) ; if ( ! SCAN_ALL ) { free ( jumps ) ; free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } free ( jumps ) ; break ; } if ( SCAN_ALGO && ( DCONF & PE_CONF_SWIZZOR ) && nsections > 1 && fsize > 64 * 1024 && fsize < 4 * 1024 * 1024 ) { if ( dirs [ 2 ] . Size ) { struct swizz_stats * stats = cli_calloc ( 1 , sizeof ( * stats ) ) ; unsigned int m = 1000 ; ret = CL_CLEAN ; if ( ! stats ) ret = CL_EMEM ; else { cli_parseres_special ( EC32 ( dirs [ 2 ] . VirtualAddress ) , EC32 ( dirs [ 2 ] . VirtualAddress ) , map , exe_sections , nsections , fsize , hdr_size , 0 , 0 , & m , stats ) ; if ( ( ret = cli_detect_swizz ( stats ) ) == CL_VIRUS ) { cli_append_virus ( ctx , ""Heuristics.Trojan.Swizzor.Gen"" ) ; } free ( stats ) ; } if ( ret != CL_CLEAN ) { if ( ! ( ret == CL_VIRUS && SCAN_ALL ) ) { free ( exe_sections ) ; return ret ; } viruses_found ++ ; } } } corrupted_cur = ctx -> corrupted_input ; ctx -> corrupted_input = 2 ; found = 0 ; if ( DCONF & ( PE_CONF_UPX | PE_CONF_FSG | PE_CONF_MEW ) ) { for ( i = 0 ; i < ( unsigned int ) nsections - 1 ; i ++ ) { if ( ! exe_sections [ i ] . rsz && exe_sections [ i ] . vsz && exe_sections [ i + 1 ] . rsz && exe_sections [ i + 1 ] . vsz ) { found = 1 ; cli_dbgmsg ( ""UPX/FSG/MEW:<S2SV_blank>empty<S2SV_blank>section<S2SV_blank>found<S2SV_blank>-<S2SV_blank>assuming<S2SV_blank>compression\\n"" ) ; # if HAVE_JSON cli_jsonbool ( pe_json , ""HasEmptySection"" , 1 ) ; # endif break ; } } } if ( found && ( DCONF & PE_CONF_MEW ) && epsize >= 16 && epbuff [ 0 ] == '\\xe9' ) { uint32_t fileoffset ; const char * tbuff ; fileoffset = ( vep + cli_readint32 ( epbuff + 1 ) + 5 ) ; while ( fileoffset == 0x154 || fileoffset == 0x158 ) { char * src ; uint32_t offdiff , uselzma ; cli_dbgmsg ( ""MEW:<S2SV_blank>found<S2SV_blank>MEW<S2SV_blank>characteristics<S2SV_blank>%08X<S2SV_blank>+<S2SV_blank>%08X<S2SV_blank>+<S2SV_blank>5<S2SV_blank>=<S2SV_blank>%08X\\n"" , cli_readint32 ( epbuff + 1 ) , vep , cli_readint32 ( epbuff + 1 ) + vep + 5 ) ; if ( ! ( tbuff = fmap_need_off_once ( map , fileoffset , 0xb0 ) ) ) break ; if ( fileoffset == 0x154 ) cli_dbgmsg ( ""MEW:<S2SV_blank>Win9x<S2SV_blank>compatibility<S2SV_blank>was<S2SV_blank>set!\\n"" ) ; else cli_dbgmsg ( ""MEW:<S2SV_blank>Win9x<S2SV_blank>compatibility<S2SV_blank>was<S2SV_blank>NOT<S2SV_blank>set!\\n"" ) ; if ( ( offdiff = cli_readint32 ( tbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) ) <= exe_sections [ i + 1 ] . rva || offdiff >= exe_sections [ i + 1 ] . rva + exe_sections [ i + 1 ] . raw - 4 ) { cli_dbgmsg ( ""MEW:<S2SV_blank>ESI<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>proper<S2SV_blank>section\\n"" ) ; break ; } offdiff -= exe_sections [ i + 1 ] . rva ; if ( ! exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""MEW:<S2SV_blank>mew<S2SV_blank>section<S2SV_blank>is<S2SV_blank>empty\\n"" ) ; break ; } ssize = exe_sections [ i + 1 ] . vsz ; dsize = exe_sections [ i ] . vsz ; cli_dbgmsg ( ""MEW:<S2SV_blank>ssize<S2SV_blank>%08x<S2SV_blank>dsize<S2SV_blank>%08x<S2SV_blank>offdiff:<S2SV_blank>%08x\\n"" , ssize , dsize , offdiff ) ; CLI_UNPSIZELIMITS ( ""MEW"" , MAX ( ssize , dsize ) ) ; CLI_UNPSIZELIMITS ( ""MEW"" , MAX ( ssize + dsize , exe_sections [ i + 1 ] . rsz ) ) ; if ( exe_sections [ i + 1 ] . rsz < offdiff + 12 || exe_sections [ i + 1 ] . rsz > ssize ) { cli_dbgmsg ( ""MEW:<S2SV_blank>Size<S2SV_blank>mismatch:<S2SV_blank>%08x\\n"" , exe_sections [ i + 1 ] . rsz ) ; break ; } if ( ! ( src = cli_calloc ( ssize + dsize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( bytes = fmap_readn ( map , src + dsize , exe_sections [ i + 1 ] . raw , exe_sections [ i + 1 ] . rsz ) ) != exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""MEW:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>[read:<S2SV_blank>%lu]\\n"" , exe_sections [ i + 1 ] . rsz , ( unsigned long ) bytes ) ; free ( exe_sections ) ; free ( src ) ; return CL_EREAD ; } cli_dbgmsg ( ""MEW:<S2SV_blank>%u<S2SV_blank>(%08x)<S2SV_blank>bytes<S2SV_blank>read\\n"" , ( unsigned int ) bytes , ( unsigned int ) bytes ) ; if ( tbuff [ 0x7b ] == '\\xe8' ) { if ( ! CLI_ISCONTAINED ( exe_sections [ 1 ] . rva , exe_sections [ 1 ] . vsz , cli_readint32 ( tbuff + 0x7c ) + fileoffset + 0x80 , 4 ) ) { cli_dbgmsg ( ""MEW:<S2SV_blank>lzma<S2SV_blank>proc<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds!\\n"" ) ; free ( src ) ; break ; } uselzma = cli_readint32 ( tbuff + 0x7c ) - ( exe_sections [ 0 ] . rva - fileoffset - 0x80 ) ; } else { uselzma = 0 ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""MEW"" ) ; # endif CLI_UNPTEMP ( ""MEW"" , ( src , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""MEW"" , ( unmew11 ( src , offdiff , ssize , dsize , EC32 ( optional_hdr32 . ImageBase ) , exe_sections [ 0 ] . rva , uselzma , ndesc ) ) , 1 , ( src , 0 ) ) ; break ; } } if ( epsize < 168 ) { free ( exe_sections ) ; return CL_CLEAN ; } if ( found || upack ) { while ( ( ( upack && nsections == 3 ) && ( ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > min && epbuff [ 5 ] == '\\xad' && epbuff [ 6 ] == '\\x50' ) || ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > min && epbuff [ 5 ] == '\\xff' && epbuff [ 6 ] == '\\x36' ) ) ) || ( ( ! upack && nsections == 2 ) && ( ( epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xe8' && cli_readint32 ( epbuff + 2 ) == 0x9 ) || ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > 0 && epbuff [ 5 ] == '\\xad' && epbuff [ 6 ] == '\\x8b' && epbuff [ 7 ] == '\\xf8' ) ) ) ) { uint32_t vma , off ; int a , b , c ; cli_dbgmsg ( ""Upack<S2SV_blank>characteristics<S2SV_blank>found.\\n"" ) ; a = exe_sections [ 0 ] . vsz ; b = exe_sections [ 1 ] . vsz ; if ( upack ) { cli_dbgmsg ( ""Upack:<S2SV_blank>var<S2SV_blank>set\\n"" ) ; c = exe_sections [ 2 ] . vsz ; ssize = exe_sections [ 0 ] . ursz + exe_sections [ 0 ] . uraw ; off = exe_sections [ 0 ] . rva ; vma = EC32 ( optional_hdr32 . ImageBase ) + exe_sections [ 0 ] . rva ; } else { cli_dbgmsg ( ""Upack:<S2SV_blank>var<S2SV_blank>NOT<S2SV_blank>set\\n"" ) ; c = exe_sections [ 1 ] . rva ; ssize = exe_sections [ 1 ] . uraw ; off = 0 ; vma = exe_sections [ 1 ] . rva - exe_sections [ 1 ] . uraw ; } dsize = a + b + c ; CLI_UNPSIZELIMITS ( ""Upack"" , MAX ( MAX ( dsize , ssize ) , exe_sections [ 1 ] . ursz ) ) ; if ( ! CLI_ISCONTAINED ( 0 , dsize , exe_sections [ 1 ] . rva - off , exe_sections [ 1 ] . ursz ) || ( upack && ! CLI_ISCONTAINED ( 0 , dsize , exe_sections [ 2 ] . rva - exe_sections [ 0 ] . rva , ssize ) ) || ssize > dsize ) { cli_dbgmsg ( ""Upack:<S2SV_blank>probably<S2SV_blank>malformed<S2SV_blank>pe-header,<S2SV_blank>skipping<S2SV_blank>to<S2SV_blank>next<S2SV_blank>unpacker\\n"" ) ; break ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( unsigned int ) fmap_readn ( map , dest , 0 , ssize ) != ssize ) { cli_dbgmsg ( ""Upack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>0\\n"" ) ; free ( dest ) ; break ; } if ( upack ) memmove ( dest + exe_sections [ 2 ] . rva - exe_sections [ 0 ] . rva , dest , ssize ) ; if ( ( unsigned int ) fmap_readn ( map , dest + exe_sections [ 1 ] . rva - off , exe_sections [ 1 ] . uraw , exe_sections [ 1 ] . ursz ) != exe_sections [ 1 ] . ursz ) { cli_dbgmsg ( ""Upack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>1\\n"" ) ; free ( dest ) ; break ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Upack"" ) ; # endif CLI_UNPTEMP ( ""Upack"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Upack"" , ( unupack ( upack , dest , dsize , epbuff , vma , ep , EC32 ( optional_hdr32 . ImageBase ) , exe_sections [ 0 ] . rva , ndesc ) ) , 1 , ( dest , 0 ) ) ; break ; } } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\x87' && epbuff [ 1 ] == '\\x25' ) { const char * dst ; uint32_t newesi , newedi , newebx , newedx ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } newedx = cli_readint32 ( epbuff + 2 ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newedx , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>xchg<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>(%x),<S2SV_blank>giving<S2SV_blank>up\\n"" , newedx ) ; break ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i + 1 ) ; free ( exe_sections ) ; return CL_ESEEK ; } dst = src + newedx - exe_sections [ i + 1 ] . rva ; if ( newedx < exe_sections [ i + 1 ] . rva || ! CLI_ISCONTAINED ( src , ssize , dst , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>ESP<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedx = cli_readint32 ( dst ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newedx , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>ESP<S2SV_blank>(%x)<S2SV_blank>is<S2SV_blank>wrong\\n"" , newedx ) ; break ; } dst = src + newedx - exe_sections [ i + 1 ] . rva ; if ( ! CLI_ISCONTAINED ( src , ssize , dst , 32 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>stack<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedi = cli_readint32 ( dst ) - EC32 ( optional_hdr32 . ImageBase ) ; newesi = cli_readint32 ( dst + 4 ) - EC32 ( optional_hdr32 . ImageBase ) ; newebx = cli_readint32 ( dst + 16 ) - EC32 ( optional_hdr32 . ImageBase ) ; newedx = cli_readint32 ( dst + 20 ) ; if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>buffer<S2SV_blank>(edi<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newebx , 16 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Array<S2SV_blank>of<S2SV_blank>functions<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedx = cli_readint32 ( newebx + 12 - exe_sections [ i + 1 ] . rva + src ) - EC32 ( optional_hdr32 . ImageBase ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , newedx ) ; if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG2 ( ""FSG"" , ( unfsg_200 ( newesi - exe_sections [ i + 1 ] . rva + src , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , newedi , EC32 ( optional_hdr32 . ImageBase ) , newedx , ndesc ) ) , 1 , ( dest , 0 ) ) ; break ; } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min ) { int sectcnt = 0 ; const char * support ; uint32_t newesi , newedi , oldep , gp , t ; struct cli_exe_section * sections ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } if ( ! ( t = cli_rawaddr ( cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) , NULL , 0 , & err , fsize , hdr_size ) ) && err ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Support<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>padding<S2SV_blank>area\\n"" ) ; break ; } gp = exe_sections [ i + 1 ] . raw - t ; CLI_UNPSIZELIMITS ( ""FSG"" , gp ) ; if ( ! ( support = fmap_need_off_once ( map , t , gp ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>padding<S2SV_blank>area\\n"" , gp ) ; free ( exe_sections ) ; return CL_EREAD ; } newedi = cli_readint32 ( support + 4 ) - EC32 ( optional_hdr32 . ImageBase ) ; newesi = cli_readint32 ( support + 8 ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>(is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } for ( t = 12 ; t < gp - 4 ; t += 4 ) { uint32_t rva = cli_readint32 ( support + t ) ; if ( ! rva ) break ; rva -= EC32 ( optional_hdr32 . ImageBase ) + 1 ; sectcnt ++ ; if ( rva % 0x1000 ) cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>misaligned\\n"" , sectcnt ) ; if ( rva < exe_sections [ i ] . rva || rva - exe_sections [ i ] . rva >= exe_sections [ i ] . vsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" , sectcnt ) ; break ; } } if ( t >= gp - 4 || cli_readint32 ( support + t ) ) { break ; } if ( ( sections = ( struct cli_exe_section * ) cli_malloc ( ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ) == NULL ) { cli_errmsg ( ""FSG:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>sections<S2SV_blank>%lu\\n"" , ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ; free ( exe_sections ) ; return CL_EMEM ; } sections [ 0 ] . rva = newedi ; for ( t = 1 ; t <= ( uint32_t ) sectcnt ; t ++ ) sections [ t ] . rva = cli_readint32 ( support + 8 + t * 4 ) - 1 - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i ) ; free ( exe_sections ) ; free ( sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; free ( sections ) ; return CL_EMEM ; } oldep = vep + 161 + 6 + cli_readint32 ( epbuff + 163 ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , oldep ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , sections , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG1 ( ""FSG"" , ( unfsg_133 ( src + newesi - exe_sections [ i + 1 ] . rva , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , sections , sectcnt , EC32 ( optional_hdr32 . ImageBase ) , oldep , ndesc ) ) , 1 , ( dest , sections , 0 ) ) ; break ; } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\xbb' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min && epbuff [ 5 ] == '\\xbf' && epbuff [ 10 ] == '\\xbe' && vep >= exe_sections [ i + 1 ] . rva && vep - exe_sections [ i + 1 ] . rva > exe_sections [ i + 1 ] . rva - 0xe0 ) { int sectcnt = 0 ; uint32_t gp , t = cli_rawaddr ( cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) , NULL , 0 , & err , fsize , hdr_size ) ; const char * support ; uint32_t newesi = cli_readint32 ( epbuff + 11 ) - EC32 ( optional_hdr32 . ImageBase ) ; uint32_t newedi = cli_readint32 ( epbuff + 6 ) - EC32 ( optional_hdr32 . ImageBase ) ; uint32_t oldep = vep - exe_sections [ i + 1 ] . rva ; struct cli_exe_section * sections ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; if ( err ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Support<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>padding<S2SV_blank>area\\n"" ) ; break ; } if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . raw ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>(is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } gp = exe_sections [ i + 1 ] . raw - t ; CLI_UNPSIZELIMITS ( ""FSG"" , gp ) if ( ! ( support = fmap_need_off_once ( map , t , gp ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>padding<S2SV_blank>area\\n"" , gp ) ; free ( exe_sections ) ; return CL_EREAD ; } for ( t = 0 ; t < gp - 2 ; t += 2 ) { uint32_t rva = support [ t ] | ( support [ t + 1 ] << 8 ) ; if ( rva == 2 || rva == 1 ) break ; rva = ( ( rva - 2 ) << 12 ) - EC32 ( optional_hdr32 . ImageBase ) ; sectcnt ++ ; if ( rva < exe_sections [ i ] . rva || rva - exe_sections [ i ] . rva >= exe_sections [ i ] . vsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" , sectcnt ) ; break ; } } if ( t >= gp - 10 || cli_readint32 ( support + t + 6 ) != 2 ) { break ; } if ( ( sections = ( struct cli_exe_section * ) cli_malloc ( ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ) == NULL ) { cli_errmsg ( ""FSG:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>sections<S2SV_blank>%lu\\n"" , ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ; free ( exe_sections ) ; return CL_EMEM ; } sections [ 0 ] . rva = newedi ; for ( t = 0 ; t <= ( uint32_t ) sectcnt - 1 ; t ++ ) { sections [ t + 1 ] . rva = ( ( ( support [ t * 2 ] | ( support [ t * 2 + 1 ] << 8 ) ) - 2 ) << 12 ) - EC32 ( optional_hdr32 . ImageBase ) ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i ) ; free ( exe_sections ) ; free ( sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; free ( sections ) ; return CL_EMEM ; } gp = 0xda + 6 * ( epbuff [ 16 ] == '\\xe8' ) ; oldep = vep + gp + 6 + cli_readint32 ( src + gp + 2 + oldep ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , oldep ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , sections , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG1 ( ""FSG"" , ( unfsg_133 ( src + newesi - exe_sections [ i + 1 ] . rva , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , sections , sectcnt , EC32 ( optional_hdr32 . ImageBase ) , oldep , ndesc ) ) , 1 , ( dest , sections , 0 ) ) ; break ; } if ( found && ( DCONF & PE_CONF_UPX ) ) { ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz + exe_sections [ i + 1 ] . vsz ; CLI_UNPSIZELIMITS ( ""UPX"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>or<S2SV_blank>dsize<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i + 1 ) ; free ( exe_sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize + 8192 , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } if ( cli_memstr ( UPX_NRV2B , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2B , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2B<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2b ; } else if ( cli_memstr ( UPX_NRV2D , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2D , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2D<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2d ; } else if ( cli_memstr ( UPX_NRV2E , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2E , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2E<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2e ; } if ( upxfn ) { int skew = cli_readint32 ( epbuff + 2 ) - EC32 ( optional_hdr32 . ImageBase ) - exe_sections [ i + 1 ] . rva ; if ( epbuff [ 1 ] != '\\xbe' || skew <= 0 || skew > 0xfff ) { skew = 0 ; } else if ( ( unsigned int ) skew > ssize ) { skew = 0 ; } else { cli_dbgmsg ( ""UPX:<S2SV_blank>UPX1<S2SV_blank>seems<S2SV_blank>skewed<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>bytes\\n"" , skew ) ; } if ( upxfn ( src + skew , ssize - skew , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - skew ) >= 0 ) { upx_success = 1 ; } else if ( skew && ( upxfn ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ) ) { upx_success = 1 ; } if ( upx_success ) cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed\\n"" ) ; else cli_dbgmsg ( ""UPX:<S2SV_blank>Preferred<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } if ( ! upx_success && upxfn != upx_inflate2b ) { if ( upx_inflate2b ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2b ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2B<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2B\\n"" ) ; } } if ( ! upx_success && upxfn != upx_inflate2d ) { if ( upx_inflate2d ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2d ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2D<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2D\\n"" ) ; } } if ( ! upx_success && upxfn != upx_inflate2e ) { if ( upx_inflate2e ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2e ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2E<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2E\\n"" ) ; } } if ( cli_memstr ( UPX_LZMA2 , 20 , epbuff + 0x2f , 20 ) ) { uint32_t strictdsize = cli_readint32 ( epbuff + 0x21 ) , skew = 0 ; if ( ssize > 0x15 && epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xbe' ) { skew = cli_readint32 ( epbuff + 2 ) - exe_sections [ i + 1 ] . rva - optional_hdr32 . ImageBase ; if ( skew != 0x15 ) skew = 0 ; } if ( strictdsize <= dsize ) upx_success = upx_inflatelzma ( src + skew , ssize - skew , dest , & strictdsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ; } else if ( cli_memstr ( UPX_LZMA1 , 20 , epbuff + 0x39 , 20 ) ) { uint32_t strictdsize = cli_readint32 ( epbuff + 0x2b ) , skew = 0 ; if ( ssize > 0x15 && epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xbe' ) { skew = cli_readint32 ( epbuff + 2 ) - exe_sections [ i + 1 ] . rva - optional_hdr32 . ImageBase ; if ( skew != 0x15 ) skew = 0 ; } if ( strictdsize <= dsize ) upx_success = upx_inflatelzma ( src + skew , ssize - skew , dest , & strictdsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ; } if ( ! upx_success ) { cli_dbgmsg ( ""UPX:<S2SV_blank>All<S2SV_blank>decompressors<S2SV_blank>failed\\n"" ) ; free ( dest ) ; } } if ( upx_success ) { free ( exe_sections ) ; CLI_UNPTEMP ( ""UPX/FSG"" , ( dest , 0 ) ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""UPX"" ) ; # endif if ( ( unsigned int ) write ( ndesc , dest , dsize ) != dsize ) { cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>Can\'t<S2SV_blank>write<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dsize ) ; free ( tempfile ) ; free ( dest ) ; close ( ndesc ) ; return CL_EWRITE ; } free ( dest ) ; if ( lseek ( ndesc , 0 , SEEK_SET ) == - 1 ) { cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>lseek()<S2SV_blank>failed\\n"" ) ; close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; SHA_RESET ; return CL_ESEEK ; } if ( ctx -> engine -> keeptmp ) cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>Decompressed<S2SV_blank>data<S2SV_blank>saved<S2SV_blank>in<S2SV_blank>%s\\n"" , tempfile ) ; cli_dbgmsg ( ""*****<S2SV_blank>Scanning<S2SV_blank>decompressed<S2SV_blank>file<S2SV_blank>*****\\n"" ) ; SHA_OFF ; if ( ( ret = cli_magic_scandesc ( ndesc , ctx ) ) == CL_VIRUS ) { close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; SHA_RESET ; return CL_VIRUS ; } SHA_RESET ; close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; return ret ; } if ( epsize < 200 ) { free ( exe_sections ) ; return CL_CLEAN ; } found = 2 ; if ( epbuff [ 0 ] != '\\xb8' || ( uint32_t ) cli_readint32 ( epbuff + 1 ) != exe_sections [ nsections - 1 ] . rva + EC32 ( optional_hdr32 . ImageBase ) ) { if ( nsections < 2 || epbuff [ 0 ] != '\\xb8' || ( uint32_t ) cli_readint32 ( epbuff + 1 ) != exe_sections [ nsections - 2 ] . rva + EC32 ( optional_hdr32 . ImageBase ) ) found = 0 ; else found = 1 ; } if ( found && ( DCONF & PE_CONF_PETITE ) ) { cli_dbgmsg ( ""Petite:<S2SV_blank>v2.%d<S2SV_blank>compression<S2SV_blank>detected\\n"" , found ) ; if ( cli_readint32 ( epbuff + 0x80 ) == 0x163c988d ) { cli_dbgmsg ( ""Petite:<S2SV_blank>level<S2SV_blank>zero<S2SV_blank>compression<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet\\n"" ) ; } else { dsize = max - min ; CLI_UNPSIZELIMITS ( ""Petite"" , dsize ) ; if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { cli_dbgmsg ( ""Petite:<S2SV_blank>Can\'t<S2SV_blank>allocate<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dsize ) ; free ( exe_sections ) ; return CL_EMEM ; } for ( i = 0 ; i < nsections ; i ++ ) { if ( exe_sections [ i ] . raw ) { if ( ! exe_sections [ i ] . rsz || ( unsigned int ) fmap_readn ( map , dest + exe_sections [ i ] . rva - min , exe_sections [ i ] . raw , exe_sections [ i ] . ursz ) != exe_sections [ i ] . ursz ) { free ( exe_sections ) ; free ( dest ) ; return CL_CLEAN ; } } } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Petite"" ) ; # endif CLI_UNPTEMP ( ""Petite"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Petite"" , ( petite_inflate2x_1to9 ( dest , min , max - min , exe_sections , nsections - ( found == 1 ? 1 : 0 ) , EC32 ( optional_hdr32 . ImageBase ) , vep , ndesc , found , EC32 ( optional_hdr32 . DataDirectory [ 2 ] . VirtualAddress ) , EC32 ( optional_hdr32 . DataDirectory [ 2 ] . Size ) ) ) , 0 , ( dest , 0 ) ) ; } } if ( ( DCONF & PE_CONF_PESPIN ) && nsections > 1 && vep >= exe_sections [ nsections - 1 ] . rva && vep < exe_sections [ nsections - 1 ] . rva + exe_sections [ nsections - 1 ] . rsz - 0x3217 - 4 && memcmp ( epbuff + 4 , ""\\xe8\\x00\\x00\\x00\\x00\\x8b\\x1c\\x24\\x83\\xc3"" , 10 ) == 0 ) { char * spinned ; CLI_UNPSIZELIMITS ( ""PEspin"" , fsize ) ; if ( ( spinned = ( char * ) cli_malloc ( fsize ) ) == NULL ) { cli_errmsg ( ""PESping:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>spinned<S2SV_blank>%lu\\n"" , ( unsigned long ) fsize ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , spinned , 0 , fsize ) != fsize ) { cli_dbgmsg ( ""PESpin:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) fsize ) ; free ( spinned ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""PEspin"" ) ; # endif CLI_UNPTEMP ( ""PESpin"" , ( spinned , exe_sections , 0 ) ) ; CLI_UNPRESULTS_ ( ""PEspin"" , SPINCASE ( ) , ( unspin ( spinned , fsize , exe_sections , nsections - 1 , vep , ndesc , ctx ) ) , 0 , ( spinned , 0 ) ) ; } if ( ( DCONF & PE_CONF_YC ) && nsections > 1 && ( EC32 ( optional_hdr32 . AddressOfEntryPoint ) == exe_sections [ nsections - 1 ] . rva + 0x60 ) ) { uint32_t ecx = 0 ; int16_t offset ; if ( ! memcmp ( epbuff , ""\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED"" , 15 ) && ! memcmp ( epbuff + 0x26 , ""\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC"" , 13 ) && ( ( uint8_t ) epbuff [ 0x13 ] == 0xB9 ) && ( ( uint16_t ) ( cli_readint16 ( epbuff + 0x18 ) ) == 0xE981 ) && ! memcmp ( epbuff + 0x1e , ""\\x8B\\xD5\\x81\\xC2"" , 4 ) ) { offset = 0 ; if ( 0x6c - cli_readint32 ( epbuff + 0xf ) + cli_readint32 ( epbuff + 0x22 ) == 0xC6 ) ecx = cli_readint32 ( epbuff + 0x14 ) - cli_readint32 ( epbuff + 0x1a ) ; } if ( ! ecx && ! memcmp ( epbuff , ""\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57"" , 9 ) && ! memcmp ( epbuff + 0x17 , ""\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed"" , 8 ) && ( ( uint8_t ) epbuff [ 0x23 ] == 0xB9 ) ) { offset = 0x10 ; if ( 0x6c - cli_readint32 ( epbuff + 0x1f ) + cli_readint32 ( epbuff + 0x32 ) == 0xC6 ) ecx = cli_readint32 ( epbuff + 0x24 ) - cli_readint32 ( epbuff + 0x2a ) ; } if ( ! ecx && ! memcmp ( epbuff , ""\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed"" , 9 ) && ( ( uint8_t ) epbuff [ 0xd ] == 0xb9 ) && ( ( uint16_t ) cli_readint16 ( epbuff + 0x12 ) == 0xbd8d ) && ! memcmp ( epbuff + 0x18 , ""\\x8b\\xf7\\xac"" , 3 ) ) { offset = - 0x18 ; if ( 0x66 - cli_readint32 ( epbuff + 0x9 ) + cli_readint32 ( epbuff + 0x14 ) == 0xae ) ecx = cli_readint32 ( epbuff + 0xe ) ; } if ( ecx > 0x800 && ecx < 0x2000 && ! memcmp ( epbuff + 0x63 + offset , ""\\xaa\\xe2\\xcc"" , 3 ) && ( fsize >= exe_sections [ nsections - 1 ] . raw + 0xC6 + ecx + offset ) ) { char * spinned ; if ( ( spinned = ( char * ) cli_malloc ( fsize ) ) == NULL ) { cli_errmsg ( ""yC:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>spinned<S2SV_blank>%lu\\n"" , ( unsigned long ) fsize ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , spinned , 0 , fsize ) != fsize ) { cli_dbgmsg ( ""yC:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) fsize ) ; free ( spinned ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""yC"" ) ; # endif cli_dbgmsg ( ""%d,%d,%d,%d\\n"" , nsections - 1 , e_lfanew , ecx , offset ) ; CLI_UNPTEMP ( ""yC"" , ( spinned , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""yC"" , ( yc_decrypt ( spinned , fsize , exe_sections , nsections - 1 , e_lfanew , ndesc , ecx , offset ) ) , 0 , ( spinned , 0 ) ) ; } } while ( ( DCONF & PE_CONF_WWPACK ) && nsections > 1 && vep == exe_sections [ nsections - 1 ] . rva && memcmp ( epbuff , ""\\x53\\x55\\x8b\\xe8\\x33\\xdb\\xeb"" , 7 ) == 0 && memcmp ( epbuff + 0x68 , ""\\xe8\\x00\\x00\\x00\\x00\\x58\\x2d\\x6d\\x00\\x00\\x00\\x50\\x60\\x33\\xc9\\x50\\x58\\x50\\x50"" , 19 ) == 0 ) { uint32_t head = exe_sections [ nsections - 1 ] . raw ; uint8_t * packer ; char * src ; ssize = 0 ; for ( i = 0 ; ; i ++ ) { if ( exe_sections [ i ] . raw < head ) head = exe_sections [ i ] . raw ; if ( i + 1 == nsections ) break ; if ( ssize < exe_sections [ i ] . rva + exe_sections [ i ] . vsz ) ssize = exe_sections [ i ] . rva + exe_sections [ i ] . vsz ; } if ( ! head || ! ssize || head > ssize ) break ; CLI_UNPSIZELIMITS ( ""WWPack"" , ssize ) ; if ( ! ( src = ( char * ) cli_calloc ( ssize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , src , 0 , head ) != head ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>headers\\n"" , head ) ; free ( src ) ; free ( exe_sections ) ; return CL_EREAD ; } for ( i = 0 ; i < ( unsigned int ) nsections - 1 ; i ++ ) { if ( ! exe_sections [ i ] . rsz ) continue ; if ( ! CLI_ISCONTAINED ( src , ssize , src + exe_sections [ i ] . rva , exe_sections [ i ] . rsz ) ) break ; if ( ( unsigned int ) fmap_readn ( map , src + exe_sections [ i ] . rva , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) != exe_sections [ i ] . rsz ) break ; } if ( i + 1 != nsections ) { cli_dbgmsg ( ""WWpack:<S2SV_blank>Probably<S2SV_blank>hacked/damaged<S2SV_blank>file.\\n"" ) ; free ( src ) ; break ; } if ( ( packer = ( uint8_t * ) cli_calloc ( exe_sections [ nsections - 1 ] . rsz , sizeof ( char ) ) ) == NULL ) { free ( src ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ! exe_sections [ nsections - 1 ] . rsz || ( size_t ) fmap_readn ( map , packer , exe_sections [ nsections - 1 ] . raw , exe_sections [ nsections - 1 ] . rsz ) != exe_sections [ nsections - 1 ] . rsz ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>wwpack<S2SV_blank>sect\\n"" , exe_sections [ nsections - 1 ] . rsz ) ; free ( src ) ; free ( packer ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""WWPack"" ) ; # endif CLI_UNPTEMP ( ""WWPack"" , ( src , packer , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""WWPack"" , ( wwunpack ( ( uint8_t * ) src , ssize , packer , exe_sections , nsections - 1 , e_lfanew , ndesc ) ) , 0 , ( src , packer , 0 ) ) ; break ; } while ( ( DCONF & PE_CONF_ASPACK ) && ep + 58 + 0x70e < fsize && ! memcmp ( epbuff , ""\\x60\\xe8\\x03\\x00\\x00\\x00\\xe9\\xeb"" , 8 ) ) { char * src ; if ( epsize < 0x3bf || memcmp ( epbuff + 0x3b9 , ""\\x68\\x00\\x00\\x00\\x00\\xc3"" , 6 ) ) break ; ssize = 0 ; for ( i = 0 ; i < nsections ; i ++ ) if ( ssize < exe_sections [ i ] . rva + exe_sections [ i ] . vsz ) ssize = exe_sections [ i ] . rva + exe_sections [ i ] . vsz ; if ( ! ssize ) break ; CLI_UNPSIZELIMITS ( ""Aspack"" , ssize ) ; if ( ! ( src = ( char * ) cli_calloc ( ssize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } for ( i = 0 ; i < ( unsigned int ) nsections ; i ++ ) { if ( ! exe_sections [ i ] . rsz ) continue ; if ( ! CLI_ISCONTAINED ( src , ssize , src + exe_sections [ i ] . rva , exe_sections [ i ] . rsz ) ) break ; if ( ( unsigned int ) fmap_readn ( map , src + exe_sections [ i ] . rva , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) != exe_sections [ i ] . rsz ) break ; } if ( i != nsections ) { cli_dbgmsg ( ""Aspack:<S2SV_blank>Probably<S2SV_blank>hacked/damaged<S2SV_blank>Aspack<S2SV_blank>file.\\n"" ) ; free ( src ) ; break ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Aspack"" ) ; # endif CLI_UNPTEMP ( ""Aspack"" , ( src , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Aspack"" , ( unaspack212 ( ( uint8_t * ) src , ssize , exe_sections , nsections , vep - 1 , EC32 ( optional_hdr32 . ImageBase ) , ndesc ) ) , 1 , ( src , 0 ) ) ; break ; } while ( DCONF & PE_CONF_NSPACK ) { uint32_t eprva = vep ; uint32_t start_of_stuff , rep = ep ; unsigned int nowinldr ; const char * nbuff ; src = epbuff ; if ( * epbuff == '\\xe9' ) { eprva = cli_readint32 ( epbuff + 1 ) + vep + 5 ; if ( ! ( rep = cli_rawaddr ( eprva , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) break ; if ( ! ( nbuff = fmap_need_off_once ( map , rep , 24 ) ) ) break ; src = nbuff ; } if ( memcmp ( src , ""\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00"" , 13 ) ) break ; nowinldr = 0x54 - cli_readint32 ( src + 17 ) ; cli_dbgmsg ( ""NsPack:<S2SV_blank>Found<S2SV_blank>*start_of_stuff<S2SV_blank>@delta-%x\\n"" , nowinldr ) ; if ( ! ( nbuff = fmap_need_off_once ( map , rep - nowinldr , 4 ) ) ) break ; start_of_stuff = rep + cli_readint32 ( nbuff ) ; if ( ! ( nbuff = fmap_need_off_once ( map , start_of_stuff , 20 ) ) ) break ; src = nbuff ; if ( ! cli_readint32 ( nbuff ) ) { start_of_stuff += 4 ; src += 4 ; } ssize = cli_readint32 ( src + 5 ) | 0xff ; dsize = cli_readint32 ( src + 9 ) ; CLI_UNPSIZELIMITS ( ""NsPack"" , MAX ( ssize , dsize ) ) ; if ( ! ssize || ! dsize || dsize != exe_sections [ 0 ] . vsz ) break ; if ( ! ( dest = cli_malloc ( dsize ) ) ) { cli_errmsg ( ""NsPack:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>dest<S2SV_blank>%u\\n"" , dsize ) ; break ; } if ( ! ( src = fmap_need_off ( map , start_of_stuff , ssize ) ) ) { free ( dest ) ; break ; } eprva += 0x27a ; if ( ! ( rep = cli_rawaddr ( eprva , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) { free ( dest ) ; break ; } if ( ! ( nbuff = fmap_need_off_once ( map , rep , 5 ) ) ) { free ( dest ) ; break ; } fmap_unneed_off ( map , start_of_stuff , ssize ) ; eprva = eprva + 5 + cli_readint32 ( nbuff + 1 ) ; cli_dbgmsg ( ""NsPack:<S2SV_blank>OEP<S2SV_blank>=<S2SV_blank>%08x\\n"" , eprva ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""NsPack"" ) ; # endif CLI_UNPTEMP ( ""NsPack"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""NsPack"" , ( unspack ( src , dest , ctx , exe_sections [ 0 ] . rva , EC32 ( optional_hdr32 . ImageBase ) , eprva , ndesc ) ) , 0 , ( dest , 0 ) ) ; break ; } ctx -> corrupted_input = corrupted_cur ; bc_ctx = cli_bytecode_context_alloc ( ) ; if ( ! bc_ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>bc_ctx\\n"" ) ; return CL_EMEM ; } cli_bytecode_context_setpe ( bc_ctx , & pedata , exe_sections ) ; cli_bytecode_context_setctx ( bc_ctx , ctx ) ; ret = cli_bytecode_runhook ( ctx , ctx -> engine , bc_ctx , BC_PE_UNPACKER , map ) ; switch ( ret ) { case CL_VIRUS : free ( exe_sections ) ; cli_bytecode_context_destroy ( bc_ctx ) ; return CL_VIRUS ; case CL_SUCCESS : ndesc = cli_bytecode_context_getresult_file ( bc_ctx , & tempfile ) ; cli_bytecode_context_destroy ( bc_ctx ) ; if ( ndesc != - 1 && tempfile ) { CLI_UNPRESULTS ( ""bytecode<S2SV_blank>PE<S2SV_blank>hook"" , 1 , 1 , ( 0 ) ) ; } break ; default : cli_bytecode_context_destroy ( bc_ctx ) ; } free ( exe_sections ) ; # if HAVE_JSON if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } # endif if ( SCAN_ALL && viruses_found ) return CL_VIRUS ; return CL_CLEAN ; }","# endif for ( i = 0 ;strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ;sname [ 8 ] = 0 ;",1674
684,"buggy line: cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>free<S2SV_blank>space\\\}}if ( exe_sections [ i ] . chr & 0x20000000 ) cli_dbgmsg ( ""Section\\\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>executable\\\if ( exe_sections [ i ] . chr & 0x80000000 ) cli_dbgmsg ( ""Section\\\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>writeable\\\if ( DETECT_BROKEN_PE && ( ! valign || ( exe_sections [ i ] . urva % valign ) ) ) {cli_dbgmsg ( ""VirtualAddress<S2SV_blank>is<S2SV_blank>misaligned\\\cli_dbgmsg ( ""------------------------------------\\\cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ;free ( section_hdr ) ;free ( exe_sections ) ;return CL_VIRUS ;}if ( exe_sections [ i ] . rsz ) {if ( exe_sections [ i ] . raw >= fsize ) {cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\\cli_dbgmsg ( ""------------------------------------\\\free ( section_hdr ) ;free ( exe_sections ) ;if ( DETECT_BROKEN_PE ) {cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ;return CL_VIRUS ;}return CL_CLEAN ;}cwe id:CWE-119context: int cli_scanpe ( cli_ctx * ctx ) { uint16_t e_magic ; uint16_t nsections ; uint32_t e_lfanew ; uint32_t ep , vep ; uint8_t polipos = 0 ; time_t timestamp ; struct pe_image_file_hdr file_hdr ; union { struct pe_image_optional_hdr64 opt64 ; struct pe_image_optional_hdr32 opt32 ; } pe_opt ; struct pe_image_section_hdr * section_hdr ; char sname [ 9 ] , epbuff [ 4096 ] , * tempfile ; uint32_t epsize ; ssize_t bytes , at ;  unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ;  unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ; int ( * upxfn ) ( const char * , uint32_t , char * , uint32_t * , uint32_t , uint32_t , uint32_t ) = NULL ; const char * src = NULL ; char * dest = NULL ; int ndesc , ret = CL_CLEAN , upack = 0 , native = 0 ; size_t fsize ;  uint32_t valign , falign , hdr_size , j ;  struct cli_exe_section * exe_sections ; char timestr [ 32 ] ; struct pe_image_data_dir * dirs ; struct cli_bc_ctx * bc_ctx ; fmap_t * map ; struct cli_pe_hook_data pedata ; # ifdef HAVE__INTERNAL__SHA_COLLECT int sha_collect = ctx -> sha_collect ; # endif const char * archtype = NULL , * subsystem = NULL ; uint32_t viruses_found = 0 ; # if HAVE_JSON int toval = 0 ; struct json_object * pe_json = NULL ; char jsonbuf [ 128 ] ; # endif if ( ! ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>ctx<S2SV_blank>==<S2SV_blank>NULL\\n"" ) ; return CL_ENULLARG ; } # if HAVE_JSON if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } if ( ctx -> options & CL_SCAN_FILE_PROPERTIES ) { pe_json = get_pe_property ( ctx ) ; } # endif map = * ctx -> fmap ; if ( fmap_readn ( map , & e_magic , 0 , sizeof ( e_magic ) ) != sizeof ( e_magic ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>DOS<S2SV_blank>signature\\n"" ) ; return CL_CLEAN ; } if ( EC16 ( e_magic ) != PE_IMAGE_DOS_SIGNATURE && EC16 ( e_magic ) != PE_IMAGE_DOS_SIGNATURE_OLD ) { cli_dbgmsg ( ""Invalid<S2SV_blank>DOS<S2SV_blank>signature\\n"" ) ; return CL_CLEAN ; } if ( fmap_readn ( map , & e_lfanew , 58 + sizeof ( e_magic ) , sizeof ( e_lfanew ) ) != sizeof ( e_lfanew ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>new<S2SV_blank>header<S2SV_blank>address\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } e_lfanew = EC32 ( e_lfanew ) ; cli_dbgmsg ( ""e_lfanew<S2SV_blank>==<S2SV_blank>%d\\n"" , e_lfanew ) ; if ( ! e_lfanew ) { cli_dbgmsg ( ""Not<S2SV_blank>a<S2SV_blank>PE<S2SV_blank>file\\n"" ) ; return CL_CLEAN ; } if ( fmap_readn ( map , & file_hdr , e_lfanew , sizeof ( struct pe_image_file_hdr ) ) != sizeof ( struct pe_image_file_hdr ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>file<S2SV_blank>header\\n"" ) ; return CL_CLEAN ; } if ( EC32 ( file_hdr . Magic ) != PE_IMAGE_NT_SIGNATURE ) { cli_dbgmsg ( ""Invalid<S2SV_blank>PE<S2SV_blank>signature<S2SV_blank>(probably<S2SV_blank>NE<S2SV_blank>file)\\n"" ) ; return CL_CLEAN ; } if ( EC16 ( file_hdr . Characteristics ) & 0x2000 ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json , ""Type"" , ""DLL"" ) ; # endif cli_dbgmsg ( ""File<S2SV_blank>type:<S2SV_blank>DLL\\n"" ) ; dll = 1 ; } else if ( EC16 ( file_hdr . Characteristics ) & 0x01 ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json , ""Type"" , ""EXE"" ) ; # endif cli_dbgmsg ( ""File<S2SV_blank>type:<S2SV_blank>Executable\\n"" ) ; } switch ( EC16 ( file_hdr . Machine ) ) { case 0x0 : archtype = ""Unknown"" ; break ; case 0x14c : archtype = ""80386"" ; break ; case 0x14d : archtype = ""80486"" ; break ; case 0x14e : archtype = ""80586"" ; break ; case 0x160 : archtype = ""R30000<S2SV_blank>(big-endian)"" ; break ; case 0x162 : archtype = ""R3000"" ; break ; case 0x166 : archtype = ""R4000"" ; break ; case 0x168 : archtype = ""R10000"" ; break ; case 0x184 : archtype = ""DEC<S2SV_blank>Alpha<S2SV_blank>AXP"" ; break ; case 0x284 : archtype = ""DEC<S2SV_blank>Alpha<S2SV_blank>AXP<S2SV_blank>64bit"" ; break ; case 0x1f0 : archtype = ""PowerPC"" ; break ; case 0x200 : archtype = ""IA64"" ; break ; case 0x268 : archtype = ""M68k"" ; break ; case 0x266 : archtype = ""MIPS16"" ; break ; case 0x366 : archtype = ""MIPS+FPU"" ; break ; case 0x466 : archtype = ""MIPS16+FPU"" ; break ; case 0x1a2 : archtype = ""Hitachi<S2SV_blank>SH3"" ; break ; case 0x1a3 : archtype = ""Hitachi<S2SV_blank>SH3-DSP"" ; break ; case 0x1a4 : archtype = ""Hitachi<S2SV_blank>SH3-E"" ; break ; case 0x1a6 : archtype = ""Hitachi<S2SV_blank>SH4"" ; break ; case 0x1a8 : archtype = ""Hitachi<S2SV_blank>SH5"" ; break ; case 0x1c0 : archtype = ""ARM"" ; break ; case 0x1c2 : archtype = ""THUMB"" ; break ; case 0x1d3 : archtype = ""AM33"" ; break ; case 0x520 : archtype = ""Infineon<S2SV_blank>TriCore"" ; break ; case 0xcef : archtype = ""CEF"" ; break ; case 0xebc : archtype = ""EFI<S2SV_blank>Byte<S2SV_blank>Code"" ; break ; case 0x9041 : archtype = ""M32R"" ; break ; case 0xc0ee : archtype = ""CEEE"" ; break ; case 0x8664 : archtype = ""AMD64"" ; break ; default : archtype = ""Unknown"" ; } if ( ( archtype ) ) { cli_dbgmsg ( ""Machine<S2SV_blank>type:<S2SV_blank>%s\\n"" , archtype ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""ArchType"" , archtype ) ; # endif } nsections = EC16 ( file_hdr . NumberOfSections ) ; if ( nsections < 1 || nsections > 96 ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadNumberOfSections"" ) ; # endif if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } if ( ! ctx -> corrupted_input ) { if ( nsections ) cli_warnmsg ( ""PE<S2SV_blank>file<S2SV_blank>contains<S2SV_blank>%d<S2SV_blank>sections\\n"" , nsections ) ; else cli_warnmsg ( ""PE<S2SV_blank>file<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>sections\\n"" ) ; } return CL_CLEAN ; } cli_dbgmsg ( ""NumberOfSections:<S2SV_blank>%d\\n"" , nsections ) ; timestamp = ( time_t ) EC32 ( file_hdr . TimeDateStamp ) ; cli_dbgmsg ( ""TimeDateStamp:<S2SV_blank>%s"" , cli_ctime ( & timestamp , timestr , sizeof ( timestr ) ) ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""TimeDateStamp"" , cli_ctime ( & timestamp , timestr , sizeof ( timestr ) ) ) ; # endif cli_dbgmsg ( ""SizeOfOptionalHeader:<S2SV_blank>%x\\n"" , EC16 ( file_hdr . SizeOfOptionalHeader ) ) ; # if HAVE_JSON cli_jsonint ( pe_json , ""SizeOfOptionalHeader"" , EC16 ( file_hdr . SizeOfOptionalHeader ) ) ; # endif if ( EC16 ( file_hdr . SizeOfOptionalHeader ) < sizeof ( struct pe_image_optional_hdr32 ) ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadOptionalHeaderSize"" ) ; # endif cli_dbgmsg ( ""SizeOfOptionalHeader<S2SV_blank>too<S2SV_blank>small\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at = e_lfanew + sizeof ( struct pe_image_file_hdr ) ; if ( fmap_readn ( map , & optional_hdr32 , at , sizeof ( struct pe_image_optional_hdr32 ) ) != sizeof ( struct pe_image_optional_hdr32 ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>optional<S2SV_blank>file<S2SV_blank>header\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_optional_hdr32 ) ; if ( EC16 ( optional_hdr64 . Magic ) == PE32P_SIGNATURE ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadOptionalHeaderSizePE32Plus"" ) ; # endif if ( EC16 ( file_hdr . SizeOfOptionalHeader ) != sizeof ( struct pe_image_optional_hdr64 ) ) { cli_dbgmsg ( ""Incorrect<S2SV_blank>SizeOfOptionalHeader<S2SV_blank>for<S2SV_blank>PE32+\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } pe_plus = 1 ; } if ( ! pe_plus ) { if ( EC16 ( file_hdr . SizeOfOptionalHeader ) != sizeof ( struct pe_image_optional_hdr32 ) ) { at += EC16 ( file_hdr . SizeOfOptionalHeader ) - sizeof ( struct pe_image_optional_hdr32 ) ; } if ( DCONF & PE_CONF_UPACK ) upack = ( EC16 ( file_hdr . SizeOfOptionalHeader ) == 0x148 ) ; vep = EC32 ( optional_hdr32 . AddressOfEntryPoint ) ; hdr_size = EC32 ( optional_hdr32 . SizeOfHeaders ) ; cli_dbgmsg ( ""File<S2SV_blank>format:<S2SV_blank>PE\\n"" ) ; cli_dbgmsg ( ""MajorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr32 . MajorLinkerVersion ) ; cli_dbgmsg ( ""MinorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr32 . MinorLinkerVersion ) ; cli_dbgmsg ( ""SizeOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfCode ) ) ; cli_dbgmsg ( ""SizeOfInitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfInitializedData ) ) ; cli_dbgmsg ( ""SizeOfUninitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfUninitializedData ) ) ; cli_dbgmsg ( ""AddressOfEntryPoint:<S2SV_blank>0x%x\\n"" , vep ) ; cli_dbgmsg ( ""BaseOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . BaseOfCode ) ) ; cli_dbgmsg ( ""SectionAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SectionAlignment ) ) ; cli_dbgmsg ( ""FileAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . FileAlignment ) ) ; cli_dbgmsg ( ""MajorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr32 . MajorSubsystemVersion ) ) ; cli_dbgmsg ( ""MinorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr32 . MinorSubsystemVersion ) ) ; cli_dbgmsg ( ""SizeOfImage:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfImage ) ) ; cli_dbgmsg ( ""SizeOfHeaders:<S2SV_blank>0x%x\\n"" , hdr_size ) ; cli_dbgmsg ( ""NumberOfRvaAndSizes:<S2SV_blank>%d\\n"" , EC32 ( optional_hdr32 . NumberOfRvaAndSizes ) ) ; dirs = optional_hdr32 . DataDirectory ; # if HAVE_JSON cli_jsonint ( pe_json , ""MajorLinkerVersion"" , optional_hdr32 . MajorLinkerVersion ) ; cli_jsonint ( pe_json , ""MinorLinkerVersion"" , optional_hdr32 . MinorLinkerVersion ) ; cli_jsonint ( pe_json , ""SizeOfCode"" , EC32 ( optional_hdr32 . SizeOfCode ) ) ; cli_jsonint ( pe_json , ""SizeOfInitializedData"" , EC32 ( optional_hdr32 . SizeOfInitializedData ) ) ; cli_jsonint ( pe_json , ""SizeOfUninitializedData"" , EC32 ( optional_hdr32 . SizeOfUninitializedData ) ) ; cli_jsonint ( pe_json , ""NumberOfRvaAndSizes"" , EC32 ( optional_hdr32 . NumberOfRvaAndSizes ) ) ; cli_jsonint ( pe_json , ""MajorSubsystemVersion"" , EC16 ( optional_hdr32 . MajorSubsystemVersion ) ) ; cli_jsonint ( pe_json , ""MinorSubsystemVersion"" , EC16 ( optional_hdr32 . MinorSubsystemVersion ) ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . BaseOfCode ) ) ; cli_jsonstr ( pe_json , ""BaseOfCode"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . SectionAlignment ) ) ; cli_jsonstr ( pe_json , ""SectionAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . FileAlignment ) ) ; cli_jsonstr ( pe_json , ""FileAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . SizeOfImage ) ) ; cli_jsonstr ( pe_json , ""SizeOfImage"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , hdr_size ) ; cli_jsonstr ( pe_json , ""SizeOfHeaders"" , jsonbuf ) ; # endif } else { if ( fmap_readn ( map , & optional_hdr32 + 1 , at , sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ) != sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>optional<S2SV_blank>file<S2SV_blank>header\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ; vep = EC32 ( optional_hdr64 . AddressOfEntryPoint ) ; hdr_size = EC32 ( optional_hdr64 . SizeOfHeaders ) ; cli_dbgmsg ( ""File<S2SV_blank>format:<S2SV_blank>PE32+\\n"" ) ; cli_dbgmsg ( ""MajorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr64 . MajorLinkerVersion ) ; cli_dbgmsg ( ""MinorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr64 . MinorLinkerVersion ) ; cli_dbgmsg ( ""SizeOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfCode ) ) ; cli_dbgmsg ( ""SizeOfInitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfInitializedData ) ) ; cli_dbgmsg ( ""SizeOfUninitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfUninitializedData ) ) ; cli_dbgmsg ( ""AddressOfEntryPoint:<S2SV_blank>0x%x\\n"" , vep ) ; cli_dbgmsg ( ""BaseOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . BaseOfCode ) ) ; cli_dbgmsg ( ""SectionAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SectionAlignment ) ) ; cli_dbgmsg ( ""FileAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . FileAlignment ) ) ; cli_dbgmsg ( ""MajorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr64 . MajorSubsystemVersion ) ) ; cli_dbgmsg ( ""MinorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr64 . MinorSubsystemVersion ) ) ; cli_dbgmsg ( ""SizeOfImage:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfImage ) ) ; cli_dbgmsg ( ""SizeOfHeaders:<S2SV_blank>0x%x\\n"" , hdr_size ) ; cli_dbgmsg ( ""NumberOfRvaAndSizes:<S2SV_blank>%d\\n"" , EC32 ( optional_hdr64 . NumberOfRvaAndSizes ) ) ; dirs = optional_hdr64 . DataDirectory ; # if HAVE_JSON cli_jsonint ( pe_json , ""MajorLinkerVersion"" , optional_hdr64 . MajorLinkerVersion ) ; cli_jsonint ( pe_json , ""MinorLinkerVersion"" , optional_hdr64 . MinorLinkerVersion ) ; cli_jsonint ( pe_json , ""SizeOfCode"" , EC32 ( optional_hdr64 . SizeOfCode ) ) ; cli_jsonint ( pe_json , ""SizeOfInitializedData"" , EC32 ( optional_hdr64 . SizeOfInitializedData ) ) ; cli_jsonint ( pe_json , ""SizeOfUninitializedData"" , EC32 ( optional_hdr64 . SizeOfUninitializedData ) ) ; cli_jsonint ( pe_json , ""NumberOfRvaAndSizes"" , EC32 ( optional_hdr64 . NumberOfRvaAndSizes ) ) ; cli_jsonint ( pe_json , ""MajorSubsystemVersion"" , EC16 ( optional_hdr64 . MajorSubsystemVersion ) ) ; cli_jsonint ( pe_json , ""MinorSubsystemVersion"" , EC16 ( optional_hdr64 . MinorSubsystemVersion ) ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . BaseOfCode ) ) ; cli_jsonstr ( pe_json , ""BaseOfCode"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . SectionAlignment ) ) ; cli_jsonstr ( pe_json , ""SectionAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . FileAlignment ) ) ; cli_jsonstr ( pe_json , ""FileAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . SizeOfImage ) ) ; cli_jsonstr ( pe_json , ""SizeOfImage"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , hdr_size ) ; cli_jsonstr ( pe_json , ""SizeOfHeaders"" , jsonbuf ) ; # endif } # if HAVE_JSON if ( ctx -> options & CL_SCAN_FILE_PROPERTIES ) { snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , vep ) ; cli_jsonstr ( pe_json , ""EntryPoint"" , jsonbuf ) ; } # endif switch ( pe_plus ? EC16 ( optional_hdr64 . Subsystem ) : EC16 ( optional_hdr32 . Subsystem ) ) { case 0 : subsystem = ""Unknown"" ; break ; case 1 : subsystem = ""Native<S2SV_blank>(svc)"" ; native = 1 ; break ; case 2 : subsystem = ""Win32<S2SV_blank>GUI"" ; break ; case 3 : subsystem = ""Win32<S2SV_blank>console"" ; break ; case 5 : subsystem = ""OS/2<S2SV_blank>console"" ; break ; case 7 : subsystem = ""POSIX<S2SV_blank>console"" ; break ; case 8 : subsystem = ""Native<S2SV_blank>Win9x<S2SV_blank>driver"" ; break ; case 9 : subsystem = ""WinCE<S2SV_blank>GUI"" ; break ; case 10 : subsystem = ""EFI<S2SV_blank>application"" ; break ; case 11 : subsystem = ""EFI<S2SV_blank>driver"" ; break ; case 12 : subsystem = ""EFI<S2SV_blank>runtime<S2SV_blank>driver"" ; break ; case 13 : subsystem = ""EFI<S2SV_blank>ROM<S2SV_blank>image"" ; break ; case 14 : subsystem = ""Xbox"" ; break ; case 16 : subsystem = ""Boot<S2SV_blank>application"" ; break ; default : subsystem = ""Unknown"" ; } cli_dbgmsg ( ""Subsystem:<S2SV_blank>%s\\n"" , subsystem ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Subsystem"" , subsystem ) ; # endif cli_dbgmsg ( ""------------------------------------\\n"" ) ; if ( DETECT_BROKEN_PE && ! native && ( ! ( pe_plus ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ) || ( pe_plus ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ) % 0x1000 ) ) { cli_dbgmsg ( ""Bad<S2SV_blank>virtual<S2SV_blank>alignemnt\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } if ( DETECT_BROKEN_PE && ! native && ( ! ( pe_plus ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ) || ( pe_plus ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ) % 0x200 ) ) { cli_dbgmsg ( ""Bad<S2SV_blank>file<S2SV_blank>alignemnt\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } fsize = map -> len ; section_hdr = ( struct pe_image_section_hdr * ) cli_calloc ( nsections , sizeof ( struct pe_image_section_hdr ) ) ; if ( ! section_hdr ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>section<S2SV_blank>headers\\n"" ) ; return CL_EMEM ; } exe_sections = ( struct cli_exe_section * ) cli_calloc ( nsections , sizeof ( struct cli_exe_section ) ) ; if ( ! exe_sections ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>section<S2SV_blank>headers\\n"" ) ; free ( section_hdr ) ; return CL_EMEM ; } valign = ( pe_plus ) ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ; falign = ( pe_plus ) ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ; if ( fmap_readn ( map , section_hdr , at , sizeof ( struct pe_image_section_hdr ) * nsections ) != ( int ) ( nsections * sizeof ( struct pe_image_section_hdr ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>section<S2SV_blank>header\\n"" ) ; cli_dbgmsg ( ""Possibly<S2SV_blank>broken<S2SV_blank>PE<S2SV_blank>file\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_section_hdr ) * nsections ; for ( i = 0 ; falign != 0x200 && i < nsections ; i ++ ) { if ( falign && section_hdr [ i ] . SizeOfRawData && EC32 ( section_hdr [ i ] . PointerToRawData ) % falign && ! ( EC32 ( section_hdr [ i ] . PointerToRawData ) % 0x200 ) ) { cli_dbgmsg ( ""Found<S2SV_blank>misaligned<S2SV_blank>section,<S2SV_blank>using<S2SV_blank>0x200\\n"" ) ; falign = 0x200 ; } } hdr_size = PESALIGN ( hdr_size , valign ) ; # if HAVE_JSON cli_jsonint ( pe_json , ""NumberOfSections"" , nsections ) ; # endif  for ( i = 0 ; i < nsections ; i ++ ) {   strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ;   sname [ 8 ] = 0 ;  exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; # if HAVE_JSON add_section_info ( ctx , & exe_sections [ i ] ) ; if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { free ( section_hdr ) ; free ( exe_sections ) ; return CL_ETIMEOUT ; } # endif if ( ! exe_sections [ i ] . vsz && exe_sections [ i ] . rsz ) exe_sections [ i ] . vsz = PESALIGN ( exe_sections [ i ] . ursz , valign ) ; if ( exe_sections [ i ] . rsz && fsize > exe_sections [ i ] . raw && ! CLI_ISCONTAINED ( 0 , ( uint32_t ) fsize , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) ) exe_sections [ i ] . rsz = fsize - exe_sections [ i ] . raw ; cli_dbgmsg ( ""Section<S2SV_blank>%d\\n"" , i ) ; cli_dbgmsg ( ""Section<S2SV_blank>name:<S2SV_blank>%s\\n"" , sname ) ; cli_dbgmsg ( ""Section<S2SV_blank>data<S2SV_blank>(from<S2SV_blank>headers<S2SV_blank>-<S2SV_blank>in<S2SV_blank>memory)\\n"" ) ; cli_dbgmsg ( ""VirtualSize:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . uvsz , exe_sections [ i ] . vsz ) ; cli_dbgmsg ( ""VirtualAddress:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . urva , exe_sections [ i ] . rva ) ; cli_dbgmsg ( ""SizeOfRawData:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . ursz , exe_sections [ i ] . rsz ) ; cli_dbgmsg ( ""PointerToRawData:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . uraw , exe_sections [ i ] . raw ) ; if ( exe_sections [ i ] . chr & 0x20 ) { cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>executable<S2SV_blank>code\\n"" ) ; if ( exe_sections [ i ] . vsz < exe_sections [ i ] . rsz ) { cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>free<S2SV_blank>space\\n"" ) ; } } if ( exe_sections [ i ] . chr & 0x20000000 ) cli_dbgmsg ( ""Section\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>executable\\n"" ) ; if ( exe_sections [ i ] . chr & 0x80000000 ) cli_dbgmsg ( ""Section\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>writeable\\n"" ) ; if ( DETECT_BROKEN_PE && ( ! valign || ( exe_sections [ i ] . urva % valign ) ) ) { cli_dbgmsg ( ""VirtualAddress<S2SV_blank>is<S2SV_blank>misaligned\\n"" ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } if ( exe_sections [ i ] . rsz ) {  if ( exe_sections [ i ] . raw >= fsize ) {  cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\n"" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } if ( SCAN_ALGO && ( DCONF & PE_CONF_POLIPOS ) && ! * sname && exe_sections [ i ] . vsz > 40000 && exe_sections [ i ] . vsz < 70000 && exe_sections [ i ] . chr == 0xe0000060 ) polipos = i ; if ( ( DCONF & PE_CONF_MD5SECT ) && ctx -> engine -> hm_mdb ) { ret = scan_pe_mdb ( ctx , & exe_sections [ i ] ) ; if ( ret != CL_CLEAN ) { if ( ret != CL_VIRUS ) cli_errmsg ( ""scan_pe:<S2SV_blank>scan_pe_mdb<S2SV_blank>failed:<S2SV_blank>%s!\\n"" , cl_strerror ( ret ) ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return ret ; } } } cli_dbgmsg ( ""------------------------------------\\n"" ) ; if ( exe_sections [ i ] . urva >> 31 || exe_sections [ i ] . uvsz >> 31 || ( exe_sections [ i ] . rsz && exe_sections [ i ] . uraw >> 31 ) || exe_sections [ i ] . ursz >> 31 ) { cli_dbgmsg ( ""Found<S2SV_blank>PE<S2SV_blank>values<S2SV_blank>with<S2SV_blank>sign<S2SV_blank>bit<S2SV_blank>set\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } if ( ! i ) { if ( DETECT_BROKEN_PE && exe_sections [ i ] . urva != hdr_size ) { cli_dbgmsg ( ""First<S2SV_blank>section<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>place\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } min = exe_sections [ i ] . rva ; max = exe_sections [ i ] . rva + exe_sections [ i ] . rsz ; } else { if ( DETECT_BROKEN_PE && exe_sections [ i ] . urva - exe_sections [ i - 1 ] . urva != exe_sections [ i - 1 ] . vsz ) { cli_dbgmsg ( ""Virtually<S2SV_blank>misplaced<S2SV_blank>section<S2SV_blank>(wrong<S2SV_blank>order,<S2SV_blank>overlapping,<S2SV_blank>non<S2SV_blank>contiguous)\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } if ( exe_sections [ i ] . rva < min ) min = exe_sections [ i ] . rva ; if ( exe_sections [ i ] . rva + exe_sections [ i ] . rsz > max ) { max = exe_sections [ i ] . rva + exe_sections [ i ] . rsz ; overlays = exe_sections [ i ] . raw + exe_sections [ i ] . rsz ; } } } free ( section_hdr ) ; if ( ! ( ep = cli_rawaddr ( vep , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) { cli_dbgmsg ( ""EntryPoint<S2SV_blank>out<S2SV_blank>of<S2SV_blank>file\\n"" ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } # if HAVE_JSON cli_jsonint ( pe_json , ""EntryPointOffset"" , ep ) ; if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } # endif cli_dbgmsg ( ""EntryPoint<S2SV_blank>offset:<S2SV_blank>0x%x<S2SV_blank>(%d)\\n"" , ep , ep ) ; if ( pe_plus ) { free ( exe_sections ) ; return CL_CLEAN ; } epsize = fmap_readn ( map , epbuff , ep , 4096 ) ; if ( overlays ) { int overlays_sz = fsize - overlays ; if ( overlays_sz > 0 ) { ret = cli_scanishield ( ctx , overlays , overlays_sz ) ; if ( ret != CL_CLEAN ) { free ( exe_sections ) ; return ret ; } } } pedata . nsections = nsections ; pedata . ep = ep ; pedata . offset = 0 ; memcpy ( & pedata . file_hdr , & file_hdr , sizeof ( file_hdr ) ) ; memcpy ( & pedata . opt32 , & pe_opt . opt32 , sizeof ( pe_opt . opt32 ) ) ; memcpy ( & pedata . opt64 , & pe_opt . opt64 , sizeof ( pe_opt . opt64 ) ) ; memcpy ( & pedata . dirs , dirs , sizeof ( pedata . dirs ) ) ; pedata . e_lfanew = e_lfanew ; pedata . overlays = overlays ; pedata . overlays_sz = fsize - overlays ; pedata . hdr_size = hdr_size ; bc_ctx = cli_bytecode_context_alloc ( ) ; if ( ! bc_ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>bc_ctx\\n"" ) ; free ( exe_sections ) ; return CL_EMEM ; } cli_bytecode_context_setpe ( bc_ctx , & pedata , exe_sections ) ; cli_bytecode_context_setctx ( bc_ctx , ctx ) ; ret = cli_bytecode_runhook ( ctx , ctx -> engine , bc_ctx , BC_PE_ALL , map ) ; switch ( ret ) { case CL_ENULLARG : cli_warnmsg ( ""cli_scanpe:<S2SV_blank>NULL<S2SV_blank>argument<S2SV_blank>supplied\\n"" ) ; break ; case CL_VIRUS : case CL_BREAK : free ( exe_sections ) ; cli_bytecode_context_destroy ( bc_ctx ) ; return ret == CL_VIRUS ? CL_VIRUS : CL_CLEAN ; } cli_bytecode_context_destroy ( bc_ctx ) ; if ( SCAN_ALGO && ( DCONF & PE_CONF_PARITE ) && ! dll && epsize == 4096 && ep == exe_sections [ nsections - 1 ] . raw ) { const char * pt = cli_memstr ( epbuff , 4040 , ""\\x47\\x65\\x74\\x50\\x72\\x6f\\x63\\x41\\x64\\x64\\x72\\x65\\x73\\x73\\x00"" , 15 ) ; if ( pt ) { pt += 15 ; if ( ( ( ( uint32_t ) cli_readint32 ( pt ) ^ ( uint32_t ) cli_readint32 ( pt + 4 ) ) == 0x505a4f ) && ( ( ( uint32_t ) cli_readint32 ( pt + 8 ) ^ ( uint32_t ) cli_readint32 ( pt + 12 ) ) == 0xffffb ) && ( ( ( uint32_t ) cli_readint32 ( pt + 16 ) ^ ( uint32_t ) cli_readint32 ( pt + 20 ) ) == 0xb8 ) ) { cli_append_virus ( ctx , ""Heuristics.W32.Parite.B"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } if ( SCAN_ALGO && ( DCONF & PE_CONF_KRIZ ) && epsize >= 200 && CLI_ISCONTAINED ( exe_sections [ nsections - 1 ] . raw , exe_sections [ nsections - 1 ] . rsz , ep , 0x0fd2 ) && epbuff [ 1 ] == '\\x9c' && epbuff [ 2 ] == '\\x60' ) { enum { KZSTRASH , KZSCDELTA , KZSPDELTA , KZSGETSIZE , KZSXORPRFX , KZSXOR , KZSDDELTA , KZSLOOP , KZSTOP } ; uint8_t kzs [ ] = { KZSTRASH , KZSCDELTA , KZSPDELTA , KZSGETSIZE , KZSTRASH , KZSXORPRFX , KZSXOR , KZSTRASH , KZSDDELTA , KZSTRASH , KZSLOOP , KZSTOP } ; uint8_t * kzstate = kzs ; uint8_t * kzcode = ( uint8_t * ) epbuff + 3 ; uint8_t kzdptr = 0xff , kzdsize = 0xff ; int kzlen = 197 , kzinitlen = 0xffff , kzxorlen = - 1 ; cli_dbgmsg ( ""in<S2SV_blank>kriz\\n"" ) ; while ( * kzstate != KZSTOP ) { uint8_t op ; if ( kzlen <= 6 ) break ; op = * kzcode ++ ; kzlen -- ; switch ( * kzstate ) { case KZSTRASH : case KZSGETSIZE : { int opsz = 0 ; switch ( op ) { case 0x81 : kzcode += 5 ; kzlen -= 5 ; break ; case 0xb8 : case 0xb9 : case 0xba : case 0xbb : case 0xbd : case 0xbe : case 0xbf : if ( * kzstate == KZSGETSIZE && cli_readint32 ( kzcode ) == 0x0fd2 ) { kzinitlen = kzlen - 5 ; kzdsize = op - 0xb8 ; kzstate ++ ; op = 4 ; cli_dbgmsg ( ""kriz:<S2SV_blank>using<S2SV_blank>#%d<S2SV_blank>as<S2SV_blank>size<S2SV_blank>counter\\n"" , kzdsize ) ; } opsz = 4 ; case 0x48 : case 0x49 : case 0x4a : case 0x4b : case 0x4d : case 0x4e : case 0x4f : op &= 7 ; if ( op != kzdptr && op != kzdsize ) { kzcode += opsz ; kzlen -= opsz ; break ; } default : kzcode -- ; kzlen ++ ; kzstate ++ ; } break ; } case KZSCDELTA : if ( op == 0xe8 && ( uint32_t ) cli_readint32 ( kzcode ) < 0xff ) { kzlen -= * kzcode + 4 ; kzcode += * kzcode + 4 ; kzstate ++ ; } else * kzstate = KZSTOP ; break ; case KZSPDELTA : if ( ( op & 0xf8 ) == 0x58 && ( kzdptr = op - 0x58 ) != 4 ) { kzstate ++ ; cli_dbgmsg ( ""kriz:<S2SV_blank>using<S2SV_blank>#%d<S2SV_blank>as<S2SV_blank>pointer\\n"" , kzdptr ) ; } else * kzstate = KZSTOP ; break ; case KZSXORPRFX : kzstate ++ ; if ( op == 0x3e ) break ; case KZSXOR : if ( op == 0x80 && * kzcode == kzdptr + 0xb0 ) { kzxorlen = kzlen ; kzcode += + 6 ; kzlen -= + 6 ; kzstate ++ ; } else * kzstate = KZSTOP ; break ; case KZSDDELTA : if ( op == kzdptr + 0x48 ) kzstate ++ ; else * kzstate = KZSTOP ; break ; case KZSLOOP : if ( op == kzdsize + 0x48 && * kzcode == 0x75 && kzlen - ( int8_t ) kzcode [ 1 ] - 3 <= kzinitlen && kzlen - ( int8_t ) kzcode [ 1 ] >= kzxorlen ) { cli_append_virus ( ctx , ""Heuristics.W32.Kriz"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } cli_dbgmsg ( ""kriz:<S2SV_blank>loop<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds,<S2SV_blank>corrupted<S2SV_blank>sample?\\n"" ) ; kzstate ++ ; } } } if ( SCAN_ALGO && ( DCONF & PE_CONF_MAGISTR ) && ! dll && ( nsections > 1 ) && ( exe_sections [ nsections - 1 ] . chr & 0x80000000 ) ) { uint32_t rsize , vsize , dam = 0 ; vsize = exe_sections [ nsections - 1 ] . uvsz ; rsize = exe_sections [ nsections - 1 ] . rsz ; if ( rsize < exe_sections [ nsections - 1 ] . ursz ) { rsize = exe_sections [ nsections - 1 ] . ursz ; dam = 1 ; } if ( vsize >= 0x612c && rsize >= 0x612c && ( ( vsize & 0xff ) == 0xec ) ) { int bw = rsize < 0x7000 ? rsize : 0x7000 ; const char * tbuff ; if ( ( tbuff = fmap_need_off_once ( map , exe_sections [ nsections - 1 ] . raw + rsize - bw , 4096 ) ) ) { if ( cli_memstr ( tbuff , 4091 , ""\\xe8\\x2c\\x61\\x00\\x00"" , 5 ) ) { cli_append_virus ( ctx , dam ? ""Heuristics.W32.Magistr.A.dam"" : ""Heuristics.W32.Magistr.A"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } else if ( rsize >= 0x7000 && vsize >= 0x7000 && ( ( vsize & 0xff ) == 0xed ) ) { int bw = rsize < 0x8000 ? rsize : 0x8000 ; const char * tbuff ; if ( ( tbuff = fmap_need_off_once ( map , exe_sections [ nsections - 1 ] . raw + rsize - bw , 4096 ) ) ) { if ( cli_memstr ( tbuff , 4091 , ""\\xe8\\x04\\x72\\x00\\x00"" , 5 ) ) { cli_append_virus ( ctx , dam ? ""Heuristics.W32.Magistr.B.dam"" : ""Heuristics.W32.Magistr.B"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } } while ( polipos && ! dll && nsections > 2 && nsections < 13 && e_lfanew <= 0x800 && ( EC16 ( optional_hdr32 . Subsystem ) == 2 || EC16 ( optional_hdr32 . Subsystem ) == 3 ) && EC16 ( file_hdr . Machine ) == 0x14c && optional_hdr32 . SizeOfStackReserve >= 0x80000 ) { uint32_t jump , jold , * jumps = NULL ; const uint8_t * code ; unsigned int xsjs = 0 ; if ( exe_sections [ 0 ] . rsz > CLI_MAX_ALLOCATION ) break ; if ( ! exe_sections [ 0 ] . rsz ) break ; if ( ! ( code = fmap_need_off_once ( map , exe_sections [ 0 ] . raw , exe_sections [ 0 ] . rsz ) ) ) break ; for ( i = 0 ; i < exe_sections [ 0 ] . rsz - 5 ; i ++ ) { if ( ( uint8_t ) ( code [ i ] - 0xe8 ) > 1 ) continue ; jump = cli_rawaddr ( exe_sections [ 0 ] . rva + i + 5 + cli_readint32 ( & code [ i + 1 ] ) , exe_sections , nsections , & err , fsize , hdr_size ) ; if ( err || ! CLI_ISCONTAINED ( exe_sections [ polipos ] . raw , exe_sections [ polipos ] . rsz , jump , 9 ) ) continue ; if ( xsjs % 128 == 0 ) { if ( xsjs == 1280 ) break ; if ( ! ( jumps = ( uint32_t * ) cli_realloc2 ( jumps , ( xsjs + 128 ) * sizeof ( uint32_t ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } } j = 0 ; for ( ; j < xsjs ; j ++ ) { if ( jumps [ j ] < jump ) continue ; if ( jumps [ j ] == jump ) { xsjs -- ; break ; } jold = jumps [ j ] ; jumps [ j ] = jump ; jump = jold ; } jumps [ j ] = jump ; xsjs ++ ; } if ( ! xsjs ) break ; cli_dbgmsg ( ""Polipos:<S2SV_blank>Checking<S2SV_blank>%d<S2SV_blank>xsect<S2SV_blank>jump(s)\\n"" , xsjs ) ; for ( i = 0 ; i < xsjs ; i ++ ) { if ( ! ( code = fmap_need_off_once ( map , jumps [ i ] , 9 ) ) ) continue ; if ( ( jump = cli_readint32 ( code ) ) == 0x60ec8b55 || ( code [ 4 ] == 0x0ec && ( ( jump == 0x83ec8b55 && code [ 6 ] == 0x60 ) || ( jump == 0x81ec8b55 && ! code [ 7 ] && ! code [ 8 ] ) ) ) ) { cli_append_virus ( ctx , ""Heuristics.W32.Polipos.A"" ) ; if ( ! SCAN_ALL ) { free ( jumps ) ; free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } free ( jumps ) ; break ; } if ( SCAN_ALGO && ( DCONF & PE_CONF_SWIZZOR ) && nsections > 1 && fsize > 64 * 1024 && fsize < 4 * 1024 * 1024 ) { if ( dirs [ 2 ] . Size ) { struct swizz_stats * stats = cli_calloc ( 1 , sizeof ( * stats ) ) ; unsigned int m = 1000 ; ret = CL_CLEAN ; if ( ! stats ) ret = CL_EMEM ; else { cli_parseres_special ( EC32 ( dirs [ 2 ] . VirtualAddress ) , EC32 ( dirs [ 2 ] . VirtualAddress ) , map , exe_sections , nsections , fsize , hdr_size , 0 , 0 , & m , stats ) ; if ( ( ret = cli_detect_swizz ( stats ) ) == CL_VIRUS ) { cli_append_virus ( ctx , ""Heuristics.Trojan.Swizzor.Gen"" ) ; } free ( stats ) ; } if ( ret != CL_CLEAN ) { if ( ! ( ret == CL_VIRUS && SCAN_ALL ) ) { free ( exe_sections ) ; return ret ; } viruses_found ++ ; } } } corrupted_cur = ctx -> corrupted_input ; ctx -> corrupted_input = 2 ; found = 0 ; if ( DCONF & ( PE_CONF_UPX | PE_CONF_FSG | PE_CONF_MEW ) ) { for ( i = 0 ; i < ( unsigned int ) nsections - 1 ; i ++ ) { if ( ! exe_sections [ i ] . rsz && exe_sections [ i ] . vsz && exe_sections [ i + 1 ] . rsz && exe_sections [ i + 1 ] . vsz ) { found = 1 ; cli_dbgmsg ( ""UPX/FSG/MEW:<S2SV_blank>empty<S2SV_blank>section<S2SV_blank>found<S2SV_blank>-<S2SV_blank>assuming<S2SV_blank>compression\\n"" ) ; # if HAVE_JSON cli_jsonbool ( pe_json , ""HasEmptySection"" , 1 ) ; # endif break ; } } } if ( found && ( DCONF & PE_CONF_MEW ) && epsize >= 16 && epbuff [ 0 ] == '\\xe9' ) { uint32_t fileoffset ; const char * tbuff ; fileoffset = ( vep + cli_readint32 ( epbuff + 1 ) + 5 ) ; while ( fileoffset == 0x154 || fileoffset == 0x158 ) { char * src ; uint32_t offdiff , uselzma ; cli_dbgmsg ( ""MEW:<S2SV_blank>found<S2SV_blank>MEW<S2SV_blank>characteristics<S2SV_blank>%08X<S2SV_blank>+<S2SV_blank>%08X<S2SV_blank>+<S2SV_blank>5<S2SV_blank>=<S2SV_blank>%08X\\n"" , cli_readint32 ( epbuff + 1 ) , vep , cli_readint32 ( epbuff + 1 ) + vep + 5 ) ; if ( ! ( tbuff = fmap_need_off_once ( map , fileoffset , 0xb0 ) ) ) break ; if ( fileoffset == 0x154 ) cli_dbgmsg ( ""MEW:<S2SV_blank>Win9x<S2SV_blank>compatibility<S2SV_blank>was<S2SV_blank>set!\\n"" ) ; else cli_dbgmsg ( ""MEW:<S2SV_blank>Win9x<S2SV_blank>compatibility<S2SV_blank>was<S2SV_blank>NOT<S2SV_blank>set!\\n"" ) ; if ( ( offdiff = cli_readint32 ( tbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) ) <= exe_sections [ i + 1 ] . rva || offdiff >= exe_sections [ i + 1 ] . rva + exe_sections [ i + 1 ] . raw - 4 ) { cli_dbgmsg ( ""MEW:<S2SV_blank>ESI<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>proper<S2SV_blank>section\\n"" ) ; break ; } offdiff -= exe_sections [ i + 1 ] . rva ; if ( ! exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""MEW:<S2SV_blank>mew<S2SV_blank>section<S2SV_blank>is<S2SV_blank>empty\\n"" ) ; break ; } ssize = exe_sections [ i + 1 ] . vsz ; dsize = exe_sections [ i ] . vsz ; cli_dbgmsg ( ""MEW:<S2SV_blank>ssize<S2SV_blank>%08x<S2SV_blank>dsize<S2SV_blank>%08x<S2SV_blank>offdiff:<S2SV_blank>%08x\\n"" , ssize , dsize , offdiff ) ; CLI_UNPSIZELIMITS ( ""MEW"" , MAX ( ssize , dsize ) ) ; CLI_UNPSIZELIMITS ( ""MEW"" , MAX ( ssize + dsize , exe_sections [ i + 1 ] . rsz ) ) ; if ( exe_sections [ i + 1 ] . rsz < offdiff + 12 || exe_sections [ i + 1 ] . rsz > ssize ) { cli_dbgmsg ( ""MEW:<S2SV_blank>Size<S2SV_blank>mismatch:<S2SV_blank>%08x\\n"" , exe_sections [ i + 1 ] . rsz ) ; break ; } if ( ! ( src = cli_calloc ( ssize + dsize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( bytes = fmap_readn ( map , src + dsize , exe_sections [ i + 1 ] . raw , exe_sections [ i + 1 ] . rsz ) ) != exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""MEW:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>[read:<S2SV_blank>%lu]\\n"" , exe_sections [ i + 1 ] . rsz , ( unsigned long ) bytes ) ; free ( exe_sections ) ; free ( src ) ; return CL_EREAD ; } cli_dbgmsg ( ""MEW:<S2SV_blank>%u<S2SV_blank>(%08x)<S2SV_blank>bytes<S2SV_blank>read\\n"" , ( unsigned int ) bytes , ( unsigned int ) bytes ) ; if ( tbuff [ 0x7b ] == '\\xe8' ) { if ( ! CLI_ISCONTAINED ( exe_sections [ 1 ] . rva , exe_sections [ 1 ] . vsz , cli_readint32 ( tbuff + 0x7c ) + fileoffset + 0x80 , 4 ) ) { cli_dbgmsg ( ""MEW:<S2SV_blank>lzma<S2SV_blank>proc<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds!\\n"" ) ; free ( src ) ; break ; } uselzma = cli_readint32 ( tbuff + 0x7c ) - ( exe_sections [ 0 ] . rva - fileoffset - 0x80 ) ; } else { uselzma = 0 ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""MEW"" ) ; # endif CLI_UNPTEMP ( ""MEW"" , ( src , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""MEW"" , ( unmew11 ( src , offdiff , ssize , dsize , EC32 ( optional_hdr32 . ImageBase ) , exe_sections [ 0 ] . rva , uselzma , ndesc ) ) , 1 , ( src , 0 ) ) ; break ; } } if ( epsize < 168 ) { free ( exe_sections ) ; return CL_CLEAN ; } if ( found || upack ) { while ( ( ( upack && nsections == 3 ) && ( ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > min && epbuff [ 5 ] == '\\xad' && epbuff [ 6 ] == '\\x50' ) || ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > min && epbuff [ 5 ] == '\\xff' && epbuff [ 6 ] == '\\x36' ) ) ) || ( ( ! upack && nsections == 2 ) && ( ( epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xe8' && cli_readint32 ( epbuff + 2 ) == 0x9 ) || ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > 0 && epbuff [ 5 ] == '\\xad' && epbuff [ 6 ] == '\\x8b' && epbuff [ 7 ] == '\\xf8' ) ) ) ) { uint32_t vma , off ; int a , b , c ; cli_dbgmsg ( ""Upack<S2SV_blank>characteristics<S2SV_blank>found.\\n"" ) ; a = exe_sections [ 0 ] . vsz ; b = exe_sections [ 1 ] . vsz ; if ( upack ) { cli_dbgmsg ( ""Upack:<S2SV_blank>var<S2SV_blank>set\\n"" ) ; c = exe_sections [ 2 ] . vsz ; ssize = exe_sections [ 0 ] . ursz + exe_sections [ 0 ] . uraw ; off = exe_sections [ 0 ] . rva ; vma = EC32 ( optional_hdr32 . ImageBase ) + exe_sections [ 0 ] . rva ; } else { cli_dbgmsg ( ""Upack:<S2SV_blank>var<S2SV_blank>NOT<S2SV_blank>set\\n"" ) ; c = exe_sections [ 1 ] . rva ; ssize = exe_sections [ 1 ] . uraw ; off = 0 ; vma = exe_sections [ 1 ] . rva - exe_sections [ 1 ] . uraw ; } dsize = a + b + c ; CLI_UNPSIZELIMITS ( ""Upack"" , MAX ( MAX ( dsize , ssize ) , exe_sections [ 1 ] . ursz ) ) ; if ( ! CLI_ISCONTAINED ( 0 , dsize , exe_sections [ 1 ] . rva - off , exe_sections [ 1 ] . ursz ) || ( upack && ! CLI_ISCONTAINED ( 0 , dsize , exe_sections [ 2 ] . rva - exe_sections [ 0 ] . rva , ssize ) ) || ssize > dsize ) { cli_dbgmsg ( ""Upack:<S2SV_blank>probably<S2SV_blank>malformed<S2SV_blank>pe-header,<S2SV_blank>skipping<S2SV_blank>to<S2SV_blank>next<S2SV_blank>unpacker\\n"" ) ; break ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( unsigned int ) fmap_readn ( map , dest , 0 , ssize ) != ssize ) { cli_dbgmsg ( ""Upack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>0\\n"" ) ; free ( dest ) ; break ; } if ( upack ) memmove ( dest + exe_sections [ 2 ] . rva - exe_sections [ 0 ] . rva , dest , ssize ) ; if ( ( unsigned int ) fmap_readn ( map , dest + exe_sections [ 1 ] . rva - off , exe_sections [ 1 ] . uraw , exe_sections [ 1 ] . ursz ) != exe_sections [ 1 ] . ursz ) { cli_dbgmsg ( ""Upack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>1\\n"" ) ; free ( dest ) ; break ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Upack"" ) ; # endif CLI_UNPTEMP ( ""Upack"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Upack"" , ( unupack ( upack , dest , dsize , epbuff , vma , ep , EC32 ( optional_hdr32 . ImageBase ) , exe_sections [ 0 ] . rva , ndesc ) ) , 1 , ( dest , 0 ) ) ; break ; } } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\x87' && epbuff [ 1 ] == '\\x25' ) { const char * dst ; uint32_t newesi , newedi , newebx , newedx ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } newedx = cli_readint32 ( epbuff + 2 ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newedx , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>xchg<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>(%x),<S2SV_blank>giving<S2SV_blank>up\\n"" , newedx ) ; break ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i + 1 ) ; free ( exe_sections ) ; return CL_ESEEK ; } dst = src + newedx - exe_sections [ i + 1 ] . rva ; if ( newedx < exe_sections [ i + 1 ] . rva || ! CLI_ISCONTAINED ( src , ssize , dst , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>ESP<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedx = cli_readint32 ( dst ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newedx , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>ESP<S2SV_blank>(%x)<S2SV_blank>is<S2SV_blank>wrong\\n"" , newedx ) ; break ; } dst = src + newedx - exe_sections [ i + 1 ] . rva ; if ( ! CLI_ISCONTAINED ( src , ssize , dst , 32 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>stack<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedi = cli_readint32 ( dst ) - EC32 ( optional_hdr32 . ImageBase ) ; newesi = cli_readint32 ( dst + 4 ) - EC32 ( optional_hdr32 . ImageBase ) ; newebx = cli_readint32 ( dst + 16 ) - EC32 ( optional_hdr32 . ImageBase ) ; newedx = cli_readint32 ( dst + 20 ) ; if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>buffer<S2SV_blank>(edi<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newebx , 16 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Array<S2SV_blank>of<S2SV_blank>functions<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedx = cli_readint32 ( newebx + 12 - exe_sections [ i + 1 ] . rva + src ) - EC32 ( optional_hdr32 . ImageBase ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , newedx ) ; if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG2 ( ""FSG"" , ( unfsg_200 ( newesi - exe_sections [ i + 1 ] . rva + src , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , newedi , EC32 ( optional_hdr32 . ImageBase ) , newedx , ndesc ) ) , 1 , ( dest , 0 ) ) ; break ; } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min ) { int sectcnt = 0 ; const char * support ; uint32_t newesi , newedi , oldep , gp , t ; struct cli_exe_section * sections ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } if ( ! ( t = cli_rawaddr ( cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) , NULL , 0 , & err , fsize , hdr_size ) ) && err ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Support<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>padding<S2SV_blank>area\\n"" ) ; break ; } gp = exe_sections [ i + 1 ] . raw - t ; CLI_UNPSIZELIMITS ( ""FSG"" , gp ) ; if ( ! ( support = fmap_need_off_once ( map , t , gp ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>padding<S2SV_blank>area\\n"" , gp ) ; free ( exe_sections ) ; return CL_EREAD ; } newedi = cli_readint32 ( support + 4 ) - EC32 ( optional_hdr32 . ImageBase ) ; newesi = cli_readint32 ( support + 8 ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>(is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } for ( t = 12 ; t < gp - 4 ; t += 4 ) { uint32_t rva = cli_readint32 ( support + t ) ; if ( ! rva ) break ; rva -= EC32 ( optional_hdr32 . ImageBase ) + 1 ; sectcnt ++ ; if ( rva % 0x1000 ) cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>misaligned\\n"" , sectcnt ) ; if ( rva < exe_sections [ i ] . rva || rva - exe_sections [ i ] . rva >= exe_sections [ i ] . vsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" , sectcnt ) ; break ; } } if ( t >= gp - 4 || cli_readint32 ( support + t ) ) { break ; } if ( ( sections = ( struct cli_exe_section * ) cli_malloc ( ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ) == NULL ) { cli_errmsg ( ""FSG:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>sections<S2SV_blank>%lu\\n"" , ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ; free ( exe_sections ) ; return CL_EMEM ; } sections [ 0 ] . rva = newedi ; for ( t = 1 ; t <= ( uint32_t ) sectcnt ; t ++ ) sections [ t ] . rva = cli_readint32 ( support + 8 + t * 4 ) - 1 - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i ) ; free ( exe_sections ) ; free ( sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; free ( sections ) ; return CL_EMEM ; } oldep = vep + 161 + 6 + cli_readint32 ( epbuff + 163 ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , oldep ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , sections , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG1 ( ""FSG"" , ( unfsg_133 ( src + newesi - exe_sections [ i + 1 ] . rva , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , sections , sectcnt , EC32 ( optional_hdr32 . ImageBase ) , oldep , ndesc ) ) , 1 , ( dest , sections , 0 ) ) ; break ; } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\xbb' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min && epbuff [ 5 ] == '\\xbf' && epbuff [ 10 ] == '\\xbe' && vep >= exe_sections [ i + 1 ] . rva && vep - exe_sections [ i + 1 ] . rva > exe_sections [ i + 1 ] . rva - 0xe0 ) { int sectcnt = 0 ; uint32_t gp , t = cli_rawaddr ( cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) , NULL , 0 , & err , fsize , hdr_size ) ; const char * support ; uint32_t newesi = cli_readint32 ( epbuff + 11 ) - EC32 ( optional_hdr32 . ImageBase ) ; uint32_t newedi = cli_readint32 ( epbuff + 6 ) - EC32 ( optional_hdr32 . ImageBase ) ; uint32_t oldep = vep - exe_sections [ i + 1 ] . rva ; struct cli_exe_section * sections ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; if ( err ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Support<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>padding<S2SV_blank>area\\n"" ) ; break ; } if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . raw ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>(is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } gp = exe_sections [ i + 1 ] . raw - t ; CLI_UNPSIZELIMITS ( ""FSG"" , gp ) if ( ! ( support = fmap_need_off_once ( map , t , gp ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>padding<S2SV_blank>area\\n"" , gp ) ; free ( exe_sections ) ; return CL_EREAD ; } for ( t = 0 ; t < gp - 2 ; t += 2 ) { uint32_t rva = support [ t ] | ( support [ t + 1 ] << 8 ) ; if ( rva == 2 || rva == 1 ) break ; rva = ( ( rva - 2 ) << 12 ) - EC32 ( optional_hdr32 . ImageBase ) ; sectcnt ++ ; if ( rva < exe_sections [ i ] . rva || rva - exe_sections [ i ] . rva >= exe_sections [ i ] . vsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" , sectcnt ) ; break ; } } if ( t >= gp - 10 || cli_readint32 ( support + t + 6 ) != 2 ) { break ; } if ( ( sections = ( struct cli_exe_section * ) cli_malloc ( ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ) == NULL ) { cli_errmsg ( ""FSG:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>sections<S2SV_blank>%lu\\n"" , ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ; free ( exe_sections ) ; return CL_EMEM ; } sections [ 0 ] . rva = newedi ; for ( t = 0 ; t <= ( uint32_t ) sectcnt - 1 ; t ++ ) { sections [ t + 1 ] . rva = ( ( ( support [ t * 2 ] | ( support [ t * 2 + 1 ] << 8 ) ) - 2 ) << 12 ) - EC32 ( optional_hdr32 . ImageBase ) ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i ) ; free ( exe_sections ) ; free ( sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; free ( sections ) ; return CL_EMEM ; } gp = 0xda + 6 * ( epbuff [ 16 ] == '\\xe8' ) ; oldep = vep + gp + 6 + cli_readint32 ( src + gp + 2 + oldep ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , oldep ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , sections , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG1 ( ""FSG"" , ( unfsg_133 ( src + newesi - exe_sections [ i + 1 ] . rva , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , sections , sectcnt , EC32 ( optional_hdr32 . ImageBase ) , oldep , ndesc ) ) , 1 , ( dest , sections , 0 ) ) ; break ; } if ( found && ( DCONF & PE_CONF_UPX ) ) { ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz + exe_sections [ i + 1 ] . vsz ; CLI_UNPSIZELIMITS ( ""UPX"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>or<S2SV_blank>dsize<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i + 1 ) ; free ( exe_sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize + 8192 , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } if ( cli_memstr ( UPX_NRV2B , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2B , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2B<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2b ; } else if ( cli_memstr ( UPX_NRV2D , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2D , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2D<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2d ; } else if ( cli_memstr ( UPX_NRV2E , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2E , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2E<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2e ; } if ( upxfn ) { int skew = cli_readint32 ( epbuff + 2 ) - EC32 ( optional_hdr32 . ImageBase ) - exe_sections [ i + 1 ] . rva ; if ( epbuff [ 1 ] != '\\xbe' || skew <= 0 || skew > 0xfff ) { skew = 0 ; } else if ( ( unsigned int ) skew > ssize ) { skew = 0 ; } else { cli_dbgmsg ( ""UPX:<S2SV_blank>UPX1<S2SV_blank>seems<S2SV_blank>skewed<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>bytes\\n"" , skew ) ; } if ( upxfn ( src + skew , ssize - skew , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - skew ) >= 0 ) { upx_success = 1 ; } else if ( skew && ( upxfn ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ) ) { upx_success = 1 ; } if ( upx_success ) cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed\\n"" ) ; else cli_dbgmsg ( ""UPX:<S2SV_blank>Preferred<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } if ( ! upx_success && upxfn != upx_inflate2b ) { if ( upx_inflate2b ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2b ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2B<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2B\\n"" ) ; } } if ( ! upx_success && upxfn != upx_inflate2d ) { if ( upx_inflate2d ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2d ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2D<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2D\\n"" ) ; } } if ( ! upx_success && upxfn != upx_inflate2e ) { if ( upx_inflate2e ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2e ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2E<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2E\\n"" ) ; } } if ( cli_memstr ( UPX_LZMA2 , 20 , epbuff + 0x2f , 20 ) ) { uint32_t strictdsize = cli_readint32 ( epbuff + 0x21 ) , skew = 0 ; if ( ssize > 0x15 && epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xbe' ) { skew = cli_readint32 ( epbuff + 2 ) - exe_sections [ i + 1 ] . rva - optional_hdr32 . ImageBase ; if ( skew != 0x15 ) skew = 0 ; } if ( strictdsize <= dsize ) upx_success = upx_inflatelzma ( src + skew , ssize - skew , dest , & strictdsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ; } else if ( cli_memstr ( UPX_LZMA1 , 20 , epbuff + 0x39 , 20 ) ) { uint32_t strictdsize = cli_readint32 ( epbuff + 0x2b ) , skew = 0 ; if ( ssize > 0x15 && epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xbe' ) { skew = cli_readint32 ( epbuff + 2 ) - exe_sections [ i + 1 ] . rva - optional_hdr32 . ImageBase ; if ( skew != 0x15 ) skew = 0 ; } if ( strictdsize <= dsize ) upx_success = upx_inflatelzma ( src + skew , ssize - skew , dest , & strictdsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ; } if ( ! upx_success ) { cli_dbgmsg ( ""UPX:<S2SV_blank>All<S2SV_blank>decompressors<S2SV_blank>failed\\n"" ) ; free ( dest ) ; } } if ( upx_success ) { free ( exe_sections ) ; CLI_UNPTEMP ( ""UPX/FSG"" , ( dest , 0 ) ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""UPX"" ) ; # endif if ( ( unsigned int ) write ( ndesc , dest , dsize ) != dsize ) { cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>Can\'t<S2SV_blank>write<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dsize ) ; free ( tempfile ) ; free ( dest ) ; close ( ndesc ) ; return CL_EWRITE ; } free ( dest ) ; if ( lseek ( ndesc , 0 , SEEK_SET ) == - 1 ) { cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>lseek()<S2SV_blank>failed\\n"" ) ; close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; SHA_RESET ; return CL_ESEEK ; } if ( ctx -> engine -> keeptmp ) cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>Decompressed<S2SV_blank>data<S2SV_blank>saved<S2SV_blank>in<S2SV_blank>%s\\n"" , tempfile ) ; cli_dbgmsg ( ""*****<S2SV_blank>Scanning<S2SV_blank>decompressed<S2SV_blank>file<S2SV_blank>*****\\n"" ) ; SHA_OFF ; if ( ( ret = cli_magic_scandesc ( ndesc , ctx ) ) == CL_VIRUS ) { close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; SHA_RESET ; return CL_VIRUS ; } SHA_RESET ; close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; return ret ; } if ( epsize < 200 ) { free ( exe_sections ) ; return CL_CLEAN ; } found = 2 ; if ( epbuff [ 0 ] != '\\xb8' || ( uint32_t ) cli_readint32 ( epbuff + 1 ) != exe_sections [ nsections - 1 ] . rva + EC32 ( optional_hdr32 . ImageBase ) ) { if ( nsections < 2 || epbuff [ 0 ] != '\\xb8' || ( uint32_t ) cli_readint32 ( epbuff + 1 ) != exe_sections [ nsections - 2 ] . rva + EC32 ( optional_hdr32 . ImageBase ) ) found = 0 ; else found = 1 ; } if ( found && ( DCONF & PE_CONF_PETITE ) ) { cli_dbgmsg ( ""Petite:<S2SV_blank>v2.%d<S2SV_blank>compression<S2SV_blank>detected\\n"" , found ) ; if ( cli_readint32 ( epbuff + 0x80 ) == 0x163c988d ) { cli_dbgmsg ( ""Petite:<S2SV_blank>level<S2SV_blank>zero<S2SV_blank>compression<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet\\n"" ) ; } else { dsize = max - min ; CLI_UNPSIZELIMITS ( ""Petite"" , dsize ) ; if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { cli_dbgmsg ( ""Petite:<S2SV_blank>Can\'t<S2SV_blank>allocate<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dsize ) ; free ( exe_sections ) ; return CL_EMEM ; } for ( i = 0 ; i < nsections ; i ++ ) { if ( exe_sections [ i ] . raw ) { if ( ! exe_sections [ i ] . rsz || ( unsigned int ) fmap_readn ( map , dest + exe_sections [ i ] . rva - min , exe_sections [ i ] . raw , exe_sections [ i ] . ursz ) != exe_sections [ i ] . ursz ) { free ( exe_sections ) ; free ( dest ) ; return CL_CLEAN ; } } } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Petite"" ) ; # endif CLI_UNPTEMP ( ""Petite"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Petite"" , ( petite_inflate2x_1to9 ( dest , min , max - min , exe_sections , nsections - ( found == 1 ? 1 : 0 ) , EC32 ( optional_hdr32 . ImageBase ) , vep , ndesc , found , EC32 ( optional_hdr32 . DataDirectory [ 2 ] . VirtualAddress ) , EC32 ( optional_hdr32 . DataDirectory [ 2 ] . Size ) ) ) , 0 , ( dest , 0 ) ) ; } } if ( ( DCONF & PE_CONF_PESPIN ) && nsections > 1 && vep >= exe_sections [ nsections - 1 ] . rva && vep < exe_sections [ nsections - 1 ] . rva + exe_sections [ nsections - 1 ] . rsz - 0x3217 - 4 && memcmp ( epbuff + 4 , ""\\xe8\\x00\\x00\\x00\\x00\\x8b\\x1c\\x24\\x83\\xc3"" , 10 ) == 0 ) { char * spinned ; CLI_UNPSIZELIMITS ( ""PEspin"" , fsize ) ; if ( ( spinned = ( char * ) cli_malloc ( fsize ) ) == NULL ) { cli_errmsg ( ""PESping:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>spinned<S2SV_blank>%lu\\n"" , ( unsigned long ) fsize ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , spinned , 0 , fsize ) != fsize ) { cli_dbgmsg ( ""PESpin:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) fsize ) ; free ( spinned ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""PEspin"" ) ; # endif CLI_UNPTEMP ( ""PESpin"" , ( spinned , exe_sections , 0 ) ) ; CLI_UNPRESULTS_ ( ""PEspin"" , SPINCASE ( ) , ( unspin ( spinned , fsize , exe_sections , nsections - 1 , vep , ndesc , ctx ) ) , 0 , ( spinned , 0 ) ) ; } if ( ( DCONF & PE_CONF_YC ) && nsections > 1 && ( EC32 ( optional_hdr32 . AddressOfEntryPoint ) == exe_sections [ nsections - 1 ] . rva + 0x60 ) ) { uint32_t ecx = 0 ; int16_t offset ; if ( ! memcmp ( epbuff , ""\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED"" , 15 ) && ! memcmp ( epbuff + 0x26 , ""\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC"" , 13 ) && ( ( uint8_t ) epbuff [ 0x13 ] == 0xB9 ) && ( ( uint16_t ) ( cli_readint16 ( epbuff + 0x18 ) ) == 0xE981 ) && ! memcmp ( epbuff + 0x1e , ""\\x8B\\xD5\\x81\\xC2"" , 4 ) ) { offset = 0 ; if ( 0x6c - cli_readint32 ( epbuff + 0xf ) + cli_readint32 ( epbuff + 0x22 ) == 0xC6 ) ecx = cli_readint32 ( epbuff + 0x14 ) - cli_readint32 ( epbuff + 0x1a ) ; } if ( ! ecx && ! memcmp ( epbuff , ""\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57"" , 9 ) && ! memcmp ( epbuff + 0x17 , ""\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed"" , 8 ) && ( ( uint8_t ) epbuff [ 0x23 ] == 0xB9 ) ) { offset = 0x10 ; if ( 0x6c - cli_readint32 ( epbuff + 0x1f ) + cli_readint32 ( epbuff + 0x32 ) == 0xC6 ) ecx = cli_readint32 ( epbuff + 0x24 ) - cli_readint32 ( epbuff + 0x2a ) ; } if ( ! ecx && ! memcmp ( epbuff , ""\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed"" , 9 ) && ( ( uint8_t ) epbuff [ 0xd ] == 0xb9 ) && ( ( uint16_t ) cli_readint16 ( epbuff + 0x12 ) == 0xbd8d ) && ! memcmp ( epbuff + 0x18 , ""\\x8b\\xf7\\xac"" , 3 ) ) { offset = - 0x18 ; if ( 0x66 - cli_readint32 ( epbuff + 0x9 ) + cli_readint32 ( epbuff + 0x14 ) == 0xae ) ecx = cli_readint32 ( epbuff + 0xe ) ; } if ( ecx > 0x800 && ecx < 0x2000 && ! memcmp ( epbuff + 0x63 + offset , ""\\xaa\\xe2\\xcc"" , 3 ) && ( fsize >= exe_sections [ nsections - 1 ] . raw + 0xC6 + ecx + offset ) ) { char * spinned ; if ( ( spinned = ( char * ) cli_malloc ( fsize ) ) == NULL ) { cli_errmsg ( ""yC:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>spinned<S2SV_blank>%lu\\n"" , ( unsigned long ) fsize ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , spinned , 0 , fsize ) != fsize ) { cli_dbgmsg ( ""yC:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) fsize ) ; free ( spinned ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""yC"" ) ; # endif cli_dbgmsg ( ""%d,%d,%d,%d\\n"" , nsections - 1 , e_lfanew , ecx , offset ) ; CLI_UNPTEMP ( ""yC"" , ( spinned , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""yC"" , ( yc_decrypt ( spinned , fsize , exe_sections , nsections - 1 , e_lfanew , ndesc , ecx , offset ) ) , 0 , ( spinned , 0 ) ) ; } } while ( ( DCONF & PE_CONF_WWPACK ) && nsections > 1 && vep == exe_sections [ nsections - 1 ] . rva && memcmp ( epbuff , ""\\x53\\x55\\x8b\\xe8\\x33\\xdb\\xeb"" , 7 ) == 0 && memcmp ( epbuff + 0x68 , ""\\xe8\\x00\\x00\\x00\\x00\\x58\\x2d\\x6d\\x00\\x00\\x00\\x50\\x60\\x33\\xc9\\x50\\x58\\x50\\x50"" , 19 ) == 0 ) { uint32_t head = exe_sections [ nsections - 1 ] . raw ; uint8_t * packer ; char * src ; ssize = 0 ; for ( i = 0 ; ; i ++ ) { if ( exe_sections [ i ] . raw < head ) head = exe_sections [ i ] . raw ; if ( i + 1 == nsections ) break ; if ( ssize < exe_sections [ i ] . rva + exe_sections [ i ] . vsz ) ssize = exe_sections [ i ] . rva + exe_sections [ i ] . vsz ; } if ( ! head || ! ssize || head > ssize ) break ; CLI_UNPSIZELIMITS ( ""WWPack"" , ssize ) ; if ( ! ( src = ( char * ) cli_calloc ( ssize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , src , 0 , head ) != head ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>headers\\n"" , head ) ; free ( src ) ; free ( exe_sections ) ; return CL_EREAD ; } for ( i = 0 ; i < ( unsigned int ) nsections - 1 ; i ++ ) { if ( ! exe_sections [ i ] . rsz ) continue ; if ( ! CLI_ISCONTAINED ( src , ssize , src + exe_sections [ i ] . rva , exe_sections [ i ] . rsz ) ) break ; if ( ( unsigned int ) fmap_readn ( map , src + exe_sections [ i ] . rva , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) != exe_sections [ i ] . rsz ) break ; } if ( i + 1 != nsections ) { cli_dbgmsg ( ""WWpack:<S2SV_blank>Probably<S2SV_blank>hacked/damaged<S2SV_blank>file.\\n"" ) ; free ( src ) ; break ; } if ( ( packer = ( uint8_t * ) cli_calloc ( exe_sections [ nsections - 1 ] . rsz , sizeof ( char ) ) ) == NULL ) { free ( src ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ! exe_sections [ nsections - 1 ] . rsz || ( size_t ) fmap_readn ( map , packer , exe_sections [ nsections - 1 ] . raw , exe_sections [ nsections - 1 ] . rsz ) != exe_sections [ nsections - 1 ] . rsz ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>wwpack<S2SV_blank>sect\\n"" , exe_sections [ nsections - 1 ] . rsz ) ; free ( src ) ; free ( packer ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""WWPack"" ) ; # endif CLI_UNPTEMP ( ""WWPack"" , ( src , packer , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""WWPack"" , ( wwunpack ( ( uint8_t * ) src , ssize , packer , exe_sections , nsections - 1 , e_lfanew , ndesc ) ) , 0 , ( src , packer , 0 ) ) ; break ; } while ( ( DCONF & PE_CONF_ASPACK ) && ep + 58 + 0x70e < fsize && ! memcmp ( epbuff , ""\\x60\\xe8\\x03\\x00\\x00\\x00\\xe9\\xeb"" , 8 ) ) { char * src ; if ( epsize < 0x3bf || memcmp ( epbuff + 0x3b9 , ""\\x68\\x00\\x00\\x00\\x00\\xc3"" , 6 ) ) break ; ssize = 0 ; for ( i = 0 ; i < nsections ; i ++ ) if ( ssize < exe_sections [ i ] . rva + exe_sections [ i ] . vsz ) ssize = exe_sections [ i ] . rva + exe_sections [ i ] . vsz ; if ( ! ssize ) break ; CLI_UNPSIZELIMITS ( ""Aspack"" , ssize ) ; if ( ! ( src = ( char * ) cli_calloc ( ssize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } for ( i = 0 ; i < ( unsigned int ) nsections ; i ++ ) { if ( ! exe_sections [ i ] . rsz ) continue ; if ( ! CLI_ISCONTAINED ( src , ssize , src + exe_sections [ i ] . rva , exe_sections [ i ] . rsz ) ) break ; if ( ( unsigned int ) fmap_readn ( map , src + exe_sections [ i ] . rva , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) != exe_sections [ i ] . rsz ) break ; } if ( i != nsections ) { cli_dbgmsg ( ""Aspack:<S2SV_blank>Probably<S2SV_blank>hacked/damaged<S2SV_blank>Aspack<S2SV_blank>file.\\n"" ) ; free ( src ) ; break ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Aspack"" ) ; # endif CLI_UNPTEMP ( ""Aspack"" , ( src , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Aspack"" , ( unaspack212 ( ( uint8_t * ) src , ssize , exe_sections , nsections , vep - 1 , EC32 ( optional_hdr32 . ImageBase ) , ndesc ) ) , 1 , ( src , 0 ) ) ; break ; } while ( DCONF & PE_CONF_NSPACK ) { uint32_t eprva = vep ; uint32_t start_of_stuff , rep = ep ; unsigned int nowinldr ; const char * nbuff ; src = epbuff ; if ( * epbuff == '\\xe9' ) { eprva = cli_readint32 ( epbuff + 1 ) + vep + 5 ; if ( ! ( rep = cli_rawaddr ( eprva , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) break ; if ( ! ( nbuff = fmap_need_off_once ( map , rep , 24 ) ) ) break ; src = nbuff ; } if ( memcmp ( src , ""\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00"" , 13 ) ) break ; nowinldr = 0x54 - cli_readint32 ( src + 17 ) ; cli_dbgmsg ( ""NsPack:<S2SV_blank>Found<S2SV_blank>*start_of_stuff<S2SV_blank>@delta-%x\\n"" , nowinldr ) ; if ( ! ( nbuff = fmap_need_off_once ( map , rep - nowinldr , 4 ) ) ) break ; start_of_stuff = rep + cli_readint32 ( nbuff ) ; if ( ! ( nbuff = fmap_need_off_once ( map , start_of_stuff , 20 ) ) ) break ; src = nbuff ; if ( ! cli_readint32 ( nbuff ) ) { start_of_stuff += 4 ; src += 4 ; } ssize = cli_readint32 ( src + 5 ) | 0xff ; dsize = cli_readint32 ( src + 9 ) ; CLI_UNPSIZELIMITS ( ""NsPack"" , MAX ( ssize , dsize ) ) ; if ( ! ssize || ! dsize || dsize != exe_sections [ 0 ] . vsz ) break ; if ( ! ( dest = cli_malloc ( dsize ) ) ) { cli_errmsg ( ""NsPack:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>dest<S2SV_blank>%u\\n"" , dsize ) ; break ; } if ( ! ( src = fmap_need_off ( map , start_of_stuff , ssize ) ) ) { free ( dest ) ; break ; } eprva += 0x27a ; if ( ! ( rep = cli_rawaddr ( eprva , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) { free ( dest ) ; break ; } if ( ! ( nbuff = fmap_need_off_once ( map , rep , 5 ) ) ) { free ( dest ) ; break ; } fmap_unneed_off ( map , start_of_stuff , ssize ) ; eprva = eprva + 5 + cli_readint32 ( nbuff + 1 ) ; cli_dbgmsg ( ""NsPack:<S2SV_blank>OEP<S2SV_blank>=<S2SV_blank>%08x\\n"" , eprva ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""NsPack"" ) ; # endif CLI_UNPTEMP ( ""NsPack"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""NsPack"" , ( unspack ( src , dest , ctx , exe_sections [ 0 ] . rva , EC32 ( optional_hdr32 . ImageBase ) , eprva , ndesc ) ) , 0 , ( dest , 0 ) ) ; break ; } ctx -> corrupted_input = corrupted_cur ; bc_ctx = cli_bytecode_context_alloc ( ) ; if ( ! bc_ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>bc_ctx\\n"" ) ; return CL_EMEM ; } cli_bytecode_context_setpe ( bc_ctx , & pedata , exe_sections ) ; cli_bytecode_context_setctx ( bc_ctx , ctx ) ; ret = cli_bytecode_runhook ( ctx , ctx -> engine , bc_ctx , BC_PE_UNPACKER , map ) ; switch ( ret ) { case CL_VIRUS : free ( exe_sections ) ; cli_bytecode_context_destroy ( bc_ctx ) ; return CL_VIRUS ; case CL_SUCCESS : ndesc = cli_bytecode_context_getresult_file ( bc_ctx , & tempfile ) ; cli_bytecode_context_destroy ( bc_ctx ) ; if ( ndesc != - 1 && tempfile ) { CLI_UNPRESULTS ( ""bytecode<S2SV_blank>PE<S2SV_blank>hook"" , 1 , 1 , ( 0 ) ) ; } break ; default : cli_bytecode_context_destroy ( bc_ctx ) ; } free ( exe_sections ) ; # if HAVE_JSON if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } # endif if ( SCAN_ALL && viruses_found ) return CL_VIRUS ; return CL_CLEAN ; }","
",1674
685,"buggy line: dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ;dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ;while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 )  {dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ;usleep ( 5 ) ;return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ;}cwe id:CWE-20context: uint16_t dm9000ReadPhyReg ( uint8_t address ) {  dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ;   dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ;   while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 )  { }  dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ;  usleep ( 5 ) ;  return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ;  }","dm9000WriteReg ( DM9000_EPAR , 0x40 | address ) ;dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR ) ;while ( ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE ) != 0 ) {}dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS ) ;usleep ( 5 ) ;return ( dm9000ReadReg ( DM9000_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_EPDRL ) ;",1675
686,"buggy line: if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer ,  & bufferoffset ,  i , t2p -> tiff_length ) ) {cwe id:CWE-787context: tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>"" ""t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( t2p -> tiff_dataoffset != 0 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( t2p -> pdf_ojpegiflength == 0 ) { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; t2pReadFile ( input , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } else { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; bufferoffset = t2pReadFile ( input , ( tdata_t ) buffer , t2p -> pdf_ojpegiflength ) ; t2p -> pdf_ojpegiflength = 0 ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & h_samp , & v_samp ) ; buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xdd ; buffer [ bufferoffset ++ ] = 0x00 ; buffer [ bufferoffset ++ ] = 0x04 ; h_samp *= 8 ; v_samp *= 8 ; ri = ( t2p -> tiff_width + h_samp - 1 ) / h_samp ; TIFFGetField ( input , TIFFTAG_ROWSPERSTRIP , & rows ) ; ri *= ( rows + v_samp - 1 ) / v_samp ; buffer [ bufferoffset ++ ] = ( ri >> 8 ) & 0xff ; buffer [ bufferoffset ++ ] = ri & 0xff ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } } else { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>tables"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; bufferoffset = t2p -> pdf_ojpegdatalength ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } if ( ! ( ( buffer [ bufferoffset - 1 ] == 0xd9 ) && ( buffer [ bufferoffset - 2 ] == 0xff ) ) ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; # if 0 TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>JPEG<S2SV_blank>File<S2SV_blank>Interchange<S2SV_blank>offset"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; # endif } } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { if ( count > 4 ) { _TIFFmemcpy ( buffer , jpt , count ) ; bufferoffset += count - 2 ; } } stripcount = TIFFNumberOfStrips ( input ) ; TIFFGetField ( input , TIFFTAG_STRIPBYTECOUNTS , & sbc ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( sbc [ i ] > max_striplength ) max_striplength = sbc [ i ] ; } stripbuffer = ( unsigned char * ) _TIFFmalloc ( max_striplength ) ; if ( stripbuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , max_striplength , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { striplength = TIFFReadRawStrip ( input , i , ( tdata_t ) stripbuffer , - 1 ) ; if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer ,  & bufferoffset ,  i , t2p -> tiff_length ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>process<S2SV_blank>JPEG<S2SV_blank>data<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( stripbuffer ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } } else { if ( t2p -> pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { sepstripsize = TIFFStripSize ( input ) ; sepstripcount = TIFFNumberOfStrips ( input ) ; stripsize = sepstripsize * t2p -> tiff_samplesperpixel ; stripcount = sepstripcount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; samplebuffer = ( unsigned char * ) _TIFFmalloc ( stripsize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { samplebufferoffset = 0 ; for ( j = 0 ; j < t2p -> tiff_samplesperpixel ; j ++ ) { read = TIFFReadEncodedStrip ( input , i + j * stripcount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , TIFFmin ( sepstripsize , stripsize - samplebufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i + j * stripcount , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; } _TIFFfree ( samplebuffer ) ; goto dataready ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } if ( t2p -> pdf_sample & T2P_SAMPLE_REALIZE_PALETTE ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_datasize * t2p -> tiff_samplesperpixel ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; t2p -> tiff_datasize *= t2p -> tiff_samplesperpixel ; } t2p_sample_realize_palette ( t2p , buffer ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length * 4 ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; } if ( ! TIFFReadRGBAImageOriented ( input , t2p -> tiff_width , t2p -> tiff_length , ( uint32 * ) buffer , ORIENTATION_TOPLEFT , 0 ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>use<S2SV_blank>TIFFReadRGBAImageOriented<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>RGB<S2SV_blank>image<S2SV_blank>from<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } t2p -> tiff_datasize = t2p_sample_abgr_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } } dataready : t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_width ) ; TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } if ( TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) == 0 ) { TIFFError ( TIFF2PDF_MODULE , ""Unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>JPEG<S2SV_blank>compression<S2SV_blank>for<S2SV_blank>input<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>output<S2SV_blank>%s"" , TIFFFileName ( input ) , TIFFFileName ( output ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; # ifdef JPEG_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_JPEG && t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , stripsize * stripcount ) ; } else # endif { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , t2p -> tiff_datasize ) ; } if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == ( tsize_t ) - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>strip<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s"" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }","if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , t2p -> tiff_datasize , & bufferoffset , i , t2p -> tiff_length ) ) {",1676
687,"buggy line: if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ;if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ;if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  attr -> ia_mode &= ~ S_ISGID ;cwe id:CWE-264context: int inode_change_ok ( const struct inode * inode , struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_SIZE ) { int error = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( error ) return error ; } if ( ia_valid & ATTR_FORCE ) return 0 ; if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ; if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ; if ( ia_valid & ATTR_MODE ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  attr -> ia_mode &= ~ S_ISGID ; } if ( ia_valid & ( ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET ) ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; } return 0 ; }","if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ;if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ;if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) attr -> ia_mode &= ~ S_ISGID ;",1677
688,"buggy line: static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) {cwe id:CWE-787context:  static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ;  UINT32 tempWidth ;  tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ;  for ( y = 0 ; y < context -> height ; y ++ )  { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; }  } ","static BOOL nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , UINT32 scanline ) {",1678
689,"buggy line: UINT32 tempWidth ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;for ( y = 0 ;y ++ )  {cwe id:CWE-787context:  static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ;  UINT32 tempWidth ;  tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ;  for ( y = 0 ; y < context -> height ; y ++ )  { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; }  } ","UINT32 tempWidth ;if ( ! context || data || ( scanline == 0 ) ) return FALSE ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ;if ( rw < scanline * 2 ) return FALSE ;for ( y = 0 ;y ++ ) {",1678
690,"buggy line: cwe id:CWE-787context:  static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ;  UINT32 tempWidth ;  tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ;  for ( y = 0 ; y < context -> height ; y ++ )  { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; }  } ",return TRUE ;,1678
691,"buggy line: }cwe id:CWE-787context:  static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ;  UINT32 tempWidth ;  tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ;  for ( y = 0 ; y < context -> height ; y ++ )  { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; }  } ",},1678
692,"buggy line: static int isofs_read_inode ( struct inode * inode )  {cwe id:CWE-20context:  static int isofs_read_inode ( struct inode * inode )  { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n"" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n"" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>"" ""(%ld<S2SV_blank>%x).\\n"" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) {  parse_rock_ridge_inode ( de , inode ) ;  if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING ""ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n"" ) ; fail : goto out ; }","static int isofs_read_inode ( struct inode * inode , int relocated ) {",1679
693,"buggy line: parse_rock_ridge_inode ( de , inode ) ;if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;cwe id:CWE-20context:  static int isofs_read_inode ( struct inode * inode )  { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n"" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n"" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>"" ""(%ld<S2SV_blank>%x).\\n"" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) {  parse_rock_ridge_inode ( de , inode ) ;  if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING ""ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n"" ) ; fail : goto out ; }","parse_rock_ridge_inode ( de , inode , relocated ) ;if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;",1679
694,"buggy line: rcu_read_lock ( ) ;__ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ;rcu_read_unlock ( ) ;cwe id:CWE-269context: static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) {  rcu_read_lock ( ) ;   __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ;  rcu_read_unlock ( ) ; }","__ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ;rcu_read_unlock ( ) ;",1680
695,buggy line: ( * re_ast ) -> root_node = NULL ;return ERROR_SUCCESS ;cwe id:CWE-674context: int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ;  ( * re_ast ) -> root_node = NULL ;  return ERROR_SUCCESS ; },( * re_ast ) -> levels = 0 ;( * re_ast ) -> root_node = NULL ;return ERROR_SUCCESS ;,1681
696,"buggy line: rc = cib_tls_signon ( cib , & ( private -> command ) ) ;}rc = cib_tls_signon ( cib , & ( private -> callback ) ) ;}cwe id:CWE-399context: int cib_remote_signon ( cib_t * cib , const char * name , enum cib_conn_type type ) { int rc = pcmk_ok ; cib_remote_opaque_t * private = cib -> variant_opaque ; if ( private -> passwd == NULL ) { struct termios settings ; int rc ; rc = tcgetattr ( 0 , & settings ) ; settings . c_lflag &= ~ ECHO ; rc = tcsetattr ( 0 , TCSANOW , & settings ) ; fprintf ( stderr , ""Password:<S2SV_blank>"" ) ; private -> passwd = calloc ( 1 , 1024 ) ; rc = scanf ( ""%s"" , private -> passwd ) ; fprintf ( stdout , ""\\n"" ) ; if ( rc < 1 ) { private -> passwd = NULL ; } settings . c_lflag |= ECHO ; rc = tcsetattr ( 0 , TCSANOW , & settings ) ; } if ( private -> server == NULL || private -> user == NULL ) { rc = - EINVAL ; } if ( rc == pcmk_ok ) {  rc = cib_tls_signon ( cib , & ( private -> command ) ) ;  } if ( rc == pcmk_ok ) {  rc = cib_tls_signon ( cib , & ( private -> callback ) ) ;  } if ( rc == pcmk_ok ) { xmlNode * hello = cib_create_op ( 0 , private -> callback . token , CRM_OP_REGISTER , NULL , NULL , NULL , 0 , NULL ) ; crm_xml_add ( hello , F_CIB_CLIENTNAME , name ) ; crm_send_remote_msg ( private -> command . session , hello , private -> command . encrypted ) ; free_xml ( hello ) ; } if ( rc == pcmk_ok ) { fprintf ( stderr , ""%s:<S2SV_blank>Opened<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>%s:%d\\n"" , name , private -> server , private -> port ) ; cib -> state = cib_connected_command ; cib -> type = cib_command ; } else { fprintf ( stderr , ""%s:<S2SV_blank>Connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed:<S2SV_blank>%s\\n"" , name , private -> server , private -> port , pcmk_strerror ( rc ) ) ; } return rc ; }","rc = cib_tls_signon ( cib , & ( private -> command ) , FALSE ) ;}rc = cib_tls_signon ( cib , & ( private -> callback ) , TRUE ) ;}",1682
697,"buggy line: msg . msg_name = ( struct sockaddr * ) & address ;msg . msg_namelen = sizeof ( address ) ;if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ;cwe id:CWE-20context: SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) size = INT_MAX ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_iovlen = 1 ; msg . msg_iov = & iov ; iov . iov_len = size ; iov . iov_base = ubuf ;  msg . msg_name = ( struct sockaddr * ) & address ;   msg . msg_namelen = sizeof ( address ) ;  if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }",msg . msg_name = addr ? ( struct sockaddr * ) & address : NULL ;msg . msg_namelen = 0 ;if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ;,1683
698,"buggy line: int num00 , tmp_err , n , sr = 0 ;int step_param = 3 ;int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ;int new_mv_mode_penalty = 256 ;const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ;while ( ( quart_frm << sr ) < MAX_FULL_PEL_VAL ) ++ sr ;tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv ,  step_param ,  x -> sadperbit16 , & num00 , & v_fn_ptr ,  x -> nmvjointcost , x -> mvcost , ref_mv ) ;best_mv -> row = tmp_mv . row ;best_mv -> col = tmp_mv . col ;cwe id:CWE-119context: static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) { MACROBLOCKD * const xd = & x -> e_mbd ; MV tmp_mv = { 0 , 0 } ; MV ref_mv_full = { ref_mv -> row >> 3 , ref_mv -> col >> 3 } ;  int num00 , tmp_err , n , sr = 0 ;  int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ;  int new_mv_mode_penalty = 256 ;   const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ;  while ( ( quart_frm << sr ) < MAX_FULL_PEL_VAL ) ++ sr ; step_param += sr ; further_steps -= sr ; v_fn_ptr . vf = get_block_variance_fn ( bsize ) ;  tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv ,  step_param ,  x -> sadperbit16 , & num00 , & v_fn_ptr ,  x -> nmvjointcost , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ;  best_mv -> row = tmp_mv . row ;  best_mv -> col = tmp_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { ++ n ; if ( num00 ) { -- num00 ; } else {  tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv ,  step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr ,  x -> nmvjointcost ,  x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ;  best_mv -> row = tmp_mv . row ;  best_mv -> col = tmp_mv . col ; } } } }","int num00 , tmp_err , n ;const int new_mv_mode_penalty = NEW_MV_MODE_PENALTY ;int step_param = 3 ;int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ;const int sr = get_search_range ( cpi ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {v_fn_ptr . vf = highbd_get_block_variance_fn ( bsize , xd -> bd ) ;}# endif tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , ref_mv ) ;* best_mv = tmp_mv ;",1684
699,"buggy line: tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv ,  step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr ,  x -> nmvjointcost ,  x -> mvcost , ref_mv ) ;best_mv -> row = tmp_mv . row ;best_mv -> col = tmp_mv . col ;cwe id:CWE-119context: static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) { MACROBLOCKD * const xd = & x -> e_mbd ; MV tmp_mv = { 0 , 0 } ; MV ref_mv_full = { ref_mv -> row >> 3 , ref_mv -> col >> 3 } ;  int num00 , tmp_err , n , sr = 0 ;  int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ;  int new_mv_mode_penalty = 256 ;   const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ;  while ( ( quart_frm << sr ) < MAX_FULL_PEL_VAL ) ++ sr ; step_param += sr ; further_steps -= sr ; v_fn_ptr . vf = get_block_variance_fn ( bsize ) ;  tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv ,  step_param ,  x -> sadperbit16 , & num00 , & v_fn_ptr ,  x -> nmvjointcost , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ;  best_mv -> row = tmp_mv . row ;  best_mv -> col = tmp_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { ++ n ; if ( num00 ) { -- num00 ; } else {  tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv ,  step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr ,  x -> nmvjointcost ,  x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ;  best_mv -> row = tmp_mv . row ;  best_mv -> col = tmp_mv . col ; } } } }","tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , ref_mv ) ;* best_mv = tmp_mv ;",1684
700,"buggy line: SET_ERRNO ( ENOTSUP ,  ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" ,  filename , page_size , off ) ;cwe id:CWE-119context: hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( ""HIVEX_DEBUG"" ) ; if ( debug && STREQ ( debug , ""1"" ) ) h -> msglvl = 2 ; DEBUG ( 2 , ""created<S2SV_blank>handle<S2SV_blank>%p"" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; h -> size = statbuf . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } if ( ! h -> writable ) { h -> addr = mmap ( NULL , h -> size , PROT_READ , MAP_SHARED , h -> fd , 0 ) ; if ( h -> addr == MAP_FAILED ) goto error ; DEBUG ( 2 , ""mapped<S2SV_blank>file<S2SV_blank>at<S2SV_blank>%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == NULL ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1 ; } if ( h -> hdr -> magic [ 0 ] != 'r' || h -> hdr -> magic [ 1 ] != 'e' || h -> hdr -> magic [ 2 ] != 'g' || h -> hdr -> magic [ 3 ] != 'f' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } uint32_t major_ver = le32toh ( h -> hdr -> major_ver ) ; if ( major_ver != 1 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>hive<S2SV_blank>file<S2SV_blank>major<S2SV_blank>version<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(expected<S2SV_blank>1)"" , filename , major_ver ) ; goto error ; } h -> bitmap = calloc ( 1 + h -> size / 32 , 1 ) ; if ( h -> bitmap == NULL ) goto error ; uint32_t sum = header_checksum ( h ) ; if ( sum != le32toh ( h -> hdr -> csum ) ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>hive<S2SV_blank>header"" , filename ) ; goto error ; } h -> last_modified = le64toh ( ( int64_t ) h -> hdr -> last_modified ) ; if ( h -> msglvl >= 2 ) { char * name = _hivex_windows_utf16_to_utf8 ( h -> hdr -> name , 64 ) ; fprintf ( stderr , ""hivex_open:<S2SV_blank>header<S2SV_blank>fields:\\n"" ""<S2SV_blank><S2SV_blank>file<S2SV_blank>version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 "".%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank>sequence<S2SV_blank>nos<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 ""<S2SV_blank>%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(sequences<S2SV_blank>nos<S2SV_blank>should<S2SV_blank>match<S2SV_blank>if<S2SV_blank>hive<S2SV_blank>was<S2SV_blank>synched<S2SV_blank>at<S2SV_blank>shutdown)\\n"" ""<S2SV_blank><S2SV_blank>last<S2SV_blank>modified<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu64 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Windows<S2SV_blank>filetime,<S2SV_blank>x<S2SV_blank>100<S2SV_blank>ns<S2SV_blank>since<S2SV_blank>1601-01-01)\\n"" ""<S2SV_blank><S2SV_blank>original<S2SV_blank>file<S2SV_blank>name<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(only<S2SV_blank>32<S2SV_blank>chars<S2SV_blank>are<S2SV_blank>stored,<S2SV_blank>name<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>truncated)\\n"" ""<S2SV_blank><S2SV_blank>root<S2SV_blank>offset<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000\\n"" ""<S2SV_blank><S2SV_blank>end<S2SV_blank>of<S2SV_blank>last<S2SV_blank>page<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000<S2SV_blank>(total<S2SV_blank>file<S2SV_blank>size<S2SV_blank>0x%zx)\\n"" ""<S2SV_blank><S2SV_blank>checksum<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>(calculated<S2SV_blank>0x%x)\\n"" , major_ver , le32toh ( h -> hdr -> minor_ver ) , le32toh ( h -> hdr -> sequence1 ) , le32toh ( h -> hdr -> sequence2 ) , h -> last_modified , name ? name : ""(conversion<S2SV_blank>failed)"" , le32toh ( h -> hdr -> offset ) , le32toh ( h -> hdr -> blocks ) , h -> size , le32toh ( h -> hdr -> csum ) , sum ) ; free ( name ) ; } h -> rootoffs = le32toh ( h -> hdr -> offset ) + 0x1000 ; h -> endpages = le32toh ( h -> hdr -> blocks ) + 0x1000 ; DEBUG ( 2 , ""root<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>0x%zx"" , h -> rootoffs ) ; int seen_root_block = 0 , bad_root_block = 0 ; size_t pages = 0 ; size_t smallest_page = SIZE_MAX , largest_page = 0 ; size_t blocks = 0 ; size_t smallest_block = SIZE_MAX , largest_block = 0 , blocks_bytes = 0 ; size_t used_blocks = 0 ; size_t used_size = 0 ; size_t off ; struct ntreg_hbin_page * page ; for ( off = 0x1000 ; off < h -> size ; off += le32toh ( page -> page_size ) ) { if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] != 'h' || page -> magic [ 1 ] != 'b' || page -> magic [ 2 ] != 'i' || page -> magic [ 3 ] != 'n' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>"" ""(at<S2SV_blank>0x%zx,<S2SV_blank>after<S2SV_blank>%zu<S2SV_blank>pages)"" , filename , off , pages ) ; goto error ; } size_t page_size = le32toh ( page -> page_size ) ; DEBUG ( 2 , ""page<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>size<S2SV_blank>%zu"" , off , page_size ) ; pages ++ ; if ( page_size < smallest_page ) smallest_page = page_size ; if ( page_size > largest_page ) largest_page = page_size ; if ( page_size <= sizeof ( struct ntreg_hbin_page ) || ( page_size & 0x0fff ) != 0 ) { SET_ERRNO ( ENOTSUP ,  ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" ,  filename , page_size , off ) ; goto error ; } size_t blkoff ; struct ntreg_hbin_block * block ; size_t seg_len ; for ( blkoff = off + 0x20 ; blkoff < off + page_size ; blkoff += seg_len ) { blocks ++ ; int is_root = blkoff == h -> rootoffs ; if ( is_root ) seen_root_block = 1 ; block = ( struct ntreg_hbin_block * ) ( ( char * ) h -> addr + blkoff ) ; int used ; seg_len = block_len ( h , blkoff , & used ) ; if ( seg_len <= 4 || ( seg_len & 3 ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%"" PRIu32 ""<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , le32toh ( block -> seg_len ) , blkoff ) ; goto error ; } if ( h -> msglvl >= 2 ) { unsigned char * id = ( unsigned char * ) block -> id ; int id0 = id [ 0 ] , id1 = id [ 1 ] ; fprintf ( stderr , ""%s:<S2SV_blank>%s:<S2SV_blank>"" ""%s<S2SV_blank>block<S2SV_blank>id<S2SV_blank>%d,%d<S2SV_blank>(%c%c)<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>size<S2SV_blank>%zu%s\\n"" , ""hivex"" , __func__ , used ? ""used"" : ""free"" , id0 , id1 , c_isprint ( id0 ) ? id0 : '.' , c_isprint ( id1 ) ? id1 : '.' , blkoff , seg_len , is_root ? ""<S2SV_blank>(root)"" : """" ) ; } blocks_bytes += seg_len ; if ( seg_len < smallest_block ) smallest_block = seg_len ; if ( seg_len > largest_block ) largest_block = seg_len ; if ( is_root && ! used ) bad_root_block = 1 ; if ( used ) { used_blocks ++ ; used_size += seg_len ; if ( is_root && ( block -> id [ 0 ] != 'n' || block -> id [ 1 ] != 'k' ) ) bad_root_block = 1 ; BITMAP_SET ( h -> bitmap , blkoff ) ; } } } if ( ! seen_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>no<S2SV_blank>root<S2SV_blank>block<S2SV_blank>found"" , filename ) ; goto error ; } if ( bad_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>bad<S2SV_blank>root<S2SV_blank>block<S2SV_blank>(free<S2SV_blank>or<S2SV_blank>not<S2SV_blank>nk)"" , filename ) ; goto error ; } DEBUG ( 1 , ""successfully<S2SV_blank>read<S2SV_blank>Windows<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file:\\n"" ""<S2SV_blank><S2SV_blank>pages:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>avg:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu\\n"" ""<S2SV_blank><S2SV_blank>bytes<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu"" , pages , smallest_page , largest_page , blocks , smallest_block , blocks_bytes / blocks , largest_block , used_blocks , used_size ) ; return h ; error : ; int err = errno ; if ( h ) { free ( h -> bitmap ) ; if ( h -> addr && h -> size && h -> addr != MAP_FAILED ) { if ( ! h -> writable ) munmap ( h -> addr , h -> size ) ; else free ( h -> addr ) ; } if ( h -> fd >= 0 ) close ( h -> fd ) ; free ( h -> filename ) ; free ( h ) ; } errno = err ; return NULL ; }","SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ;goto error ;}if ( off + page_size > h -> size ) {SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>extends<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ;",1685
701,"buggy line: return merged ;}cwe id:CWE-611context: void * merge_directory_configs ( apr_pool_t * mp , void * _parent , void * _child ) { directory_config * parent = ( directory_config * ) _parent ; directory_config * child = ( directory_config * ) _child ; directory_config * merged = create_directory_config ( mp , NULL ) ; # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Merge<S2SV_blank>parent<S2SV_blank>%pp<S2SV_blank>child<S2SV_blank>%pp<S2SV_blank>RESULT<S2SV_blank>%pp"" , _parent , _child , merged ) ; # endif if ( merged == NULL ) return NULL ; merged -> is_enabled = ( child -> is_enabled == NOT_SET ? parent -> is_enabled : child -> is_enabled ) ; merged -> reqbody_access = ( child -> reqbody_access == NOT_SET ? parent -> reqbody_access : child -> reqbody_access ) ; merged -> reqbody_buffering = ( child -> reqbody_buffering == NOT_SET ? parent -> reqbody_buffering : child -> reqbody_buffering ) ; merged -> reqbody_inmemory_limit = ( child -> reqbody_inmemory_limit == NOT_SET ? parent -> reqbody_inmemory_limit : child -> reqbody_inmemory_limit ) ; merged -> reqbody_limit = ( child -> reqbody_limit == NOT_SET ? parent -> reqbody_limit : child -> reqbody_limit ) ; merged -> reqbody_no_files_limit = ( child -> reqbody_no_files_limit == NOT_SET ? parent -> reqbody_no_files_limit : child -> reqbody_no_files_limit ) ; merged -> resbody_access = ( child -> resbody_access == NOT_SET ? parent -> resbody_access : child -> resbody_access ) ; merged -> of_limit = ( child -> of_limit == NOT_SET ? parent -> of_limit : child -> of_limit ) ; merged -> if_limit_action = ( child -> if_limit_action == NOT_SET ? parent -> if_limit_action : child -> if_limit_action ) ; merged -> of_limit_action = ( child -> of_limit_action == NOT_SET ? parent -> of_limit_action : child -> of_limit_action ) ; merged -> reqintercept_oe = ( child -> reqintercept_oe == NOT_SET ? parent -> reqintercept_oe : child -> reqintercept_oe ) ; if ( child -> of_mime_types != NOT_SET_P ) { if ( child -> of_mime_types_cleared == 1 ) { merged -> of_mime_types = child -> of_mime_types ; merged -> of_mime_types_cleared = 1 ; } else { if ( parent -> of_mime_types == NOT_SET_P ) { merged -> of_mime_types = child -> of_mime_types ; merged -> of_mime_types_cleared = NOT_SET ; } else { merged -> of_mime_types = apr_table_overlay ( mp , parent -> of_mime_types , child -> of_mime_types ) ; if ( merged -> of_mime_types == NULL ) return NULL ; } } } else { if ( child -> of_mime_types_cleared == 1 ) { merged -> of_mime_types_cleared = 1 ; } else { merged -> of_mime_types = parent -> of_mime_types ; merged -> of_mime_types_cleared = parent -> of_mime_types_cleared ; } } if ( child -> debuglog_fd == NOT_SET_P ) { merged -> debuglog_name = parent -> debuglog_name ; merged -> debuglog_fd = parent -> debuglog_fd ; } else { merged -> debuglog_name = child -> debuglog_name ; merged -> debuglog_fd = child -> debuglog_fd ; } merged -> debuglog_level = ( child -> debuglog_level == NOT_SET ? parent -> debuglog_level : child -> debuglog_level ) ; merged -> cookie_format = ( child -> cookie_format == NOT_SET ? parent -> cookie_format : child -> cookie_format ) ; merged -> argument_separator = ( child -> argument_separator == NOT_SET ? parent -> argument_separator : child -> argument_separator ) ; merged -> cookiev0_separator = ( child -> cookiev0_separator == NOT_SET_P ? parent -> cookiev0_separator : child -> cookiev0_separator ) ; if ( ( child -> rule_inheritance == NOT_SET ) || ( child -> rule_inheritance == 1 ) ) { merged -> rule_inheritance = parent -> rule_inheritance ; if ( ( child -> ruleset == NULL ) && ( parent -> ruleset == NULL ) ) { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""No<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif } else if ( child -> ruleset == NULL ) { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Using<S2SV_blank>parent<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( parent -> ruleset -> engine , mp ) ; copy_rules ( mp , parent -> ruleset , merged -> ruleset , child -> rule_exceptions ) ; } else if ( parent -> ruleset == NULL ) { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Using<S2SV_blank>child<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( child -> ruleset -> engine , mp ) ; merged -> ruleset -> phase_request_headers = apr_array_copy ( mp , child -> ruleset -> phase_request_headers ) ; merged -> ruleset -> phase_request_body = apr_array_copy ( mp , child -> ruleset -> phase_request_body ) ; merged -> ruleset -> phase_response_headers = apr_array_copy ( mp , child -> ruleset -> phase_response_headers ) ; merged -> ruleset -> phase_response_body = apr_array_copy ( mp , child -> ruleset -> phase_response_body ) ; merged -> ruleset -> phase_logging = apr_array_copy ( mp , child -> ruleset -> phase_logging ) ; } else { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Using<S2SV_blank>parent<S2SV_blank>then<S2SV_blank>child<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( parent -> ruleset -> engine , mp ) ; copy_rules ( mp , parent -> ruleset , merged -> ruleset , child -> rule_exceptions ) ; apr_array_cat ( merged -> ruleset -> phase_request_headers , child -> ruleset -> phase_request_headers ) ; apr_array_cat ( merged -> ruleset -> phase_request_body , child -> ruleset -> phase_request_body ) ; apr_array_cat ( merged -> ruleset -> phase_response_headers , child -> ruleset -> phase_response_headers ) ; apr_array_cat ( merged -> ruleset -> phase_response_body , child -> ruleset -> phase_response_body ) ; apr_array_cat ( merged -> ruleset -> phase_logging , child -> ruleset -> phase_logging ) ; } } else { merged -> rule_inheritance = 0 ; if ( child -> ruleset != NULL ) { merged -> ruleset = msre_ruleset_create ( child -> ruleset -> engine , mp ) ; merged -> ruleset -> phase_request_headers = apr_array_copy ( mp , child -> ruleset -> phase_request_headers ) ; merged -> ruleset -> phase_request_body = apr_array_copy ( mp , child -> ruleset -> phase_request_body ) ; merged -> ruleset -> phase_response_headers = apr_array_copy ( mp , child -> ruleset -> phase_response_headers ) ; merged -> ruleset -> phase_response_body = apr_array_copy ( mp , child -> ruleset -> phase_response_body ) ; merged -> ruleset -> phase_logging = apr_array_copy ( mp , child -> ruleset -> phase_logging ) ; } } merged -> rule_exceptions = apr_array_append ( mp , parent -> rule_exceptions , child -> rule_exceptions ) ; merged -> hash_method = apr_array_append ( mp , parent -> hash_method , child -> hash_method ) ; merged -> auditlog_flag = ( child -> auditlog_flag == NOT_SET ? parent -> auditlog_flag : child -> auditlog_flag ) ; merged -> auditlog_type = ( child -> auditlog_type == NOT_SET ? parent -> auditlog_type : child -> auditlog_type ) ; merged -> max_rule_time = ( child -> max_rule_time == NOT_SET ? parent -> max_rule_time : child -> max_rule_time ) ; merged -> auditlog_dirperms = ( child -> auditlog_dirperms == NOT_SET ? parent -> auditlog_dirperms : child -> auditlog_dirperms ) ; merged -> auditlog_fileperms = ( child -> auditlog_fileperms == NOT_SET ? parent -> auditlog_fileperms : child -> auditlog_fileperms ) ; if ( child -> auditlog_fd != NOT_SET_P ) { merged -> auditlog_fd = child -> auditlog_fd ; merged -> auditlog_name = child -> auditlog_name ; } else { merged -> auditlog_fd = parent -> auditlog_fd ; merged -> auditlog_name = parent -> auditlog_name ; } if ( child -> auditlog2_fd != NOT_SET_P ) { merged -> auditlog2_fd = child -> auditlog2_fd ; merged -> auditlog2_name = child -> auditlog2_name ; } else { merged -> auditlog2_fd = parent -> auditlog2_fd ; merged -> auditlog2_name = parent -> auditlog2_name ; } merged -> auditlog_storage_dir = ( child -> auditlog_storage_dir == NOT_SET_P ? parent -> auditlog_storage_dir : child -> auditlog_storage_dir ) ; merged -> auditlog_parts = ( child -> auditlog_parts == NOT_SET_P ? parent -> auditlog_parts : child -> auditlog_parts ) ; merged -> auditlog_relevant_regex = ( child -> auditlog_relevant_regex == NOT_SET_P ? parent -> auditlog_relevant_regex : child -> auditlog_relevant_regex ) ; merged -> tmp_dir = ( child -> tmp_dir == NOT_SET_P ? parent -> tmp_dir : child -> tmp_dir ) ; merged -> upload_dir = ( child -> upload_dir == NOT_SET_P ? parent -> upload_dir : child -> upload_dir ) ; merged -> upload_keep_files = ( child -> upload_keep_files == NOT_SET ? parent -> upload_keep_files : child -> upload_keep_files ) ; merged -> upload_validates_files = ( child -> upload_validates_files == NOT_SET ? parent -> upload_validates_files : child -> upload_validates_files ) ; merged -> upload_filemode = ( child -> upload_filemode == NOT_SET ? parent -> upload_filemode : child -> upload_filemode ) ; merged -> upload_file_limit = ( child -> upload_file_limit == NOT_SET ? parent -> upload_file_limit : child -> upload_file_limit ) ; merged -> data_dir = ( child -> data_dir == NOT_SET_P ? parent -> data_dir : child -> data_dir ) ; merged -> webappid = ( child -> webappid == NOT_SET_P ? parent -> webappid : child -> webappid ) ; merged -> sensor_id = ( child -> sensor_id == NOT_SET_P ? parent -> sensor_id : child -> sensor_id ) ; merged -> httpBlkey = ( child -> httpBlkey == NOT_SET_P ? parent -> httpBlkey : child -> httpBlkey ) ; merged -> content_injection_enabled = ( child -> content_injection_enabled == NOT_SET ? parent -> content_injection_enabled : child -> content_injection_enabled ) ; merged -> stream_inbody_inspection = ( child -> stream_inbody_inspection == NOT_SET ? parent -> stream_inbody_inspection : child -> stream_inbody_inspection ) ; merged -> stream_outbody_inspection = ( child -> stream_outbody_inspection == NOT_SET ? parent -> stream_outbody_inspection : child -> stream_outbody_inspection ) ; merged -> geo = ( child -> geo == NOT_SET_P ? parent -> geo : child -> geo ) ; merged -> gsb = ( child -> gsb == NOT_SET_P ? parent -> gsb : child -> gsb ) ; merged -> u_map = ( child -> u_map == NOT_SET_P ? parent -> u_map : child -> u_map ) ; merged -> cache_trans = ( child -> cache_trans == NOT_SET ? parent -> cache_trans : child -> cache_trans ) ; merged -> cache_trans_incremental = ( child -> cache_trans_incremental == NOT_SET ? parent -> cache_trans_incremental : child -> cache_trans_incremental ) ; merged -> cache_trans_min = ( child -> cache_trans_min == ( apr_size_t ) NOT_SET ? parent -> cache_trans_min : child -> cache_trans_min ) ; merged -> cache_trans_max = ( child -> cache_trans_max == ( apr_size_t ) NOT_SET ? parent -> cache_trans_max : child -> cache_trans_max ) ; merged -> cache_trans_maxitems = ( child -> cache_trans_maxitems == ( apr_size_t ) NOT_SET ? parent -> cache_trans_maxitems : child -> cache_trans_maxitems ) ; merged -> component_signatures = apr_array_append ( mp , parent -> component_signatures , child -> component_signatures ) ; merged -> request_encoding = ( child -> request_encoding == NOT_SET_P ? parent -> request_encoding : child -> request_encoding ) ; merged -> disable_backend_compression = ( child -> disable_backend_compression == NOT_SET ? parent -> disable_backend_compression : child -> disable_backend_compression ) ; merged -> col_timeout = ( child -> col_timeout == NOT_SET ? parent -> col_timeout : child -> col_timeout ) ; merged -> crypto_key = ( child -> crypto_key == NOT_SET_P ? parent -> crypto_key : child -> crypto_key ) ; merged -> crypto_key_len = ( child -> crypto_key_len == NOT_SET ? parent -> crypto_key_len : child -> crypto_key_len ) ; merged -> crypto_key_add = ( child -> crypto_key_add == NOT_SET ? parent -> crypto_key_add : child -> crypto_key_add ) ; merged -> crypto_param_name = ( child -> crypto_param_name == NOT_SET_P ? parent -> crypto_param_name : child -> crypto_param_name ) ; merged -> hash_is_enabled = ( child -> hash_is_enabled == NOT_SET ? parent -> hash_is_enabled : child -> hash_is_enabled ) ; merged -> hash_enforcement = ( child -> hash_enforcement == NOT_SET ? parent -> hash_enforcement : child -> hash_enforcement ) ; merged -> crypto_hash_href_rx = ( child -> crypto_hash_href_rx == NOT_SET ? parent -> crypto_hash_href_rx : child -> crypto_hash_href_rx ) ; merged -> crypto_hash_faction_rx = ( child -> crypto_hash_faction_rx == NOT_SET ? parent -> crypto_hash_faction_rx : child -> crypto_hash_faction_rx ) ; merged -> crypto_hash_location_rx = ( child -> crypto_hash_location_rx == NOT_SET ? parent -> crypto_hash_location_rx : child -> crypto_hash_location_rx ) ; merged -> crypto_hash_iframesrc_rx = ( child -> crypto_hash_iframesrc_rx == NOT_SET ? parent -> crypto_hash_iframesrc_rx : child -> crypto_hash_iframesrc_rx ) ; merged -> crypto_hash_framesrc_rx = ( child -> crypto_hash_framesrc_rx == NOT_SET ? parent -> crypto_hash_framesrc_rx : child -> crypto_hash_framesrc_rx ) ; merged -> crypto_hash_href_pm = ( child -> crypto_hash_href_pm == NOT_SET ? parent -> crypto_hash_href_pm : child -> crypto_hash_href_pm ) ; merged -> crypto_hash_faction_pm = ( child -> crypto_hash_faction_pm == NOT_SET ? parent -> crypto_hash_faction_pm : child -> crypto_hash_faction_pm ) ; merged -> crypto_hash_location_pm = ( child -> crypto_hash_location_pm == NOT_SET ? parent -> crypto_hash_location_pm : child -> crypto_hash_location_pm ) ; merged -> crypto_hash_iframesrc_pm = ( child -> crypto_hash_iframesrc_pm == NOT_SET ? parent -> crypto_hash_iframesrc_pm : child -> crypto_hash_iframesrc_pm ) ; merged -> crypto_hash_framesrc_pm = ( child -> crypto_hash_framesrc_pm == NOT_SET ? parent -> crypto_hash_framesrc_pm : child -> crypto_hash_framesrc_pm ) ;  return merged ;  }",merged -> xml_external_entity = ( child -> xml_external_entity == NOT_SET ? parent -> xml_external_entity : child -> xml_external_entity ) ;return merged ;},1686
702,"buggy line: if ( used_address && used_address -> name_len == msg_sys -> msg_namelen &&   ! memcmp ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ) {memcpy ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ;cwe id:CWE-476context: static int __sys_sendmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned flags , struct used_address * used_address ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct sockaddr_storage address ; struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; unsigned char ctl [ sizeof ( struct cmsghdr ) + 20 ] __attribute__ ( ( aligned ( sizeof ( __kernel_size_t ) ) ) ) ; unsigned char * ctl_buf = ctl ; int err , ctl_len , iov_size , total_len ; err = - EFAULT ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) ) return - EFAULT ; err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ) ; if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ) ; if ( ! iov ) goto out ; } if ( MSG_CMSG_COMPAT & flags ) { err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; } else err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; err = - ENOBUFS ; if ( msg_sys -> msg_controllen > INT_MAX ) goto out_freeiov ; ctl_len = msg_sys -> msg_controllen ; if ( ( MSG_CMSG_COMPAT & flags ) && ctl_len ) { err = cmsghdr_from_user_compat_to_kern ( msg_sys , sock -> sk , ctl , sizeof ( ctl ) ) ; if ( err ) goto out_freeiov ; ctl_buf = msg_sys -> msg_control ; ctl_len = msg_sys -> msg_controllen ; } else if ( ctl_len ) { if ( ctl_len > sizeof ( ctl ) ) { ctl_buf = sock_kmalloc ( sock -> sk , ctl_len , GFP_KERNEL ) ; if ( ctl_buf == NULL ) goto out_freeiov ; } err = - EFAULT ; if ( copy_from_user ( ctl_buf , ( void __user __force * ) msg_sys -> msg_control , ctl_len ) ) goto out_freectl ; msg_sys -> msg_control = ctl_buf ; } msg_sys -> msg_flags = flags ; if ( sock -> file -> f_flags & O_NONBLOCK ) msg_sys -> msg_flags |= MSG_DONTWAIT ;  if ( used_address && used_address -> name_len == msg_sys -> msg_namelen &&   ! memcmp ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ) { err = sock_sendmsg_nosec ( sock , msg_sys , total_len ) ; goto out_freectl ; } err = sock_sendmsg ( sock , msg_sys , total_len ) ; if ( used_address && err >= 0 ) { used_address -> name_len = msg_sys -> msg_namelen ;  memcpy ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ; } out_freectl : if ( ctl_buf != ctl ) sock_kfree_s ( sock -> sk , ctl_buf , ctl_len ) ; out_freeiov : if ( iov != iovstack ) sock_kfree_s ( sock -> sk , iov , iov_size ) ; out : return err ; }","if ( used_address && msg_sys -> msg_name && used_address -> name_len == msg_sys -> msg_namelen && ! memcmp ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) ) {if ( msg_sys -> msg_name ) memcpy ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) ;",1687
703,"buggy line: struct skcipher_ctx * ctx = ask -> private ;unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ;struct skcipher_sg_list * sgl ;struct scatterlist * sg ;unsigned long iovlen ;struct iovec * iov ;int err = - EAGAIN ;int used ;long copied = 0 ;lock_sock ( sk ) ;msg -> msg_namelen = 0 ;cwe id:CWE-20context: static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ;  lock_sock ( sk ) ;  msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }","
",1688
704,"buggy line: size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one ,  offset ,  pixel_info_length ;ssize_t count , y ;if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;cwe id:CWE-119context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one ,  offset ,  pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ;  if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ;  p = pixels + offset ;   if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ;ssize_t count , offset , y ;if ( ( offset < 0 ) || ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;",1689
705,"buggy line: if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  {cwe id:CWE-119context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one ,  offset ,  pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ;  if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ;  p = pixels + offset ;   if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {,1689
706,"buggy line: p = pixels + offset ;if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  {cwe id:CWE-119context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one ,  offset ,  pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ;  if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ;  p = pixels + offset ;   if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;}p = pixels + offset ;if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) {",1689
707,"buggy line: if ( ( r = cipher_get_keyiv ( cc , enc -> iv , enc -> iv_len ) ) != 0 ) return r ;if ( ( b = sshbuf_new ( ) ) == NULL ) return SSH_ERR_ALLOC_FAIL ;if ( ( r = sshbuf_put_u32 ( b , comp -> type ) ) != 0 ||  ( r = sshbuf_put_u32 ( b , comp -> enabled ) ) != 0 ||  ( r = sshbuf_put_cstring ( b , comp -> name ) ) != 0 ) goto out ;cwe id:CWE-119context: static int newkeys_to_blob ( struct sshbuf * m , struct ssh * ssh , int mode ) { struct sshbuf * b ; struct sshcipher_ctx * cc ; struct sshcomp * comp ; struct sshenc * enc ; struct sshmac * mac ; struct newkeys * newkey ; int r ; if ( ( newkey = ssh -> state -> newkeys [ mode ] ) == NULL ) return SSH_ERR_INTERNAL_ERROR ; enc = & newkey -> enc ; mac = & newkey -> mac ; comp = & newkey -> comp ; cc = ( mode == MODE_OUT ) ? ssh -> state -> send_context : ssh -> state -> receive_context ; if ( ( r = cipher_get_keyiv ( cc , enc -> iv , enc -> iv_len ) ) != 0 ) return r ; if ( ( b = sshbuf_new ( ) ) == NULL ) return SSH_ERR_ALLOC_FAIL ; if ( ( r = sshbuf_put_cstring ( b , enc -> name ) ) != 0 || ( r = sshbuf_put ( b , & enc -> cipher , sizeof ( enc -> cipher ) ) ) != 0 || ( r = sshbuf_put_u32 ( b , enc -> enabled ) ) != 0 || ( r = sshbuf_put_u32 ( b , enc -> block_size ) ) != 0 || ( r = sshbuf_put_string ( b , enc -> key , enc -> key_len ) ) != 0 || ( r = sshbuf_put_string ( b , enc -> iv , enc -> iv_len ) ) != 0 ) goto out ; if ( cipher_authlen ( enc -> cipher ) == 0 ) { if ( ( r = sshbuf_put_cstring ( b , mac -> name ) ) != 0 || ( r = sshbuf_put_u32 ( b , mac -> enabled ) ) != 0 || ( r = sshbuf_put_string ( b , mac -> key , mac -> key_len ) ) != 0 ) goto out ; } if ( ( r = sshbuf_put_u32 ( b , comp -> type ) ) != 0 ||  ( r = sshbuf_put_u32 ( b , comp -> enabled ) ) != 0 ||  ( r = sshbuf_put_cstring ( b , comp -> name ) ) != 0 ) goto out ; r = sshbuf_put_stringb ( m , b ) ; out : sshbuf_free ( b ) ; return r ; }","if ( ( r = sshbuf_put_u32 ( b , comp -> type ) ) != 0 || ( r = sshbuf_put_u32 ( b , comp -> enabled ) ) != 0 || ( r = sshbuf_put_cstring ( b , comp -> name ) ) != 0 ) goto out ;",1690
708,"buggy line: option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;cwe id:CWE-000context: static int traceDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * option , * ovalue , * tok ; route = state -> route ; route -> trace = httpCreateTrace ( route -> trace ) ; for ( option = stok ( sclone ( value ) , ""<S2SV_blank>\\t"" , & tok ) ; option ; option = stok ( 0 , ""<S2SV_blank>\\t"" , & tok ) ) {  option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ;  ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( smatch ( option , ""content"" ) ) { httpSetTraceContentSize ( route -> trace , ( ssize ) getnum ( ovalue ) ) ; } else { httpSetTraceEventLevel ( route -> trace , option , atoi ( ovalue ) ) ; } } return 0 ; }","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",1691
709,"buggy line: cib_client_t * client = user_data ;if ( client == NULL ) {cwe id:CWE-399context: void cib_remote_connection_destroy ( gpointer user_data ) {  cib_client_t * client = user_data ;  if ( client == NULL ) { return ; } crm_trace ( ""Cleaning<S2SV_blank>up<S2SV_blank>after<S2SV_blank>client<S2SV_blank>disconnect:<S2SV_blank>%s/%s"" , crm_str ( client -> name ) , client -> id ) ; if ( client -> id != NULL ) { if ( ! g_hash_table_remove ( client_list , client -> id ) ) { crm_err ( ""Client<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>hashtable"" , client -> name ) ; } } crm_trace ( ""Destroying<S2SV_blank>%s<S2SV_blank>(%p)"" , client -> name , user_data ) ; num_clients -- ; crm_trace ( ""Num<S2SV_blank>unfree\'d<S2SV_blank>clients:<S2SV_blank>%d"" , num_clients ) ;  free ( client -> name ) ;  free ( client -> callback_id ) ; free ( client -> id ) ; free ( client -> user ) ;  free ( client ) ;  crm_trace ( ""Freed<S2SV_blank>the<S2SV_blank>cib<S2SV_blank>client"" ) ; if ( cib_shutdown_flag ) { cib_shutdown ( 0 ) ; } return ; }",cib_client_t * client = user_data ;int csock = 0 ;if ( client == NULL ) {,1692
710,"buggy line: free ( client -> name ) ;free ( client -> callback_id ) ;free ( client ) ;crm_trace ( ""Freed<S2SV_blank>the<S2SV_blank>cib<S2SV_blank>client"" ) ;cwe id:CWE-399context: void cib_remote_connection_destroy ( gpointer user_data ) {  cib_client_t * client = user_data ;  if ( client == NULL ) { return ; } crm_trace ( ""Cleaning<S2SV_blank>up<S2SV_blank>after<S2SV_blank>client<S2SV_blank>disconnect:<S2SV_blank>%s/%s"" , crm_str ( client -> name ) , client -> id ) ; if ( client -> id != NULL ) { if ( ! g_hash_table_remove ( client_list , client -> id ) ) { crm_err ( ""Client<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>hashtable"" , client -> name ) ; } } crm_trace ( ""Destroying<S2SV_blank>%s<S2SV_blank>(%p)"" , client -> name , user_data ) ; num_clients -- ; crm_trace ( ""Num<S2SV_blank>unfree\'d<S2SV_blank>clients:<S2SV_blank>%d"" , num_clients ) ;  free ( client -> name ) ;  free ( client -> callback_id ) ; free ( client -> id ) ; free ( client -> user ) ;  free ( client ) ;  crm_trace ( ""Freed<S2SV_blank>the<S2SV_blank>cib<S2SV_blank>client"" ) ; if ( cib_shutdown_flag ) { cib_shutdown ( 0 ) ; } return ; }","if ( client -> remote_auth_timeout ) {g_source_remove ( client -> remote_auth_timeout ) ;}if ( client -> encrypted ) {# ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> session ) {void * sock_ptr = gnutls_transport_get_ptr ( * client -> session ) ;csock = GPOINTER_TO_INT ( sock_ptr ) ;if ( client -> handshake_complete ) {gnutls_bye ( * client -> session , GNUTLS_SHUT_WR ) ;}gnutls_deinit ( * client -> session ) ;gnutls_free ( client -> session ) ;}# endif }else {csock = GPOINTER_TO_INT ( client -> session ) ;}client -> session = NULL ;if ( csock > 0 ) {close ( csock ) ;}free ( client -> recv_buf ) ;free ( client -> name ) ;free ( client -> callback_id ) ;free ( client ) ;crm_trace ( ""Freed<S2SV_blank>the<S2SV_blank>cib<S2SV_blank>client"" ) ;",1692
711,"buggy line: * p = thread -> twups ;thread -> twups = thread ;work ++ ;if ( ! iswhite ( uv ) ) markvalue ( g , uv -> v ) ;cwe id:CWE-763context: static int remarkupvals ( global_State * g ) { lua_State * thread ; lua_State * * p = & g -> twups ; int work = 0 ; while ( ( thread = * p ) != NULL ) { work ++ ; lua_assert ( ! isblack ( thread ) ) ; if ( isgray ( thread ) && thread -> openupval != NULL ) p = & thread -> twups ; else { UpVal * uv ;  * p = thread -> twups ;  thread -> twups = thread ; for ( uv = thread -> openupval ; uv != NULL ; uv = uv -> u . open . next ) {  work ++ ;  if ( ! iswhite ( uv ) ) markvalue ( g , uv -> v ) ; } } } return work ; }","lua_assert ( ! isold ( thread ) || thread -> openupval == NULL ) ;* p = thread -> twups ;thread -> twups = thread ;lua_assert ( getage ( uv ) <= getage ( thread ) ) ;work ++ ;if ( ! iswhite ( uv ) ) markvalue ( g , uv -> v ) ;",1693
712,"buggy line: px -> ft -> data = px ;px -> ft -> accept = prpl_xfer_accept ;cwe id:CWE-476context: static gboolean prplcb_xfer_new_send_cb ( gpointer data , gint fd , b_input_condition cond ) { PurpleXfer * xfer = data ; struct im_connection * ic = purple_ic_by_pa ( xfer -> account ) ; struct prpl_xfer_data * px = xfer -> ui_data ; PurpleBuddy * buddy ; const char * who ; buddy = purple_find_buddy ( xfer -> account , xfer -> who ) ; who = buddy ? purple_buddy_get_name ( buddy ) : xfer -> who ; px -> ft = imcb_file_send_start ( ic , ( char * ) who , xfer -> filename , xfer -> size ) ;  px -> ft -> data = px ;  px -> ft -> accept = prpl_xfer_accept ; px -> ft -> canceled = prpl_xfer_canceled ; px -> ft -> free = prpl_xfer_free ; px -> ft -> write_request = prpl_xfer_write_request ; return FALSE ; }",if ( ! px -> ft ) {return FALSE ;}px -> ft -> data = px ;px -> ft -> accept = prpl_xfer_accept ;,1694
713,"buggy line: return FALSE ;}cwe id:CWE-476context: BOOL transport_connect_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> layer == TRANSPORT_LAYER_TSG ) return TRUE ; if ( ! transport_connect_tls ( transport ) ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { if ( ! connectErrorCode ) connectErrorCode = AUTHENTICATIONERROR ; fprintf ( stderr , ""Authentication<S2SV_blank>failure,<S2SV_blank>check<S2SV_blank>credentials.\\n"" ""If<S2SV_blank>credentials<S2SV_blank>are<S2SV_blank>valid,<S2SV_blank>the<S2SV_blank>NTLMSSP<S2SV_blank>implementation<S2SV_blank>may<S2SV_blank>be<S2SV_blank>to<S2SV_blank>blame.\\n"" ) ; credssp_free ( transport -> credssp ) ;  return FALSE ;  } credssp_free ( transport -> credssp ) ; return TRUE ; }",transport -> credssp = NULL ;return FALSE ;},1695
714,"buggy line: olddentry = ovl_dentry_upper ( old ) ;newdentry = ovl_dentry_upper ( new ) ;if ( newdentry ) {newdentry = opaquedir ;opaquedir = NULL ;dget ( newdentry ) ;newdentry = lookup_one_len ( new -> d_name . name , new_upperdir ,  new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) )  goto out_unlock ;}err = - ESTALE ;if ( olddentry -> d_parent != old_upperdir )  goto out_dput ;if ( newdentry -> d_parent != new_upperdir )   goto out_dput ;if ( olddentry == trap ) goto out_dput ;if ( newdentry == trap ) goto out_dput ;cwe id:CWE-20context: static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_lower ( old ) -> d_inode == ovl_dentry_lower ( new ) -> d_inode ) goto out ; } if ( OVL_TYPE_UPPER ( new_type ) && OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_upper ( old ) -> d_inode == ovl_dentry_upper ( new ) -> d_inode ) goto out ; } } else { if ( ovl_dentry_is_opaque ( new ) ) new_type = __OVL_PATH_UPPER ; else new_type = __OVL_PATH_UPPER | __OVL_PATH_PURE ; } err = ovl_want_write ( old ) ; if ( err ) goto out ; err = ovl_copy_up ( old ) ; if ( err ) goto out_drop_write ; err = ovl_copy_up ( new -> d_parent ) ; if ( err ) goto out_drop_write ; if ( ! overwrite ) { err = ovl_copy_up ( new ) ; if ( err ) goto out_drop_write ; } old_opaque = ! OVL_TYPE_PURE_UPPER ( old_type ) ; new_opaque = ! OVL_TYPE_PURE_UPPER ( new_type ) ; if ( old_opaque || new_opaque ) { err = - ENOMEM ; override_cred = prepare_creds ( ) ; if ( ! override_cred ) goto out_drop_write ; cap_raise ( override_cred -> cap_effective , CAP_SYS_ADMIN ) ; cap_raise ( override_cred -> cap_effective , CAP_DAC_OVERRIDE ) ; cap_raise ( override_cred -> cap_effective , CAP_FOWNER ) ; cap_raise ( override_cred -> cap_effective , CAP_FSETID ) ; cap_raise ( override_cred -> cap_effective , CAP_CHOWN ) ; old_cred = override_creds ( override_cred ) ; } if ( overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) { opaquedir = ovl_check_empty_and_clear ( new ) ; err = PTR_ERR ( opaquedir ) ; if ( IS_ERR ( opaquedir ) ) { opaquedir = NULL ; goto out_revert_creds ; } } if ( overwrite ) { if ( old_opaque ) { if ( new -> d_inode || ! new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } } else if ( is_dir && ! new -> d_inode && new_opaque ) { flags |= RENAME_EXCHANGE ; cleanup_whiteout = true ; } } old_upperdir = ovl_dentry_upper ( old -> d_parent ) ; new_upperdir = ovl_dentry_upper ( new -> d_parent ) ; trap = lock_rename ( new_upperdir , old_upperdir ) ;  olddentry = ovl_dentry_upper ( old ) ;  newdentry = ovl_dentry_upper ( new ) ; if ( newdentry ) { if ( opaquedir ) { newdentry = opaquedir ; opaquedir = NULL ; } else { dget ( newdentry ) ; } } else { new_create = true ;  newdentry = lookup_one_len ( new -> d_name . name , new_upperdir ,  new -> d_name . len ) ;  err = PTR_ERR ( newdentry ) ;   if ( IS_ERR ( newdentry ) )  goto out_unlock ;  }  err = - ESTALE ;  if ( olddentry -> d_parent != old_upperdir )  goto out_dput ;  if ( newdentry -> d_parent != new_upperdir )   goto out_dput ;  if ( olddentry == trap ) goto out_dput ; if ( newdentry == trap ) goto out_dput ; if ( is_dir && ! old_opaque && new_opaque ) { err = ovl_set_opaque ( olddentry ) ; if ( err ) goto out_dput ; } if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) { err = ovl_set_opaque ( newdentry ) ; if ( err ) goto out_dput ; } if ( old_opaque || new_opaque ) { err = ovl_do_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , flags ) ; } else { BUG_ON ( flags & ~ RENAME_EXCHANGE ) ; err = vfs_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , NULL , flags ) ; } if ( err ) { if ( is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( newdentry ) ; goto out_dput ; } if ( is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( newdentry ) ; if ( old_opaque != new_opaque ) { ovl_dentry_set_opaque ( old , new_opaque ) ; if ( ! overwrite ) ovl_dentry_set_opaque ( new , old_opaque ) ; } if ( cleanup_whiteout ) ovl_cleanup ( old_upperdir -> d_inode , newdentry ) ; ovl_dentry_version_inc ( old -> d_parent ) ; ovl_dentry_version_inc ( new -> d_parent ) ; out_dput : dput ( newdentry ) ;  out_unlock :  unlock_rename ( new_upperdir , old_upperdir ) ; out_revert_creds : if ( old_opaque || new_opaque ) { revert_creds ( old_cred ) ; put_cred ( override_cred ) ; } out_drop_write : ovl_drop_write ( old ) ; out : dput ( opaquedir ) ; return err ; }","olddentry = lookup_one_len ( old -> d_name . name , new_upperdir , new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) ) goto out_unlock ;}err = - ESTALE ;if ( olddentry -> d_parent != old_upperdir ) goto out_dput ;if ( newdentry -> d_parent != new_upperdir ) goto out_dput ;if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ;newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) ) goto out_dput_old ;err = - ESTALE ;if ( ovl_dentry_upper ( new ) ) {if ( newdentry != opaquedir ) goto out_dput ;if ( newdentry != ovl_dentry_upper ( new ) ) goto out_dput ;if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ;}out_dput_old : dput ( olddentry ) ;",1696
715,"buggy line: out_unlock :  unlock_rename ( new_upperdir , old_upperdir ) ;cwe id:CWE-20context: static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_lower ( old ) -> d_inode == ovl_dentry_lower ( new ) -> d_inode ) goto out ; } if ( OVL_TYPE_UPPER ( new_type ) && OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_upper ( old ) -> d_inode == ovl_dentry_upper ( new ) -> d_inode ) goto out ; } } else { if ( ovl_dentry_is_opaque ( new ) ) new_type = __OVL_PATH_UPPER ; else new_type = __OVL_PATH_UPPER | __OVL_PATH_PURE ; } err = ovl_want_write ( old ) ; if ( err ) goto out ; err = ovl_copy_up ( old ) ; if ( err ) goto out_drop_write ; err = ovl_copy_up ( new -> d_parent ) ; if ( err ) goto out_drop_write ; if ( ! overwrite ) { err = ovl_copy_up ( new ) ; if ( err ) goto out_drop_write ; } old_opaque = ! OVL_TYPE_PURE_UPPER ( old_type ) ; new_opaque = ! OVL_TYPE_PURE_UPPER ( new_type ) ; if ( old_opaque || new_opaque ) { err = - ENOMEM ; override_cred = prepare_creds ( ) ; if ( ! override_cred ) goto out_drop_write ; cap_raise ( override_cred -> cap_effective , CAP_SYS_ADMIN ) ; cap_raise ( override_cred -> cap_effective , CAP_DAC_OVERRIDE ) ; cap_raise ( override_cred -> cap_effective , CAP_FOWNER ) ; cap_raise ( override_cred -> cap_effective , CAP_FSETID ) ; cap_raise ( override_cred -> cap_effective , CAP_CHOWN ) ; old_cred = override_creds ( override_cred ) ; } if ( overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) { opaquedir = ovl_check_empty_and_clear ( new ) ; err = PTR_ERR ( opaquedir ) ; if ( IS_ERR ( opaquedir ) ) { opaquedir = NULL ; goto out_revert_creds ; } } if ( overwrite ) { if ( old_opaque ) { if ( new -> d_inode || ! new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } } else if ( is_dir && ! new -> d_inode && new_opaque ) { flags |= RENAME_EXCHANGE ; cleanup_whiteout = true ; } } old_upperdir = ovl_dentry_upper ( old -> d_parent ) ; new_upperdir = ovl_dentry_upper ( new -> d_parent ) ; trap = lock_rename ( new_upperdir , old_upperdir ) ;  olddentry = ovl_dentry_upper ( old ) ;  newdentry = ovl_dentry_upper ( new ) ; if ( newdentry ) { if ( opaquedir ) { newdentry = opaquedir ; opaquedir = NULL ; } else { dget ( newdentry ) ; } } else { new_create = true ;  newdentry = lookup_one_len ( new -> d_name . name , new_upperdir ,  new -> d_name . len ) ;  err = PTR_ERR ( newdentry ) ;   if ( IS_ERR ( newdentry ) )  goto out_unlock ;  }  err = - ESTALE ;  if ( olddentry -> d_parent != old_upperdir )  goto out_dput ;  if ( newdentry -> d_parent != new_upperdir )   goto out_dput ;  if ( olddentry == trap ) goto out_dput ; if ( newdentry == trap ) goto out_dput ; if ( is_dir && ! old_opaque && new_opaque ) { err = ovl_set_opaque ( olddentry ) ; if ( err ) goto out_dput ; } if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) { err = ovl_set_opaque ( newdentry ) ; if ( err ) goto out_dput ; } if ( old_opaque || new_opaque ) { err = ovl_do_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , flags ) ; } else { BUG_ON ( flags & ~ RENAME_EXCHANGE ) ; err = vfs_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , NULL , flags ) ; } if ( err ) { if ( is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( newdentry ) ; goto out_dput ; } if ( is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( newdentry ) ; if ( old_opaque != new_opaque ) { ovl_dentry_set_opaque ( old , new_opaque ) ; if ( ! overwrite ) ovl_dentry_set_opaque ( new , old_opaque ) ; } if ( cleanup_whiteout ) ovl_cleanup ( old_upperdir -> d_inode , newdentry ) ; ovl_dentry_version_inc ( old -> d_parent ) ; ovl_dentry_version_inc ( new -> d_parent ) ; out_dput : dput ( newdentry ) ;  out_unlock :  unlock_rename ( new_upperdir , old_upperdir ) ; out_revert_creds : if ( old_opaque || new_opaque ) { revert_creds ( old_cred ) ; put_cred ( override_cred ) ; } out_drop_write : ovl_drop_write ( old ) ; out : dput ( opaquedir ) ; return err ; }","out_unlock : unlock_rename ( new_upperdir , old_upperdir ) ;",1696
716,"buggy line: sock_put ( skpair ) ;unix_peer ( sk ) = NULL ;cwe id:CWE-000context: static void unix_release_sock ( struct sock * sk , int embrion ) { struct unix_sock * u = unix_sk ( sk ) ; struct path path ; struct sock * skpair ; struct sk_buff * skb ; int state ; unix_remove_socket ( sk ) ; unix_state_lock ( sk ) ; sock_orphan ( sk ) ; sk -> sk_shutdown = SHUTDOWN_MASK ; path = u -> path ; u -> path . dentry = NULL ; u -> path . mnt = NULL ; state = sk -> sk_state ; sk -> sk_state = TCP_CLOSE ; unix_state_unlock ( sk ) ; wake_up_interruptible_all ( & u -> peer_wait ) ; skpair = unix_peer ( sk ) ; if ( skpair != NULL ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_SEQPACKET ) { unix_state_lock ( skpair ) ; skpair -> sk_shutdown = SHUTDOWN_MASK ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || embrion ) skpair -> sk_err = ECONNRESET ; unix_state_unlock ( skpair ) ; skpair -> sk_state_change ( skpair ) ; sk_wake_async ( skpair , SOCK_WAKE_WAITD , POLL_HUP ) ; }  sock_put ( skpair ) ;  unix_peer ( sk ) = NULL ; } while ( ( skb = skb_dequeue ( & sk -> sk_receive_queue ) ) != NULL ) { if ( state == TCP_LISTEN ) unix_release_sock ( skb -> sk , 1 ) ; UNIXCB ( skb ) . consumed = skb -> len ; kfree_skb ( skb ) ; } if ( path . dentry ) path_put ( & path ) ; sock_put ( sk ) ; if ( unix_tot_inflight ) unix_gc ( ) ; }","unix_dgram_peer_wake_disconnect ( sk , skpair ) ;sock_put ( skpair ) ;unix_peer ( sk ) = NULL ;",0
717,"buggy line: static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index ,  int_mv * ref_mv ,  int_mv * second_ref_mv , int64_t comp_pred_diff [ REFERENCE_MODES ] ,  int64_t tx_size_diff [ TX_MODES ] ,   int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ) {MACROBLOCKD * const xd = & x -> e_mbd ;ctx -> best_mode_index = mode_index ;ctx -> mic = * xd -> mi [ 0 ] ;ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ;ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ;vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ;vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ;cwe id:CWE-119context: static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index ,  int_mv * ref_mv ,  int_mv * second_ref_mv , int64_t comp_pred_diff [ REFERENCE_MODES ] ,  int64_t tx_size_diff [ TX_MODES ] ,   int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ) {  MACROBLOCKD * const xd = & x -> e_mbd ; ctx -> skip = x -> skip ;  ctx -> best_mode_index = mode_index ;  ctx -> mic = * xd -> mi [ 0 ] ;  ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ;  ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ; ctx -> single_pred_diff = ( int ) comp_pred_diff [ SINGLE_REFERENCE ] ; ctx -> comp_pred_diff = ( int ) comp_pred_diff [ COMPOUND_REFERENCE ] ; ctx -> hybrid_pred_diff = ( int ) comp_pred_diff [ REFERENCE_MODE_SELECT ] ;  vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ;  vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ; }","static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index , int64_t comp_pred_diff [ REFERENCE_MODES ] , int64_t tx_size_diff [ TX_MODES ] , int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] , int skippable ) {MACROBLOCKD * const xd = & x -> e_mbd ;ctx -> mbmi_ext = * x -> mbmi_ext ;ctx -> best_mode_index = mode_index ;ctx -> mic = * xd -> mi [ 0 ] ;ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ;ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ;memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ;vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ;",1
718,"buggy line: ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ;cwe id:CWE-125context: static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { ""invalid"" , ""rsasig"" , ""shared-secret"" , ""dsssig"" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ;  ND_TCHECK ( * ext ) ;  UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }","ND_TCHECK2 ( * ext , sizeof ( a ) ) ;UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ;",2
719,"buggy line: if ( ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) || ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ LAST_FRAME ] ) ) {cm -> allow_comp_inter_inter = 0 ;}cm -> allow_comp_inter_inter = 1 ;cm -> comp_fixed_ref = ALTREF_FRAME ;int i ;const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ;const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ;if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter )  cm -> reference_mode = SINGLE_REFERENCE ;else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] &&   mode_thresh [ COMPOUND_REFERENCE ] >   mode_thresh [ REFERENCE_MODE_SELECT ] &&  check_dual_ref_flags ( cpi ) && cpi -> static_mb_pct == 100 ) cm -> reference_mode = COMPOUND_REFERENCE ;else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] )  cm -> reference_mode = SINGLE_REFERENCE ;else cm -> reference_mode = REFERENCE_MODE_SELECT ;if ( cm -> interp_filter == SWITCHABLE ) {if ( frame_type != ALTREF_FRAME && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP_SHARP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ SWITCHABLE - 1 ] ) {cm -> interp_filter = EIGHTTAP_SMOOTH ;}else if ( filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ SWITCHABLE - 1 ] ) {cm -> interp_filter = EIGHTTAP_SHARP ;}else if ( filter_thresh [ EIGHTTAP ] > filter_thresh [ SWITCHABLE - 1 ] ) {cm -> interp_filter = EIGHTTAP ;}}encode_frame_internal ( cpi ) ;for ( i = 0 ;i < REFERENCE_MODES ;++ i ) {const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ;cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] += diff ;for ( i = 0 ;const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ;cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ;}for ( i = 0 ;cwe id:CWE-119context: void vp9_encode_frame ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; if ( ! frame_is_intra_only ( cm ) ) { if ( ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) || ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ LAST_FRAME ] ) ) {  cm -> allow_comp_inter_inter = 0 ;  } else {  cm -> allow_comp_inter_inter = 1 ;  cm -> comp_fixed_ref = ALTREF_FRAME ; cm -> comp_var_ref [ 0 ] = LAST_FRAME ; cm -> comp_var_ref [ 1 ] = GOLDEN_FRAME ; } } if ( cpi -> sf . frame_parameter_update ) {  int i ;  const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;  const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ;   const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ;   if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter )  cm -> reference_mode = SINGLE_REFERENCE ;  else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] &&   mode_thresh [ COMPOUND_REFERENCE ] >   mode_thresh [ REFERENCE_MODE_SELECT ] &&  check_dual_ref_flags ( cpi ) && cpi -> static_mb_pct == 100 ) cm -> reference_mode = COMPOUND_REFERENCE ;  else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] )  cm -> reference_mode = SINGLE_REFERENCE ; else cm -> reference_mode = REFERENCE_MODE_SELECT ;  if ( cm -> interp_filter == SWITCHABLE ) {  if ( frame_type != ALTREF_FRAME && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP_SHARP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ SWITCHABLE - 1 ] ) {  cm -> interp_filter = EIGHTTAP_SMOOTH ;  } else if ( filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP_SHARP ; } else if ( filter_thresh [ EIGHTTAP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP ; } } encode_frame_internal ( cpi ) ;  for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) {   const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ;  cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] >>= 1 ; }  for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) {   const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ;  cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ;  }  for ( i = 0 ; i < TX_MODES ; ++ i ) { int64_t pd = cpi -> rd_tx_select_diff [ i ] ; int diff ; if ( i == TX_MODE_SELECT ) pd -= RDCOST ( cpi -> mb . rdmult , cpi -> mb . rddiv , 2048 * ( TX_SIZES - 1 ) , 0 ) ; diff = ( int ) ( pd / cm -> MBs ) ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] /= 2 ; } if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { int single_count_zero = 0 ; int comp_count_zero = 0 ; for ( i = 0 ; i < COMP_INTER_CONTEXTS ; i ++ ) {  single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ;   comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ;  } if ( comp_count_zero == 0 ) { cm -> reference_mode = SINGLE_REFERENCE ;  vp9_zero ( cm -> counts . comp_inter ) ;  } else if ( single_count_zero == 0 ) { cm -> reference_mode = COMPOUND_REFERENCE ;  vp9_zero ( cm -> counts . comp_inter ) ;  } } if ( cm -> tx_mode == TX_MODE_SELECT ) { int count4x4 = 0 ; int count8x8_lp = 0 , count8x8_8x8p = 0 ; int count16x16_16x16p = 0 , count16x16_lp = 0 ; int count32x32 = 0 ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) {  count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ;   count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ;   count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ;   count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ;   count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ;   count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ;   count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ;   count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ;   count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ;  } if ( count4x4 == 0 && count16x16_lp == 0 && count16x16_16x16p == 0 && count32x32 == 0 ) { cm -> tx_mode = ALLOW_8X8 ;  reset_skip_txfm_size ( cm , TX_8X8 ) ;  } else if ( count8x8_8x8p == 0 && count16x16_16x16p == 0 && count8x8_lp == 0 && count16x16_lp == 0 && count32x32 == 0 ) { cm -> tx_mode = ONLY_4X4 ;  reset_skip_txfm_size ( cm , TX_4X4 ) ;  } else if ( count8x8_lp == 0 && count16x16_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_32X32 ; } else if ( count32x32 == 0 && count8x8_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_16X16 ;  reset_skip_txfm_size ( cm , TX_16X16 ) ;  } } } else { cm -> reference_mode = SINGLE_REFERENCE ;  cm -> interp_filter = SWITCHABLE ;  encode_frame_internal ( cpi ) ; } }",cpi -> allow_comp_inter_inter = 0 ;}cm -> allow_comp_inter_inter = 1 ;cm -> comp_fixed_ref = ALTREF_FRAME ;+ i ) {int i ;const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;int64_t * const mode_thrs = rd_opt -> prediction_type_threshes [ frame_type ] ;const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ;int64_t * const filter_thrs = rd_opt -> filter_threshes [ frame_type ] [ i ] += diff ;for ( i = 0 ;const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ;cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ;}for ( i = 0 ;,3
720,"buggy line: single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ;comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ;}vp9_zero ( cm -> counts . comp_inter ) ;}vp9_zero ( cm -> counts . comp_inter ) ;}cwe id:CWE-119context: void vp9_encode_frame ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; if ( ! frame_is_intra_only ( cm ) ) { if ( ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) || ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ LAST_FRAME ] ) ) {  cm -> allow_comp_inter_inter = 0 ;  } else {  cm -> allow_comp_inter_inter = 1 ;  cm -> comp_fixed_ref = ALTREF_FRAME ; cm -> comp_var_ref [ 0 ] = LAST_FRAME ; cm -> comp_var_ref [ 1 ] = GOLDEN_FRAME ; } } if ( cpi -> sf . frame_parameter_update ) {  int i ;  const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;  const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ;   const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ;   if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter )  cm -> reference_mode = SINGLE_REFERENCE ;  else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] &&   mode_thresh [ COMPOUND_REFERENCE ] >   mode_thresh [ REFERENCE_MODE_SELECT ] &&  check_dual_ref_flags ( cpi ) && cpi -> static_mb_pct == 100 ) cm -> reference_mode = COMPOUND_REFERENCE ;  else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] )  cm -> reference_mode = SINGLE_REFERENCE ; else cm -> reference_mode = REFERENCE_MODE_SELECT ;  if ( cm -> interp_filter == SWITCHABLE ) {  if ( frame_type != ALTREF_FRAME && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP_SHARP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ SWITCHABLE - 1 ] ) {  cm -> interp_filter = EIGHTTAP_SMOOTH ;  } else if ( filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP_SHARP ; } else if ( filter_thresh [ EIGHTTAP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP ; } } encode_frame_internal ( cpi ) ;  for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) {   const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ;  cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] >>= 1 ; }  for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) {   const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ;  cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ;  }  for ( i = 0 ; i < TX_MODES ; ++ i ) { int64_t pd = cpi -> rd_tx_select_diff [ i ] ; int diff ; if ( i == TX_MODE_SELECT ) pd -= RDCOST ( cpi -> mb . rdmult , cpi -> mb . rddiv , 2048 * ( TX_SIZES - 1 ) , 0 ) ; diff = ( int ) ( pd / cm -> MBs ) ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] /= 2 ; } if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { int single_count_zero = 0 ; int comp_count_zero = 0 ; for ( i = 0 ; i < COMP_INTER_CONTEXTS ; i ++ ) {  single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ;   comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ;  } if ( comp_count_zero == 0 ) { cm -> reference_mode = SINGLE_REFERENCE ;  vp9_zero ( cm -> counts . comp_inter ) ;  } else if ( single_count_zero == 0 ) { cm -> reference_mode = COMPOUND_REFERENCE ;  vp9_zero ( cm -> counts . comp_inter ) ;  } } if ( cm -> tx_mode == TX_MODE_SELECT ) { int count4x4 = 0 ; int count8x8_lp = 0 , count8x8_8x8p = 0 ; int count16x16_16x16p = 0 , count16x16_lp = 0 ; int count32x32 = 0 ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) {  count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ;   count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ;   count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ;   count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ;   count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ;   count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ;   count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ;   count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ;   count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ;  } if ( count4x4 == 0 && count16x16_lp == 0 && count16x16_16x16p == 0 && count32x32 == 0 ) { cm -> tx_mode = ALLOW_8X8 ;  reset_skip_txfm_size ( cm , TX_8X8 ) ;  } else if ( count8x8_8x8p == 0 && count16x16_16x16p == 0 && count8x8_lp == 0 && count16x16_lp == 0 && count32x32 == 0 ) { cm -> tx_mode = ONLY_4X4 ;  reset_skip_txfm_size ( cm , TX_4X4 ) ;  } else if ( count8x8_lp == 0 && count16x16_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_32X32 ; } else if ( count32x32 == 0 && count8x8_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_16X16 ;  reset_skip_txfm_size ( cm , TX_16X16 ) ;  } } } else { cm -> reference_mode = SINGLE_REFERENCE ;  cm -> interp_filter = SWITCHABLE ;  encode_frame_internal ( cpi ) ; } }",single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ;comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ;}vp9_zero ( cm -> counts . comp_inter ) ;}vp9_zero ( cm -> counts . comp_inter ) ;},3
721,"buggy line: count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ;count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ;count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ;count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ;count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ;count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ;count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ;}reset_skip_txfm_size ( cm , TX_8X8 ) ;}reset_skip_txfm_size ( cm , TX_4X4 ) ;}reset_skip_txfm_size ( cm , TX_16X16 ) ;}cm -> interp_filter = SWITCHABLE ;encode_frame_internal ( cpi ) ;cwe id:CWE-119context: void vp9_encode_frame ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; if ( ! frame_is_intra_only ( cm ) ) { if ( ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) || ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ LAST_FRAME ] ) ) {  cm -> allow_comp_inter_inter = 0 ;  } else {  cm -> allow_comp_inter_inter = 1 ;  cm -> comp_fixed_ref = ALTREF_FRAME ; cm -> comp_var_ref [ 0 ] = LAST_FRAME ; cm -> comp_var_ref [ 1 ] = GOLDEN_FRAME ; } } if ( cpi -> sf . frame_parameter_update ) {  int i ;  const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;  const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ;   const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ;   if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter )  cm -> reference_mode = SINGLE_REFERENCE ;  else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] &&   mode_thresh [ COMPOUND_REFERENCE ] >   mode_thresh [ REFERENCE_MODE_SELECT ] &&  check_dual_ref_flags ( cpi ) && cpi -> static_mb_pct == 100 ) cm -> reference_mode = COMPOUND_REFERENCE ;  else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] )  cm -> reference_mode = SINGLE_REFERENCE ; else cm -> reference_mode = REFERENCE_MODE_SELECT ;  if ( cm -> interp_filter == SWITCHABLE ) {  if ( frame_type != ALTREF_FRAME && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP_SHARP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ SWITCHABLE - 1 ] ) {  cm -> interp_filter = EIGHTTAP_SMOOTH ;  } else if ( filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP_SHARP ; } else if ( filter_thresh [ EIGHTTAP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP ; } } encode_frame_internal ( cpi ) ;  for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) {   const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ;  cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] >>= 1 ; }  for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) {   const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ;  cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ;  }  for ( i = 0 ; i < TX_MODES ; ++ i ) { int64_t pd = cpi -> rd_tx_select_diff [ i ] ; int diff ; if ( i == TX_MODE_SELECT ) pd -= RDCOST ( cpi -> mb . rdmult , cpi -> mb . rddiv , 2048 * ( TX_SIZES - 1 ) , 0 ) ; diff = ( int ) ( pd / cm -> MBs ) ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] /= 2 ; } if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { int single_count_zero = 0 ; int comp_count_zero = 0 ; for ( i = 0 ; i < COMP_INTER_CONTEXTS ; i ++ ) {  single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ;   comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ;  } if ( comp_count_zero == 0 ) { cm -> reference_mode = SINGLE_REFERENCE ;  vp9_zero ( cm -> counts . comp_inter ) ;  } else if ( single_count_zero == 0 ) { cm -> reference_mode = COMPOUND_REFERENCE ;  vp9_zero ( cm -> counts . comp_inter ) ;  } } if ( cm -> tx_mode == TX_MODE_SELECT ) { int count4x4 = 0 ; int count8x8_lp = 0 , count8x8_8x8p = 0 ; int count16x16_16x16p = 0 , count16x16_lp = 0 ; int count32x32 = 0 ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) {  count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ;   count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ;   count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ;   count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ;   count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ;   count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ;   count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ;   count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ;   count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ;  } if ( count4x4 == 0 && count16x16_lp == 0 && count16x16_16x16p == 0 && count32x32 == 0 ) { cm -> tx_mode = ALLOW_8X8 ;  reset_skip_txfm_size ( cm , TX_8X8 ) ;  } else if ( count8x8_8x8p == 0 && count16x16_16x16p == 0 && count8x8_lp == 0 && count16x16_lp == 0 && count32x32 == 0 ) { cm -> tx_mode = ONLY_4X4 ;  reset_skip_txfm_size ( cm , TX_4X4 ) ;  } else if ( count8x8_lp == 0 && count16x16_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_32X32 ; } else if ( count32x32 == 0 && count8x8_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_16X16 ;  reset_skip_txfm_size ( cm , TX_16X16 ) ;  } } } else { cm -> reference_mode = SINGLE_REFERENCE ;  cm -> interp_filter = SWITCHABLE ;  encode_frame_internal ( cpi ) ; } }","count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ;count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ;count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ;count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ;count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ;count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ;count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ;}reset_skip_txfm_size ( cm , TX_8X8 ) ;}reset_skip_txfm_size ( cm , TX_4X4 ) ;}reset_skip_txfm_size ( cm , TX_16X16 ) ;}cm -> interp_filter = get_interp_filter ( filter_thrs , is_alt_ref ) ;encode_frame_internal ( cpi ) ;",3
722,"buggy line: if ( test_bit ( EV_KEY , dev -> evbit ) &&  ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) {cwe id:CWE-787context: int input_set_keycode ( struct input_dev * dev , const struct input_keymap_entry * ke ) { unsigned long flags ; unsigned int old_keycode ; int retval ; if ( ke -> keycode > KEY_MAX ) return - EINVAL ; spin_lock_irqsave ( & dev -> event_lock , flags ) ; retval = dev -> setkeycode ( dev , ke , & old_keycode ) ; if ( retval ) goto out ; __clear_bit ( KEY_RESERVED , dev -> keybit ) ;  if ( test_bit ( EV_KEY , dev -> evbit ) &&  ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) { struct input_value vals [ ] = { { EV_KEY , old_keycode , 0 } , input_value_sync } ; input_pass_values ( dev , vals , ARRAY_SIZE ( vals ) ) ; } out : spin_unlock_irqrestore ( & dev -> event_lock , flags ) ; return retval ; }","if ( old_keycode > KEY_MAX ) {dev_warn ( dev -> dev . parent ? : & dev -> dev , ""%s:<S2SV_blank>got<S2SV_blank>too<S2SV_blank>big<S2SV_blank>old<S2SV_blank>keycode<S2SV_blank>%#x\\\}else if ( test_bit ( EV_KEY , dev -> evbit ) && ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) {",4
723,"buggy line: if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) )  goto out_nofree ;if ( addr_len ) * addr_len = sizeof ( sa ) ;cwe id:CWE-200context: static int pn_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct sk_buff * skb = NULL ; struct sockaddr_pn sa ; int rval = - EOPNOTSUPP ; int copylen ; if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) )  goto out_nofree ;  if ( addr_len ) * addr_len = sizeof ( sa ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rval ) ; if ( skb == NULL ) goto out_nofree ; pn_skb_get_src_sockaddr ( skb , & sa ) ; copylen = skb -> len ; if ( len < copylen ) { msg -> msg_flags |= MSG_TRUNC ; copylen = len ; } rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ) ; if ( rval ) { rval = - EFAULT ; goto out ; } rval = ( flags & MSG_TRUNC ) ? skb -> len : copylen ;  if ( msg -> msg_name != NULL )   memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ;  out : skb_free_datagram ( sk , skb ) ; out_nofree : return rval ; }",if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) ) goto out_nofree ;,5
724,"buggy line: if ( msg -> msg_name != NULL )   memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ;out : skb_free_datagram ( sk , skb ) ;cwe id:CWE-200context: static int pn_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct sk_buff * skb = NULL ; struct sockaddr_pn sa ; int rval = - EOPNOTSUPP ; int copylen ; if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) )  goto out_nofree ;  if ( addr_len ) * addr_len = sizeof ( sa ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rval ) ; if ( skb == NULL ) goto out_nofree ; pn_skb_get_src_sockaddr ( skb , & sa ) ; copylen = skb -> len ; if ( len < copylen ) { msg -> msg_flags |= MSG_TRUNC ; copylen = len ; } rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ) ; if ( rval ) { rval = - EFAULT ; goto out ; } rval = ( flags & MSG_TRUNC ) ? skb -> len : copylen ;  if ( msg -> msg_name != NULL )   memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ;  out : skb_free_datagram ( sk , skb ) ; out_nofree : return rval ; }","if ( msg -> msg_name != NULL ) {memcpy ( msg -> msg_name , & sa , sizeof ( sa ) ) ;* addr_len = sizeof ( sa ) ;}out : skb_free_datagram ( sk , skb ) ;",5
725,"buggy line: if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) )  return CURLE_OUT_OF_MEMORY ;cwe id:CWE-119context: CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) { CURLcode result ; char * plainauth ; size_t ulen ; size_t plen ; size_t plainlen ; * outlen = 0 ; * outptr = NULL ; ulen = strlen ( userp ) ; plen = strlen ( passwdp ) ;  if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) )  return CURLE_OUT_OF_MEMORY ; plainlen = 2 * ulen + plen + 2 ; plainauth = malloc ( plainlen ) ; if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ; memcpy ( plainauth , userp , ulen ) ; plainauth [ ulen ] = '\\0' ; memcpy ( plainauth + ulen + 1 , userp , ulen ) ; plainauth [ 2 * ulen + 1 ] = '\\0' ; memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ; result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ; free ( plainauth ) ; return result ; }",if ( ( ulen > SIZE_T_MAX / 4 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;,6
726,"buggy line: if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) {log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ;cwe id:CWE-59context: static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s"" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ;  if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) {  log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }","if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW ) ) == - 1 ) {log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ;",7
727,"buggy line: saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;saddr . sin_port = htons ( port ) ;cwe id:CWE-284context: int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # ifdef SO_NOSIGPIPE if ( setsockopt ( sfd , SOL_SOCKET , SO_NOSIGPIPE , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # endif memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ;  saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;  saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }",saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;saddr . sin_port = htons ( port ) ;,8
728,"buggy line: FILE * fp = fopen ( dest_filename , ""w"" ) ;if ( ! fp ) return false ;cwe id:CWE-59context: static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) {  FILE * fp = fopen ( dest_filename , ""w"" ) ;  if ( ! fp ) return false ; unsigned fd = 0 ; while ( fd <= 99999 ) { sprintf ( source_filename + source_base_ofs , ""fd/%u"" , fd ) ; char * name = malloc_readlink ( source_filename ) ; if ( ! name ) break ; fprintf ( fp , ""%u:%s\\n"" , fd , name ) ; free ( name ) ; sprintf ( source_filename + source_base_ofs , ""fdinfo/%u"" , fd ) ; fd ++ ; FILE * in = fopen ( source_filename , ""r"" ) ; if ( ! in ) continue ; char buf [ 128 ] ; while ( fgets ( buf , sizeof ( buf ) - 1 , in ) ) { char * eol = strchrnul ( buf , '\\n' ) ; eol [ 0 ] = '\\n' ; eol [ 1 ] = '\\0' ; fputs ( buf , fp ) ; } fclose ( in ) ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( ""Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu"" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; } fclose ( fp ) ; return true ; }","FILE * fp = fopen ( dest_filename , ""wx"" ) ;if ( ! fp ) return false ;",9
729,"buggy line: * low = p - reg -> dmax ;if ( * low > s ) {if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc ,  ( pprev ? pprev : str ) , * low ) ;}cwe id:CWE-476context: static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; if ( q >= end ) return 0 ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) {  * low = p - reg -> dmax ;  if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc ,  ( pprev ? pprev : str ) , * low ) ;  } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }","if ( p - str < reg -> dmax ) {* low = ( UChar * ) str ;if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ;}}else {* low = p - reg -> dmax ;if ( * low > s ) {if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ;}",10
730,"buggy line: if ( hrtimer_cancel ( timer ) )  hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;}cwe id:CWE-362context: void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ;  if ( hrtimer_cancel ( timer ) )  hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;  } ","mutex_lock ( & pit -> pit_state . lock ) ;if ( hrtimer_cancel ( timer ) ) hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;mutex_unlock ( & pit -> pit_state . lock ) ;}",11
731,"buggy line: vpx_roi_map_t roi = {0 };roi . rows = ( cfg -> g_h + 15 ) / 16 ;cwe id:CWE-119context: static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ;  vpx_roi_map_t roi = { 0 } ;  roi . rows = ( cfg -> g_h + 15 ) / 16 ; roi . cols = ( cfg -> g_w + 15 ) / 16 ; roi . delta_q [ 0 ] = 0 ; roi . delta_q [ 1 ] = - 2 ; roi . delta_q [ 2 ] = - 4 ; roi . delta_q [ 3 ] = - 6 ; roi . delta_lf [ 0 ] = 0 ; roi . delta_lf [ 1 ] = 1 ; roi . delta_lf [ 2 ] = 2 ; roi . delta_lf [ 3 ] = 3 ; roi . static_threshold [ 0 ] = 1500 ; roi . static_threshold [ 1 ] = 1000 ; roi . static_threshold [ 2 ] = 500 ; roi . static_threshold [ 3 ] = 0 ; roi . roi_map = ( uint8_t * ) malloc ( roi . rows * roi . cols ) ; for ( i = 0 ; i < roi . rows * roi . cols ; ++ i ) roi . roi_map [ i ] = i % 4 ; if ( vpx_codec_control ( codec , VP8E_SET_ROI_MAP , & roi ) ) die_codec ( codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>ROI<S2SV_blank>map"" ) ; free ( roi . roi_map ) ; }","vpx_roi_map_t roi ;memset ( & roi , 0 , sizeof ( roi ) ) ;roi . rows = ( cfg -> g_h + 15 ) / 16 ;",12
732,"buggy line: static const char * parse_object ( cJSON * item , const char * value )  {ep = value ;return 0 ;' )  return value + 1 ;if ( ! ( item -> child = child = cJSON_New_Item ( ) ) )  return 0 ;if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) )  return 0 ;ep = value ;return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) )  return 0 ;if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ;child -> next = new_item ;new_item -> prev = child ;child = new_item ;if ( ! ( value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) )  return 0 ;ep = value ;return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) )  return 0 ;' )  return value + 1 ;ep = value ;cwe id:CWE-119context:  static const char * parse_object ( cJSON * item , const char * value )  { cJSON * child ; if ( * value != '{' ) {  ep = value ;  return 0 ; } item -> type = cJSON_Object ; value = skip ( value + 1 ) ; if ( * value == '}' )  return value + 1 ;   if ( ! ( item -> child = child = cJSON_New_Item ( ) ) )  return 0 ;  if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) )  return 0 ; child -> string = child -> valuestring ; child -> valuestring = 0 ; if ( * value != ':' ) {  ep = value ;  return 0 ; }  if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) )  return 0 ; while ( * value == ',' ) { cJSON * new_item ; if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ; child -> next = new_item ; new_item -> prev = child ;  child = new_item ;   if ( ! ( value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) )  return 0 ; child -> string = child -> valuestring ; child -> valuestring = 0 ; if ( * value != ':' ) {  ep = value ;  return 0 ; }  if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) )  return 0 ; } if ( * value == '}' )  return value + 1 ;  ep = value ; return 0 ; }","static const char * parse_object ( cJSON * item , const char * value , const char * * ep ) {* ep = value ;return 0 ;' ) return value + 1 ;item -> child = child = cJSON_New_Item ( ) ) ) return 0 ;if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) ) return 0 ;ep = value ;return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) return 0 ;if ( ! ( new_item = cJSON_New_Item ( ) ;if ( ! item -> child ) return 0 ;value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) ) return 0 ;* ep = value ;return 0 ;value = skip ( parse_value ( child , skip ( value + 1 ) , ep ) ) ;if ( ! value ) return 0 ;' ) return value + 1 ;* ep = value ;",13
733,"buggy line: cwe id:CWE-119context: static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ;  ncomponents = bytestream2_get_be16u ( & s -> g ) ;  if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components"" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n"" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; if ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>separation<S2SV_blank>%d/%d\\n"" , s -> cdx [ i ] , s -> cdy [ i ] ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>"" ""components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>"" ""cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n"" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } s -> avctx -> bits_per_raw_sample = s -> precision ; return 0 ; }","if ( s -> image_offset_x || s -> image_offset_y ) {avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ;return AVERROR_PATCHWELCOME ;}",14
734,"buggy line: ncomponents = bytestream2_get_be16u ( & s -> g ) ;if ( ncomponents <= 0 ) {cwe id:CWE-119context: static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ;  ncomponents = bytestream2_get_be16u ( & s -> g ) ;  if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components"" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n"" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; if ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>separation<S2SV_blank>%d/%d\\n"" , s -> cdx [ i ] , s -> cdy [ i ] ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>"" ""components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>"" ""cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n"" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } s -> avctx -> bits_per_raw_sample = s -> precision ; return 0 ; }",ncomponents = bytestream2_get_be16u ( & s -> g ) ;if ( ncomponents <= 0 ) {,14
735,"buggy line: addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ;}cwe id:CWE-190context: static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ;  addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ;  } }","addModuleArgument ( pParse , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ;}",15
736,buggy line: return 0 ;}cwe id:CWE-119context: static av_cold int xpm_decode_close ( AVCodecContext * avctx ) { XPMDecContext * x = avctx -> priv_data ; av_freep ( & x -> pixels ) ;  return 0 ;  },av_freep ( & x -> buf ) ;x -> buf_size = 0 ;return 0 ;},16
737,"buggy line: new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ;cwe id:CWE-787context: static void write_version ( FILE * fp , const char * fname , const char * dirname , xref_t * xref ) { long start ; char * c , * new_fname , data ; FILE * new_fp ; start = ftell ( fp ) ; if ( ( c = strstr ( fname , "".pdf"" ) ) ) * c = '\\0' ;  new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;  snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ; if ( ! ( new_fp = fopen ( new_fname , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , new_fname ) ; fseek ( fp , start , SEEK_SET ) ; free ( new_fname ) ; return ; } fseek ( fp , 0 , SEEK_SET ) ; while ( fread ( & data , 1 , 1 , fp ) ) fwrite ( & data , 1 , 1 , new_fp ) ; fprintf ( new_fp , ""\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF"" , xref -> start ) ; fclose ( new_fp ) ; free ( new_fname ) ; fseek ( fp , start , SEEK_SET ) ; }","new_fname = safe_calloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ;",17
738,"buggy line: break ;}cwe id:CWE-254context: static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - ECHILD ; nd -> path . dentry = parent ; nd -> seq = seq ;  break ;  } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }",if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;break ;},18
739,"buggy line: strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ;cwe id:CWE-200context: static int crypto_report_akcipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_akcipher rakcipher ;  strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ;  if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }","strncpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ;",19
740,"buggy line: void imap_quote_string ( char * dest , size_t dlen , const char * src )  {static const char quote [ ] = ""\\\\""\\\\\\\\"" ;cwe id:CWE-77context:  void imap_quote_string ( char * dest , size_t dlen , const char * src )  { static const char quote [ ] = ""\\""\\\\"" ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { dlen -= 2 ; if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }","void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) {const char * quote = ""`\\\\""\\\\\\\\"" ;if ( ! quote_backtick ) quote ++ ;",20
741,"buggy line: int r ;if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ;for ( ;if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) {cwe id:CWE-320context: int sshkey_load_file ( int fd , struct sshbuf * blob ) { u_char buf [ 1024 ] ; size_t len ; struct stat st ;  int r ;  if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ; if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size > MAX_KEY_FILE_SIZE ) return SSH_ERR_INVALID_FORMAT ;  for ( ; ; ) {  if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) { if ( errno == EPIPE ) break ; r = SSH_ERR_SYSTEM_ERROR ; goto out ; } if ( ( r = sshbuf_put ( blob , buf , len ) ) != 0 ) goto out ; if ( sshbuf_len ( blob ) > MAX_KEY_FILE_SIZE ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } } if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size != ( off_t ) sshbuf_len ( blob ) ) { r = SSH_ERR_FILE_CHANGED ; goto out ; } r = 0 ; out : explicit_bzero ( buf , sizeof ( buf ) ) ; if ( r != 0 ) sshbuf_reset ( blob ) ; return r ; }","int r , dontmax = 0 ;if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ;if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) {st . st_size = 64 * 1024 ;dontmax = 1 ;}if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;for ( ;if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) {",21
742,buggy line: if ( params -> buffer . fragment_size == 0 ||  params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size )  return - EINVAL ;cwe id:CWE-000context: static int snd_compress_check_input ( struct snd_compr_params * params ) { if ( params -> buffer . fragment_size == 0 ||  params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size )  return - EINVAL ; if ( params -> codec . id == 0 || params -> codec . id > SND_AUDIOCODEC_MAX ) return - EINVAL ; if ( params -> codec . ch_in == 0 || params -> codec . ch_out == 0 ) return - EINVAL ; return 0 ; },if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > INT_MAX / params -> buffer . fragment_size ) return - EINVAL ;,22
743,"buggy line: memcpy ( output , input , sizeof ( uint8_t ) * length ) ;return ;cwe id:CWE-119context: static void resize_multistep ( const uint8_t * const input , int length , uint8_t * output , int olength , uint8_t * buf ) { int steps ; if ( length == olength ) {  memcpy ( output , input , sizeof ( uint8_t ) * length ) ;  return ; } steps = get_down2_steps ( length , olength ) ; if ( steps > 0 ) { int s ; uint8_t * out = NULL ; uint8_t * tmpbuf = NULL ; uint8_t * otmp , * otmp2 ; int filteredlength = length ; if ( ! tmpbuf ) { tmpbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * length ) ; otmp = tmpbuf ; } else { otmp = buf ; } otmp2 = otmp + get_down2_length ( length , 1 ) ; for ( s = 0 ; s < steps ; ++ s ) { const int proj_filteredlength = get_down2_length ( filteredlength , 1 ) ; const uint8_t * const in = ( s == 0 ? input : out ) ; if ( s == steps - 1 && proj_filteredlength == olength ) out = output ; else out = ( s & 1 ? otmp2 : otmp ) ; if ( filteredlength & 1 ) down2_symodd ( in , filteredlength , out ) ; else down2_symeven ( in , filteredlength , out ) ; filteredlength = proj_filteredlength ; } if ( filteredlength != olength ) { interpolate ( out , filteredlength , output , olength ) ; } if ( tmpbuf ) free ( tmpbuf ) ; } else { interpolate ( input , length , output , olength ) ; } }","memcpy ( output , input , sizeof ( output [ 0 ] ) * length ) ;return ;",23
744,buggy line: if ( vcpu -> arch . time_page ) {kvm_release_page_dirty ( vcpu -> arch . time_page ) ;vcpu -> arch . time_page = NULL ;}cwe id:CWE-399context: static void kvmclock_reset ( struct kvm_vcpu * vcpu ) {  if ( vcpu -> arch . time_page ) {  kvm_release_page_dirty ( vcpu -> arch . time_page ) ; vcpu -> arch . time_page = NULL ; } },vcpu -> arch . pv_time_enabled = false ;,24
745,"buggy line: handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ;if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ;data . allocation . handle = handle -> id ;cleanup_handle = handle ;break ;case ION_IOC_FREE : {struct ion_handle * handle ;handle = ion_handle_get_by_id ( client , data . handle . handle ) ;if ( IS_ERR ( handle ) )  return PTR_ERR ( handle ) ;ion_free ( client , handle ) ;ion_handle_put ( handle ) ;cwe id:CWE-264context: static long ion_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) { struct ion_client * client = filp -> private_data ; struct ion_device * dev = client -> dev ; struct ion_handle * cleanup_handle = NULL ; int ret = 0 ; unsigned int dir ; union { struct ion_fd_data fd ; struct ion_allocation_data allocation ; struct ion_handle_data handle ; struct ion_custom_data custom ; } data ; dir = ion_ioctl_dir ( cmd ) ; if ( _IOC_SIZE ( cmd ) > sizeof ( data ) ) return - EINVAL ; if ( dir & _IOC_WRITE ) if ( copy_from_user ( & data , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) return - EFAULT ; switch ( cmd ) { case ION_IOC_ALLOC : { struct ion_handle * handle ; handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . allocation . handle = handle -> id ; cleanup_handle = handle ; break ; } case ION_IOC_FREE : { struct ion_handle * handle ;  handle = ion_handle_get_by_id ( client , data . handle . handle ) ;   if ( IS_ERR ( handle ) )  return PTR_ERR ( handle ) ;  ion_free ( client , handle ) ;  ion_handle_put ( handle ) ; break ; } case ION_IOC_SHARE : case ION_IOC_MAP : { struct ion_handle * handle ; handle = ion_handle_get_by_id ( client , data . handle . handle ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . fd . fd = ion_share_dma_buf_fd ( client , handle ) ; ion_handle_put ( handle ) ; if ( data . fd . fd < 0 ) ret = data . fd . fd ; break ; } case ION_IOC_IMPORT : { struct ion_handle * handle ; handle = ion_import_dma_buf_fd ( client , data . fd . fd ) ; if ( IS_ERR ( handle ) ) ret = PTR_ERR ( handle ) ; else data . handle . handle = handle -> id ; break ; } case ION_IOC_SYNC : { ret = ion_sync_for_device ( client , data . fd . fd ) ; break ; } case ION_IOC_CUSTOM : { if ( ! dev -> custom_ioctl ) return - ENOTTY ; ret = dev -> custom_ioctl ( client , data . custom . cmd , data . custom . arg ) ; break ; } default : return - ENOTTY ; } if ( dir & _IOC_READ ) { if ( copy_to_user ( ( void __user * ) arg , & data , _IOC_SIZE ( cmd ) ) ) { if ( cleanup_handle ) ion_free ( client , cleanup_handle ) ; return - EFAULT ; } } return ret ; }","mutex_lock ( & client -> lock ) ;handle = ion_handle_get_by_id_nolock ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ;if ( IS_ERR ( handle ) ) {mutex_unlock ( & client -> lock ) ;return PTR_ERR ( handle ) ;ion_free_nolock ( client , handle ) ;ion_handle_put_nolock ( handle ) ;mutex_unlock ( & client -> lock ) ;",25
746,"buggy line: int data_len = elt -> length -   sizeof ( struct oz_get_desc_rsp ) + 1 ;u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ;u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ;cwe id:CWE-119context: void oz_usb_rx ( struct oz_pd * pd , struct oz_elt * elt ) { struct oz_usb_hdr * usb_hdr = ( struct oz_usb_hdr * ) ( elt + 1 ) ; struct oz_usb_ctx * usb_ctx ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; usb_ctx = ( struct oz_usb_ctx * ) pd -> app_ctx [ OZ_APPID_USB ] ; if ( usb_ctx ) oz_usb_get ( usb_ctx ) ; spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; if ( usb_ctx == NULL ) return ; if ( usb_ctx -> stopped ) goto done ; if ( usb_hdr -> elt_seq_num != 0 ) { if ( ( ( usb_ctx -> rx_seq_num - usb_hdr -> elt_seq_num ) & 0x80 ) == 0 ) goto done ; } usb_ctx -> rx_seq_num = usb_hdr -> elt_seq_num ; switch ( usb_hdr -> type ) { case OZ_GET_DESC_RSP : { struct oz_get_desc_rsp * body = ( struct oz_get_desc_rsp * ) usb_hdr ;  int data_len = elt -> length -   sizeof ( struct oz_get_desc_rsp ) + 1 ;  u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ; } break ; case OZ_USB_ENDPOINT_DATA : oz_usb_handle_ep_data ( usb_ctx , usb_hdr , elt -> length ) ; break ; } done : oz_usb_put ( usb_ctx ) ; }","u16 offs , total_size ;u8 data_len ;if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ;data_len = elt -> length - ( sizeof ( struct oz_get_desc_rsp ) - 1 ) ;offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ;total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ;",26
747,"buggy line: cwe id:CWE-119context: void oz_usb_rx ( struct oz_pd * pd , struct oz_elt * elt ) { struct oz_usb_hdr * usb_hdr = ( struct oz_usb_hdr * ) ( elt + 1 ) ; struct oz_usb_ctx * usb_ctx ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; usb_ctx = ( struct oz_usb_ctx * ) pd -> app_ctx [ OZ_APPID_USB ] ; if ( usb_ctx ) oz_usb_get ( usb_ctx ) ; spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; if ( usb_ctx == NULL ) return ; if ( usb_ctx -> stopped ) goto done ; if ( usb_hdr -> elt_seq_num != 0 ) { if ( ( ( usb_ctx -> rx_seq_num - usb_hdr -> elt_seq_num ) & 0x80 ) == 0 ) goto done ; } usb_ctx -> rx_seq_num = usb_hdr -> elt_seq_num ; switch ( usb_hdr -> type ) { case OZ_GET_DESC_RSP : { struct oz_get_desc_rsp * body = ( struct oz_get_desc_rsp * ) usb_hdr ;  int data_len = elt -> length -   sizeof ( struct oz_get_desc_rsp ) + 1 ;  u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ; } break ; case OZ_USB_ENDPOINT_DATA : oz_usb_handle_ep_data ( usb_ctx , usb_hdr , elt -> length ) ; break ; } done : oz_usb_put ( usb_ctx ) ; }","case OZ_SET_CONFIG_RSP : {struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ;}break ;case OZ_SET_INTERFACE_RSP : {struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ;}break ;case OZ_VENDOR_CLASS_RSP : {struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ;}break ;",26
748,"buggy line: growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;cwe id:CWE-119context: xmlChar * xmlStringLenDecodeEntities ( xmlParserCtxtPtr ctxt , const xmlChar * str , int len , int what , xmlChar end , xmlChar end2 , xmlChar end3 ) { xmlChar * buffer = NULL ; int buffer_size = 0 ; xmlChar * current = NULL ; xmlChar * rep = NULL ; const xmlChar * last ; xmlEntityPtr ent ; int c , l ; int nbchars = 0 ; if ( ( ctxt == NULL ) || ( str == NULL ) || ( len < 0 ) ) return ( NULL ) ; last = str + len ; if ( ( ( ctxt -> depth > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> depth > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; return ( NULL ) ; } buffer_size = XML_PARSER_BIG_BUFFER_SIZE ; buffer = ( xmlChar * ) xmlMallocAtomic ( buffer_size * sizeof ( xmlChar ) ) ; if ( buffer == NULL ) goto mem_error ; if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; while ( ( c != 0 ) && ( c != end ) && ( c != end2 ) && ( c != end3 ) ) { if ( c == 0 ) break ; if ( ( c == '&' ) && ( str [ 1 ] == '#' ) ) { int val = xmlParseStringCharRef ( ctxt , & str ) ; if ( val != 0 ) { COPY_BUF ( 0 , buffer , nbchars , val ) ; } if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else if ( ( c == '&' ) && ( what & XML_SUBSTITUTE_REF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""String<S2SV_blank>decoding<S2SV_blank>Entity<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , str ) ; ent = xmlParseStringEntityRef ( ctxt , & str ) ; if ( ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) || ( ctxt -> lastError . code == XML_ERR_INTERNAL_ERROR ) ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ( ent != NULL ) && ( ent -> etype == XML_INTERNAL_PREDEFINED_ENTITY ) ) { if ( ent -> content != NULL ) { COPY_BUF ( 0 , buffer , nbchars , ent -> content [ 0 ] ) ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else { xmlFatalErrMsg ( ctxt , XML_ERR_INTERNAL_ERROR , ""predefined<S2SV_blank>entity<S2SV_blank>has<S2SV_blank>no<S2SV_blank>content\\n"" ) ; } } else if ( ( ent != NULL ) && ( ent -> content != NULL ) ) { ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } else if ( ent != NULL ) { int i = xmlStrlen ( ent -> name ) ; const xmlChar * cur = ent -> name ; buffer [ nbchars ++ ] = '&' ; if ( nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE ) {  growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;  } for ( ; i > 0 ; i -- ) buffer [ nbchars ++ ] = * cur ++ ; buffer [ nbchars ++ ] = ';' ; } } else if ( c == '%' && ( what & XML_SUBSTITUTE_PEREF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""String<S2SV_blank>decoding<S2SV_blank>PE<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , str ) ; ent = xmlParseStringPEReference ( ctxt , & str ) ; if ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ent != NULL ) { if ( ent -> content == NULL ) { xmlLoadEntityContent ( ctxt , ent ) ; } ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } } else { COPY_BUF ( l , buffer , nbchars , c ) ; str += l ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; } buffer [ nbchars ] = 0 ; return ( buffer ) ; mem_error : xmlErrMemory ( ctxt , NULL ) ; int_error : if ( rep != NULL ) xmlFree ( rep ) ; if ( buffer != NULL ) xmlFree ( buffer ) ; return ( NULL ) ; }","growBuffer ( buffer , i + XML_PARSER_BUFFER_SIZE ) ;",27
749,"buggy line: growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;}cwe id:CWE-119context: xmlChar * xmlStringLenDecodeEntities ( xmlParserCtxtPtr ctxt , const xmlChar * str , int len , int what , xmlChar end , xmlChar end2 , xmlChar end3 ) { xmlChar * buffer = NULL ; int buffer_size = 0 ; xmlChar * current = NULL ; xmlChar * rep = NULL ; const xmlChar * last ; xmlEntityPtr ent ; int c , l ; int nbchars = 0 ; if ( ( ctxt == NULL ) || ( str == NULL ) || ( len < 0 ) ) return ( NULL ) ; last = str + len ; if ( ( ( ctxt -> depth > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> depth > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; return ( NULL ) ; } buffer_size = XML_PARSER_BIG_BUFFER_SIZE ; buffer = ( xmlChar * ) xmlMallocAtomic ( buffer_size * sizeof ( xmlChar ) ) ; if ( buffer == NULL ) goto mem_error ; if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; while ( ( c != 0 ) && ( c != end ) && ( c != end2 ) && ( c != end3 ) ) { if ( c == 0 ) break ; if ( ( c == '&' ) && ( str [ 1 ] == '#' ) ) { int val = xmlParseStringCharRef ( ctxt , & str ) ; if ( val != 0 ) { COPY_BUF ( 0 , buffer , nbchars , val ) ; } if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else if ( ( c == '&' ) && ( what & XML_SUBSTITUTE_REF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""String<S2SV_blank>decoding<S2SV_blank>Entity<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , str ) ; ent = xmlParseStringEntityRef ( ctxt , & str ) ; if ( ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) || ( ctxt -> lastError . code == XML_ERR_INTERNAL_ERROR ) ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ( ent != NULL ) && ( ent -> etype == XML_INTERNAL_PREDEFINED_ENTITY ) ) { if ( ent -> content != NULL ) { COPY_BUF ( 0 , buffer , nbchars , ent -> content [ 0 ] ) ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else { xmlFatalErrMsg ( ctxt , XML_ERR_INTERNAL_ERROR , ""predefined<S2SV_blank>entity<S2SV_blank>has<S2SV_blank>no<S2SV_blank>content\\n"" ) ; } } else if ( ( ent != NULL ) && ( ent -> content != NULL ) ) { ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } else if ( ent != NULL ) { int i = xmlStrlen ( ent -> name ) ; const xmlChar * cur = ent -> name ; buffer [ nbchars ++ ] = '&' ; if ( nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE ) {  growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;  } for ( ; i > 0 ; i -- ) buffer [ nbchars ++ ] = * cur ++ ; buffer [ nbchars ++ ] = ';' ; } } else if ( c == '%' && ( what & XML_SUBSTITUTE_PEREF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""String<S2SV_blank>decoding<S2SV_blank>PE<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , str ) ; ent = xmlParseStringPEReference ( ctxt , & str ) ; if ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ent != NULL ) { if ( ent -> content == NULL ) { xmlLoadEntityContent ( ctxt , ent ) ; } ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } } else { COPY_BUF ( l , buffer , nbchars , c ) ; str += l ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; } buffer [ nbchars ] = 0 ; return ( buffer ) ; mem_error : xmlErrMemory ( ctxt , NULL ) ; int_error : if ( rep != NULL ) xmlFree ( rep ) ; if ( buffer != NULL ) xmlFree ( buffer ) ; return ( NULL ) ; }","growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;}",27
750,"buggy line: if ( len < 5 )   return len ;b -> opcode = 0xe9 ;cwe id:CWE-200context: unsigned paravirt_patch_jmp ( void * insnbuf , const void * target , unsigned long addr , unsigned len ) { struct branch * b = insnbuf ; unsigned long delta = ( unsigned long ) target - ( addr + 5 ) ;  if ( len < 5 )   return len ;  b -> opcode = 0xe9 ; b -> delta = delta ; return 5 ; }","if ( len < 5 ) {# ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\\# endif return len ;}b -> opcode = 0xe9 ;",28
751,"buggy line: continue ;}cwe id:CWE-119context: static int parse_packet ( sockent_t * se , void * buffer , size_t buffer_size , int flags , const char * username ) { int status ; value_list_t vl = VALUE_LIST_INIT ; notification_t n ; # if HAVE_LIBGCRYPT int packet_was_signed = ( flags & PP_SIGNED ) ; int packet_was_encrypted = ( flags & PP_ENCRYPTED ) ; int printed_ignore_warning = 0 ; # endif memset ( & vl , '\\0' , sizeof ( vl ) ) ; memset ( & n , '\\0' , sizeof ( n ) ) ; status = 0 ; while ( ( status == 0 ) && ( 0 < buffer_size ) && ( ( unsigned int ) buffer_size > sizeof ( part_header_t ) ) ) { uint16_t pkg_length ; uint16_t pkg_type ; memcpy ( ( void * ) & pkg_type , ( void * ) buffer , sizeof ( pkg_type ) ) ; memcpy ( ( void * ) & pkg_length , ( void * ) ( buffer + sizeof ( pkg_type ) ) , sizeof ( pkg_length ) ) ; pkg_length = ntohs ( pkg_length ) ; pkg_type = ntohs ( pkg_type ) ; if ( pkg_length > buffer_size ) break ; if ( pkg_length < ( 2 * sizeof ( uint16_t ) ) ) break ; if ( pkg_type == TYPE_ENCR_AES256 ) { status = parse_part_encr_aes256 ( se , & buffer , & buffer_size , flags ) ; if ( status != 0 ) { ERROR ( ""network<S2SV_blank>plugin:<S2SV_blank>Decrypting<S2SV_blank>AES256<S2SV_blank>"" ""part<S2SV_blank>failed<S2SV_blank>"" ""with<S2SV_blank>status<S2SV_blank>%i."" , status ) ; break ; } } # if HAVE_LIBGCRYPT else if ( ( se -> data . server . security_level == SECURITY_LEVEL_ENCRYPT ) && ( packet_was_encrypted == 0 ) ) { if ( printed_ignore_warning == 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>Unencrypted<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>"" ""part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored."" ) ; printed_ignore_warning = 1 ; } buffer = ( ( char * ) buffer ) + pkg_length ;  continue ;  } # endif else if ( pkg_type == TYPE_SIGN_SHA256 ) { status = parse_part_sign_sha256 ( se , & buffer , & buffer_size , flags ) ; if ( status != 0 ) { ERROR ( ""network<S2SV_blank>plugin:<S2SV_blank>Verifying<S2SV_blank>HMAC-SHA-256<S2SV_blank>"" ""signature<S2SV_blank>failed<S2SV_blank>"" ""with<S2SV_blank>status<S2SV_blank>%i."" , status ) ; break ; } } # if HAVE_LIBGCRYPT else if ( ( se -> data . server . security_level == SECURITY_LEVEL_SIGN ) && ( packet_was_encrypted == 0 ) && ( packet_was_signed == 0 ) ) { if ( printed_ignore_warning == 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>Unsigned<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>"" ""part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored."" ) ; printed_ignore_warning = 1 ; } buffer = ( ( char * ) buffer ) + pkg_length ;  continue ;  } # endif else if ( pkg_type == TYPE_VALUES ) { status = parse_part_values ( & buffer , & buffer_size , & vl . values , & vl . values_len ) ; if ( status != 0 ) break ; network_dispatch_values ( & vl , username ) ; sfree ( vl . values ) ; } else if ( pkg_type == TYPE_TIME ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) { vl . time = TIME_T_TO_CDTIME_T ( tmp ) ; n . time = TIME_T_TO_CDTIME_T ( tmp ) ; } } else if ( pkg_type == TYPE_TIME_HR ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) { vl . time = ( cdtime_t ) tmp ; n . time = ( cdtime_t ) tmp ; } } else if ( pkg_type == TYPE_INTERVAL ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) vl . interval = TIME_T_TO_CDTIME_T ( tmp ) ; } else if ( pkg_type == TYPE_INTERVAL_HR ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) vl . interval = ( cdtime_t ) tmp ; } else if ( pkg_type == TYPE_HOST ) { status = parse_part_string ( & buffer , & buffer_size , vl . host , sizeof ( vl . host ) ) ; if ( status == 0 ) sstrncpy ( n . host , vl . host , sizeof ( n . host ) ) ; } else if ( pkg_type == TYPE_PLUGIN ) { status = parse_part_string ( & buffer , & buffer_size , vl . plugin , sizeof ( vl . plugin ) ) ; if ( status == 0 ) sstrncpy ( n . plugin , vl . plugin , sizeof ( n . plugin ) ) ; } else if ( pkg_type == TYPE_PLUGIN_INSTANCE ) { status = parse_part_string ( & buffer , & buffer_size , vl . plugin_instance , sizeof ( vl . plugin_instance ) ) ; if ( status == 0 ) sstrncpy ( n . plugin_instance , vl . plugin_instance , sizeof ( n . plugin_instance ) ) ; } else if ( pkg_type == TYPE_TYPE ) { status = parse_part_string ( & buffer , & buffer_size , vl . type , sizeof ( vl . type ) ) ; if ( status == 0 ) sstrncpy ( n . type , vl . type , sizeof ( n . type ) ) ; } else if ( pkg_type == TYPE_TYPE_INSTANCE ) { status = parse_part_string ( & buffer , & buffer_size , vl . type_instance , sizeof ( vl . type_instance ) ) ; if ( status == 0 ) sstrncpy ( n . type_instance , vl . type_instance , sizeof ( n . type_instance ) ) ; } else if ( pkg_type == TYPE_MESSAGE ) { status = parse_part_string ( & buffer , & buffer_size , n . message , sizeof ( n . message ) ) ; if ( status != 0 ) { } else if ( ( n . severity != NOTIF_FAILURE ) && ( n . severity != NOTIF_WARNING ) && ( n . severity != NOTIF_OKAY ) ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""unknown<S2SV_blank>severity<S2SV_blank>%i."" , n . severity ) ; } else if ( n . time <= 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""time<S2SV_blank>==<S2SV_blank>0."" ) ; } else if ( strlen ( n . message ) <= 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""an<S2SV_blank>empty<S2SV_blank>message."" ) ; } else { network_dispatch_notification ( & n ) ; } } else if ( pkg_type == TYPE_SEVERITY ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) n . severity = ( int ) tmp ; } else { DEBUG ( ""network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Unknown<S2SV_blank>part"" ""<S2SV_blank>type:<S2SV_blank>0x%04hx"" , pkg_type ) ; buffer = ( ( char * ) buffer ) + pkg_length ;  }  } if ( status == 0 && buffer_size > 0 ) WARNING ( ""network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>"" ""packet,<S2SV_blank>try<S2SV_blank>increasing<S2SV_blank>`MaxPacketSize\'"" ) ; return ( status ) ; }",buffer_size -= ( size_t ) pkg_length ;continue ;},29
752,"buggy line: continue ;}cwe id:CWE-119context: static int parse_packet ( sockent_t * se , void * buffer , size_t buffer_size , int flags , const char * username ) { int status ; value_list_t vl = VALUE_LIST_INIT ; notification_t n ; # if HAVE_LIBGCRYPT int packet_was_signed = ( flags & PP_SIGNED ) ; int packet_was_encrypted = ( flags & PP_ENCRYPTED ) ; int printed_ignore_warning = 0 ; # endif memset ( & vl , '\\0' , sizeof ( vl ) ) ; memset ( & n , '\\0' , sizeof ( n ) ) ; status = 0 ; while ( ( status == 0 ) && ( 0 < buffer_size ) && ( ( unsigned int ) buffer_size > sizeof ( part_header_t ) ) ) { uint16_t pkg_length ; uint16_t pkg_type ; memcpy ( ( void * ) & pkg_type , ( void * ) buffer , sizeof ( pkg_type ) ) ; memcpy ( ( void * ) & pkg_length , ( void * ) ( buffer + sizeof ( pkg_type ) ) , sizeof ( pkg_length ) ) ; pkg_length = ntohs ( pkg_length ) ; pkg_type = ntohs ( pkg_type ) ; if ( pkg_length > buffer_size ) break ; if ( pkg_length < ( 2 * sizeof ( uint16_t ) ) ) break ; if ( pkg_type == TYPE_ENCR_AES256 ) { status = parse_part_encr_aes256 ( se , & buffer , & buffer_size , flags ) ; if ( status != 0 ) { ERROR ( ""network<S2SV_blank>plugin:<S2SV_blank>Decrypting<S2SV_blank>AES256<S2SV_blank>"" ""part<S2SV_blank>failed<S2SV_blank>"" ""with<S2SV_blank>status<S2SV_blank>%i."" , status ) ; break ; } } # if HAVE_LIBGCRYPT else if ( ( se -> data . server . security_level == SECURITY_LEVEL_ENCRYPT ) && ( packet_was_encrypted == 0 ) ) { if ( printed_ignore_warning == 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>Unencrypted<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>"" ""part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored."" ) ; printed_ignore_warning = 1 ; } buffer = ( ( char * ) buffer ) + pkg_length ;  continue ;  } # endif else if ( pkg_type == TYPE_SIGN_SHA256 ) { status = parse_part_sign_sha256 ( se , & buffer , & buffer_size , flags ) ; if ( status != 0 ) { ERROR ( ""network<S2SV_blank>plugin:<S2SV_blank>Verifying<S2SV_blank>HMAC-SHA-256<S2SV_blank>"" ""signature<S2SV_blank>failed<S2SV_blank>"" ""with<S2SV_blank>status<S2SV_blank>%i."" , status ) ; break ; } } # if HAVE_LIBGCRYPT else if ( ( se -> data . server . security_level == SECURITY_LEVEL_SIGN ) && ( packet_was_encrypted == 0 ) && ( packet_was_signed == 0 ) ) { if ( printed_ignore_warning == 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>Unsigned<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>"" ""part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored."" ) ; printed_ignore_warning = 1 ; } buffer = ( ( char * ) buffer ) + pkg_length ;  continue ;  } # endif else if ( pkg_type == TYPE_VALUES ) { status = parse_part_values ( & buffer , & buffer_size , & vl . values , & vl . values_len ) ; if ( status != 0 ) break ; network_dispatch_values ( & vl , username ) ; sfree ( vl . values ) ; } else if ( pkg_type == TYPE_TIME ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) { vl . time = TIME_T_TO_CDTIME_T ( tmp ) ; n . time = TIME_T_TO_CDTIME_T ( tmp ) ; } } else if ( pkg_type == TYPE_TIME_HR ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) { vl . time = ( cdtime_t ) tmp ; n . time = ( cdtime_t ) tmp ; } } else if ( pkg_type == TYPE_INTERVAL ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) vl . interval = TIME_T_TO_CDTIME_T ( tmp ) ; } else if ( pkg_type == TYPE_INTERVAL_HR ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) vl . interval = ( cdtime_t ) tmp ; } else if ( pkg_type == TYPE_HOST ) { status = parse_part_string ( & buffer , & buffer_size , vl . host , sizeof ( vl . host ) ) ; if ( status == 0 ) sstrncpy ( n . host , vl . host , sizeof ( n . host ) ) ; } else if ( pkg_type == TYPE_PLUGIN ) { status = parse_part_string ( & buffer , & buffer_size , vl . plugin , sizeof ( vl . plugin ) ) ; if ( status == 0 ) sstrncpy ( n . plugin , vl . plugin , sizeof ( n . plugin ) ) ; } else if ( pkg_type == TYPE_PLUGIN_INSTANCE ) { status = parse_part_string ( & buffer , & buffer_size , vl . plugin_instance , sizeof ( vl . plugin_instance ) ) ; if ( status == 0 ) sstrncpy ( n . plugin_instance , vl . plugin_instance , sizeof ( n . plugin_instance ) ) ; } else if ( pkg_type == TYPE_TYPE ) { status = parse_part_string ( & buffer , & buffer_size , vl . type , sizeof ( vl . type ) ) ; if ( status == 0 ) sstrncpy ( n . type , vl . type , sizeof ( n . type ) ) ; } else if ( pkg_type == TYPE_TYPE_INSTANCE ) { status = parse_part_string ( & buffer , & buffer_size , vl . type_instance , sizeof ( vl . type_instance ) ) ; if ( status == 0 ) sstrncpy ( n . type_instance , vl . type_instance , sizeof ( n . type_instance ) ) ; } else if ( pkg_type == TYPE_MESSAGE ) { status = parse_part_string ( & buffer , & buffer_size , n . message , sizeof ( n . message ) ) ; if ( status != 0 ) { } else if ( ( n . severity != NOTIF_FAILURE ) && ( n . severity != NOTIF_WARNING ) && ( n . severity != NOTIF_OKAY ) ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""unknown<S2SV_blank>severity<S2SV_blank>%i."" , n . severity ) ; } else if ( n . time <= 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""time<S2SV_blank>==<S2SV_blank>0."" ) ; } else if ( strlen ( n . message ) <= 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""an<S2SV_blank>empty<S2SV_blank>message."" ) ; } else { network_dispatch_notification ( & n ) ; } } else if ( pkg_type == TYPE_SEVERITY ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) n . severity = ( int ) tmp ; } else { DEBUG ( ""network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Unknown<S2SV_blank>part"" ""<S2SV_blank>type:<S2SV_blank>0x%04hx"" , pkg_type ) ; buffer = ( ( char * ) buffer ) + pkg_length ;  }  } if ( status == 0 && buffer_size > 0 ) WARNING ( ""network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>"" ""packet,<S2SV_blank>try<S2SV_blank>increasing<S2SV_blank>`MaxPacketSize\'"" ) ; return ( status ) ; }",buffer_size -= ( size_t ) pkg_length ;continue ;},29
753,"buggy line: }}cwe id:CWE-119context: static int parse_packet ( sockent_t * se , void * buffer , size_t buffer_size , int flags , const char * username ) { int status ; value_list_t vl = VALUE_LIST_INIT ; notification_t n ; # if HAVE_LIBGCRYPT int packet_was_signed = ( flags & PP_SIGNED ) ; int packet_was_encrypted = ( flags & PP_ENCRYPTED ) ; int printed_ignore_warning = 0 ; # endif memset ( & vl , '\\0' , sizeof ( vl ) ) ; memset ( & n , '\\0' , sizeof ( n ) ) ; status = 0 ; while ( ( status == 0 ) && ( 0 < buffer_size ) && ( ( unsigned int ) buffer_size > sizeof ( part_header_t ) ) ) { uint16_t pkg_length ; uint16_t pkg_type ; memcpy ( ( void * ) & pkg_type , ( void * ) buffer , sizeof ( pkg_type ) ) ; memcpy ( ( void * ) & pkg_length , ( void * ) ( buffer + sizeof ( pkg_type ) ) , sizeof ( pkg_length ) ) ; pkg_length = ntohs ( pkg_length ) ; pkg_type = ntohs ( pkg_type ) ; if ( pkg_length > buffer_size ) break ; if ( pkg_length < ( 2 * sizeof ( uint16_t ) ) ) break ; if ( pkg_type == TYPE_ENCR_AES256 ) { status = parse_part_encr_aes256 ( se , & buffer , & buffer_size , flags ) ; if ( status != 0 ) { ERROR ( ""network<S2SV_blank>plugin:<S2SV_blank>Decrypting<S2SV_blank>AES256<S2SV_blank>"" ""part<S2SV_blank>failed<S2SV_blank>"" ""with<S2SV_blank>status<S2SV_blank>%i."" , status ) ; break ; } } # if HAVE_LIBGCRYPT else if ( ( se -> data . server . security_level == SECURITY_LEVEL_ENCRYPT ) && ( packet_was_encrypted == 0 ) ) { if ( printed_ignore_warning == 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>Unencrypted<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>"" ""part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored."" ) ; printed_ignore_warning = 1 ; } buffer = ( ( char * ) buffer ) + pkg_length ;  continue ;  } # endif else if ( pkg_type == TYPE_SIGN_SHA256 ) { status = parse_part_sign_sha256 ( se , & buffer , & buffer_size , flags ) ; if ( status != 0 ) { ERROR ( ""network<S2SV_blank>plugin:<S2SV_blank>Verifying<S2SV_blank>HMAC-SHA-256<S2SV_blank>"" ""signature<S2SV_blank>failed<S2SV_blank>"" ""with<S2SV_blank>status<S2SV_blank>%i."" , status ) ; break ; } } # if HAVE_LIBGCRYPT else if ( ( se -> data . server . security_level == SECURITY_LEVEL_SIGN ) && ( packet_was_encrypted == 0 ) && ( packet_was_signed == 0 ) ) { if ( printed_ignore_warning == 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>Unsigned<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>"" ""part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored."" ) ; printed_ignore_warning = 1 ; } buffer = ( ( char * ) buffer ) + pkg_length ;  continue ;  } # endif else if ( pkg_type == TYPE_VALUES ) { status = parse_part_values ( & buffer , & buffer_size , & vl . values , & vl . values_len ) ; if ( status != 0 ) break ; network_dispatch_values ( & vl , username ) ; sfree ( vl . values ) ; } else if ( pkg_type == TYPE_TIME ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) { vl . time = TIME_T_TO_CDTIME_T ( tmp ) ; n . time = TIME_T_TO_CDTIME_T ( tmp ) ; } } else if ( pkg_type == TYPE_TIME_HR ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) { vl . time = ( cdtime_t ) tmp ; n . time = ( cdtime_t ) tmp ; } } else if ( pkg_type == TYPE_INTERVAL ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) vl . interval = TIME_T_TO_CDTIME_T ( tmp ) ; } else if ( pkg_type == TYPE_INTERVAL_HR ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) vl . interval = ( cdtime_t ) tmp ; } else if ( pkg_type == TYPE_HOST ) { status = parse_part_string ( & buffer , & buffer_size , vl . host , sizeof ( vl . host ) ) ; if ( status == 0 ) sstrncpy ( n . host , vl . host , sizeof ( n . host ) ) ; } else if ( pkg_type == TYPE_PLUGIN ) { status = parse_part_string ( & buffer , & buffer_size , vl . plugin , sizeof ( vl . plugin ) ) ; if ( status == 0 ) sstrncpy ( n . plugin , vl . plugin , sizeof ( n . plugin ) ) ; } else if ( pkg_type == TYPE_PLUGIN_INSTANCE ) { status = parse_part_string ( & buffer , & buffer_size , vl . plugin_instance , sizeof ( vl . plugin_instance ) ) ; if ( status == 0 ) sstrncpy ( n . plugin_instance , vl . plugin_instance , sizeof ( n . plugin_instance ) ) ; } else if ( pkg_type == TYPE_TYPE ) { status = parse_part_string ( & buffer , & buffer_size , vl . type , sizeof ( vl . type ) ) ; if ( status == 0 ) sstrncpy ( n . type , vl . type , sizeof ( n . type ) ) ; } else if ( pkg_type == TYPE_TYPE_INSTANCE ) { status = parse_part_string ( & buffer , & buffer_size , vl . type_instance , sizeof ( vl . type_instance ) ) ; if ( status == 0 ) sstrncpy ( n . type_instance , vl . type_instance , sizeof ( n . type_instance ) ) ; } else if ( pkg_type == TYPE_MESSAGE ) { status = parse_part_string ( & buffer , & buffer_size , n . message , sizeof ( n . message ) ) ; if ( status != 0 ) { } else if ( ( n . severity != NOTIF_FAILURE ) && ( n . severity != NOTIF_WARNING ) && ( n . severity != NOTIF_OKAY ) ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""unknown<S2SV_blank>severity<S2SV_blank>%i."" , n . severity ) ; } else if ( n . time <= 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""time<S2SV_blank>==<S2SV_blank>0."" ) ; } else if ( strlen ( n . message ) <= 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""an<S2SV_blank>empty<S2SV_blank>message."" ) ; } else { network_dispatch_notification ( & n ) ; } } else if ( pkg_type == TYPE_SEVERITY ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) n . severity = ( int ) tmp ; } else { DEBUG ( ""network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Unknown<S2SV_blank>part"" ""<S2SV_blank>type:<S2SV_blank>0x%04hx"" , pkg_type ) ; buffer = ( ( char * ) buffer ) + pkg_length ;  }  } if ( status == 0 && buffer_size > 0 ) WARNING ( ""network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>"" ""packet,<S2SV_blank>try<S2SV_blank>increasing<S2SV_blank>`MaxPacketSize\'"" ) ; return ( status ) ; }",buffer_size -= ( size_t ) pkg_length ;}},29
754,"buggy line: mapping = ( struct address_space * ) page_private ( page ) ;mutex_lock ( & mapping -> i_mmap_mutex ) ;cwe id:CWE-399context: static int unmap_ref_private ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * page , unsigned long address ) { struct hstate * h = hstate_vma ( vma ) ; struct vm_area_struct * iter_vma ; struct address_space * mapping ; struct prio_tree_iter iter ; pgoff_t pgoff ; address = address & huge_page_mask ( h ) ; pgoff = vma_hugecache_offset ( h , vma , address ) ;  mapping = ( struct address_space * ) page_private ( page ) ;  mutex_lock ( & mapping -> i_mmap_mutex ) ; vma_prio_tree_foreach ( iter_vma , & iter , & mapping -> i_mmap , pgoff , pgoff ) { if ( iter_vma == vma ) continue ; if ( ! is_vma_resv_set ( iter_vma , HPAGE_RESV_OWNER ) ) __unmap_hugepage_range ( iter_vma , address , address + huge_page_size ( h ) , page ) ; } mutex_unlock ( & mapping -> i_mmap_mutex ) ; return 1 ; }",mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping ;mutex_lock ( & mapping -> i_mmap_mutex ) ;,30
755,"buggy line: void fdct16_8col ( __m128i * in ) {__m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ;const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ;const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ;cwe id:CWE-119context:  void fdct16_8col ( __m128i * in ) {  __m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ;  const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;  const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ;  const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;  const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p28_p04 = pair_set_epi16 ( cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m04_p28 = pair_set_epi16 ( - cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p12_p20 = pair_set_epi16 ( cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_m20_p12 = pair_set_epi16 ( - cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p30_p02 = pair_set_epi16 ( cospi_30_64 , cospi_2_64 ) ; const __m128i k__cospi_p14_p18 = pair_set_epi16 ( cospi_14_64 , cospi_18_64 ) ; const __m128i k__cospi_m02_p30 = pair_set_epi16 ( - cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_m18_p14 = pair_set_epi16 ( - cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p22_p10 = pair_set_epi16 ( cospi_22_64 , cospi_10_64 ) ; const __m128i k__cospi_p06_p26 = pair_set_epi16 ( cospi_6_64 , cospi_26_64 ) ; const __m128i k__cospi_m10_p22 = pair_set_epi16 ( - cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_m26_p06 = pair_set_epi16 ( - cospi_26_64 , cospi_6_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; i [ 0 ] = _mm_add_epi16 ( in [ 0 ] , in [ 15 ] ) ; i [ 1 ] = _mm_add_epi16 ( in [ 1 ] , in [ 14 ] ) ; i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , in [ 13 ] ) ; i [ 3 ] = _mm_add_epi16 ( in [ 3 ] , in [ 12 ] ) ; i [ 4 ] = _mm_add_epi16 ( in [ 4 ] , in [ 11 ] ) ; i [ 5 ] = _mm_add_epi16 ( in [ 5 ] , in [ 10 ] ) ; i [ 6 ] = _mm_add_epi16 ( in [ 6 ] , in [ 9 ] ) ; i [ 7 ] = _mm_add_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 0 ] = _mm_sub_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 1 ] = _mm_sub_epi16 ( in [ 6 ] , in [ 9 ] ) ; s [ 2 ] = _mm_sub_epi16 ( in [ 5 ] , in [ 10 ] ) ; s [ 3 ] = _mm_sub_epi16 ( in [ 4 ] , in [ 11 ] ) ; s [ 4 ] = _mm_sub_epi16 ( in [ 3 ] , in [ 12 ] ) ; s [ 5 ] = _mm_sub_epi16 ( in [ 2 ] , in [ 13 ] ) ; s [ 6 ] = _mm_sub_epi16 ( in [ 1 ] , in [ 14 ] ) ; s [ 7 ] = _mm_sub_epi16 ( in [ 0 ] , in [ 15 ] ) ; p [ 0 ] = _mm_add_epi16 ( i [ 0 ] , i [ 7 ] ) ; p [ 1 ] = _mm_add_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 2 ] = _mm_add_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 3 ] = _mm_add_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 4 ] = _mm_sub_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 6 ] = _mm_sub_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 7 ] = _mm_sub_epi16 ( i [ 0 ] , i [ 7 ] ) ; u [ 0 ] = _mm_add_epi16 ( p [ 0 ] , p [ 3 ] ) ; u [ 1 ] = _mm_add_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 2 ] = _mm_sub_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 3 ] = _mm_sub_epi16 ( p [ 0 ] , p [ 3 ] ) ; v [ 0 ] = _mm_unpacklo_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 1 ] = _mm_unpackhi_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 2 ] = _mm_unpacklo_epi16 ( u [ 2 ] , u [ 3 ] ) ; v [ 3 ] = _mm_unpackhi_epi16 ( u [ 2 ] , u [ 3 ] ) ; u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ; u [ 1 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_p16 ) ; u [ 2 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ; u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_m16 ) ; u [ 4 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_p24_p08 ) ; u [ 5 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_p24_p08 ) ; u [ 6 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_m08_p24 ) ; u [ 7 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_m08_p24 ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; in [ 4 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; in [ 8 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; in [ 12 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 5 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 5 ] , p [ 6 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; u [ 0 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; u [ 1 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 0 ] = _mm_add_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 1 ] = _mm_sub_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 2 ] = _mm_sub_epi16 ( p [ 7 ] , u [ 1 ] ) ; t [ 3 ] = _mm_add_epi16 ( p [ 7 ] , u [ 1 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( t [ 1 ] , t [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( t [ 1 ] , t [ 2 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_p04 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_p04 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_p20 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_p20 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m04_p28 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m04_p28 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; in [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 14 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 3 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; p [ 0 ] = _mm_add_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 1 ] = _mm_add_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 2 ] = _mm_sub_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 3 ] = _mm_sub_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 4 ] = _mm_sub_epi16 ( s [ 7 ] , t [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 6 ] = _mm_add_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 7 ] = _mm_add_epi16 ( s [ 7 ] , t [ 4 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( p [ 2 ] , p [ 5 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( p [ 2 ] , p [ 5 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ;  v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ;  v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ;  v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;   u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;  u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 6 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 0 ] = _mm_add_epi16 ( p [ 0 ] , t [ 1 ] ) ; s [ 1 ] = _mm_sub_epi16 ( p [ 0 ] , t [ 1 ] ) ;  s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ;   s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;  s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 6 ] = _mm_sub_epi16 ( p [ 7 ] , t [ 6 ] ) ; s [ 7 ] = _mm_add_epi16 ( p [ 7 ] , t [ 6 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p30_p02 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p30_p02 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p14_p18 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p14_p18 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p22_p10 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p22_p10 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p06_p26 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p06_p26 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m26_p06 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m26_p06 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m10_p22 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m10_p22 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m18_p14 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m18_p14 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m02_p30 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m02_p30 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 13 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 3 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; }","static void fdct16_8col ( __m128i * in ) {__m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ;const __m128i k__cospi_p08_m24 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_8_64 , - cospi_24_64 ) ;const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ;",31
756,"buggy line: i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , in [ 13 ] ) ;i [ 3 ] = _mm_add_epi16 ( in [ 3 ] , in [ 12 ] ) ;i [ 4 ] = _mm_add_epi16 ( in [ 4 ] , in [ 11 ] ) ;i [ 5 ] = _mm_add_epi16 ( in [ 5 ] , in [ 10 ] ) ;i [ 6 ] = _mm_add_epi16 ( in [ 6 ] , in [ 9 ] ) ;i [ 7 ] = _mm_add_epi16 ( in [ 7 ] , in [ 8 ] ) ;s [ 0 ] = _mm_sub_epi16 ( in [ 7 ] , in [ 8 ] ) ;s [ 1 ] = _mm_sub_epi16 ( in [ 6 ] , in [ 9 ] ) ;s [ 2 ] = _mm_sub_epi16 ( in [ 5 ] , in [ 10 ] ) ;s [ 3 ] = _mm_sub_epi16 ( in [ 4 ] , in [ 11 ] ) ;s [ 4 ] = _mm_sub_epi16 ( in [ 3 ] , in [ 12 ] ) ;s [ 5 ] = _mm_sub_epi16 ( in [ 2 ] , in [ 13 ] ) ;s [ 6 ] = _mm_sub_epi16 ( in [ 1 ] , in [ 14 ] ) ;s [ 7 ] = _mm_sub_epi16 ( in [ 0 ] , in [ 15 ] ) ;p [ 0 ] = _mm_add_epi16 ( i [ 0 ] , i [ 7 ] ) ;p [ 1 ] = _mm_add_epi16 ( i [ 1 ] , i [ 6 ] ) ;p [ 2 ] = _mm_add_epi16 ( i [ 2 ] , i [ 5 ] ) ;p [ 3 ] = _mm_add_epi16 ( i [ 3 ] , i [ 4 ] ) ;p [ 4 ] = _mm_sub_epi16 ( i [ 3 ] , i [ 4 ] ) ;p [ 5 ] = _mm_sub_epi16 ( i [ 2 ] , i [ 5 ] ) ;p [ 6 ] = _mm_sub_epi16 ( i [ 1 ] , i [ 6 ] ) ;p [ 7 ] = _mm_sub_epi16 ( i [ 0 ] , i [ 7 ] ) ;u [ 0 ] = _mm_add_epi16 ( p [ 0 ] , p [ 3 ] ) ;u [ 1 ] = _mm_add_epi16 ( p [ 1 ] , p [ 2 ] ) ;u [ 2 ] = _mm_sub_epi16 ( p [ 1 ] , p [ 2 ] ) ;u [ 3 ] = _mm_sub_epi16 ( p [ 0 ] , p [ 3 ] ) ;v [ 0 ] = _mm_unpacklo_epi16 ( u [ 0 ] , u [ 1 ] ) ;v [ 1 ] = _mm_unpackhi_epi16 ( u [ 0 ] , u [ 1 ] ) ;v [ 2 ] = _mm_unpacklo_epi16 ( u [ 2 ] , u [ 3 ] ) ;v [ 3 ] = _mm_unpackhi_epi16 ( u [ 2 ] , u [ 3 ] ) ;u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ;u [ 1 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_p16 ) ;u [ 2 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ;u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_m16 ) ;u [ 4 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_p24_p08 ) ;cwe id:CWE-119context:  void fdct16_8col ( __m128i * in ) {  __m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ;  const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;  const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ;  const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;  const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p28_p04 = pair_set_epi16 ( cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m04_p28 = pair_set_epi16 ( - cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p12_p20 = pair_set_epi16 ( cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_m20_p12 = pair_set_epi16 ( - cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p30_p02 = pair_set_epi16 ( cospi_30_64 , cospi_2_64 ) ; const __m128i k__cospi_p14_p18 = pair_set_epi16 ( cospi_14_64 , cospi_18_64 ) ; const __m128i k__cospi_m02_p30 = pair_set_epi16 ( - cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_m18_p14 = pair_set_epi16 ( - cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p22_p10 = pair_set_epi16 ( cospi_22_64 , cospi_10_64 ) ; const __m128i k__cospi_p06_p26 = pair_set_epi16 ( cospi_6_64 , cospi_26_64 ) ; const __m128i k__cospi_m10_p22 = pair_set_epi16 ( - cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_m26_p06 = pair_set_epi16 ( - cospi_26_64 , cospi_6_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; i [ 0 ] = _mm_add_epi16 ( in [ 0 ] , in [ 15 ] ) ; i [ 1 ] = _mm_add_epi16 ( in [ 1 ] , in [ 14 ] ) ; i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , in [ 13 ] ) ; i [ 3 ] = _mm_add_epi16 ( in [ 3 ] , in [ 12 ] ) ; i [ 4 ] = _mm_add_epi16 ( in [ 4 ] , in [ 11 ] ) ; i [ 5 ] = _mm_add_epi16 ( in [ 5 ] , in [ 10 ] ) ; i [ 6 ] = _mm_add_epi16 ( in [ 6 ] , in [ 9 ] ) ; i [ 7 ] = _mm_add_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 0 ] = _mm_sub_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 1 ] = _mm_sub_epi16 ( in [ 6 ] , in [ 9 ] ) ; s [ 2 ] = _mm_sub_epi16 ( in [ 5 ] , in [ 10 ] ) ; s [ 3 ] = _mm_sub_epi16 ( in [ 4 ] , in [ 11 ] ) ; s [ 4 ] = _mm_sub_epi16 ( in [ 3 ] , in [ 12 ] ) ; s [ 5 ] = _mm_sub_epi16 ( in [ 2 ] , in [ 13 ] ) ; s [ 6 ] = _mm_sub_epi16 ( in [ 1 ] , in [ 14 ] ) ; s [ 7 ] = _mm_sub_epi16 ( in [ 0 ] , in [ 15 ] ) ; p [ 0 ] = _mm_add_epi16 ( i [ 0 ] , i [ 7 ] ) ; p [ 1 ] = _mm_add_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 2 ] = _mm_add_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 3 ] = _mm_add_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 4 ] = _mm_sub_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 6 ] = _mm_sub_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 7 ] = _mm_sub_epi16 ( i [ 0 ] , i [ 7 ] ) ; u [ 0 ] = _mm_add_epi16 ( p [ 0 ] , p [ 3 ] ) ; u [ 1 ] = _mm_add_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 2 ] = _mm_sub_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 3 ] = _mm_sub_epi16 ( p [ 0 ] , p [ 3 ] ) ; v [ 0 ] = _mm_unpacklo_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 1 ] = _mm_unpackhi_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 2 ] = _mm_unpacklo_epi16 ( u [ 2 ] , u [ 3 ] ) ; v [ 3 ] = _mm_unpackhi_epi16 ( u [ 2 ] , u [ 3 ] ) ; u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ; u [ 1 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_p16 ) ; u [ 2 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ; u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_m16 ) ; u [ 4 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_p24_p08 ) ; u [ 5 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_p24_p08 ) ; u [ 6 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_m08_p24 ) ; u [ 7 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_m08_p24 ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; in [ 4 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; in [ 8 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; in [ 12 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 5 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 5 ] , p [ 6 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; u [ 0 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; u [ 1 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 0 ] = _mm_add_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 1 ] = _mm_sub_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 2 ] = _mm_sub_epi16 ( p [ 7 ] , u [ 1 ] ) ; t [ 3 ] = _mm_add_epi16 ( p [ 7 ] , u [ 1 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( t [ 1 ] , t [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( t [ 1 ] , t [ 2 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_p04 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_p04 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_p20 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_p20 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m04_p28 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m04_p28 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; in [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 14 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 3 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; p [ 0 ] = _mm_add_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 1 ] = _mm_add_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 2 ] = _mm_sub_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 3 ] = _mm_sub_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 4 ] = _mm_sub_epi16 ( s [ 7 ] , t [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 6 ] = _mm_add_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 7 ] = _mm_add_epi16 ( s [ 7 ] , t [ 4 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( p [ 2 ] , p [ 5 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( p [ 2 ] , p [ 5 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ;  v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ;  v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ;  v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;   u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;  u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 6 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 0 ] = _mm_add_epi16 ( p [ 0 ] , t [ 1 ] ) ; s [ 1 ] = _mm_sub_epi16 ( p [ 0 ] , t [ 1 ] ) ;  s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ;   s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;  s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 6 ] = _mm_sub_epi16 ( p [ 7 ] , t [ 6 ] ) ; s [ 7 ] = _mm_add_epi16 ( p [ 7 ] , t [ 6 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p30_p02 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p30_p02 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p14_p18 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p14_p18 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p22_p10 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p22_p10 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p06_p26 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p06_p26 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m26_p06 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m26_p06 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m10_p22 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m10_p22 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m18_p14 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m18_p14 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m02_p30 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m02_p30 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 13 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 3 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; }","i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , k__cospi_p24_p08 ) ;",31
757,"buggy line: v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_p04 ) ;v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_p04 ) ;v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_p20 ) ;v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_p20 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m20_p12 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m20_p12 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m04_p28 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m04_p28 ) ;u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ;u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ;u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ;u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ;u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ;u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ;v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ;v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ;v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ;v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ;v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ;v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ;v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ;v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ;in [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ;in [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ;in [ 10 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ;in [ 14 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ;u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ;u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ;u [ 2 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ;u [ 3 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ;v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ;v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ;v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ;v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ;u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ;u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ;u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ;u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ;u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ;v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ;v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ;v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ;v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ;v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ;v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ;v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ;v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ;t [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ;t [ 3 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ;t [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ;t [ 5 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ;p [ 0 ] = _mm_add_epi16 ( s [ 0 ] , t [ 3 ] ) ;p [ 1 ] = _mm_add_epi16 ( s [ 1 ] , t [ 2 ] ) ;p [ 2 ] = _mm_sub_epi16 ( s [ 1 ] , t [ 2 ] ) ;p [ 3 ] = _mm_sub_epi16 ( s [ 0 ] , t [ 3 ] ) ;p [ 4 ] = _mm_sub_epi16 ( s [ 7 ] , t [ 4 ] ) ;p [ 5 ] = _mm_sub_epi16 ( s [ 6 ] , t [ 5 ] ) ;p [ 6 ] = _mm_add_epi16 ( s [ 6 ] , t [ 5 ] ) ;p [ 7 ] = _mm_add_epi16 ( s [ 7 ] , t [ 4 ] ) ;u [ 0 ] = _mm_unpacklo_epi16 ( p [ 1 ] , p [ 6 ] ) ;u [ 1 ] = _mm_unpackhi_epi16 ( p [ 1 ] , p [ 6 ] ) ;u [ 2 ] = _mm_unpacklo_epi16 ( p [ 2 ] , p [ 5 ] ) ;u [ 3 ] = _mm_unpackhi_epi16 ( p [ 2 ] , p [ 5 ] ) ;v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ;v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ;v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ;v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ;u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;cwe id:CWE-119context:  void fdct16_8col ( __m128i * in ) {  __m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ;  const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;  const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ;  const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;  const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p28_p04 = pair_set_epi16 ( cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m04_p28 = pair_set_epi16 ( - cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p12_p20 = pair_set_epi16 ( cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_m20_p12 = pair_set_epi16 ( - cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p30_p02 = pair_set_epi16 ( cospi_30_64 , cospi_2_64 ) ; const __m128i k__cospi_p14_p18 = pair_set_epi16 ( cospi_14_64 , cospi_18_64 ) ; const __m128i k__cospi_m02_p30 = pair_set_epi16 ( - cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_m18_p14 = pair_set_epi16 ( - cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p22_p10 = pair_set_epi16 ( cospi_22_64 , cospi_10_64 ) ; const __m128i k__cospi_p06_p26 = pair_set_epi16 ( cospi_6_64 , cospi_26_64 ) ; const __m128i k__cospi_m10_p22 = pair_set_epi16 ( - cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_m26_p06 = pair_set_epi16 ( - cospi_26_64 , cospi_6_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; i [ 0 ] = _mm_add_epi16 ( in [ 0 ] , in [ 15 ] ) ; i [ 1 ] = _mm_add_epi16 ( in [ 1 ] , in [ 14 ] ) ; i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , in [ 13 ] ) ; i [ 3 ] = _mm_add_epi16 ( in [ 3 ] , in [ 12 ] ) ; i [ 4 ] = _mm_add_epi16 ( in [ 4 ] , in [ 11 ] ) ; i [ 5 ] = _mm_add_epi16 ( in [ 5 ] , in [ 10 ] ) ; i [ 6 ] = _mm_add_epi16 ( in [ 6 ] , in [ 9 ] ) ; i [ 7 ] = _mm_add_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 0 ] = _mm_sub_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 1 ] = _mm_sub_epi16 ( in [ 6 ] , in [ 9 ] ) ; s [ 2 ] = _mm_sub_epi16 ( in [ 5 ] , in [ 10 ] ) ; s [ 3 ] = _mm_sub_epi16 ( in [ 4 ] , in [ 11 ] ) ; s [ 4 ] = _mm_sub_epi16 ( in [ 3 ] , in [ 12 ] ) ; s [ 5 ] = _mm_sub_epi16 ( in [ 2 ] , in [ 13 ] ) ; s [ 6 ] = _mm_sub_epi16 ( in [ 1 ] , in [ 14 ] ) ; s [ 7 ] = _mm_sub_epi16 ( in [ 0 ] , in [ 15 ] ) ; p [ 0 ] = _mm_add_epi16 ( i [ 0 ] , i [ 7 ] ) ; p [ 1 ] = _mm_add_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 2 ] = _mm_add_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 3 ] = _mm_add_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 4 ] = _mm_sub_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 6 ] = _mm_sub_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 7 ] = _mm_sub_epi16 ( i [ 0 ] , i [ 7 ] ) ; u [ 0 ] = _mm_add_epi16 ( p [ 0 ] , p [ 3 ] ) ; u [ 1 ] = _mm_add_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 2 ] = _mm_sub_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 3 ] = _mm_sub_epi16 ( p [ 0 ] , p [ 3 ] ) ; v [ 0 ] = _mm_unpacklo_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 1 ] = _mm_unpackhi_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 2 ] = _mm_unpacklo_epi16 ( u [ 2 ] , u [ 3 ] ) ; v [ 3 ] = _mm_unpackhi_epi16 ( u [ 2 ] , u [ 3 ] ) ; u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ; u [ 1 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_p16 ) ; u [ 2 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ; u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_m16 ) ; u [ 4 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_p24_p08 ) ; u [ 5 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_p24_p08 ) ; u [ 6 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_m08_p24 ) ; u [ 7 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_m08_p24 ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; in [ 4 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; in [ 8 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; in [ 12 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 5 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 5 ] , p [ 6 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; u [ 0 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; u [ 1 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 0 ] = _mm_add_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 1 ] = _mm_sub_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 2 ] = _mm_sub_epi16 ( p [ 7 ] , u [ 1 ] ) ; t [ 3 ] = _mm_add_epi16 ( p [ 7 ] , u [ 1 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( t [ 1 ] , t [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( t [ 1 ] , t [ 2 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_p04 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_p04 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_p20 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_p20 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m04_p28 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m04_p28 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; in [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 14 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 3 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; p [ 0 ] = _mm_add_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 1 ] = _mm_add_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 2 ] = _mm_sub_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 3 ] = _mm_sub_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 4 ] = _mm_sub_epi16 ( s [ 7 ] , t [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 6 ] = _mm_add_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 7 ] = _mm_add_epi16 ( s [ 7 ] , t [ 4 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( p [ 2 ] , p [ 5 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( p [ 2 ] , p [ 5 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ;  v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ;  v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ;  v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;   u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;  u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 6 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 0 ] = _mm_add_epi16 ( p [ 0 ] , t [ 1 ] ) ; s [ 1 ] = _mm_sub_epi16 ( p [ 0 ] , t [ 1 ] ) ;  s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ;   s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;  s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 6 ] = _mm_sub_epi16 ( p [ 7 ] , t [ 6 ] ) ; s [ 7 ] = _mm_add_epi16 ( p [ 7 ] , t [ 6 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p30_p02 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p30_p02 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p14_p18 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p14_p18 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p22_p10 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p22_p10 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p06_p26 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p06_p26 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m26_p06 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m26_p06 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m10_p22 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m10_p22 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m18_p14 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m18_p14 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m02_p30 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m02_p30 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 13 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 3 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; }","v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p24_p08 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;u [ 2 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 3 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;",31
758,"buggy line: s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ;cwe id:CWE-119context:  void fdct16_8col ( __m128i * in ) {  __m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ;  const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;  const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ;  const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;  const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p28_p04 = pair_set_epi16 ( cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m04_p28 = pair_set_epi16 ( - cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p12_p20 = pair_set_epi16 ( cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_m20_p12 = pair_set_epi16 ( - cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p30_p02 = pair_set_epi16 ( cospi_30_64 , cospi_2_64 ) ; const __m128i k__cospi_p14_p18 = pair_set_epi16 ( cospi_14_64 , cospi_18_64 ) ; const __m128i k__cospi_m02_p30 = pair_set_epi16 ( - cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_m18_p14 = pair_set_epi16 ( - cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p22_p10 = pair_set_epi16 ( cospi_22_64 , cospi_10_64 ) ; const __m128i k__cospi_p06_p26 = pair_set_epi16 ( cospi_6_64 , cospi_26_64 ) ; const __m128i k__cospi_m10_p22 = pair_set_epi16 ( - cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_m26_p06 = pair_set_epi16 ( - cospi_26_64 , cospi_6_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; i [ 0 ] = _mm_add_epi16 ( in [ 0 ] , in [ 15 ] ) ; i [ 1 ] = _mm_add_epi16 ( in [ 1 ] , in [ 14 ] ) ; i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , in [ 13 ] ) ; i [ 3 ] = _mm_add_epi16 ( in [ 3 ] , in [ 12 ] ) ; i [ 4 ] = _mm_add_epi16 ( in [ 4 ] , in [ 11 ] ) ; i [ 5 ] = _mm_add_epi16 ( in [ 5 ] , in [ 10 ] ) ; i [ 6 ] = _mm_add_epi16 ( in [ 6 ] , in [ 9 ] ) ; i [ 7 ] = _mm_add_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 0 ] = _mm_sub_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 1 ] = _mm_sub_epi16 ( in [ 6 ] , in [ 9 ] ) ; s [ 2 ] = _mm_sub_epi16 ( in [ 5 ] , in [ 10 ] ) ; s [ 3 ] = _mm_sub_epi16 ( in [ 4 ] , in [ 11 ] ) ; s [ 4 ] = _mm_sub_epi16 ( in [ 3 ] , in [ 12 ] ) ; s [ 5 ] = _mm_sub_epi16 ( in [ 2 ] , in [ 13 ] ) ; s [ 6 ] = _mm_sub_epi16 ( in [ 1 ] , in [ 14 ] ) ; s [ 7 ] = _mm_sub_epi16 ( in [ 0 ] , in [ 15 ] ) ; p [ 0 ] = _mm_add_epi16 ( i [ 0 ] , i [ 7 ] ) ; p [ 1 ] = _mm_add_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 2 ] = _mm_add_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 3 ] = _mm_add_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 4 ] = _mm_sub_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 6 ] = _mm_sub_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 7 ] = _mm_sub_epi16 ( i [ 0 ] , i [ 7 ] ) ; u [ 0 ] = _mm_add_epi16 ( p [ 0 ] , p [ 3 ] ) ; u [ 1 ] = _mm_add_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 2 ] = _mm_sub_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 3 ] = _mm_sub_epi16 ( p [ 0 ] , p [ 3 ] ) ; v [ 0 ] = _mm_unpacklo_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 1 ] = _mm_unpackhi_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 2 ] = _mm_unpacklo_epi16 ( u [ 2 ] , u [ 3 ] ) ; v [ 3 ] = _mm_unpackhi_epi16 ( u [ 2 ] , u [ 3 ] ) ; u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ; u [ 1 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_p16 ) ; u [ 2 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ; u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_m16 ) ; u [ 4 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_p24_p08 ) ; u [ 5 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_p24_p08 ) ; u [ 6 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_m08_p24 ) ; u [ 7 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_m08_p24 ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; in [ 4 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; in [ 8 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; in [ 12 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 5 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 5 ] , p [ 6 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; u [ 0 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; u [ 1 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 0 ] = _mm_add_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 1 ] = _mm_sub_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 2 ] = _mm_sub_epi16 ( p [ 7 ] , u [ 1 ] ) ; t [ 3 ] = _mm_add_epi16 ( p [ 7 ] , u [ 1 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( t [ 1 ] , t [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( t [ 1 ] , t [ 2 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_p04 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_p04 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_p20 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_p20 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m04_p28 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m04_p28 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; in [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 14 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 3 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; p [ 0 ] = _mm_add_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 1 ] = _mm_add_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 2 ] = _mm_sub_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 3 ] = _mm_sub_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 4 ] = _mm_sub_epi16 ( s [ 7 ] , t [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 6 ] = _mm_add_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 7 ] = _mm_add_epi16 ( s [ 7 ] , t [ 4 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( p [ 2 ] , p [ 5 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( p [ 2 ] , p [ 5 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ;  v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ;  v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ;  v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;   u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;  u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 6 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 0 ] = _mm_add_epi16 ( p [ 0 ] , t [ 1 ] ) ; s [ 1 ] = _mm_sub_epi16 ( p [ 0 ] , t [ 1 ] ) ;  s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ;   s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;  s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 6 ] = _mm_sub_epi16 ( p [ 7 ] , t [ 6 ] ) ; s [ 7 ] = _mm_add_epi16 ( p [ 7 ] , t [ 6 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p30_p02 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p30_p02 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p14_p18 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p14_p18 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p22_p10 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p22_p10 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p06_p26 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p06_p26 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m26_p06 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m26_p06 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m10_p22 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m10_p22 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m18_p14 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m18_p14 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m02_p30 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m02_p30 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 13 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 3 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; }","s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ;",31
759,"buggy line: cwe id:CWE-835context: static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>syncword\\n"" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>streamid\\n"" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n"" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n"" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ;  if ( pes_signal != 1 || pes_header_data_length == 0 ) {  pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\n"" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , ""header<S2SV_blank>too<S2SV_blank>short\\n"" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , ""audio<S2SV_blank>data<S2SV_blank>corruption\\n"" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }",if ( avio_feof ( pb ) ) {return AVERROR_EOF ;},32
760,"buggy line: if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\cwe id:CWE-835context: static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>syncword\\n"" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>streamid\\n"" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n"" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n"" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ;  if ( pes_signal != 1 || pes_header_data_length == 0 ) {  pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\n"" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , ""header<S2SV_blank>too<S2SV_blank>short\\n"" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , ""audio<S2SV_blank>data<S2SV_blank>corruption\\n"" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }","if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\",32
761,"buggy line: newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;cwe id:CWE-000context: static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ;  newnp -> mcast_oif = inet6_iif ( skb ) ;  newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ;  newnp -> pktoptions = NULL ;  newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }",newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;,33
762,"buggy line: newnp -> pktoptions = NULL ;newnp -> opt = NULL ;cwe id:CWE-000context: static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ;  newnp -> mcast_oif = inet6_iif ( skb ) ;  newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ;  newnp -> pktoptions = NULL ;  newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }",newnp -> pktoptions = NULL ;newnp -> opt = NULL ;,33
763,"buggy line: long elements ;elements = parse_iv2 ( ( * p ) + 2 , p ) ;( * p ) += 2 ;if ( ce -> serialize == NULL ) {object_init_ex ( * rval , ce ) ;else {zend_error ( E_WARNING , ""Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\\\'%s\\\'"" , ce -> name ) ;return 0 ;}cwe id:CWE-125context: static inline long object_common1 ( UNSERIALIZE_PARAMETER , zend_class_entry * ce ) {  long elements ;  elements = parse_iv2 ( ( * p ) + 2 , p ) ; ( * p ) += 2 ; if ( ce -> serialize == NULL ) { object_init_ex ( * rval , ce ) ; } else { zend_error ( E_WARNING , ""Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\'%s\'"" , ce -> name ) ;  return 0 ;  } return elements ; }","long elements ;if ( * p >= max - 2 ) {zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ;return - 1 ;",34
764,"buggy line: trace_kvm_emulate_insn_failed ( vcpu ) ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;cwe id:CWE-362context: static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) { int r = EMULATE_DONE ; ++ vcpu -> stat . insn_emulation_fail ; trace_kvm_emulate_insn_failed ( vcpu ) ;  if ( ! is_guest_mode ( vcpu ) ) {  vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; vcpu -> run -> internal . ndata = 0 ; r = EMULATE_FAIL ; } kvm_queue_exception ( vcpu , UD_VECTOR ) ; return r ; }",trace_kvm_emulate_insn_failed ( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0 ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;,35
765,"buggy line: auth . skb = chunk -> auth_chunk ;auth . asoc = chunk -> asoc ;cwe id:CWE-476context: sctp_disposition_t sctp_sf_do_5_1D_ce ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; sctp_init_chunk_t * peer_init ; struct sctp_chunk * repl ; struct sctp_ulpevent * ev , * ai_ev = NULL ; int error = 0 ; struct sctp_chunk * err_chk_p ; struct sock * sk ; if ( ep == sctp_sk ( net -> sctp . ctl_sock ) -> ep ) { SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; sk = ep -> base . sk ; if ( ! sctp_sstate ( sk , LISTENING ) || ( sctp_style ( sk , TCP ) && sk_acceptq_is_full ( sk ) ) ) return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } peer_init = & chunk -> subh . cookie_hdr -> c . peer_init [ 0 ] ; if ( ! sctp_process_init ( new_asoc , chunk , & chunk -> subh . cookie_hdr -> c . peer_addr , peer_init , GFP_ATOMIC ) ) goto nomem_init ; error = sctp_auth_asoc_init_active_key ( new_asoc , GFP_ATOMIC ) ; if ( error ) goto nomem_init ; if ( chunk -> auth_chunk ) { struct sctp_chunk auth ; sctp_ierror_t ret ;  auth . skb = chunk -> auth_chunk ;  auth . asoc = chunk -> asoc ; auth . sctp_hdr = chunk -> sctp_hdr ; auth . chunk_hdr = ( sctp_chunkhdr_t * ) skb_push ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; skb_pull ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; auth . transport = chunk -> transport ; ret = sctp_sf_authenticate ( net , ep , new_asoc , type , & auth ) ; kfree_skb ( chunk -> auth_chunk ) ; if ( ret != SCTP_IERROR_NO_ERROR ) { sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } repl = sctp_make_cookie_ack ( new_asoc , chunk ) ; if ( ! repl ) goto nomem_init ; ev = sctp_ulpevent_make_assoc_change ( new_asoc , 0 , SCTP_COMM_UP , 0 , new_asoc -> c . sinit_num_ostreams , new_asoc -> c . sinit_max_instreams , NULL , GFP_ATOMIC ) ; if ( ! ev ) goto nomem_ev ; if ( new_asoc -> peer . adaptation_ind ) { ai_ev = sctp_ulpevent_make_adaptation_indication ( new_asoc , GFP_ATOMIC ) ; if ( ! ai_ev ) goto nomem_aiev ; } sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_STATE , SCTP_STATE ( SCTP_STATE_ESTABLISHED ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_CURRESTAB ) ; SCTP_INC_STATS ( net , SCTP_MIB_PASSIVEESTABS ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_HB_TIMERS_START , SCTP_NULL ( ) ) ; if ( new_asoc -> timeouts [ SCTP_EVENT_TIMEOUT_AUTOCLOSE ] ) sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_START , SCTP_TO ( SCTP_EVENT_TIMEOUT_AUTOCLOSE ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( repl ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ev ) ) ; if ( ai_ev ) sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ai_ev ) ) ; return SCTP_DISPOSITION_CONSUME ; nomem_aiev : sctp_ulpevent_free ( ev ) ; nomem_ev : sctp_chunk_free ( repl ) ; nomem_init : sctp_association_free ( new_asoc ) ; nomem : return SCTP_DISPOSITION_NOMEM ; }","if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) {kfree_skb ( chunk -> auth_chunk ) ;sctp_association_free ( new_asoc ) ;return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ;}auth . skb = chunk -> auth_chunk ;auth . asoc = chunk -> asoc ;",36
766,"buggy line: params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;cwe id:CWE-119context: TEE_Result syscall_obj_generate_key ( unsigned long obj , unsigned long key_size , const struct utee_attribute * usr_params , unsigned long param_count ) { TEE_Result res ; struct tee_ta_session * sess ; const struct tee_cryp_obj_type_props * type_props ; struct tee_obj * o ; struct tee_cryp_obj_secret * key ; size_t byte_size ; TEE_Attribute * params = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_STATE ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_STATE ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size % type_props -> quanta != 0 ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size < type_props -> min_size ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size > type_props -> max_size ) return TEE_ERROR_NOT_SUPPORTED ;  params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ;  if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_GENERATE_KEY , type_props , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; switch ( o -> info . objectType ) { case TEE_TYPE_AES : case TEE_TYPE_DES : case TEE_TYPE_DES3 : case TEE_TYPE_HMAC_MD5 : case TEE_TYPE_HMAC_SHA1 : case TEE_TYPE_HMAC_SHA224 : case TEE_TYPE_HMAC_SHA256 : case TEE_TYPE_HMAC_SHA384 : case TEE_TYPE_HMAC_SHA512 : case TEE_TYPE_GENERIC_SECRET : byte_size = key_size / 8 ; if ( o -> info . objectType == TEE_TYPE_DES || o -> info . objectType == TEE_TYPE_DES3 ) { byte_size = ( key_size + key_size / 7 ) / 8 ; } key = ( struct tee_cryp_obj_secret * ) o -> attr ; if ( byte_size > key -> alloc_size ) { res = TEE_ERROR_EXCESS_DATA ; goto out ; } res = crypto_rng_read ( ( void * ) ( key + 1 ) , byte_size ) ; if ( res != TEE_SUCCESS ) goto out ; key -> key_size = byte_size ; o -> have_attrs = ( 1 << type_props -> num_type_attrs ) - 1 ; break ; case TEE_TYPE_RSA_KEYPAIR : res = tee_svc_obj_generate_key_rsa ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DSA_KEYPAIR : res = tee_svc_obj_generate_key_dsa ( o , type_props , key_size ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DH_KEYPAIR : res = tee_svc_obj_generate_key_dh ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_ECDSA_KEYPAIR : case TEE_TYPE_ECDH_KEYPAIR : res = tee_svc_obj_generate_key_ecc ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; default : res = TEE_ERROR_BAD_FORMAT ; } out : free ( params ) ; if ( res == TEE_SUCCESS ) { o -> info . keySize = key_size ; o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; } return res ; }","size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;",37
767,"buggy line: declen = mutt_b64_decode ( out2 , out1 ) ;if ( ! TEST_CHECK ( declen == - 1 ) ) {cwe id:CWE-120context: void test_base64_lengths ( void ) { const char * in = ""FuseMuse"" ; char out1 [ 32 ] ; char out2 [ 32 ] ; size_t enclen ; int declen ; enclen = mutt_b64_encode ( out1 , in , 0 , 32 ) ; if ( ! TEST_CHECK ( enclen == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , 0 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , enclen ) ; } out1 [ 0 ] = '\\0' ;  declen = mutt_b64_decode ( out2 , out1 ) ;  if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , - 1 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , declen ) ; } for ( size_t i = 1 ; i <= 8 ; ++ i ) { enclen = mutt_b64_encode ( out1 , in , i , 32 ) ; size_t exp = ( ( i + 2 ) / 3 ) << 2 ; if ( ! TEST_CHECK ( enclen == exp ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , exp ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , enclen ) ; }  declen = mutt_b64_decode ( out2 , out1 ) ;  if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , i ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , declen ) ; } out2 [ declen ] = '\\0' ; if ( ! TEST_CHECK ( strncmp ( out2 , in , i ) == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%s"" , in ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s"" , out2 ) ; } } }","declen = mutt_b64_decode ( out2 , out1 , sizeof ( out2 ) ) ;if ( ! TEST_CHECK ( declen == - 1 ) ) {",38
768,"buggy line: declen = mutt_b64_decode ( out2 , out1 ) ;if ( ! TEST_CHECK ( declen == i ) ) {cwe id:CWE-120context: void test_base64_lengths ( void ) { const char * in = ""FuseMuse"" ; char out1 [ 32 ] ; char out2 [ 32 ] ; size_t enclen ; int declen ; enclen = mutt_b64_encode ( out1 , in , 0 , 32 ) ; if ( ! TEST_CHECK ( enclen == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , 0 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , enclen ) ; } out1 [ 0 ] = '\\0' ;  declen = mutt_b64_decode ( out2 , out1 ) ;  if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , - 1 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , declen ) ; } for ( size_t i = 1 ; i <= 8 ; ++ i ) { enclen = mutt_b64_encode ( out1 , in , i , 32 ) ; size_t exp = ( ( i + 2 ) / 3 ) << 2 ; if ( ! TEST_CHECK ( enclen == exp ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , exp ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , enclen ) ; }  declen = mutt_b64_decode ( out2 , out1 ) ;  if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , i ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , declen ) ; } out2 [ declen ] = '\\0' ; if ( ! TEST_CHECK ( strncmp ( out2 , in , i ) == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%s"" , in ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s"" , out2 ) ; } } }","declen = mutt_b64_decode ( out2 , out1 , sizeof ( out2 ) ) ;if ( ! TEST_CHECK ( declen == i ) ) {",38
769,"buggy line: RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ;RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ;RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ;RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ;RANGE_CHECK_HI ( cfg , g_profile , 3 ) ;cwe id:CWE-119context: static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg , const struct vp8_extracfg * vp8_cfg , int finalize ) { RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ;  RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ;  RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ; RANGE_CHECK_HI ( cfg , g_threads , 64 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # else RANGE_CHECK_HI ( cfg , g_lag_in_frames , 25 ) ; # endif RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ; # if CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , rc_resize_allowed , 0 ) ; # else RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ; # endif RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # else RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ; # endif if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ; RANGE_CHECK_BOOL ( vp8_cfg , enable_auto_alt_ref ) ; RANGE_CHECK ( vp8_cfg , cpu_used , - 16 , 16 ) ; # if CONFIG_REALTIME_ONLY && ! CONFIG_TEMPORAL_DENOISING RANGE_CHECK ( vp8_cfg , noise_sensitivity , 0 , 0 ) ; # else RANGE_CHECK_HI ( vp8_cfg , noise_sensitivity , 6 ) ; # endif RANGE_CHECK ( vp8_cfg , token_partitions , VP8_ONE_TOKENPARTITION , VP8_EIGHT_TOKENPARTITION ) ; RANGE_CHECK_HI ( vp8_cfg , Sharpness , 7 ) ; RANGE_CHECK ( vp8_cfg , arnr_max_frames , 0 , 15 ) ; RANGE_CHECK_HI ( vp8_cfg , arnr_strength , 6 ) ; RANGE_CHECK ( vp8_cfg , arnr_type , 1 , 3 ) ;  RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ;  if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cfg -> g_pass == VPX_RC_LAST_PASS ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; FIRSTPASS_STATS * stats ; if ( ! cfg -> rc_twopass_stats_in . buf ) ERROR ( ""rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set."" ) ; if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) ERROR ( ""rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet."" ) ; if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets."" ) ; stats = ( void * ) ( ( char * ) cfg -> rc_twopass_stats_in . buf + ( n_packets - 1 ) * packet_sz ) ; if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ; } # endif RANGE_CHECK ( cfg , ts_number_layers , 1 , 5 ) ; if ( cfg -> ts_number_layers > 1 ) { unsigned int i ; RANGE_CHECK_HI ( cfg , ts_periodicity , 16 ) ; for ( i = 1 ; i < cfg -> ts_number_layers ; i ++ )  if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] )  ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ; RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ; for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; i -- ) if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; RANGE_CHECK_HI ( cfg , ts_layer_id [ i ] , cfg -> ts_number_layers - 1 ) ; } # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cfg -> g_threads > ( 1 << vp8_cfg -> token_partitions ) ) ERROR ( ""g_threads<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>token<S2SV_blank>partitions"" ) ; # endif return VPX_CODEC_OK ; }","RANGE_CHECK ( cfg , g_w , 1 , 1000000000 ) ;RANGE_CHECK_HI ( cfg , g_profile , 3 ) ;",39
770,"buggy line: RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ;if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ;cwe id:CWE-119context: static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg , const struct vp8_extracfg * vp8_cfg , int finalize ) { RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ;  RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ;  RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ; RANGE_CHECK_HI ( cfg , g_threads , 64 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # else RANGE_CHECK_HI ( cfg , g_lag_in_frames , 25 ) ; # endif RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ; # if CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , rc_resize_allowed , 0 ) ; # else RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ; # endif RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # else RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ; # endif if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ; RANGE_CHECK_BOOL ( vp8_cfg , enable_auto_alt_ref ) ; RANGE_CHECK ( vp8_cfg , cpu_used , - 16 , 16 ) ; # if CONFIG_REALTIME_ONLY && ! CONFIG_TEMPORAL_DENOISING RANGE_CHECK ( vp8_cfg , noise_sensitivity , 0 , 0 ) ; # else RANGE_CHECK_HI ( vp8_cfg , noise_sensitivity , 6 ) ; # endif RANGE_CHECK ( vp8_cfg , token_partitions , VP8_ONE_TOKENPARTITION , VP8_EIGHT_TOKENPARTITION ) ; RANGE_CHECK_HI ( vp8_cfg , Sharpness , 7 ) ; RANGE_CHECK ( vp8_cfg , arnr_max_frames , 0 , 15 ) ; RANGE_CHECK_HI ( vp8_cfg , arnr_strength , 6 ) ; RANGE_CHECK ( vp8_cfg , arnr_type , 1 , 3 ) ;  RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ;  if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cfg -> g_pass == VPX_RC_LAST_PASS ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; FIRSTPASS_STATS * stats ; if ( ! cfg -> rc_twopass_stats_in . buf ) ERROR ( ""rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set."" ) ; if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) ERROR ( ""rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet."" ) ; if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets."" ) ; stats = ( void * ) ( ( char * ) cfg -> rc_twopass_stats_in . buf + ( n_packets - 1 ) * packet_sz ) ; if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ; } # endif RANGE_CHECK ( cfg , ts_number_layers , 1 , 5 ) ; if ( cfg -> ts_number_layers > 1 ) { unsigned int i ; RANGE_CHECK_HI ( cfg , ts_periodicity , 16 ) ; for ( i = 1 ; i < cfg -> ts_number_layers ; i ++ )  if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] )  ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ; RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ; for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; i -- ) if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; RANGE_CHECK_HI ( cfg , ts_layer_id [ i ] , cfg -> ts_number_layers - 1 ) ; } # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cfg -> g_threads > ( 1 << vp8_cfg -> token_partitions ) ) ERROR ( ""g_threads<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>token<S2SV_blank>partitions"" ) ; # endif return VPX_CODEC_OK ; }","RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ;RANGE_CHECK_HI ( vp8_cfg , screen_content_mode , 2 ) ;if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ;",39
771,"buggy line: i ++ )  if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] )  ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ;cwe id:CWE-119context: static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg , const struct vp8_extracfg * vp8_cfg , int finalize ) { RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ;  RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ;  RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ; RANGE_CHECK_HI ( cfg , g_threads , 64 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # else RANGE_CHECK_HI ( cfg , g_lag_in_frames , 25 ) ; # endif RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ; # if CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , rc_resize_allowed , 0 ) ; # else RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ; # endif RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # else RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ; # endif if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ; RANGE_CHECK_BOOL ( vp8_cfg , enable_auto_alt_ref ) ; RANGE_CHECK ( vp8_cfg , cpu_used , - 16 , 16 ) ; # if CONFIG_REALTIME_ONLY && ! CONFIG_TEMPORAL_DENOISING RANGE_CHECK ( vp8_cfg , noise_sensitivity , 0 , 0 ) ; # else RANGE_CHECK_HI ( vp8_cfg , noise_sensitivity , 6 ) ; # endif RANGE_CHECK ( vp8_cfg , token_partitions , VP8_ONE_TOKENPARTITION , VP8_EIGHT_TOKENPARTITION ) ; RANGE_CHECK_HI ( vp8_cfg , Sharpness , 7 ) ; RANGE_CHECK ( vp8_cfg , arnr_max_frames , 0 , 15 ) ; RANGE_CHECK_HI ( vp8_cfg , arnr_strength , 6 ) ; RANGE_CHECK ( vp8_cfg , arnr_type , 1 , 3 ) ;  RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ;  if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cfg -> g_pass == VPX_RC_LAST_PASS ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; FIRSTPASS_STATS * stats ; if ( ! cfg -> rc_twopass_stats_in . buf ) ERROR ( ""rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set."" ) ; if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) ERROR ( ""rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet."" ) ; if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets."" ) ; stats = ( void * ) ( ( char * ) cfg -> rc_twopass_stats_in . buf + ( n_packets - 1 ) * packet_sz ) ; if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ; } # endif RANGE_CHECK ( cfg , ts_number_layers , 1 , 5 ) ; if ( cfg -> ts_number_layers > 1 ) { unsigned int i ; RANGE_CHECK_HI ( cfg , ts_periodicity , 16 ) ; for ( i = 1 ; i < cfg -> ts_number_layers ; i ++ )  if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] )  ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ; RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ; for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; i -- ) if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; RANGE_CHECK_HI ( cfg , ts_layer_id [ i ] , cfg -> ts_number_layers - 1 ) ; } # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cfg -> g_threads > ( 1 << vp8_cfg -> token_partitions ) ) ERROR ( ""g_threads<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>token<S2SV_blank>partitions"" ) ; # endif return VPX_CODEC_OK ; }","i ++ ) if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] && cfg -> rc_target_bitrate > 0 ) ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ;",39
772,"buggy line: if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ;if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ;ret = 0 ;if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ;key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , KEY_NEED_SETATTR ) ;if ( IS_ERR ( key_ref ) ) {ret = PTR_ERR ( key_ref ) ;goto error ;}key = key_ref_to_ptr ( key_ref ) ;ret = - EACCES ;down_write ( & key -> sem ) ;if ( ! capable ( CAP_SYS_ADMIN ) ) {if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ;if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ;}if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) {ret = - ENOMEM ;newowner = key_user_lookup ( uid ) ;if ( ! newowner ) goto error_put ;if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) {unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ;unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ;spin_lock ( & newowner -> lock ) ;if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ;newowner -> qnkeys ++ ;newowner -> qnbytes += key -> quotalen ;spin_unlock ( & newowner -> lock ) ;spin_lock ( & key -> user -> lock ) ;key -> user -> qnkeys -- ;key -> user -> qnbytes -= key -> quotalen ;spin_unlock ( & key -> user -> lock ) ;}atomic_dec ( & key -> user -> nkeys ) ;atomic_inc ( & newowner -> nkeys ) ;if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {atomic_dec ( & key -> user -> nikeys ) ;cwe id:CWE-20context: long keyctl_chown_key ( key_serial_t id , uid_t user , gid_t group ) { struct key_user * newowner , * zapowner = NULL ; struct key * key ; key_ref_t key_ref ; long ret ; kuid_t uid ; kgid_t gid ; uid = make_kuid ( current_user_ns ( ) , user ) ; gid = make_kgid ( current_user_ns ( ) , group ) ; ret = - EINVAL ; if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ; if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ; ret = 0 ; if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ; key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , KEY_NEED_SETATTR ) ; if ( IS_ERR ( key_ref ) ) { ret = PTR_ERR ( key_ref ) ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = - EACCES ; down_write ( & key -> sem ) ; if ( ! capable ( CAP_SYS_ADMIN ) ) { if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ; if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ; } if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) { ret = - ENOMEM ; newowner = key_user_lookup ( uid ) ; if ( ! newowner ) goto error_put ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & newowner -> lock ) ; if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ; newowner -> qnkeys ++ ; newowner -> qnbytes += key -> quotalen ; spin_unlock ( & newowner -> lock ) ; spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; atomic_inc ( & newowner -> nkeys ) ;  if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {  atomic_dec ( & key -> user -> nikeys ) ; atomic_inc ( & newowner -> nikeys ) ; } zapowner = key -> user ; key -> user = newowner ; key -> uid = uid ; } if ( group != ( gid_t ) - 1 ) key -> gid = gid ; ret = 0 ; error_put : up_write ( & key -> sem ) ; key_put ( key ) ; if ( zapowner ) key_user_put ( zapowner ) ; error : return ret ; quota_overrun : spin_unlock ( & newowner -> lock ) ; zapowner = newowner ; ret = - EDQUOT ; goto error_put ; }",if ( key -> state != KEY_IS_UNINSTANTIATED ) {atomic_dec ( & key -> user -> nikeys ) ;,40
773,"buggy line: long mtemp , save_adjust , rem ;s64 freq_adj ;cwe id:CWE-189context: int do_adjtimex ( struct timex * txc ) {  long mtemp , save_adjust , rem ;  s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ; # if 0 time_status &= ~ STA_CLOCKERR ; # endif if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc -> maxerror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_maxerror = txc -> maxerror ; } if ( txc -> modes & ADJ_ESTERROR ) { if ( txc -> esterror < 0 || txc -> esterror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_esterror = txc -> esterror ; } if ( txc -> modes & ADJ_TIMECONST ) { if ( txc -> constant < 0 ) { result = - EINVAL ; goto leave ; } time_constant = min ( txc -> constant + 4 , ( long ) MAXTC ) ; } if ( txc -> modes & ADJ_OFFSET ) { if ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) { time_adjust = txc -> offset ; } else if ( time_status & STA_PLL ) { time_offset = txc -> offset * NSEC_PER_USEC ; time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ; time_offset = max ( time_offset , ( s64 ) - MAXPHASE * NSEC_PER_USEC ) ; if ( time_status & STA_FREQHOLD || time_reftime == 0 ) time_reftime = xtime . tv_sec ; mtemp = xtime . tv_sec - time_reftime ; time_reftime = xtime . tv_sec ; freq_adj = time_offset * mtemp ; freq_adj = shift_right ( freq_adj , time_constant * 2 + ( SHIFT_PLL + 2 ) * 2 - SHIFT_NSEC ) ; if ( mtemp >= MINSEC && ( time_status & STA_FLL || mtemp > MAXSEC ) ) freq_adj += div_s64 ( time_offset << ( SHIFT_NSEC - SHIFT_FLL ) , mtemp ) ; freq_adj += time_freq ; freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ;  time_offset = div_long_long_rem_signed ( time_offset ,   NTP_INTERVAL_FREQ ,  & rem ) ; time_offset <<= SHIFT_UPDATE ; } } if ( txc -> modes & ADJ_TICK ) tick_usec = txc -> tick ; if ( txc -> modes & ( ADJ_TICK | ADJ_FREQUENCY | ADJ_OFFSET ) ) ntp_update_frequency ( ) ; } leave : if ( ( time_status & ( STA_UNSYNC | STA_CLOCKERR ) ) != 0 ) result = TIME_ERROR ; if ( ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) || ( txc -> modes == ADJ_OFFSET_SS_READ ) ) txc -> offset = save_adjust ; else txc -> offset = ( ( long ) shift_right ( time_offset , SHIFT_UPDATE ) ) * NTP_INTERVAL_FREQ / 1000 ; txc -> freq = ( time_freq / NSEC_PER_USEC ) << ( SHIFT_USEC - SHIFT_NSEC ) ; txc -> maxerror = time_maxerror ; txc -> esterror = time_esterror ; txc -> status = time_status ; txc -> constant = time_constant ; txc -> precision = 1 ; txc -> tolerance = MAXFREQ ; txc -> tick = tick_usec ; txc -> ppsfreq = 0 ; txc -> jitter = 0 ; txc -> shift = 0 ; txc -> stabil = 0 ; txc -> jitcnt = 0 ; txc -> calcnt = 0 ; txc -> errcnt = 0 ; txc -> stbcnt = 0 ; write_sequnlock_irq ( & xtime_lock ) ; do_gettimeofday ( & txc -> time ) ; notify_cmos_timer ( ) ; return ( result ) ; }","long mtemp , save_adjust ;s64 freq_adj ;",41
774,"buggy line: time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ;cwe id:CWE-189context: int do_adjtimex ( struct timex * txc ) {  long mtemp , save_adjust , rem ;  s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ; # if 0 time_status &= ~ STA_CLOCKERR ; # endif if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc -> maxerror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_maxerror = txc -> maxerror ; } if ( txc -> modes & ADJ_ESTERROR ) { if ( txc -> esterror < 0 || txc -> esterror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_esterror = txc -> esterror ; } if ( txc -> modes & ADJ_TIMECONST ) { if ( txc -> constant < 0 ) { result = - EINVAL ; goto leave ; } time_constant = min ( txc -> constant + 4 , ( long ) MAXTC ) ; } if ( txc -> modes & ADJ_OFFSET ) { if ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) { time_adjust = txc -> offset ; } else if ( time_status & STA_PLL ) { time_offset = txc -> offset * NSEC_PER_USEC ; time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ; time_offset = max ( time_offset , ( s64 ) - MAXPHASE * NSEC_PER_USEC ) ; if ( time_status & STA_FREQHOLD || time_reftime == 0 ) time_reftime = xtime . tv_sec ; mtemp = xtime . tv_sec - time_reftime ; time_reftime = xtime . tv_sec ; freq_adj = time_offset * mtemp ; freq_adj = shift_right ( freq_adj , time_constant * 2 + ( SHIFT_PLL + 2 ) * 2 - SHIFT_NSEC ) ; if ( mtemp >= MINSEC && ( time_status & STA_FLL || mtemp > MAXSEC ) ) freq_adj += div_s64 ( time_offset << ( SHIFT_NSEC - SHIFT_FLL ) , mtemp ) ; freq_adj += time_freq ; freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ;  time_offset = div_long_long_rem_signed ( time_offset ,   NTP_INTERVAL_FREQ ,  & rem ) ; time_offset <<= SHIFT_UPDATE ; } } if ( txc -> modes & ADJ_TICK ) tick_usec = txc -> tick ; if ( txc -> modes & ( ADJ_TICK | ADJ_FREQUENCY | ADJ_OFFSET ) ) ntp_update_frequency ( ) ; } leave : if ( ( time_status & ( STA_UNSYNC | STA_CLOCKERR ) ) != 0 ) result = TIME_ERROR ; if ( ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) || ( txc -> modes == ADJ_OFFSET_SS_READ ) ) txc -> offset = save_adjust ; else txc -> offset = ( ( long ) shift_right ( time_offset , SHIFT_UPDATE ) ) * NTP_INTERVAL_FREQ / 1000 ; txc -> freq = ( time_freq / NSEC_PER_USEC ) << ( SHIFT_USEC - SHIFT_NSEC ) ; txc -> maxerror = time_maxerror ; txc -> esterror = time_esterror ; txc -> status = time_status ; txc -> constant = time_constant ; txc -> precision = 1 ; txc -> tolerance = MAXFREQ ; txc -> tick = tick_usec ; txc -> ppsfreq = 0 ; txc -> jitter = 0 ; txc -> shift = 0 ; txc -> stabil = 0 ; txc -> jitcnt = 0 ; txc -> calcnt = 0 ; txc -> errcnt = 0 ; txc -> stbcnt = 0 ; write_sequnlock_irq ( & xtime_lock ) ; do_gettimeofday ( & txc -> time ) ; notify_cmos_timer ( ) ; return ( result ) ; }","time_offset = div_s64 ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ;",41
775,"buggy line: time_offset = div_long_long_rem_signed ( time_offset ,   NTP_INTERVAL_FREQ ,  & rem ) ;cwe id:CWE-189context: int do_adjtimex ( struct timex * txc ) {  long mtemp , save_adjust , rem ;  s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ; # if 0 time_status &= ~ STA_CLOCKERR ; # endif if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc -> maxerror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_maxerror = txc -> maxerror ; } if ( txc -> modes & ADJ_ESTERROR ) { if ( txc -> esterror < 0 || txc -> esterror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_esterror = txc -> esterror ; } if ( txc -> modes & ADJ_TIMECONST ) { if ( txc -> constant < 0 ) { result = - EINVAL ; goto leave ; } time_constant = min ( txc -> constant + 4 , ( long ) MAXTC ) ; } if ( txc -> modes & ADJ_OFFSET ) { if ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) { time_adjust = txc -> offset ; } else if ( time_status & STA_PLL ) { time_offset = txc -> offset * NSEC_PER_USEC ; time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ; time_offset = max ( time_offset , ( s64 ) - MAXPHASE * NSEC_PER_USEC ) ; if ( time_status & STA_FREQHOLD || time_reftime == 0 ) time_reftime = xtime . tv_sec ; mtemp = xtime . tv_sec - time_reftime ; time_reftime = xtime . tv_sec ; freq_adj = time_offset * mtemp ; freq_adj = shift_right ( freq_adj , time_constant * 2 + ( SHIFT_PLL + 2 ) * 2 - SHIFT_NSEC ) ; if ( mtemp >= MINSEC && ( time_status & STA_FLL || mtemp > MAXSEC ) ) freq_adj += div_s64 ( time_offset << ( SHIFT_NSEC - SHIFT_FLL ) , mtemp ) ; freq_adj += time_freq ; freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ;  time_offset = div_long_long_rem_signed ( time_offset ,   NTP_INTERVAL_FREQ ,  & rem ) ; time_offset <<= SHIFT_UPDATE ; } } if ( txc -> modes & ADJ_TICK ) tick_usec = txc -> tick ; if ( txc -> modes & ( ADJ_TICK | ADJ_FREQUENCY | ADJ_OFFSET ) ) ntp_update_frequency ( ) ; } leave : if ( ( time_status & ( STA_UNSYNC | STA_CLOCKERR ) ) != 0 ) result = TIME_ERROR ; if ( ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) || ( txc -> modes == ADJ_OFFSET_SS_READ ) ) txc -> offset = save_adjust ; else txc -> offset = ( ( long ) shift_right ( time_offset , SHIFT_UPDATE ) ) * NTP_INTERVAL_FREQ / 1000 ; txc -> freq = ( time_freq / NSEC_PER_USEC ) << ( SHIFT_USEC - SHIFT_NSEC ) ; txc -> maxerror = time_maxerror ; txc -> esterror = time_esterror ; txc -> status = time_status ; txc -> constant = time_constant ; txc -> precision = 1 ; txc -> tolerance = MAXFREQ ; txc -> tick = tick_usec ; txc -> ppsfreq = 0 ; txc -> jitter = 0 ; txc -> shift = 0 ; txc -> stabil = 0 ; txc -> jitcnt = 0 ; txc -> calcnt = 0 ; txc -> errcnt = 0 ; txc -> stbcnt = 0 ; write_sequnlock_irq ( & xtime_lock ) ; do_gettimeofday ( & txc -> time ) ; notify_cmos_timer ( ) ; return ( result ) ; }","time_offset = div_long_long_rem_signed ( time_offset , NTP_INTERVAL_FREQ ) ;",41
776,"buggy line: cwe id:CWE-125context: static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>ubik<S2SV_blank>call<S2SV_blank>%s"" , tok2str ( ubik_req , ""op#%d"" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>syncsite<S2SV_blank>%s"" , temp ? ""yes"" : ""no"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>votestart"" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , ""<S2SV_blank>site"" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ;  temp = EXTRACT_32BITS ( bp ) ;  bp += sizeof ( int32_t ) ; tok2str ( ubik_lock_types , ""type<S2SV_blank>%d"" , temp ) ; break ; case 20003 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; break ; case 20005 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; break ; case 20006 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20009 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; break ; case 20012 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>oldversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>newversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; default : ; } return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|ubik]"" ) ) ; }",ND_TCHECK_32BITS ( bp ) ;,42
777,"buggy line: temp = EXTRACT_32BITS ( bp ) ;bp += sizeof ( int32_t ) ;cwe id:CWE-125context: static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>ubik<S2SV_blank>call<S2SV_blank>%s"" , tok2str ( ubik_req , ""op#%d"" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>syncsite<S2SV_blank>%s"" , temp ? ""yes"" : ""no"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>votestart"" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , ""<S2SV_blank>site"" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ;  temp = EXTRACT_32BITS ( bp ) ;  bp += sizeof ( int32_t ) ; tok2str ( ubik_lock_types , ""type<S2SV_blank>%d"" , temp ) ; break ; case 20003 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; break ; case 20005 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; break ; case 20006 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20009 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; break ; case 20012 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>oldversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>newversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; default : ; } return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|ubik]"" ) ) ; }",temp = EXTRACT_32BITS ( bp ) ;bp += sizeof ( int32_t ) ;,42
778,"buggy line: if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {char hexstr [ 3 ] ;cwe id:CWE-119context: CURLcode Curl_urldecode ( struct SessionHandle * data , const char * string , size_t length , char * * ostring , size_t * olen , bool reject_ctrl ) { size_t alloc = ( length ? length : strlen ( string ) ) + 1 ; char * ns = malloc ( alloc ) ; unsigned char in ; size_t strindex = 0 ; unsigned long hex ; CURLcode res ; if ( ! ns ) return CURLE_OUT_OF_MEMORY ; while ( -- alloc > 0 ) { in = * string ;  if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {  char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; res = Curl_convert_from_network ( data , & in , 1 ) ; if ( res ) { free ( ns ) ; return res ; } string += 2 ; alloc -= 2 ; } if ( reject_ctrl && ( in < 0x20 ) ) { free ( ns ) ; return CURLE_URL_MALFORMAT ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) * olen = strindex ; if ( ostring ) * ostring = ns ; return CURLE_OK ; }",if ( ( '%' == in ) && ( alloc > 2 ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {char hexstr [ 3 ] ;,43
779,"buggy line: size_t length ;uint_t i ;if ( segment -> dataOffset < 5 )  return NULL ;length = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ;i = 0 ;if ( option -> kind == TCP_OPTION_NOP )  {continue ;}if ( option -> kind == TCP_OPTION_END ) break ;if ( ( i + 1 ) >= length || ( i + option -> length ) > length )  break ;return NULL ;}cwe id:CWE-20context: TcpOption * tcpGetOption ( TcpHeader * segment , uint8_t kind ) {  size_t length ;  uint_t i ; TcpOption * option ;  if ( segment -> dataOffset < 5 )  return NULL ;  length = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ;  i = 0 ; while ( i < length ) { option = ( TcpOption * ) ( segment -> options + i ) ;  if ( option -> kind == TCP_OPTION_NOP )  { i ++ ;  continue ;  } if ( option -> kind == TCP_OPTION_END ) break ;  if ( ( i + 1 ) >= length || ( i + option -> length ) > length )  break ; if ( option -> kind == kind ) return option ; i += option -> length ; }  return NULL ;  }",size_t i ;size_t length ;if ( segment -> dataOffset >= ( sizeof ( TcpHeader ) / 4 ) ) {length = ( segment -> dataOffset * 4 ) - sizeof ( TcpHeader ) ;i = 0 ;if ( option -> kind == TCP_OPTION_END ) {break ;}else if ( option -> kind == TCP_OPTION_NOP ) {}else {if ( ( i + 1 ) >= length ) break ;if ( option -> length < sizeof ( TcpOption ) || ( i + option -> length ) > length ) break ;}}return NULL ;},44
780,"buggy line: double vp9_convert_qindex_to_q ( int qindex ) {return vp9_ac_quant ( qindex , 0 ) / 4.0 ;}cwe id:CWE-119context:  double vp9_convert_qindex_to_q ( int qindex ) {   return vp9_ac_quant ( qindex , 0 ) / 4.0 ;   } ","double vp9_convert_qindex_to_q ( int qindex , vpx_bit_depth_t bit_depth ) {# if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) {case VPX_BITS_8 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ;case VPX_BITS_10 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 16.0 ;case VPX_BITS_12 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 64.0 ;default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ;return - 1.0 ;}# else return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ;# endif }",45
781,"buggy line: if ( byte [ i ] & 0x40 )  i -- ;cwe id:CWE-125context: void bit_write_MC ( Bit_Chain * dat , BITCODE_MC val ) { int i , j ; int negative = 0 ; unsigned char byte [ 5 ] ; BITCODE_UMC mask = 0x0000007f ; BITCODE_UMC value = ( BITCODE_UMC ) val ; if ( val < 0 ) { negative = 1 ; value = ( BITCODE_UMC ) - val ; } for ( i = 4 , j = 0 ; i >= 0 ; i -- , j += 7 ) { byte [ i ] = ( unsigned char ) ( ( value & mask ) >> j ) ; byte [ i ] |= 0x80 ; mask = mask << 7 ; } for ( i = 0 ; i < 4 ; i ++ ) if ( byte [ i ] & 0x7f ) break ;  if ( byte [ i ] & 0x40 )  i -- ; byte [ i ] &= 0x7f ; if ( negative ) byte [ i ] |= 0x40 ; for ( j = 4 ; j >= i ; j -- ) bit_write_RC ( dat , byte [ j ] ) ; }",if ( byte [ i ] & 0x40 && i > 0 ) i -- ;,46
782,"buggy line: if ( s -> pts == AV_NOPTS_VALUE ) {cwe id:CWE-399context: static int filter_frame ( AVFilterLink * inlink , AVFrame * buf ) { AVFilterContext * ctx = inlink -> dst ; FPSContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int64_t delta ; int i , ret ; s -> frames_in ++ ; if ( s -> pts == AV_NOPTS_VALUE ) { if ( buf -> pts != AV_NOPTS_VALUE ) { ret = write_to_fifo ( s -> fifo , buf ) ; if ( ret < 0 ) return ret ; if ( s -> start_time != DBL_MAX && s -> start_time != AV_NOPTS_VALUE ) { double first_pts = s -> start_time * AV_TIME_BASE ; first_pts = FFMIN ( FFMAX ( first_pts , INT64_MIN ) , INT64_MAX ) ; s -> first_pts = s -> pts = av_rescale_q ( first_pts , AV_TIME_BASE_Q , inlink -> time_base ) ; av_log ( ctx , AV_LOG_VERBOSE , ""Set<S2SV_blank>first<S2SV_blank>pts<S2SV_blank>to<S2SV_blank>(in:%"" PRId64 ""<S2SV_blank>out:%"" PRId64 "")\\n"" , s -> first_pts , av_rescale_q ( first_pts , AV_TIME_BASE_Q , outlink -> time_base ) ) ; } else { s -> first_pts = s -> pts = buf -> pts ; } } else { av_log ( ctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>initial<S2SV_blank>frame(s)<S2SV_blank>with<S2SV_blank>no<S2SV_blank>"" ""timestamp.\\n"" ) ; av_frame_free ( & buf ) ; s -> drop ++ ; } return 0 ; }  if ( buf -> pts == AV_NOPTS_VALUE ) {  return write_to_fifo ( s -> fifo , buf ) ; } delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ) ; if ( delta < 1 ) { AVFrame * tmp ; int drop = av_fifo_size ( s -> fifo ) / sizeof ( AVFrame * ) ; av_log ( ctx , AV_LOG_DEBUG , ""Dropping<S2SV_blank>%d<S2SV_blank>frame(s).\\n"" , drop ) ; s -> drop += drop ; av_fifo_generic_read ( s -> fifo , & tmp , sizeof ( tmp ) , NULL ) ; flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , tmp ) ; av_frame_free ( & buf ) ; return ret ; } for ( i = 0 ; i < delta ; i ++ ) { AVFrame * buf_out ; av_fifo_generic_read ( s -> fifo , & buf_out , sizeof ( buf_out ) , NULL ) ; if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 ) { AVFrame * dup = av_frame_clone ( buf_out ) ; av_log ( ctx , AV_LOG_DEBUG , ""Duplicating<S2SV_blank>frame.\\n"" ) ; if ( dup ) ret = write_to_fifo ( s -> fifo , dup ) ; else ret = AVERROR ( ENOMEM ) ; if ( ret < 0 ) { av_frame_free ( & buf_out ) ; av_frame_free ( & buf ) ; return ret ; } s -> dup ++ ; } buf_out -> pts = av_rescale_q ( s -> first_pts , inlink -> time_base , outlink -> time_base ) + s -> frames_out ; if ( ( ret = ff_filter_frame ( outlink , buf_out ) ) < 0 ) { av_frame_free ( & buf ) ; return ret ; } s -> frames_out ++ ; } flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , buf ) ; s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ) ; return ret ; }",if ( s -> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0 ) {,47
783,"buggy line: if ( buf -> pts == AV_NOPTS_VALUE ) {return write_to_fifo ( s -> fifo , buf ) ;cwe id:CWE-399context: static int filter_frame ( AVFilterLink * inlink , AVFrame * buf ) { AVFilterContext * ctx = inlink -> dst ; FPSContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int64_t delta ; int i , ret ; s -> frames_in ++ ; if ( s -> pts == AV_NOPTS_VALUE ) { if ( buf -> pts != AV_NOPTS_VALUE ) { ret = write_to_fifo ( s -> fifo , buf ) ; if ( ret < 0 ) return ret ; if ( s -> start_time != DBL_MAX && s -> start_time != AV_NOPTS_VALUE ) { double first_pts = s -> start_time * AV_TIME_BASE ; first_pts = FFMIN ( FFMAX ( first_pts , INT64_MIN ) , INT64_MAX ) ; s -> first_pts = s -> pts = av_rescale_q ( first_pts , AV_TIME_BASE_Q , inlink -> time_base ) ; av_log ( ctx , AV_LOG_VERBOSE , ""Set<S2SV_blank>first<S2SV_blank>pts<S2SV_blank>to<S2SV_blank>(in:%"" PRId64 ""<S2SV_blank>out:%"" PRId64 "")\\n"" , s -> first_pts , av_rescale_q ( first_pts , AV_TIME_BASE_Q , outlink -> time_base ) ) ; } else { s -> first_pts = s -> pts = buf -> pts ; } } else { av_log ( ctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>initial<S2SV_blank>frame(s)<S2SV_blank>with<S2SV_blank>no<S2SV_blank>"" ""timestamp.\\n"" ) ; av_frame_free ( & buf ) ; s -> drop ++ ; } return 0 ; }  if ( buf -> pts == AV_NOPTS_VALUE ) {  return write_to_fifo ( s -> fifo , buf ) ; } delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ) ; if ( delta < 1 ) { AVFrame * tmp ; int drop = av_fifo_size ( s -> fifo ) / sizeof ( AVFrame * ) ; av_log ( ctx , AV_LOG_DEBUG , ""Dropping<S2SV_blank>%d<S2SV_blank>frame(s).\\n"" , drop ) ; s -> drop += drop ; av_fifo_generic_read ( s -> fifo , & tmp , sizeof ( tmp ) , NULL ) ; flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , tmp ) ; av_frame_free ( & buf ) ; return ret ; } for ( i = 0 ; i < delta ; i ++ ) { AVFrame * buf_out ; av_fifo_generic_read ( s -> fifo , & buf_out , sizeof ( buf_out ) , NULL ) ; if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 ) { AVFrame * dup = av_frame_clone ( buf_out ) ; av_log ( ctx , AV_LOG_DEBUG , ""Duplicating<S2SV_blank>frame.\\n"" ) ; if ( dup ) ret = write_to_fifo ( s -> fifo , dup ) ; else ret = AVERROR ( ENOMEM ) ; if ( ret < 0 ) { av_frame_free ( & buf_out ) ; av_frame_free ( & buf ) ; return ret ; } s -> dup ++ ; } buf_out -> pts = av_rescale_q ( s -> first_pts , inlink -> time_base , outlink -> time_base ) + s -> frames_out ; if ( ( ret = ff_filter_frame ( outlink , buf_out ) ) < 0 ) { av_frame_free ( & buf ) ; return ret ; } s -> frames_out ++ ; } flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , buf ) ; s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ) ; return ret ; }","if ( buf -> pts == AV_NOPTS_VALUE ) {return write_to_fifo ( s -> fifo , buf ) ;",47
784,"buggy line: parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;parameters -> prch_init [ i ] = 256 ;}cwe id:CWE-787context: static void opj_j2k_set_cinema_parameters ( opj_cparameters_t * parameters , opj_image_t * image , opj_event_mgr_t * p_manager ) { int i ; parameters -> tile_size_on = OPJ_FALSE ; parameters -> cp_tdx = 1 ; parameters -> cp_tdy = 1 ; parameters -> tp_flag = 'C' ; parameters -> tp_on = 1 ; parameters -> cp_tx0 = 0 ; parameters -> cp_ty0 = 0 ; parameters -> image_offset_x0 = 0 ; parameters -> image_offset_y0 = 0 ; parameters -> cblockw_init = 32 ; parameters -> cblockh_init = 32 ; parameters -> mode = 0 ; parameters -> roi_compno = - 1 ; parameters -> subsampling_dx = 1 ; parameters -> subsampling_dy = 1 ; parameters -> irreversible = 1 ; if ( parameters -> tcp_numlayers > 1 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""1<S2SV_blank>single<S2SV_blank>quality<S2SV_blank>layer"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>layers<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" ""-><S2SV_blank>Rate<S2SV_blank>of<S2SV_blank>the<S2SV_blank>last<S2SV_blank>layer<S2SV_blank>(%3.1f)<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used"" , parameters -> tcp_numlayers , parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ) ; parameters -> tcp_rates [ 0 ] = parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ; parameters -> tcp_numlayers = 1 ; } switch ( parameters -> rsiz ) { case OPJ_PROFILE_CINEMA_2K : if ( parameters -> numresolution > 6 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>(2k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank><=<S2SV_blank>5\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>5<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 6 ; } break ; case OPJ_PROFILE_CINEMA_4K : if ( parameters -> numresolution < 2 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 1 ; } else if ( parameters -> numresolution > 7 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>6<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 7 ; } break ; default : break ; } parameters -> csty |= 0x01 ;  parameters -> res_spec = parameters -> numresolution - 1 ;  for ( i = 0 ; i < parameters -> res_spec ; i ++ ) { parameters -> prcw_init [ i ] = 256 ;  parameters -> prch_init [ i ] = 256 ;  } parameters -> prog_order = OPJ_CPRL ; if ( parameters -> rsiz == OPJ_PROFILE_CINEMA_4K ) { parameters -> numpocs = ( OPJ_UINT32 ) opj_j2k_initialise_4K_poc ( parameters -> POC , parameters -> numresolution ) ; } else { parameters -> numpocs = 0 ; } parameters -> cp_disto_alloc = 1 ; if ( parameters -> max_cs_size <= 0 ) { parameters -> max_cs_size = OPJ_CINEMA_24_CS ; opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n"" ) ; } else if ( parameters -> max_cs_size > OPJ_CINEMA_24_CS ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1302083<S2SV_blank>bytes.\\n"" ) ; parameters -> max_cs_size = OPJ_CINEMA_24_CS ; } if ( parameters -> max_comp_size <= 0 ) { parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n"" ) ; } else if ( parameters -> max_comp_size > OPJ_CINEMA_24_COMP ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1041666<S2SV_blank>bytes.\\n"" ) ; parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; } parameters -> tcp_rates [ 0 ] = ( OPJ_FLOAT32 ) ( image -> numcomps * image -> comps [ 0 ] . w * image -> comps [ 0 ] . h * image -> comps [ 0 ] . prec ) / ( OPJ_FLOAT32 ) ( ( ( OPJ_UINT32 ) parameters -> max_cs_size ) * 8 * image -> comps [ 0 ] . dx * image -> comps [ 0 ] . dy ) ; }",if ( parameters -> numresolution == 1 ) {parameters -> res_spec = 1 ;parameters -> prcw_init [ 0 ] = 128 ;parameters -> prch_init [ 0 ] = 128 ;}else {parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;}parameters -> prch_init [ i ] = 256 ;},48
785,"buggy line: return ERROR_INV_SPS_PPS_T ;}cwe id:CWE-000context: WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = - 1 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) { if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) { if ( ps_dec -> ps_pps [ i ] . ps_sps -> u1_is_valid == TRUE ) { j = i ; break ; } } } if ( j == - 1 ) {  return ERROR_INV_SPS_PPS_T ;  } if ( ps_dec -> u4_pic_buf_got == 0 ) { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } ps_dec -> u4_first_slice_in_pic = 0 ; } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { if ( ( u1_mbaff ) && ( ps_dec -> u4_num_mbs_cur_nmb & 1 ) ) { ps_dec -> u4_num_mbs_cur_nmb = ps_dec -> u4_num_mbs_cur_nmb - 1 ; ps_dec -> u2_cur_mb_addr -- ; } u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; if ( u1_num_mbs ) { ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } if ( ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice < ( UWORD32 ) ( ps_dec -> u2_total_mbs_coded >> ps_slice -> u1_mbaff_frame_flag ) ) { ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> ps_parse_cur_slice ++ ; } } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= u1_mbaff ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }",return ERROR_INV_SLICE_HDR_T ;},49
786,"buggy line: if ( ! setup_stratum_curl ( pool ) ) goto out ;resend : if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) {cwe id:CWE-119context: bool initiate_stratum ( struct pool * pool ) { char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; bool ret = false , recvd = false ; json_error_t err ; int n2size ; if ( ! setup_stratum_curl ( pool ) ) goto out ; resend : if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , true ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = json_array_string ( json_array_get ( res_val , 0 ) , 1 ) ; if ( ! sessionid ) { applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ;  if ( ! n2size ) {  applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } mutex_lock ( & pool -> pool_lock ) ; pool -> sessionid = sessionid ; free ( pool -> nonce1 ) ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; pool -> n2size = n2size ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( val ) json_decref ( val ) ; if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && pool -> sessionid ) { mutex_lock ( & pool -> pool_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiate<S2SV_blank>stratum<S2SV_blank>failed"" ) ; if ( pool -> sock != INVSOCK ) { shutdown ( pool -> sock , SHUT_RDWR ) ; pool -> sock = INVSOCK ; } } return ret ; }",if ( n2size < 1 ) {,50
787,"buggy line: if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;cwe id:CWE-119context: bool initiate_stratum ( struct pool * pool ) { char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; bool ret = false , recvd = false ; json_error_t err ; int n2size ; if ( ! setup_stratum_curl ( pool ) ) goto out ; resend : if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , true ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = json_array_string ( json_array_get ( res_val , 0 ) , 1 ) ; if ( ! sessionid ) { applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ;  if ( ! n2size ) {  applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } mutex_lock ( & pool -> pool_lock ) ; pool -> sessionid = sessionid ; free ( pool -> nonce1 ) ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; pool -> n2size = n2size ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( val ) json_decref ( val ) ; if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && pool -> sessionid ) { mutex_lock ( & pool -> pool_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiate<S2SV_blank>stratum<S2SV_blank>failed"" ) ; if ( pool -> sock != INVSOCK ) { shutdown ( pool -> sock , SHUT_RDWR ) ; pool -> sock = INVSOCK ; } } return ret ; }","if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;",50
788,"buggy line: for ( i = 0 ;i ++ )   nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ;if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) {cwe id:CWE-834context: static int nsv_parse_NSVf_header ( AVFormatContext * s ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; unsigned int av_unused file_size ; unsigned int size ; int64_t duration ; int strings_size ; int table_entries ; int table_entries_used ; nsv -> state = NSV_UNSYNC ; size = avio_rl32 ( pb ) ; if ( size < 28 ) return - 1 ; nsv -> NSVf_end = size ; file_size = ( uint32_t ) avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>chunk_size<S2SV_blank>%u\\n"" , size ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>file_size<S2SV_blank>%u\\n"" , file_size ) ; nsv -> duration = duration = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>duration<S2SV_blank>%"" PRId64 ""<S2SV_blank>ms\\n"" , duration ) ; strings_size = avio_rl32 ( pb ) ; table_entries = avio_rl32 ( pb ) ; table_entries_used = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>info-strings<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>table<S2SV_blank>entries:<S2SV_blank>%d,<S2SV_blank>bis<S2SV_blank>%d\\n"" , strings_size , table_entries , table_entries_used ) ; if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>header;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; if ( strings_size > 0 ) { char * strings ; char * p , * endp ; char * token , * value ; char quote ; p = strings = av_mallocz ( ( size_t ) strings_size + 1 ) ; if ( ! p ) return AVERROR ( ENOMEM ) ; endp = strings + strings_size ; avio_read ( pb , strings , strings_size ) ; while ( p < endp ) { while ( * p == '<S2SV_blank>' ) p ++ ; if ( p >= endp - 2 ) break ; token = p ; p = strchr ( p , '=' ) ; if ( ! p || p >= endp - 2 ) break ; * p ++ = '\\0' ; quote = * p ++ ; value = p ; p = strchr ( p , quote ) ; if ( ! p || p >= endp ) break ; * p ++ = '\\0' ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>INFO:<S2SV_blank>%s=\'%s\'\\n"" , token , value ) ; av_dict_set ( & s -> metadata , token , value , 0 ) ; } av_free ( strings ) ; } if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>infos;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; if ( table_entries_used > 0 ) { int i ; nsv -> index_entries = table_entries_used ; if ( ( unsigned ) table_entries_used >= UINT_MAX / sizeof ( uint32_t ) ) return - 1 ; nsv -> nsvs_file_offset = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_file_offset ) return AVERROR ( ENOMEM ) ;  for ( i = 0 ; i < table_entries_used ; i ++ )   nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ;  if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) { nsv -> nsvs_timestamps = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_timestamps ) return AVERROR ( ENOMEM ) ; for ( i = 0 ; i < table_entries_used ; i ++ ) { nsv -> nsvs_timestamps [ i ] = avio_rl32 ( pb ) ; } } } av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>index;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; avio_seek ( pb , nsv -> base_offset + size , SEEK_SET ) ; if ( avio_feof ( pb ) ) return - 1 ; nsv -> state = NSV_HAS_READ_NSVF ; return 0 ; }","for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ;}if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) {",51
789,"buggy line: # undef _  default : switch ( variable & 0xff ) {cwe id:CWE-264context: const char * string_of_NPPVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPPVpluginNameString ) ; _ ( NPPVpluginDescriptionString ) ; _ ( NPPVpluginWindowBool ) ; _ ( NPPVpluginTransparentBool ) ; _ ( NPPVjavaClass ) ; _ ( NPPVpluginWindowSize ) ; _ ( NPPVpluginTimerInterval ) ; _ ( NPPVpluginScriptableInstance ) ; _ ( NPPVpluginScriptableIID ) ; _ ( NPPVjavascriptPushCallerBool ) ; _ ( NPPVpluginKeepLibraryInMemory ) ; _ ( NPPVpluginNeedsXEmbed ) ; _ ( NPPVpluginScriptableNPObject ) ; _ ( NPPVformValue ) ;  # undef _  default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPPVpluginScriptableInstance ) ; # undef _ default : str = ""<unknown<S2SV_blank>variable>"" ; break ; } break ; } return str ; }",_ ( NPPVpluginUrlRequestsDisplayedBool ) ;_ ( NPPVpluginWantsAllNetworkStreams ) ;_ ( NPPVpluginNativeAccessibleAtkPlugId ) ;_ ( NPPVpluginCancelSrcStream ) ;_ ( NPPVSupportsAdvancedKeyHandling ) ;# undef _ default : switch ( variable & 0xff ) {,52
790,"buggy line: if ( level != SOL_PPPOL2TP )  return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ;if ( get_user ( len , optlen ) ) return - EFAULT ;cwe id:CWE-269context: static int pppol2tp_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; int val , len ; int err ; struct pppol2tp_session * ps ; if ( level != SOL_PPPOL2TP )  return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ;  if ( get_user ( len , optlen ) ) return - EFAULT ; len = min_t ( unsigned int , len , sizeof ( int ) ) ; if ( len < 0 ) return - EINVAL ; err = - ENOTCONN ; if ( sk -> sk_user_data == NULL ) goto end ; err = - EBADF ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == NULL ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - EBADF ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == NULL ) goto end_put_sess ; err = pppol2tp_tunnel_getsockopt ( sk , tunnel , optname , & val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_getsockopt ( sk , session , optname , & val ) ; err = - EFAULT ; if ( put_user ( len , optlen ) ) goto end_put_sess ; if ( copy_to_user ( ( void __user * ) optval , & val , len ) ) goto end_put_sess ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }","if ( level != SOL_PPPOL2TP ) return - EINVAL ;if ( get_user ( len , optlen ) ) return - EFAULT ;",53
791,"buggy line: # ifdef HAVE_OPENSSL  if ( opt_use_ssl ) {mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ;mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ;mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ;}mysql_options ( & mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ;# endif if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;cwe id:CWE-284context: int main ( int argc , char * * argv ) { int error ; my_bool first_argument_uses_wildcards = 0 ; char * wild ; MYSQL mysql ; MY_INIT ( argv [ 0 ] ) ; my_getopt_use_args_separator = TRUE ; if ( load_defaults ( ""my"" , load_default_groups , & argc , & argv ) ) exit ( 1 ) ; my_getopt_use_args_separator = FALSE ; get_options ( & argc , & argv ) ; wild = 0 ; if ( argc ) { char * pos = argv [ argc - 1 ] , * to ; for ( to = pos ; * pos ; pos ++ , to ++ ) { switch ( * pos ) { case '*' : * pos = '%' ; first_argument_uses_wildcards = 1 ; break ; case '?' : * pos = '_' ; first_argument_uses_wildcards = 1 ; break ; case '%' : case '_' : first_argument_uses_wildcards = 1 ; break ; case '\\\\' : pos ++ ; default : break ; } * to = * pos ; } * to = * pos ; } if ( first_argument_uses_wildcards ) wild = argv [ -- argc ] ; else if ( argc == 3 ) wild = argv [ -- argc ] ; if ( argc > 2 ) { fprintf ( stderr , ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>arguments\\n"" , my_progname ) ; exit ( 1 ) ; } mysql_init ( & mysql ) ; if ( opt_compress ) mysql_options ( & mysql , MYSQL_OPT_COMPRESS , NullS ) ;  # ifdef HAVE_OPENSSL  if ( opt_use_ssl ) { mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( & mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ; # endif if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif mysql_options ( & mysql , MYSQL_SET_CHARSET_NAME , default_charset ) ; if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql , MYSQL_OPT_CONNECT_ATTR_ADD , ""program_name"" , ""mysqlshow"" ) ; if ( ! ( mysql_real_connect ( & mysql , host , user , opt_password , ( first_argument_uses_wildcards ) ? """" : argv [ 0 ] , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>%s\\n"" , my_progname , mysql_error ( & mysql ) ) ; exit ( 1 ) ; } mysql . reconnect = 1 ; switch ( argc ) { case 0 : error = list_dbs ( & mysql , wild ) ; break ; case 1 : if ( opt_status ) error = list_table_status ( & mysql , argv [ 0 ] , wild ) ; else error = list_tables ( & mysql , argv [ 0 ] , wild ) ; break ; default : if ( opt_status && ! wild ) error = list_table_status ( & mysql , argv [ 0 ] , argv [ 1 ] ) ; else error = list_fields ( & mysql , argv [ 0 ] , argv [ 1 ] , wild ) ; break ; } mysql_close ( & mysql ) ; my_free ( opt_password ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) my_free ( shared_memory_base_name ) ; # endif my_end ( my_end_arg ) ; exit ( error ? 1 : 0 ) ; return 0 ; }","SSL_SET_OPTIONS ( & mysql ) ;if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;",54
792,"buggy line: if ( ipv6_hdr ( skb ) -> payload_len == 0 ) {pr_debug ( ""payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\\return skb ;}if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ;clone = skb_clone ( skb , GFP_ATOMIC ) ;if ( clone == NULL ) {pr_debug ( ""Can\\\'t<S2SV_blank>clone<S2SV_blank>skb\\\return skb ;}NFCT_FRAG6_CB ( clone ) -> orig = skb ;if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) {pr_debug ( ""message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\\goto ret_orig ;}skb_set_transport_header ( clone , fhoff ) ;hdr = ipv6_hdr ( clone ) ;fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ;if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) {pr_debug ( ""Invalid<S2SV_blank>fragment<S2SV_blank>offset\\\goto ret_orig ;}cwe id:CWE-000context: struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) { struct sk_buff * clone ; struct net_device * dev = skb -> dev ; struct frag_hdr * fhdr ; struct nf_ct_frag6_queue * fq ; struct ipv6hdr * hdr ; int fhoff , nhoff ; u8 prevhdr ; struct sk_buff * ret_skb = NULL ; if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { pr_debug ( ""payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\n"" ) ; return skb ; } if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ; clone = skb_clone ( skb , GFP_ATOMIC ) ; if ( clone == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>clone<S2SV_blank>skb\\n"" ) ; return skb ; } NFCT_FRAG6_CB ( clone ) -> orig = skb ; if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { pr_debug ( ""message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\n"" ) ; goto ret_orig ; } skb_set_transport_header ( clone , fhoff ) ; hdr = ipv6_hdr ( clone ) ; fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ;  if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) {  pr_debug ( ""Invalid<S2SV_blank>fragment<S2SV_blank>offset\\n"" ) ; goto ret_orig ; } if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) nf_ct_frag6_evictor ( ) ; fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; if ( fq == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\n"" ) ; goto ret_orig ; } spin_lock_bh ( & fq -> q . lock ) ; if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { spin_unlock_bh ( & fq -> q . lock ) ; pr_debug ( ""Can\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\n"" ) ; fq_put ( fq ) ; goto ret_orig ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) { ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; if ( ret_skb == NULL ) pr_debug ( ""Can\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\n"" ) ; } spin_unlock_bh ( & fq -> q . lock ) ; fq_put ( fq ) ; return ret_skb ; ret_orig : kfree_skb ( clone ) ; return skb ; }","
",55
793,"buggy line: if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS )  {enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteBuffer ( interface , ENC624J600_CMD_WGPDATA , buffer , offset ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ;enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ;enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ;return NO_ERROR ;cwe id:CWE-20context: error_t enc624j600SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; }  if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS )  { return ERROR_FAILURE ; }  enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ;  enc624j600WriteBuffer ( interface , ENC624J600_CMD_WGPDATA , buffer , offset ) ;  enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ;   enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ;   enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ;   enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ;  return NO_ERROR ; }","if ( enc624j600ReadReg ( interface , ENC624J600_ECON1 ) & ENC624J600_ECON1_TXRTS ) {enc624j600WriteReg ( interface , ENC624J600_EGPWRPT , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteBuffer ( interface , ENC624J600_ETXST , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ;enc624j600ClearBit ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF ) ;enc624j600SetBit ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_TXRTS ) ;return NO_ERROR ;",56
794,"buggy line: native_handle_t * h = malloc (   sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ;if ( h ) {cwe id:CWE-189context: native_handle_t * native_handle_create ( int numFds , int numInts ) {  native_handle_t * h = malloc (   sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ;  if ( h ) { h -> version = sizeof ( native_handle_t ) ; h -> numFds = numFds ; h -> numInts = numInts ; } return h ; }",if ( numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts ) {return NULL ;}size_t mallocSize = sizeof ( native_handle_t ) + ( sizeof ( int ) * ( numFds + numInts ) ) ;native_handle_t * h = malloc ( mallocSize ) ;if ( h ) {,57
795,"buggy line: static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 )   {psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;psf -> header [ psf -> headindex ++ ] = x ;};}cwe id:CWE-119context: static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x )  { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 )   { psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ;   psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;   psf -> header [ psf -> headindex ++ ] = x ;   } ;  }","static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x ) {psf -> header ) - 3 ) {psf -> header . ptr [ psf -> header . ptr [ psf -> headindex ++ ] = x ;}",58
796,"buggy line: ptr = p + 2 ;}cwe id:CWE-78context: static inline int r_sys_mkdirp ( char * dir ) { int ret = 1 ; const char slash = DIRSEP ; char * path = dir ; char * ptr = path ; if ( * ptr == slash ) { ptr ++ ; } # if __SDB_WINDOWS__ char * p = strstr ( ptr , "":\\\\"" ) ; if ( p ) {  ptr = p + 2 ;  } # endif while ( ( ptr = strchr ( ptr , slash ) ) ) { * ptr = 0 ; if ( ! r_sys_mkdir ( path ) && r_sys_mkdir_failed ( ) ) { eprintf ( ""r_sys_mkdirp:<S2SV_blank>fail<S2SV_blank>\'%s\'<S2SV_blank>of<S2SV_blank>\'%s\'\\n"" , path , dir ) ; * ptr = slash ; return 0 ; } * ptr = slash ; ptr ++ ; } return ret ; }",ptr = p + 3 ;},59
797,"buggy line: if ( pmd_none ( * pmd ) ) {if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ;if ( err ) break ;continue ;}if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ;if ( err ) break ;if ( ! walk -> pte_entry ) continue ;split_huge_page_pmd ( walk -> mm , pmd ) ;if ( pmd_none_or_clear_bad ( pmd ) )  goto again ;cwe id:CWE-264context: static int walk_pmd_range ( pud_t * pud , unsigned long addr , unsigned long end , struct mm_walk * walk ) { pmd_t * pmd ; unsigned long next ; int err = 0 ; pmd = pmd_offset ( pud , addr ) ; do { again : next = pmd_addr_end ( addr , end ) ; if ( pmd_none ( * pmd ) ) { if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ; if ( err ) break ; continue ; } if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ; if ( err ) break ; if ( ! walk -> pte_entry ) continue ; split_huge_page_pmd ( walk -> mm , pmd ) ;  if ( pmd_none_or_clear_bad ( pmd ) )  goto again ; err = walk_pte_range ( pmd , addr , next , walk ) ; if ( err ) break ; } while ( pmd ++ , addr = next , addr != end ) ; return err ; }",if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) goto again ;,60
798,"buggy line: while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 )  {cwe id:CWE-254context: IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) { ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; }  while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 )  { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }","while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) {",61
799,"buggy line: else if ( ! ctx -> iface || ! ctx -> priv || ! ctx -> iface -> ctrl_maps ) res = VPX_CODEC_ERROR ;else {vpx_codec_ctrl_fn_map_t * entry ;res = VPX_CODEC_ERROR ;for ( entry = ctx -> iface -> ctrl_maps ;entry && entry -> fn ;entry ++ ) {if ( ! entry -> ctrl_id || entry -> ctrl_id == ctrl_id ) {va_list ap ;va_start ( ap , ctrl_id ) ;res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ;va_end ( ap ) ;cwe id:CWE-119context: vpx_codec_err_t vpx_codec_control_ ( vpx_codec_ctx_t * ctx , int ctrl_id , ... ) { vpx_codec_err_t res ; if ( ! ctx || ! ctrl_id ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv || ! ctx -> iface -> ctrl_maps ) res = VPX_CODEC_ERROR ; else { vpx_codec_ctrl_fn_map_t * entry ; res = VPX_CODEC_ERROR ; for ( entry = ctx -> iface -> ctrl_maps ; entry && entry -> fn ; entry ++ ) { if ( ! entry -> ctrl_id || entry -> ctrl_id == ctrl_id ) { va_list ap ; va_start ( ap , ctrl_id ) ;  res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ;  va_end ( ap ) ; break ; } } } return SAVE_STATUS ( ctx , res ) ; }","else if ( ! ctx -> iface || ! ctx -> priv , ap ) ;va_end ( ap ) ;",62
800,"buggy line: isoclns_print ( ndo , p , length , caplen ) ;return ( hdrlen ) ;cwe id:CWE-125context: int llc_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { uint8_t dsap_field , dsap , ssap_field , ssap ; uint16_t control ; int hdrlen ; int is_u ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( caplen ) ; } if ( length < 3 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( length ) ; } dsap_field = * p ; ssap_field = * ( p + 1 ) ; control = * ( p + 2 ) ; if ( ( control & LLC_U_FMT ) == LLC_U_FMT ) { is_u = 1 ; hdrlen = 3 ; } else { if ( caplen < 4 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( caplen ) ; } if ( length < 4 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( length ) ; } control = EXTRACT_LE_16BITS ( p + 2 ) ; is_u = 0 ; hdrlen = 4 ; } if ( ssap_field == LLCSAP_GLOBAL && dsap_field == LLCSAP_GLOBAL ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IPX<S2SV_blank>802.3:<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 0 ) ; } dsap = dsap_field & ~ LLC_IG ; ssap = ssap_field & ~ LLC_GSAP ; if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""LLC,<S2SV_blank>dsap<S2SV_blank>%s<S2SV_blank>(0x%02x)<S2SV_blank>%s,<S2SV_blank>ssap<S2SV_blank>%s<S2SV_blank>(0x%02x)<S2SV_blank>%s"" , tok2str ( llc_values , ""Unknown"" , dsap ) , dsap , tok2str ( llc_ig_flag_values , ""Unknown"" , dsap_field & LLC_IG ) , tok2str ( llc_values , ""Unknown"" , ssap ) , ssap , tok2str ( llc_flag_values , ""Unknown"" , ssap_field & LLC_GSAP ) ) ) ; if ( is_u ) { ND_PRINT ( ( ndo , "",<S2SV_blank>ctrl<S2SV_blank>0x%02x:<S2SV_blank>"" , control ) ) ; } else { ND_PRINT ( ( ndo , "",<S2SV_blank>ctrl<S2SV_blank>0x%04x:<S2SV_blank>"" , control ) ) ; } } p += hdrlen ; length -= hdrlen ; caplen -= hdrlen ; if ( ssap == LLCSAP_SNAP && dsap == LLCSAP_SNAP && control == LLC_UI ) { if ( ! snap_print ( ndo , p , length , caplen , src , dst , 2 ) ) { return ( - ( hdrlen + 5 ) ) ; } else return ( hdrlen + 5 ) ; } if ( ssap == LLCSAP_8021D && dsap == LLCSAP_8021D && control == LLC_UI ) { stp_print ( ndo , p , length ) ; return ( hdrlen ) ; } if ( ssap == LLCSAP_IP && dsap == LLCSAP_IP && control == LLC_UI ) { ip_print ( ndo , p , length ) ; return ( hdrlen ) ; } if ( ssap == LLCSAP_IPX && dsap == LLCSAP_IPX && control == LLC_UI ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IPX<S2SV_blank>802.2:<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( hdrlen ) ; } # ifdef ENABLE_SMB if ( ssap == LLCSAP_NETBEUI && dsap == LLCSAP_NETBEUI && ( ! ( control & LLC_S_FMT ) || control == LLC_U_FMT ) ) { netbeui_print ( ndo , control , p , length ) ; return ( hdrlen ) ; } # endif if ( ssap == LLCSAP_ISONS && dsap == LLCSAP_ISONS && control == LLC_UI ) {  isoclns_print ( ndo , p , length , caplen ) ;  return ( hdrlen ) ; } if ( ! ndo -> ndo_eflag ) { if ( ssap == dsap ) { if ( src == NULL || dst == NULL ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; else ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" , ( src -> addr_string ) ( ndo , src -> addr ) , ( dst -> addr_string ) ( ndo , dst -> addr ) , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; } else { if ( src == NULL || dst == NULL ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>"" , tok2str ( llc_values , ""Unknown<S2SV_blank>SSAP<S2SV_blank>0x%02x"" , ssap ) , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; else ND_PRINT ( ( ndo , ""%s<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" , ( src -> addr_string ) ( ndo , src -> addr ) , tok2str ( llc_values , ""Unknown<S2SV_blank>SSAP<S2SV_blank>0x%02x"" , ssap ) , ( dst -> addr_string ) ( ndo , dst -> addr ) , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; } } if ( is_u ) { ND_PRINT ( ( ndo , ""Unnumbered,<S2SV_blank>%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( llc_cmd_values , ""%02x"" , LLC_U_CMD ( control ) ) , tok2str ( llc_flag_values , ""?"" , ( ssap_field & LLC_GSAP ) | ( control & LLC_U_POLL ) ) , length + hdrlen ) ) ; if ( ( control & ~ LLC_U_POLL ) == LLC_XID ) { if ( length == 0 ) { return ( hdrlen ) ; } if ( caplen < 1 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; if ( caplen > 0 ) ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( hdrlen ) ; } if ( * p == LLC_XID_FI ) { if ( caplen < 3 || length < 3 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; if ( caplen > 0 ) ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; } else ND_PRINT ( ( ndo , "":<S2SV_blank>%02x<S2SV_blank>%02x"" , p [ 1 ] , p [ 2 ] ) ) ; return ( hdrlen ) ; } } } else { if ( ( control & LLC_S_FMT ) == LLC_S_FMT ) { ND_PRINT ( ( ndo , ""Supervisory,<S2SV_blank>%s,<S2SV_blank>rcv<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( llc_supervisory_values , ""?"" , LLC_S_CMD ( control ) ) , LLC_IS_NR ( control ) , tok2str ( llc_flag_values , ""?"" , ( ssap_field & LLC_GSAP ) | ( control & LLC_IS_POLL ) ) , length + hdrlen ) ) ; return ( hdrlen ) ; } else { ND_PRINT ( ( ndo , ""Information,<S2SV_blank>send<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>rcv<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , LLC_I_NS ( control ) , LLC_IS_NR ( control ) , tok2str ( llc_flag_values , ""?"" , ( ssap_field & LLC_GSAP ) | ( control & LLC_IS_POLL ) ) , length + hdrlen ) ) ; } } return ( - hdrlen ) ; }","isoclns_print ( ndo , p , length , caplen ) ;return ( hdrlen ) ;",63
801,"buggy line: # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE &&  * p == SSL3_MT_CLIENT_HELLO ) &&  ! dtls1_record_replay_check ( s , bitmap ) ) {cwe id:CWE-000context: int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ; if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE &&  * p == SSL3_MT_CLIENT_HELLO ) &&  ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } return ( 1 ) ; }","# endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) {",64
802,"buggy line: d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ;if ( ! d ) return NULL ;cwe id:CWE-125context: static expr_ty ast_for_decorator ( struct compiling * c , const node * n ) { expr_ty d = NULL ; expr_ty name_expr ; REQ ( n , decorator ) ; REQ ( CHILD ( n , 0 ) , AT ) ; REQ ( RCHILD ( n , - 1 ) , NEWLINE ) ; name_expr = ast_for_dotted_name ( c , CHILD ( n , 1 ) ) ; if ( ! name_expr ) return NULL ; if ( NCH ( n ) == 3 ) { d = name_expr ; name_expr = NULL ; } else if ( NCH ( n ) == 5 ) { d = Call ( name_expr , NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( ! d ) return NULL ; name_expr = NULL ; } else {  d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ;  if ( ! d ) return NULL ; name_expr = NULL ; } return d ; }","d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr , true ) ;if ( ! d ) return NULL ;",65
803,"buggy line: ue -> info = * info ;ue -> info . access = 0 ;cwe id:CWE-362context: static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ;  ue -> info = * info ;  ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }",ue -> card = card ;ue -> info = * info ;ue -> info . access = 0 ;,66
804,"buggy line: }fpp = & fpl -> fp [ fpl -> count ] ;cwe id:CWE-399context: static int scm_fp_copy ( struct cmsghdr * cmsg , struct scm_fp_list * * fplp ) { int * fdp = ( int * ) CMSG_DATA ( cmsg ) ; struct scm_fp_list * fpl = * fplp ; struct file * * fpp ; int i , num ; num = ( cmsg -> cmsg_len - CMSG_ALIGN ( sizeof ( struct cmsghdr ) ) ) / sizeof ( int ) ; if ( num <= 0 ) return 0 ; if ( num > SCM_MAX_FD ) return - EINVAL ; if ( ! fpl ) { fpl = kmalloc ( sizeof ( struct scm_fp_list ) , GFP_KERNEL ) ; if ( ! fpl ) return - ENOMEM ; * fplp = fpl ; fpl -> count = 0 ; fpl -> max = SCM_MAX_FD ;  }  fpp = & fpl -> fp [ fpl -> count ] ; if ( fpl -> count + num > fpl -> max ) return - EINVAL ; for ( i = 0 ; i < num ; i ++ ) { int fd = fdp [ i ] ; struct file * file ; if ( fd < 0 || ! ( file = fget_raw ( fd ) ) ) return - EBADF ; * fpp ++ = file ; fpl -> count ++ ; }  return num ;  }",fpl -> user = NULL ;}fpp = & fpl -> fp [ fpl -> count ] ;,67
805,"buggy line: return num ;}cwe id:CWE-399context: static int scm_fp_copy ( struct cmsghdr * cmsg , struct scm_fp_list * * fplp ) { int * fdp = ( int * ) CMSG_DATA ( cmsg ) ; struct scm_fp_list * fpl = * fplp ; struct file * * fpp ; int i , num ; num = ( cmsg -> cmsg_len - CMSG_ALIGN ( sizeof ( struct cmsghdr ) ) ) / sizeof ( int ) ; if ( num <= 0 ) return 0 ; if ( num > SCM_MAX_FD ) return - EINVAL ; if ( ! fpl ) { fpl = kmalloc ( sizeof ( struct scm_fp_list ) , GFP_KERNEL ) ; if ( ! fpl ) return - ENOMEM ; * fplp = fpl ; fpl -> count = 0 ; fpl -> max = SCM_MAX_FD ;  }  fpp = & fpl -> fp [ fpl -> count ] ; if ( fpl -> count + num > fpl -> max ) return - EINVAL ; for ( i = 0 ; i < num ; i ++ ) { int fd = fdp [ i ] ; struct file * file ; if ( fd < 0 || ! ( file = fget_raw ( fd ) ) ) return - EBADF ; * fpp ++ = file ; fpl -> count ++ ; }  return num ;  }",if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ;return num ;},67
806,"buggy line: u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;smin_val = src_reg . smin_value ;smax_val = src_reg . smax_value ;umin_val = src_reg . umin_value ;umax_val = src_reg . umax_value ;src_known = tnum_is_const ( src_reg . var_off ) ;dst_known = tnum_is_const ( dst_reg -> var_off ) ;if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}switch ( opcode ) {case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value += smin_val ;dst_reg -> smax_value += smax_val ;}if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value += umin_val ;dst_reg -> umax_value += umax_val ;}dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ;break ;case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value -= smax_val ;dst_reg -> smax_value -= smin_val ;}if ( dst_reg -> umin_value < umax_val ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value -= umax_val ;dst_reg -> umax_value -= umin_val ;}dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ;break ;case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ;if ( smin_val < 0 || dst_reg -> smin_value < 0 ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}break ;case BPF_AND : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = dst_reg -> var_off . value ;dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ;dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_LSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value <<= umin_val ;dst_reg -> umax_value <<= umax_val ;}dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ;__update_reg_bounds ( dst_reg ) ;break ;case BPF_RSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ;dst_reg -> umin_value >>= umax_val ;dst_reg -> umax_value >>= umin_val ;__update_reg_bounds ( dst_reg ) ;break ;case BPF_ARSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value >>= umin_val ;dst_reg -> smax_value >>= umin_val ;dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ;dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;__update_reg_bounds ( dst_reg ) ;break ;default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {coerce_reg_to_size ( & src_reg , 4 ) ;}cwe id:CWE-125context: static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ;  u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;  smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ;  coerce_reg_to_size ( & src_reg , 4 ) ;  } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }",u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;if ( insn_bitness == 32 ) {},68
807,"buggy line: error = copy_to_user ( buf , & socket_packet -> icmp_packet ,   socket_packet -> icmp_len ) ;packet_len = socket_packet -> icmp_len ;cwe id:CWE-119context: static ssize_t bat_socket_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct socket_client * socket_client = file -> private_data ; struct socket_packet * socket_packet ; size_t packet_len ; int error ; if ( ( file -> f_flags & O_NONBLOCK ) && ( socket_client -> queue_len == 0 ) ) return - EAGAIN ; if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) return - EINVAL ; if ( ! access_ok ( VERIFY_WRITE , buf , count ) ) return - EFAULT ; error = wait_event_interruptible ( socket_client -> queue_wait , socket_client -> queue_len ) ; if ( error ) return error ; spin_lock_bh ( & socket_client -> lock ) ; socket_packet = list_first_entry ( & socket_client -> queue_list , struct socket_packet , list ) ; list_del ( & socket_packet -> list ) ; socket_client -> queue_len -- ; spin_unlock_bh ( & socket_client -> lock ) ;  error = copy_to_user ( buf , & socket_packet -> icmp_packet ,   socket_packet -> icmp_len ) ;  packet_len = socket_packet -> icmp_len ; kfree ( socket_packet ) ; if ( error ) return - EFAULT ; return packet_len ; }","packet_len = min ( count , socket_packet -> icmp_len ) ;error = copy_to_user ( buf , & socket_packet -> icmp_packet , packet_len ) ;",69
808,"buggy line: READ ( data , msg . f . length )   if ( msg . f . length > sizeof ( data ) )  rfbLog ( ""Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\\else   HandleFence ( cl , flags , msg . f . length , data ) ;return ;cwe id:CWE-787context: static void rfbProcessClientNormalMessage ( rfbClientPtr cl ) { int n ; rfbClientToServerMsg msg ; char * str ; READ ( ( char * ) & msg , 1 ) switch ( msg . type ) { case rfbSetPixelFormat : READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetPixelFormatMsg - 1 ) cl -> format . bitsPerPixel = msg . spf . format . bitsPerPixel ; cl -> format . depth = msg . spf . format . depth ; cl -> format . bigEndian = ( msg . spf . format . bigEndian ? 1 : 0 ) ; cl -> format . trueColour = ( msg . spf . format . trueColour ? 1 : 0 ) ; cl -> format . redMax = Swap16IfLE ( msg . spf . format . redMax ) ; cl -> format . greenMax = Swap16IfLE ( msg . spf . format . greenMax ) ; cl -> format . blueMax = Swap16IfLE ( msg . spf . format . blueMax ) ; cl -> format . redShift = msg . spf . format . redShift ; cl -> format . greenShift = msg . spf . format . greenShift ; cl -> format . blueShift = msg . spf . format . blueShift ; cl -> readyForSetColourMapEntries = TRUE ; rfbSetTranslateFunction ( cl ) ; return ; case rfbFixColourMapEntries : READ ( ( ( char * ) & msg ) + 1 , sz_rfbFixColourMapEntriesMsg - 1 ) rfbLog ( ""rfbProcessClientNormalMessage:<S2SV_blank>FixColourMapEntries<S2SV_blank>unsupported\\n"" ) ; rfbCloseClient ( cl ) ; return ; case rfbSetEncodings : { int i ; CARD32 enc ; Bool firstFence = ! cl -> enableFence ; Bool firstCU = ! cl -> enableCU ; Bool firstGII = ! cl -> enableGII ; Bool logTightCompressLevel = FALSE ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetEncodingsMsg - 1 ) msg . se . nEncodings = Swap16IfLE ( msg . se . nEncodings ) ; cl -> preferredEncoding = - 1 ; cl -> useCopyRect = FALSE ; cl -> enableCursorShapeUpdates = FALSE ; cl -> enableCursorPosUpdates = FALSE ; cl -> enableLastRectEncoding = FALSE ; cl -> tightCompressLevel = TIGHT_DEFAULT_COMPRESSION ; cl -> tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP ; cl -> tightQualityLevel = - 1 ; cl -> imageQualityLevel = - 1 ; for ( i = 0 ; i < msg . se . nEncodings ; i ++ ) { READ ( ( char * ) & enc , 4 ) enc = Swap32IfLE ( enc ) ; switch ( enc ) { case rfbEncodingCopyRect : cl -> useCopyRect = TRUE ; break ; case rfbEncodingRaw : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>raw<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>rre<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingCoRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>CoRRE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingHextile : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>hextile<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingZlib : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>zlib<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingZRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>ZRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingZYWRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>ZYWRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingTight : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>tight<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingXCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( ""Enabling<S2SV_blank>X-style<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = FALSE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingRichCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( ""Enabling<S2SV_blank>full-color<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = TRUE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingPointerPos : if ( ! cl -> enableCursorPosUpdates ) { rfbLog ( ""Enabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorPosUpdates = TRUE ; cl -> cursorWasMoved = TRUE ; cl -> cursorX = - 1 ; cl -> cursorY = - 1 ; } break ; case rfbEncodingLastRect : if ( ! cl -> enableLastRectEncoding ) { rfbLog ( ""Enabling<S2SV_blank>LastRect<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableLastRectEncoding = TRUE ; } break ; case rfbEncodingFence : if ( ! cl -> enableFence ) { rfbLog ( ""Enabling<S2SV_blank>Fence<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableFence = TRUE ; } break ; case rfbEncodingContinuousUpdates : if ( ! cl -> enableCU ) { rfbLog ( ""Enabling<S2SV_blank>Continuous<S2SV_blank>Updates<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCU = TRUE ; } break ; case rfbEncodingNewFBSize : if ( ! cl -> enableDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( ""Enabling<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableDesktopSize = TRUE ; } else rfbLog ( ""WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\n"" ) ; } break ; case rfbEncodingExtendedDesktopSize : if ( ! cl -> enableExtDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( ""Enabling<S2SV_blank>Extended<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableExtDesktopSize = TRUE ; } else rfbLog ( ""WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\n"" ) ; } break ; case rfbEncodingGII : if ( ! cl -> enableGII ) { rfbLog ( ""Enabling<S2SV_blank>GII<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableGII = TRUE ; } break ; default : if ( enc >= ( CARD32 ) rfbEncodingCompressLevel0 && enc <= ( CARD32 ) rfbEncodingCompressLevel9 ) { cl -> zlibCompressLevel = enc & 0x0F ; cl -> tightCompressLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) logTightCompressLevel = TRUE ; else rfbLog ( ""Using<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightCompressLevel , cl -> host ) ; if ( rfbInterframe == - 1 ) { if ( cl -> tightCompressLevel >= 5 ) { if ( ! InterframeOn ( cl ) ) { rfbCloseClient ( cl ) ; return ; } } else InterframeOff ( cl ) ; } } else if ( enc >= ( CARD32 ) rfbEncodingSubsamp1X && enc <= ( CARD32 ) rfbEncodingSubsampGray ) { cl -> tightSubsampLevel = enc & 0xFF ; rfbLog ( ""Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightSubsampLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingQualityLevel0 && enc <= ( CARD32 ) rfbEncodingQualityLevel9 ) { cl -> tightQualityLevel = JPEG_QUAL [ enc & 0x0F ] ; cl -> tightSubsampLevel = JPEG_SUBSAMP [ enc & 0x0F ] ; cl -> imageQualityLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) rfbLog ( ""Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d,<S2SV_blank>Q%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightSubsampLevel , cl -> tightQualityLevel , cl -> host ) ; else rfbLog ( ""Using<S2SV_blank>image<S2SV_blank>quality<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> imageQualityLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingFineQualityLevel0 + 1 && enc <= ( CARD32 ) rfbEncodingFineQualityLevel100 ) { cl -> tightQualityLevel = enc & 0xFF ; rfbLog ( ""Using<S2SV_blank>JPEG<S2SV_blank>quality<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightQualityLevel , cl -> host ) ; } else { rfbLog ( ""rfbProcessClientNormalMessage:<S2SV_blank>ignoring<S2SV_blank>unknown<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>(%x)\\n"" , ( int ) enc , ( int ) enc ) ; } } } if ( cl -> preferredEncoding == - 1 ) cl -> preferredEncoding = rfbEncodingTight ; if ( cl -> preferredEncoding == rfbEncodingTight && logTightCompressLevel ) rfbLog ( ""Using<S2SV_blank>Tight<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , rfbTightCompressLevel ( cl ) , cl -> host ) ; if ( cl -> enableCursorPosUpdates && ! cl -> enableCursorShapeUpdates ) { rfbLog ( ""Disabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorPosUpdates = FALSE ; } if ( cl -> enableFence && firstFence ) { if ( ! rfbSendFence ( cl , rfbFenceFlagRequest , 0 , NULL ) ) return ; } if ( cl -> enableCU && cl -> enableFence && firstCU ) { if ( ! rfbSendEndOfCU ( cl ) ) return ; } if ( cl -> enableGII && firstGII ) { rfbGIIServerVersionMsg msg ; msg . type = rfbGIIServer ; msg . endianAndSubType = rfbGIIVersion | rfbGIIBE ; msg . length = Swap16IfLE ( sz_rfbGIIServerVersionMsg - 4 ) ; msg . maximumVersion = msg . minimumVersion = Swap16IfLE ( 1 ) ; if ( WriteExact ( cl , ( char * ) & msg , sz_rfbGIIServerVersionMsg ) < 0 ) { rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; return ; } } return ; } case rfbFramebufferUpdateRequest : { RegionRec tmpRegion ; BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFramebufferUpdateRequestMsg - 1 ) box . x1 = Swap16IfLE ( msg . fur . x ) ; box . y1 = Swap16IfLE ( msg . fur . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . fur . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . fur . h ) ; SAFE_REGION_INIT ( pScreen , & tmpRegion , & box , 0 ) ; if ( ! msg . fur . incremental || ! cl -> continuousUpdates ) REGION_UNION ( pScreen , & cl -> requestedRegion , & cl -> requestedRegion , & tmpRegion ) ; if ( ! cl -> readyForSetColourMapEntries ) { cl -> readyForSetColourMapEntries = TRUE ; if ( ! cl -> format . trueColour ) { if ( ! rfbSetClientColourMap ( cl , 0 , 0 ) ) { REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } } } if ( ! msg . fur . incremental ) { REGION_UNION ( pScreen , & cl -> modifiedRegion , & cl -> modifiedRegion , & tmpRegion ) ; REGION_SUBTRACT ( pScreen , & cl -> copyRegion , & cl -> copyRegion , & tmpRegion ) ; REGION_UNION ( pScreen , & cl -> ifRegion , & cl -> ifRegion , & tmpRegion ) ; cl -> pendingExtDesktopResize = TRUE ; } if ( FB_UPDATE_PENDING ( cl ) && ( ! cl -> deferredUpdateScheduled || rfbDeferUpdateTime == 0 || gettime ( ) - cl -> deferredUpdateStart >= ( double ) rfbDeferUpdateTime ) ) { if ( rfbSendFramebufferUpdate ( cl ) ) cl -> deferredUpdateScheduled = FALSE ; } REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } case rfbKeyEvent : cl -> rfbKeyEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbKeyEventMsg - 1 ) if ( ! rfbViewOnly && ! cl -> viewOnly ) KeyEvent ( ( KeySym ) Swap32IfLE ( msg . ke . key ) , msg . ke . down ) ; return ; case rfbPointerEvent : cl -> rfbPointerEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbPointerEventMsg - 1 ) if ( pointerClient && ( pointerClient != cl ) ) return ; if ( msg . pe . buttonMask == 0 ) pointerClient = NULL ; else pointerClient = cl ; if ( ! rfbViewOnly && ! cl -> viewOnly ) { cl -> cursorX = ( int ) Swap16IfLE ( msg . pe . x ) ; cl -> cursorY = ( int ) Swap16IfLE ( msg . pe . y ) ; PtrAddEvent ( msg . pe . buttonMask , cl -> cursorX , cl -> cursorY , cl ) ; } return ; case rfbClientCutText : { int ignoredBytes = 0 ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbClientCutTextMsg - 1 ) msg . cct . length = Swap32IfLE ( msg . cct . length ) ; if ( msg . cct . length > rfbMaxClipboard ) { rfbLog ( ""Truncating<S2SV_blank>%d-byte<S2SV_blank>clipboard<S2SV_blank>update<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>bytes.\\n"" , msg . cct . length , rfbMaxClipboard ) ; ignoredBytes = msg . cct . length - rfbMaxClipboard ; msg . cct . length = rfbMaxClipboard ; } if ( msg . cct . length <= 0 ) return ; str = ( char * ) malloc ( msg . cct . length ) ; if ( str == NULL ) { rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>rfbClientCutText<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; rfbCloseClient ( cl ) ; return ; } if ( ( n = ReadExact ( cl , str , msg . cct . length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>read"" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } if ( ignoredBytes > 0 ) { if ( ( n = SkipExact ( cl , ignoredBytes ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>read"" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } } if ( ! rfbViewOnly && ! cl -> viewOnly && ! rfbAuthDisableCBRecv ) { vncClientCutText ( str , msg . cct . length ) ; if ( rfbSyncCutBuffer ) rfbSetXCutText ( str , msg . cct . length ) ; } free ( str ) ; return ; } case rfbEnableContinuousUpdates : { BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbEnableContinuousUpdatesMsg - 1 ) if ( ! cl -> enableFence || ! cl -> enableCU ) { rfbLog ( ""Ignoring<S2SV_blank>request<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>continuous<S2SV_blank>updates<S2SV_blank>because<S2SV_blank>the<S2SV_blank>client<S2SV_blank>does<S2SV_blank>not\\n"" ) ; rfbLog ( ""support<S2SV_blank>the<S2SV_blank>flow<S2SV_blank>control<S2SV_blank>extensions.\\n"" ) ; return ; } box . x1 = Swap16IfLE ( msg . ecu . x ) ; box . y1 = Swap16IfLE ( msg . ecu . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . ecu . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . ecu . h ) ; SAFE_REGION_INIT ( pScreen , & cl -> cuRegion , & box , 0 ) ; cl -> continuousUpdates = msg . ecu . enable ; if ( cl -> continuousUpdates ) { REGION_EMPTY ( pScreen , & cl -> requestedRegion ) ; if ( ! rfbSendFramebufferUpdate ( cl ) ) return ; } else { if ( ! rfbSendEndOfCU ( cl ) ) return ; } rfbLog ( ""Continuous<S2SV_blank>updates<S2SV_blank>%s\\n"" , cl -> continuousUpdates ? ""enabled"" : ""disabled"" ) ; return ; } case rfbFence : { CARD32 flags ; char data [ 64 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFenceMsg - 1 ) flags = Swap32IfLE ( msg . f . flags ) ;  READ ( data , msg . f . length )   if ( msg . f . length > sizeof ( data ) )  rfbLog ( ""Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\n"" , msg . f . length ) ;  else   HandleFence ( cl , flags , msg . f . length , data ) ;  return ; } # define EDSERROR ( format , args ... ) { if ( ! strlen ( errMsg ) ) snprintf ( errMsg , 256 , ""Desktop<S2SV_blank>resize<S2SV_blank>ERROR:<S2SV_blank>"" format ""\\n"" , args ) ; result = rfbEDSResultInvalid ; } case rfbSetDesktopSize : { int i ; struct xorg_list newScreens ; rfbClientPtr cl2 ; int result = rfbEDSResultSuccess ; char errMsg [ 256 ] = ""\\0"" ; ScreenPtr pScreen = screenInfo . screens [ 0 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetDesktopSizeMsg - 1 ) if ( msg . sds . numScreens < 1 ) EDSERROR ( ""Requested<S2SV_blank>number<S2SV_blank>of<S2SV_blank>screens<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid"" , msg . sds . numScreens ) ; msg . sds . w = Swap16IfLE ( msg . sds . w ) ; msg . sds . h = Swap16IfLE ( msg . sds . h ) ; if ( msg . sds . w < 1 || msg . sds . h < 1 ) EDSERROR ( ""Requested<S2SV_blank>framebuffer<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid"" , msg . sds . w , msg . sds . h ) ; xorg_list_init ( & newScreens ) ; for ( i = 0 ; i < msg . sds . numScreens ; i ++ ) { rfbScreenInfo * screen = rfbNewScreen ( 0 , 0 , 0 , 0 , 0 , 0 ) ; READ ( ( char * ) & screen -> s , sizeof ( rfbScreenDesc ) ) screen -> s . id = Swap32IfLE ( screen -> s . id ) ; screen -> s . x = Swap16IfLE ( screen -> s . x ) ; screen -> s . y = Swap16IfLE ( screen -> s . y ) ; screen -> s . w = Swap16IfLE ( screen -> s . w ) ; screen -> s . h = Swap16IfLE ( screen -> s . h ) ; screen -> s . flags = Swap32IfLE ( screen -> s . flags ) ; if ( screen -> s . w < 1 || screen -> s . h < 1 ) EDSERROR ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid"" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h ) ; if ( screen -> s . x >= msg . sds . w || screen -> s . y >= msg . sds . h || screen -> s . x + screen -> s . w > msg . sds . w || screen -> s . y + screen -> s . h > msg . sds . h ) EDSERROR ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>geometry<S2SV_blank>%dx%d+%d+%d<S2SV_blank>exceeds<S2SV_blank>requested<S2SV_blank>framebuffer<S2SV_blank>dimensions"" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h , screen -> s . x , screen -> s . y ) ; if ( rfbFindScreenID ( & newScreens , screen -> s . id ) ) { EDSERROR ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>duplicate<S2SV_blank>ID"" , ( unsigned int ) screen -> s . id ) ; free ( screen ) ; } else rfbAddScreen ( & newScreens , screen ) ; } if ( cl -> viewOnly ) { rfbLog ( ""NOTICE:<S2SV_blank>Ignoring<S2SV_blank>remote<S2SV_blank>desktop<S2SV_blank>resize<S2SV_blank>request<S2SV_blank>from<S2SV_blank>a<S2SV_blank>view-only<S2SV_blank>client.\\n"" ) ; result = rfbEDSResultProhibited ; } else if ( result == rfbEDSResultSuccess ) { result = ResizeDesktop ( pScreen , cl , msg . sds . w , msg . sds . h , & newScreens ) ; if ( result == rfbEDSResultSuccess ) return ; } else rfbLog ( errMsg ) ; rfbRemoveScreens ( & newScreens ) ; for ( cl2 = rfbClientHead ; cl2 ; cl2 = cl2 -> next ) { if ( cl2 == cl ) { cl2 -> pendingExtDesktopResize = TRUE ; cl2 -> reason = rfbEDSReasonClient ; cl2 -> result = result ; rfbSendFramebufferUpdate ( cl2 ) ; break ; } } return ; } case rfbGIIClient : { CARD8 endianAndSubType , littleEndian , subType ; READ ( ( char * ) & endianAndSubType , 1 ) ; littleEndian = ( endianAndSubType & rfbGIIBE ) ? 0 : 1 ; subType = endianAndSubType & ~ rfbGIIBE ; switch ( subType ) { case rfbGIIVersion : READ ( ( char * ) & msg . giicv . length , sz_rfbGIIClientVersionMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giicv . length = Swap16 ( msg . giicv . length ) ; msg . giicv . version = Swap16 ( msg . giicv . version ) ; } if ( msg . giicv . length != sz_rfbGIIClientVersionMsg - 4 || msg . giicv . version < 1 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>client<S2SV_blank>version<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } rfbLog ( ""Client<S2SV_blank>supports<S2SV_blank>GII<S2SV_blank>version<S2SV_blank>%d\\n"" , msg . giicv . version ) ; break ; case rfbGIIDeviceCreate : { int i ; rfbDevInfo dev ; rfbGIIDeviceCreatedMsg dcmsg ; memset ( & dev , 0 , sizeof ( dev ) ) ; dcmsg . deviceOrigin = 0 ; READ ( ( char * ) & msg . giidc . length , sz_rfbGIIDeviceCreateMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidc . length = Swap16 ( msg . giidc . length ) ; msg . giidc . vendorID = Swap32 ( msg . giidc . vendorID ) ; msg . giidc . productID = Swap32 ( msg . giidc . productID ) ; msg . giidc . canGenerate = Swap32 ( msg . giidc . canGenerate ) ; msg . giidc . numRegisters = Swap32 ( msg . giidc . numRegisters ) ; msg . giidc . numValuators = Swap32 ( msg . giidc . numValuators ) ; msg . giidc . numButtons = Swap32 ( msg . giidc . numButtons ) ; } rfbLog ( ""GII<S2SV_blank>Device<S2SV_blank>Create:<S2SV_blank>%s\\n"" , msg . giidc . deviceName ) ; # ifdef GII_DEBUG rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vendor<S2SV_blank>ID:<S2SV_blank>%d\\n"" , msg . giidc . vendorID ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Product<S2SV_blank>ID:<S2SV_blank>%d\\n"" , msg . giidc . productID ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Event<S2SV_blank>mask:<S2SV_blank>%.8x\\n"" , msg . giidc . canGenerate ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Registers:<S2SV_blank>%d\\n"" , msg . giidc . numRegisters ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuators:<S2SV_blank>%d\\n"" , msg . giidc . numValuators ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Buttons:<S2SV_blank>%d\\n"" , msg . giidc . numButtons ) ; # endif if ( msg . giidc . length != sz_rfbGIIDeviceCreateMsg - 4 + msg . giidc . numValuators * sz_rfbGIIValuator ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } if ( msg . giidc . numButtons > MAX_BUTTONS ) { rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>buttons<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\n"" , msg . giidc . numButtons , MAX_BUTTONS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } if ( msg . giidc . numValuators > MAX_VALUATORS ) { rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>valuators<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\n"" , msg . giidc . numValuators , MAX_VALUATORS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } memcpy ( & dev . name , msg . giidc . deviceName , 32 ) ; dev . numButtons = msg . giidc . numButtons ; dev . numValuators = msg . giidc . numValuators ; dev . eventMask = msg . giidc . canGenerate ; dev . mode = ( dev . eventMask & rfbGIIValuatorAbsoluteMask ) ? Absolute : Relative ; dev . productID = msg . giidc . productID ; if ( dev . mode == Relative ) { rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>relative<S2SV_blank>valuators<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>(yet)\\n"" ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } for ( i = 0 ; i < dev . numValuators ; i ++ ) { rfbGIIValuator * v = & dev . valuators [ i ] ; READ ( ( char * ) v , sz_rfbGIIValuator ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v -> index = Swap32 ( v -> index ) ; v -> rangeMin = Swap32 ( ( CARD32 ) v -> rangeMin ) ; v -> rangeCenter = Swap32 ( ( CARD32 ) v -> rangeCenter ) ; v -> rangeMax = Swap32 ( ( CARD32 ) v -> rangeMax ) ; v -> siUnit = Swap32 ( v -> siUnit ) ; v -> siAdd = Swap32 ( ( CARD32 ) v -> siAdd ) ; v -> siMul = Swap32 ( ( CARD32 ) v -> siMul ) ; v -> siDiv = Swap32 ( ( CARD32 ) v -> siDiv ) ; v -> siShift = Swap32 ( ( CARD32 ) v -> siShift ) ; } # ifdef GII_DEBUG rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuator:<S2SV_blank>%s<S2SV_blank>(%s)\\n"" , v -> longName , v -> shortName ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Index:<S2SV_blank>%d\\n"" , v -> index ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Range:<S2SV_blank>min<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>center<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>max<S2SV_blank>=<S2SV_blank>%d\\n"" , v -> rangeMin , v -> rangeCenter , v -> rangeMax ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>unit:<S2SV_blank>%d\\n"" , v -> siUnit ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>add:<S2SV_blank>%d\\n"" , v -> siAdd ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>multiply:<S2SV_blank>%d\\n"" , v -> siMul ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>divide:<S2SV_blank>%d\\n"" , v -> siDiv ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>shift:<S2SV_blank>%d\\n"" , v -> siShift ) ; # endif } for ( i = 0 ; i < cl -> numDevices ; i ++ ) { if ( ! strcmp ( dev . name , cl -> devices [ i ] . name ) ) { rfbLog ( ""Device<S2SV_blank>\\\'%s\\\'<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>with<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>%d\\n"" , dev . name , i + 1 ) ; dcmsg . deviceOrigin = Swap32IfLE ( i + 1 ) ; goto sendMessage ; } } if ( rfbVirtualTablet || AddExtInputDevice ( & dev ) ) { memcpy ( & cl -> devices [ cl -> numDevices ] , & dev , sizeof ( dev ) ) ; cl -> numDevices ++ ; dcmsg . deviceOrigin = Swap32IfLE ( cl -> numDevices ) ; } rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%d\\n"" , cl -> numDevices ) ; sendMessage : dcmsg . type = rfbGIIServer ; dcmsg . endianAndSubType = rfbGIIDeviceCreate | rfbGIIBE ; dcmsg . length = Swap16IfLE ( sz_rfbGIIDeviceCreatedMsg - 4 ) ; if ( WriteExact ( cl , ( char * ) & dcmsg , sz_rfbGIIDeviceCreatedMsg ) < 0 ) { rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; return ; } break ; } case rfbGIIDeviceDestroy : READ ( ( char * ) & msg . giidd . length , sz_rfbGIIDeviceDestroyMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidd . length = Swap16 ( msg . giidd . length ) ; msg . giidd . deviceOrigin = Swap32 ( msg . giidd . deviceOrigin ) ; } if ( msg . giidd . length != sz_rfbGIIDeviceDestroyMsg - 4 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } RemoveExtInputDevice ( cl , msg . giidd . deviceOrigin - 1 ) ; break ; case rfbGIIEvent : { CARD16 length ; READ ( ( char * ) & length , sizeof ( CARD16 ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) length = Swap16 ( length ) ; while ( length > 0 ) { CARD8 eventSize , eventType ; READ ( ( char * ) & eventSize , 1 ) ; READ ( ( char * ) & eventType , 1 ) ; switch ( eventType ) { case rfbGIIButtonPress : case rfbGIIButtonRelease : { rfbGIIButtonEvent b ; rfbDevInfo * dev ; READ ( ( char * ) & b . pad , sz_rfbGIIButtonEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { b . deviceOrigin = Swap32 ( b . deviceOrigin ) ; b . buttonNumber = Swap32 ( b . buttonNumber ) ; } if ( eventSize != sz_rfbGIIButtonEvent || b . deviceOrigin <= 0 || b . buttonNumber < 1 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event\\n"" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( b . deviceOrigin < 1 || b . deviceOrigin > cl -> numDevices ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\n"" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ b . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIButtonPress && ( dev -> eventMask & rfbGIIButtonPressMask ) == 0 ) || ( eventType == rfbGIIButtonRelease && ( dev -> eventMask & rfbGIIButtonReleaseMask ) == 0 ) ) { rfbLog ( ""ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>can\'t<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>events\\n"" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( b . buttonNumber > dev -> numButtons ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>button<S2SV_blank>count<S2SV_blank>(%d)\\n"" , b . buttonNumber , b . deviceOrigin , dev -> numButtons ) ; rfbCloseClient ( cl ) ; return ; } # ifdef GII_DEBUG rfbLog ( ""Device<S2SV_blank>%d<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>%s\\n"" , b . deviceOrigin , b . buttonNumber , eventType == rfbGIIButtonPress ? ""PRESS"" : ""release"" ) ; fflush ( stderr ) ; # endif ExtInputAddEvent ( dev , eventType == rfbGIIButtonPress ? ButtonPress : ButtonRelease , b . buttonNumber ) ; break ; } case rfbGIIValuatorRelative : case rfbGIIValuatorAbsolute : { rfbGIIValuatorEvent v ; int i ; rfbDevInfo * dev ; READ ( ( char * ) & v . pad , sz_rfbGIIValuatorEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v . deviceOrigin = Swap32 ( v . deviceOrigin ) ; v . first = Swap32 ( v . first ) ; v . count = Swap32 ( v . count ) ; } if ( eventSize != sz_rfbGIIValuatorEvent + sizeof ( int ) * v . count ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event\\n"" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( v . deviceOrigin < 1 || v . deviceOrigin > cl -> numDevices ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\n"" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ v . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIValuatorRelative && ( dev -> eventMask & rfbGIIValuatorRelativeMask ) == 0 ) || ( eventType == rfbGIIValuatorAbsolute && ( dev -> eventMask & rfbGIIValuatorAbsoluteMask ) == 0 ) ) { rfbLog ( ""ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>cannot<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>events\\n"" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( v . first + v . count > dev -> numValuators ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>valuator<S2SV_blank>count<S2SV_blank>(%d)\\n"" , v . deviceOrigin , dev -> numValuators ) ; rfbCloseClient ( cl ) ; return ; } # ifdef GII_DEBUG rfbLog ( ""Device<S2SV_blank>%d<S2SV_blank>Valuator<S2SV_blank>%s<S2SV_blank>first=%d<S2SV_blank>count=%d:\\n"" , v . deviceOrigin , eventType == rfbGIIValuatorRelative ? ""rel"" : ""ABS"" , v . first , v . count ) ; # endif for ( i = v . first ; i < v . first + v . count ; i ++ ) { READ ( ( char * ) & dev -> values [ i ] , sizeof ( int ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) dev -> values [ i ] = Swap32 ( ( CARD32 ) dev -> values [ i ] ) ; # ifdef GII_DEBUG fprintf ( stderr , ""v[%d]=%d<S2SV_blank>"" , i , dev -> values [ i ] ) ; # endif } # ifdef GII_DEBUG fprintf ( stderr , ""\\n"" ) ; # endif if ( v . count > 0 ) { dev -> valFirst = v . first ; dev -> valCount = v . count ; dev -> mode = eventType == rfbGIIValuatorAbsolute ? Absolute : Relative ; ExtInputAddEvent ( dev , MotionNotify , 0 ) ; } break ; } default : rfbLog ( ""ERROR:<S2SV_blank>This<S2SV_blank>server<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>type<S2SV_blank>%d\\n"" , eventType ) ; rfbCloseClient ( cl ) ; return ; } } if ( length != 0 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } break ; } } return ; } default : rfbLog ( ""rfbProcessClientNormalMessage:<S2SV_blank>unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d\\n"" , msg . type ) ; rfbLog ( ""<S2SV_blank>...<S2SV_blank>closing<S2SV_blank>connection\\n"" ) ; rfbCloseClient ( cl ) ; return ; } }","if ( msg . f . length > sizeof ( data ) ) {rfbLog ( ""Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\\SKIP ( msg . f . length ) }else {READ ( data , msg . f . length ) HandleFence ( cl , flags , msg . f . length , data ) ;}return ;",70
809,"buggy line: uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ( cc % ( bps * stride ) ) != 0 ) {if ( ! tmp )  return 0 ;cwe id:CWE-119context: static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ;  uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;  if ( ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ; return 0 ; }  if ( ! tmp )  return 0 ; _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) return 1 ; }",uint8 * tmp ;if ( ( cc % ( bps * stride ) ) != 0 ) {tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ! tmp ) return 0 ;,71
810,"buggy line: spin_lock_irq ( & tu -> qlock ) ;while ( ( long ) count - result >= unit ) {while ( ! tu -> qused ) {wait_queue_t wait ;if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) {err = - EAGAIN ;goto _error ;}set_current_state ( TASK_INTERRUPTIBLE ) ;init_waitqueue_entry ( & wait , current ) ;add_wait_queue ( & tu -> qchange_sleep , & wait ) ;spin_unlock_irq ( & tu -> qlock ) ;schedule ( ) ;spin_lock_irq ( & tu -> qlock ) ;cwe id:CWE-200context: static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ;  spin_lock_irq ( & tu -> qlock ) ;  while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ;  schedule ( ) ;  spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ;  mutex_lock ( & tu -> ioctl_lock ) ;  if ( tu -> tread ) { if ( copy_to_user ( buffer , & tu -> tqueue [ qhead ] , sizeof ( struct snd_timer_tread ) ) ) err = - EFAULT ; } else { if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ; }  mutex_unlock ( & tu -> ioctl_lock ) ;  spin_lock_irq ( & tu -> qlock ) ; if ( err < 0 ) goto _error ; result += unit ; buffer += unit ; } _error : spin_unlock_irq ( & tu -> qlock ) ;  return result > 0 ? result : err ;  }",mutex_lock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;mutex_unlock ( & tu -> ioctl_lock ) ;schedule ( ) ;mutex_lock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;,72
811,"buggy line: mutex_lock ( & tu -> ioctl_lock ) ;if ( tu -> tread ) {else {if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ;}mutex_unlock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;return result > 0 ? result : err ;}cwe id:CWE-200context: static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ;  spin_lock_irq ( & tu -> qlock ) ;  while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ;  schedule ( ) ;  spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ;  mutex_lock ( & tu -> ioctl_lock ) ;  if ( tu -> tread ) { if ( copy_to_user ( buffer , & tu -> tqueue [ qhead ] , sizeof ( struct snd_timer_tread ) ) ) err = - EFAULT ; } else { if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ; }  mutex_unlock ( & tu -> ioctl_lock ) ;  spin_lock_irq ( & tu -> qlock ) ; if ( err < 0 ) goto _error ; result += unit ; buffer += unit ; } _error : spin_unlock_irq ( & tu -> qlock ) ;  return result > 0 ? result : err ;  }",if ( tu -> tread ) {spin_lock_irq ( & tu -> qlock ) ;mutex_unlock ( & tu -> ioctl_lock ) ;return result > 0 ? result : err ;},72
812,"buggy line: avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ;while ( len && avail && * old ) {cwe id:CWE-119context: int nfs3svc_decode_symlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_symlinkargs * args ) { unsigned int len , avail ; char * old , * new ; struct kvec * vec ; if ( ! ( p = decode_fh ( p , & args -> ffh ) ) || ! ( p = decode_filename ( p , & args -> fname , & args -> flen ) ) ) return 0 ; p = decode_sattr3 ( p , & args -> attrs ) ; len = ntohl ( * p ++ ) ; if ( len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE ) return 0 ; args -> tname = new = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; args -> tlen = len ; old = ( char * ) p ; vec = & rqstp -> rq_arg . head [ 0 ] ;  avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ;  while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } if ( len && ! avail && rqstp -> rq_arg . page_len ) { avail = min_t ( unsigned int , rqstp -> rq_arg . page_len , PAGE_SIZE ) ; old = page_address ( rqstp -> rq_arg . pages [ 0 ] ) ; } while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } * new = '\\0' ; if ( len ) return 0 ; return 1 ; }",if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ;while ( len && avail && * old ) {,73
813,"buggy line: int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) {const char * cbuf = buf ;int sent = send ( conn -> sock , cbuf , len , flags ) ;if ( sent == - 1 ) {cwe id:CWE-190context:  int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) {  const char * cbuf = buf ; # ifdef __APPLE__ int flags = 0 ; # else int flags = MSG_NOSIGNAL ; # endif while ( len ) {  int sent = send ( conn -> sock , cbuf , len , flags ) ;  if ( sent == - 1 ) { if ( errno == EPIPE ) conn -> connected = 0 ; __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }","int mongo_env_write_socket ( mongo * conn , const void * buf , size_t len ) {const char * cbuf = buf ;size_t sent = send ( conn -> sock , cbuf , len , flags ) ;if ( sent == - 1 ) {",74
814,"buggy line: uint32_t qttag , qtsize32 , len ;int32_t nest = 0 ;cwe id:CWE-787context: size_t OpenMP4SourceUDTA ( char * filename ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; memset ( mp4 , 0 , sizeof ( mp4object ) ) ; # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) {  uint32_t qttag , qtsize32 , len ;  int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; if ( len == 8 ) { if ( ! GPMF_VALID_FOURCC ( qttag ) ) {  LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ;  NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) ) {  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;  NESTSIZE ( qtsize ) ; continue ; } if ( qttag == MAKEID ( 'G' , 'P' , 'M' , 'F' ) ) { mp4 -> videolength += 1.0 ; mp4 -> metadatalength += 1.0 ; mp4 -> indexcount = ( int ) mp4 -> metadatalength ; mp4 -> metasizes = ( uint32_t * ) malloc ( mp4 -> indexcount * 4 + 4 ) ; memset ( mp4 -> metasizes , 0 , mp4 -> indexcount * 4 + 4 ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> indexcount * 8 + 8 ) ; memset ( mp4 -> metaoffsets , 0 , mp4 -> indexcount * 8 + 8 ) ; mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ; mp4 -> metaoffsets [ 0 ] = ftell ( mp4 -> mediafp ) ; mp4 -> metasize_count = 1 ; return ( size_t ) mp4 ; } if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'u' , 'd' , 't' , 'a' ) ) {  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;  NESTSIZE ( qtsize ) ; continue ; } else { NESTSIZE ( 8 ) ; } } } while ( len > 0 ) ; } return ( size_t ) mp4 ; }","uint32_t qttag , qtsize32 ;size_t len ;int32_t nest = 0 ;",75
815,"buggy line: LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ;NESTSIZE ( lastsize - 8 ) ;cwe id:CWE-787context: size_t OpenMP4SourceUDTA ( char * filename ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; memset ( mp4 , 0 , sizeof ( mp4object ) ) ; # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) {  uint32_t qttag , qtsize32 , len ;  int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; if ( len == 8 ) { if ( ! GPMF_VALID_FOURCC ( qttag ) ) {  LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ;  NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) ) {  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;  NESTSIZE ( qtsize ) ; continue ; } if ( qttag == MAKEID ( 'G' , 'P' , 'M' , 'F' ) ) { mp4 -> videolength += 1.0 ; mp4 -> metadatalength += 1.0 ; mp4 -> indexcount = ( int ) mp4 -> metadatalength ; mp4 -> metasizes = ( uint32_t * ) malloc ( mp4 -> indexcount * 4 + 4 ) ; memset ( mp4 -> metasizes , 0 , mp4 -> indexcount * 4 + 4 ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> indexcount * 8 + 8 ) ; memset ( mp4 -> metaoffsets , 0 , mp4 -> indexcount * 8 + 8 ) ; mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ; mp4 -> metaoffsets [ 0 ] = ftell ( mp4 -> mediafp ) ; mp4 -> metasize_count = 1 ; return ( size_t ) mp4 ; } if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'u' , 'd' , 't' , 'a' ) ) {  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;  NESTSIZE ( qtsize ) ; continue ; } else { NESTSIZE ( 8 ) ; } } } while ( len > 0 ) ; } return ( size_t ) mp4 ; }","LongSeek ( mp4 , lastsize - 8 - 8 , SEEK_CUR ) ;NESTSIZE ( lastsize - 8 ) ;",75
816,"buggy line: LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;cwe id:CWE-787context: size_t OpenMP4SourceUDTA ( char * filename ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; memset ( mp4 , 0 , sizeof ( mp4object ) ) ; # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) {  uint32_t qttag , qtsize32 , len ;  int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; if ( len == 8 ) { if ( ! GPMF_VALID_FOURCC ( qttag ) ) {  LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ;  NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) ) {  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;  NESTSIZE ( qtsize ) ; continue ; } if ( qttag == MAKEID ( 'G' , 'P' , 'M' , 'F' ) ) { mp4 -> videolength += 1.0 ; mp4 -> metadatalength += 1.0 ; mp4 -> indexcount = ( int ) mp4 -> metadatalength ; mp4 -> metasizes = ( uint32_t * ) malloc ( mp4 -> indexcount * 4 + 4 ) ; memset ( mp4 -> metasizes , 0 , mp4 -> indexcount * 4 + 4 ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> indexcount * 8 + 8 ) ; memset ( mp4 -> metaoffsets , 0 , mp4 -> indexcount * 8 + 8 ) ; mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ; mp4 -> metaoffsets [ 0 ] = ftell ( mp4 -> mediafp ) ; mp4 -> metasize_count = 1 ; return ( size_t ) mp4 ; } if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'u' , 'd' , 't' , 'a' ) ) {  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;  NESTSIZE ( qtsize ) ; continue ; } else { NESTSIZE ( 8 ) ; } } } while ( len > 0 ) ; } return ( size_t ) mp4 ; }","LongSeek ( mp4 , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;",75
817,"buggy line: mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ;mp4 -> metaoffsets [ 0 ] = ftell ( mp4 -> mediafp ) ;mp4 -> metasize_count = 1 ;return ( size_t ) mp4 ;}if ( qttag != MAKEID ( \'m\' , \'o\' , \'o\' , \'v\' ) && qttag != MAKEID ( \'u\' , \'d\' , \'t\' , \'a\' ) ) {LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;cwe id:CWE-787context: size_t OpenMP4SourceUDTA ( char * filename ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; memset ( mp4 , 0 , sizeof ( mp4object ) ) ; # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) {  uint32_t qttag , qtsize32 , len ;  int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; if ( len == 8 ) { if ( ! GPMF_VALID_FOURCC ( qttag ) ) {  LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ;  NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) ) {  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;  NESTSIZE ( qtsize ) ; continue ; } if ( qttag == MAKEID ( 'G' , 'P' , 'M' , 'F' ) ) { mp4 -> videolength += 1.0 ; mp4 -> metadatalength += 1.0 ; mp4 -> indexcount = ( int ) mp4 -> metadatalength ; mp4 -> metasizes = ( uint32_t * ) malloc ( mp4 -> indexcount * 4 + 4 ) ; memset ( mp4 -> metasizes , 0 , mp4 -> indexcount * 4 + 4 ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> indexcount * 8 + 8 ) ; memset ( mp4 -> metaoffsets , 0 , mp4 -> indexcount * 8 + 8 ) ; mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ; mp4 -> metaoffsets [ 0 ] = ftell ( mp4 -> mediafp ) ; mp4 -> metasize_count = 1 ; return ( size_t ) mp4 ; } if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'u' , 'd' , 't' , 'a' ) ) {  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;  NESTSIZE ( qtsize ) ; continue ; } else { NESTSIZE ( 8 ) ; } } } while ( len > 0 ) ; } return ( size_t ) mp4 ; }",mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ) ;NESTSIZE ( qtsize ) ;,75
818,"buggy line: struct sk_buff * skb ;skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ;if ( dump_one_state ( x , 0 , & info ) ) {kfree_skb ( skb ) ;return NULL ;}cwe id:CWE-000context: static struct sk_buff * xfrm_state_netlink ( struct sk_buff * in_skb , struct xfrm_state * x , u32 seq ) { struct xfrm_dump_info info ;  struct sk_buff * skb ;  skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) return ERR_PTR ( - ENOMEM ) ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = seq ; info . nlmsg_flags = 0 ;  if ( dump_one_state ( x , 0 , & info ) ) {  kfree_skb ( skb ) ;  return NULL ;  } return skb ; }","struct sk_buff * skb ;int err ;skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ;err = dump_one_state ( x , 0 , & info ) ;if ( err ) {kfree_skb ( skb ) ;return ERR_PTR ( err ) ;}",76
819,"buggy line: len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ;if ( len == - 1 ) {cwe id:CWE-120context: enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) { char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ; unsigned char hmac_response [ MD5_DIGEST_LEN ] ; int len ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ; mutt_message ( _ ( ""Authenticating<S2SV_blank>(CRAM-MD5)..."" ) ) ; if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; imap_cmd_start ( idata , ""AUTHENTICATE<S2SV_blank>CRAM-MD5"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""Invalid<S2SV_blank>response<S2SV_blank>from<S2SV_blank>server:<S2SV_blank>%s\\n"" , ibuf ) ; goto bail ; }  len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ;  if ( len == - 1 ) { mutt_debug ( 1 , ""Error<S2SV_blank>decoding<S2SV_blank>base64<S2SV_blank>response.\\n"" ) ; goto bail ; } obuf [ len ] = '\\0' ; mutt_debug ( 2 , ""CRAM<S2SV_blank>challenge:<S2SV_blank>%s\\n"" , obuf ) ; hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ; int off = snprintf ( obuf , sizeof ( obuf ) , ""%s<S2SV_blank>"" , idata -> conn -> account . user ) ; mutt_md5_toascii ( hmac_response , obuf + off ) ; mutt_debug ( 2 , ""CRAM<S2SV_blank>response:<S2SV_blank>%s\\n"" , obuf ) ; mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ; mutt_str_strcat ( ibuf , sizeof ( ibuf ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , ibuf ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_OK ) { mutt_debug ( 1 , ""Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n"" ) ; goto bail ; } if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ; bail : mutt_error ( _ ( ""CRAM-MD5<S2SV_blank>authentication<S2SV_blank>failed."" ) ) ; return IMAP_AUTH_FAILURE ; }","len = mutt_b64_decode ( obuf , idata -> buf + 2 , sizeof ( obuf ) ) ;if ( len == - 1 ) {",77
820,"buggy line: UWORD16 u2_first_mb_in_slice , u2_frame_num ;UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ;UWORD32 u4_idr_pic_id = 0 ;UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ;UWORD8 u1_nal_unit_type ;UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ;UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ;WORD8 i1_is_end_of_poc ;WORD32 ret , end_of_frame ;WORD32 prev_slice_err , num_mb_skipped ;UWORD8 u1_mbaff ;pocstruct_t * ps_cur_poc ;UWORD32 u4_temp ;WORD32 i_temp ;UWORD32 u4_call_end_of_pic = 0 ;ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ;u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) {return ERROR_CORRUPTED_SLICE ;}if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) {return ERROR_CORRUPTED_SLICE ;}COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ;u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ;u1_slice_type = u4_temp ;COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ;ps_dec -> u1_sl_typ_5_9 = 0 ;if ( u1_slice_type > 4 ) {u1_slice_type -= 5 ;ps_dec -> u1_sl_typ_5_9 = 1 ;}{UWORD32 skip ;if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) {UWORD32 u4_bit_stream_offset = 0 ;if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) {skip = 0 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ;}else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) {skip = 0 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ;}else {skip = 1 ;}if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) {skip = 0 ;}if ( skip ) {ps_dec -> u4_prev_nal_skipped = 1 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ;return 0 ;}else {if ( 1 == ps_dec -> u4_prev_nal_skipped ) {ps_dec -> u4_return_to_app = 1 ;return 0 ;}}}}u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ;COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ;ps_pps = & ps_dec -> ps_pps [ u4_temp ] ;if ( FALSE == ps_pps -> u1_is_valid ) {return ERROR_INV_SLICE_HDR_T ;}ps_seq = ps_pps -> ps_sps ;if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ;if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ;u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ;if ( ! ps_seq -> u1_frame_mbs_only_flag )  {u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ;u1_bottom_field_flag = 0 ;cwe id:CWE-000context: WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SLICE_HDR_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ;  if ( ! ps_seq -> u1_frame_mbs_only_flag )  { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 1 ; ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; if ( ps_dec -> u4_first_slice_in_pic != 2 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ;  }  u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { ps_dec -> ps_decode_cur_slice ++ ; } ps_dec -> u1_slice_header_done = 0 ;  if ( ! ps_dec -> u1_first_slice_in_stream )  { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }",if ( i1_is_end_of_poc ) {ps_dec -> u1_first_slice_in_stream = 0 ;return ERROR_INCOMPLETE_FRAME ;},78
821,"buggy line: }u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ;cwe id:CWE-000context: WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SLICE_HDR_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ;  if ( ! ps_seq -> u1_frame_mbs_only_flag )  { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 1 ; ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; if ( ps_dec -> u4_first_slice_in_pic != 2 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ;  }  u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { ps_dec -> ps_decode_cur_slice ++ ; } ps_dec -> u1_slice_header_done = 0 ;  if ( ! ps_dec -> u1_first_slice_in_stream )  { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }",}u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ;,78
822,"buggy line: if ( ! ps_dec -> u1_first_slice_in_stream )  {cwe id:CWE-000context: WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SLICE_HDR_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ;  if ( ! ps_seq -> u1_frame_mbs_only_flag )  { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 1 ; ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; if ( ps_dec -> u4_first_slice_in_pic != 2 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ;  }  u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { ps_dec -> ps_decode_cur_slice ++ ; } ps_dec -> u1_slice_header_done = 0 ;  if ( ! ps_dec -> u1_first_slice_in_stream )  { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }",if ( ! ps_dec -> u1_first_slice_in_stream ) {,78
823,"buggy line: int vm_shared = dst_vma -> vm_flags & VM_SHARED ;struct hstate * h = hstate_vma ( dst_vma ) ;cwe id:CWE-119context: int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) {  int vm_shared = dst_vma -> vm_flags & VM_SHARED ;  struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ;  if ( vm_shared ) {   struct address_space * mapping = dst_vma -> vm_file -> f_mapping ;  pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ;  spin_lock ( ptl ) ;  ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : put_page ( page ) ; goto out ; }",struct address_space * mapping ;pgoff_t idx ;unsigned long size ;int vm_shared = dst_vma -> vm_flags & VM_SHARED ;struct hstate * h = hstate_vma ( dst_vma ) ;,79
824,"buggy line: if ( vm_shared ) {struct address_space * mapping = dst_vma -> vm_file -> f_mapping ;pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ;spin_lock ( ptl ) ;ret = - EEXIST ;cwe id:CWE-119context: int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) {  int vm_shared = dst_vma -> vm_flags & VM_SHARED ;  struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ;  if ( vm_shared ) {   struct address_space * mapping = dst_vma -> vm_file -> f_mapping ;  pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ;  spin_lock ( ptl ) ;  ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : put_page ( page ) ; goto out ; }","mapping = dst_vma -> vm_file -> f_mapping ;idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ;if ( vm_shared ) {size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ;ret = - EFAULT ;if ( idx >= size ) goto out_release_nounlock ;spin_lock ( ptl ) ;size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ;ret = - EFAULT ;if ( idx >= size ) goto out_release_unlock ;ret = - EEXIST ;",79
825,"buggy line: char query [ 1024 ] , * end ;MYSQL_RES * result ;end = strxmov ( query , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`"" , db , ""`"" , NullS ) ;if ( wild && wild [ 0 ] )  strxmov ( end , ""<S2SV_blank>like<S2SV_blank>\\\'"" , wild , ""\\\'"" , NullS ) ;cwe id:CWE-000context: static int list_table_status ( MYSQL * mysql , const char * db , const char * wild ) {  char query [ 1024 ] , * end ;  MYSQL_RES * result ; MYSQL_ROW row ;  end = strxmov ( query , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`"" , db , ""`"" , NullS ) ;   if ( wild && wild [ 0 ] )  strxmov ( end , ""<S2SV_blank>like<S2SV_blank>\'"" , wild , ""\'"" , NullS ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>get<S2SV_blank>status<S2SV_blank>for<S2SV_blank>db:<S2SV_blank>%s,<S2SV_blank>table:<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , wild ? wild : """" , mysql_error ( mysql ) ) ; if ( mysql_errno ( mysql ) == ER_PARSE_ERROR ) fprintf ( stderr , ""This<S2SV_blank>error<S2SV_blank>probably<S2SV_blank>means<S2SV_blank>that<S2SV_blank>your<S2SV_blank>MySQL<S2SV_blank>server<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>the\\n\\\'show<S2SV_blank>table<S2SV_blank>status\'<S2SV_blank>command.\\n"" ) ; return 1 ; } printf ( ""Database:<S2SV_blank>%s"" , db ) ; if ( wild ) printf ( ""<S2SV_blank><S2SV_blank>Wildcard:<S2SV_blank>%s"" , wild ) ; putchar ( '\\n' ) ; print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; mysql_free_result ( result ) ; return 0 ; }","char query [ NAME_LEN + 100 ] ;int len ;MYSQL_RES * result ;len = sizeof ( query ) ;len -= my_snprintf ( query , len , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`%s`"" , db ) ;if ( wild && wild [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len , ""<S2SV_blank>like<S2SV_blank>\\\'"" , wild , ""\\\'"" , NullS ) ;",80
826,"buggy line: unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ;unsigned char * y ;y_stride = 32 ;vfp -> copymem ( y_0 - 1 - pre_stride , pre_stride , xd -> y_buf , y_stride , 18 ) ;y = xd -> y_buf + y_stride + 1 ;# else unsigned char * y = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ;y_stride = pre_stride ;# endif  bestmv -> as_mv . row <<= 3 ;bestmv -> as_mv . col <<= 3 ;startmv = * bestmv ;cwe id:CWE-119context: int vp8_find_best_sub_pixel_step ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * bestmv , int_mv * ref_mv , int error_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvcost [ 2 ] , int * distortion , unsigned int * sse1 ) { int bestmse = INT_MAX ; int_mv startmv ; int_mv this_mv ; unsigned char * z = ( * ( b -> base_src ) + b -> src ) ; int left , right , up , down , diag ; unsigned int sse ; int whichdir ; int thismse ; int y_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; # if ARCH_X86 || ARCH_X86_64 MACROBLOCKD * xd = & x -> e_mbd ; unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ; unsigned char * y ; y_stride = 32 ; vfp -> copymem ( y_0 - 1 - pre_stride , pre_stride , xd -> y_buf , y_stride , 18 ) ; y = xd -> y_buf + y_stride + 1 ; # else unsigned char * y = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ; y_stride = pre_stride ; # endif  bestmv -> as_mv . row <<= 3 ;   bestmv -> as_mv . col <<= 3 ;  startmv = * bestmv ; bestmse = vfp -> vf ( y , y_stride , z , b -> src_stride , sse1 ) ; * distortion = bestmse ; bestmse += mv_err_cost ( bestmv , ref_mv , mvcost , error_per_bit ) ; this_mv . as_mv . row = startmv . as_mv . row ; this_mv . as_mv . col = ( ( startmv . as_mv . col - 8 ) | 4 ) ; thismse = vfp -> svf_halfpix_h ( y - 1 , y_stride , z , b -> src_stride , & sse ) ; left = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( left < bestmse ) { * bestmv = this_mv ; bestmse = left ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col += 8 ; thismse = vfp -> svf_halfpix_h ( y , y_stride , z , b -> src_stride , & sse ) ; right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( right < bestmse ) { * bestmv = this_mv ; bestmse = right ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col = startmv . as_mv . col ; this_mv . as_mv . row = ( ( startmv . as_mv . row - 8 ) | 4 ) ; thismse = vfp -> svf_halfpix_v ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ; up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( up < bestmse ) { * bestmv = this_mv ; bestmse = up ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . row += 8 ; thismse = vfp -> svf_halfpix_v ( y , y_stride , z , b -> src_stride , & sse ) ; down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( down < bestmse ) { * bestmv = this_mv ; bestmse = down ; * distortion = thismse ; * sse1 = sse ; } whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ; this_mv = startmv ; switch ( whichdir ) { case 0 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ; this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ; thismse = vfp -> svf_halfpix_hv ( y - 1 - y_stride , y_stride , z , b -> src_stride , & sse ) ; break ; case 1 : this_mv . as_mv . col += 4 ; this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ; thismse = vfp -> svf_halfpix_hv ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ; break ; case 2 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ; this_mv . as_mv . row += 4 ; thismse = vfp -> svf_halfpix_hv ( y - 1 , y_stride , z , b -> src_stride , & sse ) ; break ; case 3 : default : this_mv . as_mv . col += 4 ; this_mv . as_mv . row += 4 ; thismse = vfp -> svf_halfpix_hv ( y , y_stride , z , b -> src_stride , & sse ) ; break ; } diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( diag < bestmse ) { * bestmv = this_mv ; bestmse = diag ; * distortion = thismse ; * sse1 = sse ; } if ( bestmv -> as_mv . row < startmv . as_mv . row ) y -= y_stride ; if ( bestmv -> as_mv . col < startmv . as_mv . col ) y -- ; startmv = * bestmv ; this_mv . as_mv . row = startmv . as_mv . row ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col = startmv . as_mv . col - 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } left = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( left < bestmse ) { * bestmv = this_mv ; bestmse = left ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col += 4 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( right < bestmse ) { * bestmv = this_mv ; bestmse = right ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col = startmv . as_mv . col ; if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row = startmv . as_mv . row - 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( up < bestmse ) { * bestmv = this_mv ; bestmse = up ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . row += 4 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( down < bestmse ) { * bestmv = this_mv ; bestmse = down ; * distortion = thismse ; * sse1 = sse ; } whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ; this_mv = startmv ; switch ( whichdir ) { case 0 : if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row -= 2 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; ; } } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride - 1 , y_stride , 6 , 6 , z , b -> src_stride , & sse ) ; } } break ; case 1 : this_mv . as_mv . col += 2 ; if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } break ; case 2 : this_mv . as_mv . row += 2 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } break ; case 3 : this_mv . as_mv . col += 2 ; this_mv . as_mv . row += 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; break ; } diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( diag < bestmse ) { * bestmv = this_mv ; bestmse = diag ; * distortion = thismse ; * sse1 = sse ; } return bestmse ; }",unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row *= 8 ;bestmv -> as_mv . col <<= 3 ;startmv = * bestmv ;,81
827,"buggy line: this_mv . as_mv . col += 8 ;thismse = vfp -> svf_halfpix_h ( y , y_stride , z , b -> src_stride , & sse ) ;right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( right < bestmse ) {* bestmv = this_mv ;bestmse = right ;* distortion = thismse ;* sse1 = sse ;}this_mv . as_mv . col = startmv . as_mv . col ;this_mv . as_mv . row = ( ( startmv . as_mv . row - 8 ) | 4 ) ;thismse = vfp -> svf_halfpix_v ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ;up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( up < bestmse ) {* bestmv = this_mv ;bestmse = up ;* distortion = thismse ;* sse1 = sse ;}this_mv . as_mv . row += 8 ;thismse = vfp -> svf_halfpix_v ( y , y_stride , z , b -> src_stride , & sse ) ;down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( down < bestmse ) {* bestmv = this_mv ;bestmse = down ;* distortion = thismse ;* sse1 = sse ;}whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ;this_mv = startmv ;switch ( whichdir ) {case 0 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ;this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ;thismse = vfp -> svf_halfpix_hv ( y - 1 - y_stride , y_stride , z , b -> src_stride , & sse ) ;break ;case 1 : this_mv . as_mv . col += 4 ;this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ;thismse = vfp -> svf_halfpix_hv ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ;break ;case 2 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ;this_mv . as_mv . row += 4 ;thismse = vfp -> svf_halfpix_hv ( y - 1 , y_stride , z , b -> src_stride , & sse ) ;break ;case 3 : default : this_mv . as_mv . col += 4 ;this_mv . as_mv . row += 4 ;thismse = vfp -> svf_halfpix_hv ( y , y_stride , z , b -> src_stride , & sse ) ;break ;}diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( diag < bestmse ) {* bestmv = this_mv ;bestmse = diag ;* distortion = thismse ;* sse1 = sse ;}if ( bestmv -> as_mv . row < startmv . as_mv . row ) y -= y_stride ;if ( bestmv -> as_mv . col < startmv . as_mv . col ) y -- ;cwe id:CWE-119context: int vp8_find_best_sub_pixel_step ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * bestmv , int_mv * ref_mv , int error_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvcost [ 2 ] , int * distortion , unsigned int * sse1 ) { int bestmse = INT_MAX ; int_mv startmv ; int_mv this_mv ; unsigned char * z = ( * ( b -> base_src ) + b -> src ) ; int left , right , up , down , diag ; unsigned int sse ; int whichdir ; int thismse ; int y_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; # if ARCH_X86 || ARCH_X86_64 MACROBLOCKD * xd = & x -> e_mbd ; unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ; unsigned char * y ; y_stride = 32 ; vfp -> copymem ( y_0 - 1 - pre_stride , pre_stride , xd -> y_buf , y_stride , 18 ) ; y = xd -> y_buf + y_stride + 1 ; # else unsigned char * y = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ; y_stride = pre_stride ; # endif  bestmv -> as_mv . row <<= 3 ;   bestmv -> as_mv . col <<= 3 ;  startmv = * bestmv ; bestmse = vfp -> vf ( y , y_stride , z , b -> src_stride , sse1 ) ; * distortion = bestmse ; bestmse += mv_err_cost ( bestmv , ref_mv , mvcost , error_per_bit ) ; this_mv . as_mv . row = startmv . as_mv . row ; this_mv . as_mv . col = ( ( startmv . as_mv . col - 8 ) | 4 ) ; thismse = vfp -> svf_halfpix_h ( y - 1 , y_stride , z , b -> src_stride , & sse ) ; left = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( left < bestmse ) { * bestmv = this_mv ; bestmse = left ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col += 8 ; thismse = vfp -> svf_halfpix_h ( y , y_stride , z , b -> src_stride , & sse ) ; right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( right < bestmse ) { * bestmv = this_mv ; bestmse = right ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col = startmv . as_mv . col ; this_mv . as_mv . row = ( ( startmv . as_mv . row - 8 ) | 4 ) ; thismse = vfp -> svf_halfpix_v ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ; up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( up < bestmse ) { * bestmv = this_mv ; bestmse = up ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . row += 8 ; thismse = vfp -> svf_halfpix_v ( y , y_stride , z , b -> src_stride , & sse ) ; down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( down < bestmse ) { * bestmv = this_mv ; bestmse = down ; * distortion = thismse ; * sse1 = sse ; } whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ; this_mv = startmv ; switch ( whichdir ) { case 0 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ; this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ; thismse = vfp -> svf_halfpix_hv ( y - 1 - y_stride , y_stride , z , b -> src_stride , & sse ) ; break ; case 1 : this_mv . as_mv . col += 4 ; this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ; thismse = vfp -> svf_halfpix_hv ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ; break ; case 2 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ; this_mv . as_mv . row += 4 ; thismse = vfp -> svf_halfpix_hv ( y - 1 , y_stride , z , b -> src_stride , & sse ) ; break ; case 3 : default : this_mv . as_mv . col += 4 ; this_mv . as_mv . row += 4 ; thismse = vfp -> svf_halfpix_hv ( y , y_stride , z , b -> src_stride , & sse ) ; break ; } diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( diag < bestmse ) { * bestmv = this_mv ; bestmse = diag ; * distortion = thismse ; * sse1 = sse ; } if ( bestmv -> as_mv . row < startmv . as_mv . row ) y -= y_stride ; if ( bestmv -> as_mv . col < startmv . as_mv . col ) y -- ; startmv = * bestmv ; this_mv . as_mv . row = startmv . as_mv . row ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col = startmv . as_mv . col - 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } left = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( left < bestmse ) { * bestmv = this_mv ; bestmse = left ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col += 4 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( right < bestmse ) { * bestmv = this_mv ; bestmse = right ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col = startmv . as_mv . col ; if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row = startmv . as_mv . row - 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( up < bestmse ) { * bestmv = this_mv ; bestmse = up ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . row += 4 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( down < bestmse ) { * bestmv = this_mv ; bestmse = down ; * distortion = thismse ; * sse1 = sse ; } whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ; this_mv = startmv ; switch ( whichdir ) { case 0 : if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row -= 2 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; ; } } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride - 1 , y_stride , 6 , 6 , z , b -> src_stride , & sse ) ; } } break ; case 1 : this_mv . as_mv . col += 2 ; if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } break ; case 2 : this_mv . as_mv . row += 2 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } break ; case 3 : this_mv . as_mv . col += 2 ; this_mv . as_mv . row += 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; break ; } diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( diag < bestmse ) { * bestmv = this_mv ; bestmse = diag ; * distortion = thismse ; * sse1 = sse ; } return bestmse ; }",this_mv . as_mv . col *= 8 ;,81
828,"buggy line: gss_buffer_desc client_name ,  service_name ;cwe id:CWE-772context: generic_ret * delete_principal_2_svc ( dprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ;  gss_buffer_desc client_name ,  service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , arg -> princ , NULL ) ) { ret . code = KADM5_AUTH_DELETE ; log_unauth ( ""kadm5_delete_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_delete_principal ( ( void * ) handle , arg -> princ ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_delete_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ;  gss_release_buffer ( & minor_stat , & client_name ) ;  gss_release_buffer ( & minor_stat , & service_name ) ;  exit_func :  free_server_handle ( handle ) ; return & ret ; }",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,82
829,"buggy line: gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;cwe id:CWE-772context: generic_ret * delete_principal_2_svc ( dprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ;  gss_buffer_desc client_name ,  service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , arg -> princ , NULL ) ) { ret . code = KADM5_AUTH_DELETE ; log_unauth ( ""kadm5_delete_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_delete_principal ( ( void * ) handle , arg -> princ ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_delete_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ;  gss_release_buffer ( & minor_stat , & client_name ) ;  gss_release_buffer ( & minor_stat , & service_name ) ;  exit_func :  free_server_handle ( handle ) ; return & ret ; }","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",82
830,"buggy line: error = scsi_nonblockable_ioctl ( sdp , cmd , p ,  ( mode & FMODE_NDELAY ) != 0 ) ;cwe id:CWE-264context: static int sd_ioctl ( struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) { struct gendisk * disk = bdev -> bd_disk ; struct scsi_disk * sdkp = scsi_disk ( disk ) ; struct scsi_device * sdp = sdkp -> device ; void __user * p = ( void __user * ) arg ; int error ; SCSI_LOG_IOCTL ( 1 , sd_printk ( KERN_INFO , sdkp , ""sd_ioctl:<S2SV_blank>disk=%s,<S2SV_blank>"" ""cmd=0x%x\\n"" , disk -> disk_name , cmd ) ) ;  error = scsi_nonblockable_ioctl ( sdp , cmd , p ,  ( mode & FMODE_NDELAY ) != 0 ) ; if ( ! scsi_block_when_processing_errors ( sdp ) || ! error ) goto out ; switch ( cmd ) { case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : error = scsi_ioctl ( sdp , cmd , p ) ; break ; default : error = scsi_cmd_blk_ioctl ( bdev , mode , cmd , p ) ; if ( error != - ENOTTY ) break ; error = scsi_ioctl ( sdp , cmd , p ) ; break ; } out : return error ; }","error = scsi_verify_blk_ioctl ( bdev , cmd ) ;if ( error < 0 ) return error ;error = scsi_nonblockable_ioctl ( sdp , cmd , p , ( mode & FMODE_NDELAY ) != 0 ) ;",83
831,"buggy line: if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock )  return 0 ;cwe id:CWE-200context: int get_rock_ridge_filename ( struct iso_directory_record * de , char * retname , struct inode * inode ) { struct rock_state rs ; struct rock_ridge * rr ; int sig ; int retnamlen = 0 ; int truncate = 0 ; int ret = 0 ;  if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock )  return 0 ; * retname = 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & RR_NM ) == 0 ) goto out ; break ; case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'N' , 'M' ) : if ( truncate ) break ; if ( rr -> len < 5 ) break ; if ( rr -> u . NM . flags & 6 ) break ; if ( rr -> u . NM . flags & ~ 1 ) { printk ( ""Unsupported<S2SV_blank>NM<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>(%d)\\n"" , rr -> u . NM . flags ) ; break ; }  if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) {  truncate = 1 ; break ; }  strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ;   retnamlen += rr -> len - 5 ;  break ; case SIG ( 'R' , 'E' ) : kfree ( rs . buffer ) ; return - 1 ; default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) return retnamlen ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }",char * p ;int len ;if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ;,84
832,"buggy line: if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) {truncate = 1 ;strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ;retnamlen += rr -> len - 5 ;break ;cwe id:CWE-200context: int get_rock_ridge_filename ( struct iso_directory_record * de , char * retname , struct inode * inode ) { struct rock_state rs ; struct rock_ridge * rr ; int sig ; int retnamlen = 0 ; int truncate = 0 ; int ret = 0 ;  if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock )  return 0 ; * retname = 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & RR_NM ) == 0 ) goto out ; break ; case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'N' , 'M' ) : if ( truncate ) break ; if ( rr -> len < 5 ) break ; if ( rr -> u . NM . flags & 6 ) break ; if ( rr -> u . NM . flags & ~ 1 ) { printk ( ""Unsupported<S2SV_blank>NM<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>(%d)\\n"" , rr -> u . NM . flags ) ; break ; }  if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) {  truncate = 1 ; break ; }  strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ;   retnamlen += rr -> len - 5 ;  break ; case SIG ( 'R' , 'E' ) : kfree ( rs . buffer ) ; return - 1 ; default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) return retnamlen ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }","len = rr -> len - 5 ) >= 254 ) {truncate = 1 ;p = memchr ( rr -> u . NM . name , len ) ;retnamlen += rr -> len - 5 ;break ;",84
833,"buggy line: VpxVideoWriter * writer = NULL ;vpx_codec_ctx_t codec ;vpx_fixed_buf_t stats = {0 };VpxVideoInfo info = {0 };const VpxInterface * encoder = NULL ;int pass ;cwe id:CWE-119context: int main ( int argc , char * * argv ) { FILE * infile = NULL ;  VpxVideoWriter * writer = NULL ;  vpx_codec_ctx_t codec ; vpx_codec_enc_cfg_t cfg ; vpx_image_t raw ; vpx_codec_err_t res ;  vpx_fixed_buf_t stats = { 0 } ;  VpxVideoInfo info = { 0 } ;  const VpxInterface * encoder = NULL ;  int pass ; const int fps = 30 ; const int bitrate = 200 ; const char * const codec_arg = argv [ 1 ] ; const char * const width_arg = argv [ 2 ] ; const char * const height_arg = argv [ 3 ] ; const char * const infile_arg = argv [ 4 ] ; const char * const outfile_arg = argv [ 5 ] ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; encoder = get_vpx_encoder_by_name ( codec_arg ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ;  info . codec_fourcc = encoder -> fourcc ;  info . time_base . numerator = 1 ; info . time_base . denominator = fps ; info . frame_width = strtol ( width_arg , NULL , 0 ) ;  info . frame_height = strtol ( height_arg , NULL , 0 ) ;   if ( info . frame_width <= 0 ||   info . frame_height <= 0 ||   ( info . frame_width % 2 ) != 0 ||   ( info . frame_height % 2 ) != 0 ) {   die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ;  }  if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width ,   info . frame_height , 1 ) ) {   die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ;  } writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing"" , outfile_arg ) ; printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; for ( pass = 0 ; pass < 2 ; ++ pass ) { int frame_count = 0 ; if ( pass == 0 ) { cfg . g_pass = VPX_RC_FIRST_PASS ; } else { cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; } if ( ! ( infile = fopen ( infile_arg , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , infile_arg ) ; if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;  while ( vpx_img_read ( & raw , infile ) ) {  ++ frame_count ; if ( pass == 0 ) { get_frame_stats ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { encode_frame ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ; } } if ( pass == 0 ) { get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { printf ( ""\\n"" ) ; }  fclose ( infile ) ;  printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , pass + 1 , frame_count ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; } vpx_img_free ( & raw ) ; free ( stats . buf ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }","int w , h ;vpx_codec_ctx_t codec ;vpx_fixed_buf_t stats ;const VpxInterface * encoder = NULL ;int pass ;",85
834,"buggy line: info . codec_fourcc = encoder -> fourcc ;info . time_base . numerator = 1 ;info . time_base . denominator = fps ;info . frame_width = strtol ( width_arg , NULL , 0 ) ;info . frame_height = strtol ( height_arg , NULL , 0 ) ;if ( info . frame_width <= 0 ||   info . frame_height <= 0 ||   ( info . frame_width % 2 ) != 0 ||   ( info . frame_height % 2 ) != 0 ) {die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ;}if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width ,   info . frame_height , 1 ) ) {die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ;}cwe id:CWE-119context: int main ( int argc , char * * argv ) { FILE * infile = NULL ;  VpxVideoWriter * writer = NULL ;  vpx_codec_ctx_t codec ; vpx_codec_enc_cfg_t cfg ; vpx_image_t raw ; vpx_codec_err_t res ;  vpx_fixed_buf_t stats = { 0 } ;  VpxVideoInfo info = { 0 } ;  const VpxInterface * encoder = NULL ;  int pass ; const int fps = 30 ; const int bitrate = 200 ; const char * const codec_arg = argv [ 1 ] ; const char * const width_arg = argv [ 2 ] ; const char * const height_arg = argv [ 3 ] ; const char * const infile_arg = argv [ 4 ] ; const char * const outfile_arg = argv [ 5 ] ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; encoder = get_vpx_encoder_by_name ( codec_arg ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ;  info . codec_fourcc = encoder -> fourcc ;  info . time_base . numerator = 1 ; info . time_base . denominator = fps ; info . frame_width = strtol ( width_arg , NULL , 0 ) ;  info . frame_height = strtol ( height_arg , NULL , 0 ) ;   if ( info . frame_width <= 0 ||   info . frame_height <= 0 ||   ( info . frame_width % 2 ) != 0 ||   ( info . frame_height % 2 ) != 0 ) {   die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ;  }  if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width ,   info . frame_height , 1 ) ) {   die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ;  } writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing"" , outfile_arg ) ; printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; for ( pass = 0 ; pass < 2 ; ++ pass ) { int frame_count = 0 ; if ( pass == 0 ) { cfg . g_pass = VPX_RC_FIRST_PASS ; } else { cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; } if ( ! ( infile = fopen ( infile_arg , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , infile_arg ) ; if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;  while ( vpx_img_read ( & raw , infile ) ) {  ++ frame_count ; if ( pass == 0 ) { get_frame_stats ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { encode_frame ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ; } } if ( pass == 0 ) { get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { printf ( ""\\n"" ) ; }  fclose ( infile ) ;  printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , pass + 1 , frame_count ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; } vpx_img_free ( & raw ) ; free ( stats . buf ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }","w = strtol ( width_arg , NULL , 0 ) ;info . frame_height = strtol ( height_arg , NULL , 0 ) ;if ( info . frame_width <= 0 || info . frame_height <= 0 || ( w % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ;}if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , w , h , 1 ) ) {die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ;}",85
835,"buggy line: while ( vpx_img_read ( & raw , infile ) ) {++ frame_count ;if ( pass == 0 ) {get_frame_stats ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ;}else {encode_frame ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ;}}if ( pass == 0 ) {get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ;}else {printf ( ""\\\}fclose ( infile ) ;printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\\cwe id:CWE-119context: int main ( int argc , char * * argv ) { FILE * infile = NULL ;  VpxVideoWriter * writer = NULL ;  vpx_codec_ctx_t codec ; vpx_codec_enc_cfg_t cfg ; vpx_image_t raw ; vpx_codec_err_t res ;  vpx_fixed_buf_t stats = { 0 } ;  VpxVideoInfo info = { 0 } ;  const VpxInterface * encoder = NULL ;  int pass ; const int fps = 30 ; const int bitrate = 200 ; const char * const codec_arg = argv [ 1 ] ; const char * const width_arg = argv [ 2 ] ; const char * const height_arg = argv [ 3 ] ; const char * const infile_arg = argv [ 4 ] ; const char * const outfile_arg = argv [ 5 ] ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; encoder = get_vpx_encoder_by_name ( codec_arg ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ;  info . codec_fourcc = encoder -> fourcc ;  info . time_base . numerator = 1 ; info . time_base . denominator = fps ; info . frame_width = strtol ( width_arg , NULL , 0 ) ;  info . frame_height = strtol ( height_arg , NULL , 0 ) ;   if ( info . frame_width <= 0 ||   info . frame_height <= 0 ||   ( info . frame_width % 2 ) != 0 ||   ( info . frame_height % 2 ) != 0 ) {   die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ;  }  if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width ,   info . frame_height , 1 ) ) {   die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ;  } writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing"" , outfile_arg ) ; printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; for ( pass = 0 ; pass < 2 ; ++ pass ) { int frame_count = 0 ; if ( pass == 0 ) { cfg . g_pass = VPX_RC_FIRST_PASS ; } else { cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; } if ( ! ( infile = fopen ( infile_arg , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , infile_arg ) ; if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;  while ( vpx_img_read ( & raw , infile ) ) {  ++ frame_count ; if ( pass == 0 ) { get_frame_stats ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { encode_frame ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ; } } if ( pass == 0 ) { get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { printf ( ""\\n"" ) ; }  fclose ( infile ) ;  printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , pass + 1 , frame_count ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; } vpx_img_free ( & raw ) ; free ( stats . buf ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }","+ frame_count ;while ( vpx_img_read ( & raw ) ;fclose ( infile ) ;printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\\",85
836,buggy line: if ( ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ;if ( c -> string )  cJSON_free ( c -> string ) ;cwe id:CWE-119context: void cJSON_Delete ( cJSON * c ) { cJSON * next ; while ( c ) { next = c -> next ; if ( ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ; if ( ! ( c -> type & cJSON_IsReference ) && c -> valuestring ) cJSON_free ( c -> valuestring ) ;  if ( c -> string )  cJSON_free ( c -> string ) ; cJSON_free ( c ) ; c = next ; } },if ( ! ( c -> type & cJSON_StringIsConst ) && ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ;if ( c -> string ) cJSON_free ( c -> string ) ;,86
837,buggy line: void vp9_inc_frame_in_layer ( SVC * svc ) {LAYER_CONTEXT * const lc = ( svc -> number_temporal_layers > 1 )  ? & svc -> layer_context [ svc -> temporal_layer_id ] : & svc -> layer_context [ svc -> spatial_layer_id ] ;}cwe id:CWE-119context:  void vp9_inc_frame_in_layer ( SVC * svc ) {   LAYER_CONTEXT * const lc = ( svc -> number_temporal_layers > 1 )  ? & svc -> layer_context [ svc -> temporal_layer_id ] : & svc -> layer_context [ svc -> spatial_layer_id ] ; ++ lc -> current_video_frame_in_layer ;  } ,void vp9_inc_frame_in_layer ( VP9_COMP * const cpi ) {LAYER_CONTEXT * const lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers ] ;++ lc -> frames_from_key_frame ;},87
838,"buggy line: if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;cwe id:CWE-269context: long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ;  if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;  for ( search = fs_searchpaths ; search ; search = search -> next )   {  len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } # ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , ""%s\\n"" , filename ) ; # endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",88
839,"buggy line: long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;cwe id:CWE-189context: static __inline__ void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ;  long rem ;   value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;  value -> tv_usec = rem / NSEC_PER_USEC ; }","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",89
840,"buggy line: switch ( atype ) {case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;else {ND_TCHECK ( * tptr ) ;cwe id:CWE-125context: static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ;  tunnel_type = * ( tptr + 1 ) ;  flags = * tptr ;  tlen = len ;  ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }","
",90
841,"buggy line: tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;cwe id:CWE-125context: static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ;  tunnel_type = * ( tptr + 1 ) ;  flags = * tptr ;  tlen = len ;  ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }","ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;",90
842,"buggy line: ExitLoop :  if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) {cwe id:CWE-125context: static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ;  ExitLoop :  if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }",quantum_info = DestroyQuantumInfo ( quantum_info ) ;ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) {,91
843,"buggy line: skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == \'\\\cwe id:CWE-835context: static enum rules_token lex ( struct scanner * s , union lvalue * val ) { skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == '\\n' ) return TOK_END_OF_LINE ; if ( chr ( s , '#' ) ) { skip_to_eol ( s ) ; goto skip_more_whitespace_and_comments ; } if ( eof ( s ) ) return TOK_END_OF_FILE ; s -> token_line = s -> line ; s -> token_column = s -> column ; s -> buf_pos = 0 ; if ( chr ( s , '<' ) ) {  while ( peek ( s ) != '>' && ! eol ( s ) )  buf_append ( s , next ( s ) ) ; if ( ! chr ( s , '>' ) ) { scanner_err ( s , ""unterminated<S2SV_blank>keysym<S2SV_blank>literal"" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , ""keysym<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_LHS_KEYSYM ; } if ( chr ( s , ':' ) ) return TOK_COLON ; if ( chr ( s , '!' ) ) return TOK_BANG ; if ( chr ( s , '~' ) ) return TOK_TILDE ; if ( chr ( s , \'\\""\' ) ) { while ( ! eof ( s ) && ! eol ( s ) && peek ( s ) != \'\\""\' ) { if ( chr ( s , '\\\\' ) ) { uint8_t o ; if ( chr ( s , '\\\\' ) ) { buf_append ( s , '\\\\' ) ; } else if ( chr ( s , \'""\' ) ) { buf_append ( s , \'""\' ) ; } else if ( chr ( s , 'x' ) || chr ( s , 'X' ) ) { if ( hex ( s , & o ) ) buf_append ( s , ( char ) o ) ; else scanner_warn ( s , ""illegal<S2SV_blank>hexadecimal<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal"" ) ; } else if ( oct ( s , & o ) ) { buf_append ( s , ( char ) o ) ; } else { scanner_warn ( s , ""unknown<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>(%c)<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal"" , peek ( s ) ) ; } } else { buf_append ( s , next ( s ) ) ; } } if ( ! chr ( s , \'\\""\' ) ) { scanner_err ( s , ""unterminated<S2SV_blank>string<S2SV_blank>literal"" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , ""string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) ; return TOK_ERROR ; } if ( ! is_valid_utf8 ( s -> buf , s -> buf_pos - 1 ) ) { scanner_err ( s , ""string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>UTF-8<S2SV_blank>string"" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_STRING ; } if ( is_alpha ( peek ( s ) ) || peek ( s ) == '_' ) { s -> buf_pos = 0 ; while ( is_alnum ( peek ( s ) ) || peek ( s ) == '_' ) buf_append ( s , next ( s ) ) ; if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , ""identifier<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) ; return TOK_ERROR ; } if ( streq ( s -> buf , ""include"" ) ) return TOK_INCLUDE ; val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_IDENT ; } skip_to_eol ( s ) ; scanner_err ( s , ""unrecognized<S2SV_blank>token"" ) ; return TOK_ERROR ; }",skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) && ! eof ( s ) ) ) if ( next ( s ) == \'\\\,92
844,"buggy line: while ( peek ( s ) != \'>\' && ! eol ( s ) )  buf_append ( s , next ( s ) ) ;cwe id:CWE-835context: static enum rules_token lex ( struct scanner * s , union lvalue * val ) { skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == '\\n' ) return TOK_END_OF_LINE ; if ( chr ( s , '#' ) ) { skip_to_eol ( s ) ; goto skip_more_whitespace_and_comments ; } if ( eof ( s ) ) return TOK_END_OF_FILE ; s -> token_line = s -> line ; s -> token_column = s -> column ; s -> buf_pos = 0 ; if ( chr ( s , '<' ) ) {  while ( peek ( s ) != '>' && ! eol ( s ) )  buf_append ( s , next ( s ) ) ; if ( ! chr ( s , '>' ) ) { scanner_err ( s , ""unterminated<S2SV_blank>keysym<S2SV_blank>literal"" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , ""keysym<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_LHS_KEYSYM ; } if ( chr ( s , ':' ) ) return TOK_COLON ; if ( chr ( s , '!' ) ) return TOK_BANG ; if ( chr ( s , '~' ) ) return TOK_TILDE ; if ( chr ( s , \'\\""\' ) ) { while ( ! eof ( s ) && ! eol ( s ) && peek ( s ) != \'\\""\' ) { if ( chr ( s , '\\\\' ) ) { uint8_t o ; if ( chr ( s , '\\\\' ) ) { buf_append ( s , '\\\\' ) ; } else if ( chr ( s , \'""\' ) ) { buf_append ( s , \'""\' ) ; } else if ( chr ( s , 'x' ) || chr ( s , 'X' ) ) { if ( hex ( s , & o ) ) buf_append ( s , ( char ) o ) ; else scanner_warn ( s , ""illegal<S2SV_blank>hexadecimal<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal"" ) ; } else if ( oct ( s , & o ) ) { buf_append ( s , ( char ) o ) ; } else { scanner_warn ( s , ""unknown<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>(%c)<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal"" , peek ( s ) ) ; } } else { buf_append ( s , next ( s ) ) ; } } if ( ! chr ( s , \'\\""\' ) ) { scanner_err ( s , ""unterminated<S2SV_blank>string<S2SV_blank>literal"" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , ""string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) ; return TOK_ERROR ; } if ( ! is_valid_utf8 ( s -> buf , s -> buf_pos - 1 ) ) { scanner_err ( s , ""string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>UTF-8<S2SV_blank>string"" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_STRING ; } if ( is_alpha ( peek ( s ) ) || peek ( s ) == '_' ) { s -> buf_pos = 0 ; while ( is_alnum ( peek ( s ) ) || peek ( s ) == '_' ) buf_append ( s , next ( s ) ) ; if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , ""identifier<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) ; return TOK_ERROR ; } if ( streq ( s -> buf , ""include"" ) ) return TOK_INCLUDE ; val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_IDENT ; } skip_to_eol ( s ) ; scanner_err ( s , ""unrecognized<S2SV_blank>token"" ) ; return TOK_ERROR ; }","while ( peek ( s ) != \'>\' && ! eol ( s ) ) buf_append ( s , next ( s ) ) ;",92
845,"buggy line: enc624j600WriteReg ( interface , ENC624J600_REG_EUDAST , 0x1234 ) ;}while ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x1234 ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_CLKRDY ) == 0 )  {}enc624j600SetBit ( interface , ENC624J600_REG_ECON2 , ECON2_ETHRST ) ;sleep ( 1 ) ;if ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x0000 )  {cwe id:CWE-20context: error_t enc624j600SoftReset ( NetInterface * interface ) { do {  enc624j600WriteReg ( interface , ENC624J600_REG_EUDAST , 0x1234 ) ;   } while ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x1234 ) ;   while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_CLKRDY ) == 0 )  { }  enc624j600SetBit ( interface , ENC624J600_REG_ECON2 , ECON2_ETHRST ) ;  sleep ( 1 ) ;  if ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x0000 )  { return ERROR_FAILURE ; } sleep ( 1 ) ; return NO_ERROR ; }","enc624j600WriteReg ( interface , ENC624J600_EUDAST , 0x1234 ) ;}while ( enc624j600ReadReg ( interface , ENC624J600_EUDAST ) != 0x1234 ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_CLKRDY ) == 0 ) {}enc624j600SetBit ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHRST ) ;sleep ( 1 ) ;if ( enc624j600ReadReg ( interface , ENC624J600_EUDAST ) != 0x0000 ) {",93
846,"buggy line: if ( length < 2 ) return 0 ;elementlen = * ( p + offset + 1 ) ;if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ;if ( length < elementlen + 2 ) return 0 ;switch ( * ( p + offset ) ) {case E_SSID : memcpy ( & ssid , p + offset , 2 ) ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) )  return 0 ;cwe id:CWE-125context: static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ;  if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) )  return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ;  if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) )  return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ;  if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) )  return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ;  memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ;  offset += tim . length - 3 ; length -= tim . length - 3 ; if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }","memcpy ( & ssid , p + offset , 2 ) ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ;",94
847,"buggy line: if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) )  return 0 ;if ( length < challenge . length ) return 0 ;cwe id:CWE-125context: static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ;  if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) )  return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ;  if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) )  return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ;  if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) )  return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ;  memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ;  offset += tim . length - 3 ; length -= tim . length - 3 ; if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }","
",94
