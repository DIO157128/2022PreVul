,source,target,group
0,if ( np -> opt != NULL )   icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen +   np -> opt -> opt_nflen ) ;inet -> inet_dport = usin -> sin6_port ;,if ( np -> opt != NULL ) icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + np -> opt -> opt_nflen ) ;inet -> inet_dport = usin -> sin6_port ;,2482
1,cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ;cm -> refresh_golden_frame = 0 ;cm -> refresh_last_frame = 1 ;cm -> refresh_entropy_probs = 1 ;,"
",2483
2,"cpi -> temporal_pattern_counter = 0 ;reset_temporal_layer_change ( cpi , oxcf , prev_number_of_layers ) ;cm -> Width = cpi -> oxcf . Width ;cm -> Height = cpi -> oxcf . Height ;if ( cpi -> oxcf . Sharpness > 7 ) cpi -> oxcf . Sharpness = 7 ;","if ( cpi -> temporal_layer_id > 0 ) {cpi -> temporal_layer_id = 0 ;cpi -> temporal_pattern_counter = 0 ;reset_temporal_layer_change ( cpi , oxcf , prev_number_of_layers ) ;}if ( ! cpi -> initial_width ) {cpi -> initial_width = cpi -> oxcf . Width ;cpi -> initial_height = cpi -> oxcf . Height ;assert ( cm -> Width <= cpi -> initial_width ) ;assert ( cm -> Height <= cpi -> initial_height ) ;}cm -> Width = cpi -> oxcf . Width ;cm -> Height = cpi -> oxcf . Height ;if ( cpi -> oxcf . Sharpness > 7 ) cpi -> oxcf . Sharpness = 7 ;",2483
3,"vp8_denoiser_allocate ( & cpi -> denoiser , width , height ) ;}","vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ;}",2483
4,if ( tcp -> csty & J2K_CP_CSTY_SOP ) {c [ 0 ] = 255 ;,"if ( tcp -> csty & J2K_CP_CSTY_SOP ) {if ( length < 6 ) {if ( p_t2_mode == FINAL_PASS ) {opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\\}return OPJ_FALSE ;}c [ 0 ] = 255 ;",2484
5,if ( tcp -> csty & J2K_CP_CSTY_EPH ) {c [ 0 ] = 255 ;,"if ( tcp -> csty & J2K_CP_CSTY_EPH ) {if ( length < 2 ) {if ( p_t2_mode == FINAL_PASS ) {opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\\}return OPJ_FALSE ;}c [ 0 ] = 255 ;",2484
6,"
",if ( lha -> compsize < 0 ) goto invalid ;,2485
7,"if ( sum_calculated != headersum ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ;","if ( sum_calculated != headersum ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ;",2485
8,"
","if ( ! allocate_field ( stream , field -> pField , field -> data_size , ( size_t ) ( * size + 1 ) ) ) return false ;field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size ) ;",2486
9,"}if ( ! pb_close_string_substream ( stream , & substream ) ) return false ;return status ;}else {pb_size_t * size = ( pb_size_t * ) field -> pSize ;if ( * size == PB_SIZE_MAX ) PB_RETURN_ERROR ( stream , ""too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries"" ) ;if ( ! check_wire_type ( wire_type , field ) ) PB_RETURN_ERROR ( stream , ""wrong<S2SV_blank>wire<S2SV_blank>type"" ) ;( * size ) ++ ;if ( ! allocate_field ( stream , field -> pField , field -> data_size , * size ) ) return false ;field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size - 1 ) ;","
",2486
10,rfcomm_dlc_accept ( d ) ;return 0 ;,rfcomm_dlc_accept ( d ) ;msg -> msg_namelen = 0 ;return 0 ;,2487
11,"static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2488
12,"memcpy ( & bss_cfg -> wmm_info , wmm_ie +   sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;priv -> wmm_enabled = 1 ;","if ( * ( wmm_ie + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return ;memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;priv -> wmm_enabled = 1 ;",2489
13,"FILE * file = fopen ( dump_file , ""w"" ) ;if ( ! file ) {","FILE * file = fopen_safe ( dump_file , ""w"" ) ;if ( ! file ) {",2490
14,if ( d_mountpoint ( dentry ) )  return 1 ;if ( nfsd4_is_junction ( dentry ) ) return 1 ;if ( ! ( exp -> ex_flags & NFSEXP_V4ROOT ) )  return 0 ;return d_inode ( dentry ) != NULL ;},if ( ! d_inode ( dentry ) ) return 0 ;if ( d_mountpoint ( dentry ) ) return 2 ;return 0 ;},2491
15,StringValue ( data ) ;in = ( unsigned char * ) RSTRING_PTR ( data ) ;,"if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ;StringValue ( data ) ;in = ( unsigned char * ) RSTRING_PTR ( data ) ;",2492
16,"p = strchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;","p = osStrchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;",2493
17,"int pkt_len , pktnum , hr , min , sec , csec ;char channel [ 10 ] , direction [ 10 ] ;","guint pkt_len ;int pktnum , hr , min , sec , csec ;char channel [ 10 ] , direction [ 10 ] ;",2494
18,"num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {phdr -> rec_type = REC_TYPE_PACKET ;phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ;","num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {if ( pkt_len > WTAP_MAX_PACKET_SIZE ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup_printf ( ""toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ;return FALSE ;}phdr -> rec_type = REC_TYPE_PACKET ;phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ;",2494
19,"ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ;pd = ws_buffer_start_ptr ( buf ) ;","ws_buffer_assure_space ( buf , pkt_len ) ;pd = ws_buffer_start_ptr ( buf ) ;",2494
20,long timeo ;msg -> msg_namelen = 0 ;,long timeo ;,2495
21,"int nNew = MAX ( 128 , p -> nAlloc * 2 ) ;while ( nByte > nNew ) nNew = nNew * 2 ;","sqlite3_int64 nNew = MAX ( 128 , 2 * ( sqlite3_int64 ) p -> nAlloc ) ;while ( nByte > nNew ) nNew = nNew * 2 ;",2496
22,"void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest ,  int stride , int eob ) {","void vp9_iht16x16_add ( TX_TYPE tx_type , const tran_low_t * input , uint8_t * dest , int stride , int eob ) {",2497
23,"xfs_daddr_t blkno = map [ 0 ] . bm_bn ;int numblks = 0 ;pag = xfs_perag_get ( btp -> bt_mount ,  xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ;","xfs_daddr_t blkno = map [ 0 ] . bm_bn ;xfs_daddr_t eofs ;int numblks = 0 ;eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ;if ( blkno >= eofs ) {xfs_alert ( btp -> bt_mount , ""%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>"" , __func__ , blkno , eofs ) ;return NULL ;}pag = xfs_perag_get ( btp -> bt_mount , xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ;",2498
24,"fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;fptr_orig = io_get_open_fptr ( mrb , orig ) ;","fptr_orig = io_get_open_fptr ( mrb , orig ) ;fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;",2499
25,"ret = poll ( pfds , 1 , 50 ) ;if ( ret < 0 ) {","ret = TEMP_FAILURE_RETRY ( poll ( pfds , 1 , 50 ) ) ;if ( ret < 0 ) {",2500
26,struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ;int err = 0 ;int is_udplite = IS_UDPLITE ( sk ) ;,struct flowi6 * fl6 ;int err = 0 ;int is_udplite = IS_UDPLITE ( sk ) ;if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ;fl6 = & inet -> cork . fl . u . ip6 ;,2501
27,"while ( c && cJSON_strcasecmp ( c -> string , string ) ) {++ i ;c = c -> next ;}if ( c ) {","+ i ;while ( c && cJSON_strcasecmp ( c -> string , string ) ) i ++ , c = c -> next ;}if ( c ) {",2502
28,"# if ENABLE_BGP_VNC  case BGP_ATTR_VNC : attrname = ""VNC"" ;","# if ENABLE_BGP_VNC_ATTR case BGP_ATTR_VNC : attrname = ""VNC"" ;",2503
29,"if ( err ) goto out ;upperdentry = ovl_dentry_upper ( dentry ) ;if ( upperdentry ) {mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ;}err = ovl_copy_up_last ( dentry , attr , false ) ;","mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ;}err = ovl_copy_up_last ( dentry , attr , false ) ;",2504
30,"if ( copy_from_user ( & info , u_info , sizeof ( info ) ) )  return - EFAULT ;if ( idx == - 1 ) idx = info . entry_number ;","if ( copy_from_user ( & info , u_info , sizeof ( info ) ) ) return - EFAULT ;if ( ! tls_desc_okay ( & info ) ) return - EINVAL ;if ( idx == - 1 ) idx = info . entry_number ;",2505
31,"
",mutt_socket_empty ( adata -> conn ) ;,2506
32,if ( rc == - 1 )  goto err_conn ;,if ( rc == - 1 ) goto err_conn ;,2506
33,"char data [ 8 ] ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;return - EIO ;}return - EIO ;}return snprintf ( buf , PAGE_SIZE , ""%d\\\","char * data ;data = kmalloc ( 8 , GFP_KERNEL ) ;if ( ! data ) return - ENOMEM ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;ret = - EIO ;goto out ;}ret = - EIO ;goto out ;}ret = snprintf ( buf , PAGE_SIZE , ""%d\\\out : kfree ( data ) ;return ret ;",2507
34,"static void set_fdc ( int drive )  {if ( drive >= 0 && drive < N_DRIVE ) {fdc = FDC ( drive ) ;current_drive = drive ;if ( fdc != 1 && fdc != 0 ) {pr_info ( ""bad<S2SV_blank>fdc<S2SV_blank>value\\\}set_dor ( fdc , ~ 0 , 8 ) ;","static void set_fdc ( int drive ) {unsigned int new_fdc = fdc ;if ( drive >= 0 && drive < N_DRIVE ) {new_fdc = FDC ( drive ) ;current_drive = drive ;if ( new_fdc >= N_FDC ) {pr_info ( ""bad<S2SV_blank>fdc<S2SV_blank>value\\\}fdc = new_fdc ;set_dor ( fdc , ~ 0 , 8 ) ;",2508
35,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( pool ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,2509
36,# if ! ( CONFIG_FAST_UNALIGNED )  dst [ 0 ] = src [ 0 ] ;dst [ 1 ] = src [ 1 ] ;dst [ 2 ] = src [ 2 ] ;dst [ 3 ] = src [ 3 ] ;dst [ 4 ] = src [ 4 ] ;dst [ 5 ] = src [ 5 ] ;dst [ 6 ] = src [ 6 ] ;dst [ 7 ] = src [ 7 ] ;dst [ 8 ] = src [ 8 ] ;dst [ 9 ] = src [ 9 ] ;dst [ 10 ] = src [ 10 ] ;dst [ 11 ] = src [ 11 ] ;dst [ 12 ] = src [ 12 ] ;dst [ 13 ] = src [ 13 ] ;dst [ 14 ] = src [ 14 ] ;dst [ 15 ] = src [ 15 ] ;# else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ;( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ;( ( uint32_t * ) dst ) [ 2 ] = ( ( uint32_t * ) src ) [ 2 ] ;( ( uint32_t * ) dst ) [ 3 ] = ( ( uint32_t * ) src ) [ 3 ] ;# endif src += src_stride ;,"memcpy ( dst , src , 16 ) ;src += src_stride ;",2510
37,"spin_lock ( & desc -> iuspin ) ;clear_bit ( WDM_RESPONDING , & desc -> flags ) ;","int length = urb -> actual_length ;spin_lock ( & desc -> iuspin ) ;clear_bit ( WDM_RESPONDING , & desc -> flags ) ;",2511
38,"desc -> reslength = urb -> actual_length ;memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ;desc -> length += desc -> reslength ;","if ( length + desc -> length > desc -> wMaxCommand ) {set_bit ( WDM_OVERFLOW , & desc -> flags ) ;}else {if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) {memmove ( desc -> ubuf + desc -> length , desc -> inbuf , length ) ;desc -> length += length ;desc -> reslength = length ;}}",2511
39,"if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) )  timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ;remaining = kc -> timer_remaining ( timr , now ) ;","if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ;remaining = kc -> timer_remaining ( timr , now ) ;",2512
40,"
","if ( s -> diff_start + s -> diff_height > cur_blk_height ) {av_log ( avctx , AV_LOG_ERROR , ""Block<S2SV_blank>parameters<S2SV_blank>invalid\\\return AVERROR_INVALIDDATA ;}",2513
41,"av_log ( avctx , AV_LOG_DEBUG ,  ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\","av_log ( avctx , AV_LOG_DEBUG , ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\",2513
42,"struct sshcomp * comp ;int r , mode ;for ( mode = 0 ;mode < MODE_MAX ;mode ++ ) {if ( ssh -> state -> newkeys [ mode ] == NULL ) continue ;comp = & ssh -> state -> newkeys [ mode ] -> comp ;if ( comp && comp -> enabled &&  ( r = ssh_packet_init_compression ( ssh ) ) != 0 )  return r ;}return 0 ;",int r ;if ( ( r = ssh_packet_init_compression ( ssh ) ) != 0 ) return r ;}return 0 ;,2514
43,"logger ( Protocol , Debug , ""rdpdr_process()"" ) ;in_uint16 ( s , component ) ;","struct stream packet = * s ;logger ( Protocol , Debug , ""rdpdr_process()"" ) ;in_uint16 ( s , component ) ;",2515
44,"in_uint32_le ( s , g_client_id ) ;if ( vmin < 0x000c ) g_client_id = 0x815ed39d ;","in_uint32_le ( s , g_client_id ) ;if ( ! s_check ( s ) ) {rdp_protocol_error ( ""rdpdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>g_client_id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>did<S2SV_blank>overrun"" , & packet ) ;}if ( vmin < 0x000c ) g_client_id = 0x815ed39d ;",2515
45,"static void filter_selectively_vert_row2 ( PLANE_TYPE plane_type ,  uint8_t * s , int pitch , unsigned int mask_16x16_l , unsigned int mask_8x8_l , unsigned int mask_4x4_l , unsigned int mask_4x4_int_l , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) {const int mask_shift = plane_type ? 4 : 8 ;const int mask_cutoff = plane_type ? 0xf : 0xff ;const int lfl_forward = plane_type ? 4 : 8 ;unsigned int mask_16x16_0 = mask_16x16_l & mask_cutoff ;","static void filter_selectively_vert_row2 ( int subsampling_factor , uint8_t * s , int pitch , unsigned int mask_16x16_l , unsigned int mask_8x8_l , unsigned int mask_4x4_l , unsigned int mask_4x4_int_l , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) {const int mask_shift = subsampling_factor ? 4 : 8 ;const int mask_cutoff = subsampling_factor ? 0xf : 0xff ;const int lfl_forward = subsampling_factor ? 4 : 8 ;unsigned int mask_16x16_0 = mask_16x16_l & mask_cutoff ;",2516
46,"const loop_filter_thresh * lfi0 = lfi_n -> lfthr + * lfl ;const loop_filter_thresh * lfi1 = lfi_n -> lfthr + * ( lfl + lfl_forward ) ;if ( mask & 1 ) {if ( ( mask_16x16_0 | mask_16x16_1 ) & 1 ) {if ( ( mask_16x16_0 & mask_16x16_1 ) & 1 ) {vp9_lpf_vertical_16_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim ,  lfi1 -> lim , lfi1 -> hev_thr ) ;if ( ( mask_8x8_0 & mask_8x8_1 ) & 1 ) {vp9_lpf_vertical_8_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ,  1 ) ;vp9_lpf_vertical_8 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ;if ( ( mask_4x4_0 & mask_4x4_1 ) & 1 ) {vp9_lpf_vertical_4_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_4 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ,  1 ) ;vp9_lpf_vertical_4 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ;vp9_lpf_vertical_4_dual ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_4 ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , 1 ) ;vp9_lpf_vertical_4 ( s + 8 * pitch + 4 , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ;","vpx_lpf_vertical_16_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vpx_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , 1 ) ;vpx_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr , 1 ) ;vpx_lpf_vertical_8_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vpx_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , 1 ) ;vpx_lpf_vertical_8 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr , 1 ) ;vp9_lpf_vertical_4_dual ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_4 ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , 1 ) ;vpx_lpf_vertical_4 ( s + 8 * pitch + 4 , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr , 1 ) ;",2516
47,"struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ;struct netdev_desc * desc ;case SIOCDEVPRIVATE :  break ;case SIOCDEVPRIVATE + 1 :   miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ;break ;case SIOCDEVPRIVATE + 2 :   mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ;break ;","struct mii_ioctl_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ;struct netdev_desc * desc ;case SIOCGMIIPHY : miidata -> phy_id = phy_addr ;break ;case SIOCGMIIREG : miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ;break ;case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ;mii_write ( dev , phy_addr , miidata -> val_in ) ;break ;",2517
48,"if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) {log ( ""cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>fractal<S2SV_blank>heap<S2SV_blank>indirect<S2SV_blank>block\\\log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s\\\if ( fgetc ( reader -> fhd ) != 0 ) {","if ( reader -> recursive_counter >= 10 ) return MYSOFA_INVALID_FORMAT ;else reader -> recursive_counter ++ ;if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) {log ( ""cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>fractal<S2SV_blank>heap<S2SV_blank>indirect<S2SV_blank>block\\\log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s<S2SV_blank>stack<S2SV_blank>%d\\\if ( fgetc ( reader -> fhd ) != 0 ) {",2518
49,return MYSOFA_OK ;},reader -> recursive_counter -- ;return MYSOFA_OK ;},2518
50,"rhost_old [ 0 ] = \'\\\\0\' ;r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ;","if ( desc == NULL ) desc = """" ;rhost_old [ 0 ] = \'\\\\0\' ;r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ;",2519
51,"static int  _PyMemoTable_ResizeTable ( PyMemoTable * self , Py_ssize_t min_size )  {Py_ssize_t new_size = MT_MINSIZE ;Py_ssize_t to_process ;assert ( min_size > 0 ) ;while ( new_size < min_size && new_size > 0 )  new_size <<= 1 ;if ( new_size <= 0 ) {","static int _PyMemoTable_ResizeTable ( PyMemoTable * self , size_t min_size ) {size_t new_size = MT_MINSIZE ;Py_ssize_t to_process ;assert ( min_size > 0 ) ;if ( min_size > PY_SSIZE_T_MAX ) {while ( new_size < min_size ) {new_size <<= 1 ;}",2520
52,struct stat st ;size_t pathlen ;,size_t pathlen ;,2521
53,"pr_fs_clear_cache ( ) ;res = pr_fsio_lstat ( path , & st ) ;xerrno = errno ;pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path ,  strerror ( xerrno ) ) ;errno = xerrno ;return - 1 ;if ( S_ISLNK ( st . st_mode ) ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>"" ""config)"" , path ) ;","res = is_symlink_path ( p , path , pathlen ) ;if ( errno == EPERM ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ;",2521
54,"static void prefetch_dec ( void )  {prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ;","static void prefetch_dec ( void ) {dec_tables . counter_head ++ ;dec_tables . counter_tail ++ ;prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ;",2522
55,"gdImageWBMPCtx ( im , fg , out ) ;rv = gdDPExtractData ( out , size ) ;out -> gd_free ( out ) ;","if ( ! _gdImageWBMPCtx ( im , fg , out ) ) {rv = gdDPExtractData ( out , size ) ;}else {rv = NULL ;}out -> gd_free ( out ) ;",2523
56,parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;parameters -> prch_init [ i ] = 256 ;},if ( parameters -> numresolution == 1 ) {parameters -> res_spec = 1 ;parameters -> prcw_init [ 0 ] = 128 ;parameters -> prch_init [ 0 ] = 128 ;}else {parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;}parameters -> prch_init [ i ] = 256 ;},2524
57,"int copied , error = - EINVAL ;if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ;","int copied , error = - EINVAL ;msg -> msg_namelen = 0 ;if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ;",2525
58,"goto try_again ;req -> status = 0 ;req -> zero = 0 ;req -> length = count ;req -> complete = f_hidg_req_complete ;req -> context = hidg ;status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ;if ( status < 0 ) {ERROR ( hidg -> func . config -> cdev , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\\goto release_write_pending_unlocked ;}spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;return status ;release_write_pending_unlocked :  hidg -> write_pending = 0 ;","goto release_write_pending ;spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;return status ;release_write_pending_unlocked : hidg -> write_pending = 0 ;",2526
59,"struct usmStateReference * old_ref = ( struct usmStateReference * ) old ;if ( old_ref ) {if ( old_ref -> usr_name_length ) SNMP_FREE ( old_ref -> usr_name ) ;if ( old_ref -> usr_engine_id_length )  SNMP_FREE ( old_ref -> usr_engine_id ) ;if ( old_ref -> usr_auth_protocol_length )  SNMP_FREE ( old_ref -> usr_auth_protocol ) ;if ( old_ref -> usr_priv_protocol_length )  SNMP_FREE ( old_ref -> usr_priv_protocol ) ;if ( old_ref -> usr_auth_key_length && old_ref -> usr_auth_key ) {SNMP_ZERO ( old_ref -> usr_auth_key , old_ref -> usr_auth_key_length ) ;SNMP_FREE ( old_ref -> usr_auth_key ) ;}if ( old_ref -> usr_priv_key_length && old_ref -> usr_priv_key ) {SNMP_ZERO ( old_ref -> usr_priv_key , old_ref -> usr_priv_key_length ) ;SNMP_FREE ( old_ref -> usr_priv_key ) ;}SNMP_ZERO ( old_ref , sizeof ( * old_ref ) ) ;SNMP_FREE ( old_ref ) ;}","struct usmStateReference * ref = old ;if ( old_ref ) {if ( old_ref -> usr_name_length ) SNMP_FREE ( old_ref -> usr_name ) ;SNMP_FREE ( ref -> usr_engine_id ) ;if ( old_ref -> usr_auth_protocol_length ) SNMP_FREE ( old_ref -> usr_auth_protocol ) ;SNMP_FREE ( ref -> usr_priv_protocol ) ;if ( old_ref -> usr_auth_key_length && old_ref -> usr_auth_key ) {SNMP_ZERO ( ref -> usr_auth_key , old_ref -> usr_auth_key_length ) ;SNMP_FREE ( ref -> usr_auth_key ) ;}if ( ref -> usr_priv_key_length && old_ref -> usr_priv_key ) {SNMP_ZERO ( ref -> usr_priv_key , old_ref -> usr_priv_key_length ) ;SNMP_FREE ( ref -> usr_priv_key ) ;}SNMP_ZERO ( old_ref , sizeof ( * old_ref ) ) ;SNMP_FREE ( old_ref ) ;}",2527
60,"if ( status ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\","if ( ! urb -> actual_length ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\\return ;}if ( status ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\",2528
61,"else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) {}else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) {memcpy ( command_info -> result_buffer , & data [ 1 ] ,  urb -> actual_length - 1 ) ;command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;","else if ( ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) {}else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) && ( urb -> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) {memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 ) ;command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;",2528
62,"void ptrace_triggered ( struct perf_event * bp , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {","void ptrace_triggered ( struct perf_event * bp , struct perf_sample_data * data , struct pt_regs * regs ) {",2529
63,"if ( plen > 1024 * 1024 - 1 ) goto error ;ret = key_get_type_from_user ( type , _type , sizeof ( type ) ) ;if ( ret < 0 ) goto error ;description = NULL ;if ( _description ) {description = strndup_user ( _description , KEY_MAX_DESC_SIZE ) ;if ( IS_ERR ( description ) ) {",if ( plen ) {,2530
64,if ( _payload ) {ret = - ENOMEM ;,if ( _payload ) {ret = - ENOMEM ;,2530
65,"static void save_context ( VP9_COMP * cpi , int mi_row , int mi_col ,  ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {const MACROBLOCK * const x = & cpi -> mb ;const MACROBLOCKD * const xd = & x -> e_mbd ;","static void save_context ( MACROBLOCK * const x , int mi_row , int mi_col , ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {const MACROBLOCKD * const xd = & x -> e_mbd ;",2531
66,"vpx_memcpy (  a + num_4x4_blocks_wide * p , xd -> above_context [ p ] + ( mi_col * 2 >> xd -> plane [ p ] . subsampling_x ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;vpx_memcpy (  l + num_4x4_blocks_high * p , xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;vpx_memcpy ( sa , xd -> above_seg_context + mi_col ,  sizeof ( * xd -> above_seg_context ) * mi_width ) ;vpx_memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) ,  sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;","memcpy ( a + num_4x4_blocks_wide * p , xd -> above_context [ p ] + ( mi_col * 2 >> xd -> plane [ p ] . subsampling_x ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;memcpy ( l + num_4x4_blocks_high * p , xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;memcpy ( sa , xd -> above_seg_context + mi_col , sizeof ( * xd -> above_seg_context ) * mi_width ) ;memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) , sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;",2531
67,int blockstodecode ;av_assert0 ( s -> samples >= 0 ) ;,int blockstodecode ;uint64_t decoded_buffer_size ;av_assert0 ( s -> samples >= 0 ) ;,2532
68,"if ( ! nblocks || nblocks > INT_MAX ) {av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\\","if ( ! nblocks || nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 ) {av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\\",2532
69,"av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size ,   2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ;if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ;","decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ;av_assert0 ( decoded_buffer_size <= INT_MAX ) ;av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , decoded_buffer_size ) ;if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ;",2532
70,"int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ;unsigned v = get_symbol ( c , state , 0 ) ;","int chroma_planes , chroma_h_shift , chroma_v_shift , transparency , colorspace , bits_per_raw_sample ;unsigned v = get_symbol ( c , state , 0 ) ;",2533
71,"f -> colorspace = get_symbol ( c , state , 0 ) ;if ( f -> version > 0 )   f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ;chroma_planes = get_rac ( c , state ) ;chroma_h_shift = get_symbol ( c , state , 0 ) ;chroma_v_shift = get_symbol ( c , state , 0 ) ;if ( chroma_planes != f -> chroma_planes  || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) {}f -> chroma_planes = chroma_planes ;","colorspace = get_symbol ( c , state , 0 ) ;bits_per_raw_sample = f -> version > 0 ) f -> avctx -> bits_per_raw_sample ;chroma_planes = get_rac ( c , state ) ;chroma_h_shift = get_symbol ( c , state , 0 ) ;chroma_v_shift = get_symbol ( c , state , 0 ) ;if ( colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) {}f -> colorspace = colorspace ;f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ;f -> chroma_planes = chroma_planes ;",2533
72,frame_end :  ff_er_frame_end ( & s -> er ) ;,frame_end : if ( ! s -> studio_profile ) ff_er_frame_end ( & s -> er ) ;,2534
73,sas_port_delete ( port -> port ) ;port -> port = NULL ;,sas_destruct_devices ( port ) ;sas_port_delete ( port -> port ) ;port -> port = NULL ;,2535
74,case OBJECT_TYPE_INTEGER :  ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ;break ;case OBJECT_TYPE_STRING :  ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;break ;,case OBJECT_TYPE_INTEGER : ( ( YR_OBJECT_INTEGER * ) copy ) -> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value ;break ;case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) object ) -> value != NULL ) {( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ;}else {( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;}break ;case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value ;break ;,2536
75,if ( ! vct_iscrlf ( * r ) ) {r ++ ;,if ( ! vct_iscrlf ( r ) ) {r ++ ;,2537
76,unsigned int random_variable = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {random_variable = get_random_int ( ) & STACK_RND_MASK ;random_variable <<= PAGE_SHIFT ;,unsigned long random_variable = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {random_variable = ( unsigned long ) get_random_int ( ) ;random_variable &= STACK_RND_MASK ;random_variable <<= PAGE_SHIFT ;,2538
77,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;buf [ 1 ] |= 1 << offset ;buf [ 2 ] = gpio_push_pull ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ;if ( ret < 0 ) {hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\\goto fail ;}spin_unlock_irqrestore ( & dev -> lock , flags ) ;cp2112_gpio_set ( chip , offset , value ) ;fail :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret < 0 ? ret : - EIO ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;mutex_unlock ( & dev -> lock , flags ) ;cp2112_gpio_set ( chip , offset , value ) ;fail : spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret < 0 ? ret : - EIO ;",2539
78,"spin_lock ( & inode -> i_lock ) ;inode -> i_blocks -= ( blocks_per_huge_page ( h ) * freed ) ;spin_unlock ( & inode -> i_lock ) ;hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ;hugetlb_acct_memory ( h , - ( chg - freed ) ) ;","struct hugepage_subpool * spool = subpool_inode ( inode ) ;spin_lock ( & inode -> i_lock ) ;hugepage_subpool_put_pages ( spool , ( chg - freed ) ) ;hugetlb_acct_memory ( h , - ( chg - freed ) ) ;",2540
79,"if ( keyring_key -> type != & key_type_logon ) {printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\\down_read ( & keyring_key -> sem ) ;ukp = user_key_payload ( keyring_key ) ;if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) {up_read ( & keyring_key -> sem ) ;","down_read ( & keyring_key -> sem ) ;if ( keyring_key -> type != & key_type_logon ) {printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\\ukp = user_key_payload ( keyring_key ) ;if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) {",2541
80,up_read ( & keyring_key -> sem ) ;up_read ( & keyring_key -> sem ) ;if ( res ) goto out ;crypt_info -> ci_keyring_key = keyring_key ;return 0 ;out : key_put ( keyring_key ) ;,out : up_read ( & keyring_key -> sem ) ;key_put ( keyring_key ) ;,2541
81,"memcpy ( res , dbg_data , nb10sz ) ;res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ;","
",2542
82,"int need_error_free = 0 ;int local_rcache = 0 , local_authcon = 0 ;if ( strcmp ( inbuf . data , sendauth_version ) ) {problem = KRB5_SENDAUTH_BADAUTHVERS ;","krb5_data d ;int need_error_free = 0 ;int local_rcache = 0 , local_authcon = 0 ;d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ;if ( ! data_eq ( inbuf , d ) ) {problem = KRB5_SENDAUTH_BADAUTHVERS ;",2543
83,"if ( appl_version && strcmp ( inbuf . data , appl_version ) ) {if ( ! problem ) {","if ( appl_version != NULL && ! problem ) {d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ;if ( ! data_eq ( inbuf , d ) ) {",2543
84,list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;ptr = buf ;,"if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ;list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;ptr = buf ;",2544
85,hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ;},hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + ( hwc -> idx - X86_PMC_IDX_FIXED ) ;},2545
86,"unsigned long flags ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;","unsigned long flags ;if ( qid > NVMET_NR_QUEUES ) return NULL ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;",2546
87,if ( msg -> maxsize - msg -> cursize < 4 ) {msg -> overflowed = qtrue ;,if ( msg -> overflowed ) {,2547
88,if ( bits == 8 ) {msg -> data [ msg -> cursize ] = value ;,if ( msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) {msg -> overflowed = qtrue ;return ;}if ( bits == 8 ) {msg -> data [ msg -> cursize ] = value ;,2547
89,nbits = bits & 7 ;for ( i = 0 ;,"nbits = bits & 7 ;if ( msg -> bit , msg -> maxsize << 3 + nbits > msg -> maxsize << 3 ) {msg -> overflowed = qtrue ;return ;}for ( i = 0 ;",2547
90,"Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;value = ( value >> 8 ) ;}}","Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;value = ( value >> 8 ) ;if ( msg -> bit > msg -> maxsize << 3 ) {msg -> overflowed = qtrue ;return ;}}}",2547
91,( NULL != ptr ) # if KEEP_NIS_AT_END  && ( NULL != ptr -> line )   && ( ( '+' != ptr -> line [ 0 ] )   && ( '-' != ptr -> line [ 0 ] ) )  # endif ;# if KEEP_NIS_AT_END  if ( ( NULL != ptr ) && ( NULL != ptr -> line ) ) {nis = ptr ;,( NULL != ptr ) # if KEEP_NIS_AT_END && ( ( NULL == ptr -> line ) && ( ( '+' != ptr -> line [ 0 ] ) ) ) # endif ;# if KEEP_NIS_AT_END if ( NULL != ptr ) {nis = ptr ;,2548
92,"if ( interpolation ) {if ( source < source_base ) source = source_base ;horiz_line_scale ( source , source_width , temp_area , dest_width ) ;}for ( k = 0 ;k < ( int ) ( dest_height + dest_band_height - 1 ) / dest_band_height ;k ++ ) {for ( i = 0 ;i < source_band_height ;i ++ ) {line_src = ( unsigned char * ) source + i * source_pitch ;if ( line_src < source_base ) line_src = source_base ;horiz_line_scale ( line_src , source_width , temp_area + ( i + 1 ) * dest_pitch , dest_width ) ;}vert_band_scale ( temp_area + dest_pitch , dest_pitch , dest , dest_pitch , dest_width ) ;if ( interpolation )  vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ;source += ( unsigned long ) source_band_height * source_pitch ;","if ( interpolation ) memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ;source += ( unsigned long ) source_band_height * source_pitch ;",2549
93,"source_band_height = temp_area_height - 1 ;dest_band_height = source_band_height * vratio / vscale ;Scale1Dh ( source , 1 , hscale , source_width + 1 , temp_area , 1 , hratio , dest_width ) ;bands = ( dest_height + dest_band_height - 1 ) / dest_band_height ;for ( k = 0 ;k < bands ;k ++ ) {for ( i = 1 ;i < source_band_height + 1 ;i ++ ) {if ( k * source_band_height + i < ( int ) source_height ) {Scale1Dh ( source + i * source_pitch , 1 , hscale , source_width + 1 , temp_area + i * dest_pitch , 1 , hratio , dest_width ) ;}else {vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ;}vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ;source += source_band_height * source_pitch ;","memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ;vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ;source += source_band_height * source_pitch ;",2549
94,if ( ack -> subh . addip_hdr -> serial == serial ) {sctp_chunk_hold ( ack ) ;,if ( sctp_chunk_pending ( ack ) ) continue ;if ( ack -> subh . addip_hdr -> serial == serial ) {sctp_chunk_hold ( ack ) ;,2550
95,if ( IS_ERR ( blkg ) ) {blkg_free ( new_blkg ) ;return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;,if ( IS_ERR ( blkg ) ) return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;,2551
96,"static int  mptctl_do_fw_download ( int ioc , char __user * ufwbuf , size_t fwlen )  {MPT_FRAME_HDR * mf ;MPT_ADAPTER * iocp ;","static int mptctl_do_fw_download ( MPT_ADAPTER * iocp , char __user * ufwbuf , size_t fwlen ) {MPT_FRAME_HDR * mf ;",2552
97,"if ( mpt_verify_adapter ( ioc , & iocp ) < 0 ) {printk ( KERN_DEBUG MYNAM ""ioctl_fwdl<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;}else {}dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_fwdl<S2SV_blank>called.<S2SV_blank>mptctl_id<S2SV_blank>=<S2SV_blank>%xh.\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.fwlen<S2SV_blank>=<S2SV_blank>%d\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.ioc<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%04xh\\\","}dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_fwdl<S2SV_blank>called.<S2SV_blank>mptctl_id<S2SV_blank>=<S2SV_blank>%xh.\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.fwlen<S2SV_blank>=<S2SV_blank>%d\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.ioc<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%04xh\\\",2552
98,"skb -> sk = sk ;llc_sap_state_process ( sap , skb ) ;","skb_orphan ( skb ) ;sock_hold ( sk ) ;skb -> sk = sk ;skb -> destructor = sock_efree ;llc_sap_state_process ( sap , skb ) ;",2553
99,# if HAVE_NEON  int64_t store_reg [ 8 ] ;# endif VP8_COMMON * cm ;,VP8_COMMON * cm ;,2554
100,return VPX_CODEC_CORRUPT_FRAME ;}cpi -> common . error . setjmp = 1 ;# if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {vp8_push_neon ( store_reg ) ;# endif vpx_usec_timer_start ( & cmptimer ) ;,vp8_clear_system_state ( ) ;return VPX_CODEC_CORRUPT_FRAME ;cpi -> common . error . setjmp = 1 ;vpx_usec_timer_start ( & cmptimer ) ;,2554
101,"# endif if ( ! cpi -> source ) {if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) {if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ;",# endif return - 1 ;,2554
102,# endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {,# endif # if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {,2554
103,if ( cpi -> oxcf . number_of_layers > 1 )  {unsigned int i ;assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;for ( i = 0 ;i < cpi -> oxcf . number_of_layers ;i ++ )  {,# if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_total_resolutions > 1 ) {LOWER_RES_FRAME_INFO * low_res_frame_info = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ;if ( cpi -> oxcf . mr_encoder_id ) {cpi -> ref_framerate = low_res_frame_info -> low_res_framerate ;}else {low_res_frame_info -> low_res_framerate = cpi -> ref_framerate ;}}# endif if ( cpi -> oxcf . number_of_layers && i < VPX_TS_MAX_LAYERS ;++ i ) {,2554
104,"layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;restore_layer_context ( cpi , layer ) ;vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ;}if ( cpi -> compressor_speed == 2 ) {vpx_usec_timer_start ( & tsctimer ) ;vpx_usec_timer_start ( & ticktimer ) ;}cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ;# if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING {int i ;const int num_part = ( 1 << cm -> multi_token_partition ) ;const unsigned long dest_size = dest_end - dest ;const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ;unsigned char * dp = dest ;cpi -> partition_d [ 0 ] = dp ;dp += dest_size / 10 ;cpi -> partition_d_end [ 0 ] = dp ;for ( i = 0 ;i < num_part ;i ++ ) {cpi -> partition_d [ i + 1 ] = dp ;dp += tok_part_buff_size ;cpi -> partition_d_end [ i + 1 ] = dp ;}}# endif * size = 0 ;vp8_clear_system_state ( ) ;cm -> frame_type = INTER_FRAME ;cm -> frame_flags = * frame_flags ;# if 0 if ( cm -> refresh_alt_ref_frame ) {cm -> refresh_golden_frame = 0 ;cm -> refresh_last_frame = 0 ;}else {cm -> refresh_golden_frame = 0 ;cm -> refresh_last_frame = 1 ;}# endif {int i = 0 ;for ( ;i < NUM_YV12_BUFFERS ;i ++ ) {if ( ! cm -> yv12_fb [ i ] . flags ) {cm -> new_fb_idx = i ;break ;}}assert ( i < NUM_YV12_BUFFERS ) ;# if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) {Pass1Encode ( cpi , size , dest , frame_flags ) ;}else if ( cpi -> pass == 2 ) {Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ;}else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ;if ( cpi -> compressor_speed == 2 ) {unsigned int duration , duration2 ;vpx_usec_timer_mark ( & tsctimer ) ;vpx_usec_timer_mark ( & ticktimer ) ;duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ;duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ;if ( cm -> frame_type != KEY_FRAME ) {if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ;else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ;}if ( duration2 ) {{if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ;else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ;}}}if ( cm -> refresh_entropy_probs == 0 ) {vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;}if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( * size > 0 ) {","if ( cpi -> temporal_layer_id >= 0 ) {memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_alt_ref_frame ) vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_golden_frame ) vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_last_frame ) vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( * size > 0 ) {",2554
105,"int y_samples = orig -> y_height * orig -> y_width ;int uv_samples = orig -> uv_height * orig -> uv_width ;int t_samples = y_samples + 2 * uv_samples ;double sq_error , sq_error2 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;","unsigned int y_width = cpi -> common . Width ;unsigned int y_height = cpi -> common . Height ;unsigned int uv_width = ( y_width + 1 ) / 2 ;unsigned int uv_height = ( y_height + 1 ) / 2 ;int y_samples = orig -> y_height * orig -> y_width ;int uv_samples = orig -> uv_height * orig -> uv_width ;int t_samples = y_samples + 2 * uv_samples ;double sq_error , sq_error2 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;",2554
106,"double frame_psnr2 , frame_ssim2 = 0 ;double weight = 0 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;","double frame_psnr2 , frame_ssim2 = 0 ;double weight = 0 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , y_width , y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , uv_width , uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> u_buffer , pp -> uv_stride , uv_width , uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;",2554
107,"frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;cpi -> summed_quality += frame_ssim2 * weight ;","frame_ssim2 = vpx_calc_ssim ( cpi -> Source , & cm -> post_proc_buffer , & weight ) ;cpi -> summed_quality += frame_ssim2 * weight ;",2554
108,"frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ;","frame_all = vpx_calc_ssimg ( cpi -> Source , cm -> frame_to_show , & y , & u , & v ) ;",2554
109,# endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {vp8_pop_neon ( store_reg ) ;}# endif cpi -> common . error . setjmp = 0 ;,# endif # endif cpi -> common . error . setjmp = 0 ;,2554
110,"( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;image = DestroyImage ( image ) ;","( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;page_geometry = DestroyString ( page_geometry ) ;image = DestroyImage ( image ) ;",2555
111,"if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) )  return cid ;cid ++ )  if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) )  return cid ;","if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) return cid ;cid ++ ) if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) return cid ;",2556
112,exit ( - 1 ) ;}exit ( - 1 ) ;}exit ( - 1 ) ;}exit ( - 1 ) ;},exit ( 1 ) ;}exit ( 1 ) ;}exit ( 1 ) ;}exit ( 1 ) ;},2557
113,"struct efx_nic * efx = netdev_priv ( net_dev ) ;if ( ring -> rx_mini_pending || ring -> rx_jumbo_pending || ring -> rx_pending > EFX_MAX_DMAQ_SIZE || ring -> tx_pending > EFX_MAX_DMAQ_SIZE ) return - EINVAL ;if ( ring -> rx_pending < EFX_MIN_RING_SIZE ||  ring -> tx_pending < EFX_MIN_RING_SIZE ) {netif_err ( efx , drv , efx -> net_dev ,  ""TX<S2SV_blank>and<S2SV_blank>RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%ld\\\return efx_realloc_channels ( efx , ring -> rx_pending , ring -> tx_pending ) ;}","struct efx_nic * efx = netdev_priv ( net_dev ) ;u32 txq_entries ;if ( ring -> rx_mini_pending || ring -> rx_jumbo_pending || ring -> rx_pending > EFX_MAX_DMAQ_SIZE || ring -> tx_pending > EFX_MAX_DMAQ_SIZE ) return - EINVAL ;if ( ring -> rx_pending < EFX_RXQ_MIN_ENT ) {netif_err ( efx , drv , efx -> net_dev , ""RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%u\\\txq_entries = max ( ring -> tx_pending , EFX_TXQ_MIN_ENT ( efx ) ) ;if ( txq_entries != ring -> tx_pending ) netif_warn ( efx , drv , efx -> net_dev , ""increasing<S2SV_blank>TX<S2SV_blank>queue<S2SV_blank>size<S2SV_blank>to<S2SV_blank>minimum<S2SV_blank>of<S2SV_blank>%u\\\return efx_realloc_channels ( efx , ring -> rx_pending , txq_entries ) ;}",2558
114,"bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ;}","bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPU_ID ) ;}",2559
115,if ( shdr -> sh_size < 1 ) {return NULL ;,if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return NULL ;,2560
116,if ( header_len > LEVEL_3_MAX_HEADER_LEN ) {return 0 ;,if ( header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header ) ) {return 0 ;,2561
117,image -> columns = image -> rows = 0 ;image -> colors = 0 ;,image -> columns = image -> rows = 0 ;image -> colors = 0 ;,2562
118,if ( BImgBuff )  BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ;;break ;,if ( BImgBuff ) ;break ;,2562
119,"void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi )  {__issue_discard_cmd ( sbi , false ) ;__drop_discard_cmd ( sbi ) ;__wait_discard_cmd ( sbi , false ) ;}","void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi , bool umount ) {__issue_discard_cmd ( sbi , ! umount ) ;}",2563
120,"dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\bsg_set_block ( bd , file ) ;","dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ;bsg_set_block ( bd , file ) ;",2564
121,"if ( check_stack_guard_page ( vma , address ) < 0 )  return VM_FAULT_SIGSEGV ;","if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ;if ( check_stack_guard_page ( vma , address ) < 0 ) return VM_FAULT_SIGSEGV ;",2565
122,if ( ! mm )  return 0 ;,if ( ! mm || ! mm -> env_end ) return 0 ;,2566
123,"static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe ,  struct pipe_buffer * buf ) {ref -> ref ++ ;}","static bool buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {if ( ref -> ref > INT_MAX / 2 ) return false ;ref -> ref ++ ;return true ;}",2567
124,"cork -> length += length ;if ( length > mtu ) {int proto = sk -> sk_protocol ;if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ;if ( proto == IPPROTO_UDP &&  ( rt -> dst . dev -> features & NETIF_F_UFO ) ) {}if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ;","if ( ( length > mtu ) {int proto = sk -> sk_protocol ;if ( dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ;skb = skb_peek_tail ( & sk -> sk_write_queue ) ;cork -> length += length ;if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) ) {if ( ! skb ) goto alloc_new_skb ;",2568
125,INST_HANDLER ( sts ) {int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,INST_HANDLER ( sts ) {if ( len < 4 ) {return ;}int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,2569
126,if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) )  if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;,"if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;",2570
127,"return kvm_x86_ops -> set_msr ( vcpu , msr ) ;}","switch ( msr -> index ) {case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ;break ;case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ;}return kvm_x86_ops -> set_msr ( vcpu , msr ) ;}",2571
128,"char file [ PATH_MAX ] ;strlcat ( info -> path , ""maps"" , sizeof ( info -> path ) ) ;while ( fscanf ( maps , ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%s<S2SV_blank>%ld<S2SV_blank>%s\\\","char file [ 1024 ] ;strlcat ( info -> path , ""maps"" , sizeof ( info -> path ) ) ;while ( fscanf ( maps , ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%5s<S2SV_blank>%ld<S2SV_blank>%1023s\\\",2572
129,"int is_pdf ;char * header ;header = get_header ( fp ) ;if ( header && strstr ( header , ""%PDF-"" ) )  is_pdf = 1 ;else is_pdf = 0 ;","char * header ;if ( ! ( header = get_header ( fp ) ) ) return 0 ;const char * c = strstr ( header , ""%PDF-"" ) ;const int is_pdf = c && ( ( c - header + strlen ( ""%PDF-M.m"" ) ) < 1024 ) ;",2573
130,"uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ;nblks += dblocks ;","uint dblocks = xfs_attr3_rmt_blocks ( mp , valuelen ) ;nblks += dblocks ;",2574
131,"archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC ,   ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;archive_clear_error ( & a -> archive ) ;","const size_t max_write = INT_MAX ;archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;if ( s > max_write ) s = max_write ;archive_clear_error ( & a -> archive ) ;",2575
132,case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE :  case RAPTOR_OPTION_RELATIVE_URIS :  case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ;,case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case RAPTOR_OPTION_RELATIVE_URIS : case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ;,2576
133,"
",if ( ! str ) return NULL ;,2577
134,"if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) {Py_DECREF ( str ) ;","if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) {Py_DECREF ( str ) ;",2577
135,if ( ( error_code >> 16 ) != 0x8009 )  return WindowsErrorString ( ) ;,if ( ( ( error_code >> 16 ) != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) return WindowsErrorString ( ) ;,2578
136,"case CRYPT_E_NO_TRUSTED_SIGNER :  return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ;default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ;","case CRYPT_E_NO_TRUSTED_SIGNER : return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ;case CERT_E_UNTRUSTEDROOT : return ""The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted."" ;case TRUST_E_NOSIGNATURE : return ""Not<S2SV_blank>digitally<S2SV_blank>signed."" ;case TRUST_E_EXPLICIT_DISTRUST : return ""One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."" ;default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ;",2578
137,"if ( perf_event_overflow ( event , 1 , & data , regs ) )  x86_pmu_stop ( event , 0 ) ;","if ( perf_event_overflow ( event , & data , regs ) ) x86_pmu_stop ( event , 0 ) ;",2579
138,"
","memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ;",2580
139,int_fb_list -> int_fb [ i ] . size = min_size ;},int_fb_list -> int_fb [ i ] . size = min_size ;},2580
140,"box -> info = boxinfo ;box -> ops = & boxinfo -> ops ;if ( extlen > 0xffffffffUL ) {jas_eprintf ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\\extlen = 0xffffffffUL ;}box -> len = extlen ;box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ;}else {box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ;}if ( box -> len != 0 && box -> len < 8 ) {goto error ;}dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ;if ( dataflag ) {if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) {goto error ;}if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) {box -> ops = & jp2_boxinfo_unk . ops ;jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\goto error ;}jas_stream_rewind ( tmpstream ) ;if ( box -> ops -> getdata ) {","box -> info = boxinfo ;box -> ops = & boxinfo -> ops ;jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\jas_stream_rewind ( tmpstream ) ;box -> ops = & boxinfo -> ops ;if ( box -> ops -> getdata ) {",2581
141,"__evtchn_fifo_handle_events ( cpu , true ) ;return 0 ;","__evtchn_fifo_handle_events ( cpu , NULL ) ;return 0 ;",2582
142,"ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ;if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;return - 1 ;}","ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;",2583
143,"l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;if  ( ! l_current_pi -> include ) {","l_current_pi -> include = 00 ;if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}if ( ! l_current_pi -> include ) {",2584
144,"if ( c == EOF ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}file = ( FILE * ) NULL ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;}length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ;( void ) length ;filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ;for ( i = 0 ;i < ( ssize_t ) filesize ;i ++ ) {c = ReadBlobByte ( pwp_image ) ;if ( c == EOF ) break ;( void ) fputc ( c , file ) ;}","if ( fputc ( c , file ) != c ) break ;",2585
145,"if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {ret = key -> type -> instantiate ( key , prep ) ;set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ;if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;","if ( key -> state == KEY_IS_UNINSTANTIATED ) {ret = key -> type -> instantiate ( key , prep ) ;mark_key_instantiated ( key , 0 ) ;if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;",2586
146,"const int sb_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ;int min_log2 = 0 , max_log2 = 0 ;while ( ( sb_cols >> max_log2 ) >= MIN_TILE_WIDTH_B64 ) ++ max_log2 ;-- max_log2 ;if ( max_log2 < 0 ) max_log2 = 0 ;while ( ( MAX_TILE_WIDTH_B64 << min_log2 ) < sb_cols ) ++ min_log2 ;assert ( min_log2 <= max_log2 ) ;* min_log2_tile_cols = min_log2 ;* max_log2_tile_cols = max_log2 ;}",const int sb64_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ;* min_log2_tile_cols = min_log2 ;* max_log2_tile_cols = get_max_log2_tile_cols ( sb64_cols ) ;assert ( * min_log2_tile_cols <= * max_log2_tile_cols ) ;},2587
147,"if ( lf -> last_sharpness_level != lf -> sharpness_level ) {update_sharpness ( lfi , lf -> sharpness_level ) ;lf -> last_sharpness_level = lf -> sharpness_level ;}for ( seg_id = 0 ;seg_id < MAX_SEGMENTS ;seg_id ++ ) {int lvl_seg = default_filt_lvl ;if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) {const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ;lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ;vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ;}","if ( segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) {const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ;lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ;vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ;}",2588
148,"dev_net_set ( dev , net ) ;dev -> rtnl_link_ops = & tun_link_ops ;","err = dev_get_valid_name ( net , dev , name ) ;if ( err ) goto err_free_dev ;dev_net_set ( dev , net ) ;dev -> rtnl_link_ops = & tun_link_ops ;",2589
149,"ctxt -> dst . type = OP_REG ;ctxt -> dst . addr . reg = & ctxt -> _eip ;ctxt -> dst . bytes = ctxt -> op_bytes ;rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;","unsigned long eip ;rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;rc = assign_eip_near ( ctxt , eip ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;",2590
150,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( pool ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,2591
151,"if ( size > INT_MAX )  size = INT_MAX ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;","if ( size > INT_MAX ) size = INT_MAX ;if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;",2592
152,"if ( attr >= 0 ) {xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ;","if ( attr >= 0 && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS ) {xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ;",2593
153,"n = r -> iov . iov_len / 512 ;if ( n ) {qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ;","n = r -> qiov . size / 512 ;if ( n ) {bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ;",2594
154,"case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED : dev_replace -> srcdev = btrfs_find_device ( fs_info -> fs_devices ,  src_devid , NULL , NULL ) ;dev_replace -> tgtdev = btrfs_find_device ( fs_info -> fs_devices , BTRFS_DEV_REPLACE_DEVID ,  NULL , NULL ) ;if ( ! dev_replace -> srcdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) {","case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED : dev_replace -> srcdev = btrfs_find_device ( fs_info -> fs_devices , src_devid , NULL , NULL , true ) ;dev_replace -> tgtdev = btrfs_find_device ( fs_info -> fs_devices , BTRFS_DEV_REPLACE_DEVID , NULL , NULL , true ) ;if ( ! dev_replace -> srcdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) {",2595
155,"
","if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) {al = SSL_AD_UNEXPECTED_MESSAGE ;SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ;goto f_err ;}",2596
156,if ( ( rsa = RSA_new ( ) ) == NULL )  {,if ( ( rsa = RSA_new ( ) ) == NULL ) {,2596
157,if ( header_len > LEVEL_3_MAX_HEADER_LEN ) {return 0 ;,if ( header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header ) ) {return 0 ;,2597
158,crypto_free_skcipher ( private ) ;},struct skcipher_tfm * tfm = private ;crypto_free_skcipher ( tfm -> skcipher ) ;kfree ( tfm ) ;},2598
159,"static void restore_context ( VP9_COMP * cpi , int mi_row , int mi_col ,  ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;","static void restore_context ( MACROBLOCK * const x , int mi_row , int mi_col , ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {MACROBLOCKD * const xd = & x -> e_mbd ;",2599
160,"vpx_memcpy (  xd -> above_context [ p ] + ( ( mi_col * 2 ) >> xd -> plane [ p ] . subsampling_x ) , a + num_4x4_blocks_wide * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;vpx_memcpy (  xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , l + num_4x4_blocks_high * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;vpx_memcpy ( xd -> above_seg_context + mi_col , sa ,  sizeof ( * xd -> above_seg_context ) * mi_width ) ;vpx_memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl ,  sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;","memcpy ( xd -> above_context [ p ] + ( ( mi_col * 2 ) >> xd -> plane [ p ] . subsampling_x ) , a + num_4x4_blocks_wide * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;memcpy ( xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , l + num_4x4_blocks_high * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;memcpy ( xd -> above_seg_context + mi_col , sa , sizeof ( * xd -> above_seg_context ) * mi_width ) ;memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl , sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;",2599
161,ND_TCHECK ( dp [ 0 ] ) ;,ND_TCHECK ( dp [ 4 ] ) ;,2600
162,"ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;dp += 3 ;ND_TCHECK ( dp [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ;","ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] ) ) ) ) ;",2600
163,"case BSD_AFNUM_ISO :  isoclns_print ( ndo , p , length , caplen ) ;break ;","case BSD_AFNUM_ISO : isoclns_print ( ndo , p , length , caplen ) ;break ;",2601
164,# endif  if ( name == NULL ) {spacePop ( ctxt ) ;,# endif if ( ctxt -> instate == XML_PARSER_EOF ) return ;if ( name == NULL ) {spacePop ( ctxt ) ;,2602
165,"
",hdr -> sadb_msg_reserved = 0 ;,2603
166,"pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;","pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;",2603
167,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\",2604
168,"if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}","if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}",2605
169,assert ( dev -> lintr . pin > 0 ) ;pthread_mutex_lock ( & dev -> lintr . lock ) ;,"if ( dev -> lintr . pin <= 0 ) {pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\\return ;}pthread_mutex_lock ( & dev -> lintr . lock ) ;",2606
170,"( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;image = DestroyImage ( image ) ;","( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;geometry = DestroyString ( geometry ) ;image = DestroyImage ( image ) ;",2607
171,"ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ;return ;}if ( ! ndo -> ndo_eflag ) {ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ;}if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) {ND_PRINT ( ( ndo , ""%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ) ;case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;if ( ATMTHRD_LEN ( ap ) != 0 ) {ND_PRINT ( ( ndo , "")"" ) ) ;}ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_NAK :  ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;","ND_PRINT ( ( ndo , ""who-has<S2SV_blank>"" ) ) ;atmarp_tpaddr_print ( ndo , ap , pro ) ;case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;if ( ATMTHRD_LEN ( ap ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;break ;case ARPOP_REPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ""at<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""for<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_NAK : ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;",2608
172,if ( ! ext_dp -> icmp_length ) {vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . len = hlen ;hlen -= 4 ;obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ;,"if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) {vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) {}vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . len = hlen ;hlen -= 4 ;obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ;",2609
173,"void show_object_with_name ( FILE * out , struct object * obj ,  struct strbuf * path , const char * component )  {fputc ( \'\\\free ( name ) ;}","void show_object_with_name ( FILE * out , struct object * obj , const char * component ) {}",2610
174,usleep ( us_delay ) ;pthread_mutex_unlock ( & out -> common . lock ) ;,TEMP_FAILURE_RETRY ( usleep ( us_delay ) ) ;pthread_mutex_unlock ( & out -> common . lock ) ;,2611
175,"int err ;if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) {struct frag_hdr fhdr ;skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;skb -> ip_summed = CHECKSUM_PARTIAL ;skb -> csum = 0 ;__skb_queue_tail ( & sk -> sk_write_queue , skb ) ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;","struct frag_hdr fhdr ;int err ;if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) {skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;skb -> csum = 0 ;__skb_queue_tail ( & sk -> sk_write_queue , skb ) ;}else if ( skb_is_gso ( skb ) ) {goto append ;}skb -> ip_summed = CHECKSUM_PARTIAL ;append : return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",2612
176,"else ND_PRINT ( ( ndo , ""[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>"" ) ) ;}}ND_PRINT ( ( ndo , ""ICMP6,<S2SV_blank>%s"" , tok2str ( icmp6_type_values , ""unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)"" , dp -> icmp6_type ) ) ) ;if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ;","ND_TCHECK ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ;",2613
177,"if ( dp -> icmp6_data16 [ 1 ] & 0xc0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""M"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x40 )  ND_PRINT ( ( ndo , ""O"" ) ) ;","if ( dp -> icmp6_data16 [ 1 ] ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;",2613
178,PureFileInfo * r ;int d ;,PureFileInfo * r ;char * alloca_subdir ;size_t sizeof_subdir ;int d ;,2614
179,"
",sizeof_subdir = PATH_MAX + 1U ;if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) {goto toomany ;},2614
180,"listfile ( s , NULL ) ;}else {d = listfile ( s , NULL ) ;}}if ( ! d ) {s -> name_offset = ( size_t ) - 1 ;}s ++ ;}outputfiles ( f , tls_fd ) ;r = dir ;while ( opt_R && r != s ) {if ( r -> name_offset != ( size_t ) - 1 && ! chdir ( FI_NAME ( r ) ) ) {char * alloca_subdir ;const size_t sizeof_subdir = PATH_MAX + 1U ;if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) {goto toomany ;}","
",2614
181,nolist :  ALLOCA_FREE ( alloca_subdir ) ;if ( matches >= max_ls_files ) {,nolist : ALLOCA_FREE ( alloca_subdir ) ;if ( matches >= max_ls_files ) {,2614
182,toomany :  free ( names ) ;free ( dir ) ;,toomany : ALLOCA_FREE ( alloca_subdir ) ;free ( names ) ;free ( dir ) ;,2614
183,"
","if ( getenv ( ""HASHSEED"" ) ) json_object_seed ( getenv_int ( ""HASHSEED"" ) ) ;",2615
184,"if ( getenv_int ( ""STRIP"" ) ) {size_t size = 0 , used = 0 ;","if ( getenv_int ( ""STRIP"" ) ) {size_t size = 0 , used = 0 ;",2615
185,"oe_errno = 0 ;if ( ! sock )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( addrlen )  addrlen_in = * addrlen ;if ( oe_syscall_getsockname_ocall ( & ret , sock -> host_fd ,  ( struct oe_sockaddr * ) addr ,  addrlen_in ,  addrlen ) != OE_OK )  {done :  return ret ;","oe_socklen_t addrlen_out = 0 ;oe_errno = 0 ;if ( oe_syscall_getsockname_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , addrlen ) != OE_OK ) {if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( addrlen_in >= addrlen_out ) * addrlen = addrlen_out ;done : return ret ;",2616
186,err = - EFAULT ;goto out ;}if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) {u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR :  case PSR_AA32_MODE_FIQ :  case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND :  case PSR_MODE_EL0t :  case PSR_MODE_EL1t :  case PSR_MODE_EL1h :  break ;,u64 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ;break ;case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;,2617
187,return ret ;},goto out_controller_put ;},2618
188,for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;,if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ;for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;,2619
189,if ( unix_sock_count ) {for ( i = scm -> fp -> count - 1 ;}return max_level ;,for ( i = scm -> fp -> count - 1 ;return max_level ;,2619
190,register const u_char * ep ;register u_char type ;ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;,register u_char type ;ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;,2620
191,"
",if ( len < 8 ) goto trunc ;{,2620
192,"case PIMV1_TYPE_JOIN_PRUNE : case PIMV1_TYPE_GRAFT : case PIMV1_TYPE_GRAFT_ACK :  if ( ndo -> ndo_vflag )  pimv1_join_prune_print ( ndo , & bp [ 8 ] , len - 8 ) ;break ;}","case PIMV1_TYPE_JOIN_PRUNE : case PIMV1_TYPE_GRAFT : case PIMV1_TYPE_GRAFT_ACK : if ( ndo -> ndo_vflag ) pimv1_join_prune_print ( ndo , & bp [ 8 ] , len - 8 ) ;}break ;}",2620
193,"if ( offset != 0 )  csum = csum_sub ( csum ,  csum_partial ( skb_transport_header ( skb ) + tlen ,   offset , 0 ) ) ;put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ;","if ( offset != 0 ) {int tend_off = skb_transport_offset ( skb ) + tlen ;csum = csum_sub ( csum , skb_checksum ( skb , tend_off , offset , 0 ) ) ;}put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ;",2621
194,"int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {","int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {",2622
195,int max_bytes_matched = input_size ;input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;,int max_bytes_matched ;max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size ;input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;,2622
196,"set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ;","set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ;set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ;",2623
197,"file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ;if ( ! file ) return - ENOMEM ;","file = kzalloc ( sizeof ( * file ) , GFP_NOIO ) ;if ( ! file ) return - ENOMEM ;",2624
198,# endif  if ( ( user = getpwnam ( username ) ) == NULL ) {,# endif char * crypt_password ;if ( ( user = getpwnam ( username ) ) == NULL ) {,2625
199,"# endif  if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 )  {","# endif crypt_password = crypt ( password , user_password ) ;if ( crypt_password == NULL ) {pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ;return - 1 ;}if ( strcmp ( user_password , crypt_password ) != 0 ) {",2625
200,"if ( atomic_dec_and_test ( & ucounts -> count ) ) {spin_lock_irqsave ( & ucounts_lock , flags ) ;hlist_del_init ( & ucounts -> node ) ;spin_unlock_irqrestore ( & ucounts_lock , flags ) ;}","spin_lock_irqsave ( & ucounts_lock , flags ) ;ucounts -> count -= 1 ;if ( ! ucounts -> count ) hlist_del_init ( & ucounts -> node ) ;else ucounts = NULL ;spin_unlock_irqrestore ( & ucounts_lock , flags ) ;",2626
201,"
",if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ;,2627
202,length += len ;},length += len ;},2627
203,if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) )  {,"( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) {",2628
204,}read_lock ( & tasklist_lock ) ;,}if ( pid == INT_MIN ) return - ESRCH ;read_lock ( & tasklist_lock ) ;,2629
205,free ( mem ) ;},if ( mem ) {free ( mem ) ;mem = NULL ;}return ;},2630
206,"size_t ld ;const char * data = luaL_checklstring ( L , 2 , & ld ) ;size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ;int n = 0 ;size_t size = optsize ( L , opt , & fmt ) ;pos += gettoalign ( pos , & h , opt , size ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;","luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ;pos -- ;int n = 0 ;size_t size = optsize ( L , size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;",2631
207,"if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 )  {","if ( TEMP_FAILURE_RETRY ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) ) == - 1 ) {",2632
208,"bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ;if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) {bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\\free ( bin -> dyld_info ) ;return false ;","bin -> dyld_info = calloc ( 1 , sizeof ( struct dyld_info_command ) ) ;if ( bin -> dyld_info ) {if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) {bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\\R_FREE ( bin -> dyld_info ) ;return false ;",2633
209,"break ;case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ;","}break ;case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ;",2633
210,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",2634
211,"else {vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",2635
212,"unix_state_double_unlock ( sk , other ) ;if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ;","unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;unix_state_double_unlock ( sk , other ) ;if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ;",2636
213,"void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) {bloc = * offset ;while ( node && node -> symbol == INTERNAL_NODE ) {if ( get_bit ( fin ) ) {","void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset , int maxoffset ) {bloc = * offset ;while ( node && node -> symbol == INTERNAL_NODE ) {if ( bloc >= maxoffset ) {* ch = 0 ;* offset = maxoffset + 1 ;return ;}if ( get_bit ( fin ) ) {",2637
214,if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,if ( ctx -> terminated || ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,2638
215,if ( enable_apicv ) {for ( msr = 0x800 ;,for ( msr = 0x800 ;,2639
216,}if ( enable_ept ) {,if ( enable_ept ) {,2639
217,"state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ;if ( ! state -> frame [ 0 ] ) {init_func_state ( env , state -> frame [ 0 ] , BPF_MAIN_FUNC , 0 , 0 ) ;for ( ;;) {struct bpf_insn * insn ;u8 class ;int err ;if ( env -> insn_idx >= insn_cnt ) {verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\\verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\\return - E2BIG ;}err = is_state_visited ( env , env -> insn_idx ) ;if ( do_print_state )  verbose ( env , ""\\\else verbose ( env , ""%d:<S2SV_blank>safe\\\","state -> speculative = false ;state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ;if ( ! state -> frame [ 0 ] ) {init_func_state ( env , ""\\\verbose ( env , ""\\\if ( do_print_state ) verbose ( env , ""\\\else verbose ( env , ""%d:<S2SV_blank>safe\\\",2640
218,"else  verbose ( env , ""\\\print_verifier_state ( env , state -> frame [ state -> curframe ] ) ;","else verbose ( env , ""\\\print_verifier_state ( env , state -> frame [ state -> curframe ] ) ;",2640
219,"if ( in ) {dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;dev -> out_pipe = usb_sndbulkpipe ( udev ,  out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;}if ( iso_in ) {","if ( in ) dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;if ( iso_in ) {",2641
220,if ( flags & MSG_OOB )  goto out ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,if ( flags & MSG_OOB ) goto out ;,2642
221,"}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;","* addr_len = sizeof ( * sin ) ;}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;",2642
222,case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE |  VM_SHARED | VM_MAYSHARE |  VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ;case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE |  VM_SHARED | VM_MAYSHARE |  VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ;,case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE | VM_NO_THP ) ) return - EINVAL ;case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE | VM_NO_THP ) ) return - EINVAL ;,2643
223,"
",mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;,2644
224,ops -> destroy ( dev ) ;mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;,ops -> destroy ( dev ) ;,2644
225,"if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) )  return FALSE ;","flatpak_bwrap_envp_to_args ( bwrap ) ;if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) ) return FALSE ;",2645
226,"if ( ! g_spawn_async ( NULL ,  ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return FALSE ;","g_assert ( bwrap -> envp != NULL ) ;g_assert ( bwrap -> envp [ 0 ] == NULL ) ;if ( ! g_spawn_async ( NULL , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return FALSE ;",2645
227,"if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 )  {","g_assert ( bwrap -> envp != NULL ) ;g_assert ( bwrap -> envp [ 0 ] == NULL ) ;if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 ) {",2645
228,"record_and_restart ( event , val , regs , nmi ) ;}","record_and_restart ( event , val , regs ) ;}",2646
229,"static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {","static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2647
230,if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;pc -> buffer = new_buffer ;,if ( ! new_buffer ) {pc -> index = 0 ;return AVERROR ( ENOMEM ) ;}pc -> buffer = new_buffer ;,2648
231,if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;pc -> buffer = new_buffer ;,if ( ! new_buffer ) {pc -> overread_index = pc -> index = 0 ;return AVERROR ( ENOMEM ) ;}pc -> buffer = new_buffer ;,2648
232,"struct fsnotify_group * group ;struct user_struct * user ;user = get_current_user ( ) ;if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) {ret = - EMFILE ;}group = inotify_new_group ( user , inotify_max_queued_events ) ;if ( IS_ERR ( group ) ) {ret = PTR_ERR ( group ) ;goto out_free_uid ;if ( ret >= 0 )  return ret ;fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;","struct fsnotify_group * group ;group = inotify_new_group ( user , inotify_max_queued_events ) ;if ( IS_ERR ( group ) ) {ret = PTR_ERR ( group ) ;if ( ret < 0 ) fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;",2649
233,"static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile ,  vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ,  int mi_row , int mi_col ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;MODE_INFO * m ;set_mi_row_col ( xd , tile ,  mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ;write_mb_modes_kf ( cpi , xd -> mi , w ) ;}pack_mb_tokens ( w , tok , tok_end ) ;}","static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile , vpx_writer * w , TOKENEXTRA * * tok , const TOKENEXTRA * const tok_end , int mi_row , int mi_col ) {const VP9_COMMON * const cm = & cpi -> td . common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;MODE_INFO * m ;cpi -> td . mb . mbmi_ext = cpi -> td . mb . mbmi_ext_base + ( mi_row * cm -> mi_cols + mi_col ) ;set_mi_row_col ( xd , tile , mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ;write_mb_modes_kf ( cm , xd , xd -> mi , w ) ;}pack_mb_tokens ( w , tok , tok_end , cm -> bit_depth ) ;}",2650
234,"mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\\if ( table -> total == table -> max ) {","if ( free < 0 ) {err = - ENOMEM ;goto out ;}mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\\if ( table -> total == table -> max ) {",2651
235,aof_fsync ( server . appendfd ) ;if ( server . vm_enabled ) unlink ( server . vm_swap_file ) ;,aof_fsync ( server . appendfd ) ;,2652
236,ACCESS_MASK access = FILE_READ_ATTRIBUTES ;,"size_t devicePathLen = 0 ;if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\\\\\Device\\\\\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) {byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ;if ( ! readBuffer ) {Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ;Irp -> IoStatus . Information = 0 ;}else {Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;break ;}",2653
237,"
",if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) {,2653
238,"
",Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;}TCfree ( readBuffer ) ;}}else {,2653
239,"byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) )  {","byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , sizeof ( readBuffer ) , & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) ) {",2653
240,Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;},Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;},2653
241,fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {,fh16 [ 3 ] = 0 ;fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {,2654
242,int err ;if ( rt ) return 0 ;daddr = inet -> inet_daddr ;if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ;,struct ip_options_rcu * inet_opt ;int err ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;rcu_read_unlock ( ) ;,2655
243,"static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type ,  u32 * mask ) {if ( IS_ERR ( algt ) )  return ;if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) )  * type |= CRYPTO_ALG_INTERNAL ;if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) )  * mask |= CRYPTO_ALG_INTERNAL ;","static inline bool mcryptd_check_internal ( struct rtattr * * tb , u32 * type , u32 * mask ) {if ( IS_ERR ( algt ) ) return false ;* type |= algt -> type & CRYPTO_ALG_INTERNAL ;* mask |= algt -> mask & CRYPTO_ALG_INTERNAL ;if ( * type & * mask & CRYPTO_ALG_INTERNAL ) return true ;else return false ;",2656
244,"priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;","if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) {dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\\return - ENODEV ;}priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;",2657
245,"int yy , mm , dd , hr , min , sec , csec ;guint pkt_len ;if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) {num_items_scanned = sscanf ( line ,  ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;","int yy , mm , dd , hr , min , sec , csec , pkt_len ;if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) {num_items_scanned = sscanf ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;",2658
246,"num_items_scanned = sscanf ( line ,  ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;yy = mm = dd = hr = min = sec = csec = 0 ;}","num_items_scanned = sscanf ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;yy = mm = dd = hr = min = sec = csec = 0 ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;}",2658
247,ND_TCHECK ( dp -> ip6f_offlg ) ;if ( ndo -> ndo_vflag ) {,ND_TCHECK ( * dp ) ;if ( ndo -> ndo_vflag ) {,2659
248,"ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" ,  ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , ""none"" , * p & 0xc0 ) , length ) ) ;","if ( length < 2 ) {ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ;return ;}if ( ! ND_TTEST_16BITS ( p ) ) {ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ;return ;}ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , ""none"" , * p & 0xc0 ) , length ) ) ;",2660
249,"return vp8_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ;}","return vpx_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ;}",2661
250,"if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ;__TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ;if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ;th = ( const struct tcphdr * ) skb -> data ;if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ;if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ;if ( skb_checksum_init ( skb , IPPROTO_TCP , ip6_compute_pseudo ) ) goto csum_error ;th = ( const struct tcphdr * ) skb -> data ;hdr = ipv6_hdr ( skb ) ;lookup : sk = __inet6_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , inet6_iif ( skb ) , & refcounted ) ;if ( ! sk ) goto no_tcp_socket ;process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ;if ( sk -> sk_state == TCP_NEW_SYN_RECV ) {struct request_sock * req = inet_reqsk ( sk ) ;struct sock * nsk ;sk = req -> rsk_listener ;tcp_v6_fill_cb ( skb , hdr , th ) ;if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) {","if ( tcp_filter ( sk , skb ) ) {",2662
251,"if ( sk_filter ( sk , skb ) )   goto discard_and_relse ;skb -> dev = NULL ;","th = ( const struct tcphdr * ) skb -> data ;hdr = ipv6_hdr ( skb ) ;if ( sk_filter ( sk , skb ) ) goto discard_and_relse ;skb -> dev = NULL ;",2662
252,if ( keyring ) {,if ( keyring && link_ret == 0 ) {,2663
253,"if ( keyring )  __key_link_end ( keyring , & key -> index_key , edit ) ;","if ( keyring ) __key_link_end ( keyring , & key -> index_key , edit ) ;",2663
254,"av_cold void ff_mpv_idct_init ( MpegEncContext * s )  {ff_idctdsp_init ( & s -> idsp , s -> avctx ) ;","av_cold void ff_mpv_idct_init ( MpegEncContext * s ) {if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;ff_idctdsp_init ( & s -> idsp , s -> avctx ) ;",2664
255,numSamples = pWTIntFrame -> numSamples ;pOutputBuffer = pWTIntFrame -> pAudioBuffer ;,"numSamples = pWTIntFrame -> numSamples ;if ( numSamples <= 0 ) {ALOGE ( ""b/26366256"" ) ;return ;}pOutputBuffer = pWTIntFrame -> pAudioBuffer ;",2665
256,"split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?  EXT4_EXT_MAY_ZEROOUT : 0 ;err = ext4_split_extent_at ( handle , inode , path ,  map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ;split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?  EXT4_EXT_MAY_ZEROOUT : 0 ;","split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ;if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ;err = ext4_split_extent_at ( handle , inode , path , map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ;split_flag1 = split_flag & ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) ;",2666
257,user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user ) return ERR_PTR ( - ENOMEM ) ;,if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ;user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user ) return ERR_PTR ( - ENOMEM ) ;,2667
258,"BIO * cmsbio = NULL , * tmpin = NULL ;if ( ! dcont && ! check_content ( cms ) ) return 0 ;","BIO * cmsbio = NULL , * tmpin = NULL , * tmpout = NULL ;if ( ! dcont && ! check_content ( cms ) ) return 0 ;",2668
259,"cmsbio = CMS_dataInit ( cms , tmpin ) ;if ( ! cmsbio ) goto err ;if ( ! cms_copy_content ( out , cmsbio , flags ) )  goto err ;if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) {","if ( ! ( flags & SMIME_BINARY ) && dcont ) {tmpout = cms_get_text_bio ( out , flags ) ;if ( ! tmpout ) {CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ;goto err ;}cmsbio = CMS_dataInit ( cms , tmpout ) ;if ( ! cmsbio ) goto err ;}SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ;if ( flags & CMS_TEXT ) {if ( ! SMIME_text ( tmpout , out ) ) {CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ;goto err ;}}}else {cmsbio = CMS_dataInit ( cms , tmpin ) ;if ( ! cmsbio ) goto err ;if ( ! cms_copy_content ( out , cmsbio , flags ) ) goto err ;if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) {",2668
260,"err :  if ( dcont && ( tmpin == dcont ) )  do_free_upto ( cmsbio , dcont ) ;if ( cms_certs )  sk_X509_pop_free ( cms_certs , X509_free ) ;","err : if ( ! ( flags & SMIME_BINARY ) && dcont ) {do_free_upto ( cmsbio , tmpout ) ;if ( tmpin != dcont ) BIO_free ( tmpin ) ;}else {if ( dcont && ( tmpin == dcont ) ) do_free_upto ( cmsbio , dcont ) ;}if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ;if ( cms_certs ) sk_X509_pop_free ( cms_certs , X509_free ) ;",2668
261,"__ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;","memset ( & t , 0 , sizeof ( t ) ) ;__ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;",2669
262,"if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h )   ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;}return res ;","int force_key = 0 ;if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) {if ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( ! valid_ref_frame_size ( ctx -> cfg . g_w , ctx -> cfg . g_h , cfg -> g_w , cfg -> g_h ) || ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) force_key = 1 ;}if ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;force_key |= ctx -> cpi -> common . profile != ctx -> oxcf . profile ;vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;}if ( force_key ) ctx -> next_frame_flags |= VPX_EFLAG_FORCE_KF ;return res ;",2670
263,"fp -> protocol = altsd -> bInterfaceProtocol ;if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ;","if ( altsd -> bNumEndpoints < 1 ) {kfree ( fp ) ;kfree ( rate_table ) ;return - EINVAL ;}fp -> protocol = altsd -> bInterfaceProtocol ;if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ;",2671
264,if ( pkt == NULL )  continue ;,"
",2672
265,int err = - EINVAL ;if ( ! kcontrol ) return err ;,unsigned int count ;int err = - EINVAL ;if ( ! kcontrol ) return err ;,2673
266,"up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < kcontrol -> count ;idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;","count = kcontrol -> count ;up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < count ;idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;",2673
267,while ( c ) {++ i ;c = c -> next ;}return i ;,"+ i ;while ( c ) i ++ , c = c -> next ;}return i ;",2674
268,time_t then ;then = 0 ;,time_t then ;if ( strlen ( stamp ) != 2 ) return SRS_ETIMESTAMPOUTOFDATE ;then = 0 ;,2675
269,"xmlNode *   crm_recv_remote_msg ( void * session , gboolean encrypted )  {char * reply = NULL ;xmlNode * xml = NULL ;if ( encrypted ) {# ifdef HAVE_GNUTLS_GNUTLS_H reply = cib_recv_tls ( session ) ;# else CRM_ASSERT ( encrypted == FALSE ) ;# endif }reply = cib_recv_plaintext ( GPOINTER_TO_INT ( session ) ) ;if ( reply == NULL || strlen ( reply ) == 0 ) {crm_trace ( ""Empty<S2SV_blank>reply"" ) ;xml = string2xml ( reply ) ;if ( xml == NULL ) {crm_err ( ""Couldn\\\'t<S2SV_blank>parse:<S2SV_blank>\\\'%.120s\\\'"" , reply ) ;free ( reply ) ;return xml ;","gboolean crm_recv_remote_msg ( void * session , char * * recv_buf , gboolean encrypted , int total_timeout , int * disconnected ) {int ret ;size_t request_len = 0 ;time_t start = time ( NULL ) ;char * raw_request = NULL ;int remaining_timeout = 0 ;if ( ret == 0 ) {crm_err ( ""poll<S2SV_blank>timed<S2SV_blank>out<S2SV_blank>(%d<S2SV_blank>ms)<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>msg"" , remaining_timeout ) ;return FALSE ;}else if ( ret < 0 ) {if ( errno != EINTR ) {crm_debug ( ""poll<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>msg,<S2SV_blank>rc:<S2SV_blank>%d,<S2SV_blank>errno:<S2SV_blank>%d"" , ret , errno ) ;* disconnected = 1 ;return FALSE ;}crm_debug ( ""poll<S2SV_blank>EINTR<S2SV_blank>encountered<S2SV_blank>during<S2SV_blank>poll,<S2SV_blank>retrying"" ) ;}raw_request = crm_recv_remote_raw ( session , encrypted , 0 , & request_len , disconnected ) ;remaining_timeout = remaining_timeout - ( ( time ( NULL ) - start ) * 1000 ) ;if ( ! raw_request ) {crm_debug ( ""Empty<S2SV_blank>msg<S2SV_blank>received<S2SV_blank>after<S2SV_blank>poll"" ) ;continue ;}if ( * recv_buf ) {int old_len = strlen ( * recv_buf ) ;crm_trace ( ""Expanding<S2SV_blank>recv<S2SV_blank>buffer<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d"" , old_len , old_len + request_len ) ;* recv_buf = realloc ( * recv_buf , old_len + request_len + 1 ) ;memcpy ( * recv_buf + old_len , raw_request , request_len ) ;* ( * recv_buf + old_len + request_len ) = \'\\\\0\' ;free ( raw_request ) ;* recv_buf = raw_request ;}if ( strstr ( * recv_buf , REMOTE_MSG_TERMINATOR ) ) {return TRUE ;return FALSE ;",2676
270,"int r , len , group = 0 ;Node * qn ;Node * * tp ;* np = NULL ;if ( tok -> type == ( enum TokenSyms ) term )  goto end_of_token ;switch ( tok -> type ) {","int r , len , group ;Node * qn ;Node * * tp ;unsigned int parse_depth ;group = 0 ;* np = NULL ;if ( tok -> type == ( enum TokenSyms ) term ) goto end_of_token ;parse_depth = env -> parse_depth ;switch ( tok -> type ) {",2677
271,"qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper ,  r == TK_INTERVAL ) ;","parse_depth ++ ;if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , r == TK_INTERVAL ) ;",2677
272,"if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ;return ;}if ( ! ndo -> ndo_eflag ) {ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ;}if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || PROTO_LEN ( ap ) != 4 || HRD_LEN ( ap ) == 0 || ndo -> ndo_vflag ) {ND_PRINT ( ( ndo , ""%s<S2SV_blank>(len<S2SV_blank>%u),<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , HRD_LEN ( ap ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , PROTO_LEN ( ap ) ) ) ;case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ;break ;case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" ,  ipaddr_string ( ndo , SPA ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" ,   linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_INVREPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" ,   linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , SPA ( ap ) ) ) ) ;","if ( ! ND_TTEST2 ( * TPA ( ap ) , PROTO_LEN ( ap ) ) ) {ND_PRINT ( ( ndo , ""who-has<S2SV_blank>"" ) ) ;tpaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;spaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REPLY : spaddr_print_ip ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>%s"" , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;tpaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REVREPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , linkaddr_string ( ndo , ""%s<S2SV_blank>at<S2SV_blank>"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_INVREPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;spaddr_print_ip ( ndo , ap , pro ) ;",2678
273,"
","if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",2679
274,break ;},break ;},2679
275,if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal )  return 0 ;,if ( ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS ) ) return 0 ;,2680
276,"char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;",2681
277,"if ( ! proc_parse_options ( options , ns ) ) {deactivate_locked_super ( sb ) ;","sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ;if ( ! proc_parse_options ( options , ns ) ) {deactivate_locked_super ( sb ) ;",2682
278,"if ( ! ssl_cipher_get_evp ( s -> session , & c , & hash , & mac_type , & mac_secret_size , & comp ,  SSL_USE_ETM ( s ) ) ) {SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ;","if ( ! ssl_cipher_get_evp ( s -> session , & c , & hash , & mac_type , & mac_secret_size , & comp , s -> tlsext_use_etm ) ) {SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ;",2683
279,"ulonglong tmp ;if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ;",2684
280,"skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;if ( ! skb ) {msg -> msg_namelen = 0 ;copied = skb -> len ;","msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;if ( ! skb ) {copied = skb -> len ;",2685
281,"static bool tailmatch ( const char * little , const char * bigone )  {size_t littlelen = strlen ( little ) ;size_t biglen = strlen ( bigone ) ;if ( littlelen > biglen )  return FALSE ;return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ;}","static bool tailmatch ( const char * cooke_domain , const char * bigone ) {size_t cookie_domain_len = strlen ( little ) ;size_t hostname_len = strlen ( bigone ) ;if ( hostname_len < cookie_domain_len ) return FALSE ;return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ;}",2686
282,},seg -> update_map = 0 ;seg -> update_data = 0 ;},2687
283,for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;,if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ;for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;,2688
284,if ( unix_sock_count ) {for ( i = scm -> fp -> count - 1 ;}return max_level ;,for ( i = scm -> fp -> count - 1 ;return max_level ;,2688
285,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},2689
286,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,2689
287,}return TRUE ;,source -> id = 0 ;}return TRUE ;,2690
288,"if ( user -> uid_keyring ) {kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ;","if ( user -> uid_keyring && user -> session_keyring ) {kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ;",2691
289,"for ( i = 0 ;mechbuf [ i ] ;host = xhash_get ( c2s -> hosts , s -> req_to ) ;","for ( i = 0 ;mechbuf [ i ] ) ;log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)"" , mechbuf ;host = xhash_get ( c2s -> hosts , s -> req_to ) ;",2692
290,"static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop )  {","static void __evtchn_fifo_handle_events ( unsigned cpu , struct evtchn_loop_ctrl * ctrl ) {",2693
291,"consume_one_event ( cpu , control_block , q , & ready , drop ) ;ready |= xchg ( & control_block -> ready , 0 ) ;","consume_one_event ( cpu , ctrl , control_block , q , & ready ) ;ready |= xchg ( & control_block -> ready , 0 ) ;",2693
292,"# endif # endif # if defined ( HAVE_GETSPNAM ) && ! defined ( M_UNIX )  if ( spwd && spwd -> sp_expire > 0 &&   ( request -> timestamp / 86400 ) > spwd -> sp_expire ) {radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ;return RLM_MODULE_REJECT ;","# endif # endif # if defined ( HAVE_GETSPNAM ) && ! defined ( M_UNIX ) if ( spwd && spwd -> sp_lstchg > 0 && spwd -> sp_max >= 0 && ( request -> timestamp / 86400 ) > ( spwd -> sp_lstchg + spwd -> sp_max ) ) {radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>account<S2SV_blank>has<S2SV_blank>expired"" , name ) ;return RLM_MODULE_REJECT ;}if ( spwd && spwd -> sp_expire > 0 && ( request -> timestamp / 86400 ) > spwd -> sp_expire ) {radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ;return RLM_MODULE_REJECT ;",2694
293,dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;,2695
294,"case \'l\' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ;case \'L\' : {","case \'l\' : {RBinObject * obj = r_bin_cur_object ( core -> bin ) ;RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ;}case \'L\' : {",2696
295,"case \'i\' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ;case \'I\' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ;","case \'i\' : {RBinObject * obj = r_bin_cur_object ( core -> bin ) ;RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ;}case \'I\' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ;",2696
296,"uint8_t i ;if ( tlv_len < 4 ) {ND_PRINT ( ( ndo , ""\\\switch ( subtype ) {case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID : if ( tlv_len < 7 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_len < 7 ) {return hexdump ;}sublen = * ( tptr + 6 ) ;if ( tlv_len < 7 + sublen ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\safeputs ( ndo , tptr + 7 , sublen ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY : if ( tlv_len < 5 ) {return hexdump ;}sublen = * ( tptr + 4 ) ;if ( tlv_len < 5 + sublen ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\safeputs ( ndo , tptr + 5 , sublen ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH ) {return hexdump ;}tval = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\for ( i = 0 ;i < NO_OF_BITS ;i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ;tval = * ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\for ( i = 0 ;i < NO_OF_BITS ;i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH ) {return hexdump ;}tval = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\","u_int i ;if ( tlv_len < 4 ) {ND_PRINT ( ( ndo , ""\\\",2697
297,"ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ;","ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ;",2697
298,"futex_wait_queue_me ( hb , & q , to ) ;spin_lock ( & hb -> lock ) ;","if ( match_futex ( & q . key , & key2 ) ) {ret = - EINVAL ;goto out_put_keys ;}futex_wait_queue_me ( hb , & q , to ) ;spin_lock ( & hb -> lock ) ;",2698
299,"if ( ( e -> target_offset == sizeof ( struct ipt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> ip ) ) ||  visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",2699
300,"struct {struct ip_options opt ;char data [ 40 ] ;}replyopts ;if ( ip_options_echo ( & replyopts . opt , skb ) )  return ;daddr = ipc . addr = rt -> rt_src ;ipc . opt = NULL ;ipc . tx_flags = 0 ;if ( replyopts . opt . optlen ) {ipc . opt = & replyopts . opt ;if ( ipc . opt -> srr )   daddr = replyopts . opt . faddr ;}",struct ip_options_data replyopts ;if ( replyopts . opt . opt . srr ) daddr = replyopts . opt . opt . faddr ;},2700
301,struct svc_rqst * rqstp = vrqstp ;set_freezable ( ) ;,"struct svc_rqst * rqstp = vrqstp ;struct net * net = & init_net ;struct lockd_net * ln = net_generic ( net , lockd_net_id ) ;set_freezable ( ) ;cancel_delayed_work_sync ( & ln -> grace_period_end ) ;locks_end_grace ( & ln -> lockd_manager ) ;",2701
302,return 0 ;},return 0 ;},2701
303,"cp = ikev1_attrmap_print ( ndo , cp ,  ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;}","cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ;if ( cp == NULL ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}",2702
304,"case 16 :  # line 94 ""hex_grammar.y""  {# line 1023 ""hex_grammar.c"" break ;case 17 :  # line 95 ""hex_grammar.y""  {# line 1029 ""hex_grammar.c"" break ;case 18 :  # line 96 ""hex_grammar.y""  {# line 1035 ""hex_grammar.c"" break ;case 19 :  # line 97 ""hex_grammar.y""  {# line 1041 ""hex_grammar.c"" break ;case 21 :  # line 100 ""hex_grammar.y""  {# line 1047 ""hex_grammar.c"" break ;case 22 :  # line 99 ""hex_grammar.y""  {# line 1053 ""hex_grammar.c"" break ;case 23 :  # line 98 ""hex_grammar.y""  {# line 1059 ""hex_grammar.c"" break ;","case 16 : # line 101 ""hex_grammar.y"" {# line 1030 ""hex_grammar.c"" break ;case 17 : # line 102 ""hex_grammar.y"" {# line 1036 ""hex_grammar.c"" break ;case 18 : # line 103 ""hex_grammar.y"" {# line 1042 ""hex_grammar.c"" break ;case 19 : # line 104 ""hex_grammar.y"" {# line 1048 ""hex_grammar.c"" break ;case 21 : # line 107 ""hex_grammar.y"" {# line 1054 ""hex_grammar.c"" break ;case 22 : # line 106 ""hex_grammar.y"" {# line 1060 ""hex_grammar.c"" break ;case 23 : # line 105 ""hex_grammar.y"" {# line 1066 ""hex_grammar.c"" break ;",2703
305,pch -> chan_net = net ;chan -> ppp = pch ;,pch -> chan_net = get_net ( net ) ;chan -> ppp = pch ;,2704
306,image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;image -> rows = ( size_t ) floor floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,2705
307,width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,width = ( size_t ) floor floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;height = ( size_t ) floor floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,2705
308,width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;,width = ( size_t ) floor floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;,2705
309,"if ( image -> columns == 0 )  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;if ( image -> columns == 0 )  image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 )  image -> rows = ( size_t ) ( metrics . ascent - metrics . descent +  draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 )  image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;","if ( image -> columns == 0 ) image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;if ( image -> columns == 0 ) image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 ) image -> rows = ( size_t ) ( metrics . ascent - metrics . descent + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 ) image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;",2705
310,"
",if ( saio -> offsets && saio -> entry_count ) {,2706
311,"
",saio = NULL ;},2706
312,"
",saiz = NULL ;,2706
313,"offset = saio -> offsets [ 0 ] + moof_offset ;nb_saio = saio -> entry_count ;for ( i = 0 ;saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ;}}","offset = saio -> offsets [ 0 ] + moof_offset ;nb_saio = saio -> entry_count ;for ( i = 0 ;saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ;}}",2706
314,int target = rc -> av_per_frame_bandwidth ;if ( ( cm -> current_video_frame == 0 ) ||  ( cm -> frame_flags & FRAMEFLAGS_KEY ) ||  ( cpi -> oxcf . auto_key && ( rc -> frames_since_key %  cpi -> key_frame_frequency == 0 ) ) ) {cm -> frame_type = KEY_FRAME ;if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) {target = calc_iframe_target_size_one_pass_cbr ( cpi ) ;if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) {,"int target = rc -> avg_frame_bandwidth ;const int layer = LAYER_IDS_TO_IDX ( cpi -> svc . spatial_layer_id , cpi -> svc . temporal_layer_id , cpi -> svc . number_temporal_layers ) ;if ( ( cm -> current_video_frame == 0 ) || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) || ( cpi -> oxcf . auto_key && ( rc -> frames_since_key % cpi -> oxcf . key_freq == 0 ) ) ) {cm -> frame_type = KEY_FRAME ;if ( is_two_pass_svc ( cpi ) ) {cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ;cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ;}else if ( is_one_pass_cbr_svc ( cpi ) ) {cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ;reset_temporal_layer_to_zero ( cpi ) ;cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ;target = calc_iframe_target_size_one_pass_cbr ( cpi ) ;if ( is_two_pass_svc ( cpi ) ) {LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ;if ( cpi -> svc . spatial_layer_id == 0 ) {lc -> is_key_frame = 0 ;}else {lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ;if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ;}cpi -> ref_frame_flags &= ( ~ VP9_ALT_FLAG ) ;}else if ( is_one_pass_cbr_svc ( cpi ) ) {LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ;if ( cpi -> svc . spatial_layer_id == 0 ) {lc -> is_key_frame = 0 ;}else {lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ;}if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ;",2707
315,"if ( used_address && used_address -> name_len == msg_sys -> msg_namelen &&   ! memcmp ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ) {memcpy ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ;","if ( used_address && msg_sys -> msg_name && used_address -> name_len == msg_sys -> msg_namelen && ! memcmp ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) ) {if ( msg_sys -> msg_name ) memcpy ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) ;",2708
316,"static void read_mv_probs ( nmv_context * ctx , int allow_hp , vp9_reader * r ) {int i , j ;","static void read_mv_probs ( nmv_context * ctx , int allow_hp , vpx_reader * r ) {int i , j ;",2709
317,"commonlen = COMPUTESIZE ( state . num , state . sumlen ) ;query = ( ltxtquery * ) palloc ( commonlen ) ;","if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;commonlen = COMPUTESIZE ( state . num , state . sumlen ) ;query = ( ltxtquery * ) palloc ( commonlen ) ;",2710
318,"send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ;}","TEMP_FAILURE_RETRY ( send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ;}",2711
319,case 'n' : * ( buf + insertpos ) = '\\\editpos ++ ;break ;case 't' : * ( buf + insertpos ) = '\\\\t' ;editpos ++ ;break ;case 'r' : * ( buf + insertpos ) = '\\\\r' ;editpos ++ ;break ;case '<S2SV_blank>' : * ( buf + insertpos ) = '<S2SV_blank>' ;editpos ++ ;break ;case '0' : if ( * ( buf + editpos + 2 ) == 'x' ) {if ( ( * ( buf + editpos + 3 ) == '0' && * ( buf + editpos + 4 ) == '0' ) ) {* ( buf + insertpos ) = * ( buf + editpos ) ;}else {* ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ;editpos += 4 ;,case 'n' : * ( buf + insertpos ) = _x2c ( & buf [ editpos + 3 ] ) ;editpos += 4 ;,2712
320,switch ( sun_info . maptype )  {case RMT_EQUAL_RGB : {,switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {,2713
321,"static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row ,  int mi_col , BLOCK_SIZE bsize , int * rate ,   int64_t * dist , int do_recon , int64_t best_rd ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;int i ;BLOCK_SIZE subsize ;int this_rate , sum_rate = 0 , best_rate = INT_MAX ;","static void nonrd_pick_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , RD_COST * rd_cost , int do_recon , int64_t best_rd ) {VP9_COMMON * const cm = & cpi -> common ;TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = & pc_tree -> none ;int i ;BLOCK_SIZE subsize ;int this_rate , sum_rate = 0 , best_rate = INT_MAX ;",2714
322,"if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index != 0 ) {* rate = 0 ;* dist = 0 ;return ;}}x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;if ( cpi -> sf . auto_min_max_partition_size ) {partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size &&   bsize >= cpi -> sf . min_partition_size ) ;partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_horz_split ) ;partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_vert_split ) ;do_split &= bsize > cpi -> sf . min_partition_size ;}if ( cpi -> sf . use_square_partition_only ) {if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) )  do_split = 0 ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col ,   & this_rate , & this_dist , bsize ) ;ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate != INT_MAX ) {int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;if ( sum_rd < best_rd ) {int64_t stop_thresh = 4096 ;int64_t stop_thresh_rd ;best_rate = this_rate ;best_dist = this_dist ;best_rd = sum_rd ;if ( bsize >= BLOCK_8X8 ) * ( get_sb_partitioning ( x , bsize ) ) = bsize ;stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) {do_split = 0 ;}if ( ! x -> in_active_map ) {do_split = 0 ;do_rect = 0 ;sum_rd = 0 ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;for ( i = 0 ;const int x_idx = ( i & 1 ) * ms ;* get_sb_index ( x , subsize ) = i ;load_pred_mv ( x , ctx ) ;nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx ,   subsize , & this_rate , & this_dist , 0 ,  best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;","x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;if ( cpi -> sf . auto_min_max_partition_size ) {partition_none_allowed &= ( bsize <= x -> max_partition_size && bsize >= cpi -> sf . min_partition_size ) ;partition_horz_allowed &= ( ( bsize <= x -> max_partition_size && bsize > cpi -> sf . min_partition_size ) || force_horz_split ) ;partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && bsize > x -> min_partition_size ) || force_vert_split ) ;do_split &= bsize > x -> min_partition_size ;}if ( sf -> use_square_partition_only ) {ctx -> pred_pixel_ready = ! ( partition_vert_allowed || partition_horz_allowed || do_split ) ;nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx ) ;ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;ctx -> mbmi_ext = * x -> mbmi_ext ;ctx -> skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;ctx -> skip = x -> skip ;if ( this_rdc . rate != INT_MAX ) {int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_NONE ] ;this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ;if ( this_rdc . rdcost < best_rdc . rdcost ) {int64_t dist_breakout_thr = sf -> partition_search_breakout_dist_thr ;int64_t rate_breakout_thr = sf -> partition_search_breakout_rate_thr ;dist_breakout_thr >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;if ( ! x -> e_mbd . lossless && this_rdc . rate < rate_breakout_thr && this_rdc . dist < dist_breakout_thr ) {do_split = 0 ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;for ( i = 0 ;const int x_idx = ( i & 1 ) * ms ;* get_sb_index ( x , subsize ) = i ;load_pred_mv ( x , ctx ) ;nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , & this_rate , & this_dist , 0 , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;",2714
323,"if ( cpi -> sf . less_rectangular_check )  do_rect &= ! partition_none_allowed ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col ,   & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ;sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}","if ( cpi -> sf . less_rectangular_check ) do_rect &= ! partition_none_allowed ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col , & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ;sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}",2714
324,"* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd && mi_col + ms < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms ,   & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}else {int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ;sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}}if ( sum_rd < best_rd ) {best_rate = sum_rate ;best_dist = sum_dist ;best_rd = sum_rd ;* ( get_sb_partitioning ( x , bsize ) ) = subsize ;* rate = best_rate ;* dist = best_dist ;if ( best_rate == INT_MAX )  return ;fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize ,  * ( get_sb_partitioning ( x , bsize ) ) ) ;if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) {int output_enabled = ( bsize == BLOCK_64X64 ) ;if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled ,  best_rate ) ;}if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ;encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ;}if ( bsize == BLOCK_64X64 ) {assert ( tp_orig < * tp ) ;assert ( best_rate < INT_MAX ) ;assert ( best_dist < INT64_MAX ) ;}","* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , td , tile_data , tp , mi_row , mi_col , output_enabled , bsize ) ;if ( bsize == BLOCK_64X64 && do_recon ) {assert ( tp_orig < * tp ) ;assert ( best_rate < INT_MAX ) ;assert ( best_dist < INT64_MAX ) ;",2714
325,"static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , const char * ident , uint16_t afi ) {char ident_buffer [ 20 ] ;uint8_t prefix [ sizeof ( struct in6_addr ) ] ;u_int metric , status_byte , bit_length , byte_length , sublen , processed , subtlvtype , subtlvlen ;if ( ! ND_TTEST2 ( * tptr , 4 ) ) return ( 0 ) ;","static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , 2 ) ) return ( 0 ) ;",2715
326,"if ( ! ND_TTEST2 ( * tptr , 1 ) )  return ( 0 ) ;","if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ;",2715
327,"static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf )  {","static int scsi_disk_emulate_command ( SCSIDiskReq * r ) {uint8_t * outbuf ;if ( ! r -> iov . iov_base ) {if ( req -> cmd . xfer > 65536 ) {goto illegal_request ;}r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ;r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ;}outbuf = r -> iov . iov_base ;",2716
328,while ( FLASH -> SR & ( 1 << 16 ) ) ;flash_unlock ( ) ;if ( FLASH -> CR & ( 1 << 30 ) ) {FLASH -> OPTKEYR = 0x08192A3B ;FLASH -> OPTKEYR = 0x4C5D6E7F ;FLASH -> OPTR = val ;FLASH -> CR |= ( 1 << 17 ) ;while ( FLASH -> SR & ( 1 << 16 ) ) ;flash_lock ( ) ;__enable_irq ( ) ;},FLASH -> CR |= FLASH_CR_OBL_LAUNCH ;while ( true ) ;,2717
329,"size_t val_len ;size_t len , cert_len ;","size_t val_len = 0 ;size_t len , cert_len ;",2718
330,"pipe_buf_get ( ipipe , ibuf ) ;obuf = opipe -> bufs + nbuf ;","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}obuf = opipe -> bufs + nbuf ;",2719
331,addr -> sap_family = AF_ATMPVC ;addr -> sap_addr . itf = vcc -> dev -> number ;,"memset ( addr , 0 , sizeof ( * addr ) ) ;addr -> sap_family = AF_ATMPVC ;addr -> sap_addr . itf = vcc -> dev -> number ;",2720
332,"else  rsprintf ( ""Content-Type:<S2SV_blank>%s\\\\r\\\","else if ( strcmp ( filetype [ i ] . ext , "".SVG"" ) == 0 ) {rsprintf ( ""Content-Type:<S2SV_blank>%s\\\\r\\\if ( strrchr ( file_name , \'/\' ) ) strlcpy ( str , strrchr ( file_name , \'/\' ) + 1 , sizeof ( str ) ) ;else strlcpy ( str , file_name , sizeof ( str ) ) ;if ( str [ 6 ] == \'_\' && str [ 13 ] == \'_\' ) rsprintf ( ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\\\""%s\\\\""\\\\r\\\else rsprintf ( ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\\\""%s\\\\""\\\\r\\\}else rsprintf ( ""Content-Type:<S2SV_blank>%s\\\\r\\\",2721
333,return ret ;},"if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;return ret ;}",2722
334,"long elements ;elements = parse_iv2 ( ( * p ) + 2 , p ) ;( * p ) += 2 ;if ( ce -> serialize == NULL ) {object_init_ex ( * rval , ce ) ;else {zend_error ( E_WARNING , ""Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\\\'%s\\\'"" , ce -> name ) ;return 0 ;}","long elements ;if ( * p >= max - 2 ) {zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ;return - 1 ;",2723
335,token ++ ;},"token ++ ;}if ( operand >= MAX_OPERANDS ) {eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\\return false ;}",2724
336,void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec )  {,WORD32 impeg2d_dec_p_mb_params ( dec_state_t * ps_dec ) {,2725
337,ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ;ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},2725
338,},return 0 ;},2725
339,"int row8x8_remaining = tile -> mi_row_end - mi_row ;int col8x8_remaining = tile -> mi_col_end - mi_col ;int block_row , block_col ;","const int row8x8_remaining = tile -> mi_row_end - mi_row ;const int col8x8_remaining = tile -> mi_col_end - mi_col ;int block_row , block_col ;",2726
340,"for ( block_row = 0 ;block_row < MI_BLOCK_SIZE ;block_row += bh ) {for ( block_col = 0 ;block_col < MI_BLOCK_SIZE ;block_col += bw ) {int index = block_row * mis + block_col ;bsize = find_partition_size ( bsize , ( row8x8_remaining - block_row ) , ( col8x8_remaining - block_col ) , & bh , & bw ) ;mi_8x8 [ index ] = mi_upper_left + index ;mi_8x8 [ index ] -> mbmi . sb_type = bsize ;}}","set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , bsize , mi_8x8 ) ;",2726
341,if ( info . si_code >= 0 )   return - EPERM ;info . si_signo = sig ;,if ( info . si_code != SI_QUEUE ) {WARN_ON_ONCE ( info . si_code < 0 ) ;return - EPERM ;}info . si_signo = sig ;,2727
342,"if ( error == NULL ) {issuer_known = TRUE ;if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) {if ( ret != GNUTLS_E_SUCCESS ) inf_gnutls_set_error ( & error , ret ) ;else if ( verify & GNUTLS_CERT_INVALID )  inf_gnutls_certificate_verification_set_error ( & error , verify ) ;}}",}if ( error == NULL ) if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) {},2728
343,"return ! inode_capable ( inode , CAP_FOWNER ) ;}","return ! capable_wrt_inode_uidgid ( inode , CAP_FOWNER ) ;}",2729
344,"if ( ( opt_len != mp_dss_len ( mdss , 1 ) &&  opt_len != mp_dss_len ( mdss , 0 ) ) || flags & TH_SYN ) return 0 ;if ( mdss -> flags & MP_DSS_A ) {ND_PRINT ( ( ndo , ""<S2SV_blank>ack<S2SV_blank>"" ) ) ;if ( mdss -> flags & MP_DSS_a ) {ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}}if ( mdss -> flags & MP_DSS_m ) {ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}ND_PRINT ( ( ndo , ""<S2SV_blank>subseq<S2SV_blank>%u"" , EXTRACT_32BITS ( opt ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ;opt += 2 ;if ( opt_len == mp_dss_len ( mdss , 1 ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ;","if ( opt_len < 4 ) return 0 ;if ( flags & TH_SYN ) return 0 ;opt_len -= 4 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""<S2SV_blank>ack<S2SV_blank>"" ) ) ;if ( mdss -> flags & MP_DSS_a ) {if ( opt_len < 8 ) return 0 ;ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;opt_len -= 8 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;opt_len -= 4 ;if ( opt_len < 2 ) return 0 ;opt_len -= 4 ;}}if ( mdss -> flags & MP_DSS_m ) {if ( opt_len < 8 ) return 0 ;ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;opt_len -= 8 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}ND_PRINT ( ( ndo , ""<S2SV_blank>subseq<S2SV_blank>%u"" , EXTRACT_32BITS ( opt ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ;opt += 2 ;opt_len -= 2 ;if ( opt_len >= 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ;opt_len -= 2 ;}if ( opt_len != 0 ) return 0 ;",2730
345,"fprintf ( fpfile , ""%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.4f""  ""%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f"" ""%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f\\\","fprintf ( fpfile , ""%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf"" ""%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf"" ""%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf\\\",2731
346,int_fb -> in_use = 0 ;return 0 ;,if ( int_fb ) int_fb -> in_use = 0 ;return 0 ;,2732
347,inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;,"uint16 bps = 0 ;( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ;if ( bps != 8 ) {TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpSeparate2ContigByRow"" ) ;return 0 ;}inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;",2733
348,if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) {sctp_chunk_free ( chunk ) ;chunk = queue -> in_progress = NULL ;},"
",2734
349,"chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ;if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ;}skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ;chunk -> subh . v = NULL ;if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) {chunk -> singleton = 0 ;}else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) {sctp_chunk_free ( chunk ) ;chunk = queue -> in_progress = NULL ;return NULL ;",chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ;chunk -> pdiscard = 1 ;chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ;,2734
350,err = - EINVAL ;ds = salg -> digestsize ;ss = salg -> statesize ;alg = & salg -> base ;,alg = & salg -> base ;err = - EINVAL ;if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ;ds = salg -> digestsize ;ss = salg -> statesize ;,2735
351,"static void  swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horAcc32 ( tif , cp0 , cc ) ;}","static int swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {return horAcc32 ( tif , cp0 , cc ) ;}",2736
352,if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) {r = - EINVAL ;,if ( ! kvm_vcpu_compatible ( vcpu ) ) {r = - EINVAL ;goto unlock_vcpu_destroy ;}if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) {r = - EINVAL ;,2737
353,struct cred * cred ;if ( ! ( unshare_flags & CLONE_NEWUSER ) ) return 0 ;cred = prepare_creds ( ) ;if ( ! cred )  return - ENOMEM ;* new_cred = cred ;return create_user_ns ( cred ) ;},struct cred * cred ;int err = - ENOMEM ;if ( cred ) {err = create_user_ns ( cred ) ;if ( err ) put_cred ( cred ) ;else * new_cred = cred ;}return err ;},2738
354,if ( peer ) {if ( ! lsk -> peer_conn_id ) return - ENOTCONN ;,lsa -> l2tp_unused = 0 ;if ( peer ) {if ( ! lsk -> peer_conn_id ) return - ENOTCONN ;,2739
355,if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 &&  rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) {,if ( * rsize >= 62 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) {,2740
356,int err ;if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ;if ( inet -> opt && inet -> opt -> srr ) {if ( ! daddr ) return - EINVAL ;nexthop = inet -> opt -> faddr ;},"int err ;struct ip_options_rcu * inet_opt ;if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt && inet_opt -> opt . srr ) {if ( ! daddr ) return - EINVAL ;nexthop = inet_opt -> opt . faddr ;}",2741
357,if ( ! inet -> opt || ! inet -> opt -> srr )  daddr = rt -> rt_dst ;if ( ! inet -> inet_saddr ) inet -> inet_saddr = rt -> rt_src ;inet -> inet_rcv_saddr = inet -> inet_saddr ;if ( tp -> rx_opt . ts_recent_stamp && inet -> inet_daddr != daddr ) {tp -> rx_opt . ts_recent = 0 ;tp -> rx_opt . ts_recent_stamp = 0 ;tp -> write_seq = 0 ;}if ( tcp_death_row . sysctl_tw_recycle && ! tp -> rx_opt . ts_recent_stamp && rt -> rt_dst == daddr ) {struct inet_peer * peer = rt_get_peer ( rt ) ;if ( peer ) {inet_peer_refcheck ( peer ) ;if ( ( u32 ) get_seconds ( ) - peer -> tcp_ts_stamp <= TCP_PAWS_MSL ) {tp -> rx_opt . ts_recent_stamp = peer -> tcp_ts_stamp ;tp -> rx_opt . ts_recent = peer -> tcp_ts ;}}}inet -> inet_dport = usin -> sin_port ;inet -> inet_daddr = daddr ;inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;if ( inet -> opt )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ;,if ( ! inet_opt || ! inet_opt -> opt . srr ) daddr = rt -> rt_dst ;if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . optlen ;,2741
358,drop_futex_key_refs ( & q -> key ) ;},},2742
359,if ( test_tsk_need_resched ( rq -> curr ) )  rq -> skip_clock_update = 1 ;,if ( rq -> curr -> se . on_rq && test_tsk_need_resched ( rq -> curr ) ) rq -> skip_clock_update = 1 ;,2743
360,"dh_clnt = EVP_PKEY_get0_DH ( ckey ) ;if ( dh_clnt == NULL || ssl_derive ( s , ckey , skey ) == 0 ) {","if ( ckey == NULL ) {SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ;return 0 ;}dh_clnt = EVP_PKEY_get0_DH ( ckey ) ;if ( dh_clnt == NULL || ssl_derive ( s , ckey , skey ) == 0 ) {",2744
361,"static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ;","static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ;",2745
362,"if ( ! in_group_p ( inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  mode &= ~ S_ISGID ;","if ( ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) mode &= ~ S_ISGID ;",2746
363,"int midi_synth_load_patch ( int dev , int format , const char __user * addr ,  int offs , int count , int pmgr_flag )  {","int midi_synth_load_patch ( int dev , int format , const char __user * addr , int count , int pmgr_flag ) {",2747
364,"if ( format != SYSEX_PATCH )  {return - EINVAL ;}if ( count < hdr_size )  {return - EINVAL ;}count -= hdr_size ;if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) )  return - EFAULT ;if ( count < sysex . len )   {sysex . len = count ;}left = sysex . len ;",if ( format != SYSEX_PATCH ) return - EINVAL ;}if ( count < hdr_size ) {return - EINVAL ;if ( count < sysex . len ) {sysex . len = count ;}left = sysex . len ;,2747
365,mk_vhost_close ( sr ) ;},if ( sr -> fd_is_fdt == MK_TRUE ) {mk_vhost_close ( sr ) ;}else {close ( sr -> fd_file ) ;}},2748
366,}pin -> request_count -- ;,rdev -> ena_pin = NULL ;return ;}pin -> request_count -- ;,2749
367,"int chars_processed ;int elt ;int data_size = ndo -> ndo_snapend - bp ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;chars_processed = 1 ;if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) {","int elt ;u_int offset , max_offset ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;max_offset = ( u_int ) ( cp - bp ) ;if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) {",2750
368,"cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;chars_processed ++ ;if ( chars_processed >= data_size ) {","offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;if ( offset >= max_offset ) {ND_PRINT ( ( ndo , ""<BAD<S2SV_blank>PTR>"" ) ) ;return ( NULL ) ;}max_offset = offset ;cp = bp + offset ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;chars_processed ++ ;if ( chars_processed >= data_size ) {",2750
369,"chars_processed += l ;ND_PRINT ( ( ndo , ""."" ) ) ;chars_processed ++ ;if ( ! compress ) rp += l + 1 ;","ND_PRINT ( ( ndo , ""."" ) ) ;if ( ! compress ) rp += l + 1 ;",2750
370,if ( ! valid_localpart ( maddr -> user ) ||   ! valid_domainpart ( maddr -> domain ) ) {if ( mailfrom && maddr -> user [ 0 ] == '\\\\0' && maddr -> domain [ 0 ] == '\\\\0' ) return ( 1 ) ;,"if ( mailfrom && maddr -> user [ 0 ] == '\\\\0' && maddr -> domain [ 0 ] == '\\\\0' ) return ( 1 ) ;if ( maddr -> user [ 0 ] == '\\\\0' || ! valid_localpart ( maddr -> user ) ) return ( 0 ) ;if ( maddr -> domain [ 0 ] == '\\\\0' ) {( void ) strlcpy ( maddr -> domain , domain , sizeof ( maddr -> domain ) ) return ( 0 ) ;return ( 1 ) ;",2751
371,"return send ( socket -> fd , buf , count , MSG_DONTWAIT ) ;}","return TEMP_FAILURE_RETRY ( send ( socket -> fd , buf , count , MSG_DONTWAIT ) ) ;}",2752
372,"static int input_stats ( struct twopass_rc * p , FIRSTPASS_STATS * fps ) {if ( p -> stats_in >= p -> stats_in_end ) return EOF ;","static int input_stats ( TWO_PASS * p , FIRSTPASS_STATS * fps ) {if ( p -> stats_in >= p -> stats_in_end ) return EOF ;",2753
373,"# ifdef CONFIG_SWAP  if ( ! file ) {* prev = vma ;force_swapin_readahead ( vma , start , end ) ;* prev = vma ;force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ;# else if ( ! file ) return - EBADF ;# endif if ( IS_DAX ( file_inode ( file ) ) ) {return 0 ;}* prev = vma ;start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;","* prev = vma ;# ifdef CONFIG_SWAP if ( ! file ) {force_swapin_readahead ( vma , start , end ) ;force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ;start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;",2754
374,"
","if ( EOFBlob ( image ) != MagickFalse ) {layer_info = DestroyLayerInfo ( layer_info , number_layers ) ;ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ;}",2755
375,"if ( image -> debug != MagickFalse )  ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ;","if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ;",2755
376,"bool __net_get_random_once ( void * buf , int nbytes , bool * done ,  struct static_key * done_key )  {","bool __net_get_random_once ( void * buf , int nbytes , bool * done , struct static_key * once_key ) {",2756
377,__net_random_once_disable_jump ( done_key ) ;return true ;,__net_random_once_disable_jump ( once_key ) ;return true ;,2756
378,"unsigned int var = block_variance ( cpi , x , bs ) ;vp9_clear_system_state ( ) ;energy = 0.9 * ( log ( var + 1.0 ) - 10.0 ) ;","double energy_midpoint ;vpx_clear_system_state ( ) ;energy_midpoint = ( cpi -> oxcf . pass == 2 ) ? cpi -> twopass . mb_av_energy : DEFAULT_E_MIDPOINT ;energy = vp9_log_block_var ( cpi , x , bs ) - energy_midpoint ;",2757
379,"static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2758
380,srose -> srose_family = AF_ROSE ;srose -> srose_addr = rose -> dest_addr ;,"memset ( srose , 0 , msg -> msg_namelen ) ;srose -> srose_family = AF_ROSE ;srose -> srose_addr = rose -> dest_addr ;",2759
381,"static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options )  {","static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options , uid_t * check_ruid ) {",2760
382,if ( ! options ) {rc = - EINVAL ;,* check_ruid = 0 ;if ( ! options ) {rc = - EINVAL ;,2760
383,"
",case ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ;break ;,2760
384,"case ecryptfs_opt_err :  default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\\","case ecryptfs_opt_err : default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\\",2760
385,"cJSON_AddFloatToObject ( j , ""cpu_util_total"" , test -> cpu_util [ 0 ] ) ;cJSON_AddFloatToObject ( j , ""cpu_util_user"" , test -> cpu_util [ 1 ] ) ;cJSON_AddFloatToObject ( j , ""cpu_util_system"" , test -> cpu_util [ 2 ] ) ;if ( ! test -> sender ) sender_has_retransmits = - 1 ;cJSON_AddIntToObject ( j , ""sender_has_retransmits"" , sender_has_retransmits ) ;if ( test -> role == \'s\' && test -> get_server_output ) {","cJSON_AddNumberToObject ( j , ""cpu_util_total"" , test -> cpu_util [ 0 ] ) ;cJSON_AddNumberToObject ( j , ""cpu_util_user"" , test -> cpu_util [ 1 ] ) ;cJSON_AddNumberToObject ( j , ""cpu_util_system"" , test -> cpu_util [ 2 ] ) ;if ( ! test -> sender ) sender_has_retransmits = - 1 ;cJSON_AddNumberToObject ( j , ""sender_has_retransmits"" , sender_has_retransmits ) ;if ( test -> role == \'s\' && test -> get_server_output ) {",2761
386,"else {cJSON_AddItemToObject ( j , ""streams"" , j_streams ) ;SLIST_FOREACH ( sp , & test -> streams , streams ) {j_stream = cJSON_CreateObject ( ) ;if ( j_stream == NULL ) {i_errno = IEPACKAGERESULTS ;r = - 1 ;}else {cJSON_AddItemToArray ( j_streams , j_stream ) ;bytes_transferred = test -> sender ? sp -> result -> bytes_sent : sp -> result -> bytes_received ;retransmits = ( test -> sender && test -> sender_has_retransmits ) ? sp -> result -> stream_retrans : - 1 ;cJSON_AddIntToObject ( j_stream , ""id"" , sp -> id ) ;cJSON_AddIntToObject ( j_stream , ""bytes"" , bytes_transferred ) ;cJSON_AddIntToObject ( j_stream , ""retransmits"" , retransmits ) ;cJSON_AddFloatToObject ( j_stream , ""jitter"" , sp -> jitter ) ;cJSON_AddIntToObject ( j_stream , ""errors"" , sp -> cnt_error ) ;cJSON_AddIntToObject ( j_stream , ""packets"" , sp -> packet_count ) ;}","cJSON_AddNumberToObject ( j_stream , ""id"" , sp -> id ) ;cJSON_AddIntToObject ( j_stream , ""bytes"" , bytes_transferred ) ;cJSON_AddIntToObject ( j_stream , ""retransmits"" , retransmits ) ;cJSON_AddFloatToObject ( j_stream , ""jitter"" , sp -> jitter ) ;cJSON_AddIntToObject ( j_stream , ""errors"" , sp -> cnt_error ) ;cJSON_AddIntToObject ( j_stream , ""packets"" , sp -> packet_count ) ;",2761
387,"memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;rinfo [ val ] . req_state = srp -> done + 1 ;","rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;rinfo [ val ] . req_state = srp -> done + 1 ;",2762
388,err = - EFAULT ;goto out ;}if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) {u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR :  case PSR_AA32_MODE_FIQ :  case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND :  case PSR_MODE_EL0t :  case PSR_MODE_EL1t :  case PSR_MODE_EL1h :  break ;,u64 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ;break ;case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;,2763
389,"static int64_t rd_pick_intra_sby_mode ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ,  int64_t tx_cache [ TX_MODES ] ,  int64_t best_rd ) {MB_PREDICTION_MODE mode ;MB_PREDICTION_MODE mode_selected = DC_PRED ;int i ;int * bmode_costs = x -> mbmode_cost ;if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) for ( i = 0 ;i < TX_MODES ;i ++ ) tx_cache [ i ] = INT64_MAX ;int64_t local_tx_cache [ TX_MODES ] ;MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ;MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ;if ( ! ( cpi -> sf . intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] & ( 1 << mode ) ) ) continue ;if ( cpi -> common . frame_type == KEY_FRAME ) {const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ;const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ;bmode_costs = x -> y_mode_costs [ A ] [ L ] ;}mic -> mbmi . mode = mode ;intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion ,   & s , NULL , bsize , local_tx_cache , best_rd ) ;if ( this_rate_tokenonly == INT_MAX ) continue ;","static int64_t rd_pick_intra_sby_mode ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , int64_t best_rd ) {MB_PREDICTION_MODE mode ;MB_PREDICTION_MODE mode_selected = DC_PRED ;int * bmode_costs ;const MODE_INFO * above_mi = xd -> above_mi ;const MODE_INFO * left_mi = xd -> left_mi ;const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ;const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ;bmode_costs = cpi -> y_mode_costs [ A ] [ L ] ;memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ;if ( cpi -> sf . use_nonrd_pick_mode ) {if ( conditional_skipintra ( mode , mode_selected ) ) continue ;if ( * skippable ) break ;}mic -> mbmi . mode = mode ;intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion , & s , NULL , bsize , local_tx_cache , best_rd ) ;if ( this_rate_tokenonly == INT_MAX ) continue ;",2764
390,}if ( cpi -> sf . tx_size_search_method == USE_FULL_RD && this_rd < INT64_MAX ) {for ( i = 0 ;i < TX_MODES && local_tx_cache [ i ] < INT64_MAX ;i ++ ) {const int64_t adj_rd = this_rd + local_tx_cache [ i ] - local_tx_cache [ cpi -> common . tx_mode ] ;if ( adj_rd < tx_cache [ i ] ) {tx_cache [ i ] = adj_rd ;}},"
",2764
391,CurrentColorSpace = ColorSpaceOut ;}Error :  cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;,Lut = NULL ;CurrentColorSpace = ColorSpaceOut ;}Error : if ( Lut != NULL ) cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;,2765
392,"
",if ( width >= ( long ) sizeof ( work ) ) width = sizeof ( work ) - 1 ;,2766
393,"
",size_t maxprec = sizeof ( work ) - 2 ;double val = p -> data . dnum ;while ( val >= 10.0 ) {val /= 10 ;maxprec -- ;}if ( prec > ( long ) maxprec ) prec = maxprec - 1 ;,2766
394,"len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ;fptr += len ;len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ;fptr += len ;","len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ;fptr += len ;len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ;fptr += len ;",2766
395,for ( fptr = work ;fptr ++ )  OUTCHAR ( * fptr ) ;,# ifdef CURLDEBUG assert ( strlen ( work ) <= sizeof ( work ) ) ;# endif for ( fptr = work ;fptr ++ ) OUTCHAR ( * fptr ) ;,2766
396,int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ;for ( y = 0 ;,int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ;av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ;av_assert0 ( height <= JPEG2000_MAX_CBLKH ) ;for ( y = 0 ;,2767
397,if ( sk -> sk_shutdown & RCV_SHUTDOWN ) {msg -> msg_namelen = 0 ;return 0 ;},if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ;,2768
398,else  msg -> msg_namelen = 0 ;,"
",2768
399,CollSeq * p4 ;if ( isCommuted ) {,CollSeq * p4 ;if ( pParse -> nErr ) return 0 ;if ( isCommuted ) {,2769
400,"mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ;mutex_unlock ( & mut ) ;","mc -> id = idr_alloc ( & multicast_idr , NULL , 0 , 0 , GFP_KERNEL ) ;mutex_unlock ( & mut ) ;",2770
401,"static void copy_to_user_policy ( struct xfrm_policy * xp , struct xfrm_userpolicy_info * p , int dir )  {memcpy ( & p -> sel , & xp -> selector , sizeof ( p -> sel ) ) ;","static void copy_to_user_policy ( struct xfrm_policy * xp , struct xfrm_userpolicy_info * p , int dir ) {memset ( p , 0 , sizeof ( * p ) ) ;memcpy ( & p -> sel , & xp -> selector , sizeof ( p -> sel ) ) ;",2771
402,continue ;},"if ( len >= FPM_LOG_BUFFER ) {zlog ( ZLOG_NOTICE , ""the<S2SV_blank>log<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>full<S2SV_blank>(%d).<S2SV_blank>The<S2SV_blank>access<S2SV_blank>log<S2SV_blank>request<S2SV_blank>has<S2SV_blank>been<S2SV_blank>truncated."" , FPM_LOG_BUFFER ) ;len = FPM_LOG_BUFFER ;break ;}continue ;}",2772
403,"
","if ( ! caller_may_see_dir ( fc -> pid , controller , path1 ) ) {ret = - ENOENT ;goto out ;}",2773
404,"if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) {ret = - EACCES ;","if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) {ret = - EACCES ;",2773
405,"CYCLIC_REFRESH * vp9_cyclic_refresh_alloc ( int mi_rows , int mi_cols ) {CYCLIC_REFRESH * const cr = vpx_calloc ( 1 , sizeof ( * cr ) ) ;return cr ;}","CYCLIC_REFRESH * vp9_cyclic_refresh_alloc ( int mi_rows , int mi_cols ) {size_t last_coded_q_map_size ;CYCLIC_REFRESH * const cr = vpx_calloc ( 1 , sizeof ( * cr ) ) ;last_coded_q_map_size = mi_rows * mi_cols * sizeof ( * cr -> last_coded_q_map ) ;cr -> last_coded_q_map = vpx_malloc ( last_coded_q_map_size ) ;if ( cr -> last_coded_q_map == NULL ) {vpx_free ( cr ) ;return NULL ;}assert ( MAXQ <= 255 ) ;memset ( cr -> last_coded_q_map , MAXQ , last_coded_q_map_size ) ;return cr ;}",2774
406,"dm9000WriteReg ( DM9000_REG_MWCMDX , 0 ) ;DM9000_INDEX_REG = DM9000_REG_MWCMD ;p = ( uint16_t * ) context -> txBuffer ;","dm9000WriteReg ( DM9000_MWCMDX , 0 ) ;DM9000_INDEX_REG = DM9000_MWCMD ;p = ( uint16_t * ) context -> txBuffer ;",2775
407,"dm9000WriteReg ( DM9000_REG_TXPLL , LSB ( length ) ) ;dm9000WriteReg ( DM9000_REG_TXPLH , MSB ( length ) ) ;dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ;dm9000WriteReg ( DM9000_REG_TCR , TCR_TXREQ ) ;","dm9000WriteReg ( DM9000_TXPLL , LSB ( length ) ) ;dm9000WriteReg ( DM9000_TXPLH , MSB ( length ) ) ;dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PT ) ;dm9000WriteReg ( DM9000_TCR , DM9000_TCR_TXREQ ) ;",2775
408,inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;,"uint16 bps = 0 ;( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ;if ( bps != 8 ) {TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpContig2SeparateByRow"" ) ;return 0 ;}inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;",2776
409,"if ( ! ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( ds ) ) & EVP_CIPH_FLAG_PIPELINE ) ) {SSLerr ( SSL_F_TLS1_ENC , SSL_R_PIPELINE_FAILURE ) ;return - 1 ;}}for ( ctr = 0 ;ctr < n_recs ;ctr ++ ) {reclen [ ctr ] = recs [ ctr ] . length ;if ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( ds ) ) & EVP_CIPH_FLAG_AEAD_CIPHER ) {unsigned char * seq ;seq = send ? RECORD_LAYER_get_write_sequence ( & s -> rlayer ) : RECORD_LAYER_get_read_sequence ( & s -> rlayer ) ;if ( SSL_IS_DTLS ( s ) ) {",if ( ! SSL_READ_ETM ( s ) ) {,2777
410,if ( ! SSL_USE_ETM ( s ) && EVP_MD_CTX_md ( s -> read_hash ) != NULL )  mac_size = EVP_MD_CTX_size ( s -> read_hash ) ;,if ( ! SSL_USE_ETM ( s ) && EVP_MD_CTX_md ( s -> read_hash ) != NULL ) mac_size = EVP_MD_CTX_size ( s -> read_hash ) ;,2777
411,static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu )  {if ( ! to_vmx ( vcpu ) -> nested . vmxon ) {,"static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu ) {if ( vmx_get_cpl ( vcpu ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;return 0 ;}if ( ! to_vmx ( vcpu ) -> nested . vmxon ) {",2778
412,"
",rcu_read_lock ( ) ;,2779
413,"final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;if ( IS_ERR ( dst ) ) {err = PTR_ERR ( dst ) ;dst = NULL ;goto done ;}skb = dccp_make_response ( sk , dst , req ) ;if ( skb != NULL ) {struct dccp_hdr * dh = dccp_hdr ( skb ) ;dh -> dccph_checksum = dccp_v6_csum_finish ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ;fl6 . daddr = ireq -> ir_v6_rmt_addr ;err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;err = net_xmit_eval ( err ) ;","final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ;rcu_read_unlock ( ) ;err = net_xmit_eval ( err ) ;",2779
414,"switch ( opt ) {case LCPOPT_VEXT : if ( len < 6 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>6)"" ) ) ;return len ;}ND_TCHECK2 ( * ( p + 2 ) , 3 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ;","ND_TCHECK_24BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ;",2780
415,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , tok2str ( ppptype2str , ""Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)"" , EXTRACT_16BITS ( p + 2 ) ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK_32BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , tok2str ( ppptype2str , ""Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)"" , EXTRACT_16BITS ( p + 2 ) ) ) ) ;",2780
416,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , "":<S2SV_blank>LQR"" ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , "":<S2SV_blank>LQR"" ) ) ;ND_TCHECK_32BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;",2780
417,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ;ND_TCHECK ( p [ 2 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Callback<S2SV_blank>Operation<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( ppp_callback_values , ""Unknown"" , p [ 2 ] ) , p [ 2 ] ) ) ;break ;case LCPOPT_MLMRRU : if ( len != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)"" ) ) ;return 0 ;}ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;",2780
418,"expr_ty str = parsestrplus ( c , n ) ;","expr_ty str = parsestrplus ( c , STR ( ch ) ) ;",2781
419,"pynum = parsenumber ( c , s ) ;if ( ! pynum ) return NULL ;","pynum = parsenumber ( c , s ) ;if ( ! pynum ) return NULL ;",2781
420,"udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ;brelse ( bh ) ;up_read ( & iinfo -> i_data_sem ) ;","err = udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p , PAGE_SIZE ) ;brelse ( bh ) ;if ( err ) goto out_unlock_inode ;up_read ( & iinfo -> i_data_sem ) ;",2782
421,const MB_PREDICTION_MODE y_mode = mi -> mbmi . mode ;const MB_PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ;const BLOCK_SIZE bsize = mi -> mbmi . sb_type ;,const PREDICTION_MODE y_mode = mi -> mbmi . mode ;const PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ;const BLOCK_SIZE bsize = mi -> mbmi . sb_type ;,2783
422,"static void  horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % stride ) == 0 ) ;if ( cc > stride ) {","static int horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % stride ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ;return 0 ;}if ( cc > stride ) {",2784
423,"
",return 1 ;,2784
424,},},2784
425,"env = g_environ_setenv ( env , var , val , TRUE ) ;}","if ( var [ 0 ] == \'\\\\0\' ) {g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>empty<S2SV_blank>name"" ) ;return G_DBUS_METHOD_INVOCATION_HANDLED ;}if ( strchr ( var , \'=\' ) != NULL ) {g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>name<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\\'=\\\'"" ) ;return G_DBUS_METHOD_INVOCATION_HANDLED ;}g_string_append ( env_string , var ) ;g_string_append_c ( env_string , \'=\' ) ;g_string_append ( env_string , val ) ;g_string_append_c ( env_string , \'\\\\0\' ) ;}",2785
426,goto errout_locked ;},goto errout_free ;},2786
427,kfree ( family -> attrbuf ) ;errout_locked : genl_unlock_all ( ) ;,errout_free : kfree ( family -> attrbuf ) ;errout_locked : genl_unlock_all ( ) ;,2786
428,"static void  horDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 2 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 2 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%(2*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",2787
429,},return 1 ;},2787
430,"up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & kctl -> id ) ;return 0 ;","struct snd_ctl_elem_id id = kctl -> id ;up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & id ) ;return 0 ;",2788
431,"( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;image = DestroyImage ( image ) ;","( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;geometry = DestroyString ( geometry ) ;image = DestroyImage ( image ) ;",2789
432,"static inline bool unconditional ( const struct arpt_arp * arp )  {return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ;}","static inline bool unconditional ( const struct arpt_entry * e ) {return e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> arp , & uncond , sizeof ( uncond ) ) == 0 ;}",2790
433,if ( user_alloc && ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) )  goto out ;,"if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size ) ) ) goto out ;",2791
434,"size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;","size_t tail = ( i << 1 ) + 1 ;if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ;size_t ofs = CDF_GETUINT32 ( p , tail ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;",2792
435,err = - EMSGSIZE ;if ( len > 0xFFFF ) goto out ;,struct ip_options_data opt_copy ;err = - EMSGSIZE ;if ( len > 0xFFFF ) goto out ;,2793
436,if ( ipc . opt ) free = 1 ;saddr = ipc . addr ;ipc . addr = daddr ;if ( ! ipc . opt )  ipc . opt = inet -> opt ;if ( ipc . opt ) {if ( ipc . opt -> srr ) {if ( ! daddr ) goto done ;daddr = ipc . opt -> faddr ;},"if ( ipc . opt ) {struct ip_options_rcu * inet_opt ;rcu_read_lock ( ) ;inet_opt = rcu_dereference ( inet -> inet_opt ) ;if ( inet_opt ) {memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ;ipc . opt = & opt_copy . opt ;rcu_read_unlock ( ) ;}if ( ipc . opt ) {if ( ipc . opt -> opt . srr ) {if ( ! daddr ) goto done ;daddr = ipc . opt -> opt . faddr ;}",2793
437,else  img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ;},else img = ctx -> iface -> enc . get_preview ( get_alg_priv ( ctx ) ) ;},2794
438,static void follow_dotdot ( struct nameidata * nd )  {,static int follow_dotdot ( struct nameidata * nd ) {,2795
439,break ;}},if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;break ;}return 0 ;},2795
440,"else if ( rc == - ENODATA )  rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ;return rc ;}","else if ( rc == - ENODATA && inode -> i_op -> removexattr ) {rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ;}return rc ;}",2796
441,MP4_READBOX_ENTER ( MP4_Box_data_string_t ) ;p_box -> data . p_string -> psz_text = malloc ( p_box -> i_size + 1 - 8 ) ;,MP4_READBOX_ENTER ( MP4_Box_data_string_t ) ;if ( p_box -> i_size < 8 || p_box -> i_size > SIZE_MAX ) MP4_READBOX_EXIT ( 0 ) ;p_box -> data . p_string -> psz_text = malloc ( p_box -> i_size + 1 - 8 ) ;,2797
442,"u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ;if ( ! d ) return - ENODEV ;if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 )  return - EAGAIN ;switch ( num ) {case 1 : switch ( msg [ 0 ] . addr ) {case SU3000_STREAM_CTRL :  obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ;obuf [ 1 ] = 3 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case DW2102_RC_QUERY :  obuf [ 0 ] = 0x10 ;if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ;msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ;break ;default :  obuf [ 0 ] = 0x08 ;obuf [ 1 ] = msg [ 0 ] . addr ;obuf [ 2 ] = msg [ 0 ] . len ;memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 ,   ibuf , 1 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case 2 :  obuf [ 0 ] = 0x09 ;obuf [ 1 ] = msg [ 0 ] . len ;obuf [ 2 ] = msg [ 1 ] . len ;obuf [ 3 ] = msg [ 0 ] . addr ;memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 ,   ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ;break ;mutex_unlock ( & d -> i2c_mutex ) ;return num ;","struct dw2102_state * state ;if ( ! d ) return - ENODEV ;state = d -> priv ;if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) return - EAGAIN ;if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) {mutex_unlock ( & d -> i2c_mutex ) ;return - EAGAIN ;}switch ( num ) {case 1 : switch ( msg [ 0 ] . addr ) {case SU3000_STREAM_CTRL : state -> data [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ;state -> data [ 1 ] = 3 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 0 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;break ;case DW2102_RC_QUERY : state -> data [ 0 ] = 0x10 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 2 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msg [ 0 ] . buf [ 1 ] = state -> data [ 0 ] ;msg [ 0 ] . buf [ 0 ] = state -> data [ 1 ] ;default : state -> data [ 0 ] = 0x08 ;state -> data [ 1 ] = msg [ 0 ] . addr ;state -> data [ 2 ] = msg [ 0 ] . len ;memcpy ( & state -> data [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , state -> data , msg [ 0 ] . len + 3 , state -> data , 1 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case 2 : state -> data [ 0 ] = 0x09 ;state -> data [ 1 ] = msg [ 0 ] . len ;state -> data [ 2 ] = msg [ 1 ] . len ;state -> data [ 3 ] = msg [ 0 ] . addr ;memcpy ( & state -> data [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , state -> data , msg [ 0 ] . len + 4 , state -> data , msg [ 1 ] . len + 1 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;memcpy ( msg [ 1 ] . buf , & state -> data [ 1 ] , msg [ 1 ] . len ) ;break ;mutex_unlock ( & d -> data_mutex ) ;mutex_unlock ( & d -> i2c_mutex ) ;return num ;",2798
443,"if ( yych == \':\' ) goto yy95 ;yy3 : # line 884 ""ext/standard/var_unserializer.re"" {return 0 ;}# line 580 ""ext/standard/var_unserializer.c"" yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy89 ;goto yy3 ;yy5 : yych = * ++ YYCURSOR ;if ( yych == \';\' ) goto yy87 ;goto yy3 ;yy6 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy83 ;goto yy3 ;yy7 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy77 ;goto yy3 ;yy8 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy53 ;goto yy3 ;yy9 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy46 ;goto yy3 ;yy10 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy39 ;goto yy3 ;yy11 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy32 ;goto yy3 ;yy12 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy25 ;goto yy3 ;yy13 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy17 ;goto yy3 ;yy14 : ++ YYCURSOR ;# line 878 ""ext/standard/var_unserializer.re"" {php_error_docref ( NULL , E_NOTICE , ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>serialized<S2SV_blank>data"" ) ;return 0 ;}# line 629 ""ext/standard/var_unserializer.c"" yy16 : yych = * ++ YYCURSOR ;goto yy3 ;yy17 : yych = * ++ YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy20 ;}if ( yych == \'+\' ) goto yy19 ;yy18 : YYCURSOR = YYMARKER ;goto yy3 ;yy19 : yych = * ++ YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy20 ;}goto yy18 ;yy20 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy20 ;}if ( yych != \':\' ) goto yy18 ;yych = * ++ YYCURSOR ;",if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \';\' ) goto yy18 ;yych = * ++ YYCURSOR ;,2799
444,"# line 804 ""ext/standard/var_unserializer.c""  yy25 : yych = * ++ YYCURSOR ;","# line 805 ""ext/standard/var_unserializer.c"" yy25 : yych = * ++ YYCURSOR ;",2799
445,"# line 836 ""ext/standard/var_unserializer.c""  yy32 : yych = * ++ YYCURSOR ;","# line 837 ""ext/standard/var_unserializer.c"" yy32 : yych = * ++ YYCURSOR ;",2799
446,"# line 881 ""ext/standard/var_unserializer.c""  yy39 : yych = * ++ YYCURSOR ;","# line 882 ""ext/standard/var_unserializer.c"" yy39 : yych = * ++ YYCURSOR ;",2799
447,"# line 936 ""ext/standard/var_unserializer.c""  yy46 : yych = * ++ YYCURSOR ;","# line 937 ""ext/standard/var_unserializer.c"" yy46 : yych = * ++ YYCURSOR ;",2799
448,"# line 989 ""ext/standard/var_unserializer.c""  yy53 : yych = * ++ YYCURSOR ;","# line 990 ""ext/standard/var_unserializer.c"" yy53 : yych = * ++ YYCURSOR ;",2799
449,"# line 1086 ""ext/standard/var_unserializer.c""  yy65 : yych = * ++ YYCURSOR ;","# line 1087 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ;",2799
450,"# line 1161 ""ext/standard/var_unserializer.c""  yy76 : yych = * ++ YYCURSOR ;","# line 1162 ""ext/standard/var_unserializer.c"" yy76 : yych = * ++ YYCURSOR ;",2799
451,"# line 1214 ""ext/standard/var_unserializer.c""  yy83 : yych = * ++ YYCURSOR ;","# line 1215 ""ext/standard/var_unserializer.c"" yy83 : yych = * ++ YYCURSOR ;",2799
452,"# line 1228 ""ext/standard/var_unserializer.c""  yy87 : ++ YYCURSOR ;# line 1237 ""ext/standard/var_unserializer.c""  yy89 : yych = * ++ YYCURSOR ;","# line 1229 ""ext/standard/var_unserializer.c"" yy87 : ++ YYCURSOR ;# line 1238 ""ext/standard/var_unserializer.c"" yy89 : yych = * ++ YYCURSOR ;",2799
453,"# line 1285 ""ext/standard/var_unserializer.c""  yy95 : yych = * ++ YYCURSOR ;","# line 1286 ""ext/standard/var_unserializer.c"" yy95 : yych = * ++ YYCURSOR ;",2799
454,"# line 1334 ""ext/standard/var_unserializer.c""  }","# line 1335 ""ext/standard/var_unserializer.c"" }",2799
455,"if ( timeri -> master )  list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ;spin_unlock_irqrestore ( & slave_active_lock , flags ) ;return 1 ;","if ( timeri -> master && timeri -> timer ) {spin_lock ( & timeri -> timer -> lock ) ;list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ;spin_unlock ( & timeri -> timer -> lock ) ;}spin_unlock_irqrestore ( & slave_active_lock , flags ) ;return 1 ;",2800
456,"int n = * pnEntry ;if ( ( n & ( n - 1 ) ) == 0 ) {int sz = ( n == 0 ) ? 1 : 2 * n ;void * pNew = sqlite3DbRealloc ( db , pArray , sz * szEntry ) ;","sqlite3_int64 n = * pnEntry ;if ( ( n & ( n - 1 ) ) == 0 ) {sqlite3_int64 sz = ( n == 0 ) ? 1 : 2 * n ;void * pNew = sqlite3DbRealloc ( db , pArray , sz * szEntry ) ;",2801
457,if ( payload_len > IPV6_MAXPLEN ) {,if ( fp && payload_len > IPV6_MAXPLEN ) {,2802
458,if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL )  fp = fp -> next ;,if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) fp = fp -> next ;,2802
459,sbi -> s_mb_cache = ext4_xattr_create_cache ( sb -> s_id ) ;if ( ! sbi -> s_mb_cache ) {,sbi -> s_mb_cache = ext4_xattr_create_cache ( ) ;if ( ! sbi -> s_mb_cache ) {,2803
460,failed_mount_wq :  if ( sbi -> s_journal ) {,failed_mount_wq : if ( sbi -> s_mb_cache ) {ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ;sbi -> s_mb_cache = NULL ;}if ( sbi -> s_journal ) {,2803
461,const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ;int ref ;,const InterpKernel * kernel = vp9_filter_kernels [ mi -> mbmi . interp_filter ) ;int ref ;,2804
462,"const MV mv = mi -> mbmi . sb_type < BLOCK_8X8  ? ( plane == 0 ? mi -> bmi [ block ] . as_mv [ ref ] . as_mv  : mi_mv_pred_q4 ( mi , ref ) ) : mi -> mbmi . mv [ ref ] . as_mv ;if ( vp9_is_scaled ( sf ) ) {pre = pre_buf -> buf + scaled_buffer_offset ( x , y , pre_buf -> stride , sf ) ;","const MV mv = mi -> mbmi . sb_type < BLOCK_8X8 ? average_split_mvs ( pd , mi , ref , block ) : mi -> mbmi . mv [ ref ] . as_mv ;const int is_scaled = vp9_is_scaled ( sf ) ;if ( is_scaled ) {pre = pre_buf -> buf + scaled_buffer_offset ( x , y , pre_buf -> stride , sf ) ;",2804
463,"inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride ,   subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ;}","# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {high_inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys , xd -> bd ) ;}else {inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ;}# else inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ;# endif }",2804
464,"
","i1_intra_pred = CLIP3 ( 0 , 8 , i1_intra_pred ) ;i1_intra_pred = CLIP3 ( 0 , 8 , i1_intra_pred ) ;",2805
465,{UWORD8 u1_err_code = pu1_intra_err_codes [ i1_intra_pred ] ;,{UWORD8 u1_err_code = pu1_intra_err_codes [ i1_intra_pred ] ;,2805
466,}{,}{,2805
467,"assert ( caplen > 0 ) ;reallen = roundup2 ( caplen , 4 ) ;","reallen = roundup2 ( caplen , 4 ) ;",2806
468,"}return ( PTR_DIFF ( s , s0 ) + 1 ) ;","ND_TCHECK2 ( * s , 1 ) ;}return ( PTR_DIFF ( s , s0 ) + 1 ) ;",2807
469,"
",if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;,2808
470,"if ( tga_info . colormap_type != 0 )  {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","if ( tga_info . colormap_type != 0 ) {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",2808
471,"_copy_from_pages ( buf , pages , res . acl_data_offset ,  res . acl_len ) ;}","_copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ;}",2809
472,mutex_unlock ( & file -> mut ) ;ucma_put_ctx ( ctx ) ;,"mutex_lock ( & mut ) ;idr_replace ( & multicast_idr , mc , mc -> id ) ;mutex_unlock ( & mut ) ;mutex_unlock ( & file -> mut ) ;ucma_put_ctx ( ctx ) ;",2810
473,"timeri = list_entry ( timer -> open_list_head . next ,  struct snd_timer_instance , open_list ) ;if ( timeri -> flags & SNDRV_TIMER_IFLG_EXCLUSIVE ) {err = - EBUSY ;timeri = NULL ;","struct snd_timer_instance * t = list_entry ( timer -> open_list_head . next , struct snd_timer_instance , open_list ) ;if ( t -> flags & SNDRV_TIMER_IFLG_EXCLUSIVE ) {err = - EBUSY ;",2811
474,"d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ;d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ;q6u16 = vmull_u8 ( vget_low_u8 ( q1u8 ) , d0u8 ) ;","d0u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 0 ] ) ;d1u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 1 ] ) ;q6u16 = vmull_u8 ( vget_low_u8 ( q1u8 ) , d0u8 ) ;",2812
475,"static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe ,  struct pipe_buffer * buf ) {ref -> ref ++ ;}","static bool buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {if ( ref -> ref > INT_MAX / 2 ) return false ;ref -> ref ++ ;return true ;}",2813
476,"int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ;int64_t total_samples = 0 , infilesize ;","int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 , format_chunk = 0 ;int64_t total_samples = 0 , infilesize ;",2814
477,"int supported = TRUE , format ;if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) {","int supported = TRUE , format ;if ( format_chunk ++ ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) {",2814
478,"
",ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;,2815
479,l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;break ;,l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;break ;,2815
480,"if ( JAS_CAST ( uint , jas_stream_read ( in , ppm -> data , ppm -> len ) ) != ppm -> len ) {goto error ;","if ( JAS_CAST ( jas_uint , jas_stream_read ( in , ppm -> data , ppm -> len ) ) != ppm -> len ) {goto error ;",2816
481,"# endif const bool bcached =  ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ;ctx -> hdrs [ i ] -> old = false ;","# endif const bool bcached = ( mutt_bcache_exists ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) == 0 ) ;ctx -> hdrs [ i ] -> old = false ;",2817
482,# ifdef SQLITE_TEST_REALLOC_STRESS  int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ;# else  int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ;UNUSED_PARAMETER ( nOp ) ;,# ifdef SQLITE_TEST_REALLOC_STRESS sqlite3_int64 nNew = ( v -> nOpAlloc >= 512 ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ;# else sqlite3_int64 nNew = ( v -> nOpAlloc ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) 1024 / sizeof ( Op ) ) ;UNUSED_PARAMETER ( nOp ) ;,2818
483,if ( key -> type -> destroy )  key -> type -> destroy ( key ) ;,"if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ;",2819
484,"int mi_row ;int mi_col ;int mi_index = 0 ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ;int rows = cm -> mi_rows ;log_frame_info ( cm , descriptor , file ) ;mi_index = 0 ;","int mi_row , mi_col ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ;int rows = cm -> mi_rows ;log_frame_info ( cm , descriptor , file ) ;",2820
485,"fprintf ( file , ""%2d<S2SV_blank>"" ,  * ( ( int * ) ( ( char * ) ( & mi_8x8 [ mi_index ] -> mbmi ) +  member_offset ) ) ) ;mi_index ++ ;}mi_index += 8 ;}","fprintf ( file , ""%2d<S2SV_blank>"" , * ( ( int * ) ( ( char * ) ( & mi [ 0 ] -> mbmi ) + member_offset ) ) ) ;mi ++ ;}mi += 8 ;}",2820
486,FIRSTPASS_STATS this_frame ;struct twopass_rc * const twopass = & cpi -> twopass ;,TWO_PASS * const twopass = & cpi -> twopass ;,2821
487,"if ( read_frame_stats ( twopass , & this_frame , ( i + offset ) ) == EOF )  break ;accumulate_frame_motion_stats ( & this_frame ,  & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , & this_frame ) ;decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ;boost_score += ( decay_accumulator *   calc_frame_boost ( cpi , & this_frame , this_frame_mv_in_out ) ) ;}","const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ;if ( this_frame == NULL ) break ;accumulate_frame_motion_stats ( this_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;decay_accumulator *= get_prediction_decay_rate ( cpi , this_frame ) ;decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ;}boost_score += decay_accumulator * calc_frame_boost ( cpi , & this_frame , this_frame_mv_in_out ) ) ;",2821
488,"if ( read_frame_stats ( twopass , & this_frame , ( i + offset ) ) == EOF )  break ;accumulate_frame_motion_stats ( & this_frame ,  & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , & this_frame ) ;decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ;boost_score += ( decay_accumulator *   calc_frame_boost ( cpi , & this_frame , this_frame_mv_in_out ) ) ;}if ( arf_boost < ( ( b_frames + f_frames ) * 20 ) )  arf_boost = ( ( b_frames + f_frames ) * 20 ) ;return arf_boost ;","if ( read_frame_stats ( twopass , & this_frame , ( i + offset ) ) == EOF ) break ;accumulate_frame_motion_stats ( & this_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , & this_frame ) ;decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ;}boost_score += ( decay_accumulator * calc_frame_boost ( cpi , this_frame , this_frame_mv_in_out , GF_MAX_BOOST ) ;if ( arf_boost < ( ( b_frames + f_frames ) * 20 ) ;arf_boost = MAX ( arf_boost , MIN_ARF_GF_BOOST ) ) arf_boost = ( ( b_frames + f_frames ) * 20 ) ;return arf_boost ;",2821
489,"emsg ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ) ;return TRUE ;","emsg ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>and<S2SV_blank>some<S2SV_blank>functionality<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ) ;return TRUE ;",2822
490,if ( m -> msg_flags & MSG_OOB )  goto read_error ;m -> msg_namelen = 0 ;,if ( m -> msg_flags & MSG_OOB ) goto read_error ;,2823
491,"lvl ++ )  vpx_memset ( lfi -> lfthr [ lvl ] . hev_thr , ( lvl >> 4 ) , SIMD_WIDTH ) ;}","lvl ++ ) memset ( lfi -> lfthr [ lvl ] . hev_thr , ( lvl >> 4 ) , SIMD_WIDTH ) ;}",2824
492,static void print_bpf_insn ( struct bpf_insn * insn )  {,"static void print_bpf_insn ( const struct bpf_verifier_env * env , const struct bpf_insn * insn ) {",2825
493,"}else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) {verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%x\\\}","}else if ( BPF_MODE ( insn -> code ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) {u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ;bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ;if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ;verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\\}",2825
494,"static INLINE void read_mv ( vp9_reader * r , MV * mv , const MV * ref ,  const nmv_context * ctx , nmv_context_counts * counts , int allow_hp ) {const MV_JOINT_TYPE joint_type =  ( MV_JOINT_TYPE ) vp9_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ;const int use_hp = allow_hp && vp9_use_mv_hp ( ref ) ;","static INLINE void read_mv ( vpx_reader * r , MV * mv , const MV * ref , const nmv_context * ctx , nmv_context_counts * counts , int allow_hp ) {const MV_JOINT_TYPE joint_type = ( MV_JOINT_TYPE ) vpx_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ;const int use_hp = allow_hp && vp9_use_mv_hp ( ref ) ;",2826
495,"virCheckDomainReturn ( dom , - 1 ) ;if ( dom -> conn -> driver -> domainGetTime ) {","virCheckDomainReturn ( dom , - 1 ) ;virCheckReadOnlyGoto ( dom -> conn -> flags , error ) ;if ( dom -> conn -> driver -> domainGetTime ) {",2827
496,"if ( ! data )   return 0 ;memset ( op , '\\\\0' , sizeof ( RAnalOp ) ) ;","if ( ! data || len < 2 ) {return 0 ;}memset ( op , '\\\\0' , sizeof ( RAnalOp ) ) ;",2828
497,"const char * value = NULL ;xmlNode * command = NULL ;cib_client_t * client = data ;crm_trace ( ""%s<S2SV_blank>callback"" , client -> encrypted ? ""secure"" : ""clear-text"" ) ;command = crm_recv_remote_msg ( client -> session , client -> encrypted ) ;if ( command == NULL ) {value = crm_element_name ( command ) ;if ( safe_str_neq ( value , ""cib_command"" ) ) {crm_log_xml_trace ( command , ""Bad<S2SV_blank>command:<S2SV_blank>"" ) ;goto bail ;if ( client -> name == NULL ) {value = crm_element_value ( command , F_CLIENTNAME ) ;if ( value == NULL ) {client -> name = strdup ( client -> id ) ;else {client -> name = strdup ( value ) ;}}if ( client -> callback_id == NULL ) {value = crm_element_value ( command , F_CIB_CALLBACK_TOKEN ) ;if ( value != NULL ) {client -> callback_id = strdup ( value ) ;crm_trace ( ""Callback<S2SV_blank>channel<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s"" , client -> id , client -> callback_id ) ;}else {client -> callback_id = strdup ( client -> id ) ;xml_remove_prop ( command , F_ORIG ) ;xml_remove_prop ( command , F_CIB_HOST ) ;xml_remove_prop ( command , F_CIB_GLOBAL_UPDATE ) ;crm_xml_add ( command , F_TYPE , T_CIB ) ;crm_xml_add ( command , F_CIB_CLIENTID , client -> id ) ;crm_xml_add ( command , F_CIB_CLIENTNAME , client -> name ) ;# if ENABLE_ACL  crm_xml_add ( command , F_CIB_USER , client -> user ) ;# endif if ( crm_element_value ( command , F_CIB_CALLID ) == NULL ) {crm_xml_add ( command , F_CIB_CALLID , call_uuid ) ;free ( call_uuid ) ;","xmlNode * command = NULL ;cib_client_t * client = data ;int disconnected = 0 ;int timeout = client -> remote_auth ? - 1 : 1000 ;crm_trace ( ""%s<S2SV_blank>callback"" , client -> encrypted ? ""secure"" : ""clear-text"" ) ;# ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> encrypted && ( client -> handshake_complete == FALSE ) ) {int rc = 0 ;do {rc = gnutls_handshake ( * client -> session ) ;if ( rc < 0 && rc != GNUTLS_E_AGAIN ) {crm_err ( ""Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>failed"" ) ;while ( rc == GNUTLS_E_INTERRUPTED ) ;if ( rc == 0 ) {crm_debug ( ""Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>completed"" ) ;client -> handshake_complete = TRUE ;if ( client -> remote_auth_timeout ) {g_source_remove ( client -> remote_auth_timeout ) ;client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , client ) ;return 0 ;# endif crm_recv_remote_msg ( client -> session , & client -> recv_buf , client -> encrypted , timeout , & disconnected ) ;if ( client -> remote_auth == FALSE ) {xmlNode * reg ;# if ENABLE_ACL crm_xml_add ( command , F_CIB_USER , client -> user ) ;# endif if ( crm_element_value ( command , F_CIB_CALLID ) == NULL ) {crm_xml_add ( command , F_CIB_CALLID , call_uuid ) ;free ( call_uuid ) ;",2829
498,"if ( entry -> me_key != NULL ) {entry -> me_value = value ;return 0 ;Py_INCREF ( key ) ;entry -> me_key = key ;entry -> me_value = value ;self -> mt_used ++ ;if ( ! ( self -> mt_used * 3 >= ( self -> mt_mask + 1 ) * 2 ) )  return 0 ;return _PyMemoTable_ResizeTable ( self ,   ( self -> mt_used > 50000 ? 2 : 4 ) * self -> mt_used ) ;}","if ( SIZE_MAX / 3 >= self -> mt_used ;return _PyMemoTable_ResizeTable ( self , desired_size && self -> mt_used ++ ;if ( ! ( self -> mt_used * 3 >= ( self -> mt_mask + 1 ) * 2 ) ) return 0 ;return _PyMemoTable_ResizeTable ( self , ( self -> mt_used > 50000 ? 2 : 4 ) * self -> mt_used ) ;",2830
499,params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,"size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;",2831
500,"# endif  vpx_memset ( segment_counts , 0 , sizeof ( segment_counts ) ) ;totalrate = 0 ;","# endif memset ( segment_counts , 0 , sizeof ( segment_counts ) ) ;totalrate = 0 ;",2832
501,"for ( i = 0 ;i < num_part ;i ++ ) {vp8_start_encode ( & bc [ i ] , cpi -> partition_d [ i + 1 ] , cpi -> partition_d_end [ i + 1 ] ) ;bc [ i ] . error = & cm -> error ;}}# endif {struct vpx_usec_timer emr_timer ;vpx_usec_timer_start ( & emr_timer ) ;# if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) {int i ;vp8cx_init_mbrthread_data ( cpi , x , cpi -> mb_row_ei , cpi -> encoding_thread_count ) ;for ( i = 0 ;i < cm -> mb_rows ;i ++ ) cpi -> mt_current_mb_col [ i ] = - 1 ;for ( i = 0 ;i < cpi -> encoding_thread_count ;i ++ ) {sem_post ( & cpi -> h_event_start_encoding [ i ] ) ;}for ( mb_row = 0 ;mb_row < cm -> mb_rows ;mb_row += ( cpi -> encoding_thread_count + 1 ) ) {vp8_zero ( cm -> left_context ) # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING tp = cpi -> tok ;# else tp = cpi -> tok + mb_row * ( cm -> mb_cols * 16 * 24 ) ;# endif encode_mb_row ( cpi , cm , mb_row , x , xd , & tp , segment_counts , & totalrate ) ;x -> src . y_buffer += 16 * x -> src . y_stride * ( cpi -> encoding_thread_count + 1 ) - 16 * cm -> mb_cols ;x -> src . u_buffer += 8 * x -> src . uv_stride * ( cpi -> encoding_thread_count + 1 ) - 8 * cm -> mb_cols ;x -> src . v_buffer += 8 * x -> src . uv_stride * ( cpi -> encoding_thread_count + 1 ) - 8 * cm -> mb_cols ;xd -> mode_info_context += xd -> mode_info_stride * cpi -> encoding_thread_count ;x -> partition_info += xd -> mode_info_stride * cpi -> encoding_thread_count ;x -> gf_active_ptr += cm -> mb_cols * cpi -> encoding_thread_count ;if ( mb_row == cm -> mb_rows - 1 ) {sem_post ( & cpi -> h_event_end_encoding ) ;}}sem_wait ( & cpi -> h_event_end_encoding ) ;for ( mb_row = 0 ;mb_row < cm -> mb_rows ;mb_row ++ ) {cpi -> tok_count += ( unsigned int ) ( cpi -> tplist [ mb_row ] . stop - cpi -> tplist [ mb_row ] . start ) ;}if ( xd -> segmentation_enabled ) {",memset ( xd -> segmentation_enabled ) {,2832
502,"vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ;tot_count = segment_counts [ 0 ] + segment_counts [ 1 ] + segment_counts [ 2 ] + segment_counts [ 3 ] ;","vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ;tot_count = segment_counts [ 0 ] + segment_counts [ 1 ] + segment_counts [ 2 ] + segment_counts [ 3 ] ;",2832
503,const char command5 [ ] = {int s ;,"const char command5 [ ] = {const char bad_command4 [ ] = {0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f };int s ;",2833
504,"
",if ( n == 0 ) {,2833
505,"
","n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ;n = read ( s , buf , sizeof ( buf ) ) ;printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\\printresponse ( buf , n ) ;close ( s ) ;s = connect_unix_socket ( sockpath ) ;}",2833
506,close ( s ) ;return 0 ;},close ( s ) ;return 0 ;},2833
507,"
","if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;",2834
508,return self ;},return self ;},2834
509,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] ;int hsub = s -> draw . hsub [ plane ] ;,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] ;int hsub = s -> draw . hsub [ plane ] ;,2835
510,"struct flowi4 fl4 ;struct rtable * rt ;if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) )  return ;if ( ! IS_ERR ( rt ) )   __sk_dst_set ( sk , & rt -> dst ) ;rcu_read_unlock ( ) ;","struct dst_entry * dst ;struct flowi4 fl4 ;struct rtable * rt ;dst = __sk_dst_get ( sk ) ;if ( ! dst || ! dst -> obsolete || dst -> ops -> check ( dst , 0 ) ) {rcu_read_unlock ( ) ;return ;}dst = ! IS_ERR ( rt ) ) __sk_dst_set ( sk , & rt -> dst : NULL ;sk_dst_set ( sk , dst ) ;rcu_read_unlock ( ) ;",2836
511,"if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) {c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ;aligned_height = FFALIGN ( c -> height , 16 ) ;av_free ( c -> framebuf ) ;","if ( ! c -> framebuf || c -> old_width < c -> width + 15 , 16 ) ;aligned_height = FFALIGN ( c -> height , 16 ) ;av_free ( c -> framebuf ) ;",2837
512,"bool tsonly ;if ( ! sk ) return ;# ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP &&  sk -> sk_type == SOCK_STREAM )  skb = tcp_get_timestamping_opt_stats ( sk ) ;else  # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ;","bool tsonly , opt_stats = false ;if ( ! sk ) return ;# ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) {skb = tcp_get_timestamping_opt_stats ( sk ) ;opt_stats = true ;}else # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ;",2838
513,"__skb_complete_tx_timestamp ( skb , sk , tstype ) ;}","__skb_complete_tx_timestamp ( skb , sk , tstype , opt_stats ) ;}",2838
514,if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 &&  rdesc [ 106 ] == 0x03 ) {,if ( * rsize >= 112 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && rdesc [ 106 ] == 0x03 ) {,2839
515,"static vpx_codec_err_t vp8e_set_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_set_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2840
516,if ( c < 0 )  break ;* p ++ = ( unsigned char ) c ;if ( c < 0 )  break ;* p ++ = ( unsigned char ) c ;,"if ( c < 0 ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}* p ++ = ( unsigned char ) c ;if ( c < 0 ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}* p ++ = ( unsigned char ) c ;",2841
517,"size_t ss = CDF_SEC_SIZE ( h ) , i , j ;scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ;","size_t ss = CDF_SHORT_SEC_SIZE ( h ) , i , j ;scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ;",2842
518,"return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ;}","return TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ;}",2843
519,"a = 1.0f / MaxF ( w . x , MaxF ( w . y , w . z ) ) ;v . x = w . x * a ;","a = 1.0f / MagickMax ( w . x , MagickMax ( w . x , MaxF ( w . y , w . z ) ) ;v . x = w . x * a ;",2844
520,"static int jas_iccgetuint ( jas_stream_t * in , int n , ulonglong * val )  {ulonglong v ;v = 0 ;","static int jas_iccgetuint ( jas_stream_t * in , int n , jas_ulonglong * val ) {jas_ulonglong v ;v = 0 ;",2845
521,int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 )  / body -> unit_size ;,int n ;if ( ! body -> unit_size ) break ;n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) / body -> unit_size ;,2846
522,uint32 nstrips ;if ( td -> td_nstrips ) return td -> td_nstrips ;,uint32 nstrips ;,2847
523,"memccpy ( result , ptr , 0 , len ) ;return result ;","memcpy ( result , ptr , 0 , len ) ;return result ;",2848
524,"imap_quote_string ( dest , dlen , buf ) ;FREE ( & buf ) ;","imap_quote_string ( dest , dlen , buf , false ) ;FREE ( & buf ) ;",2849
525,ifd ++ ;break ;,ifd ++ ;# ifdef LIBRAW_LIBRARY_BUILD if ( ifd >= sizeof tiff_ifd / sizeof tiff_ifd [ 0 ] ) throw LIBRAW_EXCEPTION_IO_CORRUPT ;# endif break ;,2850
526,# endif if ( len > 1000 ) len = 1000 ;,# endif if ( len < 1 || len > 1000 ) len = 1000 ;,2850
527,case 50454 : case 50455 :  if ( len > 2560000 || ! ( cbuf = ( char * ) malloc ( len ) ) )  break ;,case 50454 : case 50455 : if ( len > 2560000 || ! ( cbuf = ( char * ) malloc ( len ) ) ) break ;,2850
528,"static int handle_emulation_failure ( struct kvm_vcpu * vcpu )  {++ vcpu -> stat . insn_emulation_fail ;trace_kvm_emulate_insn_failed ( vcpu ) ;vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;kvm_queue_exception ( vcpu , UD_VECTOR ) ;return EMULATE_FAIL ;}","+ vcpu -> stat . insn_emulation_fail ;static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) {int r = EMULATE_DONE ;++ vcpu -> stat . insn_emulation_fail ;trace_kvm_emulate_insn_failed ( vcpu ) ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;r = EMULATE_FAIL ;}kvm_queue_exception ( vcpu , UD_VECTOR ) ;return r ;}",2851
529,"# define COPY_PORT ( dest , src ) do {","if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) {dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\\return - ENODEV ;}# define COPY_PORT ( dest , src ) do {",2852
530,"swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ;","swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ;",2852
531,"err = 0 ;skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ;payload_len = dg -> payload_size ;if ( payload_len != skb -> len - sizeof ( * dg ) ) {err = - EINVAL ;goto out ;}if ( payload_len > len ) {payload_len = len ;msg -> msg_flags |= MSG_TRUNC ;}err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ;if ( err ) goto out ;msg -> msg_namelen = 0 ;if ( msg -> msg_name ) {","msg -> msg_namelen = 0 ;err = 0 ;skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ;if ( msg -> msg_name ) {",2853
532,"pixs = pixRead ( ""cat.035.jpg"" ) ;pixn = pixBackgroundNormSimple ( pixs , NULL , NULL ) ;","lept_rmdir ( ""lept/dewmod"" ) ;lept_mkdir ( ""lept/dewmod"" ) ;pixs = pixRead ( ""cat.035.jpg"" ) ;pixn = pixBackgroundNormSimple ( pixs , NULL , NULL ) ;",2854
533,"lept_stderr ( ""pdf<S2SV_blank>file<S2SV_blank>made:<S2SV_blank>/tmp/lept/model/dewarptest1.pdf\\\lept_rmdir ( ""lept/dewmod"" ) ;lept_rmdir ( ""lept/dewtest"" ) ;","lept_stderr ( ""pdf<S2SV_blank>file<S2SV_blank>made:<S2SV_blank>/tmp/lept/model/dewarptest1.pdf\\\",2854
534,"endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ;","if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) {dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\\err = - EINVAL ;goto fail3 ;}endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ;",2855
535,goto fail3 ;},err = - EINVAL ;goto fail3 ;},2855
536,"long newpos ;JAS_DBGLOG ( 100 , ( ""mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\\","size_t newpos ;JAS_DBGLOG ( 100 , ( ""mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\\",2856
537,"set_header ( res , ""Content-Type"" , mime ) ;}","set_header ( res , ""Content-Type"" , ""%s"" , mime ) ;}",2857
538,"FD_SET ( sock , & mset ) ;max = sock > max ? sock : max ;}}for ( i = 0 ;i < modernsocks -> len ;i ++ ) {int sock = g_array_index ( modernsocks , int , i ) ;FD_SET ( sock , & mset ) ;max = sock > max ? sock : max ;}for ( ;;) {if ( is_sighup_caught ) {int n ;GError * gerror = NULL ;msg ( LOG_INFO , ""reconfiguration<S2SV_blank>request<S2SV_blank>received"" ) ;is_sighup_caught = 0 ;n = append_new_servers ( servers , & gerror ) ;if ( n == - 1 ) msg ( LOG_ERR , ""failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>new<S2SV_blank>servers:<S2SV_blank>%s"" , gerror -> message ) ;for ( i = servers -> len - n ;i < servers -> len ;++ i ) {const SERVER server = g_array_index ( servers , SERVER , i ) ;if ( server . socket >= 0 ) {FD_SET ( server . socket , & mset ) ;max = server . socket > max ? server . socket : max ;}msg ( LOG_INFO , ""reconfigured<S2SV_blank>new<S2SV_blank>server:<S2SV_blank>%s"" , server . servename ) ;}}memcpy ( & rset , & mset , sizeof ( fd_set ) ) ;if ( select ( max + 1 , & rset , NULL , NULL , NULL ) > 0 ) {int net ;DEBUG ( ""accept,<S2SV_blank>"" ) ;","+ i ) {DEBUG ( ""accept,<S2SV_blank>"" ) ;",2858
539,"CLIENT * client ;if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) {err_nonfatal ( ""accept:<S2SV_blank>%m"" ) ;client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ;if ( ! client ) {","CLIENT * client ;if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) {err_nonfatal ( ""accept:<S2SV_blank>%m"" ) ;client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ;if ( ! client ) {",2858
540,sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ;if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ;,sc -> drefs_count = 0 ;sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ;if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ;,2859
541,"if ( ND_TTEST2 ( bp [ 0 ] , 30 ) && bp [ 11 ] == 1 && ( ( njoin = EXTRACT_16BITS ( & bp [ 20 ] ) ) + EXTRACT_16BITS ( & bp [ 22 ] ) ) == 1 ) {int hold ;ND_PRINT ( ( ndo , ""<S2SV_blank>RPF<S2SV_blank>%s<S2SV_blank>"" , ipaddr_string ( ndo , bp ) ) ) ;hold = EXTRACT_16BITS ( & bp [ 6 ] ) ;if ( hold != 180 ) {ND_PRINT ( ( ndo , ""Hold<S2SV_blank>"" ) ) ;unsigned_relts_print ( ndo , hold ) ;}ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%s/%d,<S2SV_blank>%s"" , njoin ? ""Join"" : ""Prune"" , ipaddr_string ( ndo , & bp [ 26 ] ) , bp [ 25 ] & 0x3f , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ;if ( EXTRACT_32BITS ( & bp [ 16 ] ) != 0xffffffff ) ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 16 ] ) ) ) ;ND_PRINT ( ( ndo , "")<S2SV_blank>%s%s<S2SV_blank>%s"" , ( bp [ 24 ] & 0x01 ) ? ""Sparse"" : ""Dense"" , ( bp [ 25 ] & 0x80 ) ? ""<S2SV_blank>WC"" : """" , ( bp [ 25 ] & 0x40 ) ? ""RP"" : ""SPT"" ) ) ;return ;}ND_TCHECK2 ( bp [ 0 ] , sizeof ( struct in_addr ) ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""<S2SV_blank>Upstream<S2SV_blank>Nbr:<S2SV_blank>%s"" , ipaddr_string ( ndo , bp ) ) ) ;ND_TCHECK2 ( bp [ 6 ] , 2 ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 6 ] ) ) ;if ( ndo -> ndo_vflag < 2 ) return ;bp += 8 ;len -= 8 ;ND_TCHECK2 ( bp [ 0 ] , 4 ) ;ND_TCHECK2 ( bp [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( bp [ 4 ] , sizeof ( struct in_addr ) ) ;if ( EXTRACT_32BITS ( & bp [ 4 ] ) != 0xffffffff )   ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 4 ] ) ) ) ;ND_TCHECK2 ( bp [ 8 ] , 4 ) ;njoin = EXTRACT_16BITS ( & bp [ 8 ] ) ;nprune = EXTRACT_16BITS ( & bp [ 10 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>joined:<S2SV_blank>%d<S2SV_blank>pruned:<S2SV_blank>%d"" , njoin , nprune ) ) ;bp += 12 ;len -= 12 ;for ( njp = 0 ;ND_TCHECK2 ( bp [ 0 ] , 6 ) ;ND_PRINT ( ( ndo , ""\\\bp += 6 ;","if ( ND_TTEST2 ( bp [ 2 ] , 2 ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 6 ] ) ) ;if ( ndo -> ndo_vflag < 2 ) return ;bp += 8 ;len -= 8 ;ND_TCHECK2 ( bp [ 0 ] , 4 ) ;ND_TCHECK2 ( bp [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( bp [ 4 ] , sizeof ( struct in_addr ) ) ;if ( EXTRACT_32BITS ( & bp [ 4 ] ) != 0xffffffff ) ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 4 ] ) ) ) ;ND_TCHECK2 ( bp [ 8 ] , 4 ) ;njoin = EXTRACT_16BITS ( & bp [ 8 ] ) ;nprune = EXTRACT_16BITS ( & bp [ 10 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>joined:<S2SV_blank>%d<S2SV_blank>pruned:<S2SV_blank>%d"" , njoin , nprune ) ) ;bp += 12 ;len -= 12 ;for ( njp = 0 ;ND_TCHECK2 ( bp [ 0 ] , 6 ) ;ND_PRINT ( ( ndo , ""\\\bp += 4 ;bp += 4 ;len -= 4 ;if ( len < 4 ) goto trunc ;",2860
542,"static void sas_destruct_devices ( struct work_struct * work )  {struct domain_device * dev , * n ;struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ;struct asd_sas_port * port = ev -> port ;clear_bit ( DISCE_DESTRUCT , & port -> disc . pending ) ;","void sas_destruct_devices ( struct work_struct * work ) {struct domain_device * dev , * n ;",2861
543,"int number_bidders , i , bid , best_bid ;struct archive_read_filter_bidder * bidder , * best_bidder ;for ( ;;) {number_bidders = sizeof ( a -> bidders ) / sizeof ( a -> bidders [ 0 ] ) ;","int number_bidders , i , bid , best_bid , n ;struct archive_read_filter_bidder * bidder , * best_bidder ;for ( n = 0 ;n < 25 ;++ n ) {number_bidders = sizeof ( a -> bidders ) / sizeof ( a -> bidders [ 0 ] ) ;",2862
544,"
","archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding"" ) ;return ( ARCHIVE_FATAL ) ;",2862
545,},},2862
546,flush_dcache_page ( page ) ;if ( ! tmp ) {,"iov_iter_advance ( ii , tmp ) ;flush_dcache_page ( page ) ;if ( ! tmp ) {",2863
547,"iov_iter_advance ( ii , tmp ) ;count += tmp ;",count += tmp ;,2863
548,numSamples = pWTIntFrame -> numSamples ;pOutputBuffer = pWTIntFrame -> pAudioBuffer ;,"numSamples = pWTIntFrame -> numSamples ;if ( numSamples <= 0 ) {ALOGE ( ""b/26366256"" ) ;return ;}pOutputBuffer = pWTIntFrame -> pAudioBuffer ;",2864
549,"RING_IDX cons = vif -> tx . req_cons ;int frags = 0 ;if ( ! ( first -> flags & XEN_NETTXF_more_data ) ) return 0 ;do {if ( frags >= work_to_do ) {netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\\return - frags ;netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\\return - frags ;","netdev_err ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\\netbk_fatal_tx_err ( vif ) ;return - frags ;netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\\return - frags ;netdev_err ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\\netbk_fatal_tx_err ( vif ) ;return - frags ;",2865
550,qemu_vfree ( r -> iov . iov_base ) ;},if ( r -> iov . iov_base ) {qemu_vfree ( r -> iov . iov_base ) ;}},2866
551,"if ( ! ( dev -> flags & IFF_UP ) )  return NET_RX_DROP ;if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) )   return NET_RX_DROP ;skb_set_dev ( skb , dev ) ;","if ( ! ( dev -> flags & IFF_UP ) || ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) ) {kfree_skb ( skb ) ;return NET_RX_DROP ;}skb_set_dev ( skb , dev ) ;",2867
552,"int ret , n ;quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ;","int ret , n ;int num_descriptors ;size_t offset = offsetof ( struct hid_descriptor , desc ) ;quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ;",2868
553,hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ;hid -> country = hdesc -> bCountryCode ;for ( n = 0 ;n < hdesc -> bNumDescriptors ;n ++ )  if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ;,"if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) {dbg_hid ( ""hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\\return - EINVAL ;}hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ;hid -> country = hdesc -> bCountryCode ;num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) ;for ( n = 0 ;n < num_descriptors ;n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ;",2868
554,"void vp9_iht16x16_256_add_c ( const int16_t * input , uint8_t * dest , int stride ,  int tx_type ) {int16_t out [ 16 * 16 ] ;int16_t * outptr = out ;int16_t temp_in [ 16 ] , temp_out [ 16 ] ;const transform_2d ht = IHT_16 [ tx_type ] ;","void vp9_iht16x16_256_add_c ( const tran_low_t * input , uint8_t * dest , int stride , int tx_type ) {tran_low_t out [ 16 * 16 ] ;tran_low_t * outptr = out ;int16_t temp_in [ 16 ] , temp_out [ 16 ] ;const transform_2d ht = IHT_16 [ tx_type ] ;",2869
555,"++ j ) temp_in [ j ] = out [ j * 16 + i ] ;for ( j = 0 ;++ j )   dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 )   + dest [ j * stride + i ] ) ;}","+ j ) temp_in [ j ] = out [ j * 16 + i ] ;++ j ) {temp_in [ j ] = out [ j * 16 + i ] ;for ( j = 0 ;+ j )   dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 )   + dest [ j * stride + i ] ) ;++ j ) dest [ j * stride + i ] = clip_pixel_add ( dest [ j * stride + i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) ) ;}}",2869
556,"memset ( sax , 0 , sizeof ( sax ) ) ;sax -> sax25_family = AF_NETROM ;","memset ( sax , 0 , sizeof ( * sax ) ) ;sax -> sax25_family = AF_NETROM ;",2870
557,for ( j = 0 ;j < book -> dim ;j ++ )  a [ i ++ ] = v [ j ] ;,for ( j = 0 ;j < book -> dim && i < n ;j ++ ) a [ i ++ ] = v [ j ] ;,2871
558,for ( j = 0 ;j < book -> dim ;j ++ )  a [ i ++ ] = 0 ;,for ( j = 0 ;j < book -> dim && i < n ;j ++ ) a [ i ++ ] = 0 ;,2871
559,zip_object_handlers . get_properties = php_zip_get_properties ;zip_object_handlers . read_property = php_zip_read_property ;,zip_object_handlers . get_gc = php_zip_get_gc ;zip_object_handlers . get_properties = php_zip_get_properties ;zip_object_handlers . read_property = php_zip_read_property ;,2872
560,"case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ;","case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN + 4 ) ;",2873
561,pptr += BGP_VPN_RD_LEN ;,pptr += BGP_VPN_RD_LEN + 4 ;,2873
562,"case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN : case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN :  ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ;offset = strlen ( buf ) ;pptr += BGP_VPN_RD_LEN ;bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ;","case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN : case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ;offset = strlen ( buf ) ;pptr += BGP_VPN_RD_LEN ;bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ;",2873
563,"}commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ;","}if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ;",2874
564,"if ( ent != NULL ) {if ( ( st = populate_policy ( context , ld , ent , pol_name , * policy ) ) != 0 ) goto cleanup ;cleanup :  ldap_msgfree ( result ) ;","if ( ent == NULL ) {st = KRB5_KDB_NOENTRY ;goto cleanup ;st = populate_policy ( context , ld , ent , pol_name , * policy ) ;cleanup : ldap_msgfree ( result ) ;",2875
565,"static void sas_probe_devices ( struct work_struct * work )  {struct domain_device * dev , * n ;struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ;struct asd_sas_port * port = ev -> port ;clear_bit ( DISCE_PROBE , & port -> disc . pending ) ;","static void sas_probe_devices ( struct asd_sas_port * port ) {struct domain_device * dev , * n ;",2876
566,if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls >  JAS_UINTFAST32_NUMBITS - 2 ||  pirlvl -> prcheightexpn + pi -> picomp -> numrlvls >  JAS_UINTFAST32_NUMBITS - 2 ) {,if ( pirlvl -> prcwidthexpn + picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {,2877
567,"char * ext_name = NULL ;struct sshbuf * b = NULL ;goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}break ;case SSH_AGENT_CONSTRAIN_EXTENSION :  if ( ( r = sshbuf_get_cstring ( m , & ext_name , NULL ) ) != 0 ) {error_fr ( r , ""parse<S2SV_blank>constraint<S2SV_blank>extension"" ) ;goto err ;}debug_f ( ""constraint<S2SV_blank>ext<S2SV_blank>%s"" , ext_name ) ;if ( strcmp ( ext_name , ""sk-provider@openssh.com"" ) == 0 ) {if ( sk_providerp == NULL ) {error_f ( ""%s<S2SV_blank>not<S2SV_blank>valid<S2SV_blank>here"" , ext_name ) ;goto err ;}if ( * sk_providerp != NULL ) {error_f ( ""%s<S2SV_blank>already<S2SV_blank>set"" , ext_name ) ;goto err ;}if ( ( r = sshbuf_get_cstring ( m , sk_providerp , NULL ) ) != 0 ) {error_fr ( r , ""parse<S2SV_blank>%s"" , ext_name ) ;goto err ;}else {error_f ( ""unsupported<S2SV_blank>constraint<S2SV_blank>\\\\""%s\\\\"""" , ext_name ) ;goto err ;}free ( ext_name ) ;err :  free ( ext_name ) ;sshbuf_free ( b ) ;return - 1 ;return 0 ;","goto out ;}r = SSH_ERR_INVALID_FORMAT ;goto out ;}goto out ;}r = SSH_ERR_INVALID_FORMAT ;goto out ;}r = SSH_ERR_INVALID_FORMAT ;goto out ;}r = SSH_ERR_INVALID_FORMAT ;goto out ;}goto out ;}goto out ;break ;case SSH_AGENT_CONSTRAIN_EXTENSION : if ( ( r = parse_key_constraint_extension ( m , sk_providerp ) ) != 0 ) goto out ;r = SSH_ERR_FEATURE_UNSUPPORTED ;goto out ;r = 0 ;out : return r ;",2878
568,"sprintf ( url_address , ""%.*s"" , url_len , url_begin ) ;if ( port_len ) snprintf ( port , 6 , ""%.*s"" , port_len , port_start ) ;","if ( url_len >= sizeof ( url_address ) ) {applog ( LOG_WARNING , ""%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\\\'%.*s\\\'"" , __func__ , url_len , url_begin ) ;url_len = sizeof ( url_address ) - 1 ;}sprintf ( url_address , ""%.*s"" , url_len , url_begin ) ;if ( port_len ) snprintf ( port , 6 , ""%.*s"" , port_len , port_start ) ;",2879
569,"static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si ,  vp8_decrypt_cb * decrypt_cb ,  void * decrypt_state ) {","static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) {",2880
570,"int n = data_sz > 10 ? 10 : data_sz ;decrypt_cb ( decrypt_state , data , clear_buffer , n ) ;if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a )  res = VPX_CODEC_UNSUP_BITSTREAM ;si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ;","int n = MIN ( sizeof ( clear_buffer ) , data_sz ) ;decrypt_cb ( decrypt_state , data , clear_buffer , n ) ;if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a ) return VPX_CODEC_UNSUP_BITSTREAM ;si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ;",2880
571,"addr . sun_family = AF_UNIX ;strcpy ( addr . sun_path , sockFile ) ;","addr . sun_family = AF_UNIX ;if ( strlen ( sockFile ) + 1 > sizeof ( addr . sun_path ) ) {rfbClientErr ( ""ConnectToUnixSock:<S2SV_blank>socket<S2SV_blank>file<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long\\\return - 1 ;}strcpy ( addr . sun_path , sockFile ) ;",2881
572,prev = NULL ;for ( vma = mm -> mmap ;,if ( ! mmget_still_valid ( mm ) ) goto skip_mm ;prev = NULL ;for ( vma = mm -> mmap ;,2882
573,up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,skip_mm : up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,2882
574,"if ( ret )  return IMPEG2D_MB_TEX_DECODE_ERR ;IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ;","if ( ret ) return IMPEG2D_MB_TEX_DECODE_ERR ;if ( 0 >= ps_dec -> u2_num_mbs_left ) {break ;}IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ;",2883
575,"vpx_memset ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ;}","memset ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ;}",2884
576,"vpx_memset ( l , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ;}","memset ( l , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ;}",2884
577,"else if ( eobs [ 0 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}else if ( eobs [ 1 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dst + 4 , stride , dst + 4 , stride ) ;vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}else if ( eobs [ 2 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 32 ] * dq [ 0 ] , dst + 8 , stride , dst + 8 , stride ) ;vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}else if ( eobs [ 3 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 48 ] * dq [ 0 ] , dst + 12 , stride , dst + 12 , stride ) ;vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",2885
578,"REMOVE_BITS ( 16 ) ;}if ( ! lzx -> header_read ) {j = 0 ;READ_BITS ( i , 1 ) ;if ( i ) {READ_BITS ( i , 16 ) ;READ_BITS ( j , 16 ) ;}lzx -> intel_filesize = ( i << 16 ) | j ;lzx -> header_read = 1 ;}frame_size = LZX_FRAME_SIZE ;if ( lzx -> length && ( lzx -> length - lzx -> offset ) < ( off_t ) frame_size ) {frame_size = lzx -> length - lzx -> offset ;}bytes_todo = lzx -> frame_posn + frame_size - window_posn ;while ( bytes_todo > 0 ) {if ( lzx -> block_remaining == 0 ) {if ( ( lzx -> block_type == LZX_BLOCKTYPE_UNCOMPRESSED ) && ( lzx -> block_length & 1 ) ) {READ_IF_NEEDED ;i_ptr ++ ;}READ_BITS ( lzx -> block_type , 3 ) ;READ_BITS ( i , 16 ) ;READ_BITS ( j , 8 ) ;lzx -> block_remaining = lzx -> block_length = ( i << 8 ) | j ;switch ( lzx -> block_type ) {case LZX_BLOCKTYPE_ALIGNED : for ( i = 0 ;i < 8 ;i ++ ) {READ_BITS ( j , 3 ) ;lzx -> ALIGNED_len [ i ] = j ;}BUILD_TABLE ( ALIGNED ) ;case LZX_BLOCKTYPE_VERBATIM : READ_LENGTHS ( MAINTREE , 0 , 256 ) ;READ_LENGTHS ( MAINTREE , 256 , LZX_NUM_CHARS + lzx -> num_offsets ) ;BUILD_TABLE ( MAINTREE ) ;if ( lzx -> MAINTREE_len [ 0xE8 ] != 0 ) lzx -> intel_started = 1 ;READ_LENGTHS ( LENGTH , 0 , LZX_NUM_SECONDARY_LENGTHS ) ;BUILD_TABLE_MAYBE_EMPTY ( LENGTH ) ;break ;case LZX_BLOCKTYPE_UNCOMPRESSED : lzx -> intel_started = 1 ;ENSURE_BITS ( 16 ) ;if ( bits_left > 16 ) i_ptr -= 2 ;","
",2886
579,"static void nsc_rle_decompress_data ( NSC_CONTEXT * context )  {rle = context -> Planes ;for ( i = 0 ;if ( planeSize == 0 )  FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ;else if ( planeSize < originalSize )   nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ;else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ;rle += planeSize ;}}","static BOOL nsc_rle_decompress_data ( NSC_CONTEXT * context ) {if ( ! context ) return FALSE ;rle = context -> Planes ;for ( i = 0 ;if ( planeSize == 0 ) {if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ;FillMemory ( context -> priv -> PlaneBuffers [ i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ;}else {if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ;CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ;}rle += planeSize ;}return TRUE ;}",2887
580,"struct sctp_endpoint * ep ;struct sctp_association * asoc ;struct list_head * pos , * temp ;unsigned int data_was_unread ;pr_debug ( ""%s:<S2SV_blank>sk:%p,<S2SV_blank>timeout:%ld\\\lock_sock ( sk ) ;sk -> sk_shutdown = SHUTDOWN_MASK ;sk -> sk_state = SCTP_SS_CLOSING ;ep = sctp_sk ( sk ) -> ep ;data_was_unread = sctp_queue_purge_ulpevents ( & sk -> sk_receive_queue ) ;data_was_unread += sctp_queue_purge_ulpevents ( & sctp_sk ( sk ) -> pd_lobby ) ;list_for_each_safe ( pos , temp , & ep -> asocs ) {asoc = list_entry ( pos , struct sctp_association , asocs ) ;if ( sctp_style ( sk , TCP ) ) {if ( sctp_state ( asoc , CLOSED ) ) {sctp_unhash_established ( asoc ) ;sctp_association_free ( asoc ) ;continue ;}}if ( data_was_unread || ! skb_queue_empty ( & asoc -> ulpq . lobby ) || ! skb_queue_empty ( & asoc -> ulpq . reasm ) || ( sock_flag ( sk , SOCK_LINGER ) && ! sk -> sk_lingertime ) ) {struct sctp_chunk * chunk ;chunk = sctp_make_abort_user ( asoc , NULL , 0 ) ;if ( chunk ) sctp_primitive_ABORT ( net , asoc , chunk ) ;}else sctp_primitive_SHUTDOWN ( net , asoc , NULL ) ;}if ( sctp_style ( sk , TCP ) && timeout ) sctp_wait_for_close ( sk , timeout ) ;release_sock ( sk ) ;local_bh_disable ( ) ;bh_lock_sock ( sk ) ;local_bh_enable ( ) ;sock_put ( sk ) ;",spin_lock_bh ( & net -> sctp . addr_wq_lock ) ;bh_lock_sock ( sk ) ;local_bh_enable ( ) ;sock_put ( sk ) ;,2888
581,"x < ( ( ssize_t ) image -> columns - 7 ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;}",x < ( ( ssize_t ) image -> columns - 3 ) ;,2889
582,for ( x = 0 ;x += 4 )  {,for ( x = 0 ;x += 4 ) {,2889
583,"p ++ ;q += GetPixelChannels ( image ) ;}if ( ( image -> columns % 4 ) != 0 ) {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;if ( ( image -> columns % 4 ) >= 1 )  {if ( ( image -> columns % 4 ) >= 2 )  {",p ++ ;}if ( ( image -> columns % 4 ) > 1 ) {if ( ( image -> columns % 4 ) >= 2 ) {,2889
584,const struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct tcp6_sock * newtcp6sk ;,const struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6_txoptions * opt ;struct tcp6_sock * newtcp6sk ;,2890
585,newnp -> saddr = newsk -> sk_v6_rcv_saddr ;inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ;newsk -> sk_backlog_rcv = tcp_v4_do_rcv ;# ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ;# endif newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> pktoptions = NULL ;newnp -> opt = NULL ;newnp -> mcast_oif = tcp_v6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ;if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ;,opt = rcu_dereference ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ;,2890
586,"if ( np -> opt )   newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ;inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ;if ( newnp -> opt )   inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen +   newnp -> opt -> opt_flen ) ;tcp_ca_openreq_child ( newsk , dst ) ;","if ( np -> opt ) ;if ( opt ) {opt = ipv6_dup_options ( newsk , opt ) ;RCU_INIT_POINTER ( newnp -> opt , opt ) ;}inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ;if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + newnp -> opt -> opt_flen ;tcp_ca_openreq_child ( newsk , dst ) ;",2890
587,"static int cost_mv_ref ( const VP9_COMP * cpi , MB_PREDICTION_MODE mode ,   int mode_context ) {const MACROBLOCK * const x = & cpi -> mb ;return x -> inter_mode_cost [ mode_context ] [ INTER_OFFSET ( mode ) ] ;}else {return 0 ;}","static int cost_mv_ref ( const VP9_COMP * cpi , PREDICTION_MODE mode , int mode_context ) {const MACROBLOCK * const x = & cpi -> mb ;return cpi -> inter_mode_cost [ mode_context ] [ INTER_OFFSET ( mode ) ] ;",2891
588,"register u_int amt ;register u_int i ;int j ;int trunc ;if ( ndo -> ndo_snapend < dat ) return ;amt = ndo -> ndo_snapend - dat ;i = min ( length , amt ) ;if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ;i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ;case RIP6_REQUEST :  j = length / sizeof ( * ni ) ;if ( j == 1  && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6  && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) {if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:"" , j , length ) ) ;else  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\break ;case RIP6_RESPONSE :  j = length / sizeof ( * ni ) ;if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;i >= sizeof ( * ni ) ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\if ( trunc )  ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ;}if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;}","unsigned int length_left ;u_int j ;ND_TCHECK ( rp -> rip6_cmd ) ;case RIP6_REQUEST : j = length / sizeof ( * ni ) ;if ( j == 1 && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) {}if ( j * sizeof ( * ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length ) ) ;else ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) ) ;for ( ni = rp -> rip6_nets ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\break ;case RIP6_RESPONSE : j = length / sizeof ( * ni ) ;if ( j * sizeof ( * ni ) != length - 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;length_left >= sizeof ( * ni ) ;length_left -= sizeof ( * ni ) , ++ ni ) {ND_TCHECK ( * ni ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\if ( length_left != 0 ) goto trunc ;}ND_TCHECK ( rp -> rip6_vers ) ;if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;return ;trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ;return ;}",2892
589,if ( ! alt )  return - ENODEV ;,if ( ! alt ) return - ENODEV ;if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;,2893
590,"if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\","if ( q < p || q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\",2894
591,if ( ( ldblk > 9999 ) || ( ldblk < 0 ) )  break ;,if ( EOFBlob ( image ) ) break ;if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) break ;,2895
592,"}ui_seamless_seticon ( id , tok5 , width , height , chunk , icon_buf , len ) ;","if ( ( size_t ) len >= sizeof ( icon_buf ) ) {logger ( Protocol , Warning , ""seamless_process_line(),<S2SV_blank>icon<S2SV_blank>data<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>icon_buf"" ) ;break ;}}ui_seamless_seticon ( id , tok5 , width , height , chunk , icon_buf , len ) ;",2896
593,uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( cc % ( bps * stride ) != 0 ) {if ( ! tmp )  return 0 ;,uint8 * tmp ;if ( cc % ( bps * stride ) != 0 ) {tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ! tmp ) return 0 ;,2897
594,"if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  if ( copy_from_user ( & ifr , argp , ifreq_len ) )  return - EFAULT ;if ( cmd == TUNGETFEATURES ) {","if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) {if ( copy_from_user ( & ifr , argp , ifreq_len ) ) return - EFAULT ;}else memset ( & ifr , 0 , sizeof ( ifr ) ) ;if ( cmd == TUNGETFEATURES ) {",2898
595,"char src [ PATH_MAX + 1 ] ;memcpy ( src , dir , dir_len ) ;src [ dir_len ] = 0 ;return NULL ;}return dst ;","if ( dir_len > PATH_MAX ) {uwsgi_log ( ""invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\\return NULL ;}char * src = uwsgi_concat2n ( dir , dir_len , """" , 0 ) ;free ( src ) ;return NULL ;}free ( src ) ;return dst ;",2899
596,"const int w = vpx_img_plane_width ( img , plane ) ;const int h = vpx_img_plane_height ( img , plane ) ;","const int w = vpx_img_plane_width ( img , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ;const int h = vpx_img_plane_height ( img , plane ) ;",2900
597,"err = device_register ( & bus -> dev ) ;if ( err ) {pr_err ( ""mii_bus<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register\\\put_device ( & bus -> dev ) ;return - EINVAL ;",return - EINVAL ;,2901
598,"vpx_memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ;}","memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ;}",2902
599,default :  OVS_NOT_REACHED ( ) ;}default :  OVS_NOT_REACHED ( ) ;},default : return OFPERR_OFPGMFC_BAD_TYPE ;}default : return OFPERR_OFPGMFC_BAD_COMMAND ;},2903
600,if ( ack -> subh . addip_hdr -> serial == serial ) {sctp_chunk_hold ( ack ) ;,if ( sctp_chunk_pending ( ack ) ) continue ;if ( ack -> subh . addip_hdr -> serial == serial ) {sctp_chunk_hold ( ack ) ;,2904
601,"struct mb_cache_entry * ce ;if ( ! header -> h_hash ) return NULL ;again :  ce = mb_cache_entry_find_first ( ext2_xattr_cache , inode -> i_sb -> s_bdev ,  hash ) ;if ( IS_ERR ( ce ) ) {if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ;break ;}ext2_error ( inode -> i_sb , ""ext2_xattr_cache_find"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%ld<S2SV_blank>read<S2SV_blank>error"" ,  inode -> i_ino , ( unsigned long ) ce -> e_block ) ;}","struct mb2_cache_entry * ce ;struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache ;if ( ! header -> h_hash ) return NULL ;again : ce = mb2_cache_entry_find_first ( ext2_mb_cache , hash ) ;ext2_error ( inode -> i_sb , ""ext2_xattr_cache_find"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%ld<S2SV_blank>read<S2SV_blank>error"" , inode -> i_ino , ( unsigned long ) ce -> e_block ) ;}else {lock_buffer ( bh ) ;if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) {mb2_cache_entry_put ( ext2_mb_cache , ce ) ;unlock_buffer ( bh ) ;brelse ( bh ) ;goto again ;}else if ( le32_to_cpu ( HDR ( bh ) -> h_refcount ) > EXT2_XATTR_REFCOUNT_MAX ) {ea_idebug ( inode , ""block<S2SV_blank>%ld<S2SV_blank>refcount<S2SV_blank>%d>%d"" , ( unsigned long ) ce -> e_block ) ;}",2905
602,"mb_cache_entry_release ( ce ) ;return bh ;ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ;}","mb2_cache_entry_touch ( ext2_mb_cache , ce ) ;mb2_cache_entry_put ( ext2_mb_cache , ce ) ;return bh ;ce = mb2_cache_entry_find_next ( ext2_mb_cache , ce ) ;}",2905
603,"if ( skb -> protocol == htons ( ETH_P_IP ) ) return tcp_v4_do_rcv ( sk , skb ) ;if ( sk_filter ( sk , skb ) )  goto discard ;","if ( tcp_filter ( sk , skb ) ;if ( sk_filter ( sk , skb ) ) goto discard ;",2906
604,"for ( plane = 0 ;if ( ! x -> skip_recode ) vp9_subtract_plane ( x , bsize , plane ) ;const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) : mbmi -> tx_size ;vp9_get_entropy_contexts ( bsize , tx_size , pd , ctx . ta [ plane ] , ctx . tl [ plane ] ) ;","mbmi -> skip = 1 ;if ( x -> skip ) return ;for ( plane = 0 ;if ( ! x -> skip_recode ) vp9_subtract_plane ( x , bsize , plane ) ;const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi , pd ) : mbmi -> tx_size ;vp9_get_entropy_contexts ( bsize , tx_size , pd , ctx . ta [ plane ] , ctx . tl [ plane ] ) ;",2907
605,"memmove ( s + j , s + qs , blen - qs ) ;j += blen - qs ;}","const int qslen = blen - qs ;memmove ( s + j , s + qs , ( size_t ) qslen ) ;qs = j ;j += qslen ;}",2908
606,if ( sec_attr == NULL ) {if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ;,if ( sec_attr == NULL || sec_attr_len ) {if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ;,2909
607,"U2FHID_INIT_RESP initresp ;if ( resplen > sizeof ( initresp ) )  {return U2FH_MEMORY_ERROR ;memcpy ( & initresp , resp , resplen ) ;dev -> cid = initresp . cid ;dev -> versionInterface = initresp . versionInterface ;dev -> versionMajor = initresp . versionMajor ;dev -> versionMinor = initresp . versionMinor ;dev -> capFlags = initresp . capFlags ;}","int offs = sizeof ( nonce ) ;if ( resplen < 17 ) {return U2FH_SIZE_ERROR ;}if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) {return U2FH_TRANSPORT_ERROR ;}dev -> cid = resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ;offs += 4 ;dev -> versionInterface = resp [ offs ++ ] ;dev -> versionMajor = resp [ offs ++ ] ;dev -> versionMinor = resp [ offs ++ ] ;dev -> versionBuild = resp [ offs ++ ] ;dev -> capFlags = resp [ offs ++ ] ;",2910
608,while ( f != upto ) ;},while ( f && f != upto ) ;},2911
609,"hash_param . data = 0 ;hash_param . len = 0 ;hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ;","hash_param . data = instance -> private_key ;hash_param . len = instance -> private_key_len ;hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ;",2912
610,ctxt -> dst . type = OP_REG ;ctxt -> dst . addr . reg = & ctxt -> _eip ;ctxt -> dst . bytes = ctxt -> op_bytes ;return em_pop ( ctxt ) ;,"int rc ;unsigned long eip ;rc = emulate_pop ( ctxt , & eip , ctxt -> op_bytes ;return em_pop ( ctxt ) ;",2913
611,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,2914
612,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",2914
613,"spin_lock ( & key -> user -> lock ) ;key -> user -> qnkeys -- ;key -> user -> qnbytes -= key -> quotalen ;spin_unlock ( & key -> user -> lock ) ;}atomic_dec ( & key -> user -> nkeys ) ;if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) atomic_dec ( & key -> user -> nikeys ) ;key_user_put ( key -> user ) ;if ( key -> type -> destroy ) key -> type -> destroy ( key ) ;",spin_lock ( & key -> user ) ;,2915
614,"static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int nodigest , int nocontent )  {wfd = Fopen ( dest , ""w.ufdio"" ) ;umask ( old_umask ) ;}","static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int exclusive , int nodigest , int nocontent ) {wfd = Fopen ( dest , exclusive ? ""wx.ufdio"" : ""a.ufdio"" ) ;umask ( old_umask ) ;if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) {rc = RPMERR_OPEN_FAILED ;goto exit ;}}",2916
615,"int rose_parse_facilities ( unsigned char * p ,  struct rose_facilities_struct * facilities ) {if ( facilities_len == 0 )  return 0 ;while ( facilities_len > 0 ) {if ( * p == 0x00 ) {if ( len < 0 )  return 0 ;facilities_len -= len + 1 ;p += len + 1 ;if ( len < 0 )  return 0 ;facilities_len -= len + 1 ;p += len + 1 ;break ;default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\\facilities_len -- ;p ++ ;else break ;}return 1 ;","int rose_parse_facilities ( unsigned char * p , unsigned packet_len , struct rose_facilities_struct * facilities ) {if ( facilities_len == 0 || ( unsigned ) facilities_len > packet_len ) return 0 ;while ( facilities_len >= 3 && * p == 0x00 ) {break ;default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\\len = 1 ;if ( len < 0 ) return 0 ;if ( WARN_ON ( len >= facilities_len ) ) return 0 ;facilities_len -= len + 1 ;return facilities_len == 0 ;",2917
616,"if ( ! ( segment -> flags & TCP_FLAG_RST ) )  tcpSendSegment ( socket , TCP_FLAG_ACK , socket -> sndNxt , socket -> rcvNxt , 0 , FALSE ) ;return ERROR_FAILURE ;","if ( ! ( segment -> flags & TCP_FLAG_RST ) ) {tcpSendSegment ( socket , TCP_FLAG_ACK , socket -> sndNxt , socket -> rcvNxt , 0 , FALSE ) ;}return ERROR_FAILURE ;",2918
617,"int y4m_write_file_header ( char * buf , size_t len , int width , int height , const struct VpxRational * framerate ,  vpx_img_fmt_t fmt ) {const char * const color = fmt == VPX_IMG_FMT_444A ? ""C444alpha\\\return snprintf ( buf , len , ""YUV4MPEG2<S2SV_blank>W%u<S2SV_blank>H%u<S2SV_blank>F%u:%u<S2SV_blank>I%c<S2SV_blank>%s"" , width , height , framerate -> numerator , framerate -> denominator , \'p\' , color ) ;","int y4m_write_file_header ( char * buf , size_t len , int width , int height , const struct VpxRational * framerate , vpx_img_fmt_t fmt , unsigned int bit_depth ) {const char * color ;switch ( bit_depth ) {case 8 : color = fmt == VPX_IMG_FMT_444A ? ""C444alpha\\\break ;case 9 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p9<S2SV_blank>XYSCSS=444P9\\\break ;case 10 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p10<S2SV_blank>XYSCSS=444P10\\\break ;case 12 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p12<S2SV_blank>XYSCSS=444P12\\\break ;case 14 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p14<S2SV_blank>XYSCSS=444P14\\\break ;case 16 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p16<S2SV_blank>XYSCSS=444P16\\\break ;default : color = NULL ;assert ( 0 ) ;}return snprintf ( buf , len , ""YUV4MPEG2<S2SV_blank>W%u<S2SV_blank>H%u<S2SV_blank>F%u:%u<S2SV_blank>I%c<S2SV_blank>%s"" , width , height , framerate -> numerator , framerate -> denominator , \'p\' , color ) ;",2919
618,const VP9_CONFIG * oxcf = & cpi -> oxcf ;if ( oxcf -> rc_max_intra_bitrate_pct ) {const int max_rate = rc -> av_per_frame_bandwidth *  oxcf -> rc_max_intra_bitrate_pct / 100 ;,const VP9EncoderConfig * oxcf = & cpi -> oxcf ;if ( oxcf -> rc_max_intra_bitrate_pct ) {const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_intra_bitrate_pct / 100 ;,2920
619,"if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) {log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , out -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ;","if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS ) {log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , out -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ;",2921
620,"if ( flags & __GFP_ZERO )  memset ( addr , 0 , size ) ;","memset ( addr , 0 , size ) ;",2922
621,static SvcInternal * get_svc_internal ( SvcContext * svc_ctx ) {if ( svc_ctx == NULL ) return NULL ;SvcInternal * const si = ( SvcInternal * ) malloc ( sizeof ( * si ) ) ;if ( si != NULL ) {return ( SvcInternal * ) svc_ctx -> internal ;},static SvcInternal_t * get_svc_internal ( SvcContext * svc_ctx ) {if ( svc_ctx == NULL ) return NULL ;SvcInternal_t * const si = ( SvcInternal * ) malloc ( sizeof ( * si ) ) ;if ( si != NULL ) {return ( SvcInternal_t * ) svc_ctx -> internal ;},2923
622,"baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ;baswap ( ( void * ) src , & l2cap_pi ( sock -> sk ) -> chan -> src ) ;","if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ;baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ;baswap ( ( void * ) src , & l2cap_pi ( sock -> sk ) -> chan -> src ) ;",2924
623,"else  jsWarn ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\\}","else {jsExceptionHere ( JSET_ERROR , ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\\return 0 ;}if ( gfx . data . height & 7 ) {jsExceptionHere ( JSET_ERROR , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\\return 0 ;}}",2925
624,"int vp9_prob_diff_update_savings_search ( const unsigned int * ct ,  vp9_prob oldp , vp9_prob * bestp ,   vp9_prob upd ) {const int old_b = cost_branch256 ( ct , oldp ) ;vp9_prob newp , bestnewp = oldp ;const int step = * bestp > oldp ? - 1 : 1 ;","int vp9_prob_diff_update_savings_search ( const unsigned int * ct , vpx_prob oldp , vpx_prob * bestp , vp9_prob upd ) {const int old_b = cost_branch256 ( ct , oldp ) ;vpx_prob newp , bestnewp = oldp ;const int step = * bestp > oldp ? - 1 : 1 ;",2926
625,if ( x & ( 1 << i ) ) return i ;},if ( x & ( 1U << ( unsigned int ) i ) ) return i ;},2927
626,"if ( secure_decrypt ( data , sizeof ( * header ) , 0 ) )   return - 1 ;header = ( const at91_secure_header_t * ) data ;if ( header -> magic != AT91_SECURE_MAGIC )  return - 1 ;file = ( unsigned char * ) data + sizeof ( * header ) ;return secure_decrypt ( file , header -> file_size , 1 ) ;}","int ret = - 1 ;if ( secure_decrypt ( data , sizeof ( * header ) , 0 ) ) goto secure_wipe_keys ;header = ( const at91_secure_header_t * ) data ;if ( header -> magic != AT91_SECURE_MAGIC ) goto secure_wipe_keys ;file = ( unsigned char * ) data + sizeof ( * header ) ;ret = secure_decrypt ( file , header -> file_size , 1 ) ;secure_wipe_keys : wipe_keys ( ) ;return ret ;}",2928
627,"if ( ! unqueue_me ( & q ) )  goto out_put_key ;ret = - ETIMEDOUT ;if ( to && ! to -> task )  goto out_put_key ;if ( ! signal_pending ( current ) ) {put_futex_key ( fshared , & q . key ) ;goto retry ;}ret = - ERESTARTSYS ;if ( ! abs_time )  goto out_put_key ;restart = & current_thread_info ( ) -> restart_block ;",if ( ! unqueue_me ( & q ) ) goto out ;ret = - ETIMEDOUT ;if ( to && ! to -> task ) goto out ;if ( ! signal_pending ( current ) ) goto retry ;}ret = - ERESTARTSYS ;if ( ! abs_time ) goto out_put_key ;restart = & current_thread_info ( ) -> restart_block ;,2929
628,"out_put_key :  put_futex_key ( fshared , & q . key ) ;","
",2929
629,u16 offset = sizeof ( struct ipv6hdr ) ;struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ;while ( offset + 1 <= packet_len ) {switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,u16 offset = sizeof ( struct ipv6hdr ) ;while ( offset <= packet_len ) {struct ipv6_opt_hdr * exthdr ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,2930
630,offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) +  offset ) ;return offset ;,if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ;exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ;offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;return - EINVAL ;,2930
631,"mm_segment_t old_fs ;if ( ! ur ) return sys_wait4 ( pid , ustatus , options , NULL ) ;ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;set_fs ( old_fs ) ;err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ;","unsigned int status = 0 ;mm_segment_t old_fs ;if ( ! ur ) return sys_wait4 ( pid , ( unsigned int __user * ) & status , options , NULL ) ;ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;set_fs ( old_fs ) ;err |= put_user ( status , ustatus ) ;err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ;",2931
632,"int get_vp9_frame_buffer ( void * cb_priv , size_t min_size ,  vpx_codec_frame_buffer_t * fb ) {","static int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {",2932
633,ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ;if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ;,"ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) calloc ( min_size , sizeof ( uint8_t ) ) ;if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ;",2932
634,"SkipRGBMipmaps ( image , dds_info , 4 ) ;return MagickTrue ;","return ( SkipRGBMipmaps ( image , dds_info , 4 , exception ) ) ;",2933
635,void * _TIFFmalloc ( tmsize_t s )  {return ( malloc ( ( size_t ) s ) ) ;,void * _TIFFmalloc ( tmsize_t s ) {if ( s == 0 ) return ( ( void * ) NULL ) ;return ( malloc ( ( size_t ) s ) ) ;,2934
636,"# ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds ,  & dec_tables ) ;# elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds ,  & dec_tables ) ;# else return do_decrypt_fn ( ctx , bx , ax ) ;","# ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , dec_tables . T ) ;# elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , dec_tables . T ) ;# else return do_decrypt_fn ( ctx , bx , ax ) ;",2935
637,if ( ret < 0 )  btrfs_release_path ( p ) ;,if ( ret < 0 && ! p -> skip_release_on_error ) btrfs_release_path ( p ) ;,2936
638,"Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;}if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) {Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".cfg\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;",2937
639,case CIPSO_V4_TAG_RBITMAP : if ( tag_len < CIPSO_V4_TAG_RBM_BLEN ) {,case CIPSO_V4_TAG_RBITMAP : if ( skb == NULL || tag_len < CIPSO_V4_TAG_RBM_BLEN ) {,2938
640,case CIPSO_V4_TAG_LOCAL :  if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) {err_offset = opt_iter ;,case CIPSO_V4_TAG_LOCAL : if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) {err_offset = opt_iter ;,2938
641,"size_t bytes_per_line , extent ,  height ,  length ;","size_t bytes_per_line , extent , height ;",2939
642,"if ( bytes_per_line == 0 )   bytes_per_line = image -> columns ;length = image -> rows * ( image -> columns + image -> columns % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;","
",2939
643,"SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 )  p ++ ;","SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 ) p ++ ;",2939
644,"length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {","
",2939
645,"case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) , ( int __user * ) arg ) ;if ( L_ICANON ( tty ) )  retval = inq_canon ( ldata ) ;","case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) && ! L_EXTPROC ( tty ) , ( int __user * ) arg ) ;if ( L_ICANON ( tty ) ) retval = inq_canon ( ldata ) ;",2940
646,"slapi_pblock_get ( pb , SLAPI_SEARCH_SCOPE , & scope ) ;if ( scope == LDAP_SCOPE_BASE ) {char * * attrs = NULL ;slapi_pblock_get ( pb , SLAPI_SEARCH_ATTRS , & attrs ) ;if ( attrs ) {for ( size_t i = 0 ;attrs [ i ] ;i ++ ) {if ( ldbm_config_moved_attr ( attrs [ i ] ) ) {slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>required<S2SV_blank>attribute<S2SV_blank>has<S2SV_blank>been<S2SV_blank>moved<S2SV_blank>to<S2SV_blank>the<S2SV_blank>BDB<S2SV_blank>scecific<S2SV_blank>configuration<S2SV_blank>entry"" ) ;break ;","slapi_pblock_get ( pb , SLAPI_RESULT_TEXT , ""at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>required<S2SV_blank>attribute<S2SV_blank>has<S2SV_blank>been<S2SV_blank>moved<S2SV_blank>to<S2SV_blank>the<S2SV_blank>BDB<S2SV_blank>scecific<S2SV_blank>configuration<S2SV_blank>entry"" ) ;break ;",2941
647,ipc_lock_object ( & shp -> shm_perm ) ;path = shp -> shm_file -> f_path ;,ipc_lock_object ( & shp -> shm_perm ) ;if ( shp -> shm_file == NULL ) {ipc_unlock_object ( & shp -> shm_perm ) ;err = - EIDRM ;goto out_unlock ;}path = shp -> shm_file -> f_path ;,2942
648,"
",if ( af == NULL ) break ;,2943
649,"af -> from_addr_param ( & addr , addr_param ,  htons ( asoc -> peer . port ) , 0 ) ;","af -> from_addr_param ( & addr , addr_param , htons ( asoc -> peer . port ) , 0 ) ;",2943
650,"ih264d_create_op_t * ps_create_op ;WORD32 ret ;ps_create_op = ( ih264d_create_op_t * ) pv_api_op ;ret = ih264d_allocate_static_bufs ( & dec_hdl , pv_api_ip , pv_api_op ) ;if ( ( IV_FAIL == ret ) && ( NULL != dec_hdl ) )  {ih264d_free_static_bufs ( dec_hdl ) ;ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ;","ih264d_create_ip_t * ps_create_ip ;ih264d_create_op_t * ps_create_op ;WORD32 ret ;ps_create_ip = ( ih264d_create_ip_t * ) pv_api_ip ;ps_create_op = ( ih264d_create_op_t * ) pv_api_op ;dec_hdl = NULL ;ret = ih264d_allocate_static_bufs ( & dec_hdl , pv_api_ip , pv_api_op ) ;if ( IV_FAIL == ret ) && ( NULL != dec_hdl ) ) {ih264d_free_static_bufs ( dec_hdl ) ;}else {void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ;void * pv_mem_ctxt ;pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ;pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ;pf_aligned_free ( pv_mem_ctxt , dec_hdl ) ;}}ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ;",2944
651,suppress_route :  ip6_rt_put ( rt ) ;return true ;,suppress_route : if ( ! ( arg -> flags & FIB_LOOKUP_NOREF ) ) ip6_rt_put ( rt ) ;return true ;,2945
652,"if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;}return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;}","struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ;int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ;goto out ;}out : return ret ;}",2946
653,arg_allow_debuggers = 1 ;break ;,"struct utsname u ;int rv = uname ( & u ) ;if ( rv != 0 ) errExit ( ""uname"" ) ;int major ;int minor ;if ( 2 != sscanf ( u . release , ""%d.%d"" , & major , & minor ) ) {fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>extract<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version:<S2SV_blank>%s\\\exit ( 1 ) ;}if ( major < 4 || ( major == 4 && minor < 8 ) ) {fprintf ( stderr , ""Error:<S2SV_blank>--allow-debuggers<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>Linux<S2SV_blank>kernels<S2SV_blank>prior<S2SV_blank>to<S2SV_blank>4.8.<S2SV_blank>"" ""A<S2SV_blank>bug<S2SV_blank>in<S2SV_blank>ptrace<S2SV_blank>call<S2SV_blank>allows<S2SV_blank>a<S2SV_blank>full<S2SV_blank>bypass<S2SV_blank>of<S2SV_blank>the<S2SV_blank>seccomp<S2SV_blank>filter.<S2SV_blank>"" ""Your<S2SV_blank>current<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d.\\\exit ( 1 ) ;}arg_allow_debuggers = 1 ;break ;",2947
654,}else  inode -> i_gid = current_fsgid ( ) ;,"else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;}else inode -> i_gid = current_fsgid ( ) ;",2948
655,if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) )  return - ENXIO ;,"if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ;if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - ENXIO ;",2949
656,"long newpos ;JAS_DBGLOG ( 100 , ( ""mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\\","size_t newpos ;JAS_DBGLOG ( 100 , ( ""mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\\",2950
657,uint16_t hmi_bpm = 0 ;uint16_t hmi_division = 0 ;,uint32_t data_siz ;uint16_t hmi_bpm = 0 ;uint16_t hmi_division = 0 ;,2951
658,}UNUSED ( hmi_size ) ;,"}if ( hmi_track_offset [ i ] >= hmi_size ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz = hmi_size - hmi_track_offset [ i ] ;",2951
659,"if ( hmi_data [ 0 ] == 0xfe ) {if ( hmi_data [ 1 ] == 0x10 ) {hmi_track_offset [ i ] += hmi_tmp ;}else if ( hmi_data [ 1 ] == 0x15 ) {hmi_data += 4 ;}hmi_data += 4 ;}if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) {goto _hmi_end ;","if ( hmi_data [ 0 ] == 0xfe ) {if ( hmi_data [ 1 ] == 0x10 ) {hmi_tmp += 4 ;hmi_tmp = 8 ;}else {hmi_tmp = 4 ;}hmi_data += 4 ;if ( hmi_tmp > data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz -= hmi_tmp ;}hmi_data += 4 ;hmi_track_offset [ i ] += 4 ;}if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , data_siz , hmi_running_event [ i ] ) ) == 0 ) {goto _hmi_end ;",2951
660,hmi_track_offset [ i ] += setup_ret ;note [ hmi_tmp ] . length = 0 ;if ( * hmi_data > 0x7f ) {do {note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ;hmi_track_offset [ i ] ++ ;}}hmi_track_offset [ i ] ++ ;if ( note [ hmi_tmp ] . length ) {,"data_siz -= setup_ret ;}}if ( data_siz && * hmi_data > 0x7f ) {do {if ( ! data_siz ) break ;if ( ! data_siz ) break ;note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ;data_siz -- ;data_siz -- ;hmi_track_offset [ i ] ++ ;}}if ( ! data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}if ( ! data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz -- ;data_siz -- ;hmi_track_offset [ i ] ++ ;if ( note [ hmi_tmp ] . length ) {",2951
661,}}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;,}}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;,2951
662,"char buf [ L_BUF_SIZE ] ;char * cmdstr , * plottitle , * dataname ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\\\'%s\\\'"" , gplot -> title ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\\\'%s\\\'"" , gplot -> xlabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\\\'%s\\\'"" , gplot -> ylabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE ,  ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;","char buf [ L_BUFSIZE ] ;char * cmdstr , * plottitle , * dataname ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>title<S2SV_blank>\\\'%s\\\'"" , gplot -> title ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\\\'%s\\\'"" , gplot -> xlabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\\\'%s\\\'"" , gplot -> ylabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;",2952
663,"snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;if ( i == 0 )  snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else if ( i < nplots - 1 )  snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else  snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;","snprintf ( buf , L_BUFSIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;if ( i == 0 ) snprintf ( buf , L_BUFSIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else if ( i < nplots - 1 ) snprintf ( buf , L_BUFSIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else snprintf ( buf , L_BUFSIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;",2952
664,"struct rt6_info * rt = ( struct rt6_info * ) dst ;if ( ! dst )  goto out ;if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) {","struct rt6_info * rt ;if ( ! dst ) goto out ;if ( dst -> ops -> family != AF_INET6 ) {dst_release ( dst ) ;return NULL ;}rt = ( struct rt6_info * ) dst ;if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) {",2953
665,"struct mb_cache_entry * ce ;ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ;ea_bdebug ( bh , ""modifying<S2SV_blank>in-place"" ) ;if ( ce )  mb_cache_entry_free ( ce ) ;int offset ;if ( ce ) mb_cache_entry_release ( ce ) ;","__u32 hash = le32_to_cpu ( header -> h_hash ) ;ea_bdebug ( bh , ""modifying<S2SV_blank>in-place"" ) ;mb2_cache_entry_delete_block ( EXT2_SB ( sb ) -> s_mb_cache , hash , bh -> b_blocknr ) ;int offset ;",2954
666,u8 ip_proto = 0 ;if ( ! data ) {,u8 ip_proto = 0 ;bool ret = false ;if ( ! data ) {,2955
667,if ( ! iph || iph -> ihl < 5 )  return false ;nhoff += iph -> ihl * 4 ;,if ( ! iph || iph -> ihl < 5 ) goto out_bad ;nhoff += iph -> ihl * 4 ;,2955
668,if ( ! iph )  return false ;ip_proto = iph -> nexthdr ;,if ( ! iph ) goto out_bad ;ip_proto = iph -> nexthdr ;,2955
669,"if ( ! vlan )  return false ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_VLANID ) ) {","if ( ! vlan ) goto out_bad ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_VLANID ) ) {",2955
670,if ( ! hdr )  return false ;proto = hdr -> proto ;default :  return false ;},if ( ! hdr ) goto out_bad ;proto = hdr -> proto ;default : goto out_bad ;},2955
671,if ( ! hdr )  return false ;key_basic -> n_proto = proto ;key_control -> thoff = ( u16 ) nhoff ;return true ;}if ( ! hdr )  return false ;if ( ( ntohl ( hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) {key_basic -> n_proto = proto ;key_basic -> ip_proto = ip_proto ;key_control -> thoff = ( u16 ) nhoff ;return true ;return true ;default :  return false ;},if ( ! hdr ) goto out_bad ;goto out_good ;}if ( ! hdr ) goto out_bad ;if ( ( ntohl ( hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) {goto out_good ;goto out_good ;default : return false ;},2955
672,if ( ! hdr )  return false ;if ( hdr -> flags & ( GRE_VERSION | GRE_ROUTING ) ) break ;,if ( ! hdr ) goto out_bad ;if ( hdr -> flags & ( GRE_VERSION | GRE_ROUTING ) ) break ;,2955
673,"if ( ! keyid )  return false ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_GRE_KEYID ) ) {","if ( ! keyid ) goto out_bad ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_GRE_KEYID ) ) {",2955
674,if ( ! eth )  return false ;proto = eth -> h_proto ;,if ( ! eth ) goto out_bad ;proto = eth -> h_proto ;,2955
675,if ( ! opthdr )  return false ;ip_proto = opthdr [ 0 ] ;,if ( ! opthdr ) goto out_bad ;ip_proto = opthdr [ 0 ] ;,2955
676,"key_basic -> n_proto = proto ;key_basic -> ip_proto = ip_proto ;key_control -> thoff = ( u16 ) nhoff ;if ( skb_flow_dissector_uses_key ( flow_dissector ,  FLOW_DISSECTOR_KEY_PORTS ) ) {return true ;","if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) {out_good : ret = true ;out_bad : key_basic -> n_proto = proto ;key_basic -> ip_proto = ip_proto ;key_control -> thoff = ( u16 ) nhoff ;return ret ;",2955
677,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,2956
678,"VP8Frame * av_uninit ( curframe ) , * prev_frame ;if ( is_vp7 ) ret = vp7_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ;","VP8Frame * av_uninit ( curframe ) , * prev_frame ;av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P ) ;if ( is_vp7 ) ret = vp7_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ;",2957
679,"show ( obj , base , name , cb_data ) ;strbuf_addstr ( base , name ) ;","strbuf_addstr ( base , name ) ;show ( obj , base -> buf , cb_data ) ;",2958
680,int64_t off = s -> off ;int len = 0 ;,uint64_t off = s -> off ;int len = 0 ;,2959
681,"len += av_strlcatf ( headers + len , sizeof ( headers ) - len ,  ""Range:<S2SV_blank>bytes=%"" PRId64 ""-"" , s -> off ) ;if ( s -> end_off ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""%"" PRId64 , s -> end_off - 1 ) ;","len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""Range:<S2SV_blank>bytes=%"" PRIu64 ""-"" , s -> off ) ;if ( s -> end_off ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""%"" PRId64 , s -> end_off - 1 ) ;",2959
682,s -> filesize = - 1 ;s -> willclose = 0 ;,s -> filesize = UINT64_MAX ;s -> willclose = 0 ;,2959
683,"size_t bits_per_pixel , map_length , number_colormaps ,  number_planes ,  one , offset , pixel_info_length ;","size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ;",2960
684,"if ( ( number_pixels * number_planes ) != ( size_t ) ( number_pixels * number_planes ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes , 4 ) ;pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof ( * pixels ) ) ;","number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ;if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * number_planes_filled ;pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof ( * pixels ) ) ;",2960
685,"static void cpStripToTile ( uint8 * out , uint8 * in ,  uint32 rows , uint32 cols , int outskew , int inskew )  {","static void cpStripToTile ( uint8 * out , uint8 * in , uint32 rows , uint32 cols , int outskew , int64 inskew ) {",2961
686,"if ( pos + 8 > len ) {return op -> size ;int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) ,  max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ;","if ( pos + 8 + 8 > len ) {return op -> size ;const int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) ;const int max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ;",2962
687,"if ( ndo -> ndo_vflag )  ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ;p += 8 ;","if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;",2963
688,interface = intf -> cur_altsetting ;endpoint = & interface -> endpoint [ 0 ] . desc ;,interface = intf -> cur_altsetting ;if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL ;endpoint = & interface -> endpoint [ 0 ] . desc ;,2964
689,const char * bufptr ;bufptr = buf ;,"const char * bufptr ;if ( cnt < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write"" ) ;}bufptr = buf ;",2965
690,"static void update_read_synchronize ( rdpUpdate * update , wStream * s )  {Stream_Seek_UINT16 ( s ) ;}","static BOOL update_read_synchronize ( rdpUpdate * update , wStream * s ) {return Stream_SafeSeek ( s , 2 ) ;}",2966
691,"case ICMP6_ROUTER_RENUMBERING_COMMAND : ND_PRINT ( ( ndo , ""router<S2SV_blank>renum:<S2SV_blank>command"" ) ) ;","case ICMP6_ROUTER_RENUMBERING_COMMAND : ND_PRINT ( ( ndo , ""%s"" , icmp6_tstr ) ) ;",2967
692,"trunc :  ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;}","trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;}",2967
693,if ( ! new )  return - ENOMEM ;BUG_ON ( new -> thread_keyring ) ;,if ( ! new ) return - ENOMEM ;,2968
694,uchar buf [ JPG_MAGICLEN ] ;int i ;,jas_uchar buf [ JPG_MAGICLEN ] ;int i ;,2969
695,"
",ps_dec -> u2_forw_f_code = 7 ;ps_dec -> u2_back_f_code = 7 ;,2970
696,ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg1 ;},ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg1 ;},2970
697,"memcpy ( vs_param_set -> ie , priv -> vs_ie [ id ] . ie ,  le16_to_cpu ( vs_param_set -> header . len ) ) ;","if ( le16_to_cpu ( vs_param_set -> header . len ) > MWIFIEX_MAX_VSIE_LEN ) {mwifiex_dbg ( priv -> adapter , ERROR , ""Invalid<S2SV_blank>param<S2SV_blank>length!\\\break ;}memcpy ( vs_param_set -> ie , priv -> vs_ie [ id ] . ie , le16_to_cpu ( vs_param_set -> header . len ) ) ;",2971
698,"static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out )  {int i ;Rune c ;for ( ;switch ( pc -> opcode ) {case I_END :  return 1 ;case I_JUMP : pc = pc -> x ;if ( match ( pc -> x , sp , bol , flags , & scratch ) ) {* out = scratch ;return 1 ;}case I_PLA :  if ( ! match ( pc -> x , sp , bol , flags , out ) )  return 0 ;if ( match ( pc -> x , sp , bol , flags , & scratch ) )  return 0 ;if ( c == 0 )  return 0 ;pc = pc + 1 ;break ;case I_ANY : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( isnewline ( c ) )  return 0 ;pc = pc + 1 ;break ;case I_CHAR : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( flags & REG_ICASE ) c = canon ( c ) ;if ( c != pc -> c )  return 0 ;pc = pc + 1 ;break ;case I_CCLASS : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( flags & REG_ICASE ) {if ( ! incclasscanon ( pc -> cc , canon ( c ) ) )  return 0 ;}else {if ( ! incclass ( pc -> cc , c ) )  return 0 ;}case I_NCCLASS : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( flags & REG_ICASE ) {if ( incclasscanon ( pc -> cc , canon ( c ) ) )  return 0 ;}else {if ( incclass ( pc -> cc , c ) )  return 0 ;}case I_REF : i = out -> sub [ pc -> n ] . ep - out -> sub [ pc -> n ] . sp ;if ( strncmpcanon ( sp , out -> sub [ pc -> n ] . sp , i ) )  return 0 ;}else {if ( strncmp ( sp , out -> sub [ pc -> n ] . sp , i ) )  return 0 ;}if ( i > 0 ) sp += i ;","static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out , int depth ) {int result ;int i ;Rune c ;if ( depth > MAXREC ) return - 1 ;for ( ;switch ( pc -> opcode ) {case I_END : return 0 ;case I_JUMP : pc = pc -> x ;result = match ( pc -> x , sp , bol , flags , & scratch , depth + 1 ) ;if ( result == - 1 ) return - 1 ;if ( result == 0 ) {* out = scratch ;return 0 ;}case I_PLA : result = match ( pc -> x , sp , bol , flags , out , depth + 1 ) ;if ( result == - 1 ) return - 1 ;if ( result == 1 ) return 1 ;result = match ( pc -> x , sp , bol , flags , & scratch , depth + 1 ) ;if ( result == - 1 ) return - 1 ;if ( result == 0 ) return 1 ;if ( c == 0 ) return 1 ;if ( c == 0 ) return 0 ;if ( isnewline ( c ) ) return 0 ;case I_CHAR : sp += chartorune ( & c , sp ) ;if ( c == 0 ) return 0 ;if ( flags & REG_ICASE ) c = canon ( c ) ;if ( c != pc -> c ) return 0 ;case I_CCLASS : sp += chartorune ( & c , sp ) ;if ( c == 0 ) return 0 ;if ( ! incclasscanon ( pc -> cc , canon ( c ) ) ) return 1 ;",2972
699,return 0 ;case I_EOL : if ( * sp == 0 ) {,return 0 ;case I_EOL : if ( * sp == 0 ) {,2972
700,return 0 ;case I_WORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ;if ( ! i )  return 0 ;pc = pc + 1 ;if ( i )  return 0 ;pc = pc + 1 ;,return 0 ;case I_WORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ;if ( ! i ) return 0 ;pc = pc + 1 ;if ( i ) return 0 ;pc = pc + 1 ;,2972
701,default :  return 0 ;},default : return 1 ;},2972
702,"m -> msg_namelen = 0 ;target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ;","target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ;",2973
703,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,2974
704,"else {ret . code = kadm5_get_policies ( ( void * ) handle , arg -> exp , & ret . pols , & ret . count ) ;if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ;log_done ( ""kadm5_get_policies"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ;if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ;}gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",2974
705,"gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ;if ( nautilus_file_can_set_permissions ( file ) ) {gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ;}gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;","gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ;if ( nautilus_file_can_set_permissions ( file ) ) {gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK ) ;}gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;",2975
706,size_t size = ( alignment - MALLOC_ALIGNMENT ) + bytes ;void * base = leak_malloc ( size ) ;,size_t size = ( alignment - MALLOC_ALIGNMENT ) + bytes ;if ( size < bytes ) {return NULL ;}void * base = leak_malloc ( size ) ;,2976
707,},"hook_del_nick_can_register ( check_registration_keywords ) ;hook_del_user_can_register ( check_registration_keywords ) ;del_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table ) ;}",2977
708,"skb -> ip_summed = CHECKSUM_PARTIAL ;skb -> csum = 0 ;__skb_queue_tail ( queue , skb ) ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;","skb -> csum = 0 ;__skb_queue_tail ( queue , skb ) ;}else if ( skb_is_gso ( skb ) ) {goto append ;}skb -> ip_summed = CHECKSUM_PARTIAL ;append : return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",2978
709,"r = - ENOMEM ;if ( ! u . lapic ) goto out ;r = kvm_vcpu_ioctl_get_lapic ( vcpu , u . lapic ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( argp , u . lapic , sizeof ( struct kvm_lapic_state ) ) ) goto out ;r = 0 ;break ;}case KVM_SET_LAPIC : {r = - EINVAL ;if ( ! vcpu -> arch . apic ) goto out ;u . lapic = memdup_user ( argp , sizeof ( * u . lapic ) ) ;if ( IS_ERR ( u . lapic ) ) return PTR_ERR ( u . lapic ) ;r = kvm_vcpu_ioctl_set_lapic ( vcpu , u . lapic ) ;break ;}case KVM_INTERRUPT : {struct kvm_interrupt irq ;r = - EFAULT ;if ( copy_from_user ( & irq , argp , sizeof irq ) ) goto out ;r = kvm_vcpu_ioctl_interrupt ( vcpu , & irq ) ;break ;}case KVM_NMI : {r = kvm_vcpu_ioctl_nmi ( vcpu ) ;break ;}case KVM_SET_CPUID : {struct kvm_cpuid __user * cpuid_arg = argp ;struct kvm_cpuid cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_set_cpuid ( vcpu , & cpuid , cpuid_arg -> entries ) ;break ;}case KVM_SET_CPUID2 : {struct kvm_cpuid2 __user * cpuid_arg = argp ;struct kvm_cpuid2 cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_set_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ;break ;}case KVM_GET_CPUID2 : {struct kvm_cpuid2 __user * cpuid_arg = argp ;struct kvm_cpuid2 cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_get_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( cpuid_arg , & cpuid , sizeof cpuid ) ) goto out ;r = 0 ;break ;}case KVM_GET_MSRS : r = msr_io ( vcpu , argp , kvm_get_msr , 1 ) ;break ;case KVM_SET_MSRS : r = msr_io ( vcpu , argp , do_set_msr , 0 ) ;break ;case KVM_TPR_ACCESS_REPORTING : {struct kvm_tpr_access_ctl tac ;r = - EFAULT ;if ( copy_from_user ( & tac , argp , sizeof tac ) ) goto out ;r = vcpu_ioctl_tpr_access_reporting ( vcpu , & tac ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( argp , & tac , sizeof tac ) ) goto out ;r = 0 ;break ;};case KVM_SET_VAPIC_ADDR : {struct kvm_vapic_addr va ;r = - EINVAL ;if ( ! irqchip_in_kernel ( vcpu -> kvm ) ) goto out ;r = - EFAULT ;if ( copy_from_user ( & va , argp , sizeof va ) ) goto out ;r = 0 ;kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ;","r = kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ;",2979
710,"FIRSTPASS_STATS this_frame ;const FIRSTPASS_STATS * start_pos ;struct twopass_rc * twopass = & cpi -> twopass ;const VP9_CONFIG * const oxcf = & cpi -> oxcf ;const int is_spatial_svc = ( svc -> number_spatial_layers > 1 ) &&   ( svc -> number_temporal_layers == 1 ) ;double frame_rate ;if ( is_spatial_svc ) {twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ;}twopass -> total_stats = * twopass -> stats_in_end ;twopass -> total_left_stats = twopass -> total_stats ;frame_rate = 10000000.0 * twopass -> total_stats . count /  twopass -> total_stats . duration ;if ( is_spatial_svc ) {vp9_update_spatial_layer_framerate ( cpi , frame_rate ) ;twopass -> bits_left =  ( int64_t ) ( twopass -> total_stats . duration *  svc -> layer_context [ svc -> spatial_layer_id ] . target_bandwidth / 10000000.0 ) ;twopass -> bits_left = ( int64_t ) ( twopass -> total_stats . duration *  oxcf -> target_bandwidth / 10000000.0 ) ;}cpi -> output_framerate = oxcf -> framerate ;if ( ! is_spatial_svc ) {twopass -> kf_intra_err_min = KF_MB_INTRA_MIN * cpi -> common . MBs ;twopass -> gf_intra_err_min = GF_MB_INTRA_MIN * cpi -> common . MBs ;double sum_iiratio = 0.0 ;start_pos = twopass -> stats_in ;while ( input_stats ( twopass , & this_frame ) != EOF ) {const double iiratio = this_frame . intra_error / DOUBLE_DIVIDE_CHECK ( this_frame . coded_error ) ;","const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;const int is_spatial_svc = ( svc -> number_spatial_layers > 1 ) && ( svc -> number_temporal_layers > 1 ) ;double frame_rate ;if ( is_spatial_svc ) {twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass : & cpi -> twopass ;double frame_rate ;FIRSTPASS_STATS * stats ;stats = & twopass -> total_stats ;* stats = * twopass -> stats_in_end ;twopass -> total_left_stats = * stats ;frame_rate = 10000000.0 * twopass -> total_stats . count / twopass -> total_stats . duration ;if ( is_two_pass_svc ) {vp9_update_spatial_layer_framerate ( cpi , frame_rate ) ;twopass -> bits_left = ( int64_t ) ( stats -> duration * svc -> layer_context [ svc -> spatial_layer_id ] . target_bandwidth / 10000000.0 ) ;twopass -> bits_left = ( int64_t ) ( stats -> duration * oxcf -> target_bandwidth / 10000000.0 ) ;double sum_iiratio = 0.0 ;start_pos = twopass -> stats_in ;while ( input_stats ( twopass , & this_frame ) != EOF ) {const double iiratio = this_frame . intra_error / DOUBLE_DIVIDE_CHECK ( this_frame . coded_error ) ;",2980
711,"twopass -> modified_error_min = ( av_error * oxcf -> two_pass_vbrmin_section ) / 100 ;twopass -> modified_error_max = ( av_error * oxcf -> two_pass_vbrmax_section ) / 100 ;twopass -> modified_error_total +=  calculate_modified_err ( cpi , & this_frame ) ;}twopass -> modified_error_left = twopass -> modified_error_total ;reset_fpf_position ( twopass , start_pos ) ;","twopass -> modified_error_min = ( avg_error * oxcf -> two_pass_vbrmin_section ) / 100 ;twopass -> modified_error_max = ( avg_error * oxcf -> two_pass_vbrmax_section ) / 100 ;twopass -> modified_error_total += calculate_modified_err ( cpi , twopass , oxcf , s ) ;++ s ;}twopass -> modified_error_left = modified_error_total ;}cpi -> rc . vbr_bits_off_target = 0 ;cpi -> rc . vbr_bits_off_target_fast = 0 ;cpi -> rc . rate_error_estimate = 0 ;twopass -> kf_zeromotion_pct = 100 ;twopass -> last_kfgroup_zeromotion_pct = 100 ;if ( oxcf -> resize_mode != RESIZE_NONE ) {vp9_init_subsampling ( cpi ) ;",2980
712,int overflow_error = 0 ;res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ;if ( ! res ) {,"size_t weights_size ;if ( overflow2 ( windows_size , sizeof ( double ) ) ) {return NULL ;}else {weights_size = windows_size * sizeof ( double ) ;}res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ;if ( ! res ) {",2981
713,"for ( u = 0 ;if ( overflow2 ( windows_size , sizeof ( double ) ) ) {res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ;}u -- ;for ( i = 0 ;gdFree ( res -> ContribRow [ i ] . Weights ) ;","for ( u = 0 ;if ( overflow2 ( windows_size , sizeof ( double ) ) ) {res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ;}u -- ;for ( i = 0 ;gdFree ( res -> ContribRow [ i ] . Weights ) ;",2981
714,"Stream_Read_UINT16 ( s ,  bitmapData -> cbCompFirstRowSize ) ;","if ( Stream_GetRemainingLength ( s ) < 8 ) return FALSE ;Stream_Read_UINT16 ( s , bitmapData -> cbCompFirstRowSize ) ;",2982
715,struct siginfo info ;info . si_signo = sig ;,struct siginfo info = {};info . si_signo = sig ;,2983
716,"DRM_DEBUG ( ""clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\\return - EINVAL ;","DRM_DEBUG ( ""clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\\return - EINVAL ;}if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) {DRM_DEBUG ( ""execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\\return - EINVAL ;",2984
717,"if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_int ( tmp , & lineno , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {if ( _PyObject_HasAttrId ( obj , & PyId_col_offset ) ) {","if ( lookup_attr_id ( obj , & PyId_lineno ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lineno , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {else {",2985
718,"if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_boolop ( tmp , & op , arena ) ;else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""op\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_values ) ) {int res ;Py_ssize_t len ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_values ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""BoolOp<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;}len = PyList_GET_SIZE ( tmp ) ;values = _Ta3_asdl_seq_new ( len , arena ) ;if ( values == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""BoolOp<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;}asdl_seq_SET ( values , i , value ) ;}Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp"" ) ;* out = BoolOp ( op , values , lineno , col_offset , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;","if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) {int res ;res = obj2ast_int ( tmp , & lineno , arena ) ;if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""col_offset\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>expr"" ) ;else {int res ;res = obj2ast_boolop ( tmp , & col_offset , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;",2985
719,"if ( _PyObject_HasAttrId ( obj , & PyId_left ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_left ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & left , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_left ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_left ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & left , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
720,"if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""right\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ;return 1 ;}* out = BinOp ( left , op , right , lineno , col_offset , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) UnaryOp_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}tmp = _PyObject_GetAttrId ( obj , & PyId_operand ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & operand , arena ) ;else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""operand\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>UnaryOp"" ) ;* out = UnaryOp ( op , operand , lineno , col_offset , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Lambda_type ) ;if ( isinstance == - 1 ) {if ( isinstance ) {arguments_ty args ;expr_ty body ;if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( lookup_attr_id ( obj , ( PyObject * ) UnaryOp_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}res = obj2ast_boolop ( tmp , & op , arena ) ;if ( lookup_attr_id ( obj , & PyId_values , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp"" ) ;else {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
721,"if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & test , arena ) ;if ( res != 0 ) goto failed ;","if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & test , arena ) ;if ( res != 0 ) goto failed ;",2985
722,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_keys ) ;",Py_ssize_t i ;,2985
723,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( keys , i , value ) ;}Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""keys\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ;return 1 ;}if ( _PyObject_HasAttrId ( obj , & PyId_values ) ) {int res ;Py_ssize_t len ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_values ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""Dict<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;}len = PyList_GET_SIZE ( tmp ) ;values = _Ta3_asdl_seq_new ( len , arena ) ;if ( values == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""Dict<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;asdl_seq_SET ( values , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ;return 1 ;","expr_ty val ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( keys , i , val ) ;",2985
724,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_elts ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_elts ) ;",2985
725,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , value ) ;}Py_CLEAR ( tmp ) ;}if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ListComp_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;","expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , value ) ;}Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , ( PyObject * ) ListComp_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;",2985
726,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;",2985
727,"comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}","comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}",2985
728,"if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;","if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;",2985
729,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;",2985
730,"comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}","comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}",2985
731,"if ( _PyObject_HasAttrId ( obj , & PyId_key ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_key ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & key , arena ) ;if ( res != 0 ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""key\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp"" ) ;","if ( _PyObject_HasAttrId ( obj , & PyId_key ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_key ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & key , arena ) ;if ( res != 0 ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""key\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp"" ) ;",2985
732,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;",2985
733,"comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}","comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}",2985
734,"if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;","if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;",2985
735,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;",2985
736,"comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}","comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}",2985
737,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
738,"if ( exists_not_none ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( exists_not_none ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
739,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
740,"if ( _PyObject_HasAttrId ( obj , & PyId_left ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_left ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & left , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""left\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_ops ) ) {Py_ssize_t len ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_ops ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""Compare<S2SV_blank>field<S2SV_blank>\\\\""ops\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;}len = PyList_GET_SIZE ( tmp ) ;ops = _Ta3_asdl_int_seq_new ( len , arena ) ;if ( ops == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {cmpop_ty value ;res = obj2ast_cmpop ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""Compare<S2SV_blank>field<S2SV_blank>\\\\""ops\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;}asdl_seq_SET ( ops , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""ops\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ;return 1 ;if ( _PyObject_HasAttrId ( obj , & PyId_comparators ) ) {int res ;Py_ssize_t len ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_comparators ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""Compare<S2SV_blank>field<S2SV_blank>\\\\""comparators\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;len = PyList_GET_SIZE ( tmp ) ;comparators = _Ta3_asdl_seq_new ( len , arena ) ;if ( comparators == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""Compare<S2SV_blank>field<S2SV_blank>\\\\""comparators\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;asdl_seq_SET ( comparators , i , value ) ;}Py_CLEAR ( tmp ) ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""comparators\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ;return 1 ;","if ( _PyObject_HasAttrId ( obj , & PyId_left , & tmp ) < 0 ) {return 1 ;if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""left\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ;else {res = obj2ast_expr ( tmp , & left , arena ) ;if ( res != 0 ) goto failed ;if ( lookup_attr_id ( obj , & PyId_op , & tmp ) < 0 ) {return 1 ;if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""op\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ;return 1 ;int res ;res = obj2ast_operator ( tmp , & right , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;",2985
741,"if ( _PyObject_HasAttrId ( obj , & PyId_func ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_func ) ;if ( tmp == NULL ) goto failed ;","if ( _PyObject_HasAttrId ( obj , & PyId_func ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_func ) ;if ( tmp == NULL ) goto failed ;",2985
742,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ;",2985
743,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( args , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""args\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_keywords ) ;","expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( args , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""args\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_keywords ) ;",2985
744,"keyword_ty value ;res = obj2ast_keyword ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""Call<S2SV_blank>field<S2SV_blank>\\\\""keywords\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;}asdl_seq_SET ( keywords , i , value ) ;}Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""keywords\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ;return 1 ;}* out = Call ( func , args , keywords , lineno , col_offset , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Num_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_n ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_n ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","keyword_ty value ;res = obj2ast_keyword ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( lookup_attr_id ( obj , ( PyObject * ) Num_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_n ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_n ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
745,"if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_s ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_string ( tmp , & s , arena ) ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""s\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Str"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_kind ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_kind ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_string ( tmp , & kind , arena ) ;else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""kind\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Str"" ) ;return 1 ;}","if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) {int res ;res = obj2ast_unaryop ( tmp , & op , arena ) ;Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , & PyId_operand , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""operand\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>UnaryOp"" ) ;return 1 ;}else {res = obj2ast_expr ( tmp , & operand , arena ) ;",2985
746,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & value , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FormattedValue"" ) ;return 1 ;}if ( exists_not_none ( obj , & PyId_conversion ) ) {","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( lookup_attr_id ( obj , & PyId_conversion ) ) {",2985
747,"tmp = _PyObject_GetAttrId ( obj , & PyId_format_spec ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & format_spec , arena ) ;format_spec = NULL ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) JoinedStr_type ) ;","res = obj2ast_arguments ( tmp , & args , arena ) ;if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Lambda"" ) ;return 1 ;}int res ;res = obj2ast_expr ( tmp , & body , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;if ( lookup_attr_id ( obj , ( PyObject * ) JoinedStr_type ) ;",2985
748,"Py_ssize_t len ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_values ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""JoinedStr<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;len = PyList_GET_SIZE ( tmp ) ;values = _Ta3_asdl_seq_new ( len , arena ) ;if ( values == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( values , i , value ) ;}Py_CLEAR ( tmp ) ;}","res = obj2ast_expr ( tmp , & test , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp"" ) ;return 1 ;}else {int res ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( values , i , value ) ;}Py_CLEAR ( tmp ) ;}",2985
749,"if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_s ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_bytes ( tmp , & s , arena ) ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""s\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Bytes"" ) ;* out = Bytes ( s , lineno , col_offset , arena ) ;isinstance = PyObject_IsInstance ( obj , ( PyObject * ) NameConstant_type ) ;singleton value ;if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_s ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_bytes ( tmp , & body , arena ) ;Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""orelse\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp"" ) ;return 1 ;}else {int res ;res = obj2ast_expr ( tmp , & orelse , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}* out = IfExp ( test , body , orelse , lineno , col_offset , arena ) ;isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Dict_type ) ;asdl_seq * keys ;asdl_seq * values ;if ( lookup_attr_id ( obj , & PyId_keys , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""keys\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ;return 1 ;}else {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
750,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
751,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute"" ) ;tmp = _PyObject_GetAttrId ( obj , & PyId_attr ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute"" ) ;tmp = _PyObject_GetAttrId ( obj , & PyId_attr ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
752,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript"" ) ;tmp = _PyObject_GetAttrId ( obj , & PyId_slice ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript"" ) ;tmp = _PyObject_GetAttrId ( obj , & PyId_slice ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
753,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
754,"if ( _PyObject_HasAttrId ( obj , & PyId_id ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_id ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_id ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_id ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
755,"if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_elts ) ;","if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) {int res ;Py_ssize_t i ;",2985
756,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""elts\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>List"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_ctx ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_ctx ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","expr_ty val ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_values , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ;return 1 ;}else {tmp = _PyObject_GetAttrId ( obj , & PyId_ctx ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
757,"if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_elts ) ;","if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) {int res ;Py_ssize_t i ;",2985
758,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""elts\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple"" ) ;return 1 ;if ( _PyObject_HasAttrId ( obj , & PyId_ctx ) ) {","expr_ty val ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , val ) ;}* out = Dict ( keys , values , lineno , col_offset , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Set_type ) ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {asdl_seq * elts ;if ( lookup_attr_id ( obj , & PyId_elts , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""elts\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Set"" ) ;return 1 ;}else {",2985
759,"else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""ctx\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple"" ) ;return 1 ;}","
",2985
760,"static const char *  parse_field ( netdissect_options * ndo , const char * * pptr , int * len )  {if ( * len <= 0 || ! pptr || ! * pptr )  return NULL ;if ( * pptr > ( const char * ) ndo -> ndo_snapend ) return NULL ;while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) {( * pptr ) ++ ;( * len ) -- ;}if ( * len < 0 || * pptr > ( const char * ) ndo -> ndo_snapend )  return NULL ;","static const char * parse_field ( netdissect_options * ndo , const char * * pptr , int * len , int * truncated ) {while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) {",2986
761,if ( ! ( assigned_dev -> flags & KVM_DEV_ASSIGN_ENABLE_IOMMU ) )  return - EINVAL ;,u8 header_type ;if ( ! ( assigned_dev -> flags & KVM_DEV_ASSIGN_ENABLE_IOMMU ) ) return - EINVAL ;,2987
762,"if ( pci_enable_device ( dev ) ) {printk ( KERN_INFO ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>enable<S2SV_blank>PCI<S2SV_blank>device\\\","pci_read_config_byte ( dev , PCI_HEADER_TYPE , & header_type ) ;if ( ( header_type & PCI_HEADER_TYPE ) != PCI_HEADER_TYPE_NORMAL ) {r = - EPERM ;goto out_put ;}r = probe_sysfs_permissions ( dev ) ;if ( r ) goto out_put ;if ( pci_enable_device ( dev ) ) {printk ( KERN_INFO ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>enable<S2SV_blank>PCI<S2SV_blank>device\\\",2987
763,flush_rq -> mq_ctx = first_rq -> mq_ctx ;flush_rq -> tag = first_rq -> tag ;},"struct blk_mq_hw_ctx * hctx ;flush_rq -> mq_ctx = first_rq -> mq_ctx ;flush_rq -> tag = first_rq -> tag ;fq -> orig_rq = first_rq ;hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ;blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq ) ;}",2988
764,struct kvm_lapic * apic = vcpu -> arch . apic ;void * vapic ;,struct kvm_lapic * apic = vcpu -> arch . apic ;,2989
765,vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ;* ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) = data ;kunmap_atomic ( vapic ) ;,"kvm_write_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) ) ;",2989
766,dtls1_process_buffered_records ( s ) ;if ( dtls1_get_processed_record ( s ) ) return 1 ;,if ( dtls1_process_buffered_records ( s ) < 0 ) return - 1 ;if ( dtls1_get_processed_record ( s ) ) return 1 ;,2990
767,"dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ;}return ( 1 ) ;}","if ( dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) < 0 ) return - 1 ;dtls1_record_bitmap_update ( s , bitmap ) ;}dtls1_record_bitmap_update ( s , bitmap ) ;return ( 1 ) ;}",2990
768,if ( ctx -> img_avail ) {if ( ! ( * iter ) ) {img = & ctx -> img ;* iter = img ;ctx -> img_avail = 0 ;,"if ( ctx -> frame_parallel_decode && ctx -> available_threads > 0 && ! ctx -> flushed ) {return NULL ;if ( ctx -> num_cache_frames > 0 ) {release_last_output_frame ( ctx ) ;ctx -> last_show_frame = ctx -> frame_cache [ ctx -> frame_cache_read ] . fb_idx ;if ( ctx -> need_resync ) return NULL ;img = & ctx -> frame_cache [ ctx -> frame_cache_read ] . img ;ctx -> frame_cache_read = ( ctx -> frame_cache_read + 1 ) % FRAME_CACHE_SIZE ;-- ctx -> num_cache_frames ;return img ;}if ( * iter == NULL && ctx -> frame_workers != NULL ) {do {YV12_BUFFER_CONFIG sd ;vp9_ppflags_t flags = {0 , 0 , 0 };const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ;VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_output_worker_id ] ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;ctx -> next_output_worker_id = ( ctx -> next_output_worker_id + 1 ) % ctx -> num_frame_workers ;if ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) set_ppflags ( ctx , & flags ) ;if ( winterface -> sync ( worker ) ) {if ( frame_worker_data -> received_frame == 1 ) {++ ctx -> available_threads ;frame_worker_data -> received_frame = 0 ;check_resync ( ctx , frame_worker_data -> pbi ) ;if ( vp9_get_raw_frame ( frame_worker_data -> pbi , & sd , & flags ) == 0 ) {VP9_COMMON * const cm = & frame_worker_data -> pbi -> common ;RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ;release_last_output_frame ( ctx ) ;ctx -> last_show_frame = frame_worker_data -> pbi -> common . new_fb_idx ;if ( ctx -> need_resync ) return NULL ;yuvconfig2image ( & ctx -> img , & sd , frame_worker_data -> user_priv ) ;ctx -> img . fb_priv = frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer . priv ;img = & ctx -> img ;}else {frame_worker_data -> received_frame = 0 ;++ ctx -> available_threads ;ctx -> need_resync = 1 ;if ( ctx -> flushed != 1 ) return NULL ;}}while ( ctx -> next_output_worker_id != ctx -> next_submit_worker_id ) ;}return NULL ;}",2991
769,". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = type -> match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , }int ret ;if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ;",". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , }int ret ;if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ;",2992
770,pairs = palloc ( count * sizeof ( Pairs ) ) ;for ( i = 0 ;,"if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;pairs = palloc ( count * sizeof ( Pairs ) ) ;for ( i = 0 ;",2993
771,"ptr = realloc ( priv -> EF_C_DevAut , len ) ;if ( ptr ) {priv -> EF_C_DevAut_len = len ;}","if ( len > 0 ) {ptr = realloc ( priv -> EF_C_DevAut , len ) ;if ( ptr ) {priv -> EF_C_DevAut_len = len ;}}",2994
772,"DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ;if ( ! fields ) {","const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ;DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ;if ( ! fields ) {",2995
773,unsigned long len = php_mysqlnd_net_field_length ( & p ) ;if ( copy_data == FALSE && current_field > start_field && last_field_was_string ) {,"const unsigned long len = php_mysqlnd_net_field_length ( & p ) ;if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) {php_error_docref ( NULL , E_WARNING , ""Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>"" MYSQLND_SZ_T_SPEC ""<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet"" , ( p + len ) - packet_end - 1 ) ;DBG_RETURN ( FAIL ) ;}if ( copy_data == FALSE && current_field > start_field && last_field_was_string ) {",2995
774,return ;},return 0 ;},2996
775,kfree ( rm -> atomic . op_notifier ) ;return ret ;,rm -> atomic . op_active = 0 ;kfree ( rm -> atomic . op_notifier ) ;return ret ;,2997
776,idata -> status = IMAP_FATAL ;return ;,"idata -> status = IMAP_FATAL ;return ;}if ( strlen ( idata -> buf ) < litlen ) {mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\\return ;",2998
777,l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;l_mco_size = 5 + l_tcp -> m_nb_mcc_records ;,l_mco_size = 5 + l_tcp -> m_nb_mcc_records ;,2999
778,"opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ;l_current_data += 2 ;","l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ;l_current_data += 2 ;",2999
779,return true ;},"if ( IS ( req -> method , METHOD_POST ) ) {const char * cookie = get_header ( req , ""Cookie"" ) ;const char * token = get_parameter ( req , ""securitytoken"" ) ;if ( ! cookie ) {LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>cookie\\\send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ;return false ;}if ( ! token ) {LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>parameter\\\send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ;return false ;}if ( ! Str_startsWith ( cookie , ""securitytoken="" ) ) {LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>no<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>cookie\\\send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ;return false ;}if ( Str_compareConstantTime ( cookie + 14 , token ) ) {LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>mismatch\\\send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ;return false ;}}return true ;}",3000
780,"int n = 0 , size = 0 , ret = - EFAULT ;struct perf_event_context * ctx = leader -> ctx ;u64 values [ 5 ] ;mutex_lock ( & ctx -> mutex ) ;","struct perf_event_context * ctx = leader -> ctx ;int n = 0 , size = 0 , ret ;u64 values [ 5 ] ;lockdep_assert_held ( & ctx -> mutex ) ;",3001
781,"if ( copy_to_user ( buf , values , size ) ) goto unlock ;","if ( copy_to_user ( buf , values , size ) ) return - EFAULT ;",3001
782,ret = - EFAULT ;goto unlock ;}unlock :  mutex_unlock ( & ctx -> mutex ) ;,ret = - EFAULT ;goto unlock ;}unlock : mutex_unlock ( & ctx -> mutex ) ;,3001
783,"int setpwnam ( struct passwd * pwd )  {int save_errno ;int found ;int namelen ;int buflen = 256 ;int contlen , rc ;char * linebuf = NULL ;char * tmpname = NULL ;char * atomic_dir = ""/etc"" ;pw_init ( ) ;if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL )  return - 1 ;","int setpwnam ( struct passwd * pwd , const char * prefix ) {pw_init ( ) ;if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) return - 1 ;",3002
784,"if ( mwifiex_map_pci_memory ( adapter , skb , MAX_EVENT_SIZE ,  PCI_DMA_FROMDEVICE ) )  return - 1 ;buf_pa = MWIFIEX_SKB_DMA_ADDR ( skb ) ;mwifiex_dbg ( adapter , EVENT , ""info:<S2SV_blank>EVT<S2SV_blank>ring:<S2SV_blank>skb=%p<S2SV_blank>len=%d<S2SV_blank>data=%p<S2SV_blank>buf_pa=%#x:%x\\\","if ( mwifiex_map_pci_memory ( adapter , skb , MAX_EVENT_SIZE , PCI_DMA_FROMDEVICE ) ) {kfree_skb ( skb ) ;kfree ( card -> evtbd_ring_vbase ) ;return - 1 ;}buf_pa = MWIFIEX_SKB_DMA_ADDR ( skb ) ;mwifiex_dbg ( adapter , EVENT , ""info:<S2SV_blank>EVT<S2SV_blank>ring:<S2SV_blank>skb=%p<S2SV_blank>len=%d<S2SV_blank>data=%p<S2SV_blank>buf_pa=%#x:%x\\\",3003
785,if ( count < sizeof ( cmd . type ) ) {ret = - EINVAL ;,if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ;if ( count < sizeof ( cmd . type ) ) {ret = - EINVAL ;,3004
786,done = EAS_TRUE ;},"if ( pWTIntFrame -> numSamples < 0 ) {ALOGE ( ""b/26366256"" ) ;pWTIntFrame -> numSamples = 0 ;}done = EAS_TRUE ;}",3005
787,"if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;status = AcquireImageColormap ( image , image -> colors , exception ) ;if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {unsigned char * viff_colormap ;switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;break ;case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}image -> colors = viff_info . map_columns ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;lsb_first = 1 ;if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : {MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}default : break ;}for ( i = 0 ;i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;i ++ ) {switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;break ;default : value = 1.0 * viff_colormap [ i ] ;break ;}if ( i < ( ssize_t ) image -> colors ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ;image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;switch ( ( int ) viff_info . data_storage_type ) {case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}if ( viff_info . data_storage_type == VFF_TYP_BIT )  max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ;else  max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ;pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ;","if ( viff_info . data_storage_type == VFF_TYP_BIT ) {if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ;else max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ;pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ;",3006
788,"static void show_object ( struct object * obj ,  struct strbuf * path , const char * last ,  void * data ) {char * name = path_name ( path , last ) ;add_preferred_base_object ( name ) ;free ( ( char * ) name ) ;}","static void show_object ( struct object * obj , const char * last , void * data ) {char * name = path_name ( path , last ) ;add_preferred_base_object ( name ) ;}",3007
789,"cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ;DPRINTF ( ( ""Chain:"" ) ) ;","cdf_secid_t maxsector = ( cdf_secid_t ) ( ( sat -> sat_len * size ) / sizeof ( maxsector ) ) ;DPRINTF ( ( ""Chain:"" ) ) ;",3008
790,"if ( sid > maxsector ) {DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\\","if ( sid >= maxsector ) {DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\\",3008
791,if ( keepinvariant ( g ) ) {,if ( g -> gckind == KGC_INC ) if ( keepinvariant ( g ) ) {,3009
792,"makewhite ( g , o ) ;}","makewhite ( g , o ) ;}",3009
793,"if ( ( wp -> path = websNormalizeUriPath ( path ) ) == 0 ) {error ( ""Cannot<S2SV_blank>normalize<S2SV_blank>URL:<S2SV_blank>%s"" , url ) ;","if ( ( wp -> path = websValidateUriPath ( path ) ) == 0 ) {error ( ""Cannot<S2SV_blank>normalize<S2SV_blank>URL:<S2SV_blank>%s"" , url ) ;",3010
794,while ( ibuf [ ind ] == 0x01 ) {if ( ibuf [ ind + 1 ] == 0xFE ) {,while ( ibuf [ ind ] == 0x01 && i < gemsafe_cert_max ) {if ( ibuf [ ind + 1 ] == 0xFE ) {,3011
795,if ( src_end - src < zsize )  return AVERROR_INVALIDDATA ;,if ( src_end - src < zsize + ( sub_type != 2 ) ) return AVERROR_INVALIDDATA ;,3012
796,bitbuf = * src ++ ;bits = 8 ;,if ( src >= src_end ) return AVERROR_INVALIDDATA ;bitbuf = * src ++ ;bits = 8 ;,3012
797,"
","if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) {av_log ( NULL , AV_LOG_ERROR , ""RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\\ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ;prev_pkt [ channel_id ] . read = 0 ;}",3013
798,"if ( ! prev_pkt [ channel_id ] . read ) {if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , size ) ) < 0 ) return ret ;","if ( ! prev_pkt [ channel_id ] . read ) {if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , size ) ) < 0 ) return ret ;",3013
799,int nAlloc = pSrc -> nSrc * 2 + nExtra ;sqlite3 * db = pParse -> db ;,sqlite3_int64 nAlloc = 2 * ( sqlite3_int64 ) pSrc -> nSrc + nExtra ;sqlite3 * db = pParse -> db ;,3014
800,get_page ( * page ) ;out : ret = 0 ;,if ( unlikely ( ! try_get_page ( * page ) ) ) {ret = - ENOMEM ;goto unmap ;}out : ret = 0 ;,3015
801,for ( plane = 0 ;plane < 4 && in -> data [ plane ] ;int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ;,for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ;,3016
802,len = dp -> ip6r_len ;ep = ndo -> ndo_snapend ;,ep = ndo -> ndo_snapend ;len = dp -> ip6r_len ;,3017
803,"if ( js_regexec ( re -> prog , source , & m , 0 ) ) {js_copy ( J , 0 ) ;","if ( js_doregexec ( J , re -> prog , source , & m , 0 ) ) {js_copy ( J , 0 ) ;",3018
804,"if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) )  goto loop ;","if ( ! js_doregexec ( J , re -> prog , source , & m , REG_NOTBOL ) ) goto loop ;",3018
805,"struct oabi_flock64 user ;struct flock64 kernel ;mm_segment_t fs = USER_DS ;unsigned long local_arg = arg ;int ret ;case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 :  if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg ,  sizeof ( user ) ) ) return - EFAULT ;","case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 : if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , sizeof ( user ) ) ) return - EFAULT ;",3019
806,"ret = sys_fcntl64 ( fd , cmd , local_arg ) ;switch ( cmd ) {case F_GETLK64 : if ( ! ret ) {user . l_type = kernel . l_type ;user . l_whence = kernel . l_whence ;user . l_start = kernel . l_start ;user . l_len = kernel . l_len ;user . l_pid = kernel . l_pid ;if ( copy_to_user ( ( struct oabi_flock64 __user * ) arg , & user , sizeof ( user ) ) ) ret = - EFAULT ;case F_SETLK64 : case F_SETLKW64 : set_fs ( fs ) ;return ret ;}","ret = sys_fcntl64 ( fd , cmd , arg ) ;",3019
807,if ( err < 0 ) return err ;,if ( err < 0 < 0 ) return err ;,3020
808,if ( err )  goto err_free_dev ;,if ( err ) goto err_free_dev ;,3020
809,chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ;chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ;,chm -> index_root >= chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ;,3021
810,"if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) {D ( ( ""index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range"" ) ) return MSPACK_ERR_DATAFORMAT ;","if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) {D ( ( ""index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range"" ) ) return MSPACK_ERR_DATAFORMAT ;",3021
811,name = p ;READ_ENCINT ( section ) ;,if ( name_len == 0 ) goto chunk_end ;name = p ;READ_ENCINT ( section ) ;,3021
812,if ( ! file )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;,if ( ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;,3022
813,"memcpy ( res , dbg_data , nb10sz ) ;res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ;","
",3023
814,"if ( istreq ( str , ""all"" ) ) {* val_rtrn = MOD_REAL_MASK_ALL ;","if ( ! str ) return false ;if ( istreq ( str , ""all"" ) ) {* val_rtrn = MOD_REAL_MASK_ALL ;",3024
815,"conn -> c_trans = trans ;ret = trans -> conn_alloc ( conn , gfp ) ;","if ( trans == NULL ) {kmem_cache_free ( rds_conn_slab , conn ) ;conn = ERR_PTR ( - ENODEV ) ;goto out ;}conn -> c_trans = trans ;ret = trans -> conn_alloc ( conn , gfp ) ;",3025
816,release_sock ( sk ) ;return 0 ;,msg -> msg_namelen = 0 ;release_sock ( sk ) ;return 0 ;,3026
817,"case suite :  if ( NCH ( n ) == 1 )  return num_stmts ( CHILD ( n , 0 ) ) ;l = 0 ;for ( i = 2 ;i ++ )  l += num_stmts ( CHILD ( n , i ) ) ;","case suite : case func_body_suite : if ( NCH ( n ) == 1 ) return num_stmts ( CHILD ( n , 0 ) ) ;i = 2 ;l = 0 ;if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) i += 2 ;for ( ;i ++ ) l += num_stmts ( CHILD ( n , i ) ) ;",3027
818,"amount = n_got * sizeof ( ut32 ) ;if ( amount < n_got || amount > UT32_MAX ) {goto out_error ;}struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ;if ( got_table ) {",amount = n_got * sizeof ( struct reloc_struct_t ) ) ;if ( got_table ) {,3028
819,"void vp9_loop_filter_rows ( const YV12_BUFFER_CONFIG * frame_buffer ,   VP9_COMMON * cm , MACROBLOCKD * xd ,  int start , int stop , int y_only ) {int mi_row , mi_col ;LOOP_FILTER_MASK lfm ;int use_420 = y_only || ( xd -> plane [ 1 ] . subsampling_y == 1 &&   xd -> plane [ 1 ] . subsampling_x == 1 ) ;for ( mi_row = start ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + mi_row * cm -> mi_stride ;for ( mi_col = 0 ;vp9_setup_dst_planes ( xd , frame_buffer , mi_row , mi_col ) ;if ( use_420 )   vp9_setup_mask ( cm , mi_row , mi_col , mi_8x8 + mi_col , cm -> mi_stride ,  & lfm ) ;for ( plane = 0 ;if ( use_420 )  vp9_filter_block_plane ( cm , & xd -> plane [ plane ] , mi_row , & lfm ) ;else filter_block_plane_non420 ( cm , & xd -> plane [ plane ] , mi_8x8 + mi_col , mi_row , mi_col ) ;}}","void vp9_loop_filter_rows ( YV12_BUFFER_CONFIG * frame_buffer , VP9_COMMON * cm , struct macroblockd_plane planes [ MAX_MB_PLANE ] , int start , int stop , int y_only ) {enum lf_path path ;LOOP_FILTER_MASK lfm ;int use_420 = y_only || ( xd -> plane [ 1 ] . subsampling_y == 1 && planes [ 1 ] . subsampling_x == 1 ) path = LF_PATH_420 ;else if ( planes [ 1 ] . subsampling_y == 0 && planes [ 1 ] . subsampling_x == 0 ) path = LF_PATH_444 ;else path = LF_PATH_SLOW ;for ( mi_row = start ;MODE_INFO * * mi = cm -> mi_grid_visible + mi_row * cm -> mi_stride ;for ( mi_col = 0 ;vp9_setup_dst_planes ( planes , frame_buffer , mi_row , mi_col ) ;vp9_setup_mask ( cm , mi_row , mi_col , mi_8x8 + mi_col , cm -> mi_stride , & lfm ) ;vp9_filter_block_plane_ss00 ( cm , & planes [ 0 ] , mi_row , & lfm ) ;for ( plane = 1 ;switch ( path ) {case LF_PATH_420 : vp9_filter_block_plane_ss11 ( cm , & planes [ plane ] , mi_row , & lfm ) ;break ;case LF_PATH_444 : vp9_filter_block_plane_ss00 ( cm , & planes [ plane ] , mi_row , & lfm ) ;break ;case LF_PATH_SLOW : vp9_filter_block_plane_non420 ( cm , & planes [ plane ] , mi + mi_col , mi_row , mi_col ) ;break ;}}}",3029
820,if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) )  return rdesc ;,if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ;if ( * rsize < 4 ) return rdesc ;,3030
821,if ( config -> listener_count == 0 # ifdef WITH_TLS || config -> default_listener . cafile || config -> default_listener . capath || config -> default_listener . certfile || config -> default_listener . keyfile || config -> default_listener . ciphers || config -> default_listener . psk_hint || config -> default_listener . require_certificate || config -> default_listener . crlfile || config -> default_listener . use_identity_as_username || config -> default_listener . use_subject_as_username # endif || config -> default_listener . use_username_as_clientid || config -> default_listener . host || config -> default_listener . port || config -> default_listener . max_connections != - 1 || config -> default_listener . mount_point || config -> default_listener . protocol != mp_mqtt || config -> default_listener . socket_domain || config -> default_listener . security_options . password_file || config -> default_listener . security_options . psk_file || config -> default_listener . security_options . auth_plugin_config_count || config -> default_listener . security_options . allow_anonymous != - 1 ) {,if ( config -> listener_count == 0 # ifdef WITH_TLS || config -> default_listener . cafile || config -> default_listener . capath || config -> default_listener . certfile || config -> default_listener . keyfile || config -> default_listener . ciphers || config -> default_listener . psk_hint || config -> default_listener . require_certificate || config -> default_listener . crlfile || config -> default_listener . use_identity_as_username || config -> default_listener . use_subject_as_username # endif || config -> default_listener . use_username_as_clientid || config -> default_listener . host || config -> default_listener . port || config -> default_listener . max_connections != - 1 || config -> default_listener . mount_point || config -> default_listener . protocol != mp_mqtt || config -> default_listener . socket_domain || config -> default_listener . security_options . acl_file = config -> default_listener . security_options . acl_file ;config -> listeners [ config -> listener_count - 1 ] . security_options . password_file || config -> default_listener . security_options . psk_file || config -> default_listener . security_options . auth_plugin_config_count || config -> default_listener . security_options . allow_anonymous != - 1 ) {,3031
822,# endif  config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ;config -> listeners [ config -> listener_count - 1 ] . security_options . psk_file = config -> default_listener . security_options . psk_file ;,# endif config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ;config -> listeners [ config -> listener_count - 1 ] . security_options . psk_file = config -> default_listener . security_options . psk_file ;,3031
823,"
","if ( ext4_has_feature_meta_bg ( sb ) ) {if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) {ext4_msg ( sb , KERN_WARNING , ""first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>"" ""(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)"" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ;goto failed_mount ;}}",3032
824,"db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) /  EXT4_DESC_PER_BLOCK ( sb ) ;sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ;","db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) / EXT4_DESC_PER_BLOCK ( sb ) ;sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ;",3032
825,"int j , len = apdu . resp [ i + 1 ] ;unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ;","size_t j , len = apdu . resp [ i + 1 ] ;unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ;",3033
826,"case 0x84 :  memcpy ( file -> name , d , len ) ;file -> namelen = len ;break ;","case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ;memcpy ( file -> name , d , file -> namelen = len ;break ;",3033
827,"dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) ,   s -> s3 -> rrec . seq_num ) ;}","if ( dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , s -> s3 -> rrec . seq_num ) < 0 ) return - 1 ;}",3034
828,"if ( ( event -> sigev_notify & SIGEV_THREAD_ID ) &&   ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ) ||   ! same_thread_group ( rtn , current ) ||  ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_SIGNAL ) ) return NULL ;if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) &&   ( ( event -> sigev_signo <= 0 ) || ( event -> sigev_signo > SIGRTMAX ) ) )   return NULL ;return task_pid ( rtn ) ;}","switch ( event -> sigev_notify & SIGEV_THREAD_ID ) && ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ;if ( ! rtn || ! same_thread_group ( rtn , current ) ) return NULL ;if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) && ( ( event -> sigev_signo <= 0 || event -> sigev_signo > SIGRTMAX ) ) ) return NULL ;case SIGEV_NONE : return task_pid ( rtn ) ;default : return NULL ;}}",3035
829,"frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment ] ;len = min ( 8u , frag -> len ) ;if ( ! vcpu -> mmio_is_write ) memcpy ( frag -> data , run -> mmio . data , len ) ;if ( frag -> len <= 8 ) {frag ++ ;vcpu -> mmio_cur_fragment ++ ;}else {frag -> data += len ;frag -> gpa += len ;frag -> len -= len ;}if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) {vcpu -> mmio_needed = 0 ;",frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment >= vcpu -> mmio_nr_fragments ) {vcpu -> mmio_needed = 0 ;,3036
830,"r = parse_gid ( e + 1 , & gid ) ;if ( r < 0 ) goto not_found ;","if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;r = parse_gid ( e + 1 , & gid ) ;if ( r < 0 ) goto not_found ;",3037
831,pch -> file . dead = 1 ;wake_up_interruptible ( & pch -> file . rwait ) ;,put_net ( pch -> chan_net ) ;pch -> chan_net = NULL ;pch -> file . dead = 1 ;wake_up_interruptible ( & pch -> file . rwait ) ;,3038
832,"dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ;dm9000WriteReg ( DM9000_REG_EPDRL , LSB ( data ) ) ;dm9000WriteReg ( DM9000_REG_EPDRH , MSB ( data ) ) ;dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRW ) ;while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 )  {dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ;}","dm9000WriteReg ( DM9000_EPAR , 0x40 | address ) ;dm9000WriteReg ( DM9000_EPDRL , LSB ( data ) ) ;dm9000WriteReg ( DM9000_EPDRH , MSB ( data ) ) ;dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW ) ;while ( ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE ) != 0 ) {dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS ) ;}",3039
833,"if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ;__TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ;if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ;th = ( const struct tcphdr * ) skb -> data ;if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ;if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ;if ( skb_checksum_init ( skb , IPPROTO_TCP , inet_compute_pseudo ) ) goto csum_error ;th = ( const struct tcphdr * ) skb -> data ;iph = ip_hdr ( skb ) ;memmove ( & TCP_SKB_CB ( skb ) -> header . h4 , IPCB ( skb ) , sizeof ( struct inet_skb_parm ) ) ;barrier ( ) ;TCP_SKB_CB ( skb ) -> seq = ntohl ( th -> seq ) ;TCP_SKB_CB ( skb ) -> end_seq = ( TCP_SKB_CB ( skb ) -> seq + th -> syn + th -> fin + skb -> len - th -> doff * 4 ) ;TCP_SKB_CB ( skb ) -> ack_seq = ntohl ( th -> ack_seq ) ;TCP_SKB_CB ( skb ) -> tcp_flags = tcp_flag_byte ( th ) ;TCP_SKB_CB ( skb ) -> tcp_tw_isn = 0 ;TCP_SKB_CB ( skb ) -> ip_dsfield = ipv4_get_dsfield ( iph ) ;TCP_SKB_CB ( skb ) -> sacked = 0 ;lookup : sk = __inet_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , & refcounted ) ;if ( ! sk ) goto no_tcp_socket ;process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ;if ( sk -> sk_state == TCP_NEW_SYN_RECV ) {struct request_sock * req = inet_reqsk ( sk ) ;struct sock * nsk ;sk = req -> rsk_listener ;if ( unlikely ( tcp_v4_inbound_md5_hash ( sk , skb ) ) ) {","if ( tcp_filter ( sk , skb ) ) ) {",3040
834,"if ( sk_filter ( sk , skb ) )   goto discard_and_relse ;skb -> dev = NULL ;","th = ( const struct tcphdr * ) skb -> data ;iph = ip_hdr ( skb ) ;if ( sk_filter ( sk , skb ) ) goto discard_and_relse ;skb -> dev = NULL ;",3040
835,goto retry ;},"err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ;if ( err ) goto out ;err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ;if ( err ) goto out ;goto retry ;}",3041
836,"
",if ( retval == 0 && server_ptr == NULL ) retval = KRB5_KDB_NOENTRY ;,3042
837,"cleanup :  if ( retval != 0 )  * status = ""UNKNOWN_SERVER"" ;","cleanup : if ( retval != 0 ) * status = ""UNKNOWN_SERVER"" ;",3042
838,"else if ( zap_huge_pmd ( tlb , vma , pmd , addr ) )  continue ;}if ( pmd_none_or_clear_bad ( pmd ) )   continue ;next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ;cond_resched ( ) ;","else if ( zap_huge_pmd ( tlb , vma , pmd , addr ) ) goto next ;}if ( pmd_none_or_clear_bad ( pmd ) ) goto next ;next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ;next : cond_resched ( ) ;",3043
839,"REQ ( CHILD ( n , 0 ) , ASYNC ) ;switch ( TYPE ( CHILD ( n , 1 ) ) ) {case funcdef :  return ast_for_funcdef_impl ( c , CHILD ( n , 1 ) , NULL ,   1 ) ;case with_stmt :  return ast_for_with_stmt ( c , CHILD ( n , 1 ) ,  1 ) ;case for_stmt :  return ast_for_for_stmt ( c , CHILD ( n , 1 ) ,  1 ) ;","REQ ( CHILD ( n , 0 ) , NAME ) ;assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ;switch ( TYPE ( CHILD ( n , 1 ) ) ) {case funcdef : return ast_for_funcdef_impl ( c , n , NULL , 1 ) ;case with_stmt : return ast_for_with_stmt ( c , n , true ) ;case for_stmt : return ast_for_for_stmt ( c , CHILD ( n , 1 ) , 1 ) ;",3044
840,"
",ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;,3045
841,"bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ;ND_PRINT ( ( ndo , ""\\\","bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ;ND_PRINT ( ( ndo , ""\\\",3045
842,},trunc : return - 1 ;},3045
843,metadatalength = GetDuration ( mp4 ) ;if ( metadatalength > 0.0 ) {,"if ( mp4 == 0 ) {printf ( ""error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\\return - 1 ;}metadatalength = GetDuration ( mp4 ) ;if ( metadatalength > 0.0 ) {",3046
844,"float in = 0.0 , out = 0.0 ;payload = GetPayload ( mp4 , payload , index ) ;","double in = 0.0 , out = 0.0 ;payload = GetPayload ( mp4 , payload , index ) ;",3046
845,"
","double in = 0.0 , out = 0.0 ;",3046
846,"uint32_t fourcc = GPMF_Key ( ms ) ;double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ;printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\\}","uint32_t fourcc = GPMF_Key ( ms ) ;double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE , & in , & out ) ;printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\\}",3046
847,"stmt_ty  For ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int  lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {","stmt_ty For ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",3047
848,p -> v . For . orelse = orelse ;p -> lineno = lineno ;,p -> v . For . orelse = orelse ;p -> v . For . type_comment = type_comment ;p -> lineno = lineno ;,3047
849,"hide_shell ( shell_visible ? 1 : 0 ) ;if ( shell_visible ) gui_mode = 2 ;}break ;default : break ;}}return 0 ;}switch ( evt -> type ) {case GF_EVENT_DURATION : Duration = ( u64 ) ( 1000 * ( s64 ) evt -> duration . duration ) ;CanSeek = evt -> duration . can_seek ;break ;case GF_EVENT_MESSAGE : {const char * servName ;if ( ! evt -> message . service || ! strcmp ( evt -> message . service , the_url ) ) {servName = """" ;}else if ( ! strnicmp ( evt -> message . service , ""data:"" , 5 ) ) {servName = ""(embedded<S2SV_blank>data)"" ;}else {servName = evt -> message . service ;}if ( ! evt -> message . message ) return 0 ;if ( evt -> message . error ) {if ( ! is_connected ) last_error = evt -> message . error ;if ( evt -> message . error == GF_SCRIPT_INFO ) {GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( ""%s\\\}else {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONSOLE , ( ""%s<S2SV_blank>%s:<S2SV_blank>%s\\\}}else if ( ! be_quiet ) GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( ""%s<S2SV_blank>%s\\\}break ;case GF_EVENT_PROGRESS : {char * szTitle = """" ;if ( evt -> progress . progress_type == 0 ) {szTitle = ""Buffer<S2SV_blank>"" ;if ( bench_mode && ( bench_mode != 3 ) ) {if ( evt -> progress . done >= evt -> progress . total ) bench_buffer = 0 ;else bench_buffer = 1 + 100 * evt -> progress . done / evt -> progress . total ;break ;}}else if ( evt -> progress . progress_type == 1 ) {if ( bench_mode ) break ;szTitle = ""Download<S2SV_blank>"" ;}else if ( evt -> progress . progress_type == 2 ) szTitle = ""Import<S2SV_blank>"" ;gf_set_progress ( szTitle , evt -> progress . done , evt -> progress . total ) ;}break ;case GF_EVENT_DBLCLICK : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ;return 0 ;case GF_EVENT_MOUSEDOWN : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) {right_down = 1 ;last_x = evt -> mouse . x ;last_y = evt -> mouse . y ;}return 0 ;case GF_EVENT_MOUSEUP : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) {right_down = 0 ;last_x = evt -> mouse . x ;last_y = evt -> mouse . y ;}return 0 ;case GF_EVENT_MOUSEMOVE : if ( right_down && ( user . init_flags & GF_TERM_WINDOWLESS ) ) {GF_Event move ;move . move . x = evt -> mouse . x - last_x ;move . move . y = last_y - evt -> mouse . y ;move . type = GF_EVENT_MOVE ;move . move . relative = 1 ;gf_term_user_event ( term , & move ) ;}return 0 ;case GF_EVENT_KEYUP : switch ( evt -> key . key_code ) {case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) switch_bench ( ! bench_mode ) ;break ;}break ;case GF_EVENT_KEYDOWN : gf_term_process_shortcut ( term , evt ) ;switch ( evt -> key . key_code ) {case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) {if ( ! bench_mode ) switch_bench ( ! bench_mode ) ;}break ;case GF_KEY_PAGEDOWN : case GF_KEY_MEDIANEXTTRACK : request_next_playlist_item = 1 ;break ;case GF_KEY_MEDIAPREVIOUSTRACK : break ;case GF_KEY_ESCAPE : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ;break ;case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) {hide_shell ( shell_visible ? 1 : 0 ) ;if ( ! shell_visible ) gui_mode = 1 ;}break ;case GF_KEY_F : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , ""Rendering<S2SV_blank>rate:<S2SV_blank>%f<S2SV_blank>FPS\\\break ;case GF_KEY_T : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , ""Scene<S2SV_blank>Time:<S2SV_blank>%f<S2SV_blank>\\\break ;case GF_KEY_D : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_DRAW_MODE , ( gf_term_get_option ( term , GF_OPT_DRAW_MODE ) == GF_DRAW_MODE_DEFER ) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER ) ;break ;case GF_KEY_4 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ;break ;case GF_KEY_5 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ;break ;case GF_KEY_6 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ;break ;case GF_KEY_7 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ;break ;case GF_KEY_O : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {if ( gf_term_get_option ( term , GF_OPT_MAIN_ADDON ) ) {fprintf ( stderr , ""Resuming<S2SV_blank>to<S2SV_blank>main<S2SV_blank>content\\\gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ;}else {fprintf ( stderr , ""Main<S2SV_blank>addon<S2SV_blank>not<S2SV_blank>enabled\\\}}break ;case GF_KEY_P : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {u32 pause_state = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ;fprintf ( stderr , ""[Status:<S2SV_blank>%s]\\\if ( ( pause_state == GF_STATE_PAUSED ) && ( evt -> key . flags & GF_KEY_MOD_SHIFT ) ) {gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ;}else {gf_term_set_option ( term , GF_OPT_PLAY_STATE , ( pause_state == GF_STATE_PAUSED ) ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ;}}break ;case GF_KEY_S : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ;fprintf ( stderr , ""Step<S2SV_blank>time:<S2SV_blank>"" ) ;PrintTime ( gf_term_get_time_in_ms ( term ) ) ;fprintf ( stderr , ""\\\}break ;case GF_KEY_B : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 1 ) ;break ;case GF_KEY_M : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 0 ) ;break ;case GF_KEY_H : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {gf_term_switch_quality ( term , 1 ) ;}break ;case GF_KEY_L : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {gf_term_switch_quality ( term , 0 ) ;}break ;case GF_KEY_F5 : if ( is_connected ) reload = 1 ;break ;case GF_KEY_A : addon_visible = ! addon_visible ;gf_term_toggle_addons ( term , addon_visible ) ;break ;case GF_KEY_UP : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) {do_set_speed ( playback_speed * 2 ) ;}break ;case GF_KEY_DOWN : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) {do_set_speed ( playback_speed / 2 ) ;}break ;case GF_KEY_LEFT : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) {do_set_speed ( - 1 * playback_speed ) ;}break ;}break ;case GF_EVENT_CONNECT : if ( evt -> connect . is_connected ) {is_connected = 1 ;fprintf ( stderr , ""Service<S2SV_blank>Connected\\\eos_seen = GF_FALSE ;if ( playback_speed != FIX_ONE ) gf_term_set_speed ( term , playback_speed ) ;}else if ( is_connected ) {fprintf ( stderr , ""Service<S2SV_blank>%s\\\is_connected = 0 ;Duration = 0 ;}if ( init_w && init_h ) {gf_term_set_size ( term , init_w , init_h ) ;}ResetCaption ( ) ;break ;case GF_EVENT_EOS : eos_seen = GF_TRUE ;if ( playlist ) {if ( Duration > 1500 ) request_next_playlist_item = GF_TRUE ;}else if ( loop_at_end ) {restart = 1 ;}break ;case GF_EVENT_SIZE : if ( user . init_flags & GF_TERM_WINDOWLESS ) {GF_Event move ;move . type = GF_EVENT_MOVE ;move . move . align_x = align_mode & 0xFF ;move . move . align_y = ( align_mode >> 8 ) & 0xFF ;move . move . relative = 2 ;gf_term_user_event ( term , & move ) ;}break ;case GF_EVENT_SCENE_SIZE : if ( forced_width && forced_height ) {GF_Event size ;size . type = GF_EVENT_SIZE ;size . size . width = forced_width ;size . size . height = forced_height ;gf_term_user_event ( term , & size ) ;}break ;case GF_EVENT_METADATA : ResetCaption ( ) ;break ;case GF_EVENT_RELOAD : if ( is_connected ) reload = 1 ;break ;case GF_EVENT_DROPFILE : {u32 i , pos ;if ( readonly_playlist ) {gf_fclose ( playlist ) ;playlist = NULL ;}readonly_playlist = 0 ;if ( ! playlist ) {readonly_playlist = 0 ;playlist = gf_temp_file_new ( NULL ) ;}pos = ftell ( playlist ) ;i = 0 ;while ( i < evt -> open_file . nb_files ) {if ( evt -> open_file . files [ i ] != NULL ) {fprintf ( playlist , ""%s\\\}i ++ ;}fseek ( playlist , pos , SEEK_SET ) ;request_next_playlist_item = 1 ;}return 1 ;case GF_EVENT_QUIT : if ( evt -> message . error ) {fprintf ( stderr , ""A<S2SV_blank>fatal<S2SV_blank>error<S2SV_blank>was<S2SV_blank>encoutered:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>exiting<S2SV_blank>...\\\}Run = 0 ;break ;case GF_EVENT_DISCONNECT : gf_term_disconnect ( term ) ;break ;case GF_EVENT_MIGRATE : {}break ;case GF_EVENT_NAVIGATE_INFO : if ( evt -> navigate . to_url ) fprintf ( stderr , ""Go<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>\\\\""%s\\\\""\\\\r"" , evt -> navigate . to_url ) ;break ;case GF_EVENT_NAVIGATE : if ( gf_term_is_supported_url ( term , evt -> navigate . to_url , 1 , no_mime_check ) ) {strcpy ( the_url , evt -> navigate . to_url ) ;fprintf ( stderr , ""Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\\","strncpy ( the_url , evt -> navigate . to_url ) ;fprintf ( stderr , ""Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\\",3048
850,"int i , attr_id = 0 , nattr ;q = ( * s ) + 1 ;","int i , attr_id = 0 , nattr ;tagname [ 0 ] = '\\\\0' ;q = ( * s ) + 1 ;",3049
851,"DWORD nbWritten = 0 ;if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ;Stream_Seek ( irp -> input , 20 ) ;WLog_Print ( serial -> log , WLOG_DEBUG , ""writing<S2SV_blank>%"" PRIu32 ""<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>%s"" , Length , serial -> device . name ) ;if ( CommWriteFile ( serial -> hComm , Stream_Pointer ( irp -> input ) , Length , & nbWritten , NULL ) )  {","void * ptr ;DWORD nbWritten = 0 ;if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ;if ( ! Stream_SafeSeek ( irp -> input , 20 ) ) return ERROR_INVALID_DATA ;WLog_Print ( serial -> log , WLOG_DEBUG , ""writing<S2SV_blank>%"" PRIu32 ""<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>%s"" , Length , serial -> device . name ) ;ptr = Stream_Pointer ( irp -> input ) ;if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ;if ( CommWriteFile ( serial -> hComm , ptr , Length , & nbWritten , NULL ) ) {",3050
852,char * buf ;pkglen = s -> end - s -> p ;,"char * buf ;struct stream packet = * s ;if ( ! s_check ( s ) ) {rdp_protocol_error ( ""seamless_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ;}pkglen = s -> end - s -> p ;",3051
853,"memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;fl6 . saddr = ireq -> ir_v6_loc_addr ;","memset ( & fl6 , rcu_dereference ( 0 , sizeof ( fl6 ) ) ;final_p = fl6_update_dst ( & fl6 , np -> opt ) , & final ) ;fl6 . saddr = ireq -> ir_v6_loc_addr ;",3052
854,"ret = hermes_enable_port ( hw , 0 ) ;}","ret = hermes_disable_port ( hw , 0 ) ;}else {priv -> tkip_cm_active = 0 ;ret = hermes_enable_port ( hw , 0 ) ;}",3053
855,bool slow ;if ( addr_len ) * addr_len = sizeof ( struct sockaddr_in6 ) ;,bool slow ;if ( addr_len ) * addr_len = sizeof ( struct sockaddr_in6 ) ;,3054
856,"
",* addr_len = sizeof ( * sin6 ) ;,3054
857,}if ( is_udp4 ) {,}if ( is_udp4 ) {,3054
858,"if ( buf_len == 0 ) {return ;}s = p = ( const unsigned char * ) buf ;PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;if ( * p != \'x\' || * ++ p != \':\' ) {goto outexcept ;}++ p ;pcount = var_tmp_var ( & var_hash ) ;if ( ! php_var_unserialize ( pcount , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pcount ) != IS_LONG ) {goto outexcept ;}-- p ;count = Z_LVAL_P ( pcount ) ;while ( count -- > 0 ) {spl_SplObjectStorageElement * pelement ;zend_string * hash ;if ( * p != \';\' ) {goto outexcept ;}++ p ;if ( * p != \'O\' && * p != \'C\' && * p != \'r\' ) {goto outexcept ;}if ( ! php_var_unserialize ( & entry , & p , s + buf_len , & var_hash ) ) {goto outexcept ;}if ( Z_TYPE ( entry ) != IS_OBJECT ) {zval_ptr_dtor ( & entry ) ;goto outexcept ;}}ZVAL_UNDEF ( & inf ) ;",+ p ;+ p ;}ZVAL_UNDEF ( & inf ) ;,3055
859,if ( uri != NULL )  uri -> port = port & INT_MAX ;* str = cur ;,if ( uri != NULL ) uri -> port = port & USHRT_MAX ;* str = cur ;,3056
860,pch -> chan_net = net ;chan -> ppp = pch ;,pch -> chan_net = get_net ( net ) ;chan -> ppp = pch ;,3057
861,"RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;}","if ( new_len > INT_MAX ) {efree ( replaced ) ;RETURN_FALSE ;}RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;}",3058
862,"ret = hermes_enable_port ( hw , 0 ) ;}","ret = hermes_disable_port ( hw , 0 ) ;}else {priv -> tkip_cm_active = 0 ;ret = hermes_enable_port ( hw , 0 ) ;}",3059
863,"switch ( atype ) {case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;else {ND_TCHECK ( * tptr ) ;","
",3060
864,"tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;","ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;",3060
865,"maj = gss_accept_sec_context ( & min , & ctx , GSS_C_NO_CREDENTIAL , & in , GSS_C_NO_CHANNEL_BINDINGS , & client , & mech_oid , & out , NULL ,  NULL , NULL ) ;if ( out . length && write_packet ( fd , & out ) ) {GSTD_GSS_ERROR ( maj , min , NULL , ""gss_accept_sec_context"" ) ;if ( maj & GSS_S_CONTINUE_NEEDED ) goto again ;","maj = gss_accept_sec_context ( & min , & ctx , GSS_C_NO_CREDENTIAL , & in , GSS_C_NO_CHANNEL_BINDINGS , & client , & mech_oid , & out , NULL , NULL ) ;gss_release_buffer ( & min , & in , NULL ) ;if ( out . length && write_packet ( fd , & out ) ) {gss_release_buffer ( & min , & out ) ;GSTD_GSS_ERROR ( maj , min , NULL , ""gss_accept_sec_context"" ) ;if ( maj & GSS_S_CONTINUE_NEEDED ) goto again ;",3061
866,"xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ;obj_id = 0 ;",xref -> entries = safe_calloc ( xref -> n_entries * sizeof ( struct _xref_entry ) ) ;obj_id = 0 ;,3062
867,pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ;if ( rec ) {,Assert ( ncolumns <= MaxTupleAttributeNumber ) ;pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ;if ( rec ) {,3063
868,assert ( ( cc0 % rowsize ) == 0 ) ;while ( cc > 0 ) {,"if ( ( cc0 % rowsize ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ;return 0 ;}while ( cc > 0 ) {",3064
869,int procfd ;signed long personality ;,signed long personality ;,3065
870,"pid_t to_cleanup_pid = pid ;close ( ipc_sockets [ 1 ] ) ;status = 0 ;ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ;if ( ret <= 0 ) {ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ;ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ;if ( ret <= 0 ) {if ( ret != 0 )  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ;if ( options -> stdin_fd == 0 ) {signal ( SIGINT , SIG_IGN ) ;signal ( SIGQUIT , SIG_IGN ) ;}ret = wait_for_pid ( pid ) ;if ( ret < 0 ) goto cleanup_error ;to_cleanup_pid = attached_pid ;","int procfd = - 1 ;pid_t to_cleanup_pid = pid ;close ( ipc_sockets [ 1 ] ) ;procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ;if ( procfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc."" ) ;ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ;if ( ret <= 0 ) {if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ;",3065
871,"if ( ret != 0 )  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ;goto cleanup_error ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ;goto cleanup_error ;shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;close ( ipc_sockets [ 0 ] ) ;cleanup_error :  shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;","if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ;goto cleanup_error ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ;goto cleanup_error ;}ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ;if ( ret <= 0 ) {if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>"" ""from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ;goto cleanup_error ;shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;close ( ipc_sockets [ 0 ] ) ;cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;",3065
872,"procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ;if ( procfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ;shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ;rexit ( - 1 ) ;}","
",3065
873,". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload ,  . procfd = procfd  }",". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload , }",3065
874,"static int try_filter_frame ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * const cpi ,  int filt_level , int partial_frame ) {int filt_err ;vp9_loop_filter_frame ( cm , & cpi -> mb . e_mbd , filt_level , 1 , partial_frame ) ;filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ;vpx_yv12_copy_y ( & cpi -> last_frame_uf , cm -> frame_to_show ) ;","static int64_t try_filter_frame ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * const cpi , int filt_level , int partial_frame ) {int64_t filt_err ;if ( cpi -> num_workers > 1 ) vp9_loop_filter_frame_mt ( cm -> frame_to_show , cm , cpi -> td . mb . e_mbd . plane , filt_level , 1 , partial_frame , cpi -> workers , cpi -> num_workers , & cpi -> td . lf_row_sync ) ;else vp9_loop_filter_frame ( cm -> frame_to_show , cm , & cpi -> mb . e_mbd , filt_level , 1 , partial_frame ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) {filt_err = vp9_highbd_get_y_sse ( sd , cm -> frame_to_show ) ;}# else filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ;# endif }else {filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ;vpx_yv12_copy_y ( & cpi -> last_frame_uf , cm -> frame_to_show ) ;",3066
875,"if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) &&  ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) )  goto invalid_key ;",if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED ) goto invalid_key ;,3067
876,"static int rd_inter4x4_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel )  {vp8_build_inter4x4_predictors_mbuv ( & x -> e_mbd ) ;","static int rd_inter4x4_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel ) {( void ) cpi ;( void ) fullpixel ;vp8_build_inter4x4_predictors_mbuv ( & x -> e_mbd ) ;",3068
877,"void vp9_update_mv_count ( VP9_COMMON * cm , const MACROBLOCKD * xd ) {const MODE_INFO * mi = xd -> mi [ 0 ] ;const MB_MODE_INFO * const mbmi = & mi -> mbmi ;if ( mbmi -> sb_type < BLOCK_8X8 ) {",void vp9_update_mv_count ( ThreadData * td ) {const MACROBLOCKD * xd ) {const MODE_INFO * mi = xd -> mi [ 0 ] ;const MB_MODE_INFO * const mbmi = & mi -> mbmi ;const MB_MODE_INFO_EXT * mbmi_ext = td -> mb . mbmi_ext ;if ( mbmi -> sb_type < BLOCK_8X8 ) {,3069
878,"if ( mi -> bmi [ i ] . as_mode == NEWMV )  inc_mvs ( mbmi , mi -> bmi [ i ] . as_mv , & cm -> counts . mv ) ;}if ( mbmi -> mode == NEWMV )  inc_mvs ( mbmi , mbmi -> mv , & cm -> counts . mv ) ;}","if ( mi -> bmi [ i ] . as_mode == NEWMV ) inc_mvs ( mbmi , mbmi_ext , mi -> bmi [ i ] . as_mv , & td -> counts -> mv ) ;}if ( mbmi -> mode == NEWMV ) inc_mvs ( mbmi , mbmi_ext , mbmi -> mv , & td -> counts -> mv ) ;}",3069
879,"static bool  ChunkedDecode ( Request * reqPtr , bool update ) {bool success = NS_TRUE ;NS_NONNULL_ASSERT ( reqPtr != NULL ) ;size_t chunk_length ;if ( p == NULL ) {success = NS_FALSE ;break ;chunk_length = ( size_t ) strtol ( chunkStart , NULL , 16 ) ;* p = \'\\\\r\' ;if ( p + 2 + chunk_length > end ) {Ns_Log ( DriverDebug , ""ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>length<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;success = NS_FALSE ;break ;memmove ( writeBuffer , p + 2 , chunk_length ) ;reqPtr -> chunkWriteOff += chunk_length ;* ( writeBuffer + chunk_length ) = \'\\\\0\' ;}reqPtr -> chunkStartOff += ( size_t ) ( p - chunkStart ) + 4u + chunk_length ;chunkStart = bufPtr -> string + reqPtr -> chunkStartOff ;return success ;}","static SockState ChunkedDecode ( Request * reqPtr , bool update ) {SockState result = SOCK_READY ;NS_NONNULL_ASSERT ( reqPtr != NULL ) ;long chunkLength ;if ( p == NULL ) {result = SOCK_MORE ;break ;chunkLength = strtol ( chunkStart , NULL , 16 ) ;* p = \'\\\\r\' ;if ( chunkLength < 0 ) {Ns_Log ( Warning , ""ChunkedDecode:<S2SV_blank>negative<S2SV_blank>chunk<S2SV_blank>length"" ) ;result = SOCK_BADREQUEST ;break ;}* p = \'\\\\r\' ;if ( p + 2 + chunkLength > end ) {Ns_Log ( DriverDebug , ""ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>length<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;result = SOCK_MORE ;break ;memmove ( writeBuffer , p + 2 , ( size_t ) chunkLength ) ;reqPtr -> chunkWriteOff += ( size_t ) chunkLength ;* ( writeBuffer + chunkLength ) = \'\\\\0\' ;}reqPtr -> chunkStartOff += ( size_t ) ( p - chunkStart ) + 4u + ( size_t ) chunkLength ;chunkStart = bufPtr -> string + reqPtr -> chunkStartOff ;}return result ;",3070
880,"static int jas_iccgetuint ( jas_stream_t * in , int n , ulonglong * val )  {ulonglong v ;v = 0 ;","static int jas_iccgetuint ( jas_stream_t * in , int n , jas_ulonglong * val ) {jas_ulonglong v ;v = 0 ;",3071
881,char * buf ;pkglen = s -> end - s -> p ;,"char * buf ;struct stream packet = * s ;if ( ! s_check ( s ) ) {rdp_protocol_error ( ""lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ;}pkglen = s -> end - s -> p ;",3072
882,"PyObject * bufobj = PyObject_CallObject ( readline , NULL ) ;if ( bufobj == NULL ) return 0 ;",PyObject * bufobj = _PyObject_CallNoArg ( readline ) ;if ( bufobj == NULL ) return 0 ;,3073
883,"static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt ,  u16 selector , int seg , u8 cpl , bool in_task_switch )  {","static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg , u8 cpl , bool in_task_switch , struct desc_struct * desc ) {",3074
884,"
",if ( desc ) * desc = seg_desc ;,3074
885,"return X86EMUL_CONTINUE ;exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ;","return X86EMUL_CONTINUE ;exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ;",3074
886,if ( op -> operands [ 1 ] . immediate == - 1 ) {return - 1 ;}immediate = op -> operands [ 1 ] . immediate * op -> operands [ 1 ] . sign ;if ( op -> operands [ 0 ] . type & OT_GPREG && ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) {if ( a -> bits == 64 && ( ( op -> operands [ 0 ] . type & OT_QWORD ) | ( op -> operands [ 1 ] . type & OT_QWORD ) ) ) {if ( ! ( op -> operands [ 1 ] . type & OT_CONSTANT ) && op -> operands [ 1 ] . extended ) {,if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED ) {,3075
887,data [ l ++ ] = 0xc7 ;data [ l ++ ] = 0xc0 | op -> operands [ 0 ] . reg ;data [ l ++ ] = 0xb8 | op -> operands [ 0 ] . reg ;,data [ l ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ;return l ;}if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) {mod = 0x2 ;if ( op -> operands [ 1 ] . offset > 127 ) {mod = 0x4 ;}}if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) {if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) {data [ l ++ ] = 0x5 ;if ( op -> operands [ 1 ] . offset > 127 ) {data [ l ++ ] = 0x80 | op -> operands [ 0 ] . reg ;,3075
888,data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 4 ;data [ l ++ ] = getsib ( op -> operands [ 0 ] . scale [ 0 ] ) << 6 | op -> operands [ 0 ] . regs [ 0 ] << 3 | 5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;return l ;}if ( ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) {if ( op -> operands [ 0 ] . reg == X86R_UNDEFINED || op -> operands [ 1 ] . reg == X86R_UNDEFINED ) {return - 1 ;}mod = 0x3 ;data [ l ++ ] = mod << 6 | op -> operands [ 1 ] . reg << 3 | op -> operands [ 0 ] . reg ;,data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ;,3075
889,data [ l ++ ] = 0xa1 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;if ( a -> bits == 64 ) {data [ l ++ ] = offset >> 32 ;data [ l ++ ] = offset >> 40 ;data [ l ++ ] = offset >> 48 ;data [ l ++ ] = offset >> 54 ;return l ;if ( op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | ( op -> operands [ 1 ] . regs [ 0 ] - 8 ) ;,data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ;if ( op -> operands [ 1 ] . offset > 127 ) {mod = 0x1 ;}else {if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) {data [ l ++ ] = 0x0d ;}else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) {data [ l ++ ] = 0x05 ;}else {data [ l ++ ] = mod << 5 | op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] - 8 ) ;,3075
890,data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ;data [ l ++ ] = 0x8b ;data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {,data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ;data [ l ++ ] = 0x8b ;data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ;}data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;}else {if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {base = 5 ;}if ( base ) {data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ;}else {data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ;}if ( offset || base ) {data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;}return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {,3075
891,data [ l ++ ] = 0x25 ;}data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;}if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {,data [ l ++ ] = 0x25 ;}data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) {if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) {data [ l ++ ] = 0x67 ;}data [ l ++ ] = 0x48 ;}}else if ( op -> operands [ 1 ] . type & OT_DWORD ) {data [ l ++ ] = 0x44 ;}else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) {data [ l ++ ] = 0x67 ;}if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) {data [ l ++ ] = 0x48 ;}}if ( op -> operands [ 0 ] . type & OT_WORD ) {data [ l ++ ] = 0x66 ;data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ;}else {data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ;}if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) {if ( a -> bits == 64 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ;data [ l ++ ] = 0x25 ;}else {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;}if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {,3075
892,"static pfn_t kvm_pin_pages ( struct kvm_memory_slot * slot , gfn_t gfn ,  unsigned long size )  {end_gfn = gfn + ( size >> PAGE_SHIFT ) ;gfn += 1 ;","static pfn_t kvm_pin_pages ( struct kvm_memory_slot * slot , gfn_t gfn , unsigned long npages ) {end_gfn = gfn + npages ;gfn += 1 ;",3076
893,"int lpc = 0 ;int csock = 0 ;unsigned laddr ;time_t now = 0 ;# ifdef HAVE_GNUTLS_GNUTLS_H  gnutls_session * session = NULL ;# endif cib_client_t * new_client = NULL ;xmlNode * login = NULL ;const char * user = NULL ;const char * pass = NULL ;const char * tmp = NULL ;# ifdef HAVE_DECL_NANOSLEEP const struct timespec sleepfast = {0 , 10000000 };# endif static struct mainloop_fd_callbacks remote_client_fd_callbacks = {",int csock = 0 ;unsigned laddr ;time_t now = 0 ;int flag ;# ifdef HAVE_GNUTLS_GNUTLS_H gnutls_session * session = NULL ;static struct mainloop_fd_callbacks remote_client_fd_callbacks = {,3077
894,"if ( ssock == remote_tls_fd ) {# ifdef HAVE_GNUTLS_GNUTLS_H  session = create_tls_session ( csock , GNUTLS_SERVER ) ;if ( session == NULL ) {do {crm_trace ( ""Iter:<S2SV_blank>%d"" , lpc ++ ) ;# ifdef HAVE_GNUTLS_GNUTLS_H  login = crm_recv_remote_msg ( session , TRUE ) ;# endif }login = crm_recv_remote_msg ( GINT_TO_POINTER ( csock ) , FALSE ) ;}","if ( ( flag = fcntl ( csock , F_GETFL ) ) >= 0 ) {if ( fcntl ( csock , F_SETFL , flag | O_NONBLOCK ) < 0 ) {crm_err ( ""fcntl()<S2SV_blank>write<S2SV_blank>failed"" ) ;close ( csock ) ;return TRUE ;}}else {crm_err ( ""fcntl()<S2SV_blank>read<S2SV_blank>failed"" ) ;close ( csock ) ;return TRUE ;}if ( ssock == remote_tls_fd ) {# ifdef HAVE_GNUTLS_GNUTLS_H session = crm_create_anon_tls_session ( csock , GNUTLS_SERVER , anon_cred_s ) ;if ( session == NULL ) {num_clients ++ ;new_client = calloc ( 1 , sizeof ( cib_client_t ) ) ;new_client -> id = crm_generate_uuid ( ) ;new_client -> callback_id = NULL ;new_client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , new_client ) ;# ifdef HAVE_GNUTLS_GNUTLS_H new_client -> encrypted = TRUE ;new_client -> session = session ;# endif }new_client -> session = GINT_TO_POINTER ( csock ) , FALSE ) ;}",3077
895,"free_xml ( login ) ;login = create_xml_node ( NULL , ""cib_result"" ) ;crm_xml_add ( login , F_CIB_OPERATION , CRM_OP_REGISTER ) ;crm_xml_add ( login , F_CIB_CLIENTID , new_client -> id ) ;crm_send_remote_msg ( new_client -> session , login , new_client -> encrypted ) ;free_xml ( login ) ;return TRUE ;bail :  if ( ssock == remote_tls_fd ) {# ifdef HAVE_GNUTLS_GNUTLS_H gnutls_bye ( * session , GNUTLS_SHUT_RDWR ) ;gnutls_deinit ( * session ) ;gnutls_free ( session ) ;# endif }close ( csock ) ;free_xml ( login ) ;","
",3077
896,if ( serial -> num_ports < 2 )  return - 1 ;,if ( serial -> num_bulk_out < 2 ) return - 1 ;,3078
897,int n ;if ( ! body -> unit_size )  break ;n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 )  / body -> unit_size ;,unsigned int n ;if ( ! body -> unit_size || len < sizeof ( struct oz_multiple_fixed ) - 1 ) ) / body -> unit_size ;,3079
898,"StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\\\'buttons\\\'><tr>"" ) ;if ( s -> start ) StringBuffer_append ( res -> outputbuffer ,  ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>""  ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'start\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Start<S2SV_blank>service\\\'></form></td>"" , s -> name ) ;if ( s -> stop ) StringBuffer_append ( res -> outputbuffer ,  ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>""  ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'stop\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Stop<S2SV_blank>service\\\'></form></td>"" , s -> name ) ;if ( ( s -> start && s -> stop ) || s -> restart ) StringBuffer_append ( res -> outputbuffer ,  ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>""  ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'restart\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Restart<S2SV_blank>service\\\'></form></td>"" , s -> name ) ;}","StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'start\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Start<S2SV_blank>service\\\'>"" ""</form>"" ""</td>"" , s -> name , res -> token ) ;if ( s -> start ) StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'stop\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Stop<S2SV_blank>service\\\'>"" ""</form>"" ""</td>"" , s -> name , res -> token ) ;if ( s -> stop ) StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'restart\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Restart<S2SV_blank>service\\\'>"" ""</form>"" ""</td>"" , s -> name , res -> token ) ;StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'%s\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'%s\\\'>"" ""</form>"" ""</td>"" , s -> name , res -> token , s -> name ) ;if ( ( s -> start && s -> stop ) || s -> restart ) StringBuffer_append ( res -> outputbuffer , ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'restart\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Restart<S2SV_blank>service\\\'></form></td>"" , s -> name ) ;StringBuffer_append ( res -> outputbuffer , ""</tr></table>"" ) ;}",3080
899,"if ( ! in_group_p ( inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  mode &= ~ S_ISGID ;","if ( ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) mode &= ~ S_ISGID ;",3081
900,"static int ceph_x_decrypt ( struct ceph_crypto_key * secret ,  void * * p , void * end , void * obuf , size_t olen )  {ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen ,  * p , len ) ;","static int ceph_x_decrypt ( struct ceph_crypto_key * secret , void * * p , void * end , void * * obuf , size_t olen ) {if ( * obuf == NULL ) {* obuf = kmalloc ( len , GFP_NOFS ) ;if ( ! * obuf ) return - ENOMEM ;olen = len ;}ret = ceph_decrypt2 ( secret , & head , & head_len , * obuf , & olen , * p , len ) ;",3082
901,"static void ptrace_triggered ( struct perf_event * bp , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {","static void ptrace_triggered ( struct perf_event * bp , struct perf_sample_data * data , struct pt_regs * regs ) {",3083
902,"
",int nb_bits = req [ offset + 5 ] ;,3084
903,"int mapping_address = address - mb_mapping -> start_bits ;if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\\","int mapping_address = address - mb_mapping -> start_bits ;if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\\",3084
904,"int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;int mapping_address = address - mb_mapping -> start_registers ;if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\\","int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;int nb_bytes = req [ offset + 5 ] ;int mapping_address = address - mb_mapping -> start_registers ;if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\\",3084
905,if ( net != c_net || ! tc -> t_sock )  continue ;,if ( net != c_net ) continue ;,3085
906,struct resv_map * reservations = vma_resv_map ( vma ) ;unsigned long reserve ;,struct resv_map * reservations = vma_resv_map ( vma ) ;struct hugepage_subpool * spool = subpool_vma ( vma ) ;unsigned long reserve ;,3086
907,"hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ;}","hugepage_subpool_put_pages ( spool , reserve ) ;}",3086
908,sc = create_spnego_ctx ( ) ;if ( sc == NULL ) {,sc = create_spnego_ctx ( 0 ) ;if ( sc == NULL ) {,3087
909,"
",}else if ( request_size < 0 ) {rc = - EINVAL ;goto out_free_buffer ;,3088
910,}},}},3088
911,rfcomm_dlc_accept ( d ) ;msg -> msg_namelen = 0 ;,rfcomm_dlc_accept ( d ) ;,3089
912,case \'<S2SV_blank>\' : case \'=\' :  case \'\\\\r\' :  case \'\\\,"case \'<S2SV_blank>\' : case \'=\' : case \\\'""\\\' : case \'\\\\\\\\\' : case \'\\\\r\' : case \'\\\",3090
913,return in ;},return NULL ;},3091
914,"int perf_event_overflow ( struct perf_event * event , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {return __perf_event_overflow ( event , nmi , 1 , data , regs ) ;}","int perf_event_overflow ( struct perf_event * event , struct perf_sample_data * data , struct pt_regs * regs ) {return __perf_event_overflow ( event , 1 , data , regs ) ;}",3092
915,"size_t i ;generic_gss_release_oid ( & tmpmin , & sc -> internal_mech ) ;",size_t i ;,3093
916,"int err ;err = crypto_ahash_export ( req , state ) ;if ( err ) return err ;ctx2 -> more = 1 ;err = crypto_ahash_import ( & ctx2 -> req , state ) ;","bool more ;int err ;lock_sock ( sk ) ;more = ctx -> more ;err = more ? crypto_ahash_export ( req , state ) : 0 ;release_sock ( sk ) ;if ( err ) return err ;ctx2 -> more = more ;if ( ! more ) return err ;err = crypto_ahash_import ( & ctx2 -> req , state ) ;",3094
917,"flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ;","if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ;flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ;",3095
918,"void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType )  {","static void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {",3096
919,"BOOL security_decrypt ( BYTE * data , int length , rdpRdp * rdp )  {if ( rdp -> decrypt_use_count >= 4096 ) {","BOOL security_decrypt ( BYTE * data , int length , rdpRdp * rdp ) {if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ;if ( rdp -> decrypt_use_count >= 4096 ) {",3097
920,"const char * errstr ;if ( ( gr = getgrnam ( s ) ) != NULL ) {# else  sscanf ( s , ""%d"" , gid ) ;# endif  if ( errstr ) return - 1 ;return 0 ;}","# if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) const char * errstr = NULL ;# else int status ;# endif if ( ( gr = getgrnam ( s ) ) != NULL ) {if ( errstr ) return - 1 ;# else status = sscanf ( s , ""%d"" , gid ) ;if ( status != 1 ) return - 1 ;# endif return 0 ;}",3098
921,"void recovery_cipher_finalize ( void )  {static char CONFIDENTIAL new_mnemonic [ MNEMONIC_BUF ] = """" ;","void recovery_cipher_finalize ( void ) {if ( ! recovery_started ) {recovery_abort ( ) ;fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ;layoutHome ( ) ;return ;}static char CONFIDENTIAL new_mnemonic [ MNEMONIC_BUF ] = """" ;",3099
922,new_mnemonic [ strlen ( new_mnemonic ) - 1 ] = \'\\\\0\' ;if ( ! dry_run && ( ! enforce_wordlist || mnemonic_check ( new_mnemonic ) ) ) {,"new_mnemonic [ MAX ( 0u , strnlen ( new_mnemonic , sizeof ( new_mnemonic ) ) - 1 ) ] = \'\\\\0\' ;if ( ! dry_run && ( ! enforce_wordlist || mnemonic_check ( new_mnemonic ) ) ) {",3099
923,"Fp = fopen ( filename , ""wb"" ) ;if ( Fp == NULL )  return HTTP_UNAUTHORIZED ;}","# ifdef UPNP_ENABLE_POST_WRITE Fp = fopen ( filename , ""wb"" ) ;if ( Fp == NULL ) return HTTP_UNAUTHORIZED ;# else return HTTP_NOT_FOUND ;# endif }",3100
924,inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;,"uint16 bps = 0 ;( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ;if ( bps != 8 ) {TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpSeparate2ContigByRow"" ) ;return 0 ;}inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;",3101
925,}if ( addr_len ) * addr_len = sizeof ( * saddr ) ;,* addr_len = sizeof ( * saddr ) ;},3102
926,if ( iterator -> next ) rfbDecrClientRef ( iterator -> next ) ;free ( iterator ) ;,if ( iterator && iterator -> next ) rfbDecrClientRef ( iterator -> next ) ;free ( iterator ) ;,3103
927,if ( key -> type -> destroy )  key -> type -> destroy ( key ) ;,"if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ;",3104
928,ptrdiff_t ext_first_part_size = token_part_sizes - pbi -> fragments . ptrs [ 0 ] + 3 * ( num_token_partitions - 1 ) ;,ptrdiff_t ext_first_part_size = token_part_sizes - pbi -> fragments . ptrs [ 0 ] + 3 * ( num_token_partitions - 1 ) {;,3105
929,# if CONFIG_MULTITHREAD  if ( pbi -> decoding_thread_count > num_token_partitions - 1 )   pbi -> decoding_thread_count = num_token_partitions - 1 ;# endif },# if CONFIG_MULTITHREAD if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) pbi -> decoding_thread_count = num_token_partitions - 1 ;}if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) {pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ;}# endif },3105
930,if ( fileblock < INDIRECT_BLOCKS )  blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ;else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 )  {,if ( fileblock < INDIRECT_BLOCKS ) {blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ;}else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) {,3106
931,"static int blosc_c ( struct thread_context * thread_context , int32_t bsize ,  int32_t leftoverblock , int32_t ntbytes , int32_t maxbytes ,  const uint8_t * src , const int32_t offset , uint8_t * dest , uint8_t * tmp , uint8_t * tmp2 ) {","static int blosc_c ( struct thread_context * thread_context , int32_t bsize , int32_t leftoverblock , int32_t ntbytes , int32_t destsize , const uint8_t * src , const int32_t offset , uint8_t * dest , uint8_t * tmp , uint8_t * tmp2 ) {",3107
932,"_sw32 ( dest - 4 , - value ) ;continue ;# endif  if ( ntbytes + maxout > maxbytes ) {maxout = ( int64_t ) maxbytes - ( int64_t ) ntbytes ;if ( maxout <= 0 ) {","if ( ntbytes > destsize ) {return - 1 ;}_sw32 ( dest - 4 , - value ) ;continue ;# endif if ( ntbytes + maxout > destsize ) {maxout = ( int64_t ) destsize - ( int64_t ) ntbytes ;if ( maxout <= 0 ) {",3107
933,if ( ( ntbytes + neblock ) > maxbytes ) {return 0 ;,if ( ( ntbytes + neblock ) > destsize ) {return 0 ;,3107
934,"zval_ptr_dtor ( value ) ;zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" , 0 ) ;","zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" , 0 ) ;",3108
935,"BIO * tmpout = NULL ;if ( out == NULL ) tmpout = BIO_new ( BIO_s_null ( ) ) ;else if ( flags & CMS_TEXT ) {tmpout = BIO_new ( BIO_s_mem ( ) ) ;BIO_set_mem_eof_return ( tmpout , 0 ) ;else tmpout = out ;","BIO * tmpout ;tmpout = cms_get_text_bio ( out , flags ) ;if ( ! tmpout ) {CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ;goto err ;for ( ;;) {i = BIO_read ( in , buf , sizeof ( buf ) ) ;if ( i <= 0 ) {if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) {if ( ! BIO_get_cipher_status ( in ) ) goto err ;}if ( i < 0 ) goto err ;break ;}if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ;}if ( flags & CMS_TEXT ) {",3109
936,continue ;},buffer_size -= ( size_t ) pkg_length ;continue ;},3110
937,continue ;},buffer_size -= ( size_t ) pkg_length ;continue ;},3110
938,}},buffer_size -= ( size_t ) pkg_length ;}},3110
939,"if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 )  isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ;else  isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ;break ;","if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 ) ;else isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ;break ;",3111
940,int copylen ;bool zerocopy = false ;,int copylen = 0 ;bool zerocopy = false ;err = - EMSGSIZE ;if ( unlikely ( count > UIO_MAXIOV ) ) goto err ;,3112
941,"if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) )  zerocopy = true ;copylen = vnet_hdr . hdr_len ;if ( ! copylen ) copylen = GOODCOPY_LEN ;","if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) zerocopy = true ;if ( count > MAX_SKB_FRAGS ) {copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ;if ( copylen < vnet_hdr_len ) copylen = 0 ;else copylen -= vnet_hdr_len ;}if ( copylen < vnet_hdr . hdr_len ) copylen = vnet_hdr . hdr_len ;if ( ! copylen ) copylen = GOODCOPY_LEN ;",3112
942,problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;,"
",3113
943,"return kvm_x86_ops -> set_msr ( vcpu , msr ) ;}","switch ( msr -> index ) {case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ;break ;case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ;}return kvm_x86_ops -> set_msr ( vcpu , msr ) ;}",3114
944,struct perf_event_context * ctx ;struct file * event_file = NULL ;,"struct perf_event_context * ctx , * uninitialized_var ( gctx ) ;struct file * event_file = NULL ;",3115
945,"if ( group_leader -> ctx -> task != ctx -> task ) goto err_context ;if ( group_leader -> cpu != event -> cpu ) goto err_context ;else {if ( group_leader -> ctx != ctx ) goto err_context ;if ( attr . exclusive || attr . pinned ) goto err_context ;if ( output_event ) {err = perf_event_set_output ( event , output_event ) ;if ( err ) goto err_context ;event_file = anon_inode_getfile ( ""[perf_event]"" , & perf_fops , event , f_flags ) ;if ( IS_ERR ( event_file ) ) {err = PTR_ERR ( event_file ) ;goto err_context ;struct perf_event_context * gctx = group_leader -> ctx ;mutex_lock ( & gctx -> mutex ) ;perf_remove_from_context ( group_leader , false ) ;perf_event__state_init ( group_leader ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_remove_from_context ( sibling , false ) ;perf_event__state_init ( sibling ) ;mutex_unlock ( & gctx -> mutex ) ;put_ctx ( gctx ) ;","gctx = group_leader -> ctx ;mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ;perf_remove_from_context ( group_leader , false ) ;perf_event__state_init ( group_leader ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_remove_from_context ( sibling , false ) ;perf_event__state_init ( sibling ) ;put_ctx ( gctx ) ;else {mutex_lock ( & ctx -> mutex ) ;WARN_ON_ONCE ( ctx -> parent_ctx ) ;if ( move_group ) {synchronize_rcu ( ) ;perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ;get_ctx ( ctx ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_install_in_context ( ctx , sibling , sibling -> cpu ) ;get_ctx ( ctx ) ;perf_install_in_context ( ctx , event , event -> cpu ) ;perf_unpin_context ( ctx ) ;mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & gctx -> mutex ) ;put_ctx ( gctx ) ;",3115
946,"}perf_install_in_context ( ctx , event , event -> cpu ) ;perf_unpin_context ( ctx ) ;","
",3115
947,"return crypto_alloc_skcipher ( name , type , mask ) ;}","struct skcipher_tfm * tfm ;struct crypto_skcipher * skcipher ;tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ;if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ;skcipher = crypto_alloc_skcipher ( name , type , mask ) ;if ( IS_ERR ( skcipher ) ) {kfree ( tfm ) ;return ERR_CAST ( skcipher ) ;}tfm -> skcipher = skcipher ;return tfm ;}",3116
948,if ( x & ( 1 << i ) ) return i ;},if ( x & ( 1U << ( unsigned int ) i ) ) return i ;},3117
949,"if ( attr >= 0 ) {xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ;","if ( attr >= 0 && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS ) {xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ;",3118
950,int req_len ;struct qeth_arp_query_info qinfo = {,unsigned int req_len ;struct qeth_arp_query_info qinfo = {,3119
951,"if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  return - EFAULT ;ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ;","if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) return - EFAULT ;if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL ;ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ;",3119
952,"separator = strchr ( connection -> buffer , '=' ) ;if ( ! separator ) return ERROR_INVALID_TAG ;","separator = osStrchr ( connection -> buffer , '=' ) ;if ( ! separator ) return ERROR_INVALID_TAG ;",3120
953,"const int min_frame_target = MAX ( rc -> min_frame_bandwidth ,   rc -> av_per_frame_bandwidth >> 5 ) ;if ( target < min_frame_target ) target = min_frame_target ;return target ;}","const VP9EncoderConfig * oxcf = & cpi -> oxcf ;const int min_frame_target = MAX ( rc -> min_frame_bandwidth , rc -> avg_frame_bandwidth >> 5 ) ;if ( target < min_frame_target ) target = min_frame_target ;if ( oxcf -> rc_max_inter_bitrate_pct ) {const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ;target = MIN ( target , max_rate ) ;}return target ;}",3121
954,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},3122
955,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,3122
956,"deconstruct_array ( key_array , TEXTOID , - 1 , false , \'i\' ,  & key_datums , & key_nulls , & key_count ) ;if ( PG_ARGISNULL ( 1 ) ) {","deconstruct_array ( key_array , TEXTOID , - 1 , false , \'i\' , & key_datums , & key_nulls , & key_count ) ;if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;if ( PG_ARGISNULL ( 1 ) ) {",3123
957,"if ( ! unqueue_me ( & q ) )  goto out_put_key ;ret = - ETIMEDOUT ;if ( to && ! to -> task )  goto out_put_key ;if ( ! signal_pending ( current ) ) {put_futex_key ( fshared , & q . key ) ;goto retry ;}ret = - ERESTARTSYS ;if ( ! abs_time )  goto out_put_key ;restart = & current_thread_info ( ) -> restart_block ;",if ( ! unqueue_me ( & q ) ) goto out ;ret = - ETIMEDOUT ;if ( to && ! to -> task ) goto out ;if ( ! signal_pending ( current ) ) goto retry ;}ret = - ERESTARTSYS ;if ( ! abs_time ) goto out_put_key ;restart = & current_thread_info ( ) -> restart_block ;,3124
958,"out_put_key :  put_futex_key ( fshared , & q . key ) ;","
",3124
959,xstep = picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;,"if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;",3125
960,if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {",3125
961,"static char * print_value ( cJSON * item , int depth , int fmt )  {if ( ! item )  return 0 ;switch ( ( item -> type ) & 255 ) {case cJSON_NULL : out = cJSON_strdup ( ""null"" ) ;case cJSON_False : out = cJSON_strdup ( ""false"" ) ;break ;case cJSON_True : out = cJSON_strdup ( ""true"" ) ;case cJSON_Number : out = print_number ( item ) ;case cJSON_String : out = print_string ( item ) ;case cJSON_Array : out = print_array ( item , depth , fmt ) ;case cJSON_Object : out = print_object ( item , depth , fmt ) ;}","static char * print_value ( cJSON * item , int depth , int fmt , printbuffer * p ) {if ( ! item ) return 0 ;if ( p ) {switch ( ( item -> type ) & 255 ) {case cJSON_NULL : {out = ensure ( p , 5 ) ;if ( out ) strcpy ( out , ""null"" ) ;}case cJSON_False : {out = ensure ( p , 6 ) ;if ( out ) strcpy ( out , ""false"" ) ;}case cJSON_True : {out = ensure ( p , 5 ) ;if ( out ) strcpy ( out , ""true"" ) ;}case cJSON_Number : out = print_number ( item , 0 , p ) ;case cJSON_String : out = print_string ( item , 0 , p ) ;case cJSON_Array : out = print_array ( item , depth , fmt , 0 ) ;}}",3126
962,"static int rd_inter16x16_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel )  {vp8_build_inter16x16_predictors_mbuv ( & x -> e_mbd ) ;","static int rd_inter16x16_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel ) {( void ) cpi ;( void ) fullpixel ;vp8_build_inter16x16_predictors_mbuv ( & x -> e_mbd ) ;",3127
963,"static void update_coef_probs ( VP9_COMP * cpi , vp9_writer * w ) {const TX_MODE tx_mode = cpi -> common . tx_mode ;vp9_coeff_stats frame_branch_ct [ TX_SIZES ] [ PLANE_TYPES ] ;vp9_clear_system_state ( ) ;++ tx_size ) build_tree_distribution ( cpi , tx_size , frame_branch_ct [ tx_size ] ) ;for ( tx_size = TX_4X4 ;tx_size <= max_tx_size ;++ tx_size )   update_coef_probs_common ( w , cpi , tx_size , frame_branch_ct [ tx_size ] ) ;}","static void update_coef_probs ( VP9_COMP * cpi , vpx_writer * w ) {const TX_MODE tx_mode = cpi -> common . tx_mode ;+ tx_size ) build_tree_distribution ( cpi , tx_size , frame_branch_ct [ tx_size ] ) ;+ tx_size )   update_coef_probs_common ( w , cpi , tx_size , frame_branch_ct [ tx_size ] ) ;++ tx_size ) {vp9_coeff_stats frame_branch_ct [ PLANE_TYPES ] ;vp9_coeff_probs_model frame_coef_probs [ PLANE_TYPES ] ;if ( cpi -> td . counts -> tx . tx_totals [ tx_size ] <= 20 || ( tx_size >= TX_16X16 && cpi -> sf . tx_size_search_method == USE_TX_8X8 ) ) {vpx_write_bit ( w , 0 ) ;}else {build_tree_distribution ( cpi , tx_size , frame_branch_ct , frame_coef_probs ) ;}}}",3128
964,"ptr = strchr ( ptr + 1 , '/' ) + 1 ;rw_exit ( & sdvp -> sdev_contents ) ;","ptr = strchr ( ptr + 1 , '/' ) ;if ( ptr == NULL ) return ( ENOENT ) ;ptr ++ ;rw_exit ( & sdvp -> sdev_contents ) ;",3129
965,"if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 ||  ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\","if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\",3130
966,},"assert_regexp_syntax_error ( ""\\\\\\\\x0"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\xxy"" ) ;}",3131
967,"
",L -> oldpc = 0 ;,3132
968,},},3132
969,"static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len ,  const u_char * ep , uint32_t phase , uint32_t doi0 _U_ ,   uint32_t proto0 _U_ , int depth )  {","static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) {",3133
970,"ND_PRINT ( ( ndo , ""<S2SV_blank>orig=("" ) ) ;switch ( ntohs ( n . type ) ) {size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ;while ( cp < ep && cp < ep2 ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;break ;}case IPSECDOI_NTYPE_REPLAY_STATUS :  ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ;break ;case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN : if ( ikev1_sub_print ( ndo , ISAKMP_NPTYPE_SA , ( const struct isakmp_gen * ) cp , ep , phase , doi , proto , depth ) == NULL ) return NULL ;default :  isakmp_print ( ndo , cp ,  item_len - sizeof ( * p ) - n . spi_size , NULL ) ;ND_PRINT ( ( ndo , "")"" ) ) ;}","switch ( ntohs ( n . type ) ) {size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) ) ;ND_PRINT ( ( ndo , "")"" ) ) ;break ;}case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ;ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ;break ;case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN : if ( ikev1_sub_print ( ndo , ISAKMP_NPTYPE_SA , ( const struct isakmp_gen * ) cp , ep , phase , doi , proto , depth ) == NULL ) return NULL ;break ;default : if ( ndo -> ndo_vflag > 3 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ;}else {if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ;if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ;ND_PRINT ( ( ndo , "")"" ) ) ;}",3133
971,cond_branch : f_offset = addrs [ i + filter [ i ] . jf ] - addrs [ i ] ;,cond_branch : f_offset = addrs [ i + filter [ i ] . jf && f_offset ] - addrs [ i ] ;,3134
972,"if ( filter [ i ] . jf )   t_offset += is_near ( f_offset ) ? 2 : 6 ;EMIT_COND_JMP ( t_op , t_offset ) ;","if ( filter [ i ] . jf ) t_offset += is_near ( f_offset ) ? 2 : 5 ;EMIT_COND_JMP ( t_op , t_offset ) ;",3134
973,"if ( test_bit ( DMF_FREEING , & md -> flags ) ||   dm_deleting_md ( md ) )  return NULL ;dm_get ( md ) ;return md ;","spin_lock ( & _minor_lock ) ;if ( test_bit ( DMF_FREEING , & md -> flags ) || dm_deleting_md ( md ) ) {md = NULL ;goto out ;}dm_get ( md ) ;out : spin_unlock ( & _minor_lock ) ;return md ;",3135
974,if ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) )  {,if ( ! ps_dec -> u1_first_slice_in_stream && ps_dec -> u4_first_slice_in_pic == 2 ) ) {,3136
975,if ( ps_dec -> u4_first_slice_in_pic != 2 )  {,if ( ps_dec -> u4_first_slice_in_pic == 0 ) {,3136
976,prev_slice_err = 1 ;}else {prev_slice_err = 2 ;}if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ;else ps_cur_slice -> u1_bottom_field_flag = 0 ;num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ;ps_cur_poc = & ps_dec -> s_cur_pic_poc ;u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ;}else if ( ps_dec -> u4_first_slice_in_pic == 2 )  {,"
",3136
977,else {if ( ps_dec -> u4_first_slice_in_pic )  {prev_slice_err = 1 ;num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ;}num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs )  - ps_dec -> u2_total_mbs_coded ;}if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded )  {num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff )  - ps_dec -> u2_total_mbs_coded ;ps_cur_poc = & s_tmp_poc ;else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) {,num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ;if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) {prev_slice_err = 2 ;num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) {num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ;ps_cur_poc = & s_tmp_poc ;else if ( ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ) {,3136
978,"if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) {ps_dec -> u1_first_slice_in_stream = 0 ;return ERROR_IN_LAST_SLICE_OF_PIC ;}if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) {ih264d_err_pic_dispbuf_mgr ( ps_dec ) ;return ERROR_NEW_FRAME_EXPECTED ;}if ( ret != OK ) return ret ;i1_is_end_of_poc = 0 ;}if ( ps_dec -> u4_first_slice_in_pic == 0 ) {ps_dec -> ps_parse_cur_slice ++ ;ps_dec -> u2_cur_slice_num ++ ;}if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) {ps_dec -> ps_decode_cur_slice ++ ;}ps_dec -> u1_slice_header_done = 0 ;if ( u1_field_pic_flag ) {ps_dec -> u2_prv_frame_num = u2_frame_num ;}if ( ps_cur_slice -> u1_mmco_equalto5 ) {WORD32 i4_temp_poc ;WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ;if ( ! ps_cur_slice -> u1_field_pic_flag ) {i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ;}else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ;ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ;}if ( ps_dec -> u4_first_slice_in_pic == 2 )  {ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ;if ( ret != OK ) return ret ;if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ;if ( i4_poc == 0 ) {ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ;ps_dec -> i4_max_poc = 0 ;}}ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ;ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ;ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ;ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ;ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ;ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ;ps_cur_slice -> u1_slice_type = u1_slice_type ;ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ;ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ;ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ;ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ;ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ;if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ;else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ;if ( u1_slice_type == B_SLICE ) {ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ;if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ;else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ;if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ;}else {if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ;}if ( ps_dec -> u4_first_slice_in_pic == 2 )  {if ( u2_first_mb_in_slice == 0 ) {ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ;if ( ret != OK ) return ret ;}ps_dec -> u4_output_present = 0 ;{ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ;if ( 0 != ps_dec -> s_disp_op . u4_error_code ) {ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ;}else ps_dec -> u4_output_present = 1 ;}if ( ps_dec -> u1_separate_parse == 1 ) {if ( ps_dec -> u4_dec_thread_created == 0 ) {ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ;ps_dec -> u4_dec_thread_created = 1 ;}if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) {ps_dec -> u4_start_recon_deblk = 0 ;ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ;ps_dec -> u4_bs_deblk_thread_created = 1 ;}}}{UWORD8 uc_nofield_nombaff ;uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ;if ( uc_nofield_nombaff ) {ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ;ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ;}else {ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ;ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ;}}{dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ;if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) {ps_err -> u1_err_flag = ACCEPT_ALL_PICS ;ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ;}ps_err -> u4_cur_frm = u2_frame_num ;}{WORD32 i4_skip_b_pic , i4_skip_p_pic ;i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ;i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ;if ( i4_skip_b_pic ) {ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ;ps_dec -> u1_last_pic_not_decoded = 1 ;return OK ;}if ( i4_skip_p_pic ) {ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ;ps_dec -> u1_last_pic_not_decoded = 1 ;return OK ;}{UWORD16 u2_mb_x , u2_mb_y ;ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ;",if ( ps_dec -> u2_total_mbs_coded ;ps_cur_poc = & s_tmp_poc ;else if ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ;,3136
979,ps_dec -> u4_first_slice_in_pic = 0 ;ps_dec -> u1_first_slice_in_stream = 0 ;,ps_dec -> u4_first_slice_in_pic = 0 ;ps_dec -> u1_first_slice_in_stream = 0 ;,3136
980,break ;case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) {if ( s -> codec_id == AV_CODEC_ID_JV ) {w_align = 8 ;,if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) {w_align = 8 ;h_align = 8 ;}break ;case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) {if ( s -> codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) {w_align = 8 ;,3137
981,"case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) , ( int __user * ) arg ) ;if ( L_ICANON ( tty ) )  retval = inq_canon ( ldata ) ;","case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) && ! L_EXTPROC ( tty ) , ( int __user * ) arg ) ;if ( L_ICANON ( tty ) ) retval = inq_canon ( ldata ) ;",3138
982,sun_info . height = ReadBlobMSBLong ( image ) ;sun_info . depth = ReadBlobMSBLong ( image ) ;sun_info . length = ReadBlobMSBLong ( image ) ;sun_info . type = ReadBlobMSBLong ( image ) ;sun_info . maptype = ReadBlobMSBLong ( image ) ;sun_info . maplength = ReadBlobMSBLong ( image ) ;extent = sun_info . height * sun_info . width ;,bytes_per_line = sun_info . width * sun_info . depth ;sun_info . height ;,3139
983,"sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length ,   sizeof ( * sun_data ) ) ;if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;height = sun_info . height ;bytes_per_line = sun_info . width * sun_info . depth ;","sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ;if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;height = sun_info . height ;bytes_per_line = sun_info . width * sun_info . depth ;",3139
984,"int release_vp9_frame_buffer ( void * cb_priv ,  vpx_codec_frame_buffer_t * fb ) {","static int release_vp9_frame_buffer ( void * cb_priv , vpx_codec_frame_buffer_t * fb ) {",3140
985,"void vp9_cost_tokens ( int * costs , const vp9_prob * probs , vp9_tree tree ) {cost ( costs , tree , probs , 0 , 0 ) ;","void vp9_cost_tokens ( int * costs , const vpx_prob * probs , vp9_tree tree ) {cost ( costs , tree , probs , 0 , 0 ) ;",3141
986,"vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ;vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ;vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ;","unsigned long cr4 ;vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ;cr4 = read_cr4 ( ) ;vmcs_writel ( HOST_CR4 , cr4 ) ;vmx -> host_state . vmcs_host_cr4 = cr4 ;",3142
987,value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) |   ( ( unsigned char * ) buffer ) [ 1 ] ) ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;,value = ( unsigned short ) buffer [ 1 ] << 8 ) | buffer [ 0 ] ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | ( ( unsigned char * ) buffer ) [ 1 ] ) ;quantum . unsigned_value = value & 0xffff ) ;return ( quantum . signed_value ) ;,3143
988,"code = validate_as_request ( kdc_active_realm , request , * princ ,  no_server , kdc_time , status , & e_data ) ;","princ -> pw_expiration = 0 ;clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;code = validate_as_request ( kdc_active_realm , request , * princ , no_server , kdc_time , status , & e_data ) ;",3144
989,"dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\\","dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\\",3145
990,"u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ;if ( ! d ) return - ENODEV ;if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 )  return - EAGAIN ;switch ( num ) {case 1 : switch ( msg [ 0 ] . addr ) {case SU3000_STREAM_CTRL :  obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ;obuf [ 1 ] = 3 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case DW2102_RC_QUERY :  obuf [ 0 ] = 0x10 ;if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ;msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ;break ;default :  obuf [ 0 ] = 0x08 ;obuf [ 1 ] = msg [ 0 ] . addr ;obuf [ 2 ] = msg [ 0 ] . len ;memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 ,   ibuf , 1 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case 2 :  obuf [ 0 ] = 0x09 ;obuf [ 1 ] = msg [ 0 ] . len ;obuf [ 2 ] = msg [ 1 ] . len ;obuf [ 3 ] = msg [ 0 ] . addr ;memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 ,   ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ;break ;mutex_unlock ( & d -> i2c_mutex ) ;return num ;","struct dw2102_state * state ;if ( ! d ) return - ENODEV ;state = d -> priv ;if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) return - EAGAIN ;if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) {mutex_unlock ( & d -> i2c_mutex ) ;return - EAGAIN ;}switch ( num ) {case 1 : switch ( msg [ 0 ] . addr ) {case SU3000_STREAM_CTRL : state -> data [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ;state -> data [ 1 ] = 3 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 0 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;break ;case DW2102_RC_QUERY : state -> data [ 0 ] = 0x10 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 2 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msg [ 0 ] . buf [ 1 ] = state -> data [ 0 ] ;msg [ 0 ] . buf [ 0 ] = state -> data [ 1 ] ;default : state -> data [ 0 ] = 0x08 ;state -> data [ 1 ] = msg [ 0 ] . addr ;state -> data [ 2 ] = msg [ 0 ] . len ;memcpy ( & state -> data [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , state -> data , msg [ 0 ] . len + 3 , state -> data , 1 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case 2 : state -> data [ 0 ] = 0x09 ;state -> data [ 1 ] = msg [ 0 ] . len ;state -> data [ 2 ] = msg [ 1 ] . len ;state -> data [ 3 ] = msg [ 0 ] . addr ;memcpy ( & state -> data [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , state -> data , msg [ 0 ] . len + 4 , state -> data , msg [ 1 ] . len + 1 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;memcpy ( msg [ 1 ] . buf , & state -> data [ 1 ] , msg [ 1 ] . len ) ;break ;mutex_unlock ( & d -> data_mutex ) ;mutex_unlock ( & d -> i2c_mutex ) ;return num ;",3146
991,blockcnt = ( ( len + pos ) + blocksize - 1 ) >>  ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ;,if ( len < 1 || len == 0xffffffff ) {return - 1 ;}blockcnt = ( ( len + pos ) + blocksize - 1 ) >> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ;,3147
992,struct cred * cred ;if ( ! ( unshare_flags & CLONE_NEWUSER ) ) return 0 ;cred = prepare_creds ( ) ;if ( ! cred )  return - ENOMEM ;* new_cred = cred ;return create_user_ns ( cred ) ;},struct cred * cred ;int err = - ENOMEM ;if ( cred ) {err = create_user_ns ( cred ) ;if ( err ) put_cred ( cred ) ;else * new_cred = cred ;}return err ;},3148
993,"
",status = register_pernet_subsys ( & sctp_ctrlsock_ops ) ;if ( status ) goto err_register_ctrlsock ;,3149
994,status = sctp_v4_protosw_init ( ) ;if ( status ) goto err_protosw_init ;status = register_pernet_subsys ( & sctp_net_ops ) ;if ( status ) goto err_register_pernet_subsys ;err_add_protocol :  unregister_pernet_subsys ( & sctp_net_ops ) ;err_register_pernet_subsys : sctp_v6_protosw_exit ( ) ;err_protosw_init :  sctp_v4_pf_exit ( ) ;,status = sctp_v4_protosw_init ( ) ;if ( status ) goto err_protosw_init ;status = register_pernet_subsys ( & sctp_net_ops ) ;if ( status ) goto err_register_pernet_subsys ;err_add_protocol : unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ;err_register_ctrlsock : sctp_v6_protosw_exit ( ) ;err_protosw_init : unregister_pernet_subsys ( & sctp_defaults_ops ) ;err_register_defaults : sctp_v4_pf_exit ( ) ;,3149
995,"
",atomic_dec ( & chip -> active ) ;,3150
996,"if ( err < 0 ) goto __error ;usb_chip [ chip -> index ] = chip ;chip -> num_interfaces ++ ;usb_set_intfdata ( intf , chip ) ;atomic_dec ( & chip -> active ) ;mutex_unlock ( & register_mutex ) ;return 0 ;__error : if ( chip ) {if ( ! chip -> num_interfaces )  snd_card_free ( chip -> card ) ;atomic_dec ( & chip -> active ) ;}",},3150
997,"cntsize ( in , & sumlen , & nnode ) ;len = COMPUTESIZE ( nnode , sumlen ) ;","cntsize ( in , & sumlen , & nnode ) ;if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;len = COMPUTESIZE ( nnode , sumlen ) ;",3151
998,"s -> decode_mb = mpeg4_decode_studio_mb ;decode_smpte_tc ( ctx , gb ) ;","s -> interlaced_dct = 0 ;s -> decode_mb = mpeg4_decode_studio_mb ;decode_smpte_tc ( ctx , gb ) ;",3152
999,"ret = read ( p_dev -> fd , & ev , sizeof ( ev ) ) ;if ( ret == 0 ) {","ret = TEMP_FAILURE_RETRY ( read ( p_dev -> fd , & ev , sizeof ( ev ) ) ) ;if ( ret == 0 ) {",3153
1000,"int status = 0 ;cred = rpc_lookup_cred ( ) ;state = nfs4_do_open ( dir , & path , flags , sattr , cred ) ;d_drop ( dentry ) ;","fmode_t fmode = flags & ( FMODE_READ | FMODE_WRITE ) ;int status = 0 ;cred = rpc_lookup_cred ( ) ;state = nfs4_do_open ( dir , & path , fmode , flags , sattr , cred ) ;d_drop ( dentry ) ;",3154
1001,"if ( status == 0 && ( nd -> flags & LOOKUP_OPEN ) != 0 )  status = nfs4_intent_set_file ( nd , & path , state ) ;else  nfs4_close_sync ( & path , state , flags ) ;out_putcred : put_rpccred ( cred ) ;","if ( status == 0 && ( nd -> flags & LOOKUP_OPEN ) != 0 ) status = nfs4_intent_set_file ( nd , & path , state , fmode ) ;out_putcred : put_rpccred ( cred ) ;",3154
1002,"struct key * keyring ;keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;","struct key * keyring ;if ( new -> thread_keyring ) return 0 ;keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;",3155
1003,if ( index > glyphCache -> glyphCache [ id ] . number )  {,if ( index >= glyphCache -> glyphCache [ id ] . number ) {,3156
1004,"end = strchr ( * value + 1 , \\\'""\\\' ) ;if ( ! end ) {end ++ ;}","char * p = end = * value + 1 ;while ( * p ) {if ( * p == \'\\\\\\\\\' ) {p ++ ;* end = * p ;}else {* end = * p ;if ( * p == \\\'""\\\' ) break ;}p ++ ;end ++ ;}if ( * end != \\\'""\\\' ) {end = ++ p ;}",3157
1005,"timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer ,  timer -> base -> get_time ( ) , timr -> it_interval ) ;","timr -> it_overrun += hrtimer_forward ( timer , timer -> base -> get_time ( ) , timr -> it_interval ) ;",3158
1006,if ( ! file )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;,if ( ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;,3159
1007,"cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) :  jas_stream_tmpfile ( ) ;","cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) : jas_stream_tmpfile ( ) ;",3160
1008,"checkstackp ( L , 1 , ra ) ;}","checkstackGCp ( L , 1 , ra ) ;}",3161
1009,vpx_active_map_t map = {0 }map . rows = ( cfg -> g_h + 15 ) / 16 ;,"vpx_active_map_t map = {0 , 0 , 0 }map . rows = ( cfg -> g_h + 15 ) / 16 ;",3162
1010,"
","if ( zPath == 0 ) zPath = """" ;",3163
1011,nPath = ( int ) strlen ( zPath ) ;mTime = zipfileGetTime ( apVal [ 4 ] ) ;,nPath = ( int ) strlen ( zPath ) ;mTime = zipfileGetTime ( apVal [ 4 ] ) ;,3163
1012,union sctp_addr_param * addr_param ;__u32 serial ;int length ;,__u32 serial ;,3164
1013,"addr_param = ( union sctp_addr_param * ) hdr -> params ;length = ntohs ( addr_param -> p . length ) ;if ( length < sizeof ( sctp_paramhdr_t ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) addr_param , commands ) ;if ( ! sctp_verify_asconf ( asoc ,  ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) ,  ( void * ) chunk -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;","if ( ! sctp_verify_asconf ( asoc , ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) , ( void * ) chunk -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;",3164
1014,"sdb_num_set ( sdb , ""num_entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) {if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) {goto beach ;}i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ;if ( i < 0 ) goto beach ;",st32 vnaux = entry -> vn_aux ;if ( vnaux < 1 ) {vstart += vnaux ;,3165
1015,"vstart += entry -> vn_aux ;for ( j = 0 , isum = i + entry -> vn_aux ;","vstart += entry -> vn_aux ;for ( j = 0 , isum = i + entry -> vn_aux ;",3165
1016,"for ( plane = 0 ;plane < 4 && src -> data [ plane ] ;plane ++ )  av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ;","for ( plane = 0 ;plane < 4 && src -> data [ plane ] && src -> linesize [ plane ] ;plane ++ ) av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ;",3166
1017,"DPRINTF ( ""Read<S2SV_blank>sector_count=%d\\\if ( r -> sector_count == 0 ) {scsi_req_complete ( & r -> req , GOOD ) ;return ;}assert ( r -> req . aiocb == NULL ) ;if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) {DPRINTF ( ""Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\\scsi_read_complete ( r , - EINVAL ) ;return ;}n = r -> sector_count ;if ( n > SCSI_DMA_BUF_SIZE / 512 ) n = SCSI_DMA_BUF_SIZE / 512 ;r -> iov . iov_len = n * 512 ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ;r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n ,  scsi_read_complete , r ) ;","r -> iov . iov_len = n * 512 ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ;r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , scsi_read_complete , r ) ;",3167
1018,"vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ;vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;}","memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ;memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;}",3168
1019,char added ;},},3169
1020,pair -> added = 0 ;for ( it = tmp_subnodes -> first ;,for ( it = tmp_subnodes -> first ;,3169
1021,int vm_shared = dst_vma -> vm_flags & VM_SHARED ;struct hstate * h = hstate_vma ( dst_vma ) ;,struct address_space * mapping ;pgoff_t idx ;unsigned long size ;int vm_shared = dst_vma -> vm_flags & VM_SHARED ;struct hstate * h = hstate_vma ( dst_vma ) ;,3170
1022,"if ( vm_shared ) {struct address_space * mapping = dst_vma -> vm_file -> f_mapping ;pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ;spin_lock ( ptl ) ;ret = - EEXIST ;","mapping = dst_vma -> vm_file -> f_mapping ;idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ;if ( vm_shared ) {size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ;ret = - EFAULT ;if ( idx >= size ) goto out_release_nounlock ;spin_lock ( ptl ) ;size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ;ret = - EFAULT ;if ( idx >= size ) goto out_release_unlock ;ret = - EEXIST ;",3170
1023,"if ( error == - EIO ) goto out ;xfs_idata_realloc ( dp , size , XFS_ATTR_FORK ) ;memcpy ( ifp -> if_u1 . if_data , tmpbuffer , size ) ;goto out ;}ASSERT ( blkno == 0 ) ;error = xfs_attr3_leaf_create ( args , blkno , & bp ) ;if ( error ) {error = xfs_da_shrink_inode ( args , 0 , bp ) ;bp = NULL ;","if ( bp && ( xfs_da_shrink_inode ( args , 0 , bp ) ;bp = NULL ;",3171
1024,"if ( ! stream -> config . cfg . g_w || ! stream -> config . cfg . g_h )  fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>Specify<S2SV_blank>stream<S2SV_blank>dimensions<S2SV_blank>with<S2SV_blank>--width<S2SV_blank>(-w)<S2SV_blank>"" ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" , stream -> index ) ;if ( stream -> config . cfg . g_profile != 0 && ! global -> experimental_bitstream ) {fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>profile<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>experimental<S2SV_blank>and<S2SV_blank>requires<S2SV_blank>the<S2SV_blank>--%s<S2SV_blank>flag"" , stream -> index , stream -> config . cfg . g_profile , experimental_bitstream . long_name ) ;if ( ! streami -> config . out_fn )  fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>Output<S2SV_blank>file<S2SV_blank>is<S2SV_blank>required<S2SV_blank>(specify<S2SV_blank>with<S2SV_blank>-o)"" , streami -> index ) ;if ( streami != stream ) {const char * a = stream -> config . out_fn ;const char * b = streami -> config . out_fn ;const char * a = stream -> config . stats_fn ;const char * b = streami -> config . stats_fn ;if ( a && b && ! strcmp ( a , b ) ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)"" , streami -> index , stream -> index ) ;}","( void ) global ;if ( ! stream -> config . cfg . g_input_bit_depth > ( unsigned int ) stream -> config . cfg . g_bit_depth ) {fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>codec<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)<S2SV_blank>less<S2SV_blank>than<S2SV_blank>input<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)"" , stream -> index , ( int ) stream -> config . cfg . g_bit_depth , stream -> config . cfg . g_input_bit_depth ) ;if ( ! streami -> config . out_fn ;const char * b = streami -> config . out_fn ;const char * a = stream -> config . stats_fn ;const char * b = streami -> config . fpmb_stats_fn ;const char * b = streami -> config . fpmb_stats_fn ;if ( a && b && ! strcmp ( a , b ) ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>mb<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)"" , streami -> index , stream -> index ) ;# endif }",3172
1025,"case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR :  ip_printroute ( ndo , cp , option_len ) ;break ;","case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ;break ;",3173
1026,"if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;","if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;return 1 ;}if ( vmx_get_cpl ( vcpu ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;",3174
1027,"if ( ! new_prog ) return - ENOMEM ;delta += cnt - 1 ;env -> prog = prog = new_prog ;insn = new_prog -> insnsi + i + delta ;continue ;}if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) {cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\\return - EINVAL ;}new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ;if ( ! new_prog ) return - ENOMEM ;delta += cnt - 1 ;env -> prog = prog = new_prog ;insn = new_prog -> insnsi + i + delta ;continue ;}if ( insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) {const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ;const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ;struct bpf_insn * patch = & insn_buf [ 0 ] ;bool issrc , isneg ;u32 off_reg ;aux = & env -> insn_aux_data [ i + delta ] ;if ( ! aux -> alu_state || aux -> alu_state == BPF_ALU_NON_POINTER ) continue ;isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ;issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ;off_reg = issrc ? insn -> src_reg : insn -> dst_reg ;if ( isneg )   * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ;* patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ;* patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ;* patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ;* patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ;* patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ;* patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ;if ( ! issrc ) * patch ++ = BPF_MOV64_REG ( insn -> dst_reg , insn -> src_reg ) ;if ( issrc && isneg )  * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ;","if ( isimm ) {* patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ;* patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ;* patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ;* patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ;}* patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ;* patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ;* patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ;* patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ;if ( ! issrc ) * patch ++ = BPF_MOV64_REG ( insn -> dst_reg , insn -> src_reg ) ;if ( issrc && isneg && ! isimm ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ;",3175
1028,"err = 0 ;skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ;payload_len = dg -> payload_size ;if ( payload_len != skb -> len - sizeof ( * dg ) ) {err = - EINVAL ;goto out ;}if ( payload_len > len ) {payload_len = len ;msg -> msg_flags |= MSG_TRUNC ;}err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ;if ( err ) goto out ;msg -> msg_namelen = 0 ;if ( msg -> msg_name ) {","msg -> msg_namelen = 0 ;err = 0 ;skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ;if ( msg -> msg_name ) {",3176
1029,"size_t i , maxcount ;const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ;","size_t maxcount ;const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ;",3177
1030,"ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ;* count = 0 ;for ( i = 0 ;i < CDF_TOLE4 ( si -> si_count ) ;i ++ ) {if ( i >= CDF_LOOP_LIMIT ) {DPRINTF ( ( ""Unpack<S2SV_blank>summary<S2SV_blank>info<S2SV_blank>loop<S2SV_blank>limit"" ) ) ;errno = EFTYPE ;if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) ,  info , count , & maxcount ) == - 1 ) {return - 1 ;}}","ssi -> si_count = CDF_TOLE4 ( si -> si_count ) ;* count = 0 ;if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) , info , count , & maxcount ) == - 1 ) {}",3177
1031,j < size ;,j < minsz ;,3178
1032,"for ( j = 0 ;r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ;}if ( op . val != UT64_MAX )  printline ( ""val"" , ""0x%08"" PFMT64x ""\\\if ( op . ptr != UT64_MAX )   printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\\if ( op . refptr != - 1 )   printline ( ""refptr"" , ""%d\\\printline ( ""size"" , ""%d\\\","int minsz = R_MIN ( len , size ) ;minsz = R_MAX ( minsz , 0 ) ;for ( j = 0 ;ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : buf [ j + idx ] ;r_cons_printf ( ""%02x"" , ch ) ;}if ( op . val != UT64_MAX ) {printline ( ""val"" , ""0x%08"" PFMT64x ""\\\}if ( op . ptr != UT64_MAX ) {printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\\}if ( op . refptr != - 1 ) {printline ( ""refptr"" , ""%d\\\}printline ( ""size"" , ""%d\\\",3178
1033,"int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ;","int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ;",3179
1034,if ( ret < 0 ) {if ( ret != - EEXIST ) goto error ;,if ( ret < 0 ) {if ( ret != - EEXIST ) goto error ;,3180
1035,"REQ ( CHILD ( n , 0 ) , ASYNC ) ;REQ ( CHILD ( n , 1 ) , funcdef ) ;return ast_for_funcdef_impl ( c , CHILD ( n , 1 ) , decorator_seq ,   1 ) ;}","REQ ( CHILD ( n , 0 ) , NAME ) ;assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ;REQ ( CHILD ( n , 1 ) , funcdef ) ;return ast_for_funcdef_impl ( c , n , decorator_seq , 1 ) ;}",3181
1036,"sprintf ( buf , ""%s.conf"" , set ) ;if ( ( f = fopen ( buf , ""r"" ) ) == NULL ) {printf ( ""\\\\\","snprintf ( buf , sizeof ( buf ) , ""%s.conf"" , set ) ;if ( ( f = fopen ( buf , ""r"" ) ) == NULL ) {printf ( ""\\\\\",3182
1037,hdr = ( void * ) p - head -> iov_base ;dlen = head -> iov_len + rqstp -> rq_arg . page_len - hdr ;,hdr = ( void * ) p - head -> iov_base ;if ( hdr > head -> iov_len ) return 0 ;dlen = head -> iov_len + rqstp -> rq_arg . page_len - hdr ;,3183
1038,"char * p , * q , * r ;Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;","char * p , * q ;Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;",3184
1039,"printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;","printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;",3184
1040,"if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {for ( p = line + 18 ;isspace ( * p ) ;p ++ )  ;lenIV = atoi ( line + 6 ) ;}else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) )  && strstr ( line , ""readstring"" ) ) {* p = \'\\\\0\' ;q = strrchr ( line , \'/\' ) ;if ( q ) {r = cs_start ;++ q ;while ( ! isspace ( * q ) && * q != \'{\' ) * r ++ = * q ++ ;* r = \'\\\\0\' ;* p = \'s\' ;if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) )  ever_active = active = 1 ;else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) )  ever_active = active = 1 ;for ( q = p ;isspace ( * q ) && * q != \'\\\q ++ )  ;","if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( ( unsigned char ) line [ 17 ] ) ) {for ( p = line + 18 ;isspace ( ( unsigned char ) * p ) ;p ++ ) ;+ q ;set_lenIV ( line ) ;else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) ) ) {set_cs_start ( line ) ;if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( ( unsigned char ) p [ 7 ] ) ) ever_active = active = 1 ;else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( ( unsigned char ) p [ 13 ] ) ) ever_active = active = 1 ;for ( q = p ;isspace ( ( unsigned char ) * q ) && * q != \'\\\q ++ ) ;",3184
1041,if ( * p ) {if ( p [ 0 ] == \'@\' ) {,char op0 = 0 ;if ( * p ) {if ( p [ 0 ] == \'@\' ) {,3185
1042,* q = 0 ;},op0 = * q ;* q = 0 ;},3185
1043,"cmd = p + 1 ;cmd = p + 1 ;}* p = \\\'""\\\' ;cmd = p ;",cmd = p ;cmd = p + 1 ;}* p = op0 ;cmd = p ;,3185
1044,"# if defined ( HAVE_OPENSSL ) && ! defined ( EMBEDDED_LIBRARY ) if ( mysql -> options . ssl_key || mysql -> options . ssl_cert || mysql -> options . ssl_ca || mysql -> options . ssl_capath || mysql -> options . ssl_cipher || ( mysql -> options . extension && mysql -> options . extension -> ssl_crl ) ||  ( mysql -> options . extension && mysql -> options . extension -> ssl_crlpath ) )   mysql -> options . use_ssl = 1 ;if ( mysql -> options . use_ssl ) mysql -> client_flag |= CLIENT_SSL ;# endif if ( mysql -> client_flag & CLIENT_PROTOCOL_41 ) {int4store ( buff , mysql -> client_flag ) ;int4store ( buff + 4 , net -> max_packet_size ) ;buff [ 8 ] = ( char ) mysql -> charset -> number ;memset ( buff + 9 , 0 , 32 - 9 ) ;end = buff + 32 ;else {int2store ( buff , mysql -> client_flag ) ;int3store ( buff + 2 , net -> max_packet_size ) ;end = buff + 5 ;# ifdef HAVE_OPENSSL  if ( mysql -> client_flag & CLIENT_SSL )  {unsigned long ssl_error ;MYSQL_TRACE ( SEND_SSL_REQUEST , mysql , ( end - buff , ( const unsigned char * ) buff ) ) ;","# if defined ( HAVE_OPENSSL ) && ! defined ( EMBEDDED_LIBRARY ) if ( mysql -> options . ssl_key || mysql -> options . ssl_cert || mysql -> options . ssl_ca || mysql -> options . ssl_capath || mysql -> options . ssl_cipher || ( mysql -> options . extension && mysql -> options . extension -> ssl_crl ) || ( mysql -> options . extension && mysql -> options . extension -> ssl_crlpath ) || ( mysql -> options . extension && mysql -> options . extension -> ssl_enforce ) ) mysql -> options . use_ssl = TRUE ;if ( mysql -> options . use_ssl ) mysql -> client_flag |= CLIENT_SSL ;# endif if ( mysql -> options . extension && mysql -> options . extension -> ssl_enforce ) {DBUG_ASSERT ( mysql -> options . use_ssl ) ;if ( ! ( mysql -> server_capabilities & CLIENT_SSL ) ) {set_mysql_extended_error ( mysql , CR_SSL_CONNECTION_ERROR , unknown_sqlstate , ER ( CR_SSL_CONNECTION_ERROR ) , ""SSL<S2SV_blank>is<S2SV_blank>required<S2SV_blank>but<S2SV_blank>the<S2SV_blank>server<S2SV_blank>doesn\\\'t<S2SV_blank>"" ""support<S2SV_blank>it"" ) ;goto error ;if ( ( mysql -> server_capabilities & CLIENT_SSL ) && mysql -> options . use_ssl ) {unsigned long ssl_error ;if ( ! mysql -> options . ssl_cipher ) {SET_OPTION ( ssl_cipher , default_ssl_cipher ) ;}MYSQL_TRACE ( SEND_SSL_REQUEST , mysql , ( end - buff , ( const unsigned char * ) buff ) ) ;",3186
1045,switch ( header -> biSize ) {,"switch ( header -> biBitCount == 0 ) {fprintf ( stderr , ""Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\\return OPJ_FALSE ;}if ( header -> biSize ) {",3187
1046,if ( header -> biSize >= 40U ) {header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ;,if ( header -> biSize >= 40U ) {header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ;,3187
1047,"int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;","unlink ( path ) ;int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_EXCL , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;",3188
1048,return - ETIMEDOUT ;},kfree_skb ( skb ) ;return - ETIMEDOUT ;},3189
1049,"
",ctx -> si . w = 0 ;ctx -> si . h = 0 ;,3190
1050,vp8_clear_system_state ( ) ;return - 1 ;,vp8_clear_system_state ( ) ;return - 1 ;,3190
1051,"if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {ret = key -> type -> instantiate ( key , prep ) ;set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ;if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;","if ( key -> state == KEY_IS_UNINSTANTIATED ) {ret = key -> type -> instantiate ( key , prep ) ;mark_key_instantiated ( key , 0 ) ;if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;",3191
1052,"BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t )  ldblk , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;","BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;",3192
1053,"if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  if ( copy_from_user ( & ifr , argp , ifreq_len ) )  return - EFAULT ;if ( cmd == TUNGETFEATURES ) {","if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) {if ( copy_from_user ( & ifr , argp , ifreq_len ) ) return - EFAULT ;}else memset ( & ifr , 0 , sizeof ( ifr ) ) ;if ( cmd == TUNGETFEATURES ) {",3193
1054,"
",last_name = 0 ;,3194
1055,if ( gfs )  gfs -> errors = gfc . errors [ 1 ] ;,if ( gfs ) gfs -> errors = gfc . errors [ 1 ] ;,3194
1056,"void bpf_map_inc ( struct bpf_map * map , bool uref )  {atomic_inc ( & map -> refcnt ) ;if ( uref ) atomic_inc ( & map -> usercnt ) ;}","struct bpf_map * bpf_map_inc ( struct bpf_map * map , bool uref ) {if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) {atomic_dec ( & map -> refcnt ) ;return ERR_PTR ( - EBUSY ) ;}if ( uref ) atomic_inc ( & map -> usercnt ) ;return map ;}",3195
1057,usb_conv_info -> class_data = u3v_conv_info ;},usb_conv_info -> class_data = u3v_conv_info ;usb_conv_info -> class_data_type = USB_CONV_U3V ;}else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) {return 0 ;},3196
1058,if ( plen == 0 ) {break ;,if ( plen < sizeof ( struct sctp_paramhdr ) ) {break ;,3197
1059,"
",if ( plen < sizeof ( struct sctp_asconf_addrv4_param ) ) {return ( - 101 ) ;},3197
1060,"phdr = sctp_get_next_param ( m , offset ,  ( struct sctp_paramhdr * ) & lstore , plen ) ;","phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) & lstore , plen ) ;",3197
1061,"if ( error == NULL ) {issuer_known = TRUE ;if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) {if ( ret != GNUTLS_E_SUCCESS ) inf_gnutls_set_error ( & error , ret ) ;else if ( verify & GNUTLS_CERT_INVALID )  inf_gnutls_certificate_verification_set_error ( & error , verify ) ;}}",}if ( error == NULL ) if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) {},3198
1062,"str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ;if ( str == ( unsigned char * ) NULL ) {","str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count + 1 , sizeof ( * str ) ) ;if ( str == ( unsigned char * ) NULL ) {",3199
1063,"PyObject * logical = NULL ;FriBidiParType base = FRIBIDI_TYPE_RTL ;const char * encoding = ""utf-8"" ;static char * kwargs [ ] =  {""logical"" , ""base_direction"" , ""encoding"" , ""clean"" , ""reordernsm"" , NULL }if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""O|isii"" , kwargs ,   & logical , & base , & encoding , & clean , & reordernsm ) )   return NULL ;if ( ! ( base == FRIBIDI_TYPE_RTL ||  base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) )  return PyErr_Format ( PyExc_ValueError , ""invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON"" , base ) ;if ( PyUnicode_Check ( logical ) )  return log2vis_unicode ( logical , base , clean , reordernsm ) ;else if ( PyString_Check ( logical ) )  return log2vis_encoded_string ( logical , encoding , base , clean , reordernsm ) ;else return PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>unicode<S2SV_blank>or<S2SV_blank>str,<S2SV_blank>not<S2SV_blank>%s"" , logical -> ob_type -> tp_name ) ;","PyUnicodeObject * logical = NULL ;FriBidiParType base = FRIBIDI_TYPE_RTL ;static char * kwargs [ ] = {""logical"" , ""base_direction"" , ""clean"" , ""reordernsm"" , NULL }if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""U|iii"" , kwargs , & logical , & base , & clean , & reordernsm ) ) {return NULL ;}if ( ! ( base == FRIBIDI_TYPE_RTL || base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) {return PyErr_Format ( PyExc_ValueError , ""invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON"" , base ) ;}return unicode_log2vis ( logical , base , clean , reordernsm ) ;",3200
1064,"nfca_poll -> nfcid1_len = * data ++ ;pr_debug ( ""sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\\","nfca_poll -> nfcid1_len = min_t ( __u8 , * data ++ , NFC_NFCID1_MAXSIZE ) ;pr_debug ( ""sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\\",3201
1065,"int zero_bits = * in & 0x07 ;size_t octets_left = inlen - 1 ;int i , count = 0 ;memset ( outbuf , 0 , outlen ) ;","int i , count = 0 ;int zero_bits ;size_t octets_left ;if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ;if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ;zero_bits = * in & 0x07 ;octets_left = inlen - 1 ;int i , count = 0 ;memset ( outbuf , 0 , outlen ) ;",3202
1066,if ( uid >= AID_APP ) {return 0 ;,if ( multiuser_get_app_id ( uid ) >= AID_APP ) {return 0 ;,3203
1067,"ret = get_tag ( asn1 , len , & inner_tag , & asn1 , & len , & rem , & rlen ) ;if ( ret ) return ret ;","ret = get_tag ( asn1 , len , & inner_tag , & asn1 , & len , & rem , & rlen , 0 ) ;if ( ret ) return ret ;",3204
1068,"}return ( PTR_DIFF ( s , s0 ) + 1 ) ;","ND_TCHECK2 ( * s , 1 ) ;}return ( PTR_DIFF ( s , s0 ) + 1 ) ;",3205
1069,"if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) {s -> width = s -> height = 0 ;","if ( ( ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ) < 0 ) {s -> width = s -> height = 0 ;",3206
1070,"static ssize_t  pipe_write ( struct kiocb * iocb , const struct iovec * _iov ,  unsigned long nr_segs , loff_t ppos ) {ssize_t ret ;int do_wakeup ;struct iovec * iov = ( struct iovec * ) _iov ;size_t total_len ;ssize_t chars ;total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) )  return 0 ;do_wakeup = 0 ;ret = 0 ;","static ssize_t pipe_write ( struct kiocb * iocb , struct iov_iter * from ) {ssize_t ret = 0 ;int do_wakeup = 0 ;size_t total_len = iov_iter_count ( from ) ;ssize_t chars ;total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) ) return 0 ;",3207
1071,"int error , atomic = 1 ;void * addr ;error = ops -> confirm ( pipe , buf ) ;iov_fault_in_pages_read ( iov , chars ) ;redo1 : if ( atomic ) addr = kmap_atomic ( buf -> page ) ;else addr = kmap ( buf -> page ) ;error = pipe_iov_copy_from_user ( offset + addr , iov , chars , atomic ) ;if ( atomic ) kunmap_atomic ( addr ) ;else kunmap ( buf -> page ) ;ret = error ;do_wakeup = 1 ;if ( error ) {if ( atomic ) {atomic = 0 ;goto redo1 ;}}buf -> len += chars ;total_len -= chars ;ret = chars ;","int error = ops -> confirm ( pipe , buf ) ;ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ;if ( unlikely ( ret < chars ) ) {error = - EFAULT ;}do_wakeup = 1 ;buf -> len += chars ;total_len -= chars ;ret = chars ;",3207
1072,"char * src ;int error , atomic = 1 ;",int copied ;,3207
1073,"chars = PAGE_SIZE ;if ( chars > total_len ) chars = total_len ;iov_fault_in_pages_read ( iov , chars ) ;redo2 : if ( atomic ) src = kmap_atomic ( page ) ;else src = kmap ( page ) ;error = pipe_iov_copy_from_user ( src , iov , chars , atomic ) ;if ( unlikely ( error ) ) {if ( atomic ) {ret += chars ;buf -> page = page ;buf -> len = chars ;buf -> flags = 0 ;total_len -= chars ;if ( ! total_len ) break ;","copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from ) ;if ( unlikely ( error ) ) {if ( atomic ) {ret += copied ;buf -> page = page ;buf -> len = copied ;buf -> flags = 0 ;if ( ! iov_iter_count ( from ) ) break ;",3207
1074,u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;if ( insn_bitness == 32 ) {,u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;u32 dst = insn -> dst_reg ;int ret ;if ( insn_bitness == 32 ) {,3208
1075,"case BPF_ADD :  if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) ||  signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {","case BPF_ADD : ret = sanitize_val_alu ( env , insn ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\\return ret ;}if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {",3208
1076,"case BPF_SUB :  if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) ||  signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {","case BPF_SUB : ret = sanitize_val_alu ( env , insn ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\\return ret ;}if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {",3208
1077,tlv = cp + i ;type = ( uint8_t ) tlv [ 0 ] ;,if ( i + 2 > length ) return - 1 ;tlv = cp + i ;type = ( uint8_t ) tlv [ 0 ] ;,3209
1078,"ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ;switch ( type ) {","ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ;if ( i + 2 + optlen > length ) return - 1 ;switch ( type ) {",3209
1079,"error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp1 ) ;if ( error ) return error ;if ( args -> blkno2 != args -> blkno ) {error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno2 , - 1 , & bp2 ) ;if ( error ) return error ;}else {bp2 = bp1 ;}leaf1 = bp1 -> b_addr ;entry1 = & xfs_attr3_leaf_entryp ( leaf1 ) [ args -> index ] ;leaf2 = bp2 -> b_addr ;entry2 = & xfs_attr3_leaf_entryp ( leaf2 ) [ args -> index2 ] ;# ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr1 , leaf1 ) ;ASSERT ( args -> index < ichdr1 . count ) ;ASSERT ( args -> index >= 0 ) ;xfs_attr3_leaf_hdr_from_disk ( & ichdr2 , leaf2 ) ;ASSERT ( args -> index2 < ichdr2 . count ) ;ASSERT ( args -> index2 >= 0 ) ;if ( entry1 -> flags & XFS_ATTR_LOCAL ) {name_loc = xfs_attr3_leaf_name_local ( leaf1 , args -> index ) ;namelen1 = name_loc -> namelen ;name1 = ( char * ) name_loc -> nameval ;}else {name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ;namelen1 = name_rmt -> namelen ;name1 = ( char * ) name_rmt -> name ;}if ( entry2 -> flags & XFS_ATTR_LOCAL ) {name_loc = xfs_attr3_leaf_name_local ( leaf2 , args -> index2 ) ;namelen2 = name_loc -> namelen ;name2 = ( char * ) name_loc -> nameval ;}else {name_rmt = xfs_attr3_leaf_name_remote ( leaf2 , args -> index2 ) ;namelen2 = name_rmt -> namelen ;name2 = ( char * ) name_rmt -> name ;}ASSERT ( be32_to_cpu ( entry1 -> hashval ) == be32_to_cpu ( entry2 -> hashval ) ) ;ASSERT ( namelen1 == namelen2 ) ;ASSERT ( memcmp ( name1 , name2 , namelen1 ) == 0 ) ;# endif ASSERT ( entry1 -> flags & XFS_ATTR_INCOMPLETE ) ;ASSERT ( ( entry2 -> flags & XFS_ATTR_INCOMPLETE ) == 0 ) ;entry1 -> flags &= ~ XFS_ATTR_INCOMPLETE ;xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , entry1 , sizeof ( * entry1 ) ) ) ;if ( args -> rmtblkno ) {ASSERT ( ( entry1 -> flags & XFS_ATTR_LOCAL ) == 0 ) ;name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ;name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ;name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ;xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , name_rmt , sizeof ( * name_rmt ) ) ) ;","error = xfs_attr3_leaf_read ( args -> rmtvaluelen ) ;xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , name_rmt , sizeof ( * name_rmt ) ) ) ;",3210
1080,if ( shdr -> sh_size < 1 ) {return false ;,if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return false ;,3211
1081,"
","Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ;const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ;Jid * msg_jid = jid_create ( stanza_from ) ;if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) {log_warning ( ""Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s"" , stanza_from ) ;return TRUE ;}",3212
1082,const gchar * to = xmpp_stanza_get_to ( message ) ;const gchar * from = xmpp_stanza_get_from ( message ) ;Jid * jid_to = jid_create ( to ) ;Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ;,const gchar * to = xmpp_stanza_get_to ( message ) ;const gchar * from = xmpp_stanza_get_from ( message ) ;Jid * jid_to = jid_create ( to ) ;,3212
1083,"buff [ r ] = \'\\\\0\' ;set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ;","buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) ] = \'\\\\0\' ;set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ;",3213
1084,return error ;},return error < 0 ? error : 0 ;},3214
1085,if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,if ( num < 0 || num >= 256 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,3215
1086,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,3215
1087,"static int cfm_network_addr_print ( netdissect_options * ndo ,  register const u_char * tptr )  {u_int hexdump = FALSE ;network_addr_type = * tptr ;case AFNUM_INET :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;break ;case AFNUM_INET6 :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;break ;","static int cfm_network_addr_print ( netdissect_options * ndo , register const u_char * tptr , const u_int length ) {u_int hexdump = FALSE ;if ( length < 1 ) {ND_PRINT ( ( ndo , ""\\\return hexdump ;}network_addr_type = * tptr ;case AFNUM_INET : if ( length != 1 + 4 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;break ;case AFNUM_INET6 : if ( length != 1 + 16 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;break ;",3216
1088,"vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;","memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;",3217
1089,"decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ;decoder_info -> pb_split = get_flc ( 1 , stream ) ;","decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ;decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE ) ) ;decoder_info -> pb_split = get_flc ( 1 , stream ) ;",3218
1090,"vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;","memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;",3219
1091,"void vp9_write_nmv_probs ( VP9_COMMON * cm , int usehp , vp9_writer * w ) {int i , j ;nmv_context * const mvc = & cm -> fc . nmvc ;nmv_context_counts * const counts = & cm -> counts . mv ;","void vp9_write_nmv_probs ( VP9_COMMON * cm , int usehp , vpx_writer * w , nmv_context_counts * const counts ) {int i , j ;nmv_context * const mvc = & cm -> fc -> nmvc ;",3220
1092,"size_t columns ,  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads ,  sizeof ( * pixels ) ) ;( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;columns = images -> columns ;for ( i = 0 ;i ++ )  {","size_t columns , rows ;rows = MagickMax ( GetImageListLength ( images ) , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( rows , sizeof ( * pixels ) ) ;columns = MaxPixelChannels ;for ( i = 0 ;i ++ ) {",3221
1093,"static void temporal_filter_iterate_c ( VP9_COMP * cpi ,  int frame_count ,  int alt_ref_index , int strength , struct scale_factors * scale ) {int mb_cols = cpi -> common . mb_cols ;int mb_rows = cpi -> common . mb_rows ;int mb_y_offset = 0 ;int mb_uv_offset = 0 ;DECLARE_ALIGNED_ARRAY ( 16 , unsigned int , accumulator , 16 * 16 * 3 ) ;DECLARE_ALIGNED_ARRAY ( 16 , uint16_t , count , 16 * 16 * 3 ) ;MACROBLOCKD * mbd = & cpi -> mb . e_mbd ;YV12_BUFFER_CONFIG * f = cpi -> frames [ alt_ref_index ] ;uint8_t * dst1 , * dst2 ;DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , predictor , 16 * 16 * 3 ) ;const int mb_uv_height = 16 >> mbd -> plane [ 1 ] . subsampling_y ;uint8_t * input_buffer [ MAX_MB_PLANE ] ;int i ;assert ( mbd -> plane [ 1 ] . subsampling_x == mbd -> plane [ 1 ] . subsampling_y ) ;for ( i = 0 ;# if ALT_REF_MC_ENABLED  cpi -> mb . mv_row_min = - ( ( mb_row * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ;cpi -> mb . mv_row_max = ( ( cpi -> common . mb_rows - 1 - mb_row ) * 16 )  + ( 17 - 2 * VP9_INTERP_EXTEND ) ;# endif  for ( mb_col = 0 ;vpx_memset ( accumulator , 0 , 16 * 16 * 3 * sizeof ( accumulator [ 0 ] ) ) ;vpx_memset ( count , 0 , 16 * 16 * 3 * sizeof ( count [ 0 ] ) ) ;# if ALT_REF_MC_ENABLED  cpi -> mb . mv_col_min = - ( ( mb_col * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ;cpi -> mb . mv_col_max = ( ( cpi -> common . mb_cols - 1 - mb_col ) * 16 )  + ( 17 - 2 * VP9_INTERP_EXTEND ) ;# endif  for ( frame = 0 ;if ( cpi -> frames [ frame ] == NULL )  continue ;int err = 0 ;# if ALT_REF_MC_ENABLED # define THRESH_LOW 10000 # define THRESH_HIGH 20000 err = temporal_filter_find_matching_mb_c ( cpi ,  cpi -> frames [ alt_ref_index ] -> y_buffer + mb_y_offset ,   cpi -> frames [ frame ] -> y_buffer + mb_y_offset ,   cpi -> frames [ frame ] -> y_stride ) ;# endif   filter_weight = err < THRESH_LOW   ? 2 : err < THRESH_HIGH ? 1 : 0 ;}temporal_filter_predictors_mb_c ( mbd ,  cpi -> frames [ frame ] -> y_buffer + mb_y_offset ,  cpi -> frames [ frame ] -> u_buffer + mb_uv_offset , cpi -> frames [ frame ] -> v_buffer + mb_uv_offset , cpi -> frames [ frame ] -> y_stride , mb_uv_height , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col , predictor , scale , mb_col * 16 , mb_row * 16 ) ;","static void temporal_filter_iterate_c ( VP9_COMP * cpi , YV12_BUFFER_CONFIG * * frames , int frame_count , int alt_ref_index , int strength , struct scale_factors * scale ) {int mb_cols = ( frames [ alt_ref_index ] -> y_crop_width + 15 ) >> 4 ;int mb_rows = ( frames [ alt_ref_index ] -> y_crop_height + 15 ) >> 4 ;int mb_y_offset = 0 ;DECLARE_ALIGNED ( 16 , unsigned int , accumulator , 16 * 16 * 3 ] ) ;DECLARE_ALIGNED ( 16 , uint16_t , count [ 16 * 16 * 3 ] ) ;MACROBLOCKD * mbd = & cpi -> td . mb . e_mbd ;YV12_BUFFER_CONFIG * f = frames [ alt_ref_index ] ;uint8_t * dst1 , * dst2 ;# if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , predictor16 [ 16 * 16 * 3 ] ) ;DECLARE_ALIGNED ( 16 , uint8_t , predictor8 [ 16 * 16 * 3 ] ) ;uint8_t * predictor ;# else DECLARE_ALIGNED ( 16 , uint8_t , predictor [ 16 * 16 * 3 ] ) ;# endif const int mb_uv_height = 16 >> mbd -> plane [ 1 ] . subsampling_y ;const int mb_uv_width = 16 >> mbd -> plane [ 1 ] . subsampling_x ;uint8_t * input_buffer [ MAX_MB_PLANE ] ;int i ;# if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {predictor = CONVERT_TO_BYTEPTR ( predictor16 ) ;}else {predictor = predictor8 ;}# endif for ( i = 0 ;cpi -> td . mb . mv_row_min = - ( ( mb_row * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ;cpi -> td . mb . mv_row_max = ( ( mb_rows - 1 - mb_row ) * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ;for ( mb_col = 0 ;memset ( accumulator , 0 , 16 * 16 * 3 * sizeof ( accumulator [ 0 ] ) ) ;memset ( count , 0 , 16 * 16 * 3 * sizeof ( count [ 0 ] ) ) ;cpi -> td . mb . mv_col_min = - ( ( mb_col * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ;cpi -> td . mb . mv_col_max = ( ( mb_cols - 1 - mb_col ) * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ;for ( frame = 0 ;const int thresh_low = 10000 ;const int thresh_high = 20000 ;if ( frames [ frame ] == NULL ) continue ;int err = temporal_filter_find_matching_mb_c ( cpi , cpi -> frames [ alt_ref_index ] -> y_buffer + mb_y_offset , cpi -> frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> y_stride ) ;# endif filter_weight = err < THRESH_LOW ? 2 : err < THRESH_HIGH ? 1 : 0 ;}temporal_filter_predictors_mb_c ( mbd , cpi -> frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> u_buffer + mb_uv_offset , cpi -> frames [ frame ] -> v_buffer + mb_uv_offset , cpi -> frames [ frame ] -> y_stride , mb_uv_height , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col , predictor , scale , mb_col * 16 , mb_row * 16 ) ;",3222
1094,pval *= cpi -> fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;byte ++ ;stride = cpi -> alt_ref_buffer . uv_stride ;byte = mb_uv_offset ;for ( j = 0 ;j < mb_uv_height ;int m = k + 256 ;pval *= cpi -> fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;pval = accumulator [ m ] + ( count [ m ] >> 1 ) ;pval *= cpi -> fixed_divide [ count [ m ] ] ;pval >>= 19 ;dst2 [ byte ] = ( uint8_t ) pval ;byte ++ ;}byte += stride - mb_uv_height ;}mb_y_offset += 16 ;mb_uv_offset += mb_uv_height ;}mb_uv_offset += mb_uv_height * ( f -> uv_stride - mb_cols ) ;},"pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1_16 [ byte ] = ( uint16_t ) pval ;byte ++ ;dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) ;dst2_16 = CONVERT_TO_SHORTPTR ( dst2 ) ;stride = cpi -> alt_ref_buffer . uv_stride ;byte = mb_uv_offset ;for ( j = 0 ;j < mb_uv_width ;int m = k + 256 ;pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1_16 [ byte ] = ( uint16_t ) pval ;pval = accumulator [ m ] + ( count [ m ] >> 1 ) ;pval *= fixed_divide [ count [ m ] ] ;pval >>= 19 ;dst2_16 [ byte ] = ( uint16_t ) pval ;byte ++ ;}byte += stride - mb_uv_width ;}}else {dst1 = cpi -> alt_ref_buffer . y_buffer ;stride = cpi -> alt_ref_buffer . y_stride ;byte = mb_y_offset ;for ( i = 0 , k = 0 ;i < 16 ;i ++ ) {for ( j = 0 ;j < 16 ;j ++ , k ++ ) {unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ;pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;byte ++ ;}byte += stride - 16 ;}dst1 = cpi -> alt_ref_buffer . u_buffer ;dst2 = cpi -> alt_ref_buffer . v_buffer ;stride = cpi -> alt_ref_buffer . uv_stride ;byte = mb_uv_offset ;for ( i = 0 , k = 256 ;i < mb_uv_height ;i ++ ) {for ( j = 0 ;j < mb_uv_width ;j ++ , k ++ ) {int m = k + 256 ;unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ;pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;pval = accumulator [ m ] + ( count [ m ] >> 1 ) ;pval *= fixed_divide [ count [ m ] ] ;pval >>= 19 ;dst2 [ byte ] = ( uint8_t ) pval ;byte ++ ;}byte += stride - mb_uv_width ;}}# else dst1 = cpi -> alt_ref_buffer . y_buffer ;stride = cpi -> alt_ref_buffer . y_stride ;byte = mb_y_offset ;for ( i = 0 , k = 0 ;i < 16 ;i ++ ) {for ( j = 0 ;j < 16 ;j ++ , k ++ ) {unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ;pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;byte ++ ;}byte += stride - 16 ;}dst1 = cpi -> alt_ref_buffer . u_buffer ;dst2 = cpi -> alt_ref_buffer . v_buffer ;stride = cpi -> alt_ref_buffer . uv_stride ;byte = mb_uv_offset ;for ( i = 0 , k = 256 ;i < mb_uv_height ;i ++ ) {for ( j = 0 ;j < mb_uv_width ;j ++ , k ++ ) {int m = k + 256 ;unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ;pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;pval = accumulator [ m ] + ( count [ m ] >> 1 ) ;pval *= fixed_divide [ count [ m ] ] ;pval >>= 19 ;dst2 [ byte ] = ( uint8_t ) pval ;byte ++ ;}byte += stride - mb_uv_width ;}# endif mb_y_offset += 16 ;mb_uv_offset += mb_uv_width ;}mb_uv_offset += mb_uv_height * f -> uv_stride - mb_cols ) ;}",3222
1095,if ( l >= ( len - o ) ) {iter -> err_off = o ;,if ( l >= ( len - o - 4 ) ) {iter -> err_off = o ;,3223
1096,"if ( ! rtlpriv -> usb_data )  return - ENOMEM ;spin_lock_init ( & rtlpriv -> locks . usb_lock ) ;INIT_WORK ( & rtlpriv -> works . fill_h2c_cmd , rtl_fill_h2c_cmd_work_callback ) ;","if ( ! rtlpriv -> usb_data ) {ieee80211_free_hw ( hw ) ;return - ENOMEM ;}spin_lock_init ( & rtlpriv -> locks . usb_lock ) ;INIT_WORK ( & rtlpriv -> works . fill_h2c_cmd , rtl_fill_h2c_cmd_work_callback ) ;kfree ( rtlpriv -> usb_data ) ;",3224
1097,complete ( & rtlpriv -> firmware_loading_complete ) ;return - ENODEV ;,complete ( & rtlpriv -> firmware_loading_complete ) ;return - ENODEV ;,3224
1098,ps_codec -> i4_slice_error = 0 ;,ret = ps_codec -> i4_slice_error = 0 ;,3225
1099,"
",if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) {return ret ;},3225
1100,"ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ;}","ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ;}",3225
1101,while ( collen > 0 )  {while ( replen > 0 )  {,while ( indexw < width && collen > 0 ) {while ( indexw < width && replen > 0 ) {,3226
1102,while ( collen > 0 )  {,while ( indexw < width && collen > 0 ) {,3226
1103,while ( replen > 0 )  {,while ( indexw < width && replen > 0 ) {,3226
1104,if ( g -> sect <= 0 ||   g -> head <= 0 ||  ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,if ( ( int ) g -> sect <= 0 || ( int ) g -> head <= 0 || ( int ) ( g -> sect * g -> head ) <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,3227
1105,"int retval = 0 ;int bytes_read = 0 ;retval = - ENODEV ;goto exit ;bytes_read = snprintf ( in_buffer , 20 , ""%lld\\\spin_unlock_irqrestore ( & dev -> lock , flags ) ;if ( * ppos < bytes_read ) {if ( copy_to_user ( buffer , in_buffer + * ppos , bytes_read - * ppos ) ) retval = - EFAULT ;else {retval = bytes_read - * ppos ;* ppos += bytes_read ;}exit : mutex_unlock ( & dev -> io_mutex ) ;return retval ;}","int len = 0 ;int bytes_read = 0 ;mutex_unlock ( & dev -> io_mutex ) ;return - ENODEV ;len = snprintf ( in_buffer , 20 , ""%lld\\\spin_unlock_irqrestore ( & dev -> lock , flags ) ;mutex_unlock ( & dev -> io_mutex ) ;return simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) ;",3228
1106,"draw_info -> geometry = AcquireString ( geometry ) ;status = AnnotateImage ( image , draw_info ) ;","( void ) CloneString ( & draw_info -> geometry = AcquireString ( geometry ) ;status = AnnotateImage ( image , draw_info ) ;",3229
1107,"isoclns_print ( ndo , p , length , caplen ) ;return ( hdrlen ) ;","isoclns_print ( ndo , p , length , caplen ) ;return ( hdrlen ) ;",3230
1108,const VP9_CONFIG * const oxcf = & cpi -> oxcf ;int layer ;int layer_end ;if ( svc -> number_temporal_layers > 1 ) {layer_end = svc -> number_temporal_layers ;else {layer_end = svc -> number_spatial_layers ;}for ( layer = 0 ;layer < layer_end ;++ layer ) {LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ;RATE_CONTROL * const lrc = & lc -> rc ;lrc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ;,"const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;int sl , tl ;int alt_ref_idx = svc -> number_spatial_layers ;if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . pass == 2 ) {if ( vpx_realloc_frame_buffer ( & cpi -> svc . empty_frame . img , SMALL_FRAME_WIDTH , SMALL_FRAME_HEIGHT , cpi -> common . subsampling_x , cpi -> common . subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cpi -> common . use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , cpi -> common . byte_alignment , NULL , NULL , NULL ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>empty<S2SV_blank>frame<S2SV_blank>for<S2SV_blank>multiple<S2SV_blank>frame<S2SV_blank>"" ""contexts"" ) ;memset ( cpi -> svc . empty_frame . img . buffer_alloc , 0x80 , cpi -> svc . empty_frame . img . buffer_alloc_sz ) ;+ layer ) {for ( sl = 0 ;sl < oxcf -> ss_number_layers ;++ sl ) {for ( tl = 0 ;tl < oxcf -> ts_number_layers ;++ tl ) {int layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ;LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ;RATE_CONTROL * const lrc = & lc -> rc ;int i ;lc -> layer_size = 0 ;lc -> frames_from_key_frame = 0 ;lc -> last_frame_type = FRAME_TYPES ;",3231
1109,"lrc -> rate_correction_factor = 1.0 ;lrc -> key_frame_rate_correction_factor = 1.0 ;if ( svc -> number_temporal_layers > 1 ) {lc -> target_bandwidth = oxcf -> ts_target_bitrate [ layer ] * 1000 ;lc -> target_bandwidth = oxcf -> ss_target_bitrate [ layer ] * 1000 ;lrc -> last_q [ 0 ] = oxcf -> best_allowed_q ;lrc -> last_q [ 1 ] = oxcf -> best_allowed_q ;lrc -> last_q [ 2 ] = oxcf -> best_allowed_q ;lrc -> buffer_level = vp9_rescale ( ( int ) ( oxcf -> starting_buffer_level ) , lc -> target_bandwidth , 1000 ) ;",for ( i = 0 ;i < RATE_FACTOR_LEVELS ;++ i ) {lrc -> rate_correction_factors [ i ] = 1.0 ;}if ( cpi -> oxcf . rc_mode == VPX_CBR ) {lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ;lrc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ;lrc -> avg_frame_qindex [ KEY_FRAME ] = oxcf -> worst_allowed_q ;lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ;lrc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ;lrc -> last_q [ INTER_FRAME ] = oxcf -> best_allowed_q ;lrc -> avg_frame_qindex [ KEY_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ;lrc -> avg_frame_qindex [ INTER_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ;if ( oxcf -> ss_enable_auto_arf [ sl ] ) lc -> alt_ref_idx = alt_ref_idx ++ ;else lc -> alt_ref_idx = INVALID_IDX ;lc -> gold_ref_idx = INVALID_IDX ;lrc -> buffer_level = oxcf -> starting_buffer_level_ms * lc -> target_bandwidth / 1000 ;if ( ! ( svc -> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) && alt_ref_idx < REF_FRAMES ) svc -> layer_context [ 0 ] . gold_ref_idx = alt_ref_idx ;},3231
1110,"struct inode * inode = page -> mapping -> host ;int ret = - EAGAIN ;if ( ret == - EAGAIN )  ret = f2fs_mpage_readpages ( page -> mapping , NULL , page , 1 , false ) ;return ret ;","struct inode * inode = page_file_mapping ( page ) -> host ;int ret = - EAGAIN ;if ( ret == - EAGAIN ) ret = f2fs_mpage_readpages ( page_file_mapping ( page ) , NULL , page , 1 , false ) ;return ret ;",3232
1111,},"hook_del_nick_can_register ( check_registration_keywords ) ;hook_del_user_can_register ( check_registration_keywords ) ;del_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table ) ;}",3233
1112,"ddi . dinfo_nboards = dgnc_NumBoards ;sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ;","memset ( & ddi , 0 , sizeof ( ddi ) ) ;ddi . dinfo_nboards = dgnc_NumBoards ;sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ;",3234
1113,if ( po -> fanout )   return - EINVAL ;lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;,lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;rcu_read_lock ( ) ;if ( po -> fanout ) {ret = - EINVAL ;lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;,3235
1114,ps_dec -> u2_total_mbs_coded ++ ;u1_num_mbsNby2 ++ ;,u1_num_mbsNby2 ++ ;,3236
1115,if ( u1_tfr_n_mb )  u1_num_mbs = 0 ;,ps_dec -> u2_total_mbs_coded += u1_num_mbs ;if ( u1_tfr_n_mb ) u1_num_mbs = 0 ;,3236
1116,"if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) {ext4_debug ( ""inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>is<S2SV_blank>empty\\\ext4_debug ( ""Dump<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>\\\list_for_each_entry ( io , & EXT4_I ( inode ) -> i_completed_io_list , list ) {","unsigned long flags ;if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) {ext4_debug ( ""inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>is<S2SV_blank>empty\\\spin_lock_irqsave ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ;ext4_debug ( ""Dump<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>\\\list_for_each_entry ( io , & EXT4_I ( inode ) -> i_completed_io_list , list ) {",3237
1117,# endif  },"spin_unlock_irqrestore ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ;# endif }",3237
1118,"static int __perf_event_overflow ( struct perf_event * event , int nmi ,  int throttle , struct perf_sample_data * data , struct pt_regs * regs ) {","static int __perf_event_overflow ( struct perf_event * event , int throttle , struct perf_sample_data * data , struct pt_regs * regs ) {",3238
1119,"if ( nmi ) {event -> pending_disable = 1 ;}else  perf_event_disable ( event ) ;if ( event -> overflow_handler ) event -> overflow_handler ( event , nmi , data , regs ) ;else  perf_event_output ( event , nmi , data , regs ) ;if ( event -> fasync && event -> pending_kill ) {if ( nmi ) {event -> pending_wakeup = 1 ;irq_work_queue ( & event -> pending ) ;}","event -> pending_disable = 1 ;irq_work_queue ( & event -> pending ) ;}if ( event -> overflow_handler ) event -> overflow_handler ( event , data , regs ) ;else perf_event_output ( event , nmi , data , regs ) ;if ( event -> fasync && event -> pending_kill ) {event -> pending_wakeup = 1 ;",3238
1120,"<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a.{1,2}b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>6<S2SV_blank>}"" , ""a\\\\0x\\\\0b\\\\0"" ) ;assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a.{1,2}b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>8<S2SV_blank>}"" , ""a\\\\0x\\\\0x\\\\0b\\\\0"" ) ;assert_regexp_syntax_error ( "")"" ) ;assert_true_regexp ( ""abc"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""abc"" , ""xbc"" ) ;assert_false_regexp ( ""abc"" , ""axc"" ) ;assert_false_regexp ( ""abc"" , ""abx"" ) ;assert_true_regexp ( ""abc"" , ""xabcx"" , ""abc"" ) ;assert_true_regexp ( ""abc"" , ""ababc"" , ""abc"" ) ;assert_true_regexp ( ""a.c"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""a.b"" , ""a\\\assert_false_regexp ( ""a.*b"" , ""acc\\\assert_false_regexp ( ""a.{4,5}b"" , ""acc\\\assert_true_regexp ( ""a.b"" , ""a\\\\rb"" , ""a\\\\rb"" ) ;assert_true_regexp ( ""ab*c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab*c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""ab*bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab*bc"" , ""abbc"" , ""abbc"" ) ;assert_true_regexp ( ""a.*bb"" , ""abbbb"" , ""abbbb"" ) ;assert_true_regexp ( ""a.*?bbb"" , ""abbbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""a.*c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""a.*c"" , ""axyzc"" , ""axyzc"" ) ;assert_true_regexp ( ""ab+c"" , ""abbc"" , ""abbc"" ) ;assert_false_regexp ( ""ab+c"" , ""ac"" ) ;assert_true_regexp ( ""ab+"" , ""abbbb"" , ""abbbb"" ) ;assert_true_regexp ( ""ab+?"" , ""abbbb"" , ""ab"" ) ;assert_false_regexp ( ""ab+bc"" , ""abc"" ) ;assert_false_regexp ( ""ab+bc"" , ""abq"" ) ;assert_true_regexp ( ""a+b+c"" , ""aabbabc"" , ""abc"" ) ;assert_false_regexp ( ""ab?bc"" , ""abbbbc"" ) ;assert_true_regexp ( ""ab?c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab*?"" , ""abbb"" , ""a"" ) ;assert_true_regexp ( ""ab?c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""ab??"" , ""ab"" , ""a"" ) ;assert_true_regexp ( ""a(b|x)c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a(b|x)c"" , ""axc"" , ""axc"" ) ;assert_true_regexp ( ""a(b|.)c"" , ""axc"" , ""axc"" ) ;assert_true_regexp ( ""a(b|x|y)c"" , ""ayc"" , ""ayc"" ) ;assert_true_regexp ( ""(a+|b)*"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a|b|c|d|e"" , ""e"" , ""e"" ) ;assert_true_regexp ( ""(a|b|c|d|e)f"" , ""ef"" , ""ef"" ) ;assert_true_regexp ( "".b{2}"" , ""abb"" , ""abb"" ) ;assert_true_regexp ( "".b{2,3}"" , ""abbb"" , ""abbb"" ) ;assert_true_regexp ( "".b{2,3}?"" , ""abbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{2,3}c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{2,3}?c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( "".b{2,3}cccc"" , ""abbbcccc"" , ""abbbcccc"" ) ;assert_true_regexp ( "".b{2,3}?cccc"" , ""abbbcccc"" , ""bbbcccc"" ) ;assert_true_regexp ( ""a.b{2,3}cccc"" , ""aabbbcccc"" , ""aabbbcccc"" ) ;assert_true_regexp ( ""ab{2,3}c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{2,3}?c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{0,1}?c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a{0,1}?bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a{0,1}bc"" , ""bbc"" , ""bc"" ) ;assert_true_regexp ( ""a{0,1}?bc"" , ""abc"" , ""bc"" ) ;assert_true_regexp ( ""aa{0,1}?bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""aa{0,1}?bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""aa{0,1}bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab{1}c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab{1,2}c"" , ""abbc"" , ""abbc"" ) ;assert_true_regexp ( ""ab{1,}c"" , ""abbbc"" , ""abbbc"" ) ;assert_false_regexp ( ""ab{1,}b"" , ""ab"" ) ;assert_false_regexp ( ""ab{1}c"" , ""abbc"" ) ;assert_true_regexp ( ""ab{0,}c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""ab{1,1}c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab{0,}c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{,3}c"" , ""abbbc"" , ""abbbc"" ) ;assert_false_regexp ( ""ab{,2}c"" , ""abbbc"" ) ;assert_false_regexp ( ""ab{4,5}bc"" , ""abbbbc"" ) ;assert_true_regexp ( ""ab{0,1}"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{0,2}"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{0,3}"" , ""abbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""ab{0,4}"" , ""abbbbb"" , ""abbbb"" ) ;assert_true_regexp ( ""ab{1,1}"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{1,2}"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{1,3}"" , ""abbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""ab{2,2}"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{2,3}"" , ""abbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""ab{1,3}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{0,1}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{0,2}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{0,3}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{0,4}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{1,1}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{1,2}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{1,3}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{2,2}?"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{2,3}?"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( "".(abc){0,1}"" , ""xabcabcabcabc"" , ""xabc"" ) ;assert_true_regexp ( "".(abc){0,2}"" , ""xabcabcabcabc"" , ""xabcabc"" ) ;assert_true_regexp ( ""x{1,2}abcd"" , ""xxxxabcd"" , ""xxabcd"" ) ;assert_true_regexp ( ""x{1,2}abcd"" , ""xxxxabcd"" , ""xxabcd"" ) ;assert_true_regexp ( ""ab{.*}"" , ""ab{c}"" , ""ab{c}"" ) ;assert_true_regexp ( "".(aa){1,2}"" , ""aaaaaaaaaa"" , ""aaaaa"" ) ;assert_true_regexp ( ""a.(bc.){2}"" , ""aabcabca"" , ""aabcabca"" ) ;assert_true_regexp ( ""(ab{1,2}c){1,3}"" , ""abbcabc"" , ""abbcabc"" ) ;assert_true_regexp ( ""ab(c|cc){1,3}d"" , ""abccccccd"" , ""abccccccd"" ) ;assert_true_regexp ( ""a[bx]c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a[bx]c"" , ""axc"" , ""axc"" ) ;assert_true_regexp ( ""a[0-9]*b"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a[0-9]*b"" , ""a0123456789b"" , ""a0123456789b"" ) ;assert_true_regexp ( ""[0-9a-f]+"" , ""0123456789abcdef"" , ""0123456789abcdef"" ) ;assert_true_regexp ( ""[0-9a-f]+"" , ""xyz0123456789xyz"" , ""0123456789"" ) ;assert_true_regexp ( ""a[\\\\\\\\s\\\\\\\\S]b"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ;assert_true_regexp ( ""a[\\\\\\\\d\\\\\\\\D]b"" , ""a1b"" , ""a1b"" ) ;assert_false_regexp ( ""[x-z]+"" , ""abc"" ) ;assert_true_regexp ( ""a[-]?c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""a[-b]"" , ""a-"" , ""a-"" ) ;assert_true_regexp ( ""a[-b]"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a[b-]"" , ""a-"" , ""a-"" ) ;assert_true_regexp ( ""a[b-]"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""[a-c-e]"" , ""b"" , ""b"" ) ;assert_true_regexp ( ""[a-c-e]"" , ""-"" , ""-"" ) ;assert_false_regexp ( ""[a-c-e]"" , ""d"" ) ;assert_regexp_syntax_error ( ""[b-a]"" ) ;assert_regexp_syntax_error ( ""(abc"" ) ;assert_regexp_syntax_error ( ""abc)"" ) ;assert_regexp_syntax_error ( ""a[]b"" ) ;assert_true_regexp ( ""a[\\\\\\\\-b]"" , ""a-"" , ""a-"" ) ;assert_true_regexp ( ""a[\\\\\\\\-b]"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a]"" , ""a]"" , ""a]"" ) ;assert_true_regexp ( ""a[]]b"" , ""a]b"" , ""a]b"" ) ;assert_true_regexp ( ""a[\\\\\\\\]]b"" , ""a]b"" , ""a]b"" ) ;assert_true_regexp ( ""a[^bc]d"" , ""aed"" , ""aed"" ) ;assert_false_regexp ( ""a[^bc]d"" , ""abd"" ) ;assert_true_regexp ( ""a[^-b]c"" , ""adc"" , ""adc"" ) ;assert_false_regexp ( ""a[^-b]c"" , ""a-c"" ) ;assert_false_regexp ( ""a[^]b]c"" , ""a]c"" ) ;assert_true_regexp ( ""a[^]b]c"" , ""adc"" , ""adc"" ) ;assert_true_regexp ( ""[^ab]*"" , ""cde"" , ""cde"" ) ;assert_regexp_syntax_error ( "")("" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\tb"" , ""a\\\\tb"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\rb"" , ""a\\\\rb"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\vb"" , ""a\\\\vb"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\fb"" , ""a\\\\fb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a<S2SV_blank>b"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\tb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\rb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\vb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\fb"" ) ;assert_true_regexp ( ""\\\\\\\assert_true_regexp ( ""[\\\\\\\assert_true_regexp ( ""\\\\\\\\x01\\\\\\\\x02\\\\\\\\x03"" , ""\\\\x01\\\\x02\\\\x03"" , ""\\\\x01\\\\x02\\\\x03"" ) ;assert_true_regexp ( ""[\\\\\\\\x01-\\\\\\\\x03]+"" , ""\\\\x01\\\\x02\\\\x03"" , ""\\\\x01\\\\x02\\\\x03"" ) ;assert_false_regexp ( ""[\\\\\\\\x00-\\\\\\\\x02]+"" , ""\\\\x03\\\\x04\\\\x05"" ) ;assert_true_regexp ( ""[\\\\\\\\x5D]"" , ""]"" , ""]"" ) ;assert_true_regexp ( ""[\\\\\\\\0x5A-\\\\\\\\x5D]"" , ""\\\\x5B"" , ""\\\\x5B"" ) ;assert_true_regexp ( ""[\\\\\\\\x5D-\\\\\\\\x5F]"" , ""\\\\x5E"" , ""\\\\x5E"" ) ;assert_true_regexp ( ""[\\\\\\\\x5C-\\\\\\\\x5F]"" , ""\\\\x5E"" , ""\\\\x5E"" ) ;assert_true_regexp ( ""[\\\\\\\\x5D-\\\\\\\\x5F]"" , ""\\\\x5E"" , ""\\\\x5E"" ) ;assert_true_regexp ( ""a\\\\\\\\wc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a\\\\\\\\wc"" , ""a_c"" , ""a_c"" ) ;assert_true_regexp ( ""a\\\\\\\\wc"" , ""a0c"" , ""a0c"" ) ;assert_false_regexp ( ""a\\\\\\\\wc"" , ""a*c"" ) ;assert_true_regexp ( ""\\\\\\\\w+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ;assert_true_regexp ( ""[\\\\\\\\w]+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ;assert_true_regexp ( ""\\\\\\\\D+"" , ""1234abc5678"" , ""abc"" ) ;assert_true_regexp ( ""[\\\\\\\\d]+"" , ""0123456789"" , ""0123456789"" ) ;assert_true_regexp ( ""[\\\\\\\\D]+"" , ""1234abc5678"" , ""abc"" ) ;assert_true_regexp ( ""[\\\\\\\\da-fA-F]+"" , ""123abc"" , ""123abc"" ) ;assert_false_regexp ( ""^(ab|cd)e"" , ""abcde"" ) ;assert_true_regexp ( ""(abc|)ef"" , ""abcdef"" , ""ef"" ) ;assert_true_regexp ( ""(abc|)ef"" , ""abcef"" , ""abcef"" ) ;assert_true_regexp ( ""\\\\\\\\babc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""abc\\\\\\\\b"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""\\\\\\\\babc"" , ""1abc"" ) ;assert_false_regexp ( ""abc\\\\\\\\b"" , ""abc1"" ) ;assert_true_regexp ( ""abc\\\\\\\\s\\\\\\\\b"" , ""abc<S2SV_blank>x"" , ""abc<S2SV_blank>"" ) ;assert_false_regexp ( ""abc\\\\\\\\s\\\\\\\\b"" , ""abc<S2SV_blank><S2SV_blank>"" ) ;assert_true_regexp ( ""\\\\\\\\babc\\\\\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\b\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\b"" , ""abcd"" , ""bcd"" ) ;assert_true_regexp ( ""\\\\\\\\b\\\\\\\\w\\\\\\\\w\\\\\\\\w"" , ""abcd"" , ""abc"" ) ;assert_false_regexp ( ""\\\\\\\\b\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\b"" , ""abcd"" ) ;assert_false_regexp ( ""\\\\\\\\Babc"" , ""abc"" ) ;assert_false_regexp ( ""abc\\\\\\\\B"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\Babc"" , ""1abc"" , ""abc"" ) ;assert_true_regexp ( ""abc\\\\\\\\B"" , ""abc1"" , ""abc"" ) ;assert_false_regexp ( ""abc\\\\\\\\s\\\\\\\\B"" , ""abc<S2SV_blank>x"" ) ;assert_true_regexp ( ""abc\\\\\\\\s\\\\\\\\B"" , ""abc<S2SV_blank><S2SV_blank>"" , ""abc<S2SV_blank>"" ) ;assert_true_regexp ( ""\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\B"" , ""abcd"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\B\\\\\\\\w\\\\\\\\w\\\\\\\\w"" , ""abcd"" , ""bcd"" ) ;assert_false_regexp ( ""\\\\\\\\B\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\B"" , ""abcd"" ) ;assert_regexp_syntax_error ( ""(|abc)ef"" ) ;assert_true_regexp ( ""((a)(b)c)(d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""(a|b)c*d"" , ""abcd"" , ""bcd"" ) ;assert_true_regexp ( ""(ab|ab*)bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a([bc]*)c*"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a([bc]*)c*"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""a([bc]*)c*"" , ""a"" , ""a"" ) ;assert_true_regexp ( ""a([bc]*)(c*d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""a([bc]+)(c*d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""a([bc]*)(c+d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""a[bcd]*dcdcde"" , ""adcdcde"" , ""adcdcde"" ) ;assert_false_regexp ( ""a[bcd]+dcdcde"" , ""adcdcde"" ) ;assert_true_regexp ( ""\\\\\\\\((.*),<S2SV_blank>(.*)\\\\\\\\)"" , ""(a,<S2SV_blank>b)"" , ""(a,<S2SV_blank>b)"" ) ;assert_true_regexp ( ""abc|123$"" , ""abcx"" , ""abc"" ) ;assert_false_regexp ( ""abc|123$"" , ""123x"" ) ;assert_true_regexp ( ""abc|^123"" , ""123"" , ""123"" ) ;assert_false_regexp ( ""abc|^123"" , ""x123"" ) ;assert_true_regexp ( ""^abc$"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""^abc$"" , ""abcc"" ) ;assert_true_regexp ( ""^abc"" , ""abcc"" , ""abc"" ) ;assert_false_regexp ( ""^abc$"" , ""aabc"" ) ;assert_false_regexp ( ""abc^"" , ""abc"" ) ;assert_false_regexp ( ""ab^c"" , ""abc"" ) ;assert_false_regexp ( ""a^bcdef"" , ""abcdef"" ) assert_true_regexp ( ""abc$"" , ""aabc"" , ""abc"" ) ;assert_false_regexp ( ""$abc"" , ""abc"" ) ;assert_true_regexp ( ""(a|a$)bcd"" , ""abcd"" , ""abcd"" ) ;assert_false_regexp ( ""(a$|a$)bcd"" , ""abcd"" ) ;assert_false_regexp ( ""(abc$|ab$)"" , ""abcd"" ) ;assert_true_regexp ( ""^a(bc+|b[eh])g|.h$"" , ""abhg"" , ""abhg"" ) ;assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effgz"" , ""effgz"" ) ;assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""ij"" , ""ij"" ) ;assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effg"" ) ;assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""bcdd"" ) ;assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""reffgz"" , ""effgz"" ) ;assert_true_regexp ( ""whatever|<S2SV_blank><S2SV_blank><S2SV_blank>x.<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x0"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x"" ) ;assert_regexp_syntax_error ( ""x{0,0}"" ) ;assert_regexp_syntax_error ( ""x{0}"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\xxy"" ) ;assert_error ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a\\\\\\\\/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ERROR_SYNTAX_ERROR ) ;assert_error ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/[a\\\\\\\\/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ERROR_SYNTAX_ERROR ) ;assert_true_rule_blob (  ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\\\t/<S2SV_blank>\\\\\"" ,  PE32_FILE ) ;assert_true_rule_blob (  ""rule<S2SV_blank>test<S2SV_blank>{"" ,  PE32_FILE ) ;","<S2SV_blank>\\\\\t/<S2SV_blank>\\\\\"" , PE32_FILE ) ;assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{"" , PE32_FILE ) ;",3239
1121,"static int jas_iccputsint ( jas_stream_t * out , int n , longlong val )  {ulonglong tmp ;tmp = ( val < 0 ) ? ( abort ( ) , 0 ) : val ;","static int jas_iccputsint ( jas_stream_t * out , int n , jas_longlong val ) {ulonglong tmp ;tmp = ( val < 0 ) ? ( abort ( ) , 0 ) : val ;",3240
1122,"rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( rc < 0 )  return rc ;inode -> i_ctime = CURRENT_TIME ;if ( rc == 0 ) acl = NULL ;","rc = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ;if ( rc ) return rc ;inode -> i_ctime = CURRENT_TIME ;",3241
1123,"pirlvl = pi -> picomp -> pirlvls ;pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;","pirlvl = pi -> picomp -> pirlvls ;if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;",3242
1124,if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {",3242
1125,"static int changedline ( const Proto * p , int oldpc , int newpc ) {while ( oldpc ++ < newpc ) {","static int changedline ( const Proto * p , int oldpc , int newpc ) {if ( p -> lineinfo == NULL ) return 0 ;while ( oldpc ++ < newpc ) {",3243
1126,"
",bool disconnect ;,3244
1127,"p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;list_del_init ( & p -> mnt_expire ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ;if ( mnt_has_parent ( p ) ) {umount_mnt ( p ) ;}change_mnt_propagation ( p , MS_PRIVATE ) ;}","p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;list_del_init ( & p -> mnt_expire ) ;disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ;if ( mnt_has_parent ( p ) ) {if ( ! disconnect ) {list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ;}}else {umount_mnt ( p ) ;}change_mnt_propagation ( p , MS_PRIVATE ) ;}",3244
1128,"static void encode_frame ( vpx_codec_ctx_t * codec ,  vpx_image_t * img , int frame_index , int flags ,  VpxVideoWriter * writer ) {vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {","static int encode_frame ( vpx_codec_ctx_t * codec , vpx_image_t * img , int frame_index , int flags , VpxVideoWriter * writer ) {int got_pkts = 0 ;vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {got_pkts = 1 ;if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {",3245
1129,},return got_pkts ;},3245
1130,for ( x = 0 ;x += 2 )  {,for ( x = 0 ;x += 4 ) {,3246
1131,"static VALUE from_document ( VALUE klass , VALUE document )  {","static VALUE from_document ( int argc , VALUE * argv , VALUE klass ) {VALUE document ;VALUE parse_options ;int scanned_args = 0 ;scanned_args = rb_scan_args ( argc , argv , ""11"" , & document , & parse_options ) ;if ( scanned_args == 1 ) {parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ;}rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;",3247
1132,return rb_schema ;},return rb_schema ;},3247
1133,"ops -> get_msr ( ctxt , MSR_EFER , & efer ) ;setup_syscalls_segments ( ctxt , & cs , & ss ) ;ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ;","if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ;ops -> get_msr ( ctxt , MSR_EFER , & efer ) ;setup_syscalls_segments ( ctxt , & cs , & ss ) ;if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt ) ;ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ;",3248
1134,"static void send ( node_t * node , node_t * child , byte * fout ) {if ( node -> parent ) {send ( node -> parent , node , fout ) ;}if ( child ) {if ( node -> right == child ) {","static void send ( node_t * node , node_t * child , byte * fout , int maxoffset ) {if ( node -> parent ) {send ( node -> parent , node , fout , maxoffset ) ;}if ( child ) {if ( bloc >= maxoffset ) {bloc = maxoffset + 1 ;return ;}if ( node -> right == child ) {",3249
1135,"int bytes_read = read ( reader -> inbound_fd , buffer -> data , reader -> buffer_size ) ;if ( bytes_read > 0 ) {","int bytes_read = TEMP_FAILURE_RETRY ( read ( reader -> inbound_fd , buffer -> data , reader -> buffer_size ) ) ;if ( bytes_read > 0 ) {",3250
1136,"if ( ! revs -> blob_objects )  return ;show ( obj , path , name , cb_data ) ;}","size_t pathlen ;if ( ! revs -> blob_objects ) return ;pathlen = path -> len ;strbuf_addstr ( path , name ) ;show ( obj , path -> buf , cb_data ) ;strbuf_setlen ( path , pathlen ) ;}",3251
1137,"yyerror ( yyscanner , lex_env , ""repeat<S2SV_blank>interval<S2SV_blank>too<S2SV_blank>large"" ) ;yyerror ( yyscanner , lex_env , ""bad<S2SV_blank>repeat<S2SV_blank>interval"" ) ;","yyerror ( yyscanner , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" ) ;yyerror ( yyscanner , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" ) ;",3252
1138,"yyerror ( yyscanner , lex_env , ""repeat<S2SV_blank>interval<S2SV_blank>too<S2SV_blank>large"" ) ;","yyerror ( yyscanner , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" ) ;",3252
1139,"yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;","yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;",3252
1140,"yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;","yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;",3252
1141,"yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;","yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;",3252
1142,"static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid ,  struct uid_gid_map * new_map ) {","static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) {",3253
1143,"if ( ns_capable ( ns -> parent , cap_setid ) )  return true ;","if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ;",3253
1144,"unsigned long cs ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE )  return rc ;if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ;if ( ctxt -> mode >= X86EMUL_MODE_PROT16 && ( cs & 3 ) > cpl ) return X86EMUL_UNHANDLEABLE ;rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ;return rc ;","unsigned long eip , cs ;u16 old_cs ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & eip , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ;rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ;return rc ;",3254
1145,"j ++ )  {body [ j ] = XMALLOC ( VarLenData , 1 ) ;return body ;}","j ++ ) {if ( a -> type == szMAPI_BINARY ) {body [ j ] = XMALLOC ( VarLenData , 1 ) ;}return body ;}",3255
1146,"sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL ,  ""FILE:<S2SV_blank>%02X%02X%02X%02X\\\}}","if ( bufLen < 2 ) break ;sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , ""FILE:<S2SV_blank>%02X%02X%02X%02X\\\bufLen -= 2 ;}}",3256
1147,"rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) ,  & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ;","rval = tpm_kdfa ( session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ;",3257
1148,"# endif const bool bcached =  ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ;ctx -> hdrs [ i ] -> old = false ;","# endif const bool bcached = ( mutt_bcache_exists ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) == 0 ) ;ctx -> hdrs [ i ] -> old = false ;",3258
1149,"struct iovec iov ;iov_for_each ( iov , i , * iter ) {if ( end < start ) return ERR_PTR ( - EINVAL ) ;","struct iovec iov ;struct bio_vec * bvec ;iov_for_each ( iov , i , * iter ) {if ( unlikely ( end < start ) return ERR_PTR ( - EINVAL ) ;",3259
1150,if ( ret < local_nr_pages ) {ret = - EFAULT ;,if ( ret < local_nr_pages ) ) {for ( j = cur_page ;j < page_limit ;j ++ ) {if ( ! pages [ j ] ) break ;put_page ( pages [ j ] ) ;}ret = - EFAULT ;,3259
1151,out_unmap :  for ( j = 0 ;j < nr_pages ;j ++ ) {if ( ! pages [ j ] ) break ;put_page ( pages [ j ] ) ;,"out_unmap : bio_for_each_segment_all ( bvec , bio , j ) {put_page ( bvec -> bv_page ) ;",3259
1152,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ;if ( current -> pid != previous_pid ) {","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , regs -> ARM_pc ) ;if ( current -> pid != previous_pid ) {",3260
1153,"ut8 * buf = calloc ( to - from , 1 ) ;if ( ! buf || ! min ) {r_buf_read_at ( bf -> buf , from , buf , to - from ) ;while ( needle < to ) {","int len = to - from ;ut8 * buf = calloc ( len , 1 ) ;if ( ! buf || ! min ) {r_buf_read_at ( bf -> buf , from , buf , len ) ;while ( needle < to ) {",3261
1154,if ( ( to - needle ) > 5 ) {bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ;if ( is_wide32 ) {,if ( ( to - needle ) > 5 + rc ) {bool is_wide32 = ( needle + rc + 2 < to ) && ( ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ) ;if ( is_wide32 ) {,3261
1155,"rd_create_ui ( ) ;in_uint32_le ( s , g_rdp_shareid ) ;in_uint16_le ( s , len_combined_caps ) ;in_uint8s ( s , len_src_descriptor ) ;","struct stream packet = * s ;rd_create_ui ( ) ;in_uint32_le ( s , g_rdp_shareid ) ;in_uint16_le ( s , len_combined_caps ) ;if ( ! s_check_rem ( s , len_src_descriptor ) ) {rdp_protocol_error ( ""rdp_demand_active(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>source<S2SV_blank>descriptor<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint8s ( s , len_src_descriptor ) ;",3262
1156,block_length = data [ i ] * 256 + data [ i + 1 ] ;},if ( i + 1 < data_size ) block_length = data [ i ] * 256 + data [ i + 1 ] ;},3263
1157,"switch ( type )  {case - 1 : {SetPixelAlpha ( image , pixel , q ) ;break ;case - 2 : case 0 : {SetPixelRed ( image , pixel , q ) ;if ( channels == 1 || type == - 2 ) SetPixelGray ( image , pixel , q ) ;if ( image -> storage_class == PseudoClass ) {if ( packet_size == 1 ) SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ;else SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;if ( image -> depth == 1 ) {SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) &   ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;x -- ;continue ;}}break ;}case 1 : {if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ;else SetPixelGreen ( image , pixel , q ) ;break ;case 2 : {if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ;else SetPixelBlue ( image , pixel , q ) ;break ;}case 3 : {if ( image -> colorspace == CMYKColorspace ) SetPixelBlack ( image , pixel , q ) ;else if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ;break ;}case 4 : {if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && ( channels > 3 ) ) break ;if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ;break ;}default : break ;}q += GetPixelChannels ( image ) ;","if ( image -> depth > 1 ) {SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ;q += GetPixelChannels ( image ) ;else {SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;if ( x != image -> columns ) x -- ;continue ;",3264
1158,"if ( sock -> type == SOCK_RAW )  sock -> ops = & rawsock_raw_ops ;else   sock -> ops = & rawsock_ops ;sk = sk_alloc ( net , PF_NFC , GFP_ATOMIC , nfc_proto -> proto , kern ) ;","if ( sock -> type == SOCK_RAW ) {if ( ! capable ( CAP_NET_RAW ) ) return - EPERM ;sock -> ops = & rawsock_raw_ops ;}else {sock -> ops = & rawsock_ops ;}sk = sk_alloc ( net , PF_NFC , GFP_ATOMIC , nfc_proto -> proto , kern ) ;",3265
1159,"if ( arg_debug ) printf ( ""Initializing<S2SV_blank>child<S2SV_blank>process\\\close ( parent_to_child_fds [ 1 ] ) ;close ( child_to_parent_fds [ 0 ] ) ;wait_for_other ( parent_to_child_fds [ 0 ] ) ;if ( arg_debug && child_pid == 1 ) printf ( ""PID<S2SV_blank>namespace<S2SV_blank>installed\\\if ( cfg . hostname ) {if ( sethostname ( cfg . hostname , strlen ( cfg . hostname ) ) < 0 ) errExit ( ""sethostname"" ) ;}if ( mount ( NULL , ""/"" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) {chk_chroot ( ) ;}preproc_mount_mnt_dir ( ) ;if ( mount ( LIBDIR ""/firejail"" , RUN_FIREJAIL_LIB_DIR , ""none"" , MS_BIND , NULL ) < 0 ) errExit ( ""mounting<S2SV_blank>"" RUN_FIREJAIL_LIB_DIR ) ;if ( cfg . name ) fs_logger2 ( ""sandbox<S2SV_blank>name:"" , cfg . name ) ;fs_logger2int ( ""sandbox<S2SV_blank>pid:"" , ( int ) sandbox_pid ) ;if ( cfg . chrootdir ) fs_logger ( ""sandbox<S2SV_blank>filesystem:<S2SV_blank>chroot"" ) ;else if ( arg_overlay ) fs_logger ( ""sandbox<S2SV_blank>filesystem:<S2SV_blank>overlay"" ) ;else fs_logger ( ""sandbox<S2SV_blank>filesystem:<S2SV_blank>local"" ) ;fs_logger ( ""install<S2SV_blank>mount<S2SV_blank>namespace"" ) ;if ( arg_netfilter && any_bridge_configured ( ) ) {netfilter ( arg_netfilter_file ) ;}if ( arg_netfilter6 && any_bridge_configured ( ) ) {netfilter6 ( arg_netfilter6_file ) ;}int gw_cfg_failed = 0 ;if ( arg_nonetwork ) {net_if_up ( ""lo"" ) ;if ( arg_debug ) printf ( ""Network<S2SV_blank>namespace<S2SV_blank>enabled,<S2SV_blank>only<S2SV_blank>loopback<S2SV_blank>interface<S2SV_blank>available\\\}else if ( arg_netns ) {netns ( arg_netns ) ;if ( arg_debug ) printf ( ""Network<S2SV_blank>namespace<S2SV_blank>\\\'%s\\\'<S2SV_blank>activated\\\}else if ( any_bridge_configured ( ) || any_interface_configured ( ) ) {net_if_up ( ""lo"" ) ;if ( mac_not_zero ( cfg . bridge0 . macsandbox ) ) net_config_mac ( cfg . bridge0 . devsandbox , cfg . bridge0 . macsandbox ) ;sandbox_if_up ( & cfg . bridge0 ) ;if ( mac_not_zero ( cfg . bridge1 . macsandbox ) ) net_config_mac ( cfg . bridge1 . devsandbox , cfg . bridge1 . macsandbox ) ;sandbox_if_up ( & cfg . bridge1 ) ;if ( mac_not_zero ( cfg . bridge2 . macsandbox ) ) net_config_mac ( cfg . bridge2 . devsandbox , cfg . bridge2 . macsandbox ) ;sandbox_if_up ( & cfg . bridge2 ) ;if ( mac_not_zero ( cfg . bridge3 . macsandbox ) ) net_config_mac ( cfg . bridge3 . devsandbox , cfg . bridge3 . macsandbox ) ;sandbox_if_up ( & cfg . bridge3 ) ;if ( cfg . interface0 . configured && cfg . interface0 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface0 . dev , cfg . interface0 . ip , cfg . interface0 . mask , cfg . interface0 . mtu ) ;}if ( cfg . interface1 . configured && cfg . interface1 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface1 . dev , cfg . interface1 . ip , cfg . interface1 . mask , cfg . interface1 . mtu ) ;}if ( cfg . interface2 . configured && cfg . interface2 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface2 . dev , cfg . interface2 . ip , cfg . interface2 . mask , cfg . interface2 . mtu ) ;}if ( cfg . interface3 . configured && cfg . interface3 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface3 . dev , cfg . interface3 . ip , cfg . interface3 . mask , cfg . interface3 . mtu ) ;}if ( cfg . defaultgw ) {if ( net_add_route ( 0 , 0 , cfg . defaultgw ) ) {fwarning ( ""cannot<S2SV_blank>configure<S2SV_blank>default<S2SV_blank>route\\\gw_cfg_failed = 1 ;}}if ( arg_debug ) printf ( ""Network<S2SV_blank>namespace<S2SV_blank>enabled\\\}if ( ! arg_quiet ) {if ( any_bridge_configured ( ) || any_interface_configured ( ) || cfg . defaultgw || cfg . dns1 ) {fmessage ( ""\\\if ( any_bridge_configured ( ) || any_interface_configured ( ) ) {if ( arg_scan ) sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 3 , PATH_FNET , ""printif"" , ""scan"" ) ;else sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 2 , PATH_FNET , ""printif"" ) ;}if ( cfg . defaultgw != 0 ) {if ( gw_cfg_failed ) fmessage ( ""Default<S2SV_blank>gateway<S2SV_blank>configuration<S2SV_blank>failed\\\else fmessage ( ""Default<S2SV_blank>gateway<S2SV_blank>%d.%d.%d.%d\\\}if ( cfg . dns1 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\if ( cfg . dns2 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\if ( cfg . dns3 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\if ( cfg . dns4 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\fmessage ( ""\\\}}if ( arg_nonetwork || any_bridge_configured ( ) || any_interface_configured ( ) ) {}else {EUID_USER ( ) ;env_ibus_load ( ) ;EUID_ROOT ( ) ;}# ifdef HAVE_SECCOMP if ( cfg . protocol ) {if ( arg_debug ) printf ( ""Build<S2SV_blank>protocol<S2SV_blank>filter:<S2SV_blank>%s\\\int rv = sbox_run ( SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP , 5 , PATH_FSECCOMP , ""protocol"" , ""build"" , cfg . protocol , RUN_SECCOMP_PROTOCOL ) ;if ( rv ) exit ( rv ) ;}if ( arg_seccomp && ( cfg . seccomp_list || cfg . seccomp_list_drop || cfg . seccomp_list_keep ) ) arg_seccomp_postexec = 1 ;# endif bool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec ;if ( getuid ( ) != 0 && ( arg_appimage || cfg . chrootdir || arg_overlay ) ) {enforce_filters ( ) ;need_preload = arg_trace || arg_tracelog ;}if ( need_preload ) fs_trace_preload ( ) ;if ( cfg . hosts_file ) fs_store_hosts_file ( ) ;# ifdef HAVE_CHROOT if ( cfg . chrootdir ) {fs_chroot ( cfg . chrootdir ) ;if ( need_preload ) fs_trace_preload ( ) ;}else # endif # ifdef HAVE_OVERLAYFS if ( arg_overlay ) fs_overlayfs ( ) ;else # endif fs_basic_fs ( ) ;if ( arg_private ) {if ( cfg . home_private ) {if ( cfg . chrootdir ) fwarning ( ""private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else fs_private_homedir ( ) ;}else if ( cfg . home_private_keep ) {if ( cfg . chrootdir ) fwarning ( ""private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else fs_private_home_list ( ) ;}else fs_private ( ) ;}if ( arg_private_dev ) fs_private_dev ( ) ;if ( arg_private_etc ) {if ( cfg . chrootdir ) fwarning ( ""private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_dir_list ( ""/etc"" , RUN_ETC_DIR , cfg . etc_private_keep ) ;if ( need_preload ) fs_trace_preload ( ) ;}}if ( arg_private_opt ) {if ( cfg . chrootdir ) fwarning ( ""private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_dir_list ( ""/opt"" , RUN_OPT_DIR , cfg . opt_private_keep ) ;}}if ( arg_private_srv ) {if ( cfg . chrootdir ) fwarning ( ""private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_dir_list ( ""/srv"" , RUN_SRV_DIR , cfg . srv_private_keep ) ;}}if ( arg_private_bin && ! arg_appimage ) {if ( cfg . chrootdir ) fwarning ( ""private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {if ( arg_x11_xorg ) {EUID_USER ( ) ;char * tmp ;if ( asprintf ( & tmp , ""%s,xauth"" , cfg . bin_private_keep ) == - 1 ) errExit ( ""asprintf"" ) ;cfg . bin_private_keep = tmp ;EUID_ROOT ( ) ;}fs_private_bin_list ( ) ;}}if ( arg_private_lib && ! arg_appimage ) {if ( cfg . chrootdir ) fwarning ( ""private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_lib ( ) ;}}if ( arg_private_cache ) {if ( cfg . chrootdir ) fwarning ( ""private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else fs_private_cache ( ) ;}if ( arg_private_tmp ) {EUID_USER ( ) ;fs_private_tmp ( ) ;EUID_ROOT ( ) ;}if ( arg_nodbus ) dbus_session_disable ( ) ;if ( cfg . hostname ) fs_hostname ( cfg . hostname ) ;if ( cfg . hosts_file ) fs_mount_hosts_file ( ) ;if ( arg_netns ) netns_mounts ( arg_netns ) ;fs_proc_sys_dev_boot ( ) ;if ( checkcfg ( CFG_DISABLE_MNT ) ) fs_mnt ( 1 ) ;else if ( arg_disable_mnt ) fs_mnt ( 0 ) ;fs_whitelist ( ) ;fs_blacklist ( ) ;if ( arg_nosound ) {pulseaudio_disable ( ) ;fs_dev_disable_sound ( ) ;}else if ( ! arg_noautopulse ) pulseaudio_init ( ) ;if ( arg_no3d ) fs_dev_disable_3d ( ) ;if ( arg_notv ) fs_dev_disable_tv ( ) ;if ( arg_nodvd ) fs_dev_disable_dvd ( ) ;if ( arg_nou2f ) fs_dev_disable_u2f ( ) ;if ( arg_novideo ) fs_dev_disable_video ( ) ;if ( need_preload ) fs_trace ( ) ;fs_resolvconf ( ) ;fs_logger_print ( ) ;fs_logger_change_owner ( ) ;EUID_USER ( ) ;int cwd = 0 ;if ( cfg . cwd ) {if ( chdir ( cfg . cwd ) == 0 ) cwd = 1 ;}if ( ! cwd ) {if ( chdir ( ""/"" ) < 0 ) errExit ( ""chdir"" ) ;if ( cfg . homedir ) {struct stat s ;if ( stat ( cfg . homedir , & s ) == 0 ) {if ( chdir ( cfg . homedir ) < 0 ) errExit ( ""chdir"" ) ;}}}if ( arg_debug ) {char * cpath = get_current_dir_name ( ) ;if ( cpath ) {printf ( ""Current<S2SV_blank>directory:<S2SV_blank>%s\\\free ( cpath ) ;}}EUID_ROOT ( ) ;fs_x11 ( ) ;if ( arg_x11_xorg ) x11_xorg ( ) ;save_umask ( ) ;save_nonewprivs ( ) ;set_caps ( ) ;save_cpu ( ) ;",save_cpu ( ) ;,3266
1160,# endif  FILE * rj = create_ready_for_join_file ( ) ;,# endif FILE * rj = create_ready_for_join_file ( ) ;,3266
1161,"
","if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) {jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\\jas_free ( siz -> comps ) ;return - 1 ;}if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) {jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\\jas_free ( siz -> comps ) ;return - 1 ;}",3267
1162,siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ;siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ;,siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ;siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ;,3267
1163,if ( ( temp_buffer & 0xffffff00 ) != 0x100 )  continue ;else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ;else if ( temp_buffer < 0x120 )  VO ++ ;else if ( temp_buffer < 0x130 )  VOL ++ ;,if ( temp_buffer & 0xfffffe00 ) continue ;if ( temp_buffer >= 0x100 && temp_buffer < 2 ) continue ;else if ( temp_buffer >= 0x120 && temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ;else if ( temp_buffer < 0x120 ) VO ++ ;else if ( temp_buffer < 0x130 ) VOL ++ ;,3268
1164,"# endif if ( quitmore # ifdef FEAT_EVAL && ! getline_equal ( fgetline , cookie , get_func_line ) # endif && ! getline_equal ( fgetline , cookie , getnextac ) ) -- quitmore ;","# endif if ( restricted != 0 && ( ea . argt & RESTRICT ) ) {errormsg = _ ( ""E981:<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ;goto doend ;}if ( quitmore # ifdef FEAT_EVAL && ! getline_equal ( fgetline , cookie , get_func_line ) # endif && ! getline_equal ( fgetline , cookie , getnextac ) ) -- quitmore ;",3269
1165,# endif  if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) )  {,# endif if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) ) {,3269
1166,"chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ;if ( chip -> data_buffer == NULL ) {","chip -> data_buffer = kzalloc ( TPM_BUFSIZE , GFP_KERNEL ) ;if ( chip -> data_buffer == NULL ) {",3270
1167,"unsigned int channo ;if ( jp2_getuint16 ( in , & cdef -> numchans ) ) {","unsigned int channo ;cdef -> ents = 0 ;if ( jp2_getuint16 ( in , & cdef -> numchans ) ) {",3271
1168,"
",}else if ( request_size < 0 ) {rc = - EINVAL ;goto out_free_buffer ;,3272
1169,}},}},3272
1170,"guchar * match ;int i ;if ( client -> auth_end_offset > 0 ) {gsize left = strlen ( AUTH_END_STRING ) - client -> auth_end_offset ;gsize to_match = MIN ( left , buffer -> pos ) ;if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 )  {","goffset offset = 0 ;gsize original_size = client -> auth_buffer -> len ;g_byte_array_append ( client -> auth_buffer , buffer -> data , buffer -> pos ) ;if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) {",3273
1171,"if ( match != NULL )  return match - buffer -> data + strlen ( AUTH_END_STRING ) ;for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ;i > 0 ;i -- ) {if ( memcmp ( buffer -> data + buffer -> pos - i , AUTH_END_STRING , i ) == 0 ) {client -> auth_end_offset = i ;break ;return - 1 ;","if ( match != NULL ) return match - buffer -> data + strlen ( AUTH_END_STRING ) ;for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ;while ( TRUE ) {guint8 * line_start = client -> auth_buffer -> data + offset ;gsize remaining_data = client -> auth_buffer -> len - offset ;guint8 * line_end ;line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ;if ( line_end ) {offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ;if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ;* line_end = 0 ;if ( auth_line_is_begin ( line_start ) ) return offset - original_size ;}else {g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ;if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ;return FIND_AUTH_END_CONTINUE ;",3273
1172,break ;default : break ;,strict = true ;break ;default : break ;,3274
1173,# if ! ( CONFIG_FAST_UNALIGNED )  dst [ 0 ] = src [ 0 ] ;dst [ 1 ] = src [ 1 ] ;dst [ 2 ] = src [ 2 ] ;dst [ 3 ] = src [ 3 ] ;dst [ 4 ] = src [ 4 ] ;dst [ 5 ] = src [ 5 ] ;dst [ 6 ] = src [ 6 ] ;dst [ 7 ] = src [ 7 ] ;# else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ;( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ;# endif src += src_stride ;,"memcpy ( dst , src , 8 ) ;src += src_stride ;",3275
1174,"size_t i ;generic_gss_release_oid ( & tmpmin , & sc -> internal_mech ) ;",size_t i ;,3276
1175,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read )  ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ;else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ;,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) {i_temp = ih264d_read_mmco_commands ( ps_dec ) ;if ( i_temp < 0 ) {return ERROR_DBP_MANAGER_T ;}ps_dec -> u4_bitoffset = i_temp ;}else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ;,3277
1176,"if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) >  ( Rec2 . RecordLength - 2 - 2 ) / 3 )  ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;","if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;",3278
1177,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank>"" ""<keyframe-interval><S2SV_blank>[<error-resilient>]\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank>"" ""<keyframe-interval><S2SV_blank>[<error-resilient>]\\\",3279
1178,# elif defined ( USE_PAM )  # define PAM_END ( msg ) do {}while ( 0 )  pam_handle_t * pamh = NULL ;,# elif defined ( USE_PAM ) # define PAM_END ( msg ) do {\\\\\while ( 0 ) pam_handle_t * pamh = NULL ;,3280
1179,"# ifndef linux if ( dup2 ( temp_stdin , STDIN_FILENO ) == - 1 ) err ( 1 , ""dup2"" ) ;","# else # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresgid ( target_pw -> pw_gid , target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setresgid"" ) ;# else if ( setregid ( target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setregid"" ) ;# endif if ( initgroups ( target_pw -> pw_name , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""initgroups"" ) ;# if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresuid ( target , target , target ) == - 1 ) err ( 1 , ""setresuid"" ) ;# else if ( setreuid ( target , target ) == - 1 ) err ( 1 , ""setreuid"" ) ;# endif # ifndef linux if ( dup2 ( temp_stdin , STDIN_FILENO ) == - 1 ) err ( 1 , ""dup2"" ) ;",3280
1180,"# endif  if ( getcwd ( cwdpath , sizeof ( cwdpath ) ) == NULL ) cwd = ""(failed)"" ;# ifndef HAVE_LOGIN_CAP_H  if ( target != 0 ) setuid ( target ) ;if ( geteuid ( ) == ROOT_UID ) setuid ( ROOT_UID ) ;# endif syslog ( LOG_AUTHPRIV | LOG_INFO , ""%s<S2SV_blank>ran<S2SV_blank>command<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s"" , myname , cmdline , target_pw -> pw_name , cwd ) ;","# endif if ( getcwd ( cwdpath , sizeof ( cwdpath ) ) == NULL ) cwd = ""(failed)"" ;syslog ( LOG_AUTHPRIV | LOG_INFO , ""%s<S2SV_blank>ran<S2SV_blank>command<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s"" , myname , cmdline , target_pw -> pw_name , cwd ) ;",3280
1181,if ( ! ( XFS_AGF_GOOD_VERSION ( be32_to_cpu ( agf -> agf_versionnum ) ) && be32_to_cpu ( agf -> agf_freeblks ) <= be32_to_cpu ( agf -> agf_length ) && be32_to_cpu ( agf -> agf_flfirst ) < xfs_agfl_size ( mp ) && be32_to_cpu ( agf -> agf_fllast ) < xfs_agfl_size ( mp ) &&  be32_to_cpu ( agf -> agf_flcount ) <= xfs_agfl_size ( mp ) ) )  return __this_address ;if ( bp -> b_pag && be32_to_cpu ( agf -> agf_seqno ) != bp -> b_pag -> pag_agno )  return __this_address ;if ( xfs_sb_version_haslazysbcount ( & mp -> m_sb ) &&  be32_to_cpu ( agf -> agf_btreeblks ) > be32_to_cpu ( agf -> agf_length ) )  return __this_address ;,if ( ! ( XFS_AGF_GOOD_VERSION ( be32_to_cpu ( agf -> agf_versionnum ) ) && be32_to_cpu ( agf -> agf_freeblks ) <= be32_to_cpu ( agf -> agf_length ) && be32_to_cpu ( agf -> agf_flfirst ) < xfs_agfl_size ( mp ) ) ) return __this_address ;if ( xfs_sb_version_hasrmapbt ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_rmap_blocks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ;if ( be32_to_cpu ( agf -> agf_length ) > mp -> m_sb . sb_dblocks ) return __this_address ;if ( be32_to_cpu ( agf -> agf_freeblks ) < be32_to_cpu ( agf -> agf_longest ) || be32_to_cpu ( agf -> agf_freeblks ) > be32_to_cpu ( agf -> agf_length && be32_to_cpu ( agf -> agf_fllast ) < xfs_agfl_size ( mp ) && be32_to_cpu ( agf -> agf_flcount ) <= xfs_agfl_size ( mp ) ) ) return __this_address ;if ( bp -> b_pag && be32_to_cpu ( agf -> agf_seqno ) != bp -> b_pag -> pag_agno ) return __this_address ;if ( xfs_sb_version_haslazysbcount ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_btreeblks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ;if ( xfs_sb_version_hasreflink ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_refcount_blocks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ;,3281
1182,"skb -> ip_summed = CHECKSUM_PARTIAL ;skb -> csum = 0 ;__skb_queue_tail ( queue , skb ) ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;","skb -> csum = 0 ;__skb_queue_tail ( queue , skb ) ;}else if ( skb_is_gso ( skb ) ) {goto append ;}skb -> ip_summed = CHECKSUM_PARTIAL ;append : return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",3282
1183,"int byte_count = 0 , count ;if ( ! format ) return psf_ftell ( psf ) ;while ( ( c = * format ++ ) )  {switch ( c )  {ucptr = ( unsigned char * ) intptr ;byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ;case \'h\' :  intptr = va_arg ( argptr , unsigned int * ) ;ucptr = ( unsigned char * ) intptr ;","int byte_count = 0 , count = 0 ;if ( ! format ) return psf_ftell ( psf ) ;while ( ( c = * format ++ ) ) {if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ;switch ( c ) {* intptr = 0 ;ucptr = ( unsigned char * ) intptr ;byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ;case \'h\' : intptr = va_arg ( argptr , unsigned int * ) ;* intptr = 0 ;ucptr = ( unsigned char * ) intptr ;",3283
1184,"if ( count > 0 )  byte_count += header_read ( psf , charptr , count ) ;break ;case \'G\' :  charptr = va_arg ( argptr , char * ) ;count = va_arg ( argptr , size_t ) ;if ( count > 0 )  byte_count += header_gets ( psf , charptr , count ) ;header_seek ( psf , count , SEEK_SET ) ;byte_count = count ;byte_count += count ;}","memset ( charptr , 0 , count ) ;byte_count += header_read ( psf , charptr , count ) ;header_seek ( psf , count , SEEK_SET ) ;byte_count = count ;break ;case \'j\' : count = va_arg ( argptr , size_t ) ;header_seek ( psf , count , SEEK_SET ) ;byte_count = count ;byte_count += count ;}",3283
1185,"if ( ! ( info = bmp_getinfo ( in ) ) ) {jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\\}if ( ! bmp_issupported ( & hdr , info ) ) {","JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\\if ( ! ( info = bmp_getinfo ( in ) ) ) {jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\\}JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" ""mincolors<S2SV_blank>%d\\\if ( ! bmp_issupported ( & hdr , info ) ) {",3284
1186,"if ( ACTION ( HOME ) ) {}handle_run ( req , res ) ;}is_monit_running ( res ) ;}else if ( ACTION ( ABOUT ) ) {do_about ( res ) ;}else if ( ACTION ( FAVICON ) ) {printFavicon ( res ) ;}else if ( ACTION ( PING ) ) {do_ping ( res ) ;}else if ( ACTION ( GETID ) ) {do_getid ( res ) ;}else if ( ACTION ( STATUS ) ) {print_status ( req , res , 1 ) ;","if ( ACTION ( RUNTIME ) ) {}handle_runtime ( req , res ) ;}is_monit_running ( res ) ;}else {handle_service ( req , res , 1 ) ;",3285
1187,"extent_type = btrfs_file_extent_type ( leaf , fi ) ;if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) {item_end += btrfs_file_extent_num_bytes ( leaf , fi ) ;else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) {item_end += btrfs_file_extent_inline_len ( leaf , path -> slots [ 0 ] , fi ) ;item_end -- ;if ( found_type > min_type ) {del_item = 1 ;else {if ( item_end < new_size ) break ;if ( found_key . offset >= new_size ) del_item = 1 ;else del_item = 0 ;}found_extent = 0 ;if ( found_type != BTRFS_EXTENT_DATA_KEY ) goto delete ;if ( del_item ) last_size = found_key . offset ;else last_size = new_size ;if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) {u64 num_dec ;extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ;if ( ! del_item ) {u64 orig_num_bytes = btrfs_file_extent_num_bytes ( leaf , fi ) ;extent_num_bytes = ALIGN ( new_size - found_key . offset , root -> sectorsize ) ;btrfs_set_file_extent_num_bytes ( leaf , fi , extent_num_bytes ) ;num_dec = ( orig_num_bytes - extent_num_bytes ) ;if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ;","extent_type = btrfs_file_extent_type ( leaf , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) {err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ;if ( err ) {btrfs_abort_transaction ( trans , root , err ) ;goto error ;pending_del_nr = 0 ;err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ;if ( err ) {btrfs_abort_transaction ( trans , root , err ) ;goto error ;else if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ;",3286
1188,"if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , num_dec ) ;if ( ! del_item &&  btrfs_file_extent_compression ( leaf , fi ) == 0 &&  btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) )  inode_sub_bytes ( inode , item_end + 1 -  new_size ) ;btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ;size = btrfs_file_extent_calc_inline_size ( size ) ;btrfs_truncate_item ( root , path , size , 1 ) ;","if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) {inode_sub_bytes ( inode , num_dec ) ;if ( ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( btrfs_file_extent_compression ( leaf , fi ) == 0 && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , item_end + 1 - new_size ) ;",3286
1189,},vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ;vpx_free ( denoiser -> denoise_state ) ;},3287
1190,struct stat st ;size_t pathlen ;,size_t pathlen ;,3288
1191,"pr_fs_clear_cache ( ) ;res = pr_fsio_lstat ( path , & st ) ;xerrno = errno ;pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path ,  strerror ( xerrno ) ) ;errno = xerrno ;return - 1 ;if ( S_ISLNK ( st . st_mode ) ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>"" ""config)"" , path ) ;","res = is_symlink_path ( p , path , pathlen ) ;if ( errno == EPERM ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ;",3288
1192,"if ( length == 1 && bp [ 0 ] == 0xff ) {ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ;}if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) {","ND_TCHECK ( bp [ 0 ] ) ;if ( length == 1 && bp [ 0 ] == 0xff ) {ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ;}ND_TCHECK ( bp [ 3 ] ) ;if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) {",3289
1193,"int col_min = ref_col - distance ;int col_max = ref_col + distance ;DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , sad_array8 , 8 ) ;unsigned int sad_array [ 3 ] ;","DECLARE_ALIGNED ( 16 , unsigned short , sad_array8 , 8 ) ;unsigned int sad_array [ 3 ] ;",3290
1194,"bestsad = fn_ptr -> sdf ( what , what_stride ,  bestaddress , in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , in_what_stride ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",3290
1195,"fn_ptr -> sdx8f ( what , what_stride , check_here , in_what_stride , sad_array8 ) ;for ( i = 0 ;i < 8 ;i ++ ) {thissad = sad_array8 [ i ] ;if ( thissad < bestsad ) {this_mv . as_mv . col = c ;thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","fn_ptr -> sdx8f ( what , what_stride , check_here , in_what_stride ) ;",3290
1196,"thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {",3290
1197,hlist_del ( & pin -> m_list ) ;hlist_del ( & pin -> s_list ) ;spin_unlock ( & pin_lock ) ;,hlist_del_init ( & pin -> m_list ) ;hlist_del_init ( & pin -> s_list ) ;spin_unlock ( & pin_lock ) ;,3291
1198,"static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf )  {","static bool do_write_pids ( pid_t tpid , uid_t tuid , const char * contrl , const char * cg , const char * file , const char * buf ) {",3292
1199,"if ( v == \'0\' ) {if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 )  fail = true ;","if ( ! may_move_pid ( tpid , tuid , cred . pid ) ) {fail = true ;break ;}if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 ) fail = true ;",3292
1200,"u_char * b , * s , * t , c ;int i , proto ;b = ( uint8_t * ) malloc ( length ) ;if ( b == NULL ) return ;for ( s = ( u_char * ) p , t = b , i = length ;i > 0 ;c = * s ++ ;if ( i > 1 ) {i -- ;c = * s ++ ^ 0x20 ;}else continue ;","u_char * b , * t , c ;const u_char * s ;int i , proto ;b = ( u_char * ) malloc ( length ) ;if ( b == NULL ) return ;for ( s = p , t = b , i = length ;i > 0 && ND_TTEST ( * s ) ;c = * s ++ ;if ( i <= 1 || ! ND_TTEST ( * s ) ) break ;i -- ;c = * s ++ ^ 0x20 ;",3293
1201,assert ( dev -> lintr . pin > 0 ) ;pthread_mutex_lock ( & dev -> lintr . lock ) ;,"if ( dev -> lintr . pin <= 0 ) {pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\\return ;}pthread_mutex_lock ( & dev -> lintr . lock ) ;",3294
1202,BUG_ON ( ret == - EEXIST ) ;if ( ret ) {,BUG_ON ( ret == - EEXIST || ret == - EOVERFLOW ) ;if ( ret ) {,3295
1203,int opts ;Resub m ;,int result ;int opts ;Resub m ;,3296
1204,"if ( ! js_regexec ( re -> prog , text , & m , opts ) ) {if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ;","result = js_regexec ( re -> prog , text , & m , opts ) ;if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ;if ( result == 0 ) {if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ;",3296
1205,"static void findoprnd ( ITEM * ptr , int32 * pos )  {if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) {","static void findoprnd ( ITEM * ptr , int32 * pos ) {check_stack_depth ( ) ;if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) {",3297
