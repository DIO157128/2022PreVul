,source,target,group
0,"DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ;if ( cfg -> is_custom_debug_file ) {fclose ( cfg -> debug_file ) ;","DBG ( ""Restored<S2SV_blank>privileges"" ) ;",855
1,"if ( item_num > 65536 ) {av_log ( mxf -> fc , AV_LOG_ERROR , ""item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\","if ( item_num > 65536 || item_num < 0 ) {av_log ( mxf -> fc , AV_LOG_ERROR , ""item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\",856
2,"for ( pad = ( ( 3 * w ) % 4 ) ? ( 4 - ( 3 * w ) % 4 ) : 0 ;else {fdest = fopen ( outfile , ""wb"" ) ;if ( ! fdest ) {fprintf ( stderr , ""ERROR<S2SV_blank>-><S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\\return 1 ;}w = ( int ) image -> comps [ 0 ] . w ;h = ( int ) image -> comps [ 0 ] . h ;fprintf ( fdest , ""BM"" ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w + 54 + 1024 + h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + w * ( w % 2 ) ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 54 + 1024 ) & 0xff , ( ( 54 + 1024 ) >> 8 ) & 0xff , ( ( 54 + 1024 ) >> 16 ) & 0xff , ( ( 54 + 1024 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 40 ) & 0xff , ( ( 40 ) >> 8 ) & 0xff , ( ( 40 ) >> 16 ) & 0xff , ( ( 40 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( w ) & 0xff ) , ( OPJ_UINT8 ) ( ( w ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( h ) & 0xff ) , ( OPJ_UINT8 ) ( ( h ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c"" , ( 1 ) & 0xff , ( ( 1 ) >> 8 ) & 0xff ) ;fprintf ( fdest , ""%c%c"" , ( 8 ) & 0xff , ( ( 8 ) >> 8 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w + h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 256 ) & 0xff , ( ( 256 ) >> 8 ) & 0xff , ( ( 256 ) >> 16 ) & 0xff , ( ( 256 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 256 ) & 0xff , ( ( 256 ) >> 8 ) & 0xff , ( ( 256 ) >> 16 ) & 0xff , ( ( 256 ) >> 24 ) & 0xff ) ;if ( image -> comps [ 0 ] . prec > 8 ) {adjustR = ( int ) image -> comps [ 0 ] . prec - 8 ;printf ( ""BMP<S2SV_blank>CONVERSION:<S2SV_blank>Truncating<S2SV_blank>component<S2SV_blank>0<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>bits<S2SV_blank>to<S2SV_blank>8<S2SV_blank>bits\\\}else adjustR = 0 ;for ( i = 0 ;i < 256 ;i ++ ) {fprintf ( fdest , ""%c%c%c%c"" , i , i , i , 0 ) ;}for ( i = 0 ;i < w * h ;i ++ ) {int r ;r = image -> comps [ 0 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ;r += ( image -> comps [ 0 ] . sgnd ? 1 << ( image -> comps [ 0 ] . prec - 1 ) : 0 ) ;r = ( ( r >> adjustR ) + ( ( r >> ( adjustR - 1 ) ) % 2 ) ) ;if ( r > 255 ) r = 255 ;else if ( r < 0 ) r = 0 ;fprintf ( fdest , ""%c"" , ( OPJ_UINT8 ) r ) ;if ( ( i + 1 ) % w == 0 ) {for ( ( pad = w % 4 ) ? ( 4 - w % 4 ) : 0 ;pad > 0 ;pad -- )  fprintf ( fdest , ""%c"" , 0 ) ;}}fclose ( fdest ) ;}",for ( pad = ( w % 4 ) ? ( 4 - w % 4 ) : 0 ;,857
3,"OPJ_UINT32 x , y ;OPJ_UINT8 * pix ;x = y = 0U ;while ( y < height ) {","OPJ_UINT32 x , y , written ;OPJ_UINT8 * pix ;x = y = written = 0U ;while ( y < height ) {",858
4,* pix = c1 ;},* pix = c1 ;written ++ ;},858
5,}if ( ( OPJ_UINT32 ) c & 1U ) {return OPJ_TRUE ;},"written ++ ;}if ( ( OPJ_UINT32 ) c & 1U ) {if ( written != width * height ) {fprintf ( stderr , ""warning,<S2SV_blank>image\\\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\\return OPJ_FALSE ;}}return OPJ_TRUE ;",858
6,"id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ;if ( id < 0 ) {ipc_rcu_putref ( msq , msg_rcu_free ) ;return id ;}msq -> q_stime = msq -> q_rtime = 0 ;msq -> q_ctime = get_seconds ( ) ;","msq -> q_stime = msq -> q_rtime = 0 ;msq -> q_ctime = get_seconds ( ) ;id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ;if ( id < 0 ) {ipc_rcu_putref ( msq , msg_rcu_free ) ;return id ;}",859
7,"static void write_interp_filter ( INTERP_FILTER filter ,  struct vp9_write_bit_buffer * wb ) {const int filter_to_literal [ ] = {vp9_wb_write_bit ( wb , filter == SWITCHABLE ) ;if ( filter != SWITCHABLE )  vp9_wb_write_literal ( wb , filter_to_literal [ filter ] , 2 ) ;}","static void write_interp_filter ( INTERP_FILTER filter , struct vpx_write_bit_buffer * wb ) {const int filter_to_literal [ ] = {vpx_wb_write_bit ( wb , filter == SWITCHABLE ) ;if ( filter != SWITCHABLE ) vpx_wb_write_literal ( wb , filter_to_literal [ filter ] , 2 ) ;}",860
8,"static void read_switchable_interp_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) {int i , j ;","static void read_switchable_interp_probs ( FRAME_CONTEXT * fc , vpx_reader * r ) {int i , j ;",861
9,"JAS_DBGLOG ( 101 , ( ""jas_malloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%zu\\\result = malloc ( size ) ;","JAS_DBGLOG ( 101 , ( ""jas_malloc(%zu)\\\result = malloc ( size ) ;",862
10,return ret <= 0 ? ret : - EIO ;},return ret < 0 ? ret : - EIO ;},863
11,if ( op -> operands [ 1 ] . immediate == - 1 ) {return - 1 ;}immediate = op -> operands [ 1 ] . immediate * op -> operands [ 1 ] . sign ;if ( op -> operands [ 0 ] . type & OT_GPREG && ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) {if ( a -> bits == 64 && ( ( op -> operands [ 0 ] . type & OT_QWORD ) | ( op -> operands [ 1 ] . type & OT_QWORD ) ) ) {if ( ! ( op -> operands [ 1 ] . type & OT_CONSTANT ) && op -> operands [ 1 ] . extended ) {,if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED ) {,864
12,data [ l ++ ] = 0xc7 ;data [ l ++ ] = 0xc0 | op -> operands [ 0 ] . reg ;data [ l ++ ] = 0xb8 | op -> operands [ 0 ] . reg ;,data [ l ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ;return l ;}if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) {mod = 0x2 ;if ( op -> operands [ 1 ] . offset > 127 ) {mod = 0x4 ;}}if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) {if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) {data [ l ++ ] = 0x5 ;if ( op -> operands [ 1 ] . offset > 127 ) {data [ l ++ ] = 0x80 | op -> operands [ 0 ] . reg ;,864
13,data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 4 ;data [ l ++ ] = getsib ( op -> operands [ 0 ] . scale [ 0 ] ) << 6 | op -> operands [ 0 ] . regs [ 0 ] << 3 | 5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;return l ;}if ( ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) {if ( op -> operands [ 0 ] . reg == X86R_UNDEFINED || op -> operands [ 1 ] . reg == X86R_UNDEFINED ) {return - 1 ;}mod = 0x3 ;data [ l ++ ] = mod << 6 | op -> operands [ 1 ] . reg << 3 | op -> operands [ 0 ] . reg ;,data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ;,864
14,data [ l ++ ] = 0xa1 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;if ( a -> bits == 64 ) {data [ l ++ ] = offset >> 32 ;data [ l ++ ] = offset >> 40 ;data [ l ++ ] = offset >> 48 ;data [ l ++ ] = offset >> 54 ;return l ;if ( op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | ( op -> operands [ 1 ] . regs [ 0 ] - 8 ) ;,data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ;if ( op -> operands [ 1 ] . offset > 127 ) {mod = 0x1 ;}else {if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) {data [ l ++ ] = 0x0d ;}else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) {data [ l ++ ] = 0x05 ;}else {data [ l ++ ] = mod << 5 | op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] - 8 ) ;,864
15,data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ;data [ l ++ ] = 0x8b ;data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {,data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ;data [ l ++ ] = 0x8b ;data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ;}data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;}else {if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {base = 5 ;}if ( base ) {data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ;}else {data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ;}if ( offset || base ) {data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;}return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {,864
16,data [ l ++ ] = 0x25 ;}data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;}if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {,data [ l ++ ] = 0x25 ;}data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) {if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) {data [ l ++ ] = 0x67 ;}data [ l ++ ] = 0x48 ;}}else if ( op -> operands [ 1 ] . type & OT_DWORD ) {data [ l ++ ] = 0x44 ;}else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) {data [ l ++ ] = 0x67 ;}if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) {data [ l ++ ] = 0x48 ;}}if ( op -> operands [ 0 ] . type & OT_WORD ) {data [ l ++ ] = 0x66 ;data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ;}else {data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ;}if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) {if ( a -> bits == 64 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ;data [ l ++ ] = 0x25 ;}else {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;}if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {,864
17,"if ( access ( path , F_OK ) ) {","if ( safe_mount ( console -> name , path , ""none"" , MS_BIND , 0 , rootfs -> mount ) ) {",865
18,"if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) {ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\\\'%s\\\'<S2SV_blank>on<S2SV_blank>\\\'%s\\\'"" , console -> name , path ) ;","if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) {ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\\\'%s\\\'<S2SV_blank>on<S2SV_blank>\\\'%s\\\'"" , console -> name , path ) ;",865
19,"static int fsmVerify ( const char * path , rpmfi fi )  {","static int fsmVerify ( const char * path , rpmfi fi , const struct stat * fsb ) {",866
20,"
",uid_t luid = dsb . st_uid ;,866
21,"if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;rc = fsmStat ( path , 0 , & dsb ) ;if ( rc == RPMERR_ENOENT ) rc = 0 ;if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;}","if ( S_ISDIR ( dsb . st_mode ) && ( luid == 0 || luid == fsb -> st_uid ) ) return 0 ;rc = fsmStat ( path , 0 , & dsb ) ;if ( rc == RPMERR_ENOENT ) rc = 0 ;if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;}",866
22,"int r = ( int ) recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt ,   p_dcb -> mtu , MSG_DONTWAIT ) ;if ( r > 0 ) {","int r = ( int ) TEMP_FAILURE_RETRY ( recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt , p_dcb -> mtu , MSG_DONTWAIT ) ) ;if ( r > 0 ) {",867
23,"dentry -> d_fsdata = ( void * ) ns -> ops ;d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ;","dentry -> d_flags |= DCACHE_RCUACCESS ;dentry -> d_fsdata = ( void * ) ns -> ops ;d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ;",868
24,"uint8_t * buf = mempool_alloc ( buf_pool ) ;struct l2tp_avp_t * avp ;uint8_t * ptr ;int n ;int len = sizeof ( pack -> hdr ) ;ptr = buf + sizeof ( pack -> hdr ) ;list_for_each_entry ( attr , & pack -> attrs , entry ) {avp -> type = htons ( attr -> attr -> id ) ;avp -> M = attr -> M ;avp -> H = attr -> H ;avp -> length = sizeof ( * avp ) + attr -> length ;* ( uint16_t * ) ptr = htons ( * ( uint16_t * ) ptr ) ;if ( attr -> H ) memcpy ( avp -> val , attr -> val . octets , attr -> length ) ;else switch ( attr -> attr -> type ) {case ATTR_TYPE_INT16 : * ( int16_t * ) avp -> val = htons ( attr -> val . int16 ) ;break ;case ATTR_TYPE_INT32 : * ( int32_t * ) avp -> val = htonl ( attr -> val . int32 ) ;break ;case ATTR_TYPE_INT64 : * ( uint64_t * ) avp -> val = htobe64 ( attr -> val . uint64 ) ;break ;case ATTR_TYPE_STRING : case ATTR_TYPE_OCTETS : memcpy ( avp -> val , attr -> val . string , attr -> length ) ;break ;}ptr += sizeof ( * avp ) + attr -> length ;len += sizeof ( * avp ) + attr -> length ;}pack -> hdr . length = htons ( len ) ;memcpy ( buf , & pack -> hdr , sizeof ( pack -> hdr ) ) ;n = sendto ( sock , buf , ntohs ( pack -> hdr . length ) , 0 ,  & pack -> addr , sizeof ( pack -> addr ) ) ;mempool_free ( buf ) ;","struct l2tp_hdr_t * hdr ;struct l2tp_avp_t * avp ;uint8_t * buf , * ptr ;int n , len ;buf = mempool_alloc ( buf_pool ) ;hdr = ( struct l2tp_hdr_t * ) buf ;ptr = ( uint8_t * ) ( hdr + 1 ) ;len = sizeof ( pack -> hdr ) ;list_for_each_entry ( attr , & pack -> attrs , entry ) {avp -> flags = htons ( ( attr -> M ? L2TP_AVP_FLAG_M : 0 ) | ( attr -> H ? L2TP_AVP_FLAG_H : 0 ) | ( ( sizeof ( * avp ) + attr -> length ;* ( uint16_t * ) ptr = htons ( * ( uint16_t * ) ptr ) ;if ( attr -> H ) memcpy ( avp -> val , attr -> val . octets , attr -> length ) & L2TP_AVP_LEN_MASK ) ) ;hdr -> flags = htons ( pack -> hdr . flags ) ;",869
25,"if ( n != ntohs ( pack -> hdr . length ) ) {if ( conf_verbose )  log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>write<S2SV_blank>(%i/%i)\\\}","if ( n != ntohs ( pack -> hdr . length ) ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>write<S2SV_blank>(%i/%i)\\\}",869
26,"if ( strlen ( str ) >= sizeof ( lowstr ) )  {if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 ||  DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {","if ( strlen ( str ) > MAXDATELEN ) {if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {errno = PGTYPES_TS_BAD_TIMESTAMP ;return ( noresult ) ;}switch ( dtype ) {case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {",870
27,"memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , bs - sizeof ( struct extendedFileEntry ) ) ;","memcpy ( iinfo -> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ;if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ;if ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , bs - sizeof ( struct extendedFileEntry ) ) ;",871
28,if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) {if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ;,if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) {if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ;,871
29,"myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = options . compression ?  ""zlib@openssh.com,zlib,none"" : ""none,zlib@openssh.com,zlib"" ;myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ;","myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = options . compression ? ""zlib@openssh.com,none"" : ""none,zlib@openssh.com"" ;myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ;",872
30,"if ( level >= ms -> c . len ) {len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ;ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ;","if ( level >= ms -> c . len = 20 + level ) * sizeof ( * ms -> c . li ) ;ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ;",873
31,"if ( ! sock_flag ( sk , SOCK_ZAPPED ) )  return - EINVAL ;","if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ;",874
32,if ( sk -> sk_state != TCP_CLOSE )  goto out_unlock ;,if ( sk -> sk_state != TCP_CLOSE ) goto out_unlock ;,874
33,}audio_conv_info -> ver_major = ver_major ;,usb_conv_info -> class_data_type = USB_CONV_AUDIO ;}else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) {return 0 ;}audio_conv_info -> ver_major = ver_major ;,875
34,"goto reset ;}SAS_DPRINTK ( ""trying<S2SV_blank>to<S2SV_blank>find<S2SV_blank>task<S2SV_blank>0x%p\\\res = sas_scsi_find_task ( task ) ;switch ( res ) {case TASK_IS_DONE : SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>done\\\sas_eh_defer_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;sas_scsi_clear_queue_lu ( work_q , cmd ) ;tmf_resp = sas_recover_I_T ( task -> dev ) ;if ( tmf_resp == TMF_RESP_FUNC_COMPLETE || tmf_resp == - ENODEV ) {struct domain_device * dev = task -> dev ;SAS_DPRINTK ( ""I_T<S2SV_blank>%016llx<S2SV_blank>recovered\\\","sas_eh_finish_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;sas_scsi_clear_queue_lu ( work_q , cmd ) ;",876
35,void close_connection ( h2o_http2_conn_t * conn )  {}},int close_connection ( h2o_http2_conn_t * conn ) {return - 1 ;}return 0 ;},877
36,"# if ENABLE_BGP_VNC  bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ;","# if ENABLE_BGP_VNC_ATTR bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ;",878
37,while ( res == 0 && dev ) {struct expander_device * ex = & dev -> ex_dev ;,if ( res == 0 && dev ) {struct expander_device * ex = & dev -> ex_dev ;,879
38,"dev = NULL ;res = sas_find_bcast_dev ( port_dev , & dev ) ;","
",879
39,"return ;}ND_PRINT ( ( ndo , ""CFMv%u<S2SV_blank>%s,<S2SV_blank>MD<S2SV_blank>Level<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , tok2str ( cfm_opcode_values , ""unknown<S2SV_blank>(%u)"" , cfm_common_header -> opcode ) , CFM_EXTRACT_MD_LEVEL ( cfm_common_header -> mdlevel_version ) , length ) ) ;if ( ndo -> ndo_vflag < 1 ) {return ;}ND_PRINT ( ( ndo , ""\\\tptr += sizeof ( const struct cfm_common_header_t ) ;tlen = length - sizeof ( struct cfm_common_header_t ) ;if ( cfm_common_header -> first_tlv_offset > tlen ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , tlen ) ) ;return ;}switch ( cfm_common_header -> opcode ) {case CFM_OPCODE_CCM : msg_ptr . cfm_ccm = ( const struct cfm_ccm_t * ) tptr ;if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ccm ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>1,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ccm ) ) ) ;return ;if ( tlen < sizeof ( * msg_ptr . cfm_ccm ) ) goto tooshort ;ND_TCHECK ( * msg_ptr . cfm_ccm ) ;ccm_interval = CFM_EXTRACT_CCM_INTERVAL ( cfm_common_header -> flags ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[CCM<S2SV_blank>Interval<S2SV_blank>%u%s]"" , ccm_interval , cfm_common_header -> flags & CFM_CCM_RDI_FLAG ? "",<S2SV_blank>RDI"" : """" ) ) ;if ( ccm_interval ) {ND_PRINT ( ( ndo , ""\\\}ND_PRINT ( ( ndo , ""\\\namesp = msg_ptr . cfm_ccm -> names ;names_data_remaining = sizeof ( msg_ptr . cfm_ccm -> names ) ;md_nameformat = * namesp ;namesp ++ ;names_data_remaining -- ;if ( md_nameformat != CFM_CCM_MD_FORMAT_NONE ) {md_namelength = * namesp ;namesp ++ ;names_data_remaining -- ;ND_PRINT ( ( ndo , ""\\\if ( md_namelength > names_data_remaining - 3 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining - 2 ) ) ;return ;}md_name = namesp ;ND_PRINT ( ( ndo , ""\\\switch ( md_nameformat ) {case CFM_CCM_MD_FORMAT_DNS : case CFM_CCM_MD_FORMAT_CHAR : safeputs ( ndo , md_name , md_namelength ) ;break ;case CFM_CCM_MD_FORMAT_MAC : if ( md_namelength == 6 ) {ND_PRINT ( ( ndo , ""\\\}else {ND_PRINT ( ( ndo , ""\\\}break ;case CFM_CCM_MA_FORMAT_8021 : default : print_unknown_data ( ndo , md_name , ""\\\}namesp += md_namelength ;names_data_remaining -= md_namelength ;}else {ND_PRINT ( ( ndo , ""\\\}ma_nameformat = * namesp ;namesp ++ ;names_data_remaining -- ;ma_namelength = * namesp ;namesp ++ ;names_data_remaining -- ;ND_PRINT ( ( ndo , ""\\\if ( ma_namelength > names_data_remaining ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining ) ) ;return ;}ma_name = namesp ;ND_PRINT ( ( ndo , ""\\\switch ( ma_nameformat ) {case CFM_CCM_MA_FORMAT_CHAR : safeputs ( ndo , ma_name , ma_namelength ) ;break ;case CFM_CCM_MA_FORMAT_8021 : case CFM_CCM_MA_FORMAT_VID : case CFM_CCM_MA_FORMAT_INT : case CFM_CCM_MA_FORMAT_VPN : default : print_unknown_data ( ndo , ma_name , ""\\\}break ;case CFM_OPCODE_LTM : msg_ptr . cfm_ltm = ( const struct cfm_ltm_t * ) tptr ;if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltm ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>4,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltm ) ) ) ;return ;}if ( tlen < sizeof ( * msg_ptr . cfm_ltm ) ) goto tooshort ;ND_TCHECK ( * msg_ptr . cfm_ltm ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltm_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case CFM_OPCODE_LTR : msg_ptr . cfm_ltr = ( const struct cfm_ltr_t * ) tptr ;if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltr ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>5,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltr ) ) ) ;return ;}if ( tlen < sizeof ( * msg_ptr . cfm_ltr ) ) goto tooshort ;ND_TCHECK ( * msg_ptr . cfm_ltr ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltr_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case CFM_OPCODE_LBR : case CFM_OPCODE_LBM : default : print_unknown_data ( ndo , tptr , ""\\\break ;}tptr += cfm_common_header -> first_tlv_offset ;tlen -= cfm_common_header -> first_tlv_offset ;while ( tlen > 0 ) {cfm_tlv_header = ( const struct cfm_tlv_header_t * ) tptr ;ND_TCHECK2 ( * tptr , 1 ) ;cfm_tlv_type = cfm_tlv_header -> type ;ND_PRINT ( ( ndo , ""\\\if ( cfm_tlv_type == CFM_TLV_END ) {return ;}if ( tlen < sizeof ( struct cfm_tlv_header_t ) ) goto tooshort ;ND_TCHECK2 ( * tptr , sizeof ( struct cfm_tlv_header_t ) ) ;cfm_tlv_len = EXTRACT_16BITS ( & cfm_tlv_header -> length ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , cfm_tlv_len ) ) ;tptr += sizeof ( struct cfm_tlv_header_t ) ;tlen -= sizeof ( struct cfm_tlv_header_t ) ;tlv_ptr = tptr ;if ( tlen < cfm_tlv_len ) goto tooshort ;ND_TCHECK2 ( * tptr , cfm_tlv_len ) ;hexdump = FALSE ;switch ( cfm_tlv_type ) {case CFM_TLV_PORT_STATUS : if ( cfm_tlv_len < 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ;return ;}ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_port_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ;break ;case CFM_TLV_INTERFACE_STATUS : if ( cfm_tlv_len < 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ;return ;}ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_interface_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ;break ;case CFM_TLV_PRIVATE : if ( cfm_tlv_len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ;return ;}ND_PRINT ( ( ndo , "",<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Sub-Type<S2SV_blank>%u"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( tptr ) ) , EXTRACT_24BITS ( tptr ) , * ( tptr + 3 ) ) ) ;hexdump = TRUE ;break ;case CFM_TLV_SENDER_ID : {u_int chassis_id_type , chassis_id_length ;u_int mgmt_addr_length ;if ( cfm_tlv_len < 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ;return ;}",goto next_tlv ;,880
40,"return ;}return ;}case CFM_CHASSIS_ID_MAC_ADDRESS :  ND_PRINT ( ( ndo , ""\\\case CFM_CHASSIS_ID_NETWORK_ADDRESS :  hexdump |= cfm_network_addr_print ( ndo , tptr ) ;break ;","return ;}return ;}case CFM_CHASSIS_ID_MAC_ADDRESS : if ( chassis_id_length != ETHER_ADDR_LEN ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)"" ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , ""\\\break ;case CFM_CHASSIS_ID_NETWORK_ADDRESS : hexdump |= cfm_network_addr_print ( ndo , tptr ) ;",880
41,"return ;}if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {return ;}cfm_tlv_len -= mgmt_addr_length ;tptr += mgmt_addr_length ;ND_PRINT ( ( ndo , ""\\\return ;if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {cfm_tlv_len -= mgmt_addr_length ;tptr += mgmt_addr_length ;","return ;}ND_PRINT ( ( ndo , ""\\\if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {return ;}cfm_tlv_len -= mgmt_addr_length ;hex_print ( ndo , ""\\\tptr += mgmt_addr_length ;ND_PRINT ( ( ndo , ""\\\return ;ND_PRINT ( ( ndo , ""\\\if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {cfm_tlv_len -= mgmt_addr_length ;hex_print ( ndo , ""\\\tptr += mgmt_addr_length ;",880
42,tptr += cfm_tlv_len ;tlen -= cfm_tlv_len ;,next_tlv : tptr += cfm_tlv_len ;tlen -= cfm_tlv_len ;,880
43,"jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\\return - 1 ;","jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\\return - 1 ;}if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) {jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\\return - 1 ;}if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) {jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\\return - 1 ;",881
44,"jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data ,  tile -> tcomps [ 2 ] . data ) ;","jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , tile -> tcomps [ 2 ] . data ) ;",881
45,if ( ret )   return - EFAULT ;ptr -> next = NULL ;i < 16 ;i ++ ) ptr -> reply [ i ] = 0 ;ptr -> resultcode = 0 ;ptr -> kernel_data = NULL ;if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) {,ptr -> next = NULL ;ptr -> kernel_data = NULL ;if ( ret ) return - EFAULT ;if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) {,882
46,if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock )  return 0 ;,char * p ;int len ;if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ;,883
47,"if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) {truncate = 1 ;strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ;retnamlen += rr -> len - 5 ;break ;","len = rr -> len - 5 ) >= 254 ) {truncate = 1 ;p = memchr ( rr -> u . NM . name , len ) ;retnamlen += rr -> len - 5 ;break ;",883
48,return - 1 ;},return 1 ;},884
49,"return 0 ;}else if ( ( strcmp ( s , ""-v"" ) == 0 ) || ( strcmp ( s , ""-version"" ) == 0 ) ) {fprintf ( stderr , ""%s<S2SV_blank>%d.%d\\\return 0 ;}else if ( strcmp ( s , ""-V"" ) == 0 ) {VerboseFlag = 1 ;return - 1 ;}return - 1 ;}return - 1 ;}",return 1 ;return - 1 ;}return - 1 ;}return 1 ;},884
50,"if ( ( inbuffer = ReadInput ( inname ) ) == 0 ) return ( - 1 ) ;if ( ( outfile = fopen ( outname , ""w"" ) ) == 0 ) {exit ( - 1 ) ;}","if ( ( inbuffer = ReadInput ( inname ) ) == 0 ) return ( 1 ) ;if ( ( outfile = fopen ( outname , ""w"" ) ) == 0 ) {exit ( 1 ) ;}",884
51,return ( - 1 ) ;},return ( 1 ) ;},884
52,"delim = strchr ( pat -> p . str , \':\' ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , delim ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;mutt_error ( _ ( ""Server-side<S2SV_blank>custom<S2SV_blank>search<S2SV_blank>not<S2SV_blank>supported:<S2SV_blank>%s"" ) , pat -> p . str ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;","delim = strchr ( pat -> p . str , false , \':\' ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , delim , false ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str , false ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str , false ) ;mutt_buffer_addstr ( buf , term ) ;mutt_error ( _ ( ""Server-side<S2SV_blank>custom<S2SV_blank>search<S2SV_blank>not<S2SV_blank>supported:<S2SV_blank>%s"" ) , pat -> p . str , false ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;",885
53,"static INLINE void right_shift_8x8 ( __m128i * res , int const bit ) {const __m128i kOne = _mm_set1_epi16 ( 1 ) ;const int bit_m02 = bit - 2 ;","static INLINE void right_shift_8x8 ( __m128i * res , const int bit ) {",886
54,"if ( bit_m02 >= 0 ) {__m128i k_const_rounding = _mm_slli_epi16 ( kOne , bit_m02 ) ;res [ 0 ] = _mm_add_epi16 ( res [ 0 ] , k_const_rounding ) ;res [ 1 ] = _mm_add_epi16 ( res [ 1 ] , k_const_rounding ) ;res [ 2 ] = _mm_add_epi16 ( res [ 2 ] , k_const_rounding ) ;res [ 3 ] = _mm_add_epi16 ( res [ 3 ] , k_const_rounding ) ;res [ 4 ] = _mm_add_epi16 ( res [ 4 ] , k_const_rounding ) ;res [ 5 ] = _mm_add_epi16 ( res [ 5 ] , k_const_rounding ) ;res [ 6 ] = _mm_add_epi16 ( res [ 6 ] , k_const_rounding ) ;res [ 7 ] = _mm_add_epi16 ( res [ 7 ] , k_const_rounding ) ;","if ( bit == 2 ) {const __m128i const_rounding = _mm_set1_epi16 ( 1 ) ;res [ 0 ] = _mm_add_epi16 ( res [ 0 ] , const_rounding ) ;res [ 1 ] = _mm_add_epi16 ( res [ 1 ] , const_rounding ) ;res [ 2 ] = _mm_add_epi16 ( res [ 2 ] , const_rounding ) ;res [ 3 ] = _mm_add_epi16 ( res [ 3 ] , const_rounding ) ;res [ 4 ] = _mm_add_epi16 ( res [ 4 ] , const_rounding ) ;res [ 5 ] = _mm_add_epi16 ( res [ 5 ] , const_rounding ) ;res [ 6 ] = _mm_add_epi16 ( res [ 6 ] , const_rounding ) ;res [ 7 ] = _mm_add_epi16 ( res [ 7 ] , const_rounding ) ;",886
55,"res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , bit ) ;res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , bit ) ;res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , bit ) ;res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , bit ) ;res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , bit ) ;res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , bit ) ;res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , bit ) ;res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , bit ) ;","if ( bit == 1 ) {res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 1 ) ;res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 1 ) ;res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 1 ) ;res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 1 ) ;res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 1 ) ;res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 1 ) ;res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 1 ) ;res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 1 ) ;}else {res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 2 ) ;res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 2 ) ;res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 2 ) ;res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 2 ) ;res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 2 ) ;res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 2 ) ;res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 2 ) ;res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 2 ) ;}",886
56,if ( ! ext4_handle_valid ( handle ) )  return 0 ;,if ( ! EXT4_SB ( sb ) -> s_journal ) return 0 ;,887
57,"newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ;atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ;","inet_sk ( newsk ) -> mc_list = NULL ;newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ;atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ;",888
58,"# endif status = nfsd4_encode_bitmap ( xdr , bmval0 , bmval1 , bmval2 ) ;","# endif status = nfsd4_encode_bitmap ( xdr , supp [ 0 ] , supp [ 1 ] , supp [ 2 ] ) ;",889
59,"status = nfsd4_encode_bitmap ( xdr , NFSD_SUPPATTR_EXCLCREAT_WORD0 ,  NFSD_SUPPATTR_EXCLCREAT_WORD1 , NFSD_SUPPATTR_EXCLCREAT_WORD2 ) ;","u32 supp [ 3 ] ;memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ;supp [ 0 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD0 ;supp [ 1 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD1 ;supp [ 2 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD2 ;status = nfsd4_encode_bitmap ( xdr , NFSD_SUPPATTR_EXCLCREAT_WORD0 , NFSD_SUPPATTR_EXCLCREAT_WORD1 , NFSD_SUPPATTR_EXCLCREAT_WORD2 ) ;",889
60,if ( wsctx && wsctx -> readbuflen )  return TRUE ;,if ( wsctx && wsctx -> readlen ) return TRUE ;,890
61,const struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct inet_sock * newinet ;,const struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6_txoptions * opt ;struct inet_sock * newinet ;,891
62,"dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ;return newsk ;}if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ;if ( ! dst ) {struct flowi6 fl6 ;dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ;if ( ! dst ) goto out ;}newsk = dccp_create_openreq_child ( sk , req , skb ) ;if ( newsk == NULL ) goto out_nonewsk ;__ip6_dst_store ( newsk , dst , NULL , NULL ) ;newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ;newdp6 = ( struct dccp6_sock * ) newsk ;newinet = inet_sk ( newsk ) ;newinet -> pinet6 = & newdp6 -> inet6 ;newnp = inet6_sk ( newsk ) ;memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ;newnp -> saddr = ireq -> ir_v6_loc_addr ;newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ;newsk -> sk_bound_dev_if = ireq -> ir_iif ;newinet -> inet_opt = NULL ;newnp -> rxopt . all = np -> rxopt . all ;newnp -> pktoptions = NULL ;newnp -> opt = NULL ;newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;if ( np -> opt != NULL )   newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ;inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ;if ( newnp -> opt != NULL )   inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen +   newnp -> opt -> opt_flen ) ;dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ;","opt = rcu_dereference ( np -> opt != NULL ) newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ;inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ;if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ;dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ;",891
63,prev = NULL ;for ( vma = mm -> mmap ;,if ( ! mmget_still_valid ( mm ) ) goto skip_mm ;prev = NULL ;for ( vma = mm -> mmap ;,892
64,up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,skip_mm : up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,892
65,pExpr -> iTable = pX -> iIdxCur ;pExpr -> iColumn = pX -> iIdxCol ;,"assert ( pExpr -> y . pTab != 0 ) ;pExpr -> affExpr = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ;pExpr -> iTable = pX -> iIdxCur ;pExpr -> iColumn = pX -> iIdxCol ;",893
66,"char * path = server . diskstore_path ;if ( ( retval = stat ( path , & sb ) == - 1 ) && errno != ENOENT ) {","char * path = server . ds_path ;if ( ( retval = stat ( path , & sb ) == - 1 ) && errno != ENOENT ) {",894
67,"Stream_Read_UINT32 ( s , scopeCount ) ;scopeList -> count = scopeCount ;","Stream_Read_UINT32 ( s , scopeCount ) ;if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE ;scopeList -> count = scopeCount ;",895
68,"void vp9_idct4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {if ( eob > 1 )  vp9_idct4x4_16_add ( input , dest , stride ) ;else  vp9_idct4x4_1_add ( input , dest , stride ) ;}","void vp9_idct4x4_add ( const tran_low_t * input , uint8_t * dest , int stride , int eob ) {if ( eob > 1 ) vpx_idct4x4_16_add ( input , dest , stride ) ;else vpx_idct4x4_1_add ( input , dest , stride ) ;}",896
69,INST_HANDLER ( sts ) {int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,INST_HANDLER ( sts ) {if ( len < 4 ) {return ;}int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,897
70,"unsigned int maxw , maxh , max ;int offset , upb ;unsigned int i , j ;upb = ( int ) img -> comps [ 0 ] . prec ;maxw = ( unsigned int ) img -> comps [ 0 ] . w ;maxh = ( unsigned int ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;for ( i = 0U ;++ i )  {for ( j = 0U ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {","size_t maxw , maxh , max , offx , loopmaxw ;int offset , upb ;size_t i ;upb = ( int ) img -> comps [ 0 ] . prec ;maxw = ( size_t ) img -> comps [ 0 ] . w ;maxh = ( size_t ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;offx = img -> x0 & 1U ;loopmaxw = maxw - offx ;for ( i = 0U ;+ i )  {++ i ) {size_t j ;if ( offx > 0U ) {sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ;++ y ;++ r ;++ g ;++ b ;}for ( j = 0U ;j < ( loopmaxw & ~ ( unsigned int ) 1U ) ;j += 2U ) {",898
71,"if ( j < maxw ) {sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;","if ( j < loopmaxw ) {sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;",898
72,# if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = maxw ;img -> comps [ 2 ] . h = maxh ;# else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;# endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails :  if ( r ) free ( r ) ;if ( g ) free ( g ) ;if ( b ) free ( b ) ;},img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ;img -> comps [ 2 ] . h = img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = img -> comps [ 0 ] . h ;img -> comps [ 1 ] . dx = img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails : free ( r ) ;if ( g ) free ( g ) ;free ( b ) ;},898
73,"int i , j , offset ;uint8_t type ;","int i , offset ;uint8_t type ;",899
74,"u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ;if ( suf < 0x0200 ) {map -> s_partition_type = UDF_VIRTUAL_MAP15 ;map -> s_partition_func = udf_get_pblock_virt15 ;}else {map -> s_partition_type = UDF_VIRTUAL_MAP20 ;map -> s_partition_func = udf_get_pblock_virt20 ;}}else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) {uint32_t loc ;struct sparingTable * st ;struct sparablePartitionMap * spm =  ( struct sparablePartitionMap * ) gpm ;","if ( udf_load_sparable_map ( sb , map , ( struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ;",899
75,ps_dec_op -> u4_output_present = 0 ;ps_dec_op -> u4_frame_decoded_flag = 0 ;ps_dec -> i4_frametype = - 1 ;ps_dec -> i4_content_type = - 1 ;{if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) {ps_dec -> u1_top_bottom_decoded = 0 ;}},"
",900
76,"ps_dec -> u4_prev_nal_skipped = 0 ;ps_dec -> u2_cur_mb_addr = 0 ;ps_dec -> u2_total_mbs_coded = 0 ;ps_dec -> u2_cur_slice_num = 0 ;ps_dec -> cur_dec_mb_num = 0 ;ps_dec -> cur_recon_mb_num = 0 ;ps_dec -> u4_first_slice_in_pic = 2 ;ps_dec -> u1_first_pb_nal_in_pic = 1 ;ps_dec -> u1_slice_header_done = 0 ;ps_dec -> u1_dangling_field = 0 ;ps_dec -> u4_dec_thread_created = 0 ;ps_dec -> u4_bs_deblk_thread_created = 0 ;ps_dec -> u4_cur_bs_mb_num = 0 ;ps_dec -> u4_start_recon_deblk = 0 ;DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\\ps_dec -> u4_pic_buf_got = 0 ;do {pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ;u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ;pu1_bitstrm_buf = ps_dec -> ps_mem_tab [ MEM_REC_BITSBUF ] . pv_base ;u4_next_is_aud = 0 ;buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ;if ( buflen == - 1 ) buflen = 0 ;buflen = MIN ( buflen , ( WORD32 ) ( ps_dec -> ps_mem_tab [ MEM_REC_BITSBUF ] . u4_mem_size - 8 ) ) ;bytes_consumed = buflen + u4_length_of_start_code ;ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ;if ( buflen >= MAX_NAL_UNIT_SIZE ) {ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ;H264_DEC_DEBUG_PRINT ( ""\\\ps_dec -> i4_error_code = 1 << IVD_CORRUPTEDDATA ;ps_dec_op -> e_pic_type = - 1 ;ih264d_signal_decode_thread ( ps_dec ) ;if ( ps_dec -> u4_pic_buf_got == 0 ) {if ( ps_dec -> i4_header_decoded == 3 ) {ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ;}","
",900
77,"
",if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) {ps_dec -> u1_top_bottom_decoded = 0 ;}if ( ps_dec -> u4_pic_buf_got == 1 ) {if ( 1 == ps_dec -> u1_last_pic_not_decoded ) {ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ;if ( ret != OK ) return ret ;ret = ih264d_end_of_pic ( ps_dec ) ;if ( ret != OK ) return ret ;}else {ret = ih264d_end_of_pic ( ps_dec ) ;if ( ret != OK ) return ret ;}},900
78,if ( ret != 0 )  {,if ( ret != 0 ) {,900
79,"DATA_SYNC ( ) ;H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\\","DATA_SYNC ( ) ;H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\\",900
80,"sy = data -> ds . dimension_size [ 1 ] ;sz = data -> ds . dimension_size [ 2 ] ;dzy = dz * dy ;szy = sz * sy ;size = data -> datalayout_chunk [ data -> ds . dimensionality ] ;log ( ""elements<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d\\\if ( ! ( output = malloc ( elements * size ) ) ) {return MYSOFA_NO_MEMORY ;}for ( e = 0 ;e < entries_used * 2 ;e ++ ) {if ( node_type == 0 ) {key = readValue ( reader , reader -> superblock . size_of_lengths ) ;}else {size_of_chunk = ( uint32_t ) readValue ( reader , 4 ) ;filter_mask = ( uint32_t ) readValue ( reader , 4 ) ;if ( filter_mask ) {log ( ""TREE<S2SV_blank>all<S2SV_blank>filters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>enabled\\\free ( output ) ;return MYSOFA_INVALID_FORMAT ;}for ( j = 0 ;j < data -> ds . dimensionality ;j ++ ) {start [ j ] = readValue ( reader , 8 ) ;log ( ""start<S2SV_blank>%d<S2SV_blank>%lu\\\}if ( readValue ( reader , 8 ) ) {break ;}child_pointer = readValue ( reader , reader -> superblock . size_of_offsets ) ;log ( ""<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%lX<S2SV_blank>len<S2SV_blank>%u\\\store = ftell ( reader -> fhd ) ;if ( fseek ( reader -> fhd , child_pointer , SEEK_SET ) < 0 ) {free ( output ) ;return errno ;}if ( ! ( input = malloc ( size_of_chunk ) ) ) {free ( output ) ;return MYSOFA_NO_MEMORY ;}if ( fread ( input , 1 , size_of_chunk , reader -> fhd ) != size_of_chunk ) {free ( output ) ;free ( input ) ;return MYSOFA_INVALID_FORMAT ;}olen = elements * size ;err = gunzip ( size_of_chunk , input , & olen , output ) ;free ( input ) ;log ( ""<S2SV_blank><S2SV_blank><S2SV_blank>gunzip<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\\if ( err || olen != elements * size ) {free ( output ) ;return MYSOFA_INVALID_FORMAT ;}switch ( data -> ds . dimensionality ) {case 1 : for ( i = 0 ;i < olen ;i ++ ) {b = i / elements ;x = i % elements + start [ 0 ] ;if ( x < sx ) {j = x * size + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;",j = x * size + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;,901
81,if ( y < sy && x < sx ) {j = ( ( x * sy + y ) * size ) + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;,if ( y < sy && x < sx ) {j = ( ( x * sy + y ) * size ) + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;,901
82,if ( z < sz && y < sy && x < sx ) {j = ( x * szy + y * sz + z ) * size + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;},if ( z < sz && y < sy && x < sx ) {j = ( x * szy + y * sz + z ) * size + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;},901
83,ExprList_Init ( & state -> expr_list ) ;FstringParser_check_invariants ( state ) ;,state -> fmode = 0 ;ExprList_Init ( & state -> expr_list ) ;FstringParser_check_invariants ( state ) ;,902
84,return ret ;},if ( ! ret ) invalidate_lstat_cache ( ) ;return ret ;},903
85,if ( ! awaiting_character ) {recovery_abort ( ) ;,if ( ! awaiting_character || ! recovery_started ) {recovery_abort ( ) ;,904
86,"int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ;if ( sent == ( signed ) len ) osi_free ( buf ) ;","int sent = TEMP_FAILURE_RETRY ( send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ) ;if ( sent == ( signed ) len ) osi_free ( buf ) ;",905
87,return - EINVAL ;},kfree ( a ) ;return - EINVAL ;},906
88,"if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ;if ( tmp == NULL ) goto failed ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""lineno\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_col_offset ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_col_offset ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""col_offset\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ;return 1 ;","if ( lookup_attr_id ( obj , & PyId_lineno ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lineno , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""lineno\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ;return 1 ;}else {int res ;}if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""col_offset\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ;else {Py_CLEAR ( tmp ) ;",907
89,"if ( exists_not_none ( obj , & PyId_type ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_type ) ;if ( tmp == NULL ) goto failed ;}else {type = NULL ;if ( exists_not_none ( obj , & PyId_name ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ;if ( tmp == NULL ) goto failed ;}else {name = NULL ;if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;","if ( lookup_attr_id ( obj , & PyId_type ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_type , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type = NULL ;}else {int res ;if ( lookup_attr_id ( obj , & PyId_name , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;name = NULL ;}else {if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExceptHandler"" ) ;return 1 ;}else {Py_ssize_t i ;",907
90,"stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExceptHandler"" ) ;return 1 ;","stmt_ty val ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}",907
91,"u8 reset ;int ret , pos = 0 ;hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;if ( ! hx ) return - ENOMEM ;reset = 1 ;if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 )  err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;","u8 * buf ;int ret , pos = 0 ;u16 cpu_cs_register = cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;",908
92,"kfree ( hx ) ;return ret ;reset = 0 ;if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) {err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;kfree ( hx ) ;return ret ;","kfree ( hx ) ;return ret ;reset = 0 ;if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register ;buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;if ( ! buf ) return - ENOMEM ;hx = ( struct hexline * ) buf ;buf [ 0 ] = 1 ;if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 ) != 1 ) {err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;kfree ( buf ) ;return ret ;",908
93,"void set_header ( HttpResponse res , const char * name , const char * value ) {HttpHeader h = NULL ;h -> value = Str_dup ( value ) ;if ( res -> headers ) {","void set_header ( HttpResponse res , const char * name , const char * value , ... ) {HttpHeader h = NULL ;va_list ap ;va_start ( ap , value ) ;h -> value = Str_vcat ( value , ap ) ;va_end ( ap ) ;if ( res -> headers ) {",909
94,"char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ;char * mask_decoded5 ;mask_decoded = NULL ;mask_decoded2 = NULL ;mask2 = weechat_string_replace ( mask , dir_separator , ""\\\\01"" ) ;if ( ! mask2 ) goto end ;mask_decoded = weechat_buffer_string_replace_local_var ( buffer , mask2 ) ;if ( ! mask_decoded ) goto end ;mask_decoded2 = weechat_string_replace ( mask_decoded , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ;if ( ! mask_decoded2 ) goto end ;# ifdef __CYGWIN__ mask_decoded3 = weechat_string_replace ( mask_decoded2 , ""\\\\\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ;# else mask_decoded3 = strdup ( mask_decoded2 ) ;# endif if ( ! mask_decoded3 ) goto end ;mask_decoded4 = weechat_string_replace ( mask_decoded3 , ""\\\\01"" , dir_separator ) ;if ( ! mask_decoded4 ) goto end ;length = strlen ( mask_decoded4 ) + 256 + 1 ;mask_decoded5 = malloc ( length ) ;if ( ! mask_decoded5 )  goto end ;mask_decoded5 [ 0 ] = \'\\\\0\' ;strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ;if ( weechat_config_boolean ( logger_config_file_name_lower_case ) )  weechat_string_tolower ( mask_decoded5 ) ;if ( weechat_logger_plugin -> debug ) {weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) ,  mask , mask_decoded5 ) ;}if ( mask_decoded )   free ( mask_decoded ) ;if ( mask_decoded2 )  free ( mask_decoded2 ) ;if ( mask_decoded3 )  free ( mask_decoded3 ) ;if ( mask_decoded4 )  free ( mask_decoded4 ) ;return mask_decoded5 ;}","char * mask2 , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 ;mask3 = NULL ;mask4 = NULL ;mask5 = NULL ;mask6 = NULL ;mask7 = NULL ;mask_decoded2 = NULL ;length = strlen ( mask ) + 256 + 1 ;mask_decoded5 = malloc ( length ) ;if ( ! mask_decoded5 ) goto end ;mask_decoded5 [ 0 ] = \'\\\\0\' ;strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) == 0 ) mask2 [ 0 ] = \'\\\\0\' ;mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\\\01"" ) ;if ( ! mask3 ) goto end ;mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ;if ( ! mask4 ) goto end ;mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ;if ( ! mask5 ) goto end ;# ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ;# else mask6 = strdup ( mask5 ) ;# endif if ( ! mask6 ) goto end ;mask7 = weechat_string_replace ( mask6 , ""\\\\01"" , dir_separator ) ;if ( ! mask7 ) goto end ;if ( weechat_config_boolean ( logger_config_file_name_lower_case ) ) weechat_string_tolower ( mask7 ) ;if ( weechat_logger_plugin -> debug ) {weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) , mask , mask7 ) ;}if ( mask3 ) free ( mask_decoded ) ;if ( mask_decoded2 ) free ( mask3 ) ;if ( mask4 ) free ( mask_decoded3 ) ;if ( mask_decoded4 ) free ( mask6 ) ;return mask7 ;}",910
95,xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;}if ( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&  ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) {,if ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) {xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;}else {xWantedSize = 0 ;}}if ( ( xWantedSize > 0 ) && ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) && ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) {,911
96,"static int em_call ( struct x86_emulate_ctxt * ctxt )  {long rel = ctxt -> src . val ;jmp_rel ( ctxt , rel ) ;return em_push ( ctxt ) ;","static int em_call ( struct x86_emulate_ctxt * ctxt ) {int rc ;long rel = ctxt -> src . val ;rc = jmp_rel ( ctxt , rel ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;return em_push ( ctxt ) ;",912
97,"if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , ""chunked"" ) != NULL ) ) {msr -> reqbody_should_exist = 1 ;","if ( ( transfer_encoding != NULL ) && ( m_strcasestr ( transfer_encoding , ""chunked"" ) != NULL ) ) {msr -> reqbody_should_exist = 1 ;",913
98,"struct desc_struct * desc ;short sel ;if ( v8086_mode ( regs ) ) return ( unsigned long ) ( sel << 4 ) ;if ( user_64bit_mode ( regs ) ) {unsigned long base ;if ( seg_reg_idx == INAT_SEG_REG_FS ) rdmsrl ( MSR_FS_BASE , base ) ;else if ( seg_reg_idx == INAT_SEG_REG_GS ) rdmsrl ( MSR_KERNEL_GS_BASE , base ) ;else base = 0 ;return base ;}desc = get_desc ( sel ) ;if ( ! desc )  return - 1L ;return get_desc_base ( desc ) ;}",struct desc_struct desc ;short sel ;desc = get_desc ( sel ) ;if ( ! desc ) return - 1L ;return get_desc_base ( & desc ) ;},914
99,entry . uncompressed_filesize = PHAR_GET_32 ( zipentry . uncompsize ) ;,entry . uncompressed_filesize || read <= 8 = PHAR_GET_32 ( zipentry . uncompsize ) ;,915
100,if ( read != entry . uncompressed_filesize ) {php_stream_close ( sigfile ) ;,if ( read != entry . uncompressed_filesize ) {php_stream_close ( sigfile ) ;,915
101,"
",userfaultfd_ctx_get ( fork_nctx ) ;,916
102,spin_unlock ( & ctx -> event_wqh . lock ) ;ret = 0 ;,spin_unlock ( & ctx -> event_wqh . lock ) ;ret = 0 ;,916
103,"if ( ! ret ) {spin_lock ( & ctx -> event_wqh . lock ) ;uwq = list_first_entry ( & fork_event ,  typeof ( * uwq ) , wq . entry ) ;userfaultfd_event_complete ( ctx , uwq ) ;}spin_unlock ( & ctx -> event_wqh . lock ) ;}","spin_lock ( & ctx -> event_wqh . lock ) ;userfaultfd_ctx_put ( fork_nctx ) ;uwq = list_first_entry ( & fork_event , typeof ( * uwq ) , wq . entry ) ;if ( likely ( ! ret ) ) userfaultfd_event_complete ( ctx , uwq ) ;}else {if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ;}spin_unlock ( & ctx -> event_wqh . lock ) ;",916
104,"const int bh = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ;vp9_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride ,  pd -> dst . buf , pd -> dst . stride ) ;","# if CONFIG_VP9_HIGHBITDEPTH if ( x -> e_mbd . cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {vpx_highbd_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride , x -> e_mbd . bd ) ;return ;}# endif vpx_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride ) ;",917
105,"static unsigned short len = 0 ;char buff [ 13 ] , * ret_msg = NULL ;","static size_t len = 0 ;char buff [ 13 ] , * ret_msg = NULL ;",918
106,"# if ALLOW_WINDOWLESS_PLUGINS case NPNVSupportsWindowless : # endif case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject :  return g_NPN_GetValue_real ( instance , variable , value ) ;default : switch ( variable & 0xff ) {","# if ALLOW_WINDOWLESS_PLUGINS case NPNVSupportsWindowless : # endif case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling : return g_NPN_GetValue_real ( instance , variable , value ) ;default : switch ( variable & 0xff ) {",919
107,"if ( out_dev == in_dev && err && IN_DEV_TX_REDIRECTS ( out_dev ) &&  ( IN_DEV_SHARED_MEDIA ( out_dev ) ||   inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) {flags |= RTCF_DOREDIRECT ;do_cache = false ;}","if ( out_dev == in_dev && err && IN_DEV_TX_REDIRECTS ( out_dev ) && skb -> protocol == htons ( ETH_P_IP ) && ( IN_DEV_SHARED_MEDIA ( out_dev ) || inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ;",920
108,"if ( ! x -> e_mbd . left_context ) return ;vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;","memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;",921
109,"static struct cifsSesInfo *  cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username )  {struct list_head * tmp ;list_for_each ( tmp , & server -> smb_ses_list ) {ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) )   continue ;++ ses -> ses_count ;","static struct cifsSesInfo * cifs_find_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * vol ) {+ ses -> ses_count ;list_for_each_entry ( ses , & server -> smb_ses_list ) {ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;if ( strncmp ( ses -> userName , vol -> username , MAX_USERNAME_SIZE ) ) continue ;if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ;}++ ses -> ses_count ;",922
110,"case 0x70 ... 0x7f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;break ;","case 0x70 ... 0x7f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;break ;",923
111,"case 0xe9 : case 0xeb :  jmp_rel ( ctxt , ctxt -> src . val ) ;ctxt -> dst . type = OP_NONE ;","case 0xe9 : case 0xeb : rc = jmp_rel ( ctxt , ctxt -> src . val ) ;ctxt -> dst . type = OP_NONE ;",923
112,"case 0x40 ... 0x4f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) ctxt -> dst . val = ctxt -> src . val ;case 0x80 ... 0x8f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;break ;","case 0x40 ... 0x4f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) rc = ctxt -> dst . val = ctxt -> src . val ;case 0x80 ... 0x8f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) jmp_rel ( ctxt , ctxt -> src . val ) ;break ;",923
113,"x < ( ( ssize_t ) image -> columns - 7 ) ;SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ;",x < ( ( ssize_t ) image -> columns - 3 ) ;p ++ ;,924
114,for ( x = 0 ;x += 4 )  {,for ( x = 0 ;x += 4 ) {,924
115,"p ++ ;q ++ ;}if ( ( image -> columns % 4 ) != 0 ) {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ;SetPixelIndex ( indexes + x , index ) ;SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ;if ( ( image -> columns % 4 ) >= 1 )  {if ( ( image -> columns % 4 ) >= 2 )  {",p ++ ;}if ( ( image -> columns % 4 ) > 1 ) {if ( ( image -> columns % 4 ) >= 2 ) {,924
116,"skb = sock_alloc_send_skb ( sk ,  hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;","struct frag_hdr fhdr ;skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;",925
117,"skb -> csum = 0 ;}err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;if ( ! err ) {struct frag_hdr fhdr ;return 0 ;}kfree_skb ( skb ) ;return err ;","skb -> csum = 0 ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",925
118,PIXA * pixa ;L_REGPARAMS * rp ;,"PIXA * pixa , * pixa2 ;L_REGPARAMS * rp ;",926
119,"pixGammaTRCMasked ( pix2 , pix2 , pixim , 1.0 , 60 , 190 ) ;regTestWritePixAndCheck ( rp , pix2 , IFF_JFIF_JPEG ) ;pixaAddPix ( pixa , pix2 , L_INSERT ) ;pixDestroy ( & pixim ) ;startTimer ( ) ;pixim = pixCreate ( w , h , 1 ) ;pixRasterop ( pixim , XS , YS , WS , HS , PIX_SET , NULL , 0 , 0 ) ;pixGetBackgroundRGBMap ( pixs , pixim , NULL , SIZE_X , SIZE_Y , BINTHRESH , MINCOUNT , & pixmr , & pixmg , & pixmb ) ;fprintf ( stderr , ""Time<S2SV_blank>for<S2SV_blank>color<S2SV_blank>adaptmap<S2SV_blank>gen:<S2SV_blank>%7.3f\\\regTestWritePixAndCheck ( rp , pixmr , IFF_PNG ) ;regTestWritePixAndCheck ( rp , pixmg , IFF_PNG ) ;regTestWritePixAndCheck ( rp , pixmb , IFF_PNG ) ;pixaAddPix ( pixa , pixmr , L_INSERT ) ;pixaAddPix ( pixa , pixmg , L_INSERT ) ;pixaAddPix ( pixa , pixmb , L_INSERT ) ;startTimer ( ) ;pixmri = pixGetInvBackgroundMap ( pixmr , BGVAL , SMOOTH_X , SMOOTH_Y ) ;pixmgi = pixGetInvBackgroundMap ( pixmg , BGVAL , SMOOTH_X , SMOOTH_Y ) ;pixmbi = pixGetInvBackgroundMap ( pixmb , BGVAL , SMOOTH_X , SMOOTH_Y ) ;fprintf ( stderr , ""Time<S2SV_blank>for<S2SV_blank>color<S2SV_blank>inv<S2SV_blank>map<S2SV_blank>generation:<S2SV_blank>%7.3f\\\regTestWritePixAndCheck ( rp , pixmri , IFF_PNG ) ;regTestWritePixAndCheck ( rp , pixmgi , IFF_PNG ) ;regTestWritePixAndCheck ( rp , pixmbi , IFF_PNG ) ;pixaAddPix ( pixa , pixmri , L_INSERT ) ;pixaAddPix ( pixa , pixmgi , L_INSERT ) ;pixaAddPix ( pixa , pixmbi , L_INSERT ) ;startTimer ( ) ;pix1 = pixApplyInvBackgroundRGBMap ( pixs , pixmri , pixmgi , pixmbi , SIZE_X , SIZE_Y ) ;fprintf ( stderr , ""Time<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>color<S2SV_blank>inv<S2SV_blank>maps:<S2SV_blank>%7.3f\\\regTestWritePixAndCheck ( rp , pix1 , IFF_JFIF_JPEG ) ;pixaAddPix ( pixa , pix1 , L_INSERT ) ;pix2 = pixGammaTRCMasked ( NULL , pix1 , pixim , 1.0 , 0 , 190 ) ;pixInvert ( pixim , pixim ) ;pixGammaTRCMasked ( pix2 , pix2 , pixim , 1.0 , 60 , 190 ) ;regTestWritePixAndCheck ( rp , pix2 , IFF_JFIF_JPEG ) ;pixaAddPix ( pixa , pix2 , L_INSERT ) ;pixDestroy ( & pixim ) ;startTimer ( ) ;pixim = pixCreate ( w , h , 1 ) ;pixRasterop ( pixim , XS , YS , WS , HS , PIX_SET , NULL , 0 , 0 ) ;pix1 = pixBackgroundNorm ( pixs , pixim , NULL , 5 , 10 , BINTHRESH , 20 , BGVAL , SMOOTH_X , SMOOTH_Y ) ;","pixa2 = pixaCreate ( 3 ) ;pix1 = pixRead ( ""weasel8.png"" ) ;pixGammaTRC ( pix1 , pix1 , 1.0 , 0 , 270 ) ;pixaAddPix ( pixa2 , pix1 , L_COPY ) ;pixGetDimensions ( pix1 , & w , & h , NULL ) ;pixRasterop ( pix1 , 0 , 0 , 5 , h , PIX_SET , NULL , 0 , 0 ) ;pixRasterop ( pix1 , 20 , BGVAL , SMOOTH_X , SMOOTH_Y ) ;",926
120,"pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ;pixWrite ( ""/tmp/lept/adapt/results.jpg"" , pix1 , IFF_JFIF_JPEG ) ;pixDisplayWithTitle ( pix1 , 100 , 0 , NULL , rp -> display ) ;pixDestroy ( & pix1 ) ;pixaDestroy ( & pixa ) ;","pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ;pixWrite ( ""/tmp/lept/adapt/results.jpg"" , pix1 , IFF_JFIF_JPEG ) ;pixDisplayWithTitle ( pix1 , 100 , 0 , NULL , rp -> display ) ;pixaDestroy ( & pixa2 ) ;pixDestroy ( & pix2 ) ;pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ;pixWrite ( ""/tmp/lept/adapt/results.jpg"" , pix1 , IFF_JFIF_JPEG ) ;pixDisplayWithTitle ( pix1 , 50 , 0 , NULL , rp -> display ) ;pixDestroy ( & pix1 ) ;pixaDestroy ( & pixa ) ;",926
121,"strncpy ( str , ""?["" , len ) ;itostr ( token , & str [ 2 ] , 10 ) ;strncat ( str , ""]"" , len ) ;","espruino_snprintf ( str , len , ""?[%d]"" , token ) ;",927
122,"static void count_segs ( VP9_COMP * cpi , const TileInfo * const tile ,   MODE_INFO * * mi_8x8 ,  int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int bw , int bh , int mi_row , int mi_col ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;xd -> mi = mi_8x8 ;segment_id = xd -> mi [ 0 ] -> mbmi . segment_id ;const BLOCK_SIZE bsize = mi_8x8 [ 0 ] -> mbmi . sb_type ;const int pred_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map ,  bsize , mi_row , mi_col ) ;","static void count_segs ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * tile , MODE_INFO * * mi_8x8 , int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int bw , int bh , int mi_row , int mi_col ) {xd -> mi = mi_8x8 ;segment_id = xd -> mi [ 0 ] -> mbmi . segment_id ;const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;const int pred_segment_id = get_segment_id ( cm , cm -> last_frame_seg_map , bsize , mi_row , mi_col ) ;",928
123,if ( dst == NULL || src == NULL ) return ERROR ;if ( dst -> entry_capacity < src -> entry_count + dst -> entry_count ) return ERROR ;,if ( dst == NULL || src == NULL ) return ERROR ;if ( src -> entry_count + dst -> entry_count < src -> entry_count ) return ERROR ;if ( src -> data_count + dst -> data_count < src -> data_count ) return ERROR ;if ( dst -> entry_capacity < src -> entry_count + dst -> entry_count ) return ERROR ;,929
124,"cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) :  jas_stream_tmpfile ( ) ;","cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) : jas_stream_tmpfile ( ) ;",930
125,return - EINVAL ;},dev_kfree_skb ( skb ) ;return - EINVAL ;},931
126,malloc_called += 1 ;return malloc ( size ) ;,malloc_called = 1 ;return malloc ( size ) ;,932
127,"StringBuffer_append ( res -> outputbuffer , ""%s"" , buf ) ;}","escapeHTML ( res -> outputbuffer , buf ) ;}",933
128,if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 &&  rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) {,if ( * rsize >= 62 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) {,934
129,if ( index > MAX_SUPPORTED_TV_TIMING )  return false ;,if ( index >= MAX_SUPPORTED_TV_TIMING ) return false ;,935
130,if ( index == 1 ) {mode -> crtc_htotal -= 1 ;mode -> crtc_vtotal -= 1 ;}break ;case 2 : tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ;if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 )  return false ;,if ( index >= MAX_SUPPORTED_TV_TIMING_V1_2 ) return false ;,935
131,NEED_IP ( 1 ) ;}copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS )  if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) {const unsigned char * ie = ip + t ;,"NEED_IP ( 1 , 0 ) ;}copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( t , 15 ) && HAVE_OP ( t , 15 ) ) ) {const unsigned char * ie = ip + t ;",936
132,NEED_OP ( t ) ;NEED_IP ( t + 3 ) ;do {,"NEED_OP ( t , 0 ) ;NEED_IP ( t , 3 ) ;do {",936
133,NEED_OP ( 2 ) ;op [ 0 ] = m_pos [ 0 ] ;,"NEED_OP ( 2 , 0 ) ;op [ 0 ] = m_pos [ 0 ] ;",936
134,NEED_IP ( 1 ) ;}NEED_IP ( 2 ) ;},"NEED_IP ( 1 , 0 ) ;}NEED_IP ( 2 , 0 ) ;}",936
135,NEED_IP ( 1 ) ;}NEED_IP ( 2 ) ;},"NEED_IP ( 1 , 0 ) ;}NEED_IP ( 2 , 0 ) ;}",936
136,if ( likely ( HAVE_OP ( t + 15 ) ) ) {do {,"if ( likely ( HAVE_OP ( t , 15 ) ) ) {do {",936
137,if ( HAVE_IP ( 6 ) ) {state = next ;,"if ( HAVE_IP ( 6 , 0 ) ) {state = next ;",936
138,NEED_OP ( t ) ;do {,"NEED_OP ( t , 0 ) ;do {",936
139,NEED_OP ( t ) ;op [ 0 ] = m_pos [ 0 ] ;,"NEED_OP ( t , 0 ) ;op [ 0 ] = m_pos [ 0 ] ;",936
140,"# if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS )  if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) {COPY4 ( op , ip ) ;NEED_IP ( t + 3 ) ;NEED_OP ( t ) ;while ( t > 0 ) {","# if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( 6 , 0 ) && HAVE_OP ( 4 , 0 ) ) ) {COPY4 ( op , ip ) ;NEED_IP ( t , 3 ) ;NEED_OP ( t , 0 ) ;while ( t > 0 ) {",936
141,"boolean_t owner = B_FALSE ;boolean_t groupmbr = B_FALSE ;uid_t uid = crgetuid ( cr ) ;mutex_enter ( & zdp -> z_acl_lock ) ;if ( FUID_INDEX ( zdp -> z_uid ) != 0 || FUID_INDEX ( zdp -> z_gid ) != 0 ) {goto out_slow ;}if ( uid == zdp -> z_uid ) {owner = B_TRUE ;if ( zdp -> z_mode & S_IXUSR ) {goto out ;}else {goto out_slow ;}}if ( groupmember ( zdp -> z_gid , cr ) ) {groupmbr = B_TRUE ;if ( zdp -> z_mode & S_IXGRP ) {goto out ;}else {goto out_slow ;}}if ( ! owner && ! groupmbr ) {if ( zdp -> z_mode & S_IXOTH ) {goto out ;}}out : mutex_exit ( & zdp -> z_acl_lock ) ;return ( 0 ) ;out_slow : mutex_exit ( & zdp -> z_acl_lock ) ;","
",937
142,"if ( ! n || ! buf || ! buf_size ) {o2 = 6 + n -> offset ;if ( ( o2 + 10 < o2 ) || ( o2 + 10 < 10 ) || ( o2 + 10 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;return ;}if ( buf [ o2 + 6 ] == 1 ) n -> order = EXIF_BYTE_ORDER_INTEL ;else if ( buf [ o2 + 6 + 1 ] == 1 ) n -> order = EXIF_BYTE_ORDER_MOTOROLA ;o2 += 8 ;c = exif_get_short ( buf + o2 , n -> order ) ;if ( ( ! ( c & 0xFF ) ) && ( c > 0x500 ) ) {if ( n -> order == EXIF_BYTE_ORDER_INTEL ) {n -> order = EXIF_BYTE_ORDER_MOTOROLA ;}else {n -> order = EXIF_BYTE_ORDER_INTEL ;}}break ;case olympusV2 : datao = o2 ;o2 += 8 ;if ( ( o2 + 4 < o2 ) || ( o2 + 4 < 4 ) || ( o2 + 4 > buf_size ) ) return ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""Parsing<S2SV_blank>Olympus<S2SV_blank>maker<S2SV_blank>note<S2SV_blank>v2<S2SV_blank>(0x%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] ) ;","if ( CHECKOVERFLOW ( o2 , buf_size , 10 ) ) {if ( CHECKOVERFLOW ( o2 , buf_size , 4 ) ) return ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""Parsing<S2SV_blank>Olympus<S2SV_blank>maker<S2SV_blank>note<S2SV_blank>v2<S2SV_blank>(0x%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] ) ;",938
143,"if ( ( ! ( c & 0xFF ) ) && ( c > 0x500 ) ) {if ( n -> order == EXIF_BYTE_ORDER_INTEL ) {n -> order = EXIF_BYTE_ORDER_MOTOROLA ;}else {n -> order = EXIF_BYTE_ORDER_INTEL ;}}break ;case nikonV2 : o2 += 6 ;if ( ( o2 + 12 < o2 ) || ( o2 + 12 < 12 ) || ( o2 + 12 > buf_size ) ) return ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""Parsing<S2SV_blank>Nikon<S2SV_blank>maker<S2SV_blank>note<S2SV_blank>v2<S2SV_blank>(0x%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>"" ""%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] , buf [ o2 + 4 ] , buf [ o2 + 5 ] , buf [ o2 + 6 ] , buf [ o2 + 7 ] ) ;","if ( CHECKOVERFLOW ( o2 , buf_size , 12 ) ) return ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""Parsing<S2SV_blank>Nikon<S2SV_blank>maker<S2SV_blank>note<S2SV_blank>v2<S2SV_blank>(0x%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>"" ""%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] , buf [ o2 + 4 ] , buf [ o2 + 5 ] , buf [ o2 + 6 ] , buf [ o2 + 7 ] ) ;",938
144,"if ( ( o2 + 2 < o2 ) || ( o2 + 2 < 2 ) || ( o2 + 2 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;if ( ! n -> entries ) {EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteOlympus"" , sizeof ( MnoteOlympusEntry ) * c ) ;return ;}tcount = 0 ;for ( i = c , o = o2 ;i ;-- i , o += 12 ) {size_t s ;if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA ,  ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\\\'%s\\\')..."" , n -> entries [ tcount ] . tag , mnote_olympus_tag_get_name ( n -> entries [ tcount ] . tag ) ) ;# ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG  if ( dataofs + s > buf_size && n -> version == sanyoV1 ) {dataofs -= datao + 6 ;if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) ||  ( dataofs + s > buf_size ) ) {","if ( CHECKOVERFLOW ( o2 , buf_size , 2 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . tag , mnote_olympus_tag_get_name ( n -> entries [ tcount ] . tag ) ) ;if ( exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) ;continue ;}# ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG if ( dataofs + s > buf_size && n -> version == sanyoV1 ) {dataofs -= datao + 6 ;if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || ( dataofs + s > buf_size ) ) {",938
145,"static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  {","static void record_and_restart ( struct perf_event * event , unsigned long val , struct pt_regs * regs ) {",939
146,"if ( perf_event_overflow ( event , nmi , & data , regs ) )  fsl_emb_pmu_stop ( event , 0 ) ;","if ( perf_event_overflow ( event , & data , regs ) ) fsl_emb_pmu_stop ( event , 0 ) ;",939
147,if ( stringset == ETH_SS_STATS )  return ARRAY_SIZE ( g_xgmac_stats_string ) ;,if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_xgmac_stats_string ) ;,940
148,"
",if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;},941
149,jumpstack [ stackidx ++ ] = e ;},jumpstack [ stackidx ++ ] = e ;},941
150,"}ret = pipe_set_size ( pipe , nr_pages ) ;","}else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) {ret = - EPERM ;goto out ;}ret = pipe_set_size ( pipe , nr_pages ) ;",942
151,"char sbuf [ 128 ] ;void * mbuf = NULL ;void * parg = ( void * ) arg ;long err = - EINVAL ;bool has_array_args ;size_t array_size = 0 ;void __user * user_ptr = NULL ;void * * kernel_ptr = NULL ;if ( _IOC_DIR ( cmd ) != _IOC_NONE ) {if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;}else {mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ;if ( NULL == mbuf ) return - ENOMEM ;parg = mbuf ;}err = - EFAULT ;if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) {unsigned long n = cmd_input_size ( cmd ) ;if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ;if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ;}else {memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ;}}err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ;if ( err < 0 ) goto out ;has_array_args = err ;if ( has_array_args ) {mbuf = kmalloc ( array_size , GFP_KERNEL ) ;err = - ENOMEM ;if ( NULL == mbuf ) goto out_array_args ;err = - EFAULT ;if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ;* kernel_ptr = mbuf ;}err = __video_do_ioctl ( file , cmd , parg ) ;if ( err == - ENOIOCTLCMD ) err = - EINVAL ;if ( has_array_args ) {* kernel_ptr = user_ptr ;if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ;goto out_array_args ;}if ( err < 0 ) goto out ;out_array_args : switch ( _IOC_DIR ( cmd ) ) {case _IOC_READ : case ( _IOC_WRITE | _IOC_READ ) : if ( copy_to_user ( ( void __user * ) arg , parg , _IOC_SIZE ( cmd ) ) ) err = - EFAULT ;break ;}out : kfree ( mbuf ) ;return err ;","return video_usercopy ( file , cmd , arg , __video_do_ioctl ) ;",943
152,"0xD5 , 0x75 , 0xF1 , 0x23 , 0xC1 , 0x81 , 0x4B , 0x44 , 0x23 , 0xBE ,  0x97 , 0x81 , 0x7A , 0xDA , 0x97 , 0x1F , 0x1F , 0x0D , 0xD5 , 0xEC ,  0xC5 , 0x5F , 0x86 , 0x42 , 0x7F , 0x38 , 0xA3 , 0x95 , 0xEE , 0xA0 ,  0x52 , 0x2C , 0xB7 , 0x20 , 0x29 , 0xC1 , 0xC7 , 0xE6 , 0x8E , 0x6F , 0xE5 , 0xC1 , 0x0D , 0xDD , 0x8A , 0xEF , 0x8D , 0xE7 , 0xA8 , 0x63 , 0xB4 , 0xF7 , 0x58 , 0x32 , 0x0E , 0x24 , 0xAC , 0x30 , 0x94 , 0xF5 , 0xC7 , 0x02 , 0x81 , 0x1B , 0xC7 , 0x68 , 0xE5 , 0x71 , 0xD7 , 0x1E , 0x3D , 0xE4 , 0x2E , 0x2F , 0xC0 , 0x0A , 0xED , 0x34 , 0xAC , 0xC0 , 0x1F , 0x0A , 0x56 , 0xA4 , 0x12 , 0x02 , 0xFD , 0x68 , 0xD2 , 0x4D , 0x5E , 0x0A , 0x5D , 0x78 , 0xE3 , 0xA0 , 0x85 , 0x75 , 0xD2 , 0xA9 , 0xC1 , 0xF2 , 0xAD , 0x65 , 0x11 , 0xDE , 0xE8 , 0x05 , 0x68 , 0x36 , 0x4C , 0x92 , 0x99 , 0x21 , 0xB9 , 0x69 , 0xD0 , 0x6F , 0xD8 , 0xA3 , 0xEA , 0x35 , 0x13 , 0x93 , 0xDC , 0x1B , 0x13 , 0x16 , 0xB2 , 0x15 , 0x8E , 0x10 , 0x22 , 0xCE , 0x01 , 0x1F , 0x1C , 0x09 , 0x86 , 0xD5 , 0xE7 , 0xCB , 0xCF , 0xFA , 0xED , 0x2F , 0xE2 , 0x3A , 0x65 , 0x14 , 0xC9 , 0xFA , 0x70 , 0x99 , 0xF7 , 0xE0 , 0x30 , 0xBF , 0x7F , 0xEA , 0x84 , 0x14 , 0x8A , 0x51 , 0xC9 , 0xE9 , 0x85 , 0x73 , 0x7F , 0xA1 , 0xB0 , 0xC3 , 0x33 , 0x9A , 0xAB , 0x69 , 0x4E , 0x75 , 0xFB , 0x12 , 0xB0 , 0x9E , 0xB1 , 0xD9 , 0xD1 , 0xB9 , 0x32 , 0x1D , 0xC6 , 0xD9 , 0x2C , 0xAA , 0xB0 , 0xC5 , 0x3E , 0x69 , 0x56 , 0xA2 , 0xB3 , 0xA2 , 0x81 , 0xCA , 0x9D , 0x77 , 0xBB , 0x52 , 0x44 , 0xA2 , 0xED , 0xE0 , 0xF0 , 0x2A , 0x81 , 0x85 , 0x90 , 0xB6 , 0x04 , 0x60 , 0xEB , 0x09 , 0x72 , 0x08 , 0x44 , 0xAF , 0x28 , 0xF5 , 0x15 , 0x34 , 0x87 , 0x5C , 0x8A , 0xB4 , 0x5B , 0x15 , 0x6A , 0xAD , 0x27 , 0x4E , 0xA0 , 0xDE , 0x99 , 0x22 , 0xCF , 0xAB , 0x4C , 0xFD , 0x75 , 0x10 , 0x5D , 0xFF , 0xE8 , 0x81 , 0x50 , 0xC4 , 0xC0 , 0x4B }","0xCF , 0x9F , 0x3A , 0x9C , 0xC5 , 0xA5 , 0x89 , 0x27 , 0x6D , 0x2C , 0x2C , 0xF3 , 0xA6 , 0x00 , 0xD2 , 0x7C , 0xEA , 0xFA , 0xF2 , 0x43 , 0x4F , 0x49 , 0x0A , 0xFC , 0xA6 , 0xE7 , 0x75 , 0xCA , 0x07 , 0xDC , 0xA5 , 0xF2 , 0x83 , 0x4E , 0x5A , 0xA0 , 0xA0 , 0xF5 , 0x9C , 0xFD , 0x02 , 0xE6 , 0x9E , 0xFC , 0x01 , 0x59 , 0xD7 , 0xB6 , 0xC1 , 0x4E , 0xC0 , 0xB6 , 0x71 , 0x49 , 0xF0 , 0xC7 , 0xD5 , 0x2F , 0x8D , 0xDF , 0xD3 , 0xF1 , 0x82 , 0x82 , 0x23 , 0x33 , 0x13 , 0x93 , 0xEB , 0x50 , 0x29 , 0xFD , 0x1B , 0x5A , 0x2F , 0xD5 , 0x08 , 0x99 , 0x64 , 0xE9 , 0x7B , 0x1A , 0xDD , 0x68 , 0x16 , 0x08 , 0xD0 , 0x13 , 0x82 , 0xB6 , 0x86 , 0x62 , 0x76 , 0xAA , 0x16 , 0x14 , 0xCC , 0x86 , 0x72 , 0x26 , 0x45 , 0x8E , 0x2A , 0x82 , 0x5B , 0x6F , 0xC1 , 0xDF , 0xAA , 0x18 , 0x43 , 0xB8 , 0xAD , 0x84 , 0x52 , 0xF2 , 0xD9 , 0x9C , 0xC0 , 0x47 , 0x52 , 0x1B , 0x8E , 0x42 , 0xC4 , 0xD3 , 0x61 , 0x7B , 0x65 , 0xA7 , 0x69 , 0x03 , 0xB5 , 0xD4 , 0x6C , 0x83 , 0x6A , 0x46 , 0x73 , 0xAF , 0x76 , 0x77 , 0x70 , 0xC2 , 0xD0 , 0x74 , 0xFE , 0x78 , 0xF5 , 0x75 , 0x3B , 0xCE , 0xE2 , 0xB6 , 0xA0 , 0x25 , 0xE9 , 0xE8 , 0x4B , 0xA2 , 0xF1 , 0x20 , 0x88 , 0x13 , 0x07 , 0xED , 0x66 , 0xBC , 0x46 , 0xA1 , 0xB3 , 0x44 , 0xAF , 0x2C , 0xED , 0x73 , 0x75 , 0x3D , 0x14 , 0x6E , 0x43 , 0x92 , 0x40 , 0x99 , 0xB0 , 0xD1 , 0xBF , 0x2C , 0x4D , 0x0F , 0x2A , 0x63 , 0xF4 , 0x85 , 0x7B , 0x1B , 0x0E , 0x48 , 0x5A , 0x06 , 0x02 , 0xA6 , 0x3D , 0x9E , 0x78 , 0x05 , 0xA8 , 0x7C , 0xAD , 0x54 , 0x49 , 0xDE , 0x7A , 0xE6 , 0x36 , 0x5C , 0x50 , 0xFC , 0x09 , 0x81 , 0x9E , 0x83 , 0x53 , 0x8C , 0x42 , 0x7F , 0x38 , 0xA3 , 0x95 , 0xEE , 0xA0 , 0x52 , 0x2C , 0xB7 , 0x20 , 0x29 , 0xC1 , 0xC7 , 0xE6 , 0x8E , 0x6F , 0xE5 , 0xC1 , 0x0D , 0xDD , 0x8A , 0xEF , 0x8D , 0xE7 , 0xA8 , 0x63 , 0xB4 , 0xF7 , 0x58 , 0x32 , 0x0E , 0x24 , 0xAC , 0x30 , 0x94 , 0xF5 , 0xC7 , 0x02 , 0x81 , 0x1B , 0xC7 , 0x68 , 0xE5 , 0x71 , 0xD7 , 0x1E , 0x3D , 0xE4 , 0x2E , 0x2F , 0xC0 , 0x0A , 0xED , 0x34 , 0xAC , 0xC0 , 0x1F , 0x0A , 0x56 , 0xA4 , 0x12 , 0x02 , 0xFD , 0x68 , 0xD2 , 0x4D , 0x5E , 0x0A , 0x5D , 0x78 , 0xE3 , 0xA0 , 0x85 , 0x75 , 0xD2 , 0xA9 , 0xC1 , 0xF2 , 0xAD , 0x65 , 0x11 , 0xDE , 0xE8 , 0x05 , 0x68 , 0x36 , 0x4C , 0x92 , 0x99 , 0x21 , 0xB9 , 0x69 , 0xD0 , 0x6F , 0xD8 , 0xA3 , 0xEA , 0x35 , 0x13 , 0x93 , 0xDC , 0x1B , 0x13 , 0x16 , 0xB2 , 0x15 , 0x8E , 0x10 , 0x22 , 0xCE , 0x01 , 0x1F , 0x1C , 0x09 , 0x86 , 0xD5 , 0xE7 , 0xCB , 0xCF , 0xFA , 0xED , 0x2F , 0xE2 , 0x3A , 0x65 , 0x14 , 0xC9 , 0xFA , 0x70 , 0x99 , 0xF7 , 0xE0 , 0x30 , 0xBF , 0x7F , 0xEA , 0x84 , 0x14 , 0x8A , 0x51 , 0xC9 , 0xE9 , 0x85 , 0x73 , 0x7F , 0xA1 , 0xB0 , 0xC3 , 0x33 , 0x9A , 0xAB , 0x69 , 0x4E , 0x75 , 0xFB , 0x12 , 0xB0 , 0x9E , 0xB1 , 0xD9 , 0xD1 , 0xB9 , 0x32 , 0x1D , 0xC6 , 0xD9 , 0x2C , 0xAA , 0xB0 , 0xC5 , 0x3E , 0x69 , 0x56 , 0xA2 , 0xB3 , 0xA2 , 0x81 , 0xCA , 0x9D , 0x77 , 0xBB , 0x52 , 0x44 , 0xA2 , 0xED , 0xE0 , 0xF0 , 0x2A , 0x81 , 0x85 , 0x90 , 0xB6 , 0x04 , 0x60 , 0xEB , 0x09 , 0x72 , 0x08 , 0x44 , 0xAF , 0x28 , 0xF5 , 0x15 , 0x34 , 0x87 , 0x5C , 0x8A , 0xB4 , 0x5B , 0x15 , 0x6A , 0xAD , 0x27 , 0x4E , 0xA0 , 0xDE , 0x99 , 0x22 , 0xCF , 0xAB , 0x4C , 0xFD , 0x75 , 0x10 , 0x5D , 0xFF , 0xE8 , 0x81 , 0x50 , 0xC4 , 0xC0 , 0x4B }",944
153,"static char * print_string_ptr ( const char * str )  {char * ptr2 , * out ;int len = 0 ;unsigned char token ;if ( ! str )  return cJSON_strdup ( """" ) ;ptr = str ;if ( strchr ( ""\\\\""\\\\\\\\\\\\b\\\\f\\\else if ( token < 32 ) len += 5 ;++ ptr ;}if ( ! ( out = ( char * ) cJSON_malloc ( len + 3 ) ) )  return 0 ;","static char * print_string_ptr ( const char * str , printbuffer * p ) {char * ptr2 , * out ;int len = 0 ;unsigned char token ;if ( ! str ) {if ( p ) out = ensure ( p , 3 ) ;else out = ( char * ) cJSON_malloc ( 3 ) ;if ( ! out ) return 0 ;strcpy ( out , ""\\\\""\\\\"""" ) ;return out ;}for ( ptr = str ;* ptr ;ptr ++ ) flag |= ( ( * ptr > 0 && * ptr < 32 ) || ( * ptr == \\\'\\\\""\\\' ) || ( * ptr == \'\\\\\\\\\' ) ) ? 1 : 0 ;if ( ! flag ) {len = ptr - str ;if ( p ) out = ensure ( p , len + 3 ) ;else out = ( char * ) cJSON_malloc ( len + 3 ) ;if ( ! out ) return 0 ;ptr2 = out ;* ptr2 ++ = \\\'\\\\""\\\' ;strcpy ( ptr2 , str ) ;ptr2 [ len ] = \\\'\\\\""\\\' ;ptr2 [ len + 1 ] = 0 ;return out ;}ptr = str ;+ ptr ;if ( strchr ( ""\\\\""\\\\\\\\\\\\b\\\\f\\\else if ( token < 32 ) len += 5 ;ptr ++ ;}if ( p ) out = ensure ( p , len + 3 ) ) ) return 0 ;",945
154,break ;},"break ;}* ptr2 ++ = \\\'\\\\""\\\' ;",945
155,"while ( impeg2d_bit_stream_nxt ( ps_stream , MB_STUFFING_CODE_LEN ) == MB_STUFFING_CODE )  impeg2d_bit_stream_flush ( ps_stream , MB_STUFFING_CODE_LEN ) ;","while ( impeg2d_bit_stream_nxt ( ps_stream , MB_STUFFING_CODE_LEN ) == MB_STUFFING_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) impeg2d_bit_stream_flush ( ps_stream , MB_STUFFING_CODE_LEN ) ;",946
156,"alloc_limit_assert ( ""checked_xcalloc"" , ( num * size ) ) ;return xcalloc ( num , size ) ;","size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;alloc_limit_assert ( ""checked_xcalloc"" , ( res ) ) ;return xcalloc ( num , size ) ;",947
157,"char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ;int dlen = mutt_b64_decode ( out , it ) ;if ( dlen == - 1 ) {","const int olen = 3 * len / 4 + 1 ;char * out = mutt_mem_malloc ( olen ) ;int dlen = mutt_b64_decode ( out , it , olen ) ;if ( dlen == - 1 ) {",948
158,if ( ! sock || ( count && ! buf ) )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;,if ( ! sock || ( count && ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;,949
159,"if ( ! list . name || list . noselect ) return ;imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ;url . path = errstr + 1 ;","if ( ! list . name , true || list . noselect ) return ;imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ;url . path = errstr + 1 ;",950
160,mmu_notifier_mm_init ( mm ) ;init_tlb_flush_pending ( mm ) ;,"RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;mmu_notifier_mm_init ( mm ) ;init_tlb_flush_pending ( mm ) ;",951
161,"const int qzbin_factor = q == 0 ? 64 : ( vp9_dc_quant ( q , 0 ) < 148 ? 84 : 80 ) ;const int qrounding_factor = q == 0 ? 64 : 48 ;quant = i == 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q )   : vp9_ac_quant ( q , 0 ) ;invert_quant ( & quants -> y_quant [ q ] [ i ] , & quants -> y_quant_shift [ q ] [ i ] , quant ) ;quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;cm -> y_dequant [ q ] [ i ] = quant ;quant = i == 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q )   : vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ;invert_quant ( & quants -> uv_quant [ q ] [ i ] , & quants -> uv_quant_shift [ q ] [ i ] , quant ) ;quants -> uv_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;quants -> uv_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;cm -> uv_dequant [ q ] [ i ] = quant ;# if CONFIG_ALPHA quant = i == 0 ? vp9_dc_quant ( q , cm -> a_dc_delta_q ) : vp9_ac_quant ( q , cm -> a_ac_delta_q ) ;invert_quant ( & quants -> a_quant [ q ] [ i ] , & quants -> a_quant_shift [ q ] [ i ] , quant ) ;quants -> a_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;quants -> a_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;cm -> a_dequant [ q ] [ i ] = quant ;# endif }for ( i = 2 ;i < 8 ;i ++ ) {quants -> y_quant [ q ] [ i ] = quants -> y_quant [ q ] [ 1 ] ;quants -> y_quant_shift [ q ] [ i ] = quants -> y_quant_shift [ q ] [ 1 ] ;quants -> y_zbin [ q ] [ i ] = quants -> y_zbin [ q ] [ 1 ] ;quants -> y_round [ q ] [ i ] = quants -> y_round [ q ] [ 1 ] ;cm -> y_dequant [ q ] [ i ] = cm -> y_dequant [ q ] [ 1 ] ;quants -> uv_quant [ q ] [ i ] = quants -> uv_quant [ q ] [ 1 ] ;quants -> uv_quant_shift [ q ] [ i ] = quants -> uv_quant_shift [ q ] [ 1 ] ;quants -> uv_zbin [ q ] [ i ] = quants -> uv_zbin [ q ] [ 1 ] ;cm -> uv_dequant [ q ] [ i ] = cm -> uv_dequant [ q ] [ 1 ] ;# if CONFIG_ALPHA  quants -> a_quant [ q ] [ i ] = quants -> a_quant [ q ] [ 1 ] ;quants -> a_round [ q ] [ i ] = quants -> a_round [ q ] [ 1 ] ;cm -> a_dequant [ q ] [ i ] = cm -> a_dequant [ q ] [ 1 ] ;# endif }","const int qzbin_factor = get_qzbin_factor ( q , cm -> bit_depth ) ;const int qrounding_factor = q == 0 ? 64 : 48 ;int qrounding_factor_fp = i == 0 ? 48 : 42 ;if ( q == 0 ) qrounding_factor_fp = 64 ;quant = i == 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q , cm -> bit_depth ) : vp9_ac_quant ( q , 0 , cm -> bit_depth ) ;invert_quant ( & quants -> y_quant [ q ] [ i ] , & quants -> y_quant_shift [ q ] [ i ] , quant ) ;quants -> y_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ;quants -> y_round_fp [ q ] [ i ] = ( qrounding_factor_fp * quant ) >> 7 ;cm -> y_dequant [ q ] [ i ] = quant ;quant = i == 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q ) : vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ;invert_quant ( & quants -> uv_quant [ q ] [ i ] , & quants -> uv_quant_shift [ q ] [ i ] , quant ) ;quants -> uv_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;quants -> uv_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;cpi -> y_dequant [ q ] [ i ] = cm -> y_dequant [ q ] [ 1 ] ;quants -> uv_quant [ q ] [ i ] = quants -> uv_quant [ q ] [ 1 ] ;quants -> uv_quant_shift [ q ] [ i ] = quants -> uv_quant_shift [ q ] [ 1 ] ;quants -> uv_zbin [ q ] [ i ] = quants -> uv_zbin [ q ] [ 1 ] ;cm -> uv_dequant [ q ] [ i ] = cm -> uv_dequant [ q ] [ 1 ] ;# if CONFIG_ALPHA quants -> a_quant [ q ] [ i ] = quants -> a_quant [ q ] [ 1 ] ;quants -> uv_round [ q ] [ i ] = quants -> a_round [ q ] [ 1 ] ;}",952
162,"static inline int  addrs_in_same_network_family ( const tor_addr_t * a1 , const tor_addr_t * a2 ) {","int addrs_in_same_network_family ( const tor_addr_t * a1 , const tor_addr_t * a2 ) {",953
163,"char buffer [ 4096 ] ;char buffer2 [ 4096 ] ;char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;}else {memcpy ( buf , name , name_len ) ;buf [ name_len ] = 0 ;}encrypt_return_plain :  if ( buf != buffer ) {efree ( buf ) ;}","char * buf , * buf2 , * d , * d_url ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;encrypt_return_plain : efree ( buf ) ;",954
164,"if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {memcpy ( buf2 , value , value_len ) ;buf2 [ value_len ] = 0 ;}else {}if ( buf != buffer ) {efree ( buf ) ;}if ( buf2 != buffer2 ) {}",efree ( buf ) ;,954
165,"msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ;if ( msg -> fp ) return 0 ;","msg -> fp = mutt_bcache_get ( pop_data -> bcache , cache_id ( h -> data ) ) ;if ( msg -> fp ) return 0 ;",955
166,"msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ;if ( ! msg -> fp ) {","msg -> fp = mutt_bcache_put ( pop_data -> bcache , cache_id ( h -> data ) ) ;if ( ! msg -> fp ) {",955
167,"if ( bcache )  mutt_bcache_commit ( pop_data -> bcache , h -> data ) ;else {","if ( bcache ) mutt_bcache_commit ( pop_data -> bcache , cache_id ( h -> data ) ) ;else {",955
168,"ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ;len = ntohs ( a . h . len ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>method=%s"" , len - 4 ,  STR_OR_ID ( a . auth_method , v2_auth ) ) ) ;if ( 1 < ndo -> ndo_vflag && 4 < len ) {ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ;ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ;}else if ( ndo -> ndo_vflag && 4 < len ) {if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ;return ( const u_char * ) ext + len ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ;","ikev2_pay_print ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ;if ( 1 < ndo -> ndo_vflag && 4 < len ) {ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ;if ( len > 4 ) {if ( ndo -> ndo_vflag && 4 < len ) {if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ;}return ( const u_char * ) ext + len ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ;",956
169,"if ( ( s < entry -> components ) || ( s == 0 ) ) {if ( s > 4 ) doff = exif_get_long ( d + offset + 8 , data -> priv -> order ) ;else doff = offset + 8 ;if ( ( doff + s < doff ) || ( doff + s < s ) || ( doff + s > size ) ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" ,  ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , doff + s , size ) ;return 0 ;","if ( doff >= size ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Tag<S2SV_blank>starts<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , doff , size ) ;if ( s > size ) ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , doff + s , size ) ;return 0 ;",957
170,"p = strchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;p = strchr ( p + 1 , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;","p = osStrchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;p = osStrchr ( p + 1 , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;",958
171,const VP9_CONFIG * const oxcf = & cpi -> oxcf ;LAYER_CONTEXT * const lc = get_layer_context ( svc ) ;RATE_CONTROL * const lrc = & lc -> rc ;const int layer = svc -> temporal_layer_id ;lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ;lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;lrc -> max_frame_bandwidth = cpi -> rc . max_frame_bandwidth ;if ( layer == 0 ) {lc -> avg_frame_size = lrc -> av_per_frame_bandwidth ;}else {const double prev_layer_framerate =  oxcf -> framerate / oxcf -> ts_rate_decimator [ layer - 1 ] ;const int prev_layer_target_bandwidth =  oxcf -> ts_target_bitrate [ layer - 1 ] * 1000 ;lc -> avg_frame_size = ( int ) ( ( lc -> target_bandwidth - prev_layer_target_bandwidth ) / ( lc -> framerate - prev_layer_framerate ) ) ;,const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;LAYER_CONTEXT * const lc = get_layer_context ( cpi ) ;RATE_CONTROL * const lrc = & lc -> rc ;const int st_idx = svc -> spatial_layer_id * svc -> number_temporal_layers + svc -> temporal_layer_id ;const int tl = svc -> temporal_layer_id ;lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ;lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;lrc -> avg_frame_bandwidth = ( int ) ( ( lc -> target_bandwidth - prev_layer_target_bandwidth ) / ( lc -> framerate - prev_layer_framerate ) ) ;,959
172,mutex_lock ( & ses -> server -> srv_mutex ) ;if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) {rc = ses -> server -> ops -> generate_signingkey ( ses ) ;kfree ( ses -> auth_key . response ) ;goto keygen_exit ;},mutex_lock ( & ses -> server -> ops -> generate_signingkey ) {rc = ses -> server -> ops -> generate_signingkey ( ses ) ;kfree ( ses -> auth_key . response ) ;return rc ;},960
173,ses -> status = CifsGood ;ses -> need_reconnect = false ;spin_unlock ( & GlobalMid_Lock ) ;keygen_exit :  if ( ! ses -> server -> sign ) {kfree ( ses -> auth_key . response ) ;ses -> auth_key . response = NULL ;},"
",960
174,"if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",961
175,f = po -> fanout ;if ( ! f )  return ;,f = po -> fanout ;if ( f ) {,962
176,"mutex_unlock ( & fanout_mutex ) ;if ( po -> rollover ) kfree_rcu ( po -> rollover , rcu ) ;}","if ( po -> rollover ) kfree_rcu ( po -> rollover , rcu ) ;}mutex_unlock ( & fanout_mutex ) ;}",962
177,"if ( l == 0 )  memcpy ( own_dir , ""."" , 2 ) ;else {","if ( l == 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , ""/dev/null/"" , 2 ) ;# endif # else memcpy ( own_dir , ""."" , 2 ) ;else {",963
178,uint32_t id ;ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ;,"uint32_t id ;if ( size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;size_left = 0 ;continue ;}ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ;",964
179,"
","if ( ! d -> iccprofile_file ) {de_warn ( c , ""Bad<S2SV_blank>ICC<S2SV_blank>profile<S2SV_blank>segment"" ) ;return ;}",965
180,"dbuf_copy ( c -> infile , pos + 4 , data_len , d -> iccprofile_file ) ;}","dbuf_copy ( c -> infile , pos + 4 , data_len , d -> iccprofile_file ) ;}",965
181,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,966
182,"else {ret . code = kadm5_create_policy ( ( void * ) handle , & arg -> rec , arg -> mask ) ;if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ;log_done ( ""kadm5_create_policy"" , ( ( prime_arg == NULL ) ? ""(null)"" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ;if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ;}gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",966
183,"int size_chk , err ;if ( chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE ) {if ( mr -> flags & ~ ( XDP_UMEM_UNALIGNED_CHUNK_FLAG | XDP_UMEM_USES_NEED_WAKEUP ) ) return - EINVAL ;",int err ;if ( chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE ) {if ( headroom >= chunk_size - XDP_PACKET_HEADROOM ) return - EINVAL ;,967
184,size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM ;if ( size_chk < 0 ) return - EINVAL ;,size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM ;if ( size_chk < 0 ) return - EINVAL ;,967
185,"int rec ;int offs = 0 ;int rec_len = file -> record_length ;for ( rec = 1 ;rv = sc_read_record ( card , rec , * out + offs + 2 , rec_len , SC_RECORD_BY_REC_NR ) ;","size_t rec ;size_t offs = 0 ;int rec_len = file -> record_length ;for ( rec = 1 ;rv = sc_read_record ( card , rec , * out + offs + 2 , rec_len , SC_RECORD_BY_REC_NR ) ;",968
186,"
",if ( rec > file -> record_count ) {rv = 0 ;break ;},968
187,"vpx_memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;vpx_memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;if ( ! x -> mode_info_context -> mbmi . is_4x4 ) {","memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;if ( ! x -> mode_info_context -> mbmi . is_4x4 ) {",969
188,"static const char * parse_value ( cJSON * item , const char * value )  {","static const char * parse_value ( cJSON * item , const char * value , const char * * ep ) {",970
189,"if ( * value == \\\'\\\\""\\\' )  return parse_string ( item , value ) ;if ( * value == \'-\' || ( * value >= \'0\' && * value <= \'9\' ) )  return parse_number ( item , value ) ;if ( * value == \'[\' )  return parse_array ( item , value ) ;if ( * value == \'{\' )  return parse_object ( item , value ) ;ep = value ;","if ( * value == \\\'\\\\""\\\' ) {return parse_string ( item , value , ep ) ;}if ( * value == \'-\' || ( * value >= \'0\' && * value <= \'9\' ) ) {return parse_number ( item , value , ep ) ;}if ( * value == \'[\' ) {return parse_array ( item , value , ep ) ;}* ep = value ;",970
190,"if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) )  return - EFAULT ;","if ( validate_core_offset ( reg ) ) return - EINVAL ;if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) return - EFAULT ;",971
191,get_page ( * page ) ;out : ret = 0 ;,if ( unlikely ( ! try_get_page ( * page ) ) ) {ret = - ENOMEM ;goto unmap ;}out : ret = 0 ;,972
192,"ses = cifs_find_smb_ses ( server , volume_info -> username ) ;if ( ses ) {","ses = cifs_find_smb_ses ( server , volume_info ) ;if ( ses ) {",973
193,"dbg_hid ( ""%s,<S2SV_blank>size:%d\\\spin_lock_irqsave ( & djrcv_dev -> lock , flags ) ;","dbg_hid ( ""%s,<S2SV_blank>size:%d\\\if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) {dev_err ( & hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\\return false ;}spin_lock_irqsave ( & djrcv_dev -> lock , flags ) ;",974
194,"fprintf ( stderr , ""usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\\","fprintf ( stderr , ""usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\\",975
195,"int xml_init ( modsec_rec * msr , char * * error_msg ) {if ( error_msg == NULL ) return - 1 ;return 1 ;}","int xml_init ( modsec_rec * msr , char * * error_msg ) {xmlParserInputBufferCreateFilenameFunc entity ;if ( error_msg == NULL ) return - 1 ;if ( msr -> txcfg -> xml_external_entity == 0 ) {entity = xmlParserInputBufferCreateFilenameDefault ( xml_unload_external_entity ) ;}return 1 ;}",976
196,"char buf [ L_BUF_SIZE ] ;char emptystring [ ] = """" ;","char buf [ L_BUFSIZE ] ;char emptystring [ ] = """" ;",977
197,"snprintf ( buf , L_BUF_SIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ;sarrayAddString ( gplot -> datanames , buf , L_COPY ) ;","snprintf ( buf , L_BUFSIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ;sarrayAddString ( gplot -> datanames , buf , L_COPY ) ;",977
198,"snprintf ( buf , L_BUF_SIZE , ""%f<S2SV_blank>%f\\\sarrayAddString ( sa , buf , L_COPY ) ;","snprintf ( buf , L_BUFSIZE , ""%f<S2SV_blank>%f\\\sarrayAddString ( sa , buf , L_COPY ) ;",977
199,"isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;return hdrlen ;","isoclns_print ( ndo , p + 1 , length - 1 ) ;return hdrlen ;",978
200,dev_data = pci_get_drvdata ( dev ) ;if ( ! pci_is_enabled ( dev ) && is_enable_cmd ( value ) ) {,u16 val ;struct pci_cmd_info * cmd = data ;dev_data = pci_get_drvdata ( dev ) ;if ( ! pci_is_enabled ( dev ) && is_enable_cmd ( value ) ) {,979
201,"return pci_write_config_word ( dev , offset , value ) ;}","cmd -> val = value ;if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ;err = pci_read_config_word ( dev , offset , & val ) ;if ( err || val == value ) return err ;value &= PCI_COMMAND_GUEST ;value |= val & ~ PCI_COMMAND_GUEST ;return pci_write_config_word ( dev , offset , value ) ;}",979
202,if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 &&  rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) {if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 &&  rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) {,if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 91 && rdesc [ 83 ] == 0x26 && rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) {if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 51 && rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) {,980
203,"return ( ! _cups_strcasecmp ( con -> clientname , ""localhost"" ) || ! _cups_strcasecmp ( con -> clientname , ""localhost."" ) ||  # ifdef __linux  ! _cups_strcasecmp ( con -> clientname , ""localhost.localdomain"" ) || # endif ! strcmp ( con -> clientname , ""127.0.0.1"" ) || ! strcmp ( con -> clientname , ""[::1]"" ) ) ;","return ( ! _cups_strcasecmp ( con -> clientname , ""localhost"" ) || ! _cups_strcasecmp ( con -> clientname , ""localhost."" ) || ! strcmp ( con -> clientname , ""127.0.0.1"" ) || ! strcmp ( con -> clientname , ""[::1]"" ) ) ;",981
204,"if ( strcmp ( im -> mode , ""1"" ) == 0 && state -> xsize > state -> bytes * 8 ) {state -> errcode = IMAGING_CODEC_OVERRUN ;}state -> errcode = IMAGING_CODEC_OVERRUN ;ptr = buf ;for ( ;",if ( ( state -> xsize * state -> bits + 7 ) / 8 > state -> bytes * 8 ) {state -> errcode = IMAGING_CODEC_OVERRUN ;}state -> errcode = IMAGING_CODEC_OVERRUN ;ptr = buf ;for ( ;,982
205,"dname = malloc ( strlen ( name ) + 16 ) ;sprintf ( dname , ""%s-versions"" , name ) ;","dname = safe_calloc ( strlen ( name ) + 16 ) ;sprintf ( dname , ""%s-versions"" , name ) ;",983
206,"err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ;if ( err ) return err ;if ( is_pointer_value ( env , insn -> dst_reg ) ) {verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\\return - EACCES ;}err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;}else if ( opcode == BPF_MOV ) {if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( insn -> imm != 0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;}err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ;if ( err ) return err ;if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ;regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ;}else {if ( is_pointer_value ( env , insn -> src_reg ) ) {verbose ( env , ""R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\\return - EACCES ;}mark_reg_unknown ( env , regs , insn -> dst_reg ) ;regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ;__update_reg_bounds ( & regs [ insn -> dst_reg ] ) ;}__mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ;}","err = check_reg_arg ( env , insn -> dst_reg , insn -> imm ) ;__mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ;if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {__mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ;}",984
207,"strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry1 ) ) , PARAMS_LEN ) ;strncat ( params , ""/"" , PARAMS_LEN ) ;strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry2 ) ) , PARAMS_LEN ) ;gtkui_start_mitm ( ) ;","strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry1 ) ) , ETH_ASCII_ADDR_LEN ) ;strncat ( params , ""/"" , 1 ) ;strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry2 ) ) , IP6_ASCII_ADDR_LEN ) ;gtkui_start_mitm ( ) ;",985
208,"if ( poll ( & pfd , 1 , 500 ) == 0 )  return 0 ;if ( ( sent = send ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 )  {","if ( TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , 500 ) ) == 0 ) return 0 ;if ( ( sent = TEMP_FAILURE_RETRY ( send ( fd , p , len , MSG_NOSIGNAL ) ) ) == - 1 ) {",986
209,"bufobj = tok -> decoding_buffer ;Py_INCREF ( bufobj ) ;}else {bufobj = PyObject_CallObject ( tok -> decoding_readline , NULL ) ;if ( bufobj == NULL ) goto error ;","bufobj = _PyObject_CallNoArg ( tok -> decoding_readline , NULL ) ;if ( bufobj == NULL ) goto error ;",987
210,return - ENOMEM ;},q -> fq = NULL ;return - ENOMEM ;},988
211,"gdImagePtr im ;char * buffer ;size_t size ;size = read_test_file ( & buffer , ""heap_overflow.tga"" ) ;im = gdImageCreateFromTgaPtr ( size , ( void * ) buffer ) ;gdTestAssert ( im == NULL ) ;free ( buffer ) ;","check_file ( ""heap_overflow_1.tga"" ) ;check_file ( ""heap_overflow_2.tga"" ) ;",989
212,# ifndef PGEN  # if PY_MINOR_VERSION >= 4  fd = _Py_dup ( fd ) ;# endif  # else fd = dup ( fd ) ;,# ifndef PGEN fd = _Py_dup ( fd ) ;# endif # else fd = dup ( fd ) ;,990
213,"u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ;u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ;struct rd_dev_sg_table * sg_table ;struct page * pg ;struct scatterlist * sg ;","struct rd_dev_sg_table * sg_table ;u32 sg_tables , total_sg_needed ;u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ;int rc ;",991
214,"while ( total_sg_needed ) {sg_per_table = ( total_sg_needed > max_sg_per_table ) ? max_sg_per_table : total_sg_needed ;sg = kzalloc ( sg_per_table * sizeof ( struct scatterlist ) , GFP_KERNEL ) ;if ( ! sg ) {pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist<S2SV_blank>array"" ""<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev\\\return - ENOMEM ;}sg_init_table ( sg , sg_per_table ) ;sg_table [ i ] . sg_table = sg ;sg_table [ i ] . rd_sg_count = sg_per_table ;sg_table [ i ] . page_start_offset = page_offset ;sg_table [ i ++ ] . page_end_offset = ( page_offset + sg_per_table ) - 1 ;for ( j = 0 ;j < sg_per_table ;j ++ ) {pg = alloc_pages ( GFP_KERNEL , 0 ) ;if ( ! pg ) {pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist"" ""<S2SV_blank>pages<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev_sg_table\\\return - ENOMEM ;}sg_assign_page ( & sg [ j ] , pg ) ;sg [ j ] . length = PAGE_SIZE ;}page_offset += sg_per_table ;total_sg_needed -= sg_per_table ;}","rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ;if ( rc ) return rc ;",991
215,"char buf [ L_BUF_SIZE ] ;char * cmdstr , * plottitle , * dataname ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\\\'%s\\\'"" , gplot -> title ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\\\'%s\\\'"" , gplot -> xlabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\\\'%s\\\'"" , gplot -> ylabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE ,  ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;","char buf [ L_BUFSIZE ] ;char * cmdstr , * plottitle , * dataname ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>title<S2SV_blank>\\\'%s\\\'"" , gplot -> title ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\\\'%s\\\'"" , gplot -> xlabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\\\'%s\\\'"" , gplot -> ylabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;",992
216,"snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;if ( i == 0 )  snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else if ( i < nplots - 1 )  snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else  snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;","snprintf ( buf , L_BUFSIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;if ( i == 0 ) snprintf ( buf , L_BUFSIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else if ( i < nplots - 1 ) snprintf ( buf , L_BUFSIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else snprintf ( buf , L_BUFSIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;",992
217,"outpos +=  sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>w"" , w ) ;}","sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>w"" , w ) ;sendClean ( outputbuffer ) ;}",993
218,"if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream ,  p_manager ) ) {","if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size , & l_current_nb_bytes_written , p_stream , p_manager ) ) {",994
219,"}msg -> msg_namelen = sizeof ( * sax ) ;skb_free_datagram ( sk , skb ) ;release_sock ( sk ) ;","msg -> msg_namelen = sizeof ( * sax ) ;}skb_free_datagram ( sk , skb ) ;release_sock ( sk ) ;",995
220,else  follow_dotdot ( nd ) ;},else return follow_dotdot ( nd ) ;},996
221,list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;ptr = buf ;,"if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ;list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;ptr = buf ;",997
222,ld -> bytes_left = ld -> buffer_size - words * 4 ;if ( ld -> bytes_left >= 4 ) {,if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ;else ld -> bytes_left = ld -> buffer_size - words * 4 ;if ( ld -> bytes_left >= 4 ) {,998
223,"profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;if ( profile != ( StringInfo * ) NULL ) {","if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;if ( profile != ( StringInfo * ) NULL ) {",999
224,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,1000
225,"sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ;sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ;","memset ( & sync , 0 , sizeof ( sync ) ) ;sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ;sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ;",1001
226,"if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) ||  ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ;set_tls_desc ( target ,  GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ;","int i ;if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ;for ( i = 0 ;i < count / sizeof ( struct user_desc ) ;i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;set_tls_desc ( target , GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ;",1002
227,"char buf [ 32 ] , * e ;sprintf ( buf , fmt , w , n ) ;","char buf [ 50 ] , * e ;sprintf ( buf , fmt , w , n ) ;",1003
228,"# ifndef CONFIG_ZISOFS case SIG ( \'R\' , \'R\' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ;","# ifndef CONFIG_ZISOFS case SIG ( \'R\' , \'R\' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ;",1004
229,"case SIG ( \'E\' , \'R\' ) :  ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ;printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ;","case SIG ( \'E\' , \'R\' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ;printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ;",1004
230,"}skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & error ) ;if ( error < 0 ) goto end ;m -> msg_namelen = 0 ;if ( skb ) {",if ( skb ) {,1005
231,disk -> queue = NULL ;continue ;,put_disk ( disk ) ;disk -> queue = NULL ;continue ;,1006
232,"static int getnum ( lua_State * L , const char * * fmt , int df ) {if ( ! isdigit ( * * fmt ) ) return df ;if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - \'0\' ) ) )  luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>overflow"" ) ;","static int getnum ( const char * * fmt , int df ) {if ( ! isdigit ( * * fmt ) ) return df ;",1007
233,void vp9_choose_segmap_coding_method ( VP9_COMP * cpi ) {VP9_COMMON * const cm = & cpi -> common ;,"void vp9_choose_segmap_coding_method ( VP9_COMMON * cm , MACROBLOCKD * xd ) {",1008
234,"int t_unpred_seg_counts [ MAX_SEGMENTS ] = {0 };vp9_prob no_pred_tree [ SEG_TREE_PROBS ] ;vp9_prob t_pred_tree [ SEG_TREE_PROBS ] ;vp9_prob t_nopred_prob [ PREDICTION_PROBS ] ;const int mis = cm -> mi_stride ;MODE_INFO * * mi_ptr , * * mi ;vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ;vpx_memset ( seg -> pred_probs , 255 , sizeof ( seg -> pred_probs ) ) ;for ( tile_col = 0 ;tile_col < 1 << cm -> log2_tile_cols ;tile_col ++ ) {TileInfo tile ;vp9_tile_init ( & tile , cm , 0 , tile_col ) ;mi_ptr = cm -> mi_grid_visible + tile . mi_col_start ;for ( mi_row = 0 ;mi_row < cm -> mi_rows ;mi_row += 8 , mi_ptr += 8 * mis ) {mi = mi_ptr ;for ( mi_col = tile . mi_col_start ;mi_col < tile . mi_col_end ;mi_col += 8 , mi += 8 )  count_segs_sb ( cpi , & tile , mi , no_pred_segcounts ,  temporal_predictor_count , t_unpred_seg_counts , mi_row , mi_col , BLOCK_64X64 ) ;}calc_segtree_probs ( no_pred_segcounts , no_pred_tree ) ;no_pred_cost = cost_segmap ( no_pred_segcounts , no_pred_tree ) ;if ( ! frame_is_intra_only ( cm ) ) {calc_segtree_probs ( t_unpred_seg_counts , t_pred_tree ) ;t_pred_cost = cost_segmap ( t_unpred_seg_counts , t_pred_tree ) ;for ( i = 0 ;i < PREDICTION_PROBS ;i ++ ) {const int count0 = temporal_predictor_count [ i ] [ 0 ] ;const int count1 = temporal_predictor_count [ i ] [ 1 ] ;t_nopred_prob [ i ] = get_binary_prob ( count0 , count1 ) ;t_pred_cost += count0 * vp9_cost_zero ( t_nopred_prob [ i ] ) + count1 * vp9_cost_one ( t_nopred_prob [ i ] ) ;}}if ( t_pred_cost < no_pred_cost ) {seg -> temporal_update = 1 ;vpx_memcpy ( seg -> tree_probs , t_pred_tree , sizeof ( t_pred_tree ) ) ;vpx_memcpy ( seg -> pred_probs , t_nopred_prob , sizeof ( t_nopred_prob ) ) ;}vpx_memcpy ( seg -> tree_probs , no_pred_tree , sizeof ( no_pred_tree ) ) ;}","vpx_prob no_pred_tree [ SEG_TREE_PROBS ] ;vp9_prob t_pred_tree [ SEG_TREE_PROBS ] ;vp9_prob t_nopred_prob [ PREDICTION_PROBS ] ;memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ;vpx_memset ( seg -> pred_probs , 255 , sizeof ( seg -> pred_probs ) ) ;memset ( seg -> tree_probs , t_pred_tree , sizeof ( t_pred_tree ) ) ;vpx_memcpy ( seg -> pred_probs , t_nopred_prob , sizeof ( t_nopred_prob ) ) ;vpx_memcpy ( seg -> tree_probs , no_pred_tree , sizeof ( no_pred_tree ) ) ;}",1008
235,"g_return_if_fail ( RS_IS_FILTER ( filter ) ) ;GString * str = g_string_new ( ""digraph<S2SV_blank>G<S2SV_blank>{g_file_set_contents ( ""/tmp/rs-filter-graph"" , str -> str , str -> len , NULL ) ;if ( 0 != system ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>/tmp/rs-filter-graph.png<S2SV_blank></tmp/rs-filter-graph"" ) )  g_warning ( ""Calling<S2SV_blank>dot<S2SV_blank>failed"" ) ;if ( 0 != system ( ""gnome-open<S2SV_blank>/tmp/rs-filter-graph.png"" ) )   g_warning ( ""Calling<S2SV_blank>gnome-open<S2SV_blank>failed."" ) ;g_string_free ( str , TRUE ) ;","g_return_if_fail ( RS_IS_FILTER ( filter ) ) ;gchar * dot_filename ;gchar * png_filename ;gchar * command_line ;GString * str = g_string_new ( ""digraph<S2SV_blank>G<S2SV_blank>{dot_filename = g_strdup_printf ( ""/tmp/rs-filter-graph.%u"" , g_random_int ( ) ) ;png_filename = g_strdup_printf ( ""%s.%u.png"" , dot_filename , g_random_int ( ) ) ;g_file_set_contents ( dot_filename , str -> str , str -> len , NULL ) ;command_line = g_strdup_printf ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>%s<S2SV_blank><%s"" , png_filename , dot_filename ) ;if ( 0 != system ( command_line ) ) g_warning ( ""Calling<S2SV_blank>dot<S2SV_blank>failed"" ) ;g_free ( command_line ) ;command_line = g_strdup_printf ( ""gnome-open<S2SV_blank>%s"" , png_filename ) ;if ( 0 != system ( command_line ) ) g_warning ( ""Calling<S2SV_blank>gnome-open<S2SV_blank>failed."" ) ;g_free ( command_line ) ;g_free ( dot_filename ) ;g_free ( png_filename ) ;g_string_free ( str , TRUE ) ;",1009
236,"if ( ( fd = open ( clonedev , O_RDWR ) ) < 0 )  {if ( ( err = ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) < 0 )  {int flags = fcntl ( fd , F_GETFL , 0 ) ;fcntl ( fd , F_SETFL , flags | O_NONBLOCK ) ;return fd ;","if ( ( fd = TEMP_FAILURE_RETRY ( open ( clonedev , O_RDWR ) ) ) < 0 ) {if ( ( err = TEMP_FAILURE_RETRY ( ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) ) < 0 ) {int flags = TEMP_FAILURE_RETRY ( fcntl ( fd , F_GETFL , 0 ) ) ;TEMP_FAILURE_RETRY ( fcntl ( fd , F_SETFL , flags | O_NONBLOCK ) ) ;return fd ;",1010
237,# if CONFIG_MULTIPLE_ARF  if ( ! cpi -> multi_arf_enabled && cpi -> refresh_golden_frame && ! cpi -> refresh_alt_ref_frame ) {# else if ( cpi -> refresh_golden_frame && ! cpi -> refresh_alt_ref_frame && ! cpi -> use_svc ) {# endif return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> alt_fb_idx ) ;# if CONFIG_MULTIPLE_ARF   if ( cpi -> multi_arf_enabled ) {int sn = cpi -> sequence_number ;arf_idx = ( cpi -> frame_coding_order [ sn ] < 0 ) ?  cpi -> arf_buffer_idx [ sn + 1 ] : cpi -> arf_buffer_idx [ sn ] ;# endif  return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> gld_fb_idx ) | ( cpi -> refresh_alt_ref_frame << arf_idx ) ;,if ( vp9_preserve_existing_gf ( cpi ) ) {return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> alt_fb_idx ) ;# if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) {int sn = cpi -> sequence_number ;arf_idx = gf_group -> arf_update_idx [ gf_group -> index ] ;# endif return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> gld_fb_idx ) | ( cpi -> refresh_alt_ref_frame << arf_idx ) ;,1011
238,"static void test_show_object ( struct object * object ,  struct strbuf * path ,   const char * last , void * data )  {","static void test_show_object ( struct object * object , const char * last , void * data ) {",1012
239,"if ( copy_from_user ( & info , u_info , sizeof ( info ) ) )  return - EFAULT ;if ( idx == - 1 ) idx = info . entry_number ;","if ( copy_from_user ( & info , u_info , sizeof ( info ) ) ) return - EFAULT ;if ( ! tls_desc_okay ( & info ) ) return - EINVAL ;if ( idx == - 1 ) idx = info . entry_number ;",1013
240,"
",shp -> shm_cprid = task_tgid_vnr ( current ) ;shp -> shm_lprid = 0 ;shp -> shm_atim = shp -> shm_dtim = 0 ;shp -> shm_ctim = get_seconds ( ) ;shp -> shm_segsz = size ;shp -> shm_nattch = 0 ;shp -> shm_file = file ;shp -> shm_creator = current ;,1014
241,"id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ;if ( id < 0 ) {shp -> shm_cprid = task_tgid_vnr ( current ) ;shp -> shm_lprid = 0 ;shp -> shm_atim = shp -> shm_dtim = 0 ;shp -> shm_ctim = get_seconds ( ) ;shp -> shm_segsz = size ;shp -> shm_nattch = 0 ;shp -> shm_file = file ;shp -> shm_creator = current ;","id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ;if ( id < 0 ) {",1014
242,". daddr = ( param -> replyopts . srr ?   param -> replyopts . faddr : iph -> saddr ) ,  . saddr = saddr , . flowi4_tos = RT_TOS ( tos ) , . flowi4_proto = IPPROTO_ICMP , . fl4_icmp_type = type , . fl4_icmp_code = code , }",". daddr = ( param -> replyopts . opt . opt . srr ? param -> replyopts . opt . opt . faddr : iph -> saddr ) , . saddr = saddr , . flowi4_tos = RT_TOS ( tos ) , . flowi4_proto = IPPROTO_ICMP , . fl4_icmp_type = type , . fl4_icmp_code = code , }",1015
243,"if ( i_arg ) {retval = copy_strings_kernel ( 1 , & i_arg , bprm ) ;bprm -> interp = interp ;file = open_exec ( interp ) ;return search_binary_handler ( bprm ) ;}","retval = bprm_change_interp ( interp , bprm ) ;if ( retval < 0 ) return retval ;file = open_exec ( interp ) ;if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ;bprm -> file = file ;retval = prepare_binprm ( bprm ) ;bprm -> interp = interp ;file = open_exec ( interp ) ;return search_binary_handler ( bprm ) ;}",1016
244,"sprintf ( addr , ""%d.%d.%d.%d"" , a , b , c , d ) ;if ( ! inet_aton ( addr , & ( sin . sin_addr ) ) ) {","snprintf ( addr , sizeof ( addr ) , ""%d.%d.%d.%d"" , a , b , c , d ) ;if ( ! inet_aton ( addr , & ( sin . sin_addr ) ) ) {",1017
245,"int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  {","static int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) {",1018
246,"cmd = kmalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ;if ( ! cmd ) return - ENOMEM ;","cmd = kzalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ;if ( ! cmd ) return - ENOMEM ;",1019
247,"hash_param . data = 0 ;hash_param . len = 0 ;hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ;","hash_param . data = instance -> private_key ;hash_param . len = instance -> private_key_len ;hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ;",1020
248,"unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ;out : if ( sk == NULL ) atomic_long_dec ( & unix_nr_socks ) ;","init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ;unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ;out : if ( sk == NULL ) atomic_long_dec ( & unix_nr_socks ) ;",1021
249,"# ifdef __linux__   sun . sun_path [ 0 ] = '\\\\0' ;memcpy ( sun . sun_path + 1 , address , strlen ( address ) ) ;sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ;# else memcpy ( sun . sun_path , address , strlen ( address ) ) ;# endif client -> control = socket ( AF_UNIX , SOCK_STREAM , 0 ) ;","memcpy ( sun . sun_path [ 0 ] = '\\\\0' ;memcpy ( sun . sun_path , address , strlen ( address ) ) ;sun_len = sizeof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ;# else memcpy ( sun . sun_path , address , strlen ( address ) ) ;client -> control = socket ( AF_UNIX , SOCK_STREAM , 0 ) ;",1022
250,# ifndef NETSNMP_NO_WRITE_SUPPORT  case MODE_SET_RESERVE1 : switch ( table_info -> colnum ) {,# if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS case MODE_SET_RESERVE1 : switch ( table_info -> colnum ) {,1023
251,# ifndef NETSNMP_NO_WRITE_SUPPORT  if ( need_to_validate ) {,# if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS if ( need_to_validate ) {,1023
252,"static struct ip_options * ip_options_get_alloc ( const int optlen )  {return kzalloc ( sizeof ( struct ip_options ) + ( ( optlen + 3 ) & ~ 3 ) ,  GFP_KERNEL ) ;","static struct ip_options_rcu * ip_options_get_alloc ( const int optlen ) {return kzalloc ( sizeof ( struct ip_options_rcu ) + ( ( optlen + 3 ) & ~ 3 ) , GFP_KERNEL ) ;",1024
253,"
",if ( ! cursor ) goto gc_complete ;,1025
254,}slot = node -> parent_slot ;BUG_ON ( ! ptr ) ;node = assoc_array_ptr_to_node ( cursor ) ;,}slot = node -> parent_slot ;BUG_ON ( ! cursor ) ;node = assoc_array_ptr_to_node ( cursor ) ;,1025
255,local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ;for ( i = 0 ;,local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ;if ( args -> nr_local == 0 ) return - EINVAL ;for ( i = 0 ;,1026
256,"if ( ! ( plen <= * len ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\\assert ( plen <= * len ) ;* len = plen ;","if ( ! ( plen <= * len && plen > 0 ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\\assert ( plen <= * len ) ;* len = plen ;",1027
257,"return send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) == size_send ;}","return TEMP_FAILURE_RETRY ( send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) ) == size_send ;}",1028
258,"ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;","ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;",1029
259,"if ( ! capable ( CAP_NET_ADMIN ) )   return - EPERM ;if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) {if ( copy_from_user ( arg , user , get_arglen [ GET_CMDID ( cmd ) ] ) != 0 )  return - EFAULT ;","unsigned int copylen ;if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ;if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL ;if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) {copylen = get_arglen [ GET_CMDID ( cmd ) ] ;if ( copylen > 128 ) return - EINVAL ;if ( copy_from_user ( arg , user , copylen ) != 0 ) return - EFAULT ;",1030
260,if ( tgt_clobbers & ~ site_clobbers )  return len ;if ( len < 5 )  return len ;,"if ( len < 5 ) {# ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\\# endif return len ;}",1031
261,if ( o == NULL ) return ;s = o -> ptr ;,"if ( o == NULL || checkType ( c , o , OBJ_STREAM ) ) return ;s = o -> ptr ;",1032
262,"case LLDP_TLV_CHASSIS_ID : case LLDP_TLV_PORT_ID : CHECK_TLV_SIZE ( 2 , ""Port<S2SV_blank>Id"" ) ;tlv_subtype = PEEK_UINT8 ;if ( ( tlv_subtype == 0 ) || ( tlv_subtype > 7 ) ) {log_warnx ( ""lldp"" , ""unknown<S2SV_blank>subtype<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>id<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( ( b = ( char * ) calloc ( 1 , tlv_size - 1 ) ) == NULL ) {log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>id<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_BYTES ( b , tlv_size - 1 ) ;if ( tlv_type == LLDP_TLV_PORT_ID ) {port -> p_id_subtype = tlv_subtype ;port -> p_id = b ;port -> p_id_len = tlv_size - 1 ;}else {chassis -> c_id_subtype = tlv_subtype ;chassis -> c_id = b ;chassis -> c_id_len = tlv_size - 1 ;}break ;case LLDP_TLV_TTL : CHECK_TLV_SIZE ( 2 , ""TTL"" ) ;chassis -> c_ttl = PEEK_UINT16 ;ttl_received = 1 ;break ;case LLDP_TLV_PORT_DESCR : case LLDP_TLV_SYSTEM_NAME : case LLDP_TLV_SYSTEM_DESCR : if ( tlv_size < 1 ) {log_debug ( ""lldp"" , ""empty<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;break ;}if ( ( b = ( char * ) calloc ( 1 , tlv_size + 1 ) ) == NULL ) {log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>string<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_BYTES ( b , tlv_size ) ;if ( tlv_type == LLDP_TLV_PORT_DESCR ) port -> p_descr = b ;else if ( tlv_type == LLDP_TLV_SYSTEM_NAME ) chassis -> c_name = b ;else chassis -> c_descr = b ;break ;case LLDP_TLV_SYSTEM_CAP : CHECK_TLV_SIZE ( 4 , ""System<S2SV_blank>capabilities"" ) ;chassis -> c_cap_available = PEEK_UINT16 ;chassis -> c_cap_enabled = PEEK_UINT16 ;break ;case LLDP_TLV_MGMT_ADDR : CHECK_TLV_SIZE ( 1 , ""Management<S2SV_blank>address"" ) ;addr_str_length = PEEK_UINT8 ;CHECK_TLV_SIZE ( 1 + addr_str_length , ""Management<S2SV_blank>address"" ) ;PEEK_BYTES ( addr_str_buffer , addr_str_length ) ;addr_length = addr_str_length - 1 ;addr_family = addr_str_buffer [ 0 ] ;addr_ptr = & addr_str_buffer [ 1 ] ;CHECK_TLV_SIZE ( 1 + addr_str_length + 5 , ""Management<S2SV_blank>address"" ) ;iface_subtype = PEEK_UINT8 ;iface_number = PEEK_UINT32 ;af = lldpd_af_from_lldp_proto ( addr_family ) ;if ( af == LLDPD_AF_UNSPEC ) break ;if ( iface_subtype == LLDP_MGMT_IFACE_IFINDEX ) iface = iface_number ;else iface = 0 ;mgmt = lldpd_alloc_mgmt ( af , addr_ptr , addr_length , iface ) ;if ( mgmt == NULL ) {assert ( errno == ENOMEM ) ;log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>management<S2SV_blank>address"" ) ;goto malformed ;}TAILQ_INSERT_TAIL ( & chassis -> c_mgmt , mgmt , m_entries ) ;break ;case LLDP_TLV_ORG :  CHECK_TLV_SIZE ( 4 , ""Organisational"" ) ;PEEK_BYTES ( orgid , sizeof ( orgid ) ) ;","case LLDP_TLV_CHASSIS_ID : case LLDP_TLV_PORT_ID : CHECK_TLV_SIZE ( 1 + ( int ) sizeof ( orgid ) , ""Organisational"" ) ;PEEK_BYTES ( orgid , sizeof ( orgid ) ) ;",1033
263,int i ;int opts ;,int result ;int i ;int opts ;,1034
264,"if ( ! js_regexec ( re -> prog , text , & m , opts ) ) {js_newarray ( J ) ;","result = js_regexec ( re -> prog , text , & m , opts ) ;if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ;if ( result == 0 ) {js_newarray ( J ) ;",1034
265,if ( m -> msg_flags & MSG_OOB )  goto read_error ;m -> msg_namelen = 0 ;,if ( m -> msg_flags & MSG_OOB ) goto read_error ;,1035
266,"cred = rpc_lookup_cred ( ) ;if ( IS_ERR ( cred ) ) return PTR_ERR ( cred ) ;state = nfs4_do_open ( dir , & path , openflags , NULL , cred ) ;put_rpccred ( cred ) ;","fmode_t fmode = openflags & ( FMODE_READ | FMODE_WRITE ) ;cred = rpc_lookup_cred ( ) ;if ( IS_ERR ( cred ) ) return PTR_ERR ( cred ) ;state = nfs4_do_open ( dir , & path , fmode , openflags , NULL , cred ) ;put_rpccred ( cred ) ;",1036
267,"nfs4_intent_set_file ( nd , & path , state ) ;return 1 ;}nfs4_close_sync ( & path , state , openflags ) ;out_drop : d_drop ( dentry ) ;","nfs4_intent_set_file ( nd , & path , state , fmode ) ;out_drop : d_drop ( dentry ) ;",1036
268,"int target = rc -> av_per_frame_bandwidth * kf_ratio ;return vp9_rc_clamp_iframe_target_size ( cpi , target ) ;","const int target = rc -> avg_frame_bandwidth * kf_ratio ;return vp9_rc_clamp_iframe_target_size ( cpi , target ) ;",1037
269,"if ( test_bit ( DMF_FREEING , & md -> flags ) ||   dm_deleting_md ( md ) )  return NULL ;dm_get ( md ) ;return md ;","spin_lock ( & _minor_lock ) ;if ( test_bit ( DMF_FREEING , & md -> flags ) || dm_deleting_md ( md ) ) {md = NULL ;goto out ;}dm_get ( md ) ;out : spin_unlock ( & _minor_lock ) ;return md ;",1038
270,"if ( nargs == 0 )  return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ;buf = mp_buf_new ( L ) ;","if ( nargs == 0 ) return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ;if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , ""Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."" ) ;buf = mp_buf_new ( L ) ;",1039
271,if ( group_leader -> ctx -> type != ctx -> type )  goto err_context ;,if ( group_leader -> ctx -> task != ctx -> type ) goto err_context ;,1040
272,down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ;if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ;,"error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ;if ( error ) goto out_dput ;down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ;if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ;",1041
273,"static unsigned int get_sby_perpixel_diff_variance ( VP9_COMP * cpi ,  MACROBLOCK * x ,  int mi_row , int mi_col , BLOCK_SIZE bs ) {const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;int offset = ( mi_row * MI_SIZE ) * yv12 -> y_stride + ( mi_col * MI_SIZE ) ;unsigned int var , sse ;var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf ,  x -> plane [ 0 ] . src . stride , yv12 -> y_buffer + offset , yv12 -> y_stride , & sse ) ;","static unsigned int get_sby_perpixel_diff_variance ( VP9_COMP * cpi , const struct buf_2d * ref , int mi_row , int mi_col , BLOCK_SIZE bs ) {unsigned int sse , var ;uint8_t * last_y ;const YV12_BUFFER_CONFIG * last = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;assert ( last != NULL ) ;last_y = & last -> y_buffer [ mi_row * MI_SIZE * last -> y_stride + ( mi_col * MI_SIZE ] ;var = cpi -> fn_ptr [ bs ] . vf ( ref -> buf , ref -> stride , last_y , last -> y_stride , & sse ) ;",1042
274,"void *  checked_xmalloc ( size_t size )  {alloc_limit_assert ( ""checked_xmalloc"" , size ) ;return xmalloc ( size ) ;}","void * checked_xmalloc ( size_t num , size_t size ) {size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;alloc_limit_assert ( ""checked_xmalloc"" , res ) ;return xmalloc ( num , size ) ;}",1043
275,int m ;m = n ;,"int m ;if ( n < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ;}m = n ;",1044
276,++ j )  if ( p ++ != pages [ i + j ] )  break ;,+ j )  if ( p ++ != pages [ i + j ] )  break ;++ j ) if ( ++ p != pages [ i + j ] ) break ;,1045
277,++ j )  if ( p ++ != pages [ i + j ] )  break ;,+ j )  if ( p ++ != pages [ i + j ] )  break ;++ j ) if ( ++ p != pages [ i + j ] ) break ;,1045
278,hdl -> client_state = HSM_COM_C_STATE_IN ;* p_hdl = hdl ;,if ( mkstemp ( hdl -> c_path ) == - 1 ) {res = HSM_COM_PATH_ERR ;goto cleanup ;}hdl -> client_state = HSM_COM_C_STATE_IN ;* p_hdl = hdl ;,1046
279,"assert ( sp -> encodepfunc != NULL ) ;( * sp -> encodepfunc ) ( tif , bp , cc ) ;return ( * sp -> encoderow ) ( tif , bp , cc , s ) ;","if ( ! assert ( sp -> encodepfunc != NULL ) ;( * sp -> encodepfunc ) ( tif , bp , cc ) ) return 0 ;return ( * sp -> encoderow ) ( tif , bp , cc , s ) ;",1047
280,new -> cid_mask = 0 ;,new -> cid_mask = ( 1 << KVM_X2APIC_CID_BITS ) - 1 ;0 ;,1048
281,new -> cid_mask = new -> lid_mask = 0xffff ;},new -> cid_mask = new -> lid_mask = 0xffff ;},1048
282,if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) {struct in_ifaddr * * ifap1 = & ifa1 -> ifa_next ;,if ( in_dev -> dead ) goto no_promotions ;if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) {struct in_ifaddr * * ifap1 = & ifa1 -> ifa_next ;,1049
283,else {,no_promotions : else {,1049
284,}* ifap = ifa1 -> ifa_next ;,}* ifap = ifa1 -> ifa_next ;,1049
285,SvcInternal * si ;if ( svc_ctx == NULL ) return ;si = ( SvcInternal * ) svc_ctx -> internal ;if ( si != NULL ) {free ( si -> buffer ) ;if ( si -> rc_stats_buf ) {free ( si -> rc_stats_buf ) ;},SvcInternal_t * si ;if ( svc_ctx == NULL ) return ;si = ( SvcInternal_t * ) svc_ctx -> internal ;if ( si != NULL ) {,1050
286,"strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ;strncpy ( extra_response -> value , NOTUNDERSTOOD ,  strlen ( NOTUNDERSTOOD ) + 1 ) ;list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ;","strlcpy ( extra_response -> key , key , sizeof ( extra_response -> key ) ) ;strlcpy ( extra_response -> value , NOTUNDERSTOOD , sizeof ( extra_response -> value ) ) ;list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ;",1051
287,"u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ;u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ;struct rd_dev_sg_table * sg_table ;struct page * pg ;struct scatterlist * sg ;","struct rd_dev_sg_table * sg_table ;u32 sg_tables , total_sg_needed ;u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ;int rc ;",1052
288,"while ( total_sg_needed ) {sg_per_table = ( total_sg_needed > max_sg_per_table ) ? max_sg_per_table : total_sg_needed ;sg = kzalloc ( sg_per_table * sizeof ( struct scatterlist ) , GFP_KERNEL ) ;if ( ! sg ) {pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist<S2SV_blank>array"" ""<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev\\\return - ENOMEM ;}sg_init_table ( sg , sg_per_table ) ;sg_table [ i ] . sg_table = sg ;sg_table [ i ] . rd_sg_count = sg_per_table ;sg_table [ i ] . page_start_offset = page_offset ;sg_table [ i ++ ] . page_end_offset = ( page_offset + sg_per_table ) - 1 ;for ( j = 0 ;j < sg_per_table ;j ++ ) {pg = alloc_pages ( GFP_KERNEL , 0 ) ;if ( ! pg ) {pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist"" ""<S2SV_blank>pages<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev_sg_table\\\return - ENOMEM ;}sg_assign_page ( & sg [ j ] , pg ) ;sg [ j ] . length = PAGE_SIZE ;}page_offset += sg_per_table ;total_sg_needed -= sg_per_table ;}","rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ;if ( rc ) return rc ;",1052
289,return ( ( Image * ) NULL ) ;},break ;},1053
290,"}commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ;","}if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ;",1054
291,"buf = malloc ( sz + 1 ) ;SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\\","buf = safe_calloc ( sz + 1 ) ;SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\\",1055
292,"switch ( s -> nal_unit_type ) {case HEVC_NAL_VPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_vps ( gb , s -> avctx , & s -> ps ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_SPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_sps ( gb , s -> avctx , & s -> ps , s -> apply_defdispwin ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_PPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_pps ( gb , s -> avctx , & s -> ps ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_SEI_PREFIX : case HEVC_NAL_SEI_SUFFIX : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_sei ( gb , s -> avctx , & s -> sei , & s -> ps , s -> nal_unit_type ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_TRAIL_R : case HEVC_NAL_TRAIL_N : case HEVC_NAL_TSA_N : case HEVC_NAL_TSA_R : case HEVC_NAL_STSA_N : case HEVC_NAL_STSA_R : case HEVC_NAL_BLA_W_LP : case HEVC_NAL_BLA_W_RADL : case HEVC_NAL_BLA_N_LP : case HEVC_NAL_IDR_W_RADL : case HEVC_NAL_IDR_N_LP : case HEVC_NAL_CRA_NUT : case HEVC_NAL_RADL_N : case HEVC_NAL_RADL_R : case HEVC_NAL_RASL_N : case HEVC_NAL_RASL_R : ret = hls_slice_header ( s ) ;if ( ret < 0 )  return ret ;if ( ( s -> avctx -> skip_frame >= AVDISCARD_BIDIR && s -> sh . slice_type == HEVC_SLICE_B ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONINTRA && s -> sh . slice_type != HEVC_SLICE_I ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONKEY && ! IS_IRAP ( s ) ) ) {break ;}if ( s -> sh . first_slice_in_pic_flag ) {if ( s -> ref ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\\goto fail ;}if ( s -> max_ra == INT_MAX ) {",switch ( s -> max_ra == INT_MAX ) {,1056
293,"pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( child == 0 ) {drop_privs ( 0 ) ;int rv = copy_file ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 )  errExit ( ""chown"" ) ;if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 )  errExit ( ""chmod"" ) ;","copy_file_as_user ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chmod"" ) ;",1057
294,"static inline long decode_twos_comp ( ulong c , int prec )  {","static inline long decode_twos_comp ( jas_ulong c , int prec ) {",1058
295,"x -> skip = 0 ;if ( xd -> segmentation_enabled ) x -> encode_breakout = cpi -> segment_encode_breakout [ xd -> mode_info_context -> mbmi . segment_id ] ;else x -> encode_breakout = cpi -> oxcf . encode_breakout ;# if CONFIG_TEMPORAL_DENOISING x -> best_reference_frame = INTRA_FRAME ;x -> best_zeromv_reference_frame = INTRA_FRAME ;x -> best_sse_inter_mode = 0 ;x -> best_sse_mv . as_int = 0 ;x -> need_to_clamp_best_mvs = 0 ;# endif if ( cpi -> sf . RD ) {int zbin_mode_boost_enabled = x -> zbin_mode_boost_enabled ;if ( cpi -> sf . use_fastquant_for_pick ) {x -> quantize_b = vp8_fast_quantize_b ;x -> quantize_b_pair = vp8_fast_quantize_b_pair ;x -> zbin_mode_boost_enabled = 0 ;}vp8_rd_pick_inter_mode ( cpi , x , recon_yoffset , recon_uvoffset , & rate ,  & distortion , & intra_error ) ;if ( cpi -> sf . improved_quant ) {x -> quantize_b = vp8_regular_quantize_b ;x -> quantize_b_pair = vp8_regular_quantize_b_pair ;","x -> zbin_mode_boost_enabled = 0 ;}vp8_rd_pick_inter_mode ( cpi , x , recon_yoffset , recon_uvoffset , & rate , & distortion , & intra_error , mb_row , mb_col ) ;if ( cpi -> sf . improved_quant ) {x -> quantize_b = vp8_regular_quantize_b ;x -> quantize_b_pair = vp8_regular_quantize_b_pair ;",1059
296,"ascii = malloc ( strlen ( str ) + 1 ) ;strncpy ( ascii , str , strlen ( str ) + 1 ) ;","ascii = safe_calloc ( strlen ( str ) + 1 ) ;strncpy ( ascii , str , strlen ( str ) + 1 ) ;",1060
297,ascii = malloc ( str_len ) ;for ( ;,ascii = safe_calloc ( str_len ) ;for ( ;,1060
298,char lowstr [ MAXDATELEN + 1 ] ;char * realptr ;if ( strlen ( str ) >= sizeof ( lowstr ) )  {,char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ;char * realptr ;if ( strlen ( str ) > MAXDATELEN ) {,1061
299,free_uid ( group -> inotify_data . user ) ;},atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ;free_uid ( group -> inotify_data . user ) ;},1062
300,"int i , j ;p = buff1 ;i = ctm -> length ;str = ( char * ) ctm -> data ;if ( ( i < 11 ) || ( i > 17 ) )  return 0 ;}if ( i < 13 )  return 0 ;}if ( ( * str == \'Z\' ) || ( * str == \'-\' ) || ( * str == \'+\' ) ) {* ( p ++ ) = * ( str ++ ) ;* ( p ++ ) = * ( str ++ ) ;if ( * str == \'.\' ) {while ( ( * str >= \'0\' ) && ( * str <= \'9\' ) )  str ++ ;if ( * str == \'Z\' )  offset = 0 ;else {if ( ( * str != \'+\' ) && ( * str != \'-\' ) )  return 0 ;","int i , j , remaining ;p = buff1 ;remaining = ctm -> length ;str = ( char * ) ctm -> data ;int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ;int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ;if ( remaining < min_length || remaining > max_length ) return 0 ;remaining -= 10 ;}int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ;int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ;if ( remaining < min_length || remaining > max_length ) return 0 ;remaining -= 12 ;}if ( ( * str == \'Z\' ) || ( * str == \'-\' ) || ( * str == \'+\' ) ) {if ( remaining < 2 ) return 0 ;* ( p ++ ) = * ( str ++ ) ;* ( p ++ ) = * ( str ++ ) ;remaining -= 2 ;if ( remaining && * str == \'.\' ) {remaining -- ;for ( i = 0 ;i < 3 && remaining ;i ++ , str ++ , remaining -- ) {if ( * str < \'0\' || * str > \'9\' ) break ;}if ( ! remaining ) return 0 ;if ( * str == \'Z\' ) {if ( remaining != 1 ) return 0 ;offset = 0 ;}else {if ( ( * str != \'+\' ) && ( * str != \'-\' ) ) return 0 ;if ( remaining != 5 ) return 0 ;if ( str [ 1 ] < \'0\' || str [ 1 ] > \'9\' || str [ 2 ] < \'0\' || str [ 2 ] > \'9\' || str [ 3 ] < \'0\' || str [ 3 ] > \'9\' || str [ 4 ] < \'0\' || str [ 4 ] > \'9\' ) return 0 ;",1063
301,void * _TIFFmalloc ( tmsize_t s )  {return ( malloc ( ( size_t ) s ) ) ;,void * _TIFFmalloc ( tmsize_t s ) {if ( s == 0 ) return ( ( void * ) NULL ) ;return ( malloc ( ( size_t ) s ) ) ;,1064
302,if ( ! ( flags | RT6_LOOKUP_F_DST_NOREF ) )  dst_hold ( & rt -> dst ) ;,if ( ! ( flags & RT6_LOOKUP_F_DST_NOREF ) ) dst_hold ( & rt -> dst ) ;,1065
303,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,1066
304,"else {log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ;}gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",1066
305,pu1_buf = ( UWORD8 * ) ps_codec -> pv_mv_bank_buf_base ;ps_mv_buf = ( mv_buf_t * ) pu1_buf ;,ps_codec -> i4_max_dpb_size = max_dpb_size ;pu1_buf = ( UWORD8 * ) ps_codec -> pv_mv_bank_buf_base ;ps_mv_buf = ( mv_buf_t * ) pu1_buf ;,1067
306,"ND_PRINT ( ( ndo , "",<S2SV_blank>(SEC)<S2SV_blank>[worktodo]"" ) ) ;","ND_PRINT ( ( ndo , ""%s"" , rpl_tstr ) ) ;",1068
307,"# if 0 trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;","# if 0 trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;",1068
308,"static int nfs4_open_recover_helper ( struct nfs4_opendata * opendata , mode_t openflags , struct nfs4_state * * res )  {opendata -> o_arg . open_flags = openflags ;memset ( & opendata -> o_res , 0 , sizeof ( opendata -> o_res ) ) ;nfs4_close_state ( & opendata -> path , newstate , openflags ) ;* res = newstate ;","static int nfs4_open_recover_helper ( struct nfs4_opendata * opendata , fmode_t fmode , struct nfs4_state * * res ) {opendata -> o_arg . open_flags = 0 ;opendata -> o_arg . fmode = fmode ;memset ( & opendata -> o_res , 0 , sizeof ( opendata -> o_res ) ) ;nfs4_close_state ( & opendata -> path , newstate , fmode ) ;* res = newstate ;",1069
309,# if ( ETH_SUPPORT == ENABLED )  message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ;,message -> interface = queueItem -> interface ;# if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ;,1070
310,while ( 1 ) {PyObject * literal = NULL ;,state -> fmode = 1 ;while ( 1 ) {PyObject * literal = NULL ;,1071
311,assert ( ! state -> last_str ||  PyUnicode_GET_LENGTH ( state -> last_str ) != 0 ) ;,"
",1071
312,"if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;","if ( pos + len > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;",1072
313,"verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j )  vstart += verdef -> vd_aux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {","verdef -> vd_version = READ16 ( dfs , j ) int vdaux = verdef -> vd_aux ;if ( vdaux < 1 ) {sdb_free ( sdb_verdef ) ;goto out_error ;}vstart += vdaux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {",1073
314,"int sec ;int dsec ;guint pkt_len ;char cap_src [ 13 ] ;guint offset = 0 ;gchar dststr [ 13 ] ;if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9u:%12s->%12s/"" ,  & sec , & dsec , cap_int , direction , & pkt_len , cap_src , cap_dst ) < 5 ) {return - 1 ;}","int pkt_len ;int sec ;int dsec ;char cap_src [ 13 ] ;int offset = 0 ;gchar dststr [ 13 ] ;if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9d:%12s->%12s/"" , & sec , & dsec , cap_int , direction , & pkt_len , cap_src , cap_dst ) < 5 ) {return - 1 ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""netscreen:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;}",1074
315,"struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;int ret , i ;","struct o2nm_cluster * cluster ;int ret , i ;",1075
316,ret = 0 ;write_lock ( & cluster -> cl_nodes_lock ) ;,o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {o2nm_unlock_subsystem ( ) ;return - EINVAL ;}ret = 0 ;write_lock ( & cluster -> cl_nodes_lock ) ;o2nm_unlock_subsystem ( ) ;,1075
317,if ( ret )  return ret ;,if ( ret ) return ret ;,1075
318,"memcpy ( new , ours , sizeof ( * new ) ) ;len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ;","memcpy ( new , ours , sizeof ( * new ) ) ;memset ( dte , 0 , sizeof ( * dte ) ) ;len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ;",1076
319,if ( ! PPEEK_IS ( ')' ) ) return ONIGERR_INVALID_GROUP_NAME ;PINC ;,"if ( ! PPEEK_IS ( ')' ) ) {r = ONIGERR_INVALID_GROUP_NAME ;onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ;return r ;}PINC ;",1077
320,"FRAME_CONTEXT * fc = & cm -> fc ;const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ;i ++ )  fc -> intra_inter_prob [ i ] = adapt_prob ( pre_fc -> intra_inter_prob [ i ] ,  counts -> intra_inter [ i ] ) ;i ++ )  fc -> comp_inter_prob [ i ] = adapt_prob ( pre_fc -> comp_inter_prob [ i ] ,  counts -> comp_inter [ i ] ) ;i ++ )  fc -> comp_ref_prob [ i ] = adapt_prob ( pre_fc -> comp_ref_prob [ i ] ,  counts -> comp_ref [ i ] ) ;j ++ )  fc -> single_ref_prob [ i ] [ j ] = adapt_prob ( pre_fc -> single_ref_prob [ i ] [ j ] ,  counts -> single_ref [ i ] [ j ] ) ;i ++ )  adapt_probs ( vp9_inter_mode_tree , pre_fc -> inter_mode_probs [ i ] ,  counts -> inter_mode [ i ] , fc -> inter_mode_probs [ i ] ) ;i ++ )  adapt_probs ( vp9_intra_mode_tree , pre_fc -> y_mode_prob [ i ] ,  counts -> y_mode [ i ] , fc -> y_mode_prob [ i ] ) ;++ i )  adapt_probs ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] ,  counts -> uv_mode [ i ] , fc -> uv_mode_prob [ i ] ) ;i ++ )  adapt_probs ( vp9_partition_tree , pre_fc -> partition_prob [ i ] ,  counts -> partition [ i ] , fc -> partition_prob [ i ] ) ;i ++ )  adapt_probs ( vp9_switchable_interp_tree , pre_fc -> switchable_interp_prob [ i ] ,  counts -> switchable_interp [ i ] , fc -> switchable_interp_prob [ i ] ) ;","FRAME_CONTEXT * fc = cm -> fc ;const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ;i ++ ) fc -> intra_inter_prob [ i ] = mode_mv_merge_probs ( pre_fc -> intra_inter_prob [ i ] , counts -> intra_inter [ i ] ) ;i ++ ) fc -> comp_inter_prob [ i ] = mode_mv_merge_probs ( pre_fc -> comp_inter_prob [ i ] , counts -> comp_inter [ i ] ) ;i ++ ) fc -> comp_ref_prob [ i ] = mode_mv_merge_probs ( pre_fc -> comp_ref_prob [ i ] , counts -> comp_ref [ i ] ) ;j ++ ) fc -> single_ref_prob [ i ] [ j ] = mode_mv_merge_probs ( pre_fc -> single_ref_prob [ i ] [ j ] , counts -> single_ref [ i ] [ j ] ) ;i ++ ) vpx_tree_merge_probs ( vp9_inter_mode_tree , pre_fc -> inter_mode_probs [ i ] , counts -> inter_mode [ i ] , fc -> inter_mode_probs [ i ] ) ;i ++ ) vpx_tree_merge_probs ( vp9_intra_mode_tree , pre_fc -> y_mode_prob [ i ] , counts -> y_mode [ i ] , fc -> y_mode_prob [ i ] ) ;+ i )  adapt_probs ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] ,  counts -> uv_mode [ i ] , fc -> uv_mode_prob [ i ] ) ;++ i ) vpx_tree_merge_probs ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] , counts -> uv_mode [ i ] , fc -> uv_mode_prob [ i ] ) ;i ++ ) vpx_tree_merge_probs ( vp9_partition_tree , pre_fc -> partition_prob [ i ] , counts -> partition [ i ] , fc -> partition_prob [ i ] ) ;i ++ ) vpx_tree_merge_probs ( vp9_switchable_interp_tree , pre_fc -> switchable_interp_prob [ i ] , counts -> switchable_interp [ i ] , fc -> switchable_interp_prob [ i ] ) ;",1078
321,"++ j )  fc -> tx_probs . p8x8 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p8x8 [ i ] [ j ] ,  branch_ct_8x8p [ j ] ) ;++ j )  fc -> tx_probs . p16x16 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p16x16 [ i ] [ j ] ,  branch_ct_16x16p [ j ] ) ;++ j )  fc -> tx_probs . p32x32 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p32x32 [ i ] [ j ] ,  branch_ct_32x32p [ j ] ) ;++ i )  fc -> skip_probs [ i ] = adapt_prob ( pre_fc -> skip_probs [ i ] , counts -> skip [ i ] ) ;}","+ j )  fc -> tx_probs . p8x8 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p8x8 [ i ] [ j ] ,  branch_ct_8x8p [ j ] ) ;++ j ) fc -> tx_probs . p8x8 [ i ] [ j ] = mode_mv_merge_probs ( pre_fc -> tx_probs . p8x8 [ i ] [ j ] , branch_ct_8x8p [ j ] ) ;+ j )  fc -> tx_probs . p16x16 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p16x16 [ i ] [ j ] ,  branch_ct_16x16p [ j ] ) ;++ j ) fc -> tx_probs . p16x16 [ i ] [ j ] = mode_mv_merge_probs ( pre_fc -> tx_probs . p16x16 [ i ] [ j ] , branch_ct_16x16p [ j ] ) ;+ j )  fc -> tx_probs . p32x32 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p32x32 [ i ] [ j ] ,  branch_ct_32x32p [ j ] ) ;++ j ) fc -> tx_probs . p32x32 [ i ] [ j ] = mode_mv_merge_probs ( pre_fc -> tx_probs . p32x32 [ i ] [ j ] , branch_ct_32x32p [ j ] ) ;+ i )  fc -> skip_probs [ i ] = adapt_prob ( pre_fc -> skip_probs [ i ] , counts -> skip [ i ] ) ;++ i ) fc -> skip_probs [ i ] = mode_mv_merge_probs ( pre_fc -> skip_probs [ i ] , counts -> skip [ i ] ) ;}",1078
322,"struct snd_kcontrol * kctl ;list_for_each_entry ( kctl , & card -> controls , list ) {","struct snd_kcontrol * kctl ;if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0 ;list_for_each_entry ( kctl , & card -> controls , list ) {",1079
323,"struct kvm_arch * ka = & v -> kvm -> arch ;void * shared_kaddr ;s64 kernel_ns , max_kernel_ns ;struct pvclock_vcpu_time_info * guest_hv_clock ;u8 pvclock_flags ;","s64 kernel_ns , max_kernel_ns ;struct pvclock_vcpu_time_info * guest_hv_clock ;u8 pvclock_flags ;",1080
324,if ( ! vcpu -> time_page )  return 0 ;,if ( ! vcpu -> pv_time_enabled ) return 0 ;,1080
325,"shared_kaddr = kmap_atomic ( vcpu -> time_page ) ;guest_hv_clock = shared_kaddr + vcpu -> time_offset ;pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ;if ( vcpu -> pvclock_set_guest_stopped_request ) {memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock ,  sizeof ( vcpu -> hv_clock ) ) ;kunmap_atomic ( shared_kaddr ) ;mark_page_dirty ( v -> kvm , vcpu -> time >> PAGE_SHIFT ) ;","if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 ;pvclock_flags = ( guest_hv_clock . flags & PVCLOCK_GUEST_STOPPED ) ;if ( vcpu -> pvclock_set_guest_stopped_request ) {kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , & vcpu -> hv_clock , sizeof ( vcpu -> hv_clock ) ) ;",1080
326,"int64_t vp9_block_error_c ( const int16_t * coeff , const int16_t * dqcoeff ,  intptr_t block_size , int64_t * ssz ) {","int64_t vp9_block_error_c ( const tran_low_t * coeff , const int16_t * dqcoeff , intptr_t block_size , int64_t * ssz ) {",1081
327,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  return - ENOKEY ;",if ( key_is_negative ( key ) ) return - ENOKEY ;,1082
328,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ;switch ( dir ) {","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , addr ) ;switch ( dir ) {",1083
329,"void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) {bloc = * offset ;while ( node && node -> symbol == INTERNAL_NODE ) {if ( get_bit ( fin ) ) {","void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset , int maxoffset ) {bloc = * offset ;while ( node && node -> symbol == INTERNAL_NODE ) {if ( bloc >= maxoffset ) {* ch = 0 ;* offset = maxoffset + 1 ;return ;}if ( get_bit ( fin ) ) {",1084
330,bufsize = file -> size ;sc_file_free ( file ) ;,"bufsize = MIN ( file -> size , sizeof buf ) ;sc_file_free ( file ) ;",1085
331,"next_byte :  b = cpu_ldub_code ( env , s -> pc ) ;","next_byte : if ( s -> pc - pc_start > 14 ) {goto illegal_op ;}b = cpu_ldub_code ( env , s -> pc ) ;",1086
332,return true ;},if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ;else return true ;},1087
333,"if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) ||  ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) {for ( i = 0 ;segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ;","if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ;if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) {for ( i = 0 ;if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ;",1088
334,const float factor = 0.5 ;const int number_blocks = cm -> mi_rows * cm -> mi_cols ;if ( rc -> av_per_frame_bandwidth < factor * number_blocks ||  number_blocks / 64 < 5 ) return 0 ;,const float factor = 0.25 ;const int number_blocks = cm -> mi_rows * cm -> mi_cols ;if ( rc -> avg_frame_bandwidth < factor * number_blocks || number_blocks / 64 < 5 ) return 0 ;,1089
335,"size_t columns ,  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads ,  sizeof ( * pixels ) ) ;( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;columns = images -> columns ;for ( i = 0 ;i ++ )  {","size_t columns , rows ;rows = MagickMax ( GetImageListLength ( images ) , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) ;pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( rows , sizeof ( * pixels ) ) ;columns = images -> columns ;for ( i = 0 ;i ++ ) {",1090
336,"char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ;ret = stat ( pathname , & sb ) ;","char * pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"" ;ret = stat ( pathname , & sb ) ;",1091
337,"result = send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ;if ( btif_is_enabled ( ) ) {","result = TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ;if ( btif_is_enabled ( ) ) {",1092
338,"uint32_t off = offset , tmp , finish ;struct ipmi_rs * rsp ;finish = fru -> size ;lprintf ( LOG_NOTICE , ""Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>"" ""Adjusting<S2SV_blank>to<S2SV_blank>%d"" , offset + length , finish - offset ) ;}memset ( & req , 0 , sizeof ( req ) ) ;","uint32_t off = offset ;uint32_t tmp ;uint32_t finish ;uint32_t size_left_in_buffer ;struct ipmi_rs * rsp ;memset ( frubuf + fru -> size , 0 , length - fru -> size ) ;finish = fru -> size ;lprintf ( LOG_NOTICE , ""Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>"" ""Adjusting<S2SV_blank>to<S2SV_blank>%d"" , offset + length , finish - offset ) ;length = finish - offset ;}memset ( & req , 0 , sizeof ( req ) ) ;",1093
339,do {tmp = fru -> access ? off >> 1 : off ;,size_left_in_buffer = length ;do {tmp = fru -> access ? off >> 1 : off ;,1093
340,"memcpy ( frubuf , rsp -> data + 1 , tmp ) ;off += tmp ;if ( tmp == 0 && off < finish ) {return 0 ;","if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) {printf ( ""<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size"" ) ;return - 1 ;}memcpy ( frubuf , rsp -> data + 1 , tmp ) ;off += tmp ;size_left_in_buffer -= tmp ;if ( tmp == 0 && off < finish ) {return 0 ;",1093
341,"if ( buffer )  vterm_allocator_free ( screen -> vt , buffer ) ;","vterm_allocator_free ( screen -> vt , buffer ) ;",1094
342,}conn_without_ssl_ok : ;,peer = NULL ;}conn_without_ssl_ok : ;,1095
343,"static uid_t uid_server = 0 ;static gid_t gid_cluster = 0 ;uid_server = getuid ( ) ;if ( crm_user_lookup ( CRM_DAEMON_USER , NULL , & gid_cluster ) < 0 ) {","static gid_t gid_cluster = 0 ;if ( crm_user_lookup ( CRM_DAEMON_USER , NULL , & gid_cluster ) < 0 ) {",1096
344,"if ( gid_cluster != 0 && gid_client != 0 ) {uid_t best_uid = - 1 ;if ( uid_client == 0 || uid_server == 0 ) {best_uid = QB_MAX ( uid_client , uid_server ) ;crm_trace ( ""Allowing<S2SV_blank>user<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>clean<S2SV_blank>up<S2SV_blank>after<S2SV_blank>disconnect"" , best_uid ) ;}qb_ipcs_connection_auth_set ( c , best_uid , gid_cluster , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) ;","if ( uid_client != 0 ) {qb_ipcs_connection_auth_set ( c , - 1 , gid_cluster , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) ;",1096
345,if ( client -> type == USER_CLIENT )  snd_seq_fifo_clear ( client -> data . user . fifo ) ;,if ( client -> type == USER_CLIENT && client -> data . user . fifo ) snd_seq_fifo_clear ( client -> data . user . fifo ) ;,1097
346,stmt_ty s ;node * ch ;mod_ty res = NULL ;c . c_arena = arena ;,"asdl_seq * type_ignores = NULL ;stmt_ty s ;node * ch ;mod_ty res = NULL ;asdl_seq * argtypes = NULL ;expr_ty ret , arg ;c . c_arena = arena ;",1098
347,"res = Module ( stmts , arena ) ;break ;","ch = CHILD ( n , NCH ( n ) - 1 ) ;REQ ( ch , ENDMARKER ) ;num = NCH ( ch ) ;type_ignores = _Py_asdl_seq_new ( num , arena ) ;if ( ! type_ignores ) goto out ;for ( i = 0 ;i < num ;i ++ ) {type_ignore_ty ti = TypeIgnore ( LINENO ( CHILD ( ch , i ) ) , arena ) ;if ( ! ti ) goto out ;asdl_seq_SET ( type_ignores , i , ti ) ;}res = Module ( stmts , type_ignores , arena ) ;break ;",1098
348,"default :  PyErr_Format ( PyExc_SystemError , ""invalid<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>PyAST_FromNode"" , TYPE ( n ) ) ;","case func_type_input : n = CHILD ( n , 0 ) ;REQ ( n , func_type ) ;if ( TYPE ( CHILD ( n , 1 ) ) == typelist ) {ch = CHILD ( n , 1 ) ;num = 0 ;for ( i = 0 ;i < NCH ( ch ) ;i ++ ) {if ( TYPE ( CHILD ( ch , i ) ) == test ) {num ++ ;}}argtypes = _Py_asdl_seq_new ( num , arena ) ;if ( ! argtypes ) goto out ;j = 0 ;for ( i = 0 ;i < NCH ( ch ) ;i ++ ) {if ( TYPE ( CHILD ( ch , i ) ) == test ) {arg = ast_for_expr ( & c , CHILD ( ch , i ) ) ;if ( ! arg ) goto out ;asdl_seq_SET ( argtypes , j ++ , arg ) ;}}}else {argtypes = _Py_asdl_seq_new ( 0 , arena ) ;if ( ! argtypes ) goto out ;}ret = ast_for_expr ( & c , CHILD ( n , NCH ( n ) - 1 ) ) ;if ( ! ret ) goto out ;res = FunctionType ( argtypes , ret , arena ) ;break ;default : PyErr_Format ( PyExc_SystemError , ""invalid<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>PyAST_FromNode"" , TYPE ( n ) ) ;",1098
349,uint8_t chipRevision ;Dm9000Context * context ;,uint8_t chipRev ;Dm9000Context * context ;,1099
350,"vendorId = ( dm9000ReadReg ( DM9000_REG_VIDH ) << 8 ) | dm9000ReadReg ( DM9000_REG_VIDL ) ;productId = ( dm9000ReadReg ( DM9000_REG_PIDH ) << 8 ) | dm9000ReadReg ( DM9000_REG_PIDL ) ;chipRevision = dm9000ReadReg ( DM9000_REG_CHIPR ) ;if ( vendorId != DM9000_VID || productId != DM9000_PID ) {if ( chipRevision != DM9000A_CHIP_REV && chipRevision != DM9000B_CHIP_REV )  {dm9000WriteReg ( DM9000_REG_GPR , 0x00 ) ;sleep ( 10 ) ;dm9000WriteReg ( DM9000_REG_NCR , NCR_RST ) ;while ( ( dm9000ReadReg ( DM9000_REG_NCR ) & NCR_RST ) != 0 )  {dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_RST ) ;while ( ( dm9000ReadPhyReg ( DM9000_PHY_REG_BMCR ) & BMCR_RST ) != 0 )  {TRACE_INFO ( ""<S2SV_blank><S2SV_blank>CHIPR<S2SV_blank>=<S2SV_blank>0x%02"" PRIX8 ""\\\\r\\\TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR1<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\\\r\\\TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR2<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\\\r\\\# if ( DM9000_LOOPBACK_MODE == ENABLED )  dm9000WriteReg ( DM9000_REG_NCR , DM9000_LBK_PHY ) ;dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_LOOPBACK | BMCR_SPEED_SEL | BMCR_AN_EN | BMCR_DUPLEX_MODE ) ;# endif for ( i = 0 ;dm9000WriteReg ( DM9000_REG_PAR0 + i , interface -> macAddr . b [ i ] ) ;}dm9000WriteReg ( DM9000_REG_MAR0 + i , 0x00 ) ;}dm9000WriteReg ( DM9000_REG_MAR7 , 0x80 ) ;dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR ) ;dm9000WriteReg ( DM9000_REG_NSR , NSR_WAKEST | NSR_TX2END | NSR_TX1END ) ;dm9000WriteReg ( DM9000_REG_ISR , ISR_LNKCHG | ISR_UDRUN | ISR_ROO | ISR_ROS | ISR_PT | ISR_PR ) ;dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR | IMR_LNKCHGI | IMR_PTI | IMR_PRI ) ;dm9000WriteReg ( DM9000_REG_RCR , RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN ) ;","vendorId = ( dm9000ReadReg ( DM9000_VIDH ) << 8 ) | dm9000ReadReg ( DM9000_VIDL ) ;productId = ( dm9000ReadReg ( DM9000_PIDH ) << 8 ) | dm9000ReadReg ( DM9000_PIDL ) ;chipRev = dm9000ReadReg ( DM9000_REG_CHIPR ) ;if ( vendorId != DM9000_VID || productId != DM9000_PID ) {if ( chipRev != DM9000_CHIPR_REV_A && chipRev != DM9000_CHIPR_REV_B ) {dm9000WriteReg ( DM9000_GPR , 0x00 ) ;sleep ( 10 ) ;dm9000WriteReg ( DM9000_NCR , DM9000_NCR_RST ) ;while ( ( dm9000ReadReg ( DM9000_NCR ) & DM9000_NCR_RST ) != 0 ) {dm9000WritePhyReg ( DM9000_BMCR , DM9000_BMCR_RST ) ;while ( ( dm9000ReadPhyReg ( DM9000_BMCR ) & DM9000_BMCR_RST ) != 0 ) {TRACE_INFO ( ""<S2SV_blank><S2SV_blank>CHIPR<S2SV_blank>=<S2SV_blank>0x%02"" PRIX8 ""\\\\r\\\TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR1<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\\\r\\\TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR2<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\\\r\\\# if ( DM9000_LOOPBACK_MODE == ENABLED ) dm9000WriteReg ( DM9000_NCR , DM9000_NCR_LBK_PHY ) ;dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_LOOPBACK | BMCR_SPEED_SEL | BMCR_AN_EN | BMCR_DUPLEX_MODE ) ;# endif for ( i = 0 ;dm9000WriteReg ( DM9000_PAR0 + i , interface -> macAddr . b [ i ] ) ;}dm9000WriteReg ( DM9000_MAR0 + i , 0x00 ) ;}dm9000WriteReg ( DM9000_MAR7 , 0x80 ) ;dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR ) ;dm9000WriteReg ( DM9000_NSR , DM9000_NSR_WAKEST | DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ;dm9000WriteReg ( DM9000_ISR , DM9000_ISR_LNKCHG | DM9000_ISR_UDRUN | DM9000_ISR_ROO | DM9000_ISR_ROS | DM9000_ISR_PT | DM9000_ISR_PR ) ;dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI ) ;dm9000WriteReg ( DM9000_RCR , DM9000_RCR_DIS_LONG | DM9000_RCR_DIS_CRC | DM9000_RCR_RXEN ) ;",1099
351,int64_t old_off = s -> off ;uint8_t old_buf [ BUFFER_SIZE ] ;else if ( ( s -> filesize == - 1 && whence == SEEK_END ) )  return AVERROR ( ENOSYS ) ;,uint64_t old_off = s -> off ;uint8_t old_buf [ BUFFER_SIZE ] ;else if ( ( s -> filesize == UINT64_MAX && whence == SEEK_END ) ) return AVERROR ( ENOSYS ) ;,1100
352,vp9_coeff_probs_model * const probs = cm -> fc . coef_probs [ tx_size ] ;const vp9_coeff_probs_model * const pre_probs = pre_fc -> coef_probs [ tx_size ] ;,vp9_coeff_probs_model * const probs = cm -> fc -> coef_probs [ tx_size ] ;const vp9_coeff_probs_model * const pre_probs = pre_fc -> coef_probs [ tx_size ] ;,1101
353,"static void  swabHorDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horDiff32 ( tif , cp0 , cc ) ;TIFFSwabArrayOfLong ( wp , wc ) ;}","static int swabHorDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ! horDiff32 ( tif , cp0 , cc ) ) return 0 ;TIFFSwabArrayOfLong ( wp , wc ) ;return 1 ;}",1102
354,"static void nfs_set_open_stateid_locked ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags )  {switch ( open_flags ) {case FMODE_READ : set_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ;","static void nfs_set_open_stateid_locked ( struct nfs4_state * state , nfs4_stateid * stateid , fmode_t fmode ) {switch ( fmode ) {case FMODE_READ : set_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ;",1103
355,cf . can_id = 0 ;switch ( * cmd ) {,"memset ( & cf , 0 , sizeof ( cf ) ) ;switch ( * cmd ) {",1104
356,* ( u64 * ) ( & cf . data ) = 0 ;if ( ! ( cf . can_id & CAN_RTR_FLAG ) ) {,if ( ! ( cf . can_id & CAN_RTR_FLAG ) ) {,1104
357,},g_free_not_null ( ircconn -> sasl_username ) ;g_free_not_null ( ircconn -> sasl_password ) ;},1105
358,sock -> sk -> sk_uid = iattr -> ia_uid ;}return err ;,if ( sock -> sk ) sock -> sk -> sk_uid = iattr -> ia_uid ;else err = - ENOENT ;}return err ;,1106
359,char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ;if ( buffer ) {,size_t size = bytes + CHK_OVERHEAD_SIZE ;if ( size < bytes ) {return NULL ;}uint8_t * buffer = ( uint8_t * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ;if ( buffer ) {,1107
360,"
","if ( rar -> dictionary_size == 0 ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size"" ) ;return ( ARCHIVE_FATAL ) ;}",1108
361,"if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context ,  rar -> dictionary_size , & g_szalloc ) ) {","if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context , rar -> dictionary_size , & g_szalloc ) ) {",1108
362,"if ( code )  return code ;code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ;","if ( code ) {* status = ""DECODE_PA_FOR_USER"" ;return code ;}code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ;",1109
363,"# line 585 ""ext/standard/var_unserializer.c""  {","# line 576 ""ext/standard/var_unserializer.c"" {",1110
364,"case \'C\' :  case \'O\' : goto yy13 ;case \'N\' : goto yy5 ;case \'R\' : goto yy2 ;case \'S\' : goto yy10 ;case \'a\' : goto yy11 ;case \'b\' : goto yy6 ;case \'d\' : goto yy8 ;case \'i\' : goto yy7 ;case \'o\' : goto yy12 ;case \'r\' : goto yy4 ;case \'s\' : goto yy9 ;case \'}\' : goto yy14 ;default : goto yy16 ;}yy3 :  # line 962 ""ext/standard/var_unserializer.re""  {# line 646 ""ext/standard/var_unserializer.c""  yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy89 ;goto yy3 ;if ( yych == \';\' ) goto yy87 ;goto yy3 ;if ( yych == \':\' ) goto yy83 ;goto yy3 ;if ( yych == \':\' ) goto yy77 ;goto yy3 ;if ( yych == \':\' ) goto yy53 ;goto yy3 ;if ( yych == \':\' ) goto yy46 ;goto yy3 ;if ( yych == \':\' ) goto yy39 ;goto yy3 ;if ( yych == \':\' ) goto yy32 ;goto yy3 ;if ( yych == \':\' ) goto yy25 ;goto yy3 ;if ( yych == \':\' ) goto yy17 ;goto yy3 ;yy14 :  ++ YYCURSOR ;# line 956 ""ext/standard/var_unserializer.re""  {# line 695 ""ext/standard/var_unserializer.c""  yy16 : yych = * ++ YYCURSOR ;goto yy3 ;yy17 : yych = * ++ YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy20 ;}if ( yych == \'+\' ) goto yy19 ;yy18 : YYCURSOR = YYMARKER ;goto yy3 ;yy19 : yych = * ++ YYCURSOR ;goto yy20 ;}goto yy18 ;yy20 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy20 ;}if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \';\' ) goto yy18 ;yych = * ++ YYCURSOR ;if ( yych != \\\'""\\\' ) goto yy18 ;++ YYCURSOR ;# line 804 ""ext/standard/var_unserializer.re""  {size_t len , len2 , len3 , maxlen ;zend_long elements ;char * str ;zend_string * class_name ;zend_class_entry * ce ;int incomplete_class = 0 ;int custom_object = 0 ;zval user_func ;zval retval ;zval args [ 1 ] ;if ( ! var_hash ) return 0 ;if ( * start == \'C\' ) {custom_object = 1 ;len2 = len = parse_uiv ( start + 2 ) ;maxlen = max - YYCURSOR ;if ( maxlen < len || len == 0 ) {* p = start + 2 ;return 0 ;}str = ( char * ) YYCURSOR ;YYCURSOR += len ;if ( * ( YYCURSOR ) != \\\'""\\\' ) {return 0 ;if ( * ( YYCURSOR + 1 ) != \':\' ) {* p = YYCURSOR + 1 ;return 0 ;len3 = strspn ( str , ""0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\177\\\\200\\\\201\\\\202\\\\203\\\\204\\\\205\\\\206\\\\207\\\\210\\\\211\\\\212\\\\213\\\\214\\\\215\\\\216\\\\217\\\\220\\\\221\\\\222\\\\223\\\\224\\\\225\\\\226\\\\227\\\\230\\\\231\\\\232\\\\233\\\\234\\\\235\\\\236\\\\237\\\\240\\\\241\\\\242\\\\243\\\\244\\\\245\\\\246\\\\247\\\\250\\\\251\\\\252\\\\253\\\\254\\\\255\\\\256\\\\257\\\\260\\\\261\\\\262\\\\263\\\\264\\\\265\\\\266\\\\267\\\\270\\\\271\\\\272\\\\273\\\\274\\\\275\\\\276\\\\277\\\\300\\\\301\\\\302\\\\303\\\\304\\\\305\\\\306\\\\307\\\\310\\\\311\\\\312\\\\313\\\\314\\\\315\\\\316\\\\317\\\\320\\\\321\\\\322\\\\323\\\\324\\\\325\\\\326\\\\327\\\\330\\\\331\\\\332\\\\333\\\\334\\\\335\\\\336\\\\337\\\\340\\\\341\\\\342\\\\343\\\\344\\\\345\\\\346\\\\347\\\\350\\\\351\\\\352\\\\353\\\\354\\\\355\\\\356\\\\357\\\\360\\\\361\\\\362\\\\363\\\\364\\\\365\\\\366\\\\367\\\\370\\\\371\\\\372\\\\373\\\\374\\\\375\\\\376\\\\377\\\\\\\\"" ) ;if ( len3 != len ) {* p = YYCURSOR + len3 - len ;return 0 ;class_name = zend_string_init ( str , len , 0 ) ;do {if ( ! unserialize_allowed_class ( class_name , classes ) ) {incomplete_class = 1 ;ce = PHP_IC_ENTRY ;break ;}BG ( serialize_lock ) ++ ;ce = zend_lookup_class ( class_name ) ;if ( ce ) {BG ( serialize_lock ) -- ;if ( EG ( exception ) ) {zend_string_release ( class_name ) ;return 0 ;break ;BG ( serialize_lock ) -- ;if ( EG ( exception ) ) {zend_string_release ( class_name ) ;return 0 ;if ( ( PG ( unserialize_callback_func ) == NULL ) || ( PG ( unserialize_callback_func ) [ 0 ] == \'\\\\0\' ) ) {incomplete_class = 1 ;ce = PHP_IC_ENTRY ;break ;}ZVAL_STRING ( & user_func , PG ( unserialize_callback_func ) ) ;ZVAL_STR_COPY ( & args [ 0 ] , class_name ) ;BG ( serialize_lock ) ++ ;if ( call_user_function_ex ( CG ( function_table ) , NULL , & user_func , & retval , 1 , args , 0 , NULL ) != SUCCESS ) {BG ( serialize_lock ) -- ;if ( EG ( exception ) ) {zend_string_release ( class_name ) ;zval_ptr_dtor ( & user_func ) ;zval_ptr_dtor ( & args [ 0 ] ) ;return 0 ;php_error_docref ( NULL , E_WARNING , ""defined<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>not<S2SV_blank>found"" , Z_STRVAL ( user_func ) ) ;incomplete_class = 1 ;ce = PHP_IC_ENTRY ;zval_ptr_dtor ( & user_func ) ;zval_ptr_dtor ( & args [ 0 ] ) ;break ;}BG ( serialize_lock ) -- ;zval_ptr_dtor ( & retval ) ;if ( EG ( exception ) ) {zend_string_release ( class_name ) ;zval_ptr_dtor ( & user_func ) ;zval_ptr_dtor ( & args [ 0 ] ) ;return 0 ;BG ( serialize_lock ) ++ ;if ( ( ce = zend_lookup_class ( class_name ) ) == NULL ) {php_error_docref ( NULL , E_WARNING , ""Function<S2SV_blank>%s()<S2SV_blank>hasn\\\'t<S2SV_blank>defined<S2SV_blank>the<S2SV_blank>class<S2SV_blank>it<S2SV_blank>was<S2SV_blank>called<S2SV_blank>for"" , Z_STRVAL ( user_func ) ) ;incomplete_class = 1 ;ce = PHP_IC_ENTRY ;BG ( serialize_lock ) -- ;zval_ptr_dtor ( & user_func ) ;zval_ptr_dtor ( & args [ 0 ] ) ;break ;while ( 1 ) ;* p = YYCURSOR ;if ( custom_object ) {int ret ;ret = object_custom ( UNSERIALIZE_PASSTHRU , ce ) ;if ( ret && incomplete_class ) {php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ;}zend_string_release ( class_name ) ;return ret ;}elements = object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ;if ( elements < 0 ) {zend_string_release ( class_name ) ;return 0 ;if ( incomplete_class ) {php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ;zend_string_release ( class_name ) ;return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ;# line 878 ""ext/standard/var_unserializer.c""  yy25 : yych = * ++ YYCURSOR ;if ( yych != \'+\' ) goto yy18 ;if ( yych <= \'-\' ) goto yy26 ;if ( yych <= \'9\' ) goto yy27 ;yy26 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy27 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yych <= \'9\' ) goto yy27 ;if ( yych >= \';\' ) goto yy18 ;yych = * ++ YYCURSOR ;if ( yych != \\\'""\\\' ) goto yy18 ;++ YYCURSOR ;# line 793 ""ext/standard/var_unserializer.re""  {zend_long elements ;if ( ! var_hash ) return 0 ;elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ;if ( elements < 0 || elements >= HT_MAX_SIZE ) {return 0 ;return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ;# line 914 ""ext/standard/var_unserializer.c"" yy32 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy33 ;if ( yych <= \'9\' ) goto yy34 ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;if ( yych >= \';\' ) goto yy18 ;yych = * ++ YYCURSOR ;if ( yych != \'{\' ) goto yy18 ;++ YYCURSOR ;# line 769 ""ext/standard/var_unserializer.re"" {zend_long elements = parse_iv ( start + 2 ) ;* p = YYCURSOR ;","case \'C\' : case \'O\' : goto yy4 ;case \'N\' : goto yy5 ;case \'R\' : goto yy6 ;case \'S\' : goto yy10 ;case \'a\' : goto yy8 ;case \'b\' : goto yy6 ;case \'d\' : goto yy10 ;case \'i\' : goto yy7 ;case \'o\' : goto yy12 ;case \'r\' : goto yy13 ;case \'s\' : goto yy9 ;case \'}\' : goto yy15 ;default : goto yy16 ;}yy3 : # line 951 ""ext/standard/var_unserializer.re"" {# line 636 ""ext/standard/var_unserializer.c"" yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy17 ;goto yy3 ;if ( yych == \';\' ) goto yy19 ;goto yy3 ;if ( yych == \':\' ) goto yy21 ;goto yy3 ;if ( yych == \':\' ) goto yy22 ;goto yy3 ;if ( yych == \':\' ) goto yy23 ;goto yy3 ;if ( yych == \':\' ) goto yy24 ;goto yy3 ;if ( yych == \':\' ) goto yy25 ;goto yy3 ;if ( yych == \':\' ) goto yy26 ;goto yy3 ;if ( yych == \':\' ) goto yy27 ;goto yy3 ;if ( yych == \':\' ) goto yy28 ;goto yy3 ;yy14 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy29 ;goto yy3 ;yy15 : ++ YYCURSOR ;# line 945 ""ext/standard/var_unserializer.re"" {# line 689 ""ext/standard/var_unserializer.c"" yy17 : yych = * ++ YYCURSOR ;+ YYCURSOR ;goto yy31 ;if ( yych == \'+\' ) goto yy30 ;yy18 : YYCURSOR = YYMARKER ;goto yy3 ;yy19 : ++ YYCURSOR ;# line 629 ""ext/standard/var_unserializer.re"" {ZVAL_NULL ( rval ) ;return 1 ;# line 707 ""ext/standard/var_unserializer.c"" yy21 : yych = * ++ YYCURSOR ;if ( yych <= \',\' ) {if ( yych == \'+\' ) goto yy33 ;goto yy18 ;else {if ( yych <= \'-\' ) goto yy33 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy34 ;goto yy18 ;yy22 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy36 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy37 ;goto yy18 ;yy23 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy39 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy40 ;goto yy18 ;yy24 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'1\' ) goto yy42 ;goto yy18 ;yy25 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) {if ( yych <= \',\' ) {if ( yych == \'+\' ) goto yy43 ;goto yy18 ;else {if ( yych <= \'-\' ) goto yy44 ;if ( yych <= \'.\' ) goto yy45 ;goto yy18 ;else {if ( yych <= \'I\' ) {if ( yych <= \'9\' ) goto yy46 ;if ( yych <= \'H\' ) goto yy18 ;goto yy48 ;else {if ( yych == \'N\' ) goto yy49 ;goto yy18 ;yy26 : yych = * ++ YYCURSOR ;if ( yych <= \',\' ) {if ( yych == \'+\' ) goto yy50 ;goto yy18 ;else {if ( yych <= \'-\' ) goto yy50 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy51 ;goto yy18 ;yy27 : yych = * ++ YYCURSOR ;if ( yych <= \',\' ) {if ( yych == \'+\' ) goto yy53 ;goto yy18 ;else {if ( yych <= \'-\' ) goto yy53 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy54 ;goto yy18 ;yy28 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy56 ;goto yy18 ;if ( yych <= \'-\' ) goto yy56 ;if ( yych <= \'9\' ) goto yy57 ;yy29 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy59 ;+ YYCURSOR ;if ( yych <= \'9\' ) goto yy60 ;goto yy18 ;yy30 : yych = * ++ YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy31 ;goto yy18 ;yy31 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy31 ;if ( yych <= \':\' ) goto yy62 ;if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ;+ YYCURSOR ;if ( yych == \';\' ) goto yy63 ;goto yy18 ;yy36 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy37 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy37 ;if ( yych <= \':\' ) goto yy65 ;goto yy18 ;yy39 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy40 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy40 ;if ( yych <= \':\' ) goto yy66 ;goto yy18 ;yy42 : yych = * ++ YYCURSOR ;if ( yych == \';\' ) goto yy67 ;goto yy18 ;yy43 : yych = * ++ YYCURSOR ;if ( yych == \'.\' ) goto yy45 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy46 ;goto yy18 ;yy44 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) {if ( yych != \'.\' ) goto yy18 ;}else {if ( yych <= \'9\' ) goto yy46 ;if ( yych == \'I\' ) goto yy48 ;goto yy18 ;}yy45 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy69 ;goto yy18 ;yy46 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ;yych = * YYCURSOR ;if ( yych <= \':\' ) {if ( yych <= \'.\' ) {if ( yych <= \'-\' ) goto yy18 ;goto yy69 ;}else {if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy46 ;goto yy18 ;}}else {if ( yych <= \'E\' ) {if ( yych <= \';\' ) goto yy71 ;if ( yych <= \'D\' ) goto yy18 ;goto yy73 ;}else {if ( yych == \'e\' ) goto yy73 ;goto yy18 ;}}yy48 : yych = * ++ YYCURSOR ;if ( yych == \'N\' ) goto yy74 ;goto yy18 ;yy49 : yych = * ++ YYCURSOR ;if ( yych == \'A\' ) goto yy75 ;goto yy18 ;yy50 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy51 : ++ YYCURSOR ;if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy51 ;if ( yych == \';\' ) goto yy76 ;goto yy18 ;yy53 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy54 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy54 ;if ( yych <= \':\' ) goto yy78 ;goto yy18 ;yy56 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy57 : ++ YYCURSOR ;if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy57 ;if ( yych == \';\' ) goto yy79 ;goto yy18 ;yy59 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy60 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy60 ;if ( yych <= \':\' ) goto yy81 ;goto yy18 ;yy62 : yych = * ++ YYCURSOR ;if ( yych == \\\'""\\\' ) goto yy82 ;goto yy18 ;yy63 : ++ YYCURSOR ;# line 580 ""ext/standard/var_unserializer.re"" {zend_long id ;* p = YYCURSOR ;if ( ! var_hash ) return 0 ;if ( * start == \'C\' ) {custom_object = 1 ;}len2 = len = parse_uiv ( start + 2 ) ;maxlen = max - YYCURSOR ;if ( maxlen < len || len == 0 ) {* p = start + 2 ;return 0 ;id = parse_iv ( start + 2 ) ;* p = YYCURSOR ;",1110
365,"# line 959 ""ext/standard/var_unserializer.c""  yy39 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy40 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy41 ;goto yy18 ;","# line 959 ""ext/standard/var_unserializer.c"" yy39 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy40 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy41 ;goto yy18 ;",1110
366,"# line 735 ""ext/standard/var_unserializer.re""  {","# line 735 ""ext/standard/var_unserializer.re"" {",1110
367,"ZVAL_LONG ( rval , parse_iv ( start + 2 ) ) ;# line 1292 ""ext/standard/var_unserializer.c""  yy83 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \'2\' ) goto yy18 ;yych = * ++ YYCURSOR ;if ( yych != \';\' ) goto yy18 ;++ YYCURSOR ;# line 646 ""ext/standard/var_unserializer.re""  {ZVAL_BOOL ( rval , parse_iv ( start + 2 ) ) ;return 1 ;# line 1306 ""ext/standard/var_unserializer.c""  yy87 : ++ YYCURSOR ;# line 640 ""ext/standard/var_unserializer.re""  {# line 1315 ""ext/standard/var_unserializer.c"" yy89 : yych = * ++ YYCURSOR ;if ( yych <= \',\' ) {if ( yych != \'+\' ) goto yy18 ;}else {if ( yych <= \'-\' ) goto yy90 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy91 ;goto yy18 ;}yy90 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy91 : ++ YYCURSOR ;","ZVAL_LONG ( rval , parse_iv ( start + 2 ) - 1 ;if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) {return 0 ;}if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) {return 0 ;}if ( Z_ISREF_P ( rval_ref ) ) {ZVAL_COPY ( rval , rval_ref ) ;}else {ZVAL_NEW_REF ( rval_ref , rval_ref ) ;ZVAL_COPY ( rval , rval_ref ) ;}+ YYCURSOR ;# line 982 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ;if ( yych == \\\'""\\\' ) goto yy84 ;goto yy18 ;yy66 : yych = * ++ YYCURSOR ;if ( yych == \'{\' ) goto yy86 ;goto yy18 ;yy67 : ++ YYCURSOR ;# line 635 ""ext/standard/var_unserializer.re"" {ZVAL_BOOL ( rval , parse_iv ( YYCURSOR ;ZVAL_BOOL ( rval , parse_iv ( start + 2 ) ) ;return 1 ;# line 1306 ""ext/standard/var_unserializer.c"" yy87 : ++ YYCURSOR ;# line 640 ""ext/standard/var_unserializer.re"" {# line 999 ""ext/standard/var_unserializer.c"" yy69 : ++ YYCURSOR ;",1110
368,"id = parse_iv ( start + 2 ) - 1 ;if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) {","id = parse_iv ( start + 2 ) - 1 ;if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) {",1110
369,"if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ;if ( yych <= \'9\' ) goto yy97 ;if ( yych != \';\' ) goto yy18 ;++ YYCURSOR ;# line 589 ""ext/standard/var_unserializer.re"" {zend_long id ;* p = YYCURSOR ;if ( ! var_hash ) return 0 ;id = parse_iv ( start + 2 ) - 1 ;if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) {return 0 ;zval_ptr_dtor ( rval ) ;if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) {ZVAL_UNDEF ( rval ) ;return 1 ;if ( Z_ISREF_P ( rval_ref ) ) {ZVAL_COPY ( rval , rval_ref ) ;}ZVAL_NEW_REF ( rval_ref , rval_ref ) ;ZVAL_COPY ( rval , rval_ref ) ;}# line 1412 ""ext/standard/var_unserializer.c""  }","if ( YYLIMIT <= YYCURSOR ) YYFILL ( 4 ) ;if ( yych <= \';\' ) {+ YYCURSOR ;if ( yych <= \'9\' ) goto yy69 ;if ( yych <= \':\' ) goto yy18 ;else {if ( yych <= \'E\' ) {if ( yych <= \'D\' ) goto yy18 ;goto yy73 ;if ( yych == \'e\' ) goto yy73 ;goto yy18 ;}}yy71 : ++ YYCURSOR ;# line 683 ""ext/standard/var_unserializer.re"" {# if SIZEOF_ZEND_LONG == 4 use_double : # endif * p = YYCURSOR ;ZVAL_DOUBLE ( rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ;# line 1412 ""ext/standard/var_unserializer.c"" }",1110
370,"}if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) ||  ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) {dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\\return ;","
",1111
371,"umode_t mode = inode -> i_mode ;error = posix_acl_equiv_mode ( acl , & mode ) ;if ( error < 0 ) {gossip_err ( ""%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\\if ( error == 0 )  acl = NULL ;","umode_t mode ;error = posix_acl_update_mode ( inode , & mode ) ;if ( error < 0 ) {gossip_err ( ""%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\\",1112
372,"FILE * file = fopen ( dump_file , ""w"" ) ;if ( ! file ) {","FILE * file = fopen_safe ( dump_file , ""w"" ) ;if ( ! file ) {",1113
373,"if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ||  uid_eq ( root_uid , current_uid ( ) ) ) {int mode = ( table -> mode >> 6 ) & 7 ;if ( gid_eq ( root_gid , current_gid ( ) ) ) {int mode = ( table -> mode >> 3 ) & 7 ;","if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || uid_eq ( root_uid , current_euid ( ) ) ) {int mode = ( table -> mode >> 6 ) & 7 ;if ( in_egroup_p ( root_gid ) ) {int mode = ( table -> mode >> 3 ) & 7 ;",1114
374,# ifdef KEY_DEBUGGING  key -> magic = KEY_DEBUG_MAGIC ;,if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;# ifdef KEY_DEBUGGING key -> magic = KEY_DEBUG_MAGIC ;,1115
375,"int64_t vp9_rd_pick_inter_mode_sub8x8 ( VP9_COMP * cpi , MACROBLOCK * x ,   const TileInfo * const tile ,  int mi_row , int mi_col ,  int * returnrate ,  int64_t * returndistortion , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd_so_far ) {VP9_COMMON * cm = & cpi -> common ;MACROBLOCKD * xd = & x -> e_mbd ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;const struct segmentation * seg = & cm -> seg ;MV_REFERENCE_FRAME ref_frame , second_ref_frame ;","void vp9_rd_pick_inter_mode_sub8x8 ( VP9_COMP * cpi , TileDataEnc * tile_data , MACROBLOCK * x , int mi_row , int mi_col , int * returnrate , int64_t * returndistortion , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd_so_far ) {VP9_COMMON * const cm = & cpi -> common ;RD_OPT * const rd_opt = & cpi -> rd ;SPEED_FEATURES * const sf = & cpi -> sf ;MACROBLOCKD * const xd = & x -> e_mbd ;MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;const struct segmentation * const seg = & cm -> seg ;MV_REFERENCE_FRAME ref_frame , second_ref_frame ;",1116
376,"int64_t best_yrd = best_rd_so_far ;int64_t best_tx_rd [ TX_MODES ] ;int64_t best_tx_diff [ TX_MODES ] ;MB_MODE_INFO best_mbmode = {0 };int mode_index , best_mode_index = 0 ;vp9_prob comp_mode_p ;int64_t best_inter_rd = INT64_MAX ;MV_REFERENCE_FRAME best_inter_ref_frame = LAST_FRAME ;int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ TX_SIZES ] ;int64_t dist_uv [ TX_SIZES ] ;int skip_uv [ TX_SIZES ] ;MB_PREDICTION_MODE mode_uv [ TX_SIZES ] = {int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ;int_mv seg_mvs [ 4 ] [ MAX_REF_FRAMES ] ;int ref_frame_mask = 0 ;int mode_skip_mask = 0 ;x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ;vpx_memset ( x -> zcoeff_blk [ TX_4X4 ] , 0 , 4 ) ;for ( i = 0 ;","MB_MODE_INFO best_mbmode ;int ref_index , best_ref_index = 0 ;vpx_prob comp_mode_p ;int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ TX_SIZES ] ;int64_t dist_uv ;int skip_uv [ TX_SIZES ] ;MB_PREDICTION_MODE mode_uv [ TX_SIZES ] = {int intra_cost_penalty = vp9_get_intra_cost_penalty ( cm -> base_qindex , cm -> y_dc_delta_q , cm -> bit_depth ) ;int_mv seg_mvs [ 4 ] [ MAX_REF_FRAMES ] ;int ref_frame_skip_mask [ 2 ] = {0 };int64_t mask_filter = 0 ;int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ;int internal_active_edge = vp9_active_edge_sb ( cpi , mi_row , mi_col ) && vp9_internal_image_edge ( cpi ) ;x -> skip_encode = sf -> skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ;memset ( x -> zcoeff_blk [ TX_4X4 ] , 0 , 4 ) ;vp9_zero ( best_mbmode ) ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;++ i ) filter_cache [ i ] = INT64_MAX ;for ( i = 0 ;",1116
377,"estimate_ref_frame_costs ( cpi , segment_id , ref_costs_single , ref_costs_comp ,  & comp_mode_p ) ;i < REFERENCE_MODES ;++ i ) best_pred_rd [ i ] = INT64_MAX ;for ( i = 0 ;i < TX_MODES ;i ++ )   best_tx_rd [ i ] = INT64_MAX ;for ( i = 0 ;i ++ )  best_filter_rd [ i ] = INT64_MAX ;i ++ ) rate_uv_intra [ i ] = INT_MAX ;* returnrate = INT_MAX ;for ( ref_frame = LAST_FRAME ;vp9_setup_buffer_inter ( cpi , x , tile ,  ref_frame , bsize , mi_row , mi_col , frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ;frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ;frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ;","estimate_ref_frame_costs ( cm , xd , segment_id , ref_costs_single , ref_costs_comp , & comp_mode_p ) ;+ i ) best_pred_rd [ i ] = INT64_MAX ;i ++ ) best_tx_rd [ i ] = INT64_MAX ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;i ++ ) best_filter_rd [ i ] = INT64_MAX ;i ++ ) best_filter_rd [ i ] = INT_MAX ;* returnrate = INT_MAX ;for ( ref_frame = LAST_FRAME ;vp9_setup_buffer_inter ( cpi , x , tile , ref_frame , bsize , mi_row , mi_col , frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ;frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ;frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ;",1116
378,"break ;}for ( mode_index = 0 ;int mode_excluded = 0 ;int disable_skip = 0 ;int compmode_cost = 0 ;int rate2 = 0 , rate_y = 0 , rate_uv = 0 ;int64_t distortion2 = 0 , distortion_y = 0 , distortion_uv = 0 ;int skippable = 0 ;int64_t tx_cache [ TX_MODES ] ;int i ;int this_skip2 = 0 ;int64_t total_sse = INT_MAX ;for ( i = 0 ;++ i )  tx_cache [ i ] = INT64_MAX ;ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 0 ] ;second_ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 1 ] ;if ( mode_index > 2 && cpi -> sf . mode_skip_start < MAX_MODES ) {if ( mode_index == 3 ) {switch ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] ) {case INTRA_FRAME :  mode_skip_mask = 0 ;break ;case LAST_FRAME :  mode_skip_mask = 0x0010 ;break ;case GOLDEN_FRAME :  mode_skip_mask = 0x0008 ;break ;case ALTREF_FRAME :  mode_skip_mask = 0x0000 ;break ;}}if ( mode_skip_mask & ( 1 << mode_index ) )  continue ;}if ( ( best_rd <  ( ( int64_t ) cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] *   cpi -> rd_thresh_freq_sub8x8 [ bsize ] [ mode_index ] >> 5 ) ) ||  cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] == INT_MAX ) continue ;if ( ( second_ref_frame > INTRA_FRAME ) &&  vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ;mbmi -> ref_frame [ 0 ] = ref_frame ;mbmi -> ref_frame [ 1 ] = second_ref_frame ;comp_pred = second_ref_frame > INTRA_FRAME ;if ( comp_pred ) {set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ;mbmi -> uv_mode = DC_PRED ;if ( comp_pred ) {if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ;","break ;}for ( mode_index = 0 ;int mode_excluded = 0 ;rate_uv_intra = INT_MAX ;for ( i = 0 ;+ i )  tx_cache [ i ] = INT64_MAX ;++ i ) tx_cache [ i ] = INT64_MAX ;ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 0 ] ;second_ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 1 ] ;if ( mode_index > 2 && cpi -> sf . mode_skip_start < MAX_MODES ) {if ( mode_index == 3 ) {switch ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] ) {case INTRA_FRAME : mode_skip_mask = 0 ;break ;case LAST_FRAME : mode_skip_mask = 0x0010 ;break ;case GOLDEN_FRAME : mode_skip_mask = 0x0008 ;break ;case ALTREF_FRAME : mode_skip_mask = 0x0000 ;break ;}}if ( mode_skip_mask & ( 1 << mode_index ) ) continue ;}if ( ( best_rd < ( ( int64_t ) cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] * cpi -> rd_thresh_freq_sub8x8 [ bsize ] [ mode_index ] >> 5 ) ) || cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] == INT_MAX ) continue ;if ( ( second_ref_frame > INTRA_FRAME ) && vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ;mbmi -> ref_frame [ 0 ] = ref_frame ;mbmi -> ref_frame [ 1 ] = second_ref_frame ;comp_pred = second_ref_frame > INTRA_FRAME ;if ( comp_pred ) {set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ;mbmi -> uv_mode = DC_PRED ;if ( comp_pred ) {if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ;",1116
379,"if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) &&  vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) {","if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) {",1116
380,"mbmi -> tx_size = TX_4X4 ;if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate , & rate_y , & distortion_y , best_rd ) >= best_rd ) continue ;if ( rate_uv_intra [ TX_4X4 ] == INT_MAX ) {choose_intra_uv_mode ( cpi , ctx , bsize , TX_4X4 ,   & rate_uv_intra [ TX_4X4 ] ,   & rate_uv_tokenonly [ TX_4X4 ] ,   & dist_uv [ TX_4X4 ] , & skip_uv [ TX_4X4 ] ,   & mode_uv [ TX_4X4 ] ) ;}rate2 += rate_uv_intra [ TX_4X4 ] ;rate_uv = rate_uv_tokenonly [ TX_4X4 ] ;distortion2 += dist_uv [ TX_4X4 ] ;distortion_uv = dist_uv [ TX_4X4 ] ;mbmi -> uv_mode = mode_uv [ TX_4X4 ] ;tx_cache [ ONLY_4X4 ] = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;","mbmi -> tx_size = TX_4X4 ;if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate , & rate_y , & distortion_y , best_rd ) >= best_rd ) continue ;if ( rate_uv_intra [ TX_4X4 ] == INT_MAX ) {choose_intra_uv_mode ( cpi , ctx , bsize , TX_4X4 , & rate_uv_intra [ TX_4X4 ] , & rate_uv_tokenonly [ TX_4X4 ] , & dist_uv [ TX_4X4 ] , & skip_uv [ TX_4X4 ] , & mode_uv [ TX_4X4 ] ) ;}rate2 += rate_uv_intra [ TX_4X4 ] ;rate_uv = rate_uv_tokenonly [ TX_4X4 ] ;distortion2 += dist_uv [ TX_4X4 ] ;distortion_uv = dist_uv [ TX_4X4 ] ;mbmi -> uv_mode = mode_uv [ TX_4X4 ] ;tx_cache [ ONLY_4X4 ] = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;",1116
381,"int64_t tmp_best_distortion = INT_MAX , tmp_best_sse , uv_sse ;int tmp_best_skippable = 0 ;int switchable_filter_index ;int_mv * second_ref = comp_pred ?  & mbmi -> ref_mvs [ second_ref_frame ] [ 0 ] : NULL ;b_mode_info tmp_best_bmodes [ 16 ] ;MB_MODE_INFO tmp_best_mbmode ;BEST_SEG_INFO bsi [ SWITCHABLE_FILTERS ] ;int pred_exists = 0 ;int uv_skippable ;this_rd_thresh = ( ref_frame == LAST_FRAME ) ?  cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_LAST ] :   cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_ALTR ] ;this_rd_thresh = ( ref_frame == GOLDEN_FRAME ) ?  cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_GOLD ] : this_rd_thresh ;xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ;cpi -> mask_filter_rd = 0 ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;++ i )  cpi -> rd_filter_cache [ i ] = INT64_MAX ;if ( cm -> interp_filter != BILINEAR ) {tmp_best_filter = EIGHTTAP ;if ( x -> source_variance <  cpi -> sf . disable_filter_search_var_thresh ) {tmp_best_filter = EIGHTTAP ;}else if ( cpi -> sf . adaptive_pred_interp_filter == 1 &&  ctx -> pred_interp_filter < SWITCHABLE ) {tmp_best_filter = ctx -> pred_interp_filter ;}else if ( cpi -> sf . adaptive_pred_interp_filter == 2 ) {tmp_best_filter = ctx -> pred_interp_filter < SWITCHABLE ? ctx -> pred_interp_filter : 0 ;}else {for ( switchable_filter_index = 0 ;switchable_filter_index < SWITCHABLE_FILTERS ;++ switchable_filter_index ) {int newbest , rs ;int64_t rs_rd ;mbmi -> interp_filter = switchable_filter_index ;tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile ,  & mbmi -> ref_mvs [ ref_frame ] [ 0 ] , second_ref , best_yrd , & rate , & rate_y , & distortion , & skippable , & total_sse , ( int ) this_rd_thresh , seg_mvs , bsi , switchable_filter_index , mi_row , mi_col ) ;if ( tmp_rd == INT64_MAX ) continue ;rs = vp9_get_switchable_rate ( x ) ;rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ;cpi -> rd_filter_cache [ switchable_filter_index ] = tmp_rd ;cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] =   MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] ,  tmp_rd + rs_rd ) ;if ( cm -> interp_filter == SWITCHABLE ) tmp_rd += rs_rd ;cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , tmp_rd ) ;newbest = ( tmp_rd < tmp_best_rd ) ;if ( newbest ) {tmp_best_filter = mbmi -> interp_filter ;tmp_best_rd = tmp_rd ;}if ( ( newbest && cm -> interp_filter == SWITCHABLE ) || ( mbmi -> interp_filter == cm -> interp_filter && cm -> interp_filter != SWITCHABLE ) ) {tmp_best_rdu = tmp_rd ;tmp_best_rate = rate ;tmp_best_ratey = rate_y ;tmp_best_distortion = distortion ;tmp_best_sse = total_sse ;tmp_best_skippable = skippable ;tmp_best_mbmode = * mbmi ;for ( i = 0 ;i < 4 ;i ++ ) {tmp_best_bmodes [ i ] = xd -> mi [ 0 ] -> bmi [ i ] ;x -> zcoeff_blk [ TX_4X4 ] [ i ] = ! x -> plane [ 0 ] . eobs [ i ] ;}pred_exists = 1 ;if ( switchable_filter_index == 0 &&  cpi -> sf . use_rd_breakout &&  best_rd < INT64_MAX ) {if ( tmp_best_rdu / 2 > best_rd ) {tmp_best_filter = mbmi -> interp_filter ;tmp_best_rdu = INT64_MAX ;break ;}}}}}}if ( tmp_best_rdu == INT64_MAX && pred_exists ) continue ;mbmi -> interp_filter = ( cm -> interp_filter == SWITCHABLE ? tmp_best_filter : cm -> interp_filter ) ;if ( ! pred_exists ) {tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile ,  & mbmi -> ref_mvs [ ref_frame ] [ 0 ] , second_ref , best_yrd , & rate , & rate_y , & distortion , & skippable , & total_sse , ( int ) this_rd_thresh , seg_mvs , bsi , 0 , mi_row , mi_col ) ;if ( tmp_rd == INT64_MAX ) continue ;else {total_sse = tmp_best_sse ;rate = tmp_best_rate ;rate_y = tmp_best_ratey ;distortion = tmp_best_distortion ;skippable = tmp_best_skippable ;* mbmi = tmp_best_mbmode ;for ( i = 0 ;i < 4 ;i ++ ) xd -> mi [ 0 ] -> bmi [ i ] = tmp_best_bmodes [ i ] ;}rate2 += rate ;distortion2 += distortion ;if ( cm -> interp_filter == SWITCHABLE )  rate2 += vp9_get_switchable_rate ( x ) ;if ( ! mode_excluded ) mode_excluded = comp_pred ? cm -> reference_mode == SINGLE_REFERENCE : cm -> reference_mode == COMPOUND_REFERENCE ;compmode_cost = vp9_cost_bit ( comp_mode_p , comp_pred ) ;tmp_best_rdu = best_rd - MIN ( RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) , RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) ;if ( tmp_best_rdu > 0 ) {vp9_build_inter_predictors_sbuv ( & x -> e_mbd , mi_row , mi_col , BLOCK_8X8 ) ;super_block_uvrd ( cpi , x , & rate_uv , & distortion_uv , & uv_skippable ,   & uv_sse , BLOCK_8X8 , tmp_best_rdu ) ;if ( rate_uv == INT_MAX ) continue ;rate2 += rate_uv ;distortion2 += distortion_uv ;skippable = skippable && uv_skippable ;total_sse += uv_sse ;tx_cache [ ONLY_4X4 ] = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;for ( i = 0 ;i < TX_MODES ;++ i ) tx_cache [ i ] = tx_cache [ ONLY_4X4 ] ;}}if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) rate2 += compmode_cost ;if ( second_ref_frame > INTRA_FRAME ) {rate2 += ref_costs_comp [ ref_frame ] ;}else {rate2 += ref_costs_single [ ref_frame ] ;}if ( ! disable_skip ) {const int mb_skip_allowed = ! vp9_segfeature_active ( seg , segment_id ,  SEG_LVL_SKIP ) ;if ( mb_skip_allowed && ref_frame != INTRA_FRAME && ! xd -> lossless ) {if ( RDCOST ( x -> rdmult , x -> rddiv , rate_y + rate_uv , distortion2 ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) {rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;}else {rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;distortion2 = total_sse ;assert ( total_sse >= 0 ) ;rate2 -= ( rate_y + rate_uv ) ;rate_y = 0 ;rate_uv = 0 ;this_skip2 = 1 ;}}else if ( mb_skip_allowed ) {rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;}this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;}if ( is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) && ! has_second_ref ( & xd -> mi [ 0 ] -> mbmi ) && ! mode_excluded && this_rd < best_inter_rd ) {best_inter_rd = this_rd ;best_inter_ref_frame = ref_frame ;}if ( ! disable_skip && ref_frame == INTRA_FRAME ) {for ( i = 0 ;i < REFERENCE_MODES ;++ i ) best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;i ++ ) best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , this_rd ) ;}if ( this_rd < best_rd || x -> skip ) {if ( ! mode_excluded ) {int max_plane = MAX_MB_PLANE ;best_mode_index = mode_index ;if ( ref_frame == INTRA_FRAME ) {mbmi -> mv [ 0 ] . as_int = 0 ;max_plane = 1 ;}* returnrate = rate2 ;* returndistortion = distortion2 ;best_rd = this_rd ;best_yrd = best_rd - RDCOST ( x -> rdmult , x -> rddiv , rate_uv , distortion_uv ) ;best_mbmode = * mbmi ;best_skip2 = this_skip2 ;if ( ! x -> select_txfm_size )   swap_block_ptr ( x , ctx , max_plane ) ;vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] ,   sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ;for ( i = 0 ;i < 4 ;i ++ ) best_bmodes [ i ] = xd -> mi [ 0 ] -> bmi [ i ] ;if ( ( cpi -> sf . mode_search_skip_flags & FLAG_EARLY_TERMINATE ) &&   ( mode_index > MIN_EARLY_TERM_INDEX ) ) {const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ;int scale = 4 ;if ( x -> source_variance < UINT_MAX ) {const int var_adjust = ( x -> source_variance < 16 ) ;scale -= var_adjust ;}if ( ref_frame > INTRA_FRAME && distortion2 * scale < qstep * qstep ) {early_term = 1 ;}}}}if ( ! disable_skip && ref_frame != INTRA_FRAME ) {int64_t single_rd , hybrid_rd , single_rate , hybrid_rate ;if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {single_rate = rate2 - compmode_cost ;hybrid_rate = rate2 ;}else {single_rate = rate2 ;hybrid_rate = rate2 + compmode_cost ;}single_rd = RDCOST ( x -> rdmult , x -> rddiv , single_rate , distortion2 ) ;hybrid_rd = RDCOST ( x -> rdmult , x -> rddiv , hybrid_rate , distortion2 ) ;if ( second_ref_frame <= INTRA_FRAME &&   single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) {best_pred_rd [ SINGLE_REFERENCE ] = single_rd ;}else if ( second_ref_frame > INTRA_FRAME &&   single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) {best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ;}if ( hybrid_rd < best_pred_rd [ REFERENCE_MODE_SELECT ] ) best_pred_rd [ REFERENCE_MODE_SELECT ] = hybrid_rd ;}if ( ! mode_excluded && ! disable_skip && ref_frame != INTRA_FRAME && cm -> interp_filter != BILINEAR ) {int64_t ref = cpi -> rd_filter_cache [ cm -> interp_filter == SWITCHABLE ?  SWITCHABLE_FILTERS : cm -> interp_filter ] ;int64_t adj_rd ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;i ++ ) {if ( ref == INT64_MAX ) adj_rd = 0 ;else if ( cpi -> rd_filter_cache [ i ] == INT64_MAX )   adj_rd = cpi -> mask_filter_rd - ref + 10 ;else  adj_rd = cpi -> rd_filter_cache [ i ] - ref ;adj_rd += this_rd ;best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , adj_rd ) ;}}if ( bsize < BLOCK_32X32 ) {if ( bsize < BLOCK_16X16 ) {tx_cache [ ALLOW_8X8 ] = tx_cache [ ONLY_4X4 ] ;tx_cache [ ALLOW_16X16 ] = tx_cache [ ALLOW_8X8 ] ;}tx_cache [ ALLOW_32X32 ] = tx_cache [ ALLOW_16X16 ] ;}if ( ! mode_excluded && this_rd != INT64_MAX ) {for ( i = 0 ;i < TX_MODES && tx_cache [ i ] < INT64_MAX ;i ++ ) {int64_t adj_rd = INT64_MAX ;if ( ref_frame > INTRA_FRAME ) adj_rd = this_rd + tx_cache [ i ] - tx_cache [ cm -> tx_mode ] ;else adj_rd = this_rd ;if ( adj_rd < best_tx_rd [ i ] ) best_tx_rd [ i ] = adj_rd ;}}if ( early_term ) break ;if ( x -> skip && ! comp_pred ) break ;}if ( best_rd >= best_rd_so_far )  return INT64_MAX ;if ( cpi -> sf . use_uv_intra_rd_estimate ) {if ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) {TX_SIZE uv_tx_size ;* mbmi = best_mbmode ;uv_tx_size = get_uv_tx_size ( mbmi ) ;rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra [ uv_tx_size ] ,   & rate_uv_tokenonly [ uv_tx_size ] ,   & dist_uv [ uv_tx_size ] ,   & skip_uv [ uv_tx_size ] ,   BLOCK_8X8 , uv_tx_size ) ;}}if ( best_rd == INT64_MAX && bsize < BLOCK_8X8 ) {* returnrate = INT_MAX ;* returndistortion = INT64_MAX ;return best_rd ;}if ( cpi -> sf . adaptive_rd_thresh ) {for ( mode_index = 0 ;","+ i )  cpi -> rd_filter_cache [ i ] = INT64_MAX ;+ switchable_filter_index ) {rd_cost -> rate = INT_MAX ;* returndistortion = INT64_MAX ;return best_rd ;+ i ) tx_cache [ i ] = tx_cache [ ONLY_4X4 ] ;+ i ) best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ;if ( cpi -> sf . adaptive_rd_thresh ) {for ( mode_index = 0 ;",1116
382,"++ i )  vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ;mbmi -> mv [ 0 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 0 ] . as_int ;","+ i )  vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ;++ i ) vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ;mbmi -> mv [ 0 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 0 ] . as_int ;",1116
383,if ( ! x -> skip ) {for ( i = 0 ;,if ( ! x -> skip ) {for ( i = 0 ;,1116
384,"store_coding_context ( x , ctx , best_mode_index ,  & mbmi -> ref_mvs [ mbmi -> ref_frame [ 0 ] ] [ 0 ] , & mbmi -> ref_mvs [ mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] ] [ 0 ] ,  best_pred_diff , best_tx_diff , best_filter_diff ) ;return best_rd ;","store_coding_context ( x , ctx , 1 , 0 , 0 , best_mode_index , & mbmi -> ref_mvs [ mbmi -> ref_frame [ 0 ] ] [ 0 ] , & mbmi -> ref_mvs [ mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] ] [ 0 ] , best_pred_diff , best_filter_diff , 0 ) ;",1116
385,the_url [ sizeof ( the_cfg ) - 1 ] = 0 ;},the_url [ sizeof ( the_cfg ) - 1 ] = 0 ;},1117
386,else {err = - EINVAL ;goto out ;}}else {* policy = pol == & default_policy ? MPOL_DEFAULT : pol -> mode ;* policy |= ( pol -> flags & MPOL_MODE_FLAGS ) ;}if ( vma ) {up_read ( & current -> mm -> mmap_sem ) ;vma = NULL ;},"
",1118
387,"return ;}switch ( ( gdAffineStandardMatrix ) type ) {case GD_AFFINE_TRANSLATE : case GD_AFFINE_SCALE : {double x , y ;if ( Z_TYPE_P ( options ) != IS_ARRAY ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Array<S2SV_blank>expected<S2SV_blank>as<S2SV_blank>options"" ) ;}if ( zend_hash_find ( HASH_OF ( options ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) {convert_to_double_ex ( tmp ) ;x = Z_DVAL_PP ( tmp ) ;}convert_to_double_ex ( tmp ) ;y = Z_DVAL_PP ( tmp ) ;}",if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;x = Z_DVAL ( dval ) ;}else {x = Z_DVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;y = Z_DVAL ( dval ) ;}else {y = Z_DVAL_PP ( tmp ) ;}},1119
388,L -> oldpc = pc + 1 ;},L -> oldpc = 1 ;},1120
389,int64_t off = s -> off ;int len = 0 ;,uint64_t off = s -> off ;int len = 0 ;,1121
390,"len += av_strlcatf ( headers + len , sizeof ( headers ) - len ,  ""Range:<S2SV_blank>bytes=%"" PRId64 ""-"" , s -> off ) ;if ( s -> end_off ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""%"" PRId64 , s -> end_off - 1 ) ;","len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""Range:<S2SV_blank>bytes=%"" PRIu64 ""-"" , s -> off ) ;if ( s -> end_off ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""%"" PRId64 , s -> end_off - 1 ) ;",1121
391,s -> filesize = - 1 ;s -> willclose = 0 ;,s -> filesize = UINT64_MAX ;s -> willclose = 0 ;,1121
392,"uint_fast32_t rawsize ;uint_fast32_t inmem ;if ( ! ( image = jas_image_create0 ( ) ) ) {return 0 ;}image -> inmem_ = true ;if ( ! ( image -> cmpts_ = jas_alloc2 ( image -> maxcmpts_ , sizeof ( jas_image_cmpt_t * ) ) ) ) {jas_image_destroy ( image ) ;return 0 ;}rawsize = 0 ;for ( cmptno = 0 , cmptparm = cmptparms ;++ cmptno ,   ++ cmptparm ) {if ( ! ( image -> cmpts_ [ cmptno ] = jas_image_cmpt_create ( cmptparm -> tlx , cmptparm -> tly , cmptparm -> hstep , cmptparm -> vstep , cmptparm -> width , cmptparm -> height , cmptparm -> prec , cmptparm -> sgnd , inmem ) ) ) {jas_image_destroy ( image ) ;return 0 ;}++ image -> numcmpts_ ;}","size_t rawsize ;uint_fast32_t inmem ;image = 0 ;JAS_DBGLOG ( 100 , ( ""jas_image_create(%d,<S2SV_blank>%p,<S2SV_blank>%d)\\\if ( ! ( image = jas_image_create0 ( ) ) ) {goto error ;}if ( ! ( image -> cmpts_ = jas_alloc2 ( image -> maxcmpts_ , sizeof ( jas_image_cmpt_t * ) ) ) ) {goto error ;}# if 0 rawsize = 0 ;# endif for ( cmptno = 0 , cmptparm = cmptparms ;+ cmptno ,   ++ cmptparm ) {+ image -> numcmpts_ ;++ cmptno , ++ cmptparm ) {if ( ! jas_safe_size_mul3 ( cmptparm -> width , cmptparm -> height , ( cmptparm -> prec + 7 ) , & rawsize ) ) {goto error ;}++ image -> numcmpts_ ;}}error : if ( image ) {goto error ;}rawsize /= 8 ;inmem = ( rawsize < JAS_IMAGE_INMEMTHRESH ) ;if ( ! ( image -> cmpts_ [ cmptno ] = jas_image_cmpt_create ( cmptparm -> tlx , cmptparm -> tly , cmptparm -> hstep , cmptparm -> vstep , cmptparm -> width , cmptparm -> height , cmptparm -> prec , cmptparm -> sgnd , inmem ) ) ) {jas_image_destroy ( image ) ;return 0 ;",1122
393,unsigned int i ;cmap -> numchans = ( box -> datalen ) / 4 ;,unsigned int i ;cmap -> ents = 0 ;cmap -> numchans = ( box -> datalen ) / 4 ;,1123
394,"if ( client -> priv -> conn != NULL ) {SmsCleanUp ( client -> priv -> conn ) ;}if ( client -> priv -> ice_connection != NULL ) {IceSetShutdownNegotiation ( client -> priv -> ice_connection , FALSE ) ;IceCloseConnection ( client -> priv -> ice_connection ) ;}if ( client -> priv -> protocol_timeout > 0 ) {g_source_remove ( client -> priv -> protocol_timeout ) ;}","
",1124
395,"VP9_COMMON * const cm = & ctx -> pbi -> common ;cm -> new_fb_idx = - 1 ;if ( ctx -> get_ext_fb_cb != NULL && ctx -> release_ext_fb_cb != NULL ) {cm -> get_fb_cb = ctx -> get_ext_fb_cb ;cm -> release_fb_cb = ctx -> release_ext_fb_cb ;cm -> cb_priv = ctx -> ext_priv ;}cm -> get_fb_cb = vp9_get_frame_buffer ;cm -> release_fb_cb = vp9_release_frame_buffer ;if ( vp9_alloc_internal_frame_buffers ( & cm -> int_frame_buffers ) )  vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>internal<S2SV_blank>frame<S2SV_blank>buffers"" ) ;cm -> cb_priv = & cm -> int_frame_buffers ;}}","int i ;for ( i = 0 ;i < ctx -> num_frame_workers ;++ i ) {VPxWorker * const worker = & ctx -> frame_workers [ i ] ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;VP9_COMMON * const cm = & frame_worker_data -> pbi -> common ;BufferPool * const pool = cm -> buffer_pool ;cm -> new_fb_idx = INVALID_IDX ;cm -> byte_alignment = ctx -> byte_alignment ;cm -> skip_loop_filter = ctx -> skip_loop_filter ;if ( ctx -> get_ext_fb_cb != NULL && ctx -> release_ext_fb_cb != NULL ) {pool -> get_fb_cb = ctx -> get_ext_fb_cb ;pool -> release_fb_cb = ctx -> release_ext_fb_cb ;pool -> cb_priv = ctx -> ext_priv ;}pool -> get_fb_cb = vp9_get_frame_buffer ;cm -> release_fb_cb = vp9_release_frame_buffer ;if ( vp9_alloc_internal_frame_buffers ( & pool -> int_frame_buffers ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>internal<S2SV_blank>frame<S2SV_blank>buffers"" ) ;pool -> cb_priv = & cm -> int_frame_buffers ;}}}",1125
396,"static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName ,   int udfLen , uint8_t * fidName ,  int fidNameLen ) {","static int udf_translate_to_linux ( uint8_t * newName , int newLen , uint8_t * udfName , int udfLen , uint8_t * fidName , int fidNameLen ) {",1126
397,if ( newIndex < 256 )  newName [ newIndex ++ ] = curr ;,if ( newIndex < newLen ) newName [ newIndex ++ ] = curr ;,1126
398,maxFilenameLen = 250 - localExtIndex ;if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ;else newIndex = newExtIndex ;}else if ( newIndex > 250 )  newIndex = 250 ;,maxFilenameLen = newLen - CRC_LEN - localExtIndex ;if ( newIndex > newLen - CRC_LEN ) newIndex = newLen - CRC_LEN ;,1126
399,"hw_init ( LOW_FREQUENCY ) ;if ( ! tsc_sensor_exists ( ) ) {if ( _NFC_status == NFC_IS_ACTIVE ) {printf1 ( TAG_NFC , ""Have<S2SV_blank>NFC\\\\r\\\isLowFreq = 1 ;IS_BUTTON_PRESSED = is_physical_button_pressed ;}else {printf1 ( TAG_NFC , ""Have<S2SV_blank>NO<S2SV_blank>NFC\\\\r\\\hw_init ( HIGH_FREQUENCY ) ;isLowFreq = 0 ;device_init_button ( ) ;}usbhid_init ( ) ;ctaphid_init ( ) ;ctap_init ( ) ;device_migrate ( ) ;# if BOOT_TO_DFU  flash_option_bytes_init ( 1 ) ;# else flash_option_bytes_init ( 0 ) ;# endif }",hw_init ( LOW_FREQUENCY ) ;# if BOOT_TO_DFU flash_option_bytes_init ( 1 ) ;# else flash_option_bytes_init ( 0 ) ;# endif if ( ! tsc_sensor_exists ( ) ) {,1127
400,"status = ocfs2_rw_lock ( inode , 1 ) ;if ( status < 0 ) {","inode_dio_wait ( inode ) ;status = ocfs2_rw_lock ( inode , 1 ) ;if ( status < 0 ) {",1128
401,if ( status )  goto bail_unlock ;inode_dio_wait ( inode ) ;,if ( status ) goto bail_unlock ;,1128
402,"static void sas_destruct_devices ( struct work_struct * work )  {struct domain_device * dev , * n ;struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ;struct asd_sas_port * port = ev -> port ;clear_bit ( DISCE_DESTRUCT , & port -> disc . pending ) ;","void sas_destruct_devices ( struct work_struct * work ) {struct domain_device * dev , * n ;",1129
403,while ( ! EOFBlob ( image ) )  {if ( filepos != ( unsigned int ) filepos )  break ;if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) )  goto MATLAB_KO ;,while ( filepos < GetBlobSize ( image ) && ! EOFBlob ( image ) ) {if ( filepos > GetBlobSize ( image ) || filepos < 0 ) break ;if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) >= GetBlobSize ( image ) ) goto MATLAB_KO ;,1130
404,"if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) ,  ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ;goto ExitLoop ;","ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ;goto ExitLoop ;",1130
405,"char * fmtname ;if ( jas_init ( ) ) {while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {switch ( id ) {case OPT_INFILE :  infile = jas_optarg ;if ( infile ) {if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) {","char * fmtname ;int debug ;if ( jas_init ( ) ) {debug = 0 ;while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {switch ( id ) {case OPT_DEBUG : debug = atoi ( jas_optarg ) ;break ;case OPT_INFILE : infile = jas_optarg ;jas_setdbglevel ( debug ) ;if ( infile ) {if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) {jas_stream_close ( instream ) ;",1131
406,"if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\\","if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\\",1131
407,"
","ps_codec -> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ;",1132
408,ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ;ps_codec -> i4_bytes_remaining -= ( nal_ofst + nal_len ) ;,ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ;ps_codec -> i4_bytes_remaining -= ( nal_ofst + nal_len ) ;,1132
409,"nfca_poll -> rats_res_len = * data ++ ;pr_debug ( ""rats_res_len<S2SV_blank>%d\\\nfcb_poll -> attrib_res_len = * data ++ ;pr_debug ( ""attrib_res_len<S2SV_blank>%d\\\","nfca_poll -> rats_res_len = min_t ( __u8 , * data ++ , 20 ) ;pr_debug ( ""rats_res_len<S2SV_blank>%d\\\nfcb_poll -> attrib_res_len = min_t ( __u8 , * data ++ , 50 ) ;pr_debug ( ""attrib_res_len<S2SV_blank>%d\\\",1133
410,p = find_eoq ( cmd + 1 ) ;if ( ! p || ! * p ) {,p = cmd [ 0 ] ? find_eoq ( cmd + 1 ) : NULL ;if ( ! p || ! * p ) {,1134
411,struct hns_roce_ib_alloc_ucontext_resp resp ;struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ;,struct hns_roce_ib_alloc_ucontext_resp resp = {};struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ;,1135
412,"int retval = 0 ;int bytes_read = 0 ;retval = - ENODEV ;goto exit ;bytes_read = snprintf ( in_buffer , 20 , ""%lld\\\spin_unlock_irqrestore ( & dev -> lock , flags ) ;if ( * ppos < bytes_read ) {if ( copy_to_user ( buffer , in_buffer + * ppos , bytes_read - * ppos ) ) retval = - EFAULT ;else {retval = bytes_read - * ppos ;* ppos += bytes_read ;}exit : mutex_unlock ( & dev -> io_mutex ) ;return retval ;}","int len = 0 ;int bytes_read = 0 ;mutex_unlock ( & dev -> io_mutex ) ;return - ENODEV ;len = snprintf ( in_buffer , 20 , ""%lld\\\spin_unlock_irqrestore ( & dev -> lock , flags ) ;mutex_unlock ( & dev -> io_mutex ) ;return simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) ;",1136
413,"dagid_str = ip6addr_string ( ndo , dao -> rpl_dagid ) ;bp += DAGID_LEN ;length -= DAGID_LEN ;}ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u%s%s,%02x]"" , dagid_str , dao -> rpl_daoseq , dao -> rpl_instanceid , RPL_DAO_K ( dao -> rpl_flags ) ? "",acK"" : """" , RPL_DAO_D ( dao -> rpl_flags ) ? "",Dagid"" : """" , dao -> rpl_flags ) ) ;trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;","dagid_str = ip6addr_string ( ndo , ""%s"" , rpl_tstr ) ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;",1137
414,"int16_t vp9_dc_quant ( int qindex , int delta ) {return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;}","int16_t vp9_dc_quant ( int qindex , int delta , vpx_bit_depth_t bit_depth ) {# if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) {case VPX_BITS_8 : return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;case VPX_BITS_10 : return dc_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ;case VPX_BITS_12 : return dc_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ;default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ;return - 1 ;}# else ( void ) bit_depth ;return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;# endif }",1138
415,"
",else {matvar -> name [ tmp - 1 ] = \'\\\\0\' ;},1139
416,}matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ;,}matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ;,1139
417,"err = aead_register_instance ( tmpl , inst ) ;if ( err ) goto out_drop_aead ;","inst -> free = pcrypt_free ;err = aead_register_instance ( tmpl , inst ) ;if ( err ) goto out_drop_aead ;",1140
418,if ( addr & ( shmlba - 1 ) ) {if ( shmflg & SHM_RND )  addr &= ~ ( shmlba - 1 ) ;,if ( ( addr & ( shmlba - 1 ) ) {if ( shmflg & SHM_RND ) && addr >= shmlba ) addr &= ~ ( shmlba - 1 ) ;,1141
419,"return ( ( Image * ) NULL ) ;}iris_info . magic = ReadBlobMSBShort ( image ) ;do {if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ;switch ( iris_info . storage ) {case 0x00 : image -> compression = NoCompression ;break ;case 0x01 : image -> compression = RLECompression ;break ;default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ;if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;iris_info . rows = ReadBlobMSBShort ( image ) ;iris_info . depth = ReadBlobMSBShort ( image ) ;if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . minimum_value = ReadBlobMSBLong ( image ) ;iris_info . maximum_value = ReadBlobMSBLong ( image ) ;iris_info . sans = ReadBlobMSBLong ( image ) ;( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * )   iris_info . name ) ;iris_info . name [ sizeof ( iris_info . name ) - 1 ] = \'\\\\0\' ;( void ) count ;image -> columns = iris_info . columns ;","count = ReadBlob ( image , sizeof ( iris_info . name ) ;if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) , ( unsigned char * ) iris_info . name ) ;iris_info . name [ sizeof ( iris_info . name ) - 1 ] = \'\\\\0\' ;( void ) count ;image -> columns = iris_info . columns ;",1142
420,"if ( EOFBlob ( image ) != MagickFalse )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;","if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",1142
421,"if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ;SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ;p += 4 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( bytes_per_pixel == 2 ) {for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {quantum = ( * p << 8 ) ;quantum |= ( * ( p + 1 ) ) ;SetPixelIndex ( image , ( Quantum ) quantum , q ) ;p += 8 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelIndex ( image , * p , q ) ;p += 4 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;}pixel_info = RelinquishVirtualMemory ( pixel_info ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;",if ( ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;,1142
422,"STREAM out ;in_uint16_le ( in , tick ) ;","STREAM out ;struct stream packet = * in ;if ( ! s_check_rem ( in , 4 ) ) {rdp_protocol_error ( ""rdpsnd_process_training(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>training<S2SV_blank>data<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint16_le ( in , tick ) ;",1143
423,"dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\bsg_set_block ( bd , file ) ;","dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ;bsg_set_block ( bd , file ) ;",1144
424,"const VP9_CONFIG * oxcf = & cpi -> oxcf ;const RATE_CONTROL * rc = & cpi -> rc ;int64_t critical_level = oxcf -> optimal_buffer_level >> 2 ;int64_t buff_lvl_step = 0 ;int active_worst_quality ;if ( cm -> frame_type == KEY_FRAME ) return rc -> worst_quality ;if ( cm -> current_video_frame > 1 )  active_worst_quality = MIN ( rc -> worst_quality ,  rc -> avg_frame_qindex [ INTER_FRAME ] * 5 / 4 ) ;else active_worst_quality = MIN ( rc -> worst_quality ,  rc -> avg_frame_qindex [ KEY_FRAME ] * 3 / 2 ) ;if ( rc -> buffer_level > oxcf -> optimal_buffer_level ) {","const RATE_CONTROL * rc = & cpi -> oxcf ;const RATE_CONTROL * rc = & cpi -> rc ;int64_t critical_level = oxcf -> optimal_buffer_level >> 3 ;int64_t buff_lvl_step = 0 ;int active_worst_quality ;int ambient_qp ;unsigned int num_frames_weight_key = 5 * cpi -> svc . number_temporal_layers ;if ( cm -> frame_type == KEY_FRAME ) return rc -> worst_quality ;ambient_qp = ( cm -> current_video_frame > 1 ) active_worst_quality = MIN ( rc -> worst_quality , rc -> avg_frame_qindex [ INTER_FRAME ] , rc -> avg_frame_qindex [ KEY_FRAME ] * 3 / 2 ) ;if ( rc -> buffer_level > oxcf -> optimal_buffer_level ) {",1145
425,adjustment =  ( int ) ( ( rc -> worst_quality - rc -> avg_frame_qindex [ INTER_FRAME ] ) *   ( oxcf -> optimal_buffer_level - rc -> buffer_level ) /  buff_lvl_step ) ;active_worst_quality = rc -> avg_frame_qindex [ INTER_FRAME ] + adjustment ;,"adjustment = ( int ) ( ( rc -> worst_quality - rc -> avg_frame_qindex [ INTER_FRAME ] ;active_worst_quality = MIN ( rc -> worst_quality , ambient_qp * 5 / 4 ) ;if ( rc -> buffer_level > rc -> optimal_buffer_level ) {int max_adjustment_down = active_worst_quality / 3 ;if ( max_adjustment_down ) {buff_lvl_step = ( ( rc -> maximum_buffer_size - rc -> optimal_buffer_level ) / max_adjustment_down ) ;if ( buff_lvl_step ) adjustment = ( int ) ( ( rc -> buffer_level - rc -> optimal_buffer_level ) / buff_lvl_step ) ;active_worst_quality -= adjustment ;}}else if ( rc -> buffer_level > critical_level ) {if ( critical_level ) {buff_lvl_step = ( rc -> optimal_buffer_level - critical_level ) ;if ( buff_lvl_step ) {adjustment = ( int ) ( ( rc -> worst_quality - ambient_qp ) * ( rc -> optimal_buffer_level - rc -> buffer_level ) / buff_lvl_step ) ;active_worst_quality = ambient_qp + adjustment ;",1145
426,if ( ! ( buf = g_try_malloc ( size ) ) ) {# ifdef DEBUG g_assert_not_reached ( ) ;,if ( ! ( buf = g_try_malloc0 ( size ) ) ) {# ifdef DEBUG g_assert_not_reached ( ) ;,1146
427,alt = pcu -> ctrl_intf -> cur_altsetting ;pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ;alt = pcu -> data_intf -> cur_altsetting ;if ( alt -> desc . bNumEndpoints != 2 ) {,if ( ! pcu -> ctrl_intf ) return - EINVAL ;alt = pcu -> ctrl_intf -> cur_altsetting ;pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ;if ( ! pcu -> data_intf ) return - EINVAL ;alt = pcu -> data_intf -> cur_altsetting ;if ( alt -> desc . bNumEndpoints != 2 ) {,1147
428,"ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;","ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;",1148
429,"ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 1 ) ;if ( bp [ hlen ] & 0xf0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( bp [ hlen ] & 0x10 )  ND_PRINT ( ( ndo , ""K"" ) ) ;hlen += 1 ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;hlen += 2 ;break ;case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ;if ( mh -> ip6m_data8 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK2 ( * mh , hlen + 16 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ;","ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;if ( bp [ hlen ] & 0xf0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;}if ( bp [ hlen ] & 0x10 ) ND_PRINT ( ( ndo , ""K"" ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ;if ( mh -> ip6m_data8 [ 1 ] ) ;if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK2 ( bp [ hlen ] , 16 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ;",1148
430,"Convert_art ( & dls , & defaultArt , 0 ) ;dls . artCount = 1 ;dls . regionCount = dls . instCount = 0 ;","if ( dls . pDLS ) {Convert_art ( & dls , & defaultArt , 0 ) ;dls . artCount = 1 ;}dls . regionCount = dls . instCount = 0 ;",1149
431,"ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ;ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & e , ext , sizeof ( e ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%d"" , ntohs ( e . len ) - 4 ) ) ;if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , ntohs ( e . len ) - 4 ) ) goto trunc ;}else if ( 1 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( const uint8_t * ) ( ext + 1 ) , ep ) )  goto trunc ;return ( const u_char * ) ext + ntohs ( e . len ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ;","ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%u"" , ntohs ( e . len ) - 4 ) ) ;if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ntohs ( e . len ) > 4 ) {if ( ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( ext + 1 ) , ep ) ) goto trunc ;}return ( const u_char * ) ext + ntohs ( e . len ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ;",1150
432,"strcpy ( plugin_name , argv [ i ] ) ;strcpy ( config_file , argv [ i ] ) ;","if ( strlen ( argv [ i ] ) + 4 + 1 > FN_REFLEN ) {fprintf ( stderr , ""ERROR:<S2SV_blank>argument<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\\return 1 ;}strcpy ( plugin_name , argv [ i ] ) ;strcpy ( config_file , argv [ i ] ) ;",1151
433,"BN_ULONG t1 , t2 ;BN_ULONG c1 , c2 , c3 ;","BN_ULONG c1 , c2 , c3 ;",1152
434,"void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi )  {__issue_discard_cmd ( sbi , false ) ;__drop_discard_cmd ( sbi ) ;__wait_discard_cmd ( sbi , false ) ;}","void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi , bool umount ) {__issue_discard_cmd ( sbi , ! umount ) ;}",1153
435,attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ;if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ;,"size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;attrs = malloc ( alloc_size ) ;if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ;",1154
436,"if ( rdf_parser -> uri_filter )  raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ;","raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;if ( rdf_parser -> uri_filter ) raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ;",1155
437,if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) ||  ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) )  return KADM5_BAD_MASK ;if ( ( mask & ~ ALL_PRINC_MASK ) )   return KADM5_BAD_MASK ;if ( entry == NULL ) return EINVAL ;,if ( entry == NULL ) return EINVAL ;if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ;,1156
438,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;else  pr_err ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_err ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;va_end ( va ) ;",1157
439,"static void read_tx_mode_probs ( struct tx_probs * tx_probs , vp9_reader * r ) {int i , j ;","static void read_tx_mode_probs ( struct tx_probs * tx_probs , vpx_reader * r ) {int i , j ;",1158
440,"static void write_frame_size ( const VP9_COMMON * cm ,  struct vp9_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ;vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ;write_display_size ( cm , wb ) ;","static void write_frame_size ( const VP9_COMMON * cm , struct vpx_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ;vpx_wb_write_literal ( wb , cm -> height - 1 , 16 ) ;write_display_size ( cm , wb ) ;",1159
441,"if ( length == SIZE_MAX ) {rfbErr ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>too<S2SV_blank>big<S2SV_blank>file<S2SV_blank>transfer<S2SV_blank>length<S2SV_blank>requested:<S2SV_blank>%u"" , ( unsigned int ) length ) ;","if ( length == SIZE_MAX || length > INT_MAX ) {rfbErr ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>too<S2SV_blank>big<S2SV_blank>file<S2SV_blank>transfer<S2SV_blank>length<S2SV_blank>requested:<S2SV_blank>%u"" , ( unsigned int ) length ) ;",1160
442,"# define ThrowCUTReaderException ( severity , tag ) {}Image * image , * palette ;","# define ThrowCUTReaderException ( severity , tag ) \\\\\\\\\\Image * image , * palette ;",1161
443,"
","( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;",1161
444,"offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {","offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {",1161
445,"
",if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;},1162
446,jumpstack [ stackidx ++ ] = e ;},jumpstack [ stackidx ++ ] = e ;},1162
447,if ( ! ( vmx -> exit_reason == EXIT_REASON_MCE_DURING_VMENTRY || vmx -> exit_reason == EXIT_REASON_EXCEPTION_NMI ) ) return ;vmx -> exit_intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ;exit_intr_info = vmx -> exit_intr_info ;if ( is_machine_check ( exit_intr_info ) ) kvm_machine_check ( ) ;if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR &&  ( exit_intr_info & INTR_INFO_VALID_MASK ) ) {,if ( is_nmi ( exit_intr_info ) ) {,1163
448,"tok -> err = json_tokener_success ;while ( PEEK_CHAR ( c , tok ) ) {","tok -> err = json_tokener_success ;if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) {tok -> err = json_tokener_error_size ;return NULL ;}while ( PEEK_CHAR ( c , tok ) ) {",1164
449,if ( c < 0 )  break ;* p ++ = ( unsigned char ) c ;if ( c < 0 )  break ;* p ++ = ( unsigned char ) c ;,"if ( c < 0 ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}* p ++ = ( unsigned char ) c ;if ( c < 0 ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}* p ++ = ( unsigned char ) c ;",1165
450,hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ;},hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + ( hwc -> idx - X86_PMC_IDX_FIXED ) ;},1166
451,"static off_t ivf_header_pos = 0 ;switch ( pkt -> kind ) {if ( ! stream -> ebml . debug )  stream -> hash = murmur ( pkt -> data . frame . buf , ( int ) pkt -> data . frame . sz , stream -> hash ) ;",static int64_t ivf_header_pos = 0 ;switch ( pkt -> kind ) {,1167
452,"off_t currpos = ftello ( stream -> file ) ;fseeko ( stream -> file , ivf_header_pos , SEEK_SET ) ;","const int64_t currpos = ftello ( stream -> file ) ;fseeko ( stream -> file , ivf_header_pos , SEEK_SET ) ;",1167
453,case VPX_CODEC_PSNR_PKT :  if ( global -> show_psnr ) {,"# if CONFIG_FP_MB_STATS case VPX_CODEC_FPMB_STATS_PKT : stats_write ( & stream -> fpmb_stats , pkt -> data . firstpass_mb_stats . buf , pkt -> data . firstpass_mb_stats . sz ) ;stream -> nbytes += pkt -> data . raw . sz ;break ;# endif case VPX_CODEC_PSNR_PKT : if ( global -> show_psnr ) {",1167
454,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,1168
455,struct snd_ctl_elem_id id ;unsigned int idx ;,struct snd_ctl_elem_id id ;unsigned int count ;unsigned int idx ;,1169
456,"up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < kcontrol -> count ;idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;","count = kcontrol -> count ;up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < count ;idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;",1169
457,Proto * p = clLvalue ( s2v ( ci -> func ) ) -> p ;if ( p -> is_vararg ) delta = ci -> u . l . nextraargs + p -> numparams + 1 ;,Proto * p = ci_func ( ci ) -> p ;if ( p -> is_vararg ) delta = ci -> u . l . nextraargs + p -> numparams + 1 ;,1170
458,"if ( isLua ( ci -> previous ) )   L -> oldpc = ci -> previous -> u . l . savedpc ;return restorestack ( L , oldtop ) ;","if ( isLua ( ci = ci -> previous ) ) L -> oldpc = pcRel ( ci -> u . l . savedpc , ci_func ( ci ) -> p ) ;return restorestack ( L , oldtop ) ;",1170
459,"pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , ""error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file"" ) ;* err = 1 ;return ( NULL ) ;}return ( NULL ) ;}amt_read = fread ( & byte_order_magic , 1 , sizeof ( byte_order_magic ) , fp ) ;","pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%"" PRIsize ""<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)"" , sizeof ( byte_order_magic ) , fp ) ;",1171
460,"if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) {pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE ,  ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%"" PRIsize ,  total_length ,  sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) ;* err = 1 ;","if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) , total_length , BT_SHB_INSANE_MAX ) ;* err = 1 ;",1171
461,"static int em_jcxz ( struct x86_emulate_ctxt * ctxt )  {if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 )  jmp_rel ( ctxt , ctxt -> src . val ) ;return X86EMUL_CONTINUE ;}","static int em_jcxz ( struct x86_emulate_ctxt * ctxt ) {int rc = X86EMUL_CONTINUE ;if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;return rc ;}",1172
462,"CRM_LOG_ASSERT ( client_obj -> request_id ) ;rid = client_obj -> request_id ;crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" ,  rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}","if ( client_obj -> ipc ) {CRM_LOG_ASSERT ( client_obj -> request_id ) ;rid = client_obj -> request_id ;crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}else {crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}}",1173
463,"void *  checked_xmalloc ( size_t size )  {alloc_limit_assert ( ""checked_xmalloc"" , size ) ;return xmalloc ( size ) ;}","void * checked_xmalloc ( size_t num , size_t size ) {size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;alloc_limit_assert ( ""checked_xmalloc"" , res ) ;return xmalloc ( num , size ) ;}",1174
464,"static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx , int ctr_id ,  va_list args ) {if ( data == 1 &&  ( cfg -> rc_end_usage == VPX_CBR ||  cfg -> g_pass == VPX_RC_FIRST_PASS || cfg -> g_pass == VPX_RC_LAST_PASS ) && cfg -> ss_number_layers > 1 && cfg -> ts_number_layers > 1 ) {","static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx , va_list args ) {if ( data == 1 && ( cfg -> g_pass == VPX_RC_FIRST_PASS || cfg -> g_pass == VPX_RC_LAST_PASS ) && cfg -> ss_number_layers > 1 && cfg -> ts_number_layers > 1 ) {",1175
465,if ( size_bmp > BMP_HEADER_SIZE ) {int ret ;,if ( size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE ) {int ret ;,1176
466,"dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ;if ( dev ) sctx = dev -> scrub_ctx ;","dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL , true ) ;if ( dev ) sctx = dev -> scrub_ctx ;",1177
467,"if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) {goto error ;box -> ops = & jp2_boxinfo_unk . ops ;JAS_DBGLOG ( 10 , (  ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\\if ( box -> len == 1 ) {if ( jp2_getuint64 ( in , & extlen ) ) {","if ( ! ( box = jp2_box_create0 ( ) ) ) {goto error ;JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\\if ( box -> len == 1 ) {JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\\if ( jp2_getuint64 ( in , & extlen ) ) {",1178
468,state -> array_nl = NULL ;}}else {if ( state -> array_nl ) ruby_xfree ( state -> array_nl ) ;state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ;state -> array_nl_len = len ;,"state -> array_nl = fstrndup ( RSTRING_PTR ( array_nl ) , len ) ;state -> array_nl_len = len ;",1179
469,"if ( ! test_bit ( HCI_UP , & hdev -> flags ) )   return - ENETDOWN ;hci_req_sync_lock ( hdev ) ;ret = __hci_req_sync ( hdev , req , opt , timeout , hci_status ) ;hci_req_sync_unlock ( hdev ) ;return ret ;","hci_req_sync_lock ( hdev ) ;if ( test_bit ( HCI_UP , & hdev -> flags ) ) ret = __hci_req_sync ( hdev , req , opt , timeout , hci_status ) ;else ret = - ENETDOWN ;hci_req_sync_unlock ( hdev ) ;return ret ;",1180
470,vpx_codec_err_t res = VPX_CODEC_OK ;yv12 -> y_buffer = img -> planes [ VPX_PLANE_Y ] ;yv12 -> y_crop_width = img -> d_w ;yv12 -> y_crop_height = img -> d_h ;yv12 -> uv_height = yv12 -> y_height / 2 ;yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ;yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ;yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> d_w ) / 2 ;,const int y_w = img -> d_w ) / 2 ;const int uv_h = ( img -> d_h + 1 ) / 2 ;vpx_codec_err_t res = VPX_CODEC_OK ;yv12 -> y_buffer = img -> planes [ VPX_PLANE_Y ] ;yv12 -> y_crop_width = y_w ;yv12 -> y_crop_height = y_h ;yv12 -> y_width = y_w ;yv12 -> y_height = y_h ;yv12 -> uv_crop_width = uv_w ;yv12 -> uv_crop_height = uv_h ;yv12 -> uv_width = uv_w ;yv12 -> uv_height = uv_h ;yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ;yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ;yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> d_w ;yv12 -> y_crop_height = img -> d_h ;,1181
471,void * buffer ;buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ;,void * buffer ;if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL ;buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ;,1182
472,if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,if ( num < 0 || num >= 256 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,1183
473,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,1183
474,state = vterm_state_new ( vt ) ;vt -> state = state ;,state = vterm_state_new ( vt ) ;if ( state == NULL ) return NULL ;vt -> state = state ;,1184
475,"mpeg4_decode_gop_header ( s , gb ) ;}else if ( startcode == VOS_STARTCODE ) {mpeg4_decode_profile_level ( s , gb ) ;if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&  ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) {s -> studio_profile = 1 ;}}","mpeg4_decode_gop_header ( s , gb , & profile , & level ) ;if ( profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) {s -> studio_profile = 1 ;}else if ( s -> studio_profile ) {av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;avpriv_request_sample ( s -> avctx , ""Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\\return AVERROR_PATCHWELCOME ;}s -> avctx -> profile = profile ;s -> avctx -> level = level ;}",1185
476,"if ( ! s -> avctx -> bits_per_raw_sample ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>VOL<S2SV_blank>header\\\","if ( ! s -> avctx -> bits_per_raw_sample ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>VOL<S2SV_blank>header\\\",1185
477,"const uint8_t * end , * ptr = avpkt -> data ;int ncolors , cpp , ret , i , j ;end = avpkt -> data + avpkt -> size ;while ( memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) && ptr < end - 9 )  ptr ++ ;if ( ptr >= end ) {","const uint8_t * end , * ptr ;int ncolors , cpp , ret , i , j ;av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ;if ( ! x -> buf ) return AVERROR ( ENOMEM ) ;memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ;x -> buf [ avpkt -> size ] = 0 ;ptr = x -> buf ;end = x -> buf + avpkt -> size ;while ( end - ptr > 9 && memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) ) ptr ++ ;if ( end - ptr <= 9 ) {",1186
478,"i ++ )  size *= 94 ;if ( ncolors <= 0 || ncolors > size ) {if ( ! x -> pixels ) return AVERROR ( ENOMEM ) ;ptr += mod_strcspn ( ptr , "","" ) + 1 ;for ( i = 0 ;const uint8_t * index ;if ( ptr + cpp > end )  return AVERROR_INVALIDDATA ;",i ++ ) size *= 95 ;if ( ncolors <= 0 || ncolors > size ) {if ( end - ptr < cpp ) return AVERROR_INVALIDDATA ;for ( i = 0 ;const uint8_t * index ;if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;if ( ptr + cpp > end ) return AVERROR_INVALIDDATA ;,1186
479,"}for ( i = 0 ;ptr += mod_strcspn ( ptr , ""\\\\"""" ) + 1 ;for ( j = 0 ;if ( ptr + cpp > end )  return AVERROR_INVALIDDATA ;","}for ( i = 0 ;if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;ptr += mod_strcspn ( ptr , ""\\\\"""" ) + 1 ;if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;for ( j = 0 ;if ( end - ptr < cpp ) return AVERROR_INVALIDDATA ;",1186
480,"static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred )  {status = _nfs4_do_open ( dir , path , flags , sattr , cred , & res ) ;if ( status == 0 ) break ;","static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , fmode_t fmode , int flags , struct iattr * sattr , struct rpc_cred * cred ) {status = _nfs4_do_open ( dir , path , fmode , flags , sattr , cred , & res ) ;if ( status == 0 ) break ;",1187
481,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
482,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
483,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
484,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
485,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
486,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
487,"
","if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",1189
488,iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;,iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;,1189
489,"if ( i_arg ) {retval = copy_strings_kernel ( 1 , & i_arg , bprm ) ;bprm -> interp = interp ;file = open_exec ( interp ) ;return search_binary_handler ( bprm ) ;}","retval = bprm_change_interp ( interp , bprm ) ;if ( retval < 0 ) return retval ;file = open_exec ( interp ) ;if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ;bprm -> file = file ;retval = prepare_binprm ( bprm ) ;bprm -> interp = interp ;file = open_exec ( interp ) ;return search_binary_handler ( bprm ) ;}",1190
490,"INIT_LIST_HEAD ( & f -> f_u . fu_list ) ;atomic_long_set ( & f -> f_count , 1 ) ;","atomic_long_set ( & f -> f_count , 1 ) ;",1191
491,ps_dec -> u4_first_slice_in_pic = 2 ;ps_dec -> u1_slice_header_done = 0 ;,ps_dec -> u4_first_slice_in_pic = 2 ;ps_dec -> u1_first_pb_nal_in_pic = 1 ;ps_dec -> u1_slice_header_done = 0 ;,1192
492,"( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ;FormatLocaleString ( clone_info -> filename , MaxTextExtent , ""%s"" , postscript_file ) ;","( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent - 1 ) ;FormatLocaleString ( clone_info -> filename , MaxTextExtent , ""%s"" , postscript_file ) ;",1193
493,if ( pkt == NULL )  continue ;,"
",1194
494,kgctx . have_acceptor_subkey = 1 ;kb1 . contents = k1buf ;,kgctx . established = 1 ;kgctx . have_acceptor_subkey = 1 ;kb1 . contents = k1buf ;,1195
495,msg -> msg_namelen = 0 ;copied = skb -> len ;,copied = skb -> len ;,1196
496,port -> exists = true ;mb ( ) ;return 0 ;,spin_lock_irq ( & i8042_lock ) ;port -> exists = true ;spin_unlock_irq ( & i8042_lock ) ;return 0 ;,1197
497,"skip :  if ( ( new -> euid != old -> uid ||  new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) {","skip : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ;if ( ( new -> euid != old -> uid || new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) {",1198
498,if ( ! rc -> source_alt_ref_pending )   rc -> source_alt_ref_active = 0 ;if ( rc -> frames_till_gf_update_due > 0 ) rc -> frames_till_gf_update_due -- ;,if ( ! rc -> source_alt_ref_pending ) {rc -> source_alt_ref_active = 0 ;}if ( rc -> frames_till_gf_update_due > 0 ) rc -> frames_till_gf_update_due -- ;,1199
499,"static void kiocb_batch_free ( struct kiocb_batch * batch )  {struct kiocb * req , * n ;list_for_each_entry_safe ( req , n , & batch -> head , ki_batch ) {kmem_cache_free ( kiocb_cachep , req ) ;}}","static void kiocb_batch_free ( struct kioctx * ctx , struct kiocb_batch * batch ) {struct kiocb * req , * n ;if ( list_empty ( & batch -> head ) ) return ;spin_lock_irq ( & ctx -> ctx_lock ) ;list_for_each_entry_safe ( req , n , & batch -> head , ki_batch ) {list_del ( & req -> ki_list ) ;kmem_cache_free ( kiocb_cachep , req ) ;ctx -> reqs_active -- ;}spin_unlock_irq ( & ctx -> ctx_lock ) ;}",1200
500,"
","memset ( sax , 0 , sizeof ( sax ) ) ;",1201
501,"sax -> sax25_family = AF_NETROM ;skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ;","sax -> sax25_family = AF_NETROM ;skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ;",1201
502,"if ( cpu_id != RING_BUFFER_ALL_CPUS && ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) return size ;size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ;size *= BUF_PAGE_SIZE ;","nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ;if ( nr_pages < 2 ) nr_pages = 2 ;size = nr_pages * BUF_PAGE_SIZE ;",1202
503,uchar * dp ;dp = data ;,jas_uchar * dp ;dp = data ;,1203
504,dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;dev -> netdev_ops = & macvlan_netdev_ops ;,dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;dev -> netdev_ops = & macvlan_netdev_ops ;,1204
505,int event_id = event -> attr . config ;if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ;,u64 event_id = event -> attr . config ;if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ;,1205
506,char * buf ;pkglen = s -> end - s -> p ;,"char * buf ;if ( ! s_check ( s ) ) {rdp_protocol_error ( ""rdpsnddbg_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , s ) ;}pkglen = s -> end - s -> p ;",1206
507,case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE :  case RAPTOR_OPTION_RELATIVE_URIS :  case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ;,case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case RAPTOR_OPTION_RELATIVE_URIS : case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ;,1207
508,"static PixelChannels * * AcquirePixelThreadSet ( const Image * image )  {size_t  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ;for ( i = 0 ;i < ( ssize_t ) number_threads ;i ++ )  {register ssize_t j ;pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns ,  sizeof ( * * pixels ) ) ;if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ;for ( j = 0 ;j < ( ssize_t ) image -> columns ;j ++ )  {","static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) {const Image * next ;size_t columns , number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( columns , sizeof ( * pixels ) ) ;columns = images -> columns ;for ( next = images ;next != ( Image * ) NULL ;next = next -> next ) columns = MagickMax ( next -> columns , columns ) ;for ( i = 0 ;i < ( ssize_t ) columns ;j ++ ) {",1208
509,"int vp9_decode_frame ( VP9Decoder * pbi ,  const uint8_t * data , const uint8_t * data_end , const uint8_t * * p_data_end ) {struct vp9_read_bit_buffer rb = {data , data_end , 0 , cm , error_handler };const size_t first_partition_size = read_uncompressed_header ( pbi , & rb ) ;const int keyframe = cm -> frame_type == KEY_FRAME ;* p_data_end = data + 1 ;return 0 ;if ( ! pbi -> decoded_key_frame && ! keyframe ) return - 1 ;data += vp9_rb_bytes_read ( & rb ) ;pbi -> do_loopfilter_inline =   ( cm -> log2_tile_rows | cm -> log2_tile_cols ) == 0 && cm -> lf . filter_level ;if ( pbi -> do_loopfilter_inline && pbi -> lf_worker . data1 == NULL ) {CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ;pbi -> lf_worker . hook = ( VP9WorkerHook ) vp9_loop_filter_worker ;if ( pbi -> oxcf . max_threads > 1 && ! vp9_worker_reset ( & pbi -> lf_worker ) ) {vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Loop<S2SV_blank>filter<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ;}}init_macroblockd ( cm , & pbi -> mb ) ;cm -> prev_mi = get_prev_mi ( cm ) ;setup_plane_dequants ( cm , xd , cm -> base_qindex ) ;cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ;vp9_zero ( xd -> dqcoeff ) ;if ( pbi -> oxcf . max_threads > 1 && tile_rows == 1 && tile_cols > 1 &&  cm -> frame_parallel_decoding_mode ) {}* p_data_end = decode_tiles ( pbi , data + first_partition_size , data_end ) ;new_fb -> corrupted |= xd -> corrupted ;if ( ! pbi -> decoded_key_frame ) {else vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME ,  ""A<S2SV_blank>stream<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>key<S2SV_blank>frame"" ) ;}","void vp9_decode_frame ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end , const uint8_t * * p_data_end ) {struct vpx_read_bit_buffer rb ;int context_updated = 0 ;uint8_t clear_data [ MAX_VP9_HEADER_SIZE ] ;const size_t first_partition_size = read_uncompressed_header ( pbi , init_read_bit_buffer ( pbi , & rb , data , data_end , clear_data ) ) ;const int keyframe = cm -> frame_type == KEY_FRAME ;* p_data_end = data + ( cm -> profile <= PROFILE_2 ? 1 : 2 ) ;return ;data += vpx_rb_bytes_read ( & rb ) ;cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> last_intra_only && cm -> last_show_frame && ( cm -> last_frame_type != KEY_FRAME ) ;* cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ;if ( ! cm -> fc -> initialized ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Uninitialized<S2SV_blank>entropy<S2SV_blank>context."" ) ;if ( new_fb -> corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>header<S2SV_blank>is<S2SV_blank>corrupted."" ) ;if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) {vp9_loop_filter_frame_init ( cm , cm -> lf . filter_level ) ;}if ( pbi -> frame_parallel_decode && cm -> frame_parallel_decoding_mode ) {VPxWorker * const worker = pbi -> frame_worker_owner ;FrameWorkerData * const frame_worker_data = worker -> data1 ;if ( cm -> refresh_frame_context ) {context_updated = 1 ;cm -> frame_contexts [ cm -> frame_context_idx ] = * cm -> fc ;}vp9_frameworker_lock_stats ( worker ) ;pbi -> cur_buf -> row = - 1 ;pbi -> cur_buf -> col = - 1 ;frame_worker_data -> frame_context_ready = 1 ;vp9_frameworker_signal_stats ( worker ) ;vp9_frameworker_unlock_stats ( worker ) ;}if ( pbi -> max_threads > 1 && tile_rows == 1 && tile_cols > 1 && cm -> frame_parallel_decoding_mode ) {if ( ! xd -> corrupted ) {if ( ! cm -> skip_loop_filter ) {vp9_loop_filter_frame_mt ( new_fb , cm , pbi -> mb . plane , cm -> lf . filter_level , 0 , 0 , pbi -> tile_workers , pbi -> num_tile_workers , & pbi -> lf_row_sync ) ;}}else {vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted."" ) ;}}* p_data_end = decode_tiles ( pbi , data + first_partition_size , data_end ) ;new_fb -> corrupted |= xd -> corrupted ;if ( ! pbi -> decoded_key_frame ) {else vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted."" ) ;}",1209
510,if ( cm -> refresh_frame_context )   cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ;return 0 ;},if ( cm -> refresh_frame_context && ! context_updated ) cm -> frame_contexts [ cm -> frame_context_idx ] = * cm -> fc ;},1209
511,sock_put ( skpair ) ;unix_peer ( sk ) = NULL ;,"unix_dgram_peer_wake_disconnect ( sk , skpair ) ;sock_put ( skpair ) ;unix_peer ( sk ) = NULL ;",1210
512,"ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ;close ( sk ) ;","TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ) ;close ( sk ) ;",1211
513,if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) {if ( new_len > old_len ) goto Efault ;,if ( new_len > old_len ) {unsigned long pgoff ;if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) goto Efault ;pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ;pgoff += vma -> vm_pgoff ;if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval ;,1212
514,"if ( dashsize ) outpos += sprintf ( outpos , ""<S2SV_blank>[%12.3f]<S2SV_blank>%12.3f<S2SV_blank>d"" , dashsize , phase ) ;else outpos += sprintf ( outpos , ""<S2SV_blank>[]<S2SV_blank>0<S2SV_blank>d"" ) ;}","if ( dashsize ) {sprintf ( outputbuffer , ""<S2SV_blank>[%12.3f]<S2SV_blank>%12.3f<S2SV_blank>d"" , dashsize , phase ) ;sendClean ( outputbuffer ) ;}else send ( ""<S2SV_blank>[]<S2SV_blank>0<S2SV_blank>d"" ) ;}",1213
515,"print_octets ( ndo , ( const u_char * ) ptr , len - 6 ) ;","print_octets ( ndo , ( const u_char * ) ptr , len - 6 , len - 6 ) ;",1214
516,"case L2TP_AVP_MSGTYPE :  l2tp_msgtype_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_PROTO_VER :  l2tp_proto_ver_print ( ndo , ptr ) ;break ;case L2TP_AVP_FRAMING_CAP :  l2tp_framing_cap_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_BEARER_CAP :  l2tp_bearer_cap_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_TIE_BREAKER :  print_octets ( ndo , ( const u_char * ) ptr , 8 ) ;break ;case L2TP_AVP_FIRM_VER : case L2TP_AVP_ASSND_TUN_ID : case L2TP_AVP_RECV_WIN_SIZE : case L2TP_AVP_ASSND_SESS_ID :  print_16bits_val ( ndo , ptr ) ;break ;case L2TP_AVP_CHALLENGE_RESP :  print_octets ( ndo , ( const u_char * ) ptr , 16 ) ;break ;case L2TP_AVP_CALL_SER_NUM : case L2TP_AVP_MINIMUM_BPS : case L2TP_AVP_MAXIMUM_BPS : case L2TP_AVP_TX_CONN_SPEED : case L2TP_AVP_PHY_CHANNEL_ID : case L2TP_AVP_RX_CONN_SPEED :  print_32bits_val ( ndo , ( const uint32_t * ) ptr ) ;break ;case L2TP_AVP_BEARER_TYPE :  l2tp_bearer_type_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_FRAMING_TYPE :  l2tp_framing_type_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_PROXY_AUTH_TYPE :  l2tp_proxy_auth_type_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_PROXY_AUTH_ID :  l2tp_proxy_auth_id_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_CALL_ERRORS :  l2tp_call_errors_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_ACCM :  l2tp_accm_print ( ndo , ( const u_char * ) ptr ) ;break ;","case L2TP_AVP_MSGTYPE : l2tp_msgtype_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_PROTO_VER : l2tp_proto_ver_print ( ndo , ptr , len - 6 ) ;break ;case L2TP_AVP_FRAMING_CAP : l2tp_framing_cap_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_BEARER_CAP : l2tp_bearer_cap_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_TIE_BREAKER : if ( len - 6 < 8 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;break ;}print_octets ( ndo , ( const u_char * ) ptr , 8 ) ;break ;case L2TP_AVP_FIRM_VER : case L2TP_AVP_ASSND_TUN_ID : case L2TP_AVP_RECV_WIN_SIZE : case L2TP_AVP_ASSND_SESS_ID : if ( len - 6 < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;break ;}print_16bits_val ( ndo , ptr ) ;break ;case L2TP_AVP_CHALLENGE_RESP : if ( len - 6 < 16 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;break ;}print_octets ( ndo , ( const u_char * ) ptr , 16 ) ;break ;case L2TP_AVP_CALL_SER_NUM : case L2TP_AVP_MINIMUM_BPS : case L2TP_AVP_MAXIMUM_BPS : case L2TP_AVP_TX_CONN_SPEED : case L2TP_AVP_PHY_CHANNEL_ID : case L2TP_AVP_RX_CONN_SPEED : if ( len - 6 < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;break ;}print_32bits_val ( ndo , ( const uint32_t * ) ptr , len - 6 ) ;break ;case L2TP_AVP_BEARER_TYPE : l2tp_bearer_type_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_FRAMING_TYPE : l2tp_framing_type_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_PROXY_AUTH_TYPE : l2tp_proxy_auth_type_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_PROXY_AUTH_ID : l2tp_proxy_auth_id_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_CALL_ERRORS : l2tp_call_errors_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_ACCM : l2tp_accm_print ( ndo , ( const u_char * ) ptr ) ;break ;",1214
517,o4 = o * sizeof ( uint32_t ) ;},if ( q + o >= e ) goto out ;o4 = o * sizeof ( uint32_t ) ;},1215
518,if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) {return NULL ;,if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 1 ) {return NULL ;,1216
519,"case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ;","# if 0 case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ;",1216
520,"case DW_FORM_data2 :  value -> encoding . data = READ ( buf , ut16 ) ;case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ;break ;case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ;for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}","case DW_FORM_data2 : value -> encoding . data = READ ( buf , ut16 ) ;# endif case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ;break ;case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ;if ( value -> encoding . block . data ) {for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}}if ( value -> encoding . block . data ) {for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}}",1216
521,"netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ;return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ;","memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ;return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ;",1217
522,"if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) {return 0 ;memset ( box , 0 , sizeof ( jp2_box_t ) ) ;box -> type = type ;",if ( ! ( box = jp2_box_create0 ( ) ) ) ) {return 0 ;box -> type = type ;,1218
523,char * name ;unsigned char dummy_key [ EVP_MAX_KEY_LENGTH ] = {0 };,char * name ;,1219
524,"if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 )  ossl_raise ( eCipherError , NULL ) ;","if ( EVP_CipherInit_ex ( ctx , cipher , NULL , NULL , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;",1219
525,"av_bprint_init ( bp , 0 , - 1 ) ;while ( zstream . avail_in > 0 ) {av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ;if ( ! buf_size ) {zstream . avail_out = buf_size ;ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ;","av_bprint_init ( bp , 2 , & buf , & buf_size ) ;if ( buf_size < 2 ) {zstream . avail_out = buf_size - 1 ;ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ;",1220
526,"unsigned v = get_symbol ( c , state , 0 ) ;if ( v >= 2 ) {av_log ( f -> avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ver01<S2SV_blank>header\\\return AVERROR_INVALIDDATA ;}f -> version = v ;f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ) ;if ( f -> ac > 1 ) {for ( i = 1 ;i < 256 ;i ++ ) f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ] ;}f -> colorspace = get_symbol ( c , state , 0 ) ;if ( f -> version > 0 ) f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ;f -> chroma_planes = get_rac ( c , state ) ;f -> chroma_h_shift = get_symbol ( c , state , 0 ) ;f -> chroma_v_shift = get_symbol ( c , state , 0 ) ;f -> transparency = get_rac ( c , state ) ;f -> plane_count = 2 + f -> transparency ;","int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ;unsigned v = get_symbol ( c , state , 0 ) ;chroma_planes = get_rac ( c , state ) ;f -> chroma_h_shift = get_symbol ( c , state , 0 ) ;f -> chroma_v_shift = get_symbol ( c , state , 0 ) ;f -> transparency = get_rac ( c , state ) ;f -> plane_count = 2 + f -> transparency ;",1221
527,r = verify_vc_kbmode ( fd ) ;if ( r < 0 ) {,r = vt_verify_kbmode ( fd ) ;if ( r < 0 ) {,1222
528,"nfcf_poll -> sensf_res_len = * data ++ ;pr_debug ( ""bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\\","nfcf_poll -> sensf_res_len = min_t ( __u8 , * data ++ , NFC_SENSF_RES_MAXSIZE ) ;pr_debug ( ""bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\\",1223
529,"
",queueItem -> interface = interface ;,1224
530,queueItem -> srcPort = 0 ;queueItem -> srcIpAddr = IP_ADDR_ANY ;,queueItem -> srcPort = 0 ;queueItem -> srcIpAddr = IP_ADDR_ANY ;,1224
531,NAPI_GRO_CB ( skb ) -> same_flow = 0 ;NAPI_GRO_CB ( skb ) -> udp_mark = 0 ;NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ;,NAPI_GRO_CB ( skb ) -> encap_mark = 0 ;NAPI_GRO_CB ( skb ) -> udp_mark = 0 ;NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ;,1225
532,"static int kvm_vm_ioctl_set_pit ( struct kvm * kvm , struct kvm_pit_state * ps )  {mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ;kvm_pit_load_count ( kvm , 0 , ps -> channels [ 0 ] . count , 0 ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;","static int kvm_vm_ioctl_set_pit ( struct kvm * kvm , struct kvm_pit_state * ps ) {int i ;mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ;for ( i = 0 ;i < 3 ;i ++ ) kvm_pit_load_count ( kvm , i , ps -> channels [ 0 ] . count , 0 ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;",1226
533,"if ( malloc_called != 20 || free_called != 20 )  fail ( ""Custom<S2SV_blank>allocation<S2SV_blank>failed"" ) ;","if ( malloc_called != 1 || free_called != 20 ) fail ( ""Custom<S2SV_blank>allocation<S2SV_blank>failed"" ) ;",1227
534,"int i ;int j ;int numrows ;int numcols ;if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & xoff , & yoff ) != 2 )   return 0 ;if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & numcols , & numrows ) != 2 )   return 0 ;if ( ! ( matrix = jas_seq2d_create ( xoff , yoff , xoff + numcols , yoff + numrows ) ) )  return 0 ;if ( jas_matrix_numrows ( matrix ) != numrows || jas_matrix_numcols ( matrix ) != numcols ) {","jas_matind_t i ;jas_matind_t j ;int numrows ;int numcols ;if ( fscanf ( in , ""%ld<S2SV_blank>%ld"" , & tmp_xoff , & tmp_yoff ) != 2 ) return 0 ;if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & numcols , & numrows ) != 2 ) {return 0 ;}xoff = tmp_xoff ;yoff = tmp_yoff ;if ( ! ( matrix = jas_seq2d_create ( xoff , yoff , xoff + numcols , yoff + numrows ) ) ) {return 0 ;}if ( jas_matrix_numrows ( matrix ) != numrows || jas_matrix_numcols ( matrix ) != numcols ) {",1228
535,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,1229
536,if ( exim_uid == 0 ) {,"if ( exim_uid == 0 ) if ( received_protocol ) {fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\\exit ( EXIT_FAILURE ) ;}else {",1230
537,uschar * p = & argrest [ 2 ] ;,"uschar * hn ;if ( received_protocol ) {fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\\exit ( EXIT_FAILURE ) ;}p = & argrest [ 2 ] ;",1230
538,"else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ;","else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ;",1230
539,"uschar * hn = Ustrchr ( argrest , \':\' ) ;if ( hn == NULL ) {","uschar * hn = Ustrchr ( argrest , \':\' ) ;if ( hn == NULL ) {",1230
540,"static uint32_t scsi_init_iovec ( SCSIDiskReq * r )  {r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;","static uint32_t scsi_init_iovec ( SCSIDiskReq * r ) {SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ;if ( ! r -> iov . iov_base ) {r -> buflen = SCSI_DMA_BUF_SIZE ;r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ;}r -> iov . iov_len = MIN ( r -> sector_count * 512 , r -> buflen ) ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;",1231
541,if ( ret != 0 )  return ret ;bo -> dumb = false ;,if ( ret != 0 ) {kfree ( bo ) ;return ret ;}bo -> dumb = false ;,1232
542,"static void encode_sb_rt ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row , int mi_col ,  int output_enabled , BLOCK_SIZE bsize ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;int ctx ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;const int idx_str = xd -> mi_stride * mi_row + mi_col ;","static void encode_sb_rt ( VP9_COMP * cpi , ThreadData * td , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PC_TREE * pc_tree ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2_lookup [ bsize ] , hbs = ( 1 << bsl ) / 4 ;int ctx ;const int idx_str = xd -> mi_stride * mi_row + mi_col ;",1233
543,"switch ( partition ) {case PARTITION_NONE :  if ( output_enabled && bsize >= BLOCK_8X8 )  cm -> counts . partition [ ctx ] [ PARTITION_NONE ] ++ ;encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;break ;case PARTITION_VERT :  if ( output_enabled )  cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ;* get_sb_index ( x , subsize ) = 0 ;encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;if ( mi_col + hbs < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;encode_b_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ;}break ;case PARTITION_HORZ :  if ( output_enabled )  cm -> counts . partition [ ctx ] [ PARTITION_HORZ ] ++ ;* get_sb_index ( x , subsize ) = 0 ;encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;if ( mi_row + hbs < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;encode_b_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ;}case PARTITION_SPLIT : subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;if ( output_enabled )  cm -> counts . partition [ ctx ] [ PARTITION_SPLIT ] ++ ;encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;* get_sb_index ( x , subsize ) = 1 ;encode_sb_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled ,  subsize ) ;* get_sb_index ( x , subsize ) = 2 ;encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled ,  subsize ) ;* get_sb_index ( x , subsize ) = 3 ;encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize ) ;default :  assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ;}","if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ ;switch ( partition ) {case PARTITION_NONE : encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;case PARTITION_VERT : if ( output_enabled ) cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ;encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ;default : assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ;}",1233
544,void * _TIFFmalloc ( tmsize_t s )  {return ( malloc ( ( size_t ) s ) ) ;,void * _TIFFmalloc ( tmsize_t s ) {if ( s == 0 ) return ( ( void * ) NULL ) ;return ( malloc ( ( size_t ) s ) ) ;,1234
545,field [ nf ] = lp ;if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) {,field [ nf ] = lp ;if ( nf >= MAXDATEFIELDS ) return - 1 ;if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) {,1235
546,if ( nf > MAXDATEFIELDS )  return - 1 ;,"
",1235
547,u_int16_t port ;unsigned int ret ;exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ;,struct nf_conn * ct = exp -> master ;union nf_inet_addr newaddr ;u_int16_t port ;unsigned int ret ;newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 ;exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ;,1236
548,"nf_ct_helper_log ( skb , exp -> master , ""all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use"" ) ;return NF_DROP ;ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo ,  protoff , matchoff , matchlen , buffer , strlen ( buffer ) ) ;nf_ct_helper_log ( skb , exp -> master , ""cannot<S2SV_blank>mangle<S2SV_blank>packet"" ) ;nf_ct_unexpect_related ( exp ) ;","nf_ct_helper_log ( skb , ct , ""all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use"" ) ;return NF_DROP ;snprintf ( buffer , sizeof ( buffer ) , ""%u<S2SV_blank>%u"" , ntohl ( newaddr . ip ) , port ) ;pr_debug ( ""nf_nat_irc:<S2SV_blank>inserting<S2SV_blank>\\\'%s\\\'<S2SV_blank>==<S2SV_blank>%pI4,<S2SV_blank>port<S2SV_blank>%u\\\ret = nf_nat_mangle_tcp_packet ( skb , ct , ctinfo , protoff , matchoff , matchlen , buffer , strlen ( buffer ) ) ;nf_ct_helper_log ( skb , ct , ""cannot<S2SV_blank>mangle<S2SV_blank>packet"" ) ;nf_ct_unexpect_related ( exp ) ;",1236
549,}return OK ;,"if ( * i == \'\\\\\\\\\' ) {AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ;return HTTP_BAD_REQUEST ;}}return OK ;",1237
550,ipc_lock_object ( & shp -> shm_perm ) ;path = shp -> shm_file -> f_path ;,ipc_lock_object ( & shp -> shm_perm ) ;if ( shp -> shm_file == NULL ) {ipc_unlock_object ( & shp -> shm_perm ) ;err = - EIDRM ;goto out_unlock ;}path = shp -> shm_file -> f_path ;,1238
551,"return ;}switch ( ( gdAffineStandardMatrix ) type ) {case GD_AFFINE_TRANSLATE : case GD_AFFINE_SCALE : {double x , y ;if ( Z_TYPE_P ( options ) != IS_ARRAY ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Array<S2SV_blank>expected<S2SV_blank>as<S2SV_blank>options"" ) ;}if ( zend_hash_find ( HASH_OF ( options ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) {convert_to_double_ex ( tmp ) ;x = Z_DVAL_PP ( tmp ) ;}convert_to_double_ex ( tmp ) ;y = Z_DVAL_PP ( tmp ) ;}",if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;x = Z_DVAL ( dval ) ;}else {x = Z_DVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;y = Z_DVAL ( dval ) ;}else {y = Z_DVAL_PP ( tmp ) ;}},1239
552,if ( test_tsk_need_resched ( rq -> curr ) )  rq -> skip_clock_update = 1 ;,if ( rq -> curr -> se . on_rq && test_tsk_need_resched ( rq -> curr ) ) rq -> skip_clock_update = 1 ;,1240
553,"rc = fsmVerify ( fpath , fi ) ;}","rc = fsmVerify ( fpath , fi , & sb ) ;}",1241
554,if ( ac_size > 0 ) {,{,1242
555,if ( dc_size > 0 ) {unsigned long dest_len = dc_count * 2LL ;if ( dc_count > ( 6LL * td -> xsize * td -> ysize + 63 ) / 64 )  return AVERROR_INVALIDDATA ;,if ( dc_size > 0 ) {unsigned long dest_len = dc_count * 2LL ;if ( dc_count != dc_w * dc_h * 3 ) return AVERROR_INVALIDDATA ;,1242
556,"static void test_show_object ( struct object * object ,  struct strbuf * path ,   const char * last , void * data )  {","static void test_show_object ( struct object * object , const char * last , void * data ) {",1243
557,if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls >  JAS_UINTFAST32_NUMBITS - 2 ||  pirlvl -> prcheightexpn + pi -> picomp -> numrlvls >  JAS_UINTFAST32_NUMBITS - 2 ) {,if ( pirlvl -> prcwidthexpn + picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {,1244
558,if ( name_len == 0 ) goto chunk_end ;name = p ;READ_ENCINT ( length ) ;if ( ( offset == 0 ) && ( length == 0 ) ) {,name = p ;READ_ENCINT ( length ) ;if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ;if ( ( offset == 0 ) && ( length == 0 ) ) {,1245
559,"path -> mnt = mntget ( nd -> path . mnt ) ;if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ;follow_mount ( path ) ;error = 0 ;","path -> mnt = nd -> path . mnt ) ;if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ;mntget ( path -> mnt ) ;follow_mount ( path ) ;error = 0 ;",1246
560,"while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != u4_start_code_val )   && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) )  {","while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != u4_start_code_val ) && ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) ) {",1247
561,if ( msg -> maxsize - msg -> cursize < 4 ) {msg -> overflowed = qtrue ;,if ( msg -> overflowed ) {,1248
562,if ( bits == 8 ) {msg -> data [ msg -> cursize ] = value ;,if ( msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) {msg -> overflowed = qtrue ;return ;}if ( bits == 8 ) {msg -> data [ msg -> cursize ] = value ;,1248
563,nbits = bits & 7 ;for ( i = 0 ;,"nbits = bits & 7 ;if ( msg -> bit , msg -> maxsize << 3 + nbits > msg -> maxsize << 3 ) {msg -> overflowed = qtrue ;return ;}for ( i = 0 ;",1248
564,"Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;value = ( value >> 8 ) ;}}","Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;value = ( value >> 8 ) ;if ( msg -> bit > msg -> maxsize << 3 ) {msg -> overflowed = qtrue ;return ;}}}",1248
565,"if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",1249
566,kgctx . have_acceptor_subkey = 1 ;kb1 . contents = k1buf ;,kgctx . established = 1 ;kgctx . have_acceptor_subkey = 1 ;kb1 . contents = k1buf ;,1250
567,"bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;switch ( rsvp_obj_ctype ) {case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ;ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" ,  ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ;","switch ( rsvp_obj_ctype ) {case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ;bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ;",1251
568,"static vpx_codec_err_t ctrl_use_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {const int reference_flag = va_arg ( args , int ) ;","static vpx_codec_err_t ctrl_use_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {const int reference_flag = va_arg ( args , int ) ;",1252
569,"image -> columns = sun_info . width ;image -> rows = sun_info . height ;image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ;if ( sun_info . depth < 24 ) {size_t one ;image -> storage_class = PseudoClass ;image -> colors = sun_info . maplength ;}switch ( sun_info . maptype ) {case RMT_NONE :  {if ( sun_info . depth < 24 ) {break ;}unsigned char  * sun_colormap ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","image -> colors = sun_info . maplength ;switch ( sun_info . maptype ) {unsigned char * sun_colormap ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",1253
570,if ( ! cpi -> refresh_alt_ref_frame && ( cm -> current_video_frame == 0 ||  ( cm -> frame_flags & FRAMEFLAGS_KEY ) ||  rc -> frames_to_key == 0 ||  ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) {cm -> frame_type = KEY_FRAME ;rc -> frames_to_key = cpi -> key_frame_frequency ;rc -> kf_boost = DEFAULT_KF_BOOST ;rc -> baseline_gf_interval = DEFAULT_GF_INTERVAL ;rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ;if ( rc -> frames_till_gf_update_due > rc -> frames_to_key )  rc -> frames_till_gf_update_due = rc -> frames_to_key ;cpi -> refresh_golden_frame = 1 ;,if ( ! cpi -> refresh_alt_ref_frame && ( cm -> current_video_frame == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) || rc -> frames_to_key == 0 || ( cpi -> oxcf . auto_key && 0 ) ) ) ) {cm -> frame_type = KEY_FRAME ;rc -> frames_to_key = cpi -> oxcf . key_freq ;rc -> kf_boost = DEFAULT_KF_BOOST ;rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ;rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ;if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) {rc -> frames_till_gf_update_due = rc -> frames_to_key ;rc -> constrained_gf_group = 1 ;}else {rc -> constrained_gf_group = 0 ;}cpi -> refresh_golden_frame = 1 ;,1254
571,"opendata = nfs4_opendata_alloc ( & ctx -> path , state -> owner , 0 , NULL ) ;if ( opendata == NULL ) return ERR_PTR ( - ENOMEM ) ;","opendata = nfs4_opendata_alloc ( & ctx -> path , state -> owner , 0 , 0 , NULL ) ;if ( opendata == NULL ) return ERR_PTR ( - ENOMEM ) ;",1255
572,"ERR ( ""callocing<S2SV_blank>this<S2SV_blank>failed"" ) ;goto error ;this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ;if ( this -> sd < 0 ) {ERR ( ""sockect<S2SV_blank>open<S2SV_blank>failed"" ) ;goto error ;struct sockaddr_in6 addr ;addr . sin6_family = AF_INET6 ;addr . sin6_port = htons ( port ) ;addr . sin6_addr = in6addr_any ;if ( bind ( this -> sd , ( struct sockaddr * ) & addr , sizeof addr ) < 0 ) {if ( g_options . only_desired_port == 1 )  ERR ( ""Bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>""  ""Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions."" ) ;ERR ( ""listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" ) ;goto error ;","ERR ( ""IPv4:<S2SV_blank>callocing<S2SV_blank>this<S2SV_blank>failed"" ) ;goto error ;this -> sd = socket ( AF_INET , SOCK_STREAM , 0 ) ;if ( this -> sd < 0 ) {ERR ( ""IPv4<S2SV_blank>socket<S2SV_blank>open<S2SV_blank>failed"" ) ;goto error ;struct sockaddr_in addr ;addr . sin_family = AF_INET ;addr . sin_port = htons ( port ) ;addr . sin_addr . s_addr = htonl ( 0x7F000001 ) ;if ( bind ( this -> sd , ( struct sockaddr * ) & addr , sizeof addr ) < 0 ) {if ( g_options . only_desired_port == 1 ) ERR ( ""IPv4<S2SV_blank>bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>"" ""Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions."" ) ;ERR ( ""IPv4<S2SV_blank>listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" ) ;goto error ;",1256
573,"col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PKTAP"" ) ;col_clear ( pinfo -> cinfo , COL_INFO ) ;ti = proto_tree_add_item ( tree , proto_pktap , tvb , offset , pkt_len , ENC_NA ) ;pktap_tree = proto_item_add_subtree ( ti , ett_pktap ) ;proto_tree_add_item ( pktap_tree , hf_pktap_hdrlen , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;if ( pkt_len < MIN_PKTAP_HDR_LEN ) {proto_tree_add_expert ( tree , pinfo , & ei_pktap_hdrlen_too_short , tvb , offset , 4 ) ;return ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_rectype , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;rectype = tvb_get_letohl ( tvb , offset ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_dlt , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;dlt = tvb_get_letohl ( tvb , offset ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_ifname , tvb , offset , 24 , ENC_ASCII | ENC_NA ) ;offset += 24 ;proto_tree_add_item ( pktap_tree , hf_pktap_flags , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_pfamily , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_llhdrlen , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_lltrlrlen , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_pid , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_cmdname , tvb , offset , 20 , ENC_UTF_8 | ENC_NA ) ;offset += 20 ;proto_tree_add_item ( pktap_tree , hf_pktap_svc_class , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_iftype , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;offset += 2 ;proto_tree_add_item ( pktap_tree , hf_pktap_ifunit , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;offset += 2 ;proto_tree_add_item ( pktap_tree , hf_pktap_epid , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_ecmdname , tvb , offset , 20 , ENC_UTF_8 | ENC_NA ) ;if ( rectype == PKT_REC_PACKET ) {next_tvb = tvb_new_subset_remaining ( tvb , pkt_len ) ;dissector_try_uint ( wtap_encap_dissector_table ,   wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ;}","int wtap_encap ;struct eth_phdr eth ;void * phdr ;col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PKTAP"" ) ;col_clear ( pinfo -> cinfo , COL_INFO ) ;wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ;switch ( wtap_encap ) {case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ;phdr = & eth ;break ;default : phdr = NULL ;break ;}dissector_try_uint_new ( wtap_encap_dissector_table , wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree , TRUE , phdr ) ;",1257
574,"VP9_COMMON * const cm = & cpi -> common ;const VP9_CONFIG * const oxcf = & cpi -> oxcf ;RATE_CONTROL * const rc = & cpi -> rc ;cm -> last_frame_type = cm -> frame_type ;rc -> projected_frame_size = ( int ) ( bytes_used << 3 ) ;vp9_rc_update_rate_correction_factors (  cpi , ( cpi -> sf . recode_loop >= ALLOW_RECODE_KFARFGF ||  oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) ? 2 : 0 ) ;rc -> last_q [ KEY_FRAME ] = cm -> base_qindex ;rc -> avg_frame_qindex [ KEY_FRAME ] = ROUND_POWER_OF_TWO (  3 * rc -> avg_frame_qindex [ KEY_FRAME ] + cm -> base_qindex , 2 ) ;}else if ( ! rc -> is_src_frame_alt_ref &&   ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) &&   ! ( cpi -> use_svc && oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) ) {rc -> last_q [ 2 ] = cm -> base_qindex ;rc -> avg_frame_qindex [ 2 ] = ROUND_POWER_OF_TWO (   3 * rc -> avg_frame_qindex [ 2 ] + cm -> base_qindex , 2 ) ;}rc -> tot_q += vp9_convert_qindex_to_q ( cm -> base_qindex ) ;rc -> avg_q = rc -> tot_q / ( double ) rc -> ni_frames ;rc -> ni_tot_qi += cm -> base_qindex ;rc -> ni_av_qi = rc -> ni_tot_qi / rc -> ni_frames ;}if ( ( cm -> base_qindex < rc -> last_boosted_qindex ) ||   ( ( cpi -> static_mb_pct < 100 ) &&   ( ( cm -> frame_type == KEY_FRAME ) || cpi -> refresh_alt_ref_frame ||  ( cpi -> refresh_golden_frame && ! rc -> is_src_frame_alt_ref ) ) ) ) {rc -> last_boosted_qindex = cm -> base_qindex ;}","const VP9_COMMON * const cm = & cpi -> common ;const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;RATE_CONTROL * const rc = & cpi -> rc ;const int qindex = cm -> base_qindex ;if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) {vp9_cyclic_refresh_postencode ( cpi ) ;}rc -> projected_frame_size = ( int ) ( bytes_used << 3 ) ;vp9_rc_update_rate_correction_factors ( cpi ) ;rc -> last_q [ KEY_FRAME ] = cm -> base_qindex ;rc -> avg_frame_qindex [ KEY_FRAME ] = qindex ;rc -> avg_frame_qindex [ 2 ] = ROUND_POWER_OF_TWO ( 3 * rc -> avg_frame_qindex [ 2 ] + cm -> base_qindex , 2 ) ;}rc -> tot_q += vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ;rc -> avg_q = rc -> tot_q / rc -> ni_frames ;rc -> ni_tot_qi += cm -> base_qindex ;rc -> ni_av_qi = rc -> ni_tot_qi / rc -> ni_frames ;}}if ( ( qindex < rc -> last_boosted_qindex ) || ( ( cpi -> static_mb_pct < 100 ) && ( ( cm -> frame_type == KEY_FRAME ) || ( ! rc -> constrained_gf_group && ( cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! rc -> is_src_frame_alt_ref ) ) ) ) {rc -> last_boosted_qindex = qindex ;}if ( cm -> frame_type == KEY_FRAME ) rc -> last_kf_qindex = qindex ;",1258
575,rc -> total_target_bits += ( cm -> show_frame ? rc -> av_per_frame_bandwidth : 0 ) ;rc -> total_target_vs_actual = rc -> total_actual_bits - rc -> total_target_bits ;if ( oxcf -> play_alternate && cpi -> refresh_alt_ref_frame &&  ( cm -> frame_type != KEY_FRAME ) ) update_alt_ref_frame_stats ( cpi ) ;if ( cm -> frame_type == KEY_FRAME )  rc -> frames_since_key = 0 ;},rc -> total_target_bits += cm -> show_frame ? rc -> av_per_frame_bandwidth : 0 ) ;rc -> total_target_vs_actual = rc -> total_actual_bits - rc -> total_target_bits ;if ( ! cpi -> use_svc ) {if ( is_altref_enabled ( cpi ) && cpi -> refresh_alt_ref_frame && ( cm -> frame_type != KEY_FRAME ) ) update_alt_ref_frame_stats ( cpi ) ;}if ( cm -> frame_type == KEY_FRAME ) rc -> frames_since_key = 0 ;if ( oxcf -> pass != 0 ) {cpi -> resize_pending = rc -> next_frame_size_selector != rc -> frame_size_selector ;rc -> frame_size_selector = rc -> next_frame_size_selector ;}},1258
576,int delegation_type = 0 ;int status ;,fmode_t delegation_type = 0 ;int status ;,1259
577,"old_locale = setlocale ( LC_NUMERIC , ""C"" ) ;rrd_graph_options ( argc , argv , & im ) ;if ( rrd_test_error ( ) ) {rrd_info_free ( im . grinfo ) ;im_free ( & im ) ;","
",1260
578,"rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ;return NULL ;","rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ;return NULL ;",1260
579,"static void findoprnd ( ITEM * ptr , int32 * pos )  {# ifdef BS_DEBUG elog ( DEBUG3 , ( ptr [ * pos ] . type == OPR ) ? ""%d<S2SV_blank><S2SV_blank>%c"" : ""%d<S2SV_blank><S2SV_blank>%d"" , * pos , ptr [ * pos ] . val ) ;","static void findoprnd ( ITEM * ptr , int32 * pos ) {check_stack_depth ( ) ;# ifdef BS_DEBUG elog ( DEBUG3 , ( ptr [ * pos ] . type == OPR ) ? ""%d<S2SV_blank><S2SV_blank>%c"" : ""%d<S2SV_blank><S2SV_blank>%d"" , * pos , ptr [ * pos ] . val ) ;",1261
580,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_ARP_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",1262
581,"static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  {","static void record_and_restart ( struct perf_event * event , unsigned long val , struct pt_regs * regs ) {",1263
582,"if ( perf_event_overflow ( event , nmi , & data , regs ) )  fsl_emb_pmu_stop ( event , 0 ) ;","if ( perf_event_overflow ( event , & data , regs ) ) fsl_emb_pmu_stop ( event , 0 ) ;",1263
583,"ctxt -> dst . type = OP_REG ;ctxt -> dst . addr . reg = & ctxt -> _eip ;ctxt -> dst . bytes = ctxt -> op_bytes ;rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;","unsigned long eip ;rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;rc = assign_eip_near ( ctxt , eip ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;",1264
584,"r = parse_gid ( e + 1 , & gid ) ;if ( r < 0 ) goto not_found ;","if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;r = parse_gid ( e + 1 , & gid ) ;if ( r < 0 ) goto not_found ;",1265
585,"static void reconstruct_inter_block ( int plane , int block ,  BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {struct inter_args * args = ( struct inter_args * ) arg ;VP9_COMMON * const cm = args -> cm ;MACROBLOCKD * const xd = args -> xd ;struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;int x , y , eob ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ;eob = vp9_decode_block_tokens ( cm , xd , plane , block , plane_bsize , x , y ,  tx_size , args -> r ) ;inverse_transform_block ( xd , plane , block , tx_size ,   & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ,  pd -> dst . stride , eob ) ;* args -> eobtotal += eob ;}","static int reconstruct_inter_block ( MACROBLOCKD * const xd = args -> xd ;struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;int x , y , eob ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ;eob = vp9_decode_block_tokens ( xd , plane , block , tx_size , & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] , pd -> dst . stride , eob ) ;return eob ;}",1266
586,"dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;if ( dh == NULL ) {","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;if ( dh == NULL ) {",1267
587,"
",if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ;,1268
588,length += len ;},length += len ;},1268
589,"
",struct name_snapshot name ;,1269
590,"mask |= FS_EVENT_ON_CHILD ;if ( path )  ret = fsnotify ( p_inode , mask , path , FSNOTIFY_EVENT_PATH ,  dentry -> d_name . name , 0 ) ;else ret = fsnotify ( p_inode , mask , dentry -> d_inode , FSNOTIFY_EVENT_INODE ,  dentry -> d_name . name , 0 ) ;}","mask |= FS_EVENT_ON_CHILD ;take_dentry_name_snapshot ( & name , dentry ) ;if ( path ) ret = fsnotify ( p_inode , mask , path , FSNOTIFY_EVENT_PATH , name . name , 0 ) ;else ret = fsnotify ( p_inode , mask , dentry -> d_inode , FSNOTIFY_EVENT_INODE , name . name , 0 ) ;release_dentry_name_snapshot ( & name ) ;}",1269
591,"size_t ss = CDF_SEC_SIZE ( h ) , i , j ;scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ;","size_t ss = CDF_SHORT_SEC_SIZE ( h ) , i , j ;scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ;",1270
592,tcon -> bad_network_name = true ;},if ( tcon ) tcon -> bad_network_name = true ;},1271
593,"memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ;rate_len = rate_ie -> len ;if ( rate_ie )   memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ;return ;","if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ;memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ;rate_len = rate_ie -> len ;if ( rate_ie ) {if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ;memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ;}return ;",1272
594,"agoo_log_cat ( & agoo_con_cat , ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]"" ,   getpid ( ) , ( unsigned long long ) cnt , b -> id , con -> sock ) ;con_cnt = atomic_fetch_add ( & agoo_server . con_cnt , 1 ) ;","agoo_log_cat ( & agoo_con_cat , ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]<S2SV_blank>from<S2SV_blank>%s"" , getpid ( ) , ( unsigned long long ) cnt , b -> id , con -> sock , con -> remote ) ;con_cnt = atomic_fetch_add ( & agoo_server . con_cnt , 1 ) ;",1273
595,"int ret ;ret = strdup_if_nonnull ( & target -> cr_principal , source -> cr_principal ) ;if ( ret )  return ret ;ret = strdup_if_nonnull ( & target -> cr_raw_principal , source -> cr_raw_principal ) ;if ( ret ) return ret ;","target -> cr_principal , source -> cr_principal , GFP_KERNEL ) ;target -> cr_raw_principal = kstrdup ( source -> cr_raw_principal , GFP_KERNEL ) ;if ( ( source -> cr_principal && ! target -> cr_principal ) || ( source -> cr_raw_principal && ! target -> cr_raw_principal ) ) return - ENOMEM ;",1274
596,assert ( offset >= capoff ) ;if ( offset == capoff || offset == capoff + 1 ) {,if ( offset == capoff || offset == capoff + 1 ) {,1275
597,"r = mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" ) ;if ( r < 0 ) {","r = safe_mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" , root ) ;if ( r < 0 ) {",1276
598,"int err = 0 ;ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\\","int err = 0 ;BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) ;ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\\",1277
599,"err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;","if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) {if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ;else err = ext4_ext_zeroout ( inode , ex ) ;}else err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;",1277
600,"void vp9_temporal_filter_apply_c ( uint8_t * frame1 , unsigned int stride , uint8_t * frame2 ,  unsigned int block_size ,  int strength , int filter_weight , unsigned int * accumulator , uint16_t * count ) {for ( i = 0 , k = 0 ;i < block_size ;for ( j = 0 ;j < block_size ;int src_byte = frame1 [ byte ] ;modifier += 1 << ( strength - 1 ) ;modifier >>= strength ;","void vp9_temporal_filter_apply_c ( uint8_t * frame1 , unsigned int block_width , unsigned int block_height , int strength , int filter_weight , unsigned int * accumulator , uint16_t * count ) {const int rounding = strength > 0 ? 1 << ( strength - 1 ) : 0 ;for ( i = 0 , k = 0 ;i < block_height ;for ( j = 0 ;j < block_width ;int src_byte = frame1 [ byte ] ;modifier += rounding ;modifier >>= strength ;",1278
601,byte += stride - block_size ;},byte += stride - block_width ;},1278
602,case PCIBAR_MEMHI64 :  assert ( idx >= 1 ) ;mask = ~ ( dev -> bar [ idx - 1 ] . size - 1 ) ;default :  assert ( 0 ) ;},"case PCIBAR_MEMHI64 : mask = ~ ( dev -> bar [ idx - 1 ] . size - 1 ) ;default : pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\\return ;}",1279
603,"return check_mac_perms_from_lookup ( spid , uid , perm , str8 ( name , name_len ) ) ? 1 : 0 ;}","if ( uid >= AID_APP ) {return 0 ;}return check_mac_perms_from_lookup ( spid , uid , perm , str8 ( name , name_len ) ) ? 1 : 0 ;}",1280
604,if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ;BeginOfThisString = Offset - SizeOfHeader - 8 ;,if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ;if ( ( Offset + Len ) > SizeOfTag + 8 ) goto Error ;BeginOfThisString = Offset - SizeOfHeader - 8 ;,1281
605,void ext4_xattr_destroy_cache ( struct mb_cache * cache )  {if ( cache )  mb_cache_destroy ( cache ) ;},void ext4_xattr_destroy_cache ( struct mb2_cache * cache ) {if ( cache ) mb2_cache_destroy ( cache ) ;},1282
606,"
",mu_run_test ( test_r_str_escape_sh ) ;,1283
607,mu_run_test ( test_r_str_unescape ) ;mu_run_test ( test_r_str_constpool ) ;,mu_run_test ( test_r_str_unescape ) ;mu_run_test ( test_r_str_constpool ) ;,1283
608,sbinfo -> hstate = config . hstate ;spin_lock_init ( & sbinfo -> stat_lock ) ;sbinfo -> max_blocks = config . nr_blocks ;sbinfo -> free_blocks = config . nr_blocks ;sbinfo -> max_inodes = config . nr_inodes ;,sbinfo -> max_inodes = config . nr_inodes ;sbinfo -> spool = NULL ;if ( config . nr_blocks != - 1 ) {sbinfo -> spool = hugepage_new_subpool ( config . nr_blocks ) ;if ( ! inode ) goto out_free ;},1284
609,if ( ! inode )  goto out_free ;root = d_alloc_root ( inode ) ;if ( ! root ) {out_free :  kfree ( sbinfo ) ;return - ENOMEM ;,if ( ! inode ) goto out_free ;root = d_alloc_root ( inode ) ;if ( ! root ) {out_free : if ( sbinfo -> spool ) kfree ( sbinfo -> spool ) ;kfree ( sbinfo ) ;return - ENOMEM ;,1284
610,"U2FHID_INIT_RESP initresp ;if ( resplen > sizeof ( initresp ) )  {return U2FH_MEMORY_ERROR ;memcpy ( & initresp , resp , resplen ) ;dev -> cid = initresp . cid ;dev -> versionInterface = initresp . versionInterface ;dev -> versionMajor = initresp . versionMajor ;dev -> versionMinor = initresp . versionMinor ;dev -> capFlags = initresp . capFlags ;}","int offs = sizeof ( nonce ) ;if ( resplen < 17 ) {return U2FH_SIZE_ERROR ;}if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) {return U2FH_TRANSPORT_ERROR ;}dev -> cid = resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ;offs += 4 ;dev -> versionInterface = resp [ offs ++ ] ;dev -> versionMajor = resp [ offs ++ ] ;dev -> versionMinor = resp [ offs ++ ] ;dev -> versionBuild = resp [ offs ++ ] ;dev -> capFlags = resp [ offs ++ ] ;",1285
611,"if ( ! lp || ! timestring || ! timefield )  return MS_FALSE ;if ( strstr ( timestring , "","" ) == NULL && strstr ( timestring , ""/"" ) == NULL ) {","if ( ! lp || ! timestring || ! timefield ) return MS_FALSE ;if ( strchr ( timestring , \'\\\\\'\' ) || strchr ( timestring , \'\\\\\\\\\' ) ) {msSetError ( MS_MISCERR , ""Invalid<S2SV_blank>time<S2SV_blank>filter."" , ""msPostGISLayerSetTimeFilter()"" ) ;return MS_FALSE ;}if ( strstr ( timestring , "","" ) == NULL && strstr ( timestring , ""/"" ) == NULL ) {",1286
612,"return recv ( socket -> fd , buf , count , MSG_DONTWAIT ) ;}","return TEMP_FAILURE_RETRY ( recv ( socket -> fd , buf , count , MSG_DONTWAIT ) ) ;}",1287
613,"if ( ( creds -> pid == task_tgid_vnr ( current ) ||  ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) &&  ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {","if ( ( creds -> pid == task_tgid_vnr ( current ) || ns_capable ( task_active_pid_ns ( current ) -> user_ns , CAP_SYS_ADMIN ) ) && ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {",1288
614,"static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",1289
615,int ret = 0 ;if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ;,"int ret = 0 ;if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ;if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ;",1290
616,"ND_TCHECK ( pptr [ 0 ] ) ;plen = pptr [ 0 ] ;if ( 0 == plen ) {snprintf ( buf , buflen , ""default<S2SV_blank>route<S2SV_blank>target"" ) ;return 1 ;}if ( 32 > plen ) return - 1 ;plen -= 32 ;if ( 64 < plen ) return - 1 ;memset ( & route_target , 0 , sizeof ( route_target ) ) ;ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ;memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ;if ( plen % 8 ) {snprintf ( buf , buflen , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" ,  as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) ,  bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ;","char asbuf [ sizeof ( astostr ) ] ;ND_TCHECK ( pptr [ 5 ] , ( plen + 7 ) / 8 ) ;memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ;if ( plen % 8 ) {snprintf ( buf , buflen , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ;",1291
617,"cork -> length += length ;if ( length > mtu ) {int proto = sk -> sk_protocol ;if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ;if ( proto == IPPROTO_UDP &&  ( rt -> dst . dev -> features & NETIF_F_UFO ) ) {}if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ;","if ( ( length > mtu ) {int proto = sk -> sk_protocol ;if ( dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ;skb = skb_peek_tail ( & sk -> sk_write_queue ) ;cork -> length += length ;if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) ) {if ( ! skb ) goto alloc_new_skb ;",1292
618,"verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j )  vstart += verdef -> vd_aux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {","verdef -> vd_version = READ16 ( dfs , j ) int vdaux = verdef -> vd_aux ;if ( vdaux < 1 ) {sdb_free ( sdb_verdef ) ;goto out_error ;}vstart += vdaux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {",1293
619,mapping = ( struct address_space * ) page_private ( page ) ;mutex_lock ( & mapping -> i_mmap_mutex ) ;,mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping ;mutex_lock ( & mapping -> i_mmap_mutex ) ;,1294
620,"zap = key -> payload . data [ 0 ] ;rcu_assign_keypointer ( key , upayload ) ;key -> expiry = 0 ;","if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) zap = key -> payload . data [ 0 ] ;else zap = NULL ;rcu_assign_keypointer ( key , upayload ) ;key -> expiry = 0 ;",1295
621,"void vp9_fht8x8_c ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {vp9_fdct8x8_c ( input , output , stride ) ;}int16_t out [ 64 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;int16_t temp_in [ 8 ] , temp_out [ 8 ] ;const transform_2d ht = FHT_8 [ tx_type ] ;++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;++ j )  outptr [ j * 8 + i ] = temp_out [ j ] ;}","void vp9_fht8x8_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {vpx_fdct8x8_c ( input , output , stride ) ;}tran_low_t out [ 64 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;tran_low_t temp_in [ 8 ] , temp_out [ 8 ] ;const transform_2d ht = FHT_8 [ tx_type ] ;+ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;++ j ) out [ j * stride + i ] * 4 ;+ j )  outptr [ j * 8 + i ] = temp_out [ j ] ;++ j ) outptr [ j * 8 + i ] = temp_out [ j ] ;}",1296
622,"emul : perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , xcp , 0 ) ;MIPS_FPU_EMU_INC_STATS ( emulated ) ;","emul : perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , xcp , 0 ) ;MIPS_FPU_EMU_INC_STATS ( emulated ) ;",1297
623,"if ( s -> chunksize >= 0 ) {if ( ! s -> chunksize ) {s -> chunksize = strtoll ( line , NULL , 16 ) ;av_log ( NULL , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\\\'\\\if ( ! s -> chunksize )  return 0 ;}int64_t target = h -> is_streamed ? 0 : s -> off ;if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ;av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 ""<S2SV_blank>error=%s.\\\av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ;av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 "".\\\return read_ret ;","if ( s -> chunksize != UINT64_MAX ) {if ( ! s -> chunksize ) {s -> chunksize = strtoull ( line , NULL , 16 ) ;av_log ( h , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\\\'\\\if ( ! s -> chunksize ) return 0 ;else if ( s -> chunksize == UINT64_MAX ) {av_log ( h , AV_LOG_ERROR , ""Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%"" PRIu64 ""\\\return AVERROR ( EINVAL ) ;}}uint64_t target = h -> is_streamed ? 0 : s -> off ;if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ;av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRIu64 ""<S2SV_blank>error=%s.\\\av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ;av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRIu64 "".\\\return read_ret ;",1298
624,int iSrc ;res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;,int iSrc ;,1299
625,for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},1299
626,"if ( uref -> field_index >= report -> maxfield ) goto inval ;field = report -> field [ uref -> field_index ] ;if ( uref -> usage_index >= field -> maxusage ) goto inval ;uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ;if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ;goto goodreturn ;default : if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT ) goto inval ;if ( uref -> report_id == HID_REPORT_ID_UNKNOWN ) {field = hiddev_lookup_usage ( hid , uref ) ;if ( field == NULL ) goto inval ;else {rinfo . report_type = uref -> report_type ;rinfo . report_id = uref -> report_id ;","
",1300
627,else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) &&  ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ;}switch ( cmd ) {,else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ;}switch ( cmd ) {,1300
628,"ALOGE ( ""b/26366256"" ) ;return ;","ALOGE ( ""b/26366256"" ) ;android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ;return ;",1301
629,void unix_inflight ( struct file * fp )  {,"void unix_inflight ( struct user_struct * user , struct file * fp ) {",1302
630,fp -> f_cred -> user -> unix_inflight ++ ;spin_unlock ( & unix_gc_lock ) ;,user -> unix_inflight ++ ;spin_unlock ( & unix_gc_lock ) ;,1302
631,"static int pimv2_addr_print ( netdissect_options * ndo ,  const u_char * bp , enum pimv2_addrtype at , int silent )  {int len , hdrlen ;ND_TCHECK ( bp [ 0 ] ) ;if ( pimv2_addr_len == 0 ) {len = sizeof ( struct in_addr ) ;break ;len = sizeof ( struct in6_addr ) ;break ;switch ( pimv2_addr_len ) {case sizeof ( struct in_addr ) : af = AF_INET ;break ;case sizeof ( struct in6_addr ) : af = AF_INET6 ;len = pimv2_addr_len ;hdrlen = 0 ;switch ( at ) {case pimv2_unicast :  ND_TCHECK2 ( bp [ 0 ] , len ) ;if ( af == AF_INET ) {return hdrlen + len ;case pimv2_group : case pimv2_source :  ND_TCHECK2 ( bp [ 0 ] , len + 2 ) ;if ( af == AF_INET ) {","static int pimv2_addr_print ( netdissect_options * ndo , const u_char * bp , u_int len , enum pimv2_addrtype at , u_int addr_len , int silent ) {int hdrlen ;if ( addr_len == 0 ) {if ( len < 2 ) goto trunc ;len = sizeof ( struct in_addr ) ;break ;len = sizeof ( struct in6_addr ) ;break ;switch ( pimv2_addr_len ) {case sizeof ( struct in_addr ) : af = AF_INET ;addr_len = ( u_int ) sizeof ( struct in6_addr ) : af = AF_INET6 ;hdrlen = 0 ;len -= hdrlen ;switch ( at ) {case pimv2_unicast : if ( len < addr_len ) goto trunc ;ND_TCHECK2 ( bp [ 0 ] , addr_len ) ;if ( af == AF_INET ) {return hdrlen + addr_len ;case pimv2_group : case pimv2_source : if ( len < addr_len + 2 ) goto trunc ;ND_TCHECK2 ( bp [ 0 ] , addr_len + 2 ) ;if ( af == AF_INET ) {",1303
632,return hdrlen + 2 + len ;default : return - 1 ;,return hdrlen + 2 + addr_len ;default : return - 1 ;,1303
633,"DPRINTF ( ""Read<S2SV_blank>sector_count=%d\\\if ( r -> sector_count == 0 ) {scsi_req_complete ( & r -> req , GOOD ) ;return ;}assert ( r -> req . aiocb == NULL ) ;if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) {DPRINTF ( ""Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\\scsi_read_complete ( r , - EINVAL ) ;return ;}n = r -> sector_count ;if ( n > SCSI_DMA_BUF_SIZE / 512 ) n = SCSI_DMA_BUF_SIZE / 512 ;r -> iov . iov_len = n * 512 ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ;r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n ,  scsi_read_complete , r ) ;","r -> iov . iov_len = n * 512 ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ;r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , scsi_read_complete , r ) ;",1304
634,match_length += callback_args -> forward_matches ;if ( callback_args -> full_word ) {,match_length += callback_args -> forward_matches ;assert ( match_offset + match_length <= callback_args -> data_size ) ;if ( callback_args -> full_word ) {,1305
635,if ( string -> space == 0 )  string -> space = 1 ;else  string -> space *= 2 ;if ( string -> space < 0 )  {new_len = string -> space = G_MAXINT - 8 ;},"if ( string -> space == 0 ) {string -> space = 4 ;}else {const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ;guint more_space = ( guint ) string -> space * 2 ;if ( string -> space < 0 ) {new_len = string -> space = more_space ;}",1306
636,newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;,newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;,1307
637,newnp -> pktoptions = NULL ;newnp -> opt = NULL ;,newnp -> pktoptions = NULL ;newnp -> opt = NULL ;,1307
638,"szLineConv [ i ] = 0 ;strcpy ( szLine , szLineConv ) ;","if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;szLineConv [ i ] = 0 ;strcpy ( szLine , szLineConv ) ;",1308
639,"ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc ,  ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ;","ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ;ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ;ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ;ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ;ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ;ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ;",1309
640,if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag )  ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ;,ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ;ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ;if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ;,1309
641,"cmdline_status = options_cmdline ( arg1 , arg2 ) ;if ( cmdline_status )  return cmdline_status ;options_apply ( ) ;if ( bind_ports ( ) )  return 1 ;# ifdef HAVE_CHROOT if ( change_root ( ) )  return 1 ;# endif if ( drop_privileges ( 1 ) )  return 1 ;if ( log_open ( SINK_OUTFILE ) )  return 1 ;# ifndef USE_FORK num_clients = 0 ;","log_flush ( LOG_MODE_BUFFER ) ;cmdline_status = options_cmdline ( arg1 , arg2 ) ;if ( cmdline_status ) {log_flush ( LOG_MODE_ERROR ) ;return cmdline_status ;}options_free ( 1 ) ;options_apply ( ) ;if ( bind_ports ( ) ) {unbind_ports ( ) ;options_free ( 1 ) ;options_defaults ( ) ;options_apply ( ) ;log_flush ( LOG_MODE_ERROR ) ;return 1 ;}# ifdef HAVE_CHROOT if ( change_root ( ) ) {log_flush ( LOG_MODE_ERROR ) ;return 1 ;}# endif if ( drop_privileges ( 1 ) ) {log_flush ( LOG_MODE_ERROR ) ;return 1 ;}if ( log_open ( SINK_OUTFILE ) ) {log_flush ( LOG_MODE_ERROR ) ;return 1 ;}# ifndef USE_FORK num_clients = 0 ;",1310
642,"else len = get_line_size ( * b , * avail , nl ) ;","else len = get_line_size ( * b + len , * avail - len , nl ) ;",1311
643,"len = get_line_size ( * b , * avail , nl ) ;if ( len >= 0 ) len += tested ;","len = get_line_size ( * b , * avail , nl ) ;if ( len >= 0 ) len += tested ;",1311
644,"else {vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",1312
645,"else {vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",1312
646,"static INLINE int cost_coeffs ( MACROBLOCK * x ,  int plane , int block , ENTROPY_CONTEXT * A , ENTROPY_CONTEXT * L , TX_SIZE tx_size , const int16_t * scan , const int16_t * nb , int use_fast_coef_costing ) {const struct macroblockd_plane * pd = & xd -> plane [ plane ] ;const PLANE_TYPE type = pd -> plane_type ;const int16_t * band_count = & band_counts [ tx_size ] [ 1 ] ;const int eob = p -> eobs [ block ] ;const int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;unsigned int ( * token_costs ) [ 2 ] [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = x -> token_costs [ tx_size ] [ type ] [ is_inter_block ( mbmi ) ] ;int c , cost ;assert ( type == PLANE_TYPE_Y ? mbmi -> tx_size == tx_size  : get_uv_tx_size ( mbmi ) == tx_size ) ;if ( eob == 0 ) {int prev_t = vp9_dct_value_tokens_ptr [ v ] . token ;cost = ( * token_costs ) [ 0 ] [ pt ] [ prev_t ] + vp9_dct_value_cost_ptr [ v ] ;token_cache [ 0 ] = vp9_pt_energy_class [ prev_t ] ;int t ;v = qcoeff [ rc ] ;t = vp9_dct_value_tokens_ptr [ v ] . token ;if ( use_fast_coef_costing ) {cost += ( * token_costs ) [ ! prev_t ] [ ! prev_t ] [ t ] + vp9_dct_value_cost_ptr [ v ] ;}cost += ( * token_costs ) [ ! prev_t ] [ pt ] [ t ] + vp9_dct_value_cost_ptr [ v ] ;token_cache [ rc ] = vp9_pt_energy_class [ t ] ;","static int cost_coeffs ( MACROBLOCK * x , int plane , int block , ENTROPY_CONTEXT * A , ENTROPY_CONTEXT * L , TX_SIZE tx_size , const int16_t * scan , const int16_t * nb , int use_fast_coef_costing ) {const tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;unsigned int ( * token_costs ) [ 2 ] [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = x -> token_costs [ tx_size ] [ type ] [ is_inter_block ( mbmi ) ] ;int c , cost ;# if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ;# else const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ;# endif assert ( type == PLANE_TYPE_Y ? mbmi -> tx_size == tx_size : get_uv_tx_size ( mbmi , pd ) == tx_size ) ;if ( eob == 0 ) {int16_t prev_t ;EXTRABIT e ;vp9_get_token_extra ( v , & prev_t , & e ) ;cost = ( * token_costs ) [ 0 ] [ pt ] [ prev_t ] + vp9_get_cost ( prev_t , e , cat6_high_cost ) ;token_cache [ 0 ] = vp9_pt_energy_class [ prev_t ] ;int16_t t ;v = qcoeff [ rc ] ;vp9_get_token_extra ( v , & t , & e ) ;if ( use_fast_coef_costing ) {cost += ( * token_costs ) [ ! prev_t ] [ ! prev_t ] [ t ] + vp9_get_cost ( t , e , cat6_high_cost ) ;}cost += ( * token_costs ) [ ! prev_t ] [ pt ] [ t ] + vp9_get_cost ( t , e , cat6_high_cost ) ;token_cache [ rc ] = vp9_pt_energy_class [ t ] ;",1313
647,if ( net != c_net || ! tc -> t_sock )  continue ;,if ( net != c_net ) continue ;,1314
648,"CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ;CU_add_test ( parserTestSuite , ""State<S2SV_blank>machine"" , test_stateMachine ) ;","CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail"" , test_parser_hvi ) ;CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ;CU_add_test ( parserTestSuite , ""State<S2SV_blank>machine"" , test_stateMachine ) ;",1315
649,"}target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ;","}m -> msg_namelen = 0 ;target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ;",1316
650,return NF_ACCEPT ;},return err == 0 ? NF_ACCEPT : NF_DROP ;},1317
651,"separator = strchr ( line , ':' ) ;if ( separator == NULL ) return ERROR_INVALID_SYNTAX ;","separator = osStrchr ( line , ':' ) ;if ( separator == NULL ) return ERROR_INVALID_SYNTAX ;",1318
652,"
",if ( plenbytes < 0 ) return plenbytes ;,1319
653,"}ND_PRINT ( ( ndo , ""%s"" , buf ) ) ;","}ND_PRINT ( ( ndo , ""%s"" , buf ) ) ;",1319
654,"msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ;if ( msg -> fp ) return 0 ;","msg -> fp = mutt_bcache_get ( pop_data -> bcache , cache_id ( h -> data ) ) ;if ( msg -> fp ) return 0 ;",1320
655,"msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ;if ( ! msg -> fp ) {","msg -> fp = mutt_bcache_put ( pop_data -> bcache , cache_id ( h -> data ) ) ;if ( ! msg -> fp ) {",1320
656,"if ( bcache )  mutt_bcache_commit ( pop_data -> bcache , h -> data ) ;else {","if ( bcache ) mutt_bcache_commit ( pop_data -> bcache , cache_id ( h -> data ) ) ;else {",1320
657,"else ND_PRINT ( ( ndo , ""[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>"" ) ) ;}}ND_PRINT ( ( ndo , ""ICMP6,<S2SV_blank>%s"" , tok2str ( icmp6_type_values , ""unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)"" , dp -> icmp6_type ) ) ) ;if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ;","ND_TCHECK ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ;",1321
658,"if ( dp -> icmp6_data16 [ 1 ] & 0xc0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""M"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x40 )  ND_PRINT ( ( ndo , ""O"" ) ) ;","if ( dp -> icmp6_data16 [ 1 ] ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;",1321
659,struct serial_icounter_struct icount ;struct sb_uart_icount cnow ;,struct serial_icounter_struct icount = {};struct sb_uart_icount cnow ;,1322
660,"r = mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" ) ;if ( r < 0 ) {","r = safe_mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" , root ) ;if ( r < 0 ) {",1323
661,"Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ;","if ( len > INT_MAX ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ;RETURN_FALSE ;}Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ;",1324
662,"# define ThrowDCMException ( exception , message ) {}char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;","# define ThrowDCMException ( exception , message ) \\\\\\\\\\char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;",1325
663,"if ( length > GetBlobSize ( image ) )  ThrowReaderException ( CorruptImageError ,  ""InsufficientImageDataInFile"" ) ;","if ( length > GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",1325
664,"strlcpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;","strncpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;",1326
665,lock_sock ( sk ) ;opt -> src_addr = sp -> sa_addr . pptp ;,if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;lock_sock ( sk ) ;opt -> src_addr = sp -> sa_addr . pptp ;,1327
666,int err ;lookup_protocol : err = - ESOCKTNOSUPPORT ;,int err ;if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL ;lookup_protocol : err = - ESOCKTNOSUPPORT ;,1328
667,return ( ( f != NULL &&   f -> addressFamily != NULL && f -> addressFamily -> data != NULL )   ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) )  : 0 ) ;,if ( f == NULL || f -> addressFamily != NULL && f -> addressFamily == NULL || f -> addressFamily -> data [ 0 ] << 8 ) | f -> addressFamily -> data [ 1 ] ;,1329
668,assert ( image_info != ( const ImageInfo * ) NULL ) ;,assert ( image_info != ( const ImageInfo * ) NULL ) {scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;;,1330
669,"if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;","}if ( chroma_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;",1330
670,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,1330
671,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) {scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;;,1330
672,"if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( y = 0 ;","if ( resize_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}for ( y = 0 ;",1330
673,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,1330
674,"if ( arg_zsh ) {if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ;struct stat s ;if ( stat ( fname , & s ) == 0 ) return ;if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) {if ( is_link ( ""/etc/skel/.zshrc"" ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.zshrc<S2SV_blank>file\\\exit ( 1 ) ;}if ( copy_file ( ""/etc/skel/.zshrc"" , fname ) == 0 ) {if ( chown ( fname , u , g ) == - 1 )  errExit ( ""chown"" ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ;}}else {FILE * fp = fopen ( fname , ""w"" ) ;if ( fp ) {fprintf ( fp , ""\\\fclose ( fp ) ;if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ;if ( chmod ( fname , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chown"" ) ;fs_logger2 ( ""touch"" , fname ) ;}}free ( fname ) ;}else if ( arg_csh ) {if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ;struct stat s ;if ( stat ( fname , & s ) == 0 ) return ;if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {if ( is_link ( ""/etc/skel/.cshrc"" ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.cshrc<S2SV_blank>file\\\if ( copy_file ( ""/etc/skel/.cshrc"" , fname ) == 0 ) {if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ;}FILE * fp = fopen ( fname , ""w"" ) ;if ( fp ) {fprintf ( fp , ""\\\fclose ( fp ) ;if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ;if ( chmod ( fname , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chown"" ) ;}if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) {if ( is_link ( ""/etc/skel/.bashrc"" ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.bashrc<S2SV_blank>file\\\if ( copy_file ( ""/etc/skel/.bashrc"" , fname ) == 0 ) {if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ;free ( fname ) ;}}","if ( is_link ( fname ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\\if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {copy_file_as_user ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ;touch_file_as_user ( fname , u , g , 0644 ) ;if ( is_link ( fname ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\\if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) {copy_file_as_user ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) ;",1331
675,"s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",1332
676,"case SCSI_REQ_STATUS_RETRY_FLUSH :  ret = scsi_disk_emulate_command ( r , r -> iov . iov_base ) ;if ( ret == 0 ) {",case SCSI_REQ_STATUS_RETRY_FLUSH : ret = scsi_disk_emulate_command ( r ) ;if ( ret == 0 ) {,1333
677,"af = EXTRACT_16BITS ( tptr ) ;safi = tptr [ 2 ] ;ND_PRINT ( ( ndo , ""\\\switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ;default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""\\\if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\goto done ;break ;}tptr += 3 ;ND_TCHECK ( tptr [ 0 ] ) ;nhlen = tptr [ 0 ] ;tlen = nhlen ;tptr ++ ;if ( tlen ) {int nnh = 0 ;ND_PRINT ( ( ndo , ""\\\while ( tlen > 0 ) {if ( nnh ++ > 0 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ;}switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ;tlen -= sizeof ( struct in_addr ) ;tptr += sizeof ( struct in_addr ) ;}break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ;tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;}break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ;tlen -= sizeof ( struct in6_addr ) ;tptr += sizeof ( struct in6_addr ) ;}break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ;tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;}break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ;tlen -= ( sizeof ( struct in_addr ) ) ;tptr += ( sizeof ( struct in_addr ) ) ;}break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ;tptr += tlen ;tlen = 0 ;break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ;if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ;else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ;tptr += tlen ;tlen = 0 ;}break ;default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ;if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\tptr += tlen ;tlen = 0 ;goto done ;break ;}}}ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ;tptr += tlen ;ND_TCHECK ( tptr [ 0 ] ) ;snpa = tptr [ 0 ] ;tptr ++ ;if ( snpa ) {ND_PRINT ( ( ndo , ""\\\for ( ;snpa > 0 ;snpa -- ) {ND_TCHECK ( tptr [ 0 ] ) ;ND_PRINT ( ( ndo , ""\\\tptr += tptr [ 0 ] + 1 ;}}else {ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ;}while ( len - ( tptr - pptr ) > 0 ) {switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;default : ND_TCHECK2 ( * tptr , tlen ) ;ND_PRINT ( ( ndo , ""\\\if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\advance = 0 ;tptr = pptr + len ;break ;}if ( advance < 0 ) break ;tptr += advance ;}done : break ;case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ;af = EXTRACT_16BITS ( tptr ) ;safi = tptr [ 2 ] ;ND_PRINT ( ( ndo , ""\\\if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\\while ( len - ( tptr - pptr ) > 0 ) {switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ;ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ;if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\\advance = 0 ;tptr = pptr + len ;break ;}if ( advance < 0 ) break ;tptr += advance ;}break ;case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;break ;}while ( tlen > 0 ) {uint16_t extd_comm ;ND_TCHECK2 ( tptr [ 0 ] , 2 ) ;extd_comm = EXTRACT_16BITS ( tptr ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ;switch ( extd_comm ) {case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ;break ;case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ;break ;case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ;break ;case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ;break ;case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ;break ;case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ;break ;case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ;break ;case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ;break ;default : ND_TCHECK2 ( * tptr , 8 ) ;print_unknown_data ( ndo , tptr , ""\\\break ;}tlen -= 8 ;tptr += 8 ;}break ;case BGPTYPE_PMSI_TUNNEL : {uint8_t tunnel_type , flags ;tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;ND_PRINT ( ( ndo , ""\\\tptr += 5 ;tlen -= 5 ;switch ( tunnel_type ) {case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\print_unknown_data ( ndo , tptr , ""\\\break ;}case BGPTYPE_AIGP : {uint8_t type ;uint16_t length ;ND_TCHECK2 ( tptr [ 0 ] , 3 ) ;tlen = len ;while ( tlen >= 3 ) {type = * tptr ;length = EXTRACT_16BITS ( tptr + 1 ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ;switch ( type ) {case BGP_AIGP_TLV :  ND_TCHECK2 ( tptr [ 3 ] , 8 ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 ,  EXTRACT_64BITS ( tptr + 3 ) ) ) ;break ;default : if ( ndo -> ndo_vflag <= 1 ) {print_unknown_data ( ndo , tptr + 3 , ""\\\}}","type = * tptr ;length = EXTRACT_16BITS ( tptr + 1 ) ;tlen -= 3 ;ND_PRINT ( ( ndo , ""\\\if ( length < 3 ) goto trunc ;length -= 3 ;ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ;switch ( type ) {case BGP_AIGP_TLV : ND_TCHECK2 ( tptr [ 3 ] , 8 ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr + 3 ) ) ) ;print_unknown_data ( ndo , tptr + 3 , ""\\\",1334
678,state -> object_nl = NULL ;}}else {if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ;state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ;state -> object_nl_len = len ;,"state -> object_nl = fstrndup ( RSTRING_PTR ( object_nl ) , len ) ;state -> object_nl_len = len ;",1335
679,y < nb_blocks ;,y < FFMIN ( nb_blocks ;,1336
680,"for ( y = 0 ;y < s -> ymin ;memset ( ptr , 0 , out_line_size ) ;","for ( y = 0 ;y < s -> ymin , s -> h ) ;memset ( ptr , 0 , out_line_size ) ;",1336
681,"for ( ac = 0 ;int count = skb_queue_len ( & pending ) , tmp ;","spin_lock ( & sta -> ps_lock ) ;for ( ac = 0 ;int count = skb_queue_len ( & pending ) , tmp ;",1337
682,"ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ;if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) {","ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ;spin_unlock ( & sta -> ps_lock ) ;if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) {",1337
683,"prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ;}","enc_tables . counter_head ++ ;enc_tables . counter_tail ++ ;prefetch_table ( ( const void * ) & enc_tables , sizeof ( encT ) ) ;}",1338
684,"struct ssh * ssh = active_state ;struct monitor * mon ;if ( options . compression ) {mon -> m_zback = mm_create ( NULL , MM_MEMSIZE ) ;mon -> m_zlib = mm_create ( mon -> m_zback , 20 * MM_MEMSIZE ) ;ssh_packet_set_compress_hooks ( ssh , mon -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ;}",struct monitor * mon ;,1339
685,if ( l >= ( len - o ) ) {iter -> err_off = o ;,if ( l >= ( len - o - 4 ) ) {iter -> err_off = o ;,1340
686,"ap_log_cerror ( APLOG_MARK , APLOG_ERR , 0 , session -> c ,  APLOGNO ( 02920 ) ""h2_session:<S2SV_blank><S2SV_blank>stream(%ld-%d):<S2SV_blank>on_header<S2SV_blank>unknown<S2SV_blank>stream"" , session -> id , ( int ) frame -> hd . stream_id ) ;if ( status != APR_SUCCESS && ! h2_stream_is_ready ( stream ) ) {return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ;","ap_log_cerror ( APLOG_MARK , APLOG_DEBUG , 0 , session -> c , APLOGNO ( 02920 ) ""h2_session:<S2SV_blank><S2SV_blank>stream(%ld-%d):<S2SV_blank>on_header<S2SV_blank>unknown<S2SV_blank>stream"" , session -> id , ( int ) frame -> hd . stream_id ) ;if ( status == APR_ECONNRESET ) {ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , status , session -> c , ""h2-stream(%ld-%d):<S2SV_blank>on_header,<S2SV_blank>reset<S2SV_blank>stream"" , session -> id , stream -> id ) ;nghttp2_submit_rst_stream ( ngh2 , NGHTTP2_FLAG_NONE , stream -> id , NGHTTP2_INTERNAL_ERROR ) ;}else if ( status != APR_SUCCESS && ! h2_stream_is_ready ( stream ) ) {return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ;",1341
687,"static void  horDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 2 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 2 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%(2*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",1342
688,},return 1 ;},1342
689,"CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ||  ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) ||  bcount != caf_chunk_header . mChunkSize ) {","CAFChannelLayout * caf_channel_layout ;if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) {error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\\\'chan\\\'<S2SV_blank>chunk!"" ) ;return WAVPACK_SOFT_ERROR ;}if ( debug_logging_mode ) error_line ( ""\\\'chan\\\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ;caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {",1343
690,"config -> qmode |= QMODE_REORDERED_CHANS ;channel_layout = num_descriptions ;}if ( ! idents ) {free ( channel_identities ) ;channel_identities = NULL ;}else channel_identities [ idents ] = 0 ;if ( debug_logging_mode ) {error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS"" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ;if ( channel_reorder && num_descriptions <= 8 ) {char reorder_string [ ] = ""12345678"" ;for ( i = 0 ;i < num_descriptions ;++ i ) reorder_string [ i ] = channel_reorder [ i ] + \'1\' ;reorder_string [ i ] = 0 ;error_line ( ""reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\""\\\}}}break ;case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ;if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x"" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ;break ;default : for ( i = 0 ;i < NUM_LAYOUTS ;++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {config -> channel_mask = layouts [ i ] . mChannelBitmap ;channel_layout = layouts [ i ] . mChannelLayoutTag ;if ( layouts [ i ] . mChannelReorder ) {channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ;config -> qmode |= QMODE_REORDERED_CHANS ;}if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ;if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s"" , channel_layout , config -> channel_mask , channel_reorder ? ""yes"" : ""no"" , channel_identities ? ""yes"" : ""no"" ) ;break ;}if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned"" , caf_channel_layout -> mChannelLayoutTag ) ;break ;}free ( caf_channel_layout ) ;}else if ( ! strncmp ( caf_chunk_header . mChunkType , ""data"" , 4 ) ) {uint32_t mEditCount ;if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) {else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) {error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ;return WAVPACK_SOFT_ERROR ;}if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) {config -> qmode |= QMODE_IGNORE_LENGTH ;if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ;else total_samples = - 1 ;}else {if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) {error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) {error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ;if ( ! total_samples ) {error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ;return WAVPACK_SOFT_ERROR ;}if ( total_samples > MAX_WAVPACK_SAMPLES ) {error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}}break ;}else {int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;","+ i ) reorder_string [ i ] = channel_reorder [ i ] + \'1\' ;+ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;char * buff ;if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) {buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;",1343
691,"char linebuf [ L_BUF_SIZE ] ;l_int32 sy , sx , cy , cx , i , j , version , ignore ;if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL )  return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ;sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ;if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\\","char linebuf [ L_BUFSIZE ] ;l_int32 sy , sx , cy , cx , i , j , version , ignore ;if ( fgets ( linebuf , L_BUFSIZE , fp ) == NULL ) return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ;sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" , selname ) ;if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\\",1344
692,"char build [ ATUSB_BUILD_SIZE + 1 ] ;int ret ;ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_BUILD , ATUSB_REQ_FROM_DEV , 0 , 0 , build , ATUSB_BUILD_SIZE , 1000 ) ;return ret ;}","char * build ;int ret ;build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ;if ( ! build ) return - ENOMEM ;ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_BUILD , ATUSB_REQ_FROM_DEV , 0 , 0 , build , ATUSB_BUILD_SIZE , 1000 ) ;kfree ( build ) ;return ret ;}",1345
693,if ( isspace ( * s ) )  continue ;,if ( isspace ( ( unsigned char ) * s ) ) continue ;,1346
694,"uzbl . net . useragent = ""Test<S2SV_blank>useragent"" ;parse_cmd_line ( ""js<S2SV_blank>Uzbl.run(\\\'print<S2SV_blank>@useragent\\\').toUpperCase();"" , result ) ;g_assert_cmpstr ( ""TEST<S2SV_blank>USERAGENT"" , == , result -> str ) ;","
",1347
695,"zval * options = NULL , * classes = NULL ;HashTable * class_hash = NULL ;","zval * options = NULL , * classes = NULL ;zval * retval ;HashTable * class_hash = NULL ;",1348
696,"if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) {PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;zval_ptr_dtor ( return_value ) ;if ( ! EG ( exception ) ) {var_push_dtor ( & var_hash , return_value ) ;PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;","retval = var_tmp_var ( & var_hash ) ;if ( ! php_var_unserialize_ex ( retval , & p , p + buf_len , & var_hash , class_hash ) ) {PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;if ( ! EG ( exception ) ) {ZVAL_COPY ( return_value , retval ) ;PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;",1348
697,"int cond_len , then_len , jump_len ;Node * cond = NODE_BAG_BODY ( node ) ;","int cond_len , then_len , else_len , jump_len ;Node * cond = NODE_BAG_BODY ( node ) ;",1349
698,jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ;if ( IS_NOT_NULL ( Else ) ) jump_len += SIZE_OP_JUMP ;,jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP ;,1349
699,"r = compile_tree ( Then , reg , env ) ;if ( r != 0 ) return r ;if ( IS_NOT_NULL ( Else ) ) {int else_len = compile_length_tree ( Else , reg ) ;r = add_op ( reg , OP_JUMP ) ;COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ;r = compile_tree ( Else , reg , env ) ;}","else_len = compile_length_tree ( Else , reg ) ;if ( else_len < 0 ) return else_len ;else else_len = 0 ;r = add_op ( reg , OP_JUMP ) ;COP ( reg ) -> jump . addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP ;r = add_op ( reg , OP_ATOMIC_END ) ;if ( r != 0 ) return r ;if ( IS_NOT_NULL ( Else ) ) {r = compile_tree ( Else , reg , env ) ;}",1349
700,facilities -> source_ndigis = 1 ;}else if ( * p == FAC_NATIONAL_SRC_DIGI ) {if ( ! fac_national_digis_received ) {,else {if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ;},1350
701,"if ( pt [ 6 ] & AX25_HBIT )  memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;else   memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;}","if ( pt [ 6 ] & AX25_HBIT ) {if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ;memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;else memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;}",1350
702,"uint8_t * outbuf ;int rc ;command = buf [ 0 ] ;outbuf = ( uint8_t * ) r -> iov . iov_base ;DPRINTF ( ""Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x"" , req -> lun , req -> tag , buf [ 0 ] ) ;# ifdef DEBUG_SCSI {int i ;for ( i = 1 ;i < r -> req . cmd . len ;i ++ ) {printf ( ""<S2SV_blank>0x%02x"" , buf [ i ] ) ;}printf ( ""\\\}# endif switch ( command ) {case TEST_UNIT_READY : case INQUIRY : case MODE_SENSE : case MODE_SENSE_10 : case RESERVE : case RESERVE_10 : case RELEASE : case RELEASE_10 : case START_STOP : case ALLOW_MEDIUM_REMOVAL : case READ_CAPACITY_10 : case READ_TOC : case GET_CONFIGURATION : case SERVICE_ACTION_IN_16 : case VERIFY_10 :  rc = scsi_disk_emulate_command ( r , outbuf ) ;if ( rc < 0 ) {return 0 ;}r -> iov . iov_len = rc ;break ;case SYNCHRONIZE_CACHE : bdrv_acct_start ( s -> bs , & r -> acct , 0 , BDRV_ACCT_FLUSH ) ;r -> req . aiocb = bdrv_aio_flush ( s -> bs , scsi_flush_complete , r ) ;if ( r -> req . aiocb == NULL ) {scsi_flush_complete ( r , - EIO ) ;}return 0 ;case READ_6 : case READ_10 : case READ_12 : case READ_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ;","int rc ;command = buf [ 0 ] ;outbuf = ( uint8_t * ) r -> iov . iov_base ;DPRINTF ( ""Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x"" , req -> lun , req -> tag , buf [ 0 ] ;",1351
703,"
","assert ( ( ae = archive_entry_new ( ) ) != NULL ) ;archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;assert ( 0 == archive_write_header ( a , ae ) ) ;assert ( 0 == archive_write_finish_entry ( a ) ) ;assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ;assert ( archive_entry_clear ( ae ) != NULL ) ;archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ;failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ;assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ;archive_entry_free ( ae ) ;assert ( 0 == archive_write_finish_entry ( a ) ) ;assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;",1352
704,"assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ;assert ( 0 == lstat ( ""dir"" , & st ) ) ;","assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ;assert ( 0 == lstat ( ""dir"" , & st ) ) ;",1352
705,"void isoclns_print ( netdissect_options * ndo ,  const uint8_t * p , u_int length , u_int caplen )  {if ( caplen <= 1 ) {ND_PRINT ( ( ndo , ""|OSI"" ) ) ;case NLPID_CLNP : if ( ! clnp_print ( ndo , p , length ) )  print_unknown_data ( ndo , p , ""\\\break ;case NLPID_ISIS : if ( ! isis_print ( ndo , p , length ) )  print_unknown_data ( ndo , p , ""\\\break ;","void isoclns_print ( netdissect_options * ndo , const uint8_t * p , u_int length ) {if ( caplen <= 1 ) {ND_PRINT ( ( ndo , ""|OSI"" ) ) ;case NLPID_CLNP : if ( ! clnp_print ( ndo , p , length ) ) print_unknown_data ( ndo , p , ""\\\break ;case NLPID_ISIS : if ( ! isis_print ( ndo , p , length ) ) print_unknown_data ( ndo , p , ""\\\break ;",1353
706,"if ( caplen > 1 )   print_unknown_data ( ndo , p , ""\\\break ;","if ( length > 1 ) print_unknown_data ( ndo , p , ""\\\break ;",1353
707,register struct enamemem * tp ;char buf [ BUFSIZE ] ;if ( tp -> e_name )   return ( tp -> e_name ) ;cp = buf ;,register struct bsnamemem * tp ;char buf [ BUFSIZE ] ;if ( tp -> bs_name ) return ( tp -> e_name ) ;cp = buf ;,1354
708,"tp -> e_name = strdup ( buf ) ;if ( tp -> e_name == NULL )  ( * ndo -> ndo_error ) ( ndo , ""le64addr_string:<S2SV_blank>strdup(buf)"" ) ;return ( tp -> e_name ) ;}","tp -> bs_name = strdup ( buf ) ;if ( tp -> bs_name == NULL ) ( * ndo -> ndo_error ) ( ndo , ""le64addr_string:<S2SV_blank>strdup(buf)"" ) ;return ( tp -> bs_name ) ;}",1354
709,if ( ctx -> mb_height > 68 && ff_dnxhd_check_header_prefix_hr ( header_prefix ) ) {ctx -> data_offset = 0x170 + ( ctx -> mb_height << 2 ) ;}else {if ( ctx -> mb_height > 68 ||  ( ctx -> mb_height << frame -> interlaced_frame ) > ( ctx -> height + 15 ) >> 4 ) {ctx -> data_offset = 0x280 ;},if ( ctx -> mb_height > 68 ) {,1355
710,"static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len )  {struct ipv6_txoptions opt_space ;","static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) {struct ipv6_txoptions * opt_to_free = NULL ;struct ipv6_txoptions opt_space ;",1356
711,"if ( ! opt )  opt = np -> opt ;if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ;","if ( ! opt ) {opt = txopt_get ( np ) ;opt_to_free = opt ;}if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ;",1356
712,return err < 0 ? err : len ;do_confirm : dst_confirm ( dst ) ;,txopt_put ( opt_to_free ) ;return err < 0 ? err : len ;do_confirm : dst_confirm ( dst ) ;,1356
713,mutex_lock ( & vdev -> vdev_mutex ) ;mutex_lock ( & vi -> vop_mutex ) ;,"if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) {ret = - EINVAL ;goto free_ret ;}mutex_lock ( & vdev -> vdev_mutex ) ;mutex_lock ( & vi -> vop_mutex ) ;",1357
714,if ( count < sizeof ( cmd ) ) {ret = - EINVAL ;,if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ;if ( count < sizeof ( cmd ) ) {ret = - EINVAL ;,1358
715,filename [ filename_size ++ ] = \'\\\\0\' ;if ( rar -> sconv_utf16be == NULL ) {,filename [ filename_size ++ ] = \'\\\\0\' ;if ( rar -> sconv_utf16be == NULL ) {,1359
716,"umode_t mode = inode -> i_mode ;rc = posix_acl_equiv_mode ( acl , & mode ) ;if ( rc < 0 ) return rc ;","umode_t mode ;rc = posix_acl_update_mode ( inode , & mode ) ;if ( rc < 0 ) return rc ;",1360
717,if ( rc == 0 )  acl = NULL ;,"
",1360
718,spin_lock_init ( & port -> phy_list_lock ) ;INIT_LIST_HEAD ( & port -> phy_list ) ;,INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;spin_lock_init ( & port -> phy_list_lock ) ;INIT_LIST_HEAD ( & port -> phy_list ) ;,1361
719,hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ;hmp_chunk [ i ] += chunk_ofs [ i ] ++ ;,hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ;chunk_length [ i ] -= chunk_ofs [ i ] ;hmp_chunk [ i ] += chunk_ofs [ i ] ++ ;,1362
720,"}uint32_t setup_ret = 0 ;if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , 0 ) ) == 0 ) {goto _hmp_end ;chunk_end [ i ] = 1 ;hmp_chunk [ i ] += 3 ;","chunk_length [ i ] -= 3 ;}uint32_t setup_ret = 0 ;if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , chunk_length [ i ] , 0 ) ) == 0 ) {goto _hmp_end ;chunk_end [ i ] = 1 ;chunk_length [ i ] -= 3 ;hmp_chunk [ i ] += 3 ;",1362
721,}var_len_shift = 0 ;if ( * hmp_chunk [ i ] < 0x80 ) {do {chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;var_len_shift += 7 ;}}chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;hmp_chunk [ i ] ++ ;},"chunk_length [ i ] -= setup_ret ;}var_len_shift = 0 ;if ( chunk_length [ i ] && * hmp_chunk [ i ] < 0x80 ) {do {if ( ! chunk_length [ i ] ) break ;chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;var_len_shift += 7 ;chunk_length [ i ] -- ;}}if ( ! chunk_length [ i ] ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmp_end ;}chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;hmp_chunk [ i ] ++ ;chunk_length [ i ] -- ;}",1362
722,"mem_free ( gr . gr_ctx . value ,  sizeof ( gss_union_ctx_id_desc ) ) ;gss_release_buffer ( & min_stat , & gd -> checksum ) ;mem_free ( gr . gr_ctx . value , sizeof ( gss_union_ctx_id_desc ) ) ;","gss_release_buffer ( & min_stat , & gd -> checksum ) ;",1363
723,"if ( ( creds -> pid == task_tgid_vnr ( current ) ||  ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) &&  ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {","if ( ( creds -> pid == task_tgid_vnr ( current ) || ns_capable ( task_active_pid_ns ( current ) -> user_ns , CAP_SYS_ADMIN ) ) && ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {",1364
724,mntput ( ns -> proc_mnt ) ;},kern_unmount ( ns -> proc_mnt ) ;},1365
725,"if ( ndo -> ndo_vflag )  ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ;p += 8 ;","if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;",1366
726,"return ! inode_capable ( inode , CAP_FOWNER ) ;}","return ! capable_wrt_inode_uidgid ( inode , CAP_FOWNER ) ;}",1367
727,"struct LayerData * cx_layer_list = NULL ;struct LayerData * layer_data ;struct Superframe superframe ;SvcInternal * const si = get_svc_internal ( svc_ctx ) ;memset ( & superframe , 0 , sizeof ( superframe ) ) ;svc_log_reset ( svc_ctx ) ;si -> rc_stats_buf_used = 0 ;si -> layers = svc_ctx -> spatial_layers ;if ( si -> frame_within_gop >= si -> kf_dist || si -> encode_frame_count == 0 ) {si -> frame_within_gop = 0 ;}si -> is_keyframe = ( si -> frame_within_gop == 0 ) ;si -> frame_size = 0 ;if ( rawimg != NULL ) {svc_log ( svc_ctx , SVC_LOG_DEBUG , ""vpx_svc_encode<S2SV_blank><S2SV_blank>layers:<S2SV_blank>%d,<S2SV_blank>frame_count:<S2SV_blank>%d,<S2SV_blank>"" ""frame_within_gop:<S2SV_blank>%d\\\}for ( si -> layer = 0 ;si -> layer < si -> layers ;++ si -> layer ) {if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && si -> is_keyframe && ( si -> layer == 1 || si -> layer == 3 ) ) {svc_log ( svc_ctx , SVC_LOG_DEBUG , ""Skip<S2SV_blank>encoding<S2SV_blank>layer<S2SV_blank>%d\\\continue ;}if ( rawimg != NULL ) {calculate_enc_frame_flags ( svc_ctx ) ;set_svc_parameters ( svc_ctx , codec_ctx ) ;}res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration , si -> enc_frame_flags , deadline ) ;case VPX_CODEC_CX_FRAME_PKT : {const uint32_t frame_pkt_size = ( uint32_t ) ( cx_pkt -> data . frame . sz ) ;si -> bytes_sum [ si -> layer ] += frame_pkt_size ;svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>size:<S2SV_blank>%u\\\ld_list_add ( & cx_layer_list , layer_data ) ;superframe . sizes [ superframe . count ++ ] = frame_pkt_size ;superframe . magnitude |= frame_pkt_size ;break ;}case VPX_CODEC_PSNR_PKT : {int i ;svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>PSNR(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\\svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>SSE(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\\for ( i = 0 ;i < COMPONENTS ;i ++ ) {si -> psnr_sum [ si -> layer ] [ i ] += cx_pkt -> data . psnr . psnr [ i ] ;si -> sse_sum [ si -> layer ] [ i ] += cx_pkt -> data . psnr . sse [ i ] ;}break ;}case VPX_CODEC_STATS_PKT : {size_t new_size = si -> rc_stats_buf_used + cx_pkt -> data . twopass_stats . sz ;if ( new_size > si -> rc_stats_buf_size ) {char * p = ( char * ) realloc ( si -> rc_stats_buf , new_size ) ;if ( p == NULL ) {svc_log ( svc_ctx , SVC_LOG_ERROR , ""Error<S2SV_blank>allocating<S2SV_blank>stats<S2SV_blank>buf\\\break ;}si -> rc_stats_buf = p ;si -> rc_stats_buf_size = new_size ;}memcpy ( si -> rc_stats_buf + si -> rc_stats_buf_used , cx_pkt -> data . twopass_stats . buf , cx_pkt -> data . twopass_stats . sz ) ;si -> rc_stats_buf_used += cx_pkt -> data . twopass_stats . sz ;break ;}default : {break ;}}}if ( rawimg == NULL ) {break ;}}if ( codec_ctx -> config . enc -> g_pass != VPX_RC_FIRST_PASS ) {sf_create_index ( & superframe ) ;layer_data = ld_create ( superframe . buffer , superframe . index_size ) ;ld_list_add ( & cx_layer_list , layer_data ) ;si -> frame_size = ld_list_get_buffer_size ( cx_layer_list ) ;if ( si -> frame_size > 0 ) {if ( si -> frame_size > si -> buffer_size ) {free ( si -> buffer ) ;si -> buffer = malloc ( si -> frame_size ) ;if ( si -> buffer == NULL ) {ld_list_free ( cx_layer_list ) ;return VPX_CODEC_MEM_ERROR ;}si -> buffer_size = si -> frame_size ;}ld_list_copy_to_buffer ( cx_layer_list , ( uint8_t * ) si -> buffer ) ;ld_list_free ( cx_layer_list ) ;svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>kf:<S2SV_blank>%d,<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>"" ""pts:<S2SV_blank>%d\\\}}++ si -> frame_within_gop ;++ si -> encode_frame_count ;return VPX_CODEC_OK ;}","SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ;+ si -> layer ) {svc_log_reset ( svc_ctx ) ;res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration , 0 , deadline ) ;case VPX_CODEC_CX_FRAME_PKT : {const uint32_t frame_pkt_size = ( uint32_t ) ( cx_pkt -> data . frame . sz ) ;si -> bytes_sum [ si -> layer ] += frame_pkt_size ;svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>size:<S2SV_blank>%u\\\+ si -> frame_within_gop ;+ si -> encode_frame_count ;",1368
728,void * parg = NULL ;long err = - EINVAL ;int is_ext_ctrl ;size_t ctrls_size = 0 ;void __user * user_ptr = NULL ;is_ext_ctrl = ( cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS || cmd == VIDIOC_TRY_EXT_CTRLS ) ;switch ( _IOC_DIR ( cmd ) ) {case _IOC_NONE :  parg = NULL ;case _IOC_READ :  case _IOC_WRITE :  case ( _IOC_WRITE | _IOC_READ ) :  if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;,"void * parg = ( void * ) arg ;long err = - EINVAL ;if ( has_array_args ) {* kernel_ptr = user_ptr ;if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ;goto out_array_args ;}if ( err < 0 ) goto out ;out_array_args : switch ( _IOC_DIR ( cmd ) ) {case _IOC_NONE : parg = NULL ;case _IOC_READ : case _IOC_WRITE : case ( _IOC_WRITE | _IOC_READ ) : if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;",1369
729,"# ifdef HAVE_INT64_TIMESTAMP  char fstr [ MAXDATELEN + 1 ] ;strcpy ( fstr , ( cp + 1 ) ) ;strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ;* ( fstr + 6 ) = \'\\\\0\' ;",# ifdef HAVE_INT64_TIMESTAMP char fstr [ 7 ] ;int i ;cp ++ ;for ( i = 0 ;i < 6 ;i ++ ) fstr [ i ] = * cp != \'\\\\0\' ? * cp ++ : \'0\' ;fstr [ i ] = \'\\\\0\' ;,1370
730,"pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn +  pi -> picomp -> numrlvls - 1 ) ) ;pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn +  pi -> picomp -> numrlvls - 1 ) ) ;pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;","pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ;pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;",1371
731,"static void  sraSpanInsertAfter ( sraSpan * newspan , sraSpan * after ) {newspan -> _next = after -> _next ;}","static void sraSpanInsertAfter ( sraSpan * newspan , sraSpan * after ) {if ( newspan && after ) {newspan -> _next = after -> _next ;}}",1372
732,while ( c && which > 0 ) {c = c -> next ;-- which ;,while ( c && which > 0 ) c = c -> next ;-- which ;,1373
733,if ( noblock )  return - EAGAIN ;,cond_resched ( ) ;,1374
734,"
","if ( len < j + msg -> len + 1 ) {LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\\return - 1 ;}",1375
735,"memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;LM_DBG ( ""msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\\","memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;LM_DBG ( ""msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\\",1375
736,"if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ;","if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ;break ;case ETHERTYPE_TEB : ether_print ( ndo , bp , len ) ) goto trunc ;",1376
737,"case ETHERTYPE_GRE_ISO :  isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ;break ;case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;","case ETHERTYPE_GRE_ISO : isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;",1376
738,skcipher -> setkey = alg -> setkey ;skcipher -> encrypt = alg -> encrypt ;,skcipher -> setkey = skcipher_setkey ;skcipher -> encrypt = alg -> encrypt ;,1377
739,c . c_arena = arena ;c . c_filename = filename ;c . c_normalize = NULL ;c . c_normalize_args = NULL ;c . c_feature_version = feature_version ;,c . c_feature_version = feature_version ;,1378
740,"PyTuple_SET_ITEM ( c . c_normalize_args , 1 , NULL ) ;Py_DECREF ( c . c_normalize_args ) ;","
",1378
741,"void vp9_encode_block_intra ( MACROBLOCK * x , int plane , int block ,  BLOCK_SIZE plane_bsize , TX_SIZE tx_size ,  unsigned char * skip ) {struct encode_b_args arg = {x , NULL , skip };encode_block_intra ( plane , block , plane_bsize , tx_size , & arg ) ;","void vp9_encode_block_intra ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {struct encode_b_args * const args = arg ;MACROBLOCK * const x = args -> x ;MACROBLOCKD * const xd = & x -> e_mbd ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;struct macroblock_plane * const p = & x -> plane [ plane ] ;struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;tran_low_t * coeff = BLOCK_OFFSET ( p -> coeff , block ) ;tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;tran_low_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;const scan_order * scan_order ;TX_TYPE tx_type = DCT_DCT ;PREDICTION_MODE mode ;const int bwl = b_width_log2_lookup [ plane_bsize ] ;const int diff_stride = 4 * ( 1 << bwl ) ;uint8_t * src , * dst ;int16_t * src_diff ;uint16_t * eob = & p -> eobs [ block ] ;const int src_stride = p -> src . stride ;const int dst_stride = pd -> dst . stride ;int i , j ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ;dst = & pd -> dst . buf [ 4 * ( j * dst_stride + i ) ] ;src = & p -> src . buf [ 4 * ( j * src_stride + i ) ] ;src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ;if ( tx_size == TX_4X4 ) {tx_type = get_tx_type_4x4 ( pd -> plane_type , xd , block ) ;scan_order = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ;mode = plane == 0 ? get_y_mode ( xd -> mi [ 0 ] , block ) : mbmi -> uv_mode ;}else {mode = plane == 0 ? mbmi -> mode : mbmi -> uv_mode ;if ( tx_size == TX_32X32 ) {scan_order = & vp9_default_scan_orders [ TX_32X32 ] ;}else {tx_type = get_tx_type ( pd -> plane_type , xd ) ;scan_order = & vp9_scan_orders [ tx_size ] [ tx_type ] ;}}vp9_predict_intra_block ( xd , bwl , tx_size , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , i , j , plane ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {switch ( tx_size ) {case TX_32X32 : if ( ! x -> skip_recode ) {vpx_highbd_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ;highbd_fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;vpx_highbd_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) {vp9_highbd_idct32x32_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ;}break ;case TX_16X16 : if ( ! x -> skip_recode ) {vpx_highbd_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ;if ( tx_type == DCT_DCT ) vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ;else vp9_highbd_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ;vpx_highbd_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) {vp9_highbd_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ;}break ;case TX_8X8 : if ( ! x -> skip_recode ) {vpx_highbd_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ;if ( tx_type == DCT_DCT ) vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ;else vp9_highbd_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ;vpx_highbd_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) {vp9_highbd_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ;}break ;case TX_4X4 : if ( ! x -> skip_recode ) {vpx_highbd_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ;if ( tx_type != DCT_DCT ) vp9_highbd_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ;else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ;vpx_highbd_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) {if ( tx_type == DCT_DCT ) {x -> highbd_itxm_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ;}else {vp9_highbd_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type , xd -> bd ) ;}}break ;default : assert ( 0 ) ;return ;}if ( * eob ) * ( args -> skip ) = 0 ;return ;}# endif switch ( tx_size ) {case TX_32X32 : if ( ! x -> skip_recode ) {vpx_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ;fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) vp9_idct32x32_add ( dqcoeff , dst , dst_stride , * eob ) ;break ;case TX_16X16 : if ( ! x -> skip_recode ) {vpx_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ;vp9_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ;vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) vp9_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ;break ;case TX_8X8 : if ( ! x -> skip_recode ) {vpx_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ;vp9_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ;vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) vp9_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ;break ;case TX_4X4 : if ( ! x -> skip_recode ) {vpx_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ;if ( tx_type != DCT_DCT ) vp9_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ;else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ;vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) {if ( tx_type == DCT_DCT ) x -> itxm_add ( dqcoeff , dst , dst_stride , * eob ) ;else vp9_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type ) ;}break ;default : assert ( 0 ) ;break ;}if ( * eob ) * ( args -> skip ) = 0 ;",1379
742,UnpackRaster :  if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {,"UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) break ;if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {",1380
743,"else {if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ;}if ( bpp == 1 ) {if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) {image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ;}}if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) {DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ;}if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) {if ( BitmapHeader2 . RotAngle & 0x8000 ) {Image * flop_image ;flop_image = FlopImage ( image , exception ) ;if ( flop_image != ( Image * ) NULL ) {DuplicateBlob ( flop_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flop_image ) ;}}if ( BitmapHeader2 . RotAngle & 0x2000 ) {Image * flip_image ;flip_image = FlipImage ( image , exception ) ;if ( flip_image != ( Image * ) NULL ) {DuplicateBlob ( flip_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flip_image ) ;}}if ( BitmapHeader2 . RotAngle & 0x0FFF ) {Image * rotate_image ;rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ;if ( rotate_image != ( Image * ) NULL ) {DuplicateBlob ( rotate_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , rotate_image ) ;}}}AcquireNextImage ( image_info , image , exception ) ;image -> depth = 8 ;if ( image -> next == ( Image * ) NULL ) goto Finish ;image = SyncNextImageInList ( image ) ;image -> columns = image -> rows = 1 ;image -> colors = 0 ;break ;case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ;break ;}}break ;case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ;StartWPG . PosSizePrecision = 0 ;while ( ! EOFBlob ( image ) ) {( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ;if ( EOFBlob ( image ) ) break ;Rec2 . Class = ( i = ReadBlobByte ( image ) ) ;if ( i == EOF ) break ;Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ;if ( i == EOF ) break ;Rd_WP_DWORD ( image , & Rec2 . Extension ) ;Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ;if ( EOFBlob ( image ) ) break ;Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ;switch ( Rec2 . RecType ) {case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ;StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ;StartWPG . PosSizePrecision = ReadBlobByte ( image ) ;break ;case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ;WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ;image -> colors = WPG_Palette . NumOfEntries ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = WPG_Palette . StartIndex ;i < ( int ) WPG_Palette . NumOfEntries ;i ++ ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;( void ) ReadBlobByte ( image ) ;}break ;case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ;Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ;if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;Bitmap2Header1 . Depth = ReadBlobByte ( image ) ;Bitmap2Header1 . Compression = ReadBlobByte ( image ) ;if ( Bitmap2Header1 . Compression > 1 ) continue ;switch ( Bitmap2Header1 . Depth ) {case 1 : bpp = 1 ;break ;case 2 : bpp = 2 ;break ;case 3 : bpp = 4 ;break ;case 4 : bpp = 8 ;break ;case 8 : bpp = 24 ;break ;default : continue ;}image -> columns = Bitmap2Header1 . Width ;image -> rows = Bitmap2Header1 . Height ;if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {size_t one ;one = 1 ;image -> colors = one << bpp ;if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ;}else {if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ;}switch ( Bitmap2Header1 . Compression ) {case 0 : {ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ;BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;for ( i = 0 ;i < ( ssize_t ) image -> rows ;i ++ ) {( void ) ReadBlob ( image , ldblk , BImgBuff ) ;InsertRow ( image , BImgBuff , i , bpp , exception ) ;}if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ;break ;}case 1 : {if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ;break ;}}if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) {Image * flop_image ;flop_image = FlopImage ( image , exception ) ;if ( flop_image != ( Image * ) NULL ) {DuplicateBlob ( flop_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flop_image ) ;}}if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) {Image * flip_image ;flip_image = FlipImage ( image , exception ) ;if ( flip_image != ( Image * ) NULL ) {DuplicateBlob ( flip_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flip_image ) ;}}AcquireNextImage ( image_info , image , exception ) ;image -> depth = 8 ;if ( image -> next == ( Image * ) NULL ) goto Finish ;image = SyncNextImageInList ( image ) ;image -> columns = image -> rows = 1 ;image -> colors = 0 ;break ;case 0x12 : i = ReadBlobLSBShort ( image ) ;if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ;break ;case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ;( void ) WPG2Flags ;break ;}}break ;default : {ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ;}}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;","
",1380
744,"
","if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;",1381
745,"if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;","if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;",1381
746,"if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;","if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;",1381
747,"int ret = - 1 ;s = ECDSA_SIG_new ( ) ;if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ;ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ;err :  ECDSA_SIG_free ( s ) ;return ( ret ) ;","const unsigned char * p = sigbuf ;unsigned char * der = NULL ;int derlen = - 1 ;int ret = - 1 ;s = ECDSA_SIG_new ( ) ;if ( d2i_ECDSA_SIG ( & s , & p , sig_len ) == NULL ) goto err ;derlen = i2d_ECDSA_SIG ( s , & der ) ;if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) goto err ;ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ;err : if ( derlen > 0 ) {OPENSSL_cleanse ( der , derlen ) ;OPENSSL_free ( der ) ;}ECDSA_SIG_free ( s ) ;return ( ret ) ;",1382
748,"switch ( af ) {case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ;","size_t pathlen = 0 ;switch ( af ) {case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ;",1383
749,"case AF_UNIX :  strncpy ( addr_text ,   ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ,  sizeof ( addr_text ) - 1 ) ;addr_text [ sizeof ( addr_text ) - 1 ] = \'\\\\0\' ;","case AF_UNIX : pathlen = sizeof ( ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ) ;if ( MAXPATHLEN <= pathlen ) {pathlen = MAXPATHLEN - 1 ;}strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ;addr_text [ pathlen ] = \'\\\\0\' ;",1383
750,"struct tpacket_req * req = & req_u -> req ;if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) {rb = tx_ring ? & po -> tx_ring : & po -> rx_ring ;rb_queue = tx_ring ? & sk -> sk_write_queue : & sk -> sk_receive_queue ;err = - EBUSY ;if ( ! closing ) {if ( atomic_read ( & po -> mapped ) ) goto out ;if ( packet_read_pending ( rb ) ) goto out ;}if ( req -> tp_block_nr ) {err = - EBUSY ;if ( unlikely ( rb -> pg_vec ) ) goto out ;switch ( po -> tp_version ) {case TPACKET_V1 : po -> tp_hdrlen = TPACKET_HDRLEN ;break ;case TPACKET_V2 : po -> tp_hdrlen = TPACKET2_HDRLEN ;break ;case TPACKET_V3 : po -> tp_hdrlen = TPACKET3_HDRLEN ;break ;}err = - EINVAL ;if ( unlikely ( ( int ) req -> tp_block_size <= 0 ) ) goto out ;if ( unlikely ( ! PAGE_ALIGNED ( req -> tp_block_size ) ) ) goto out ;if ( po -> tp_version >= TPACKET_V3 && ( int ) ( req -> tp_block_size - BLK_PLUS_PRIV ( req_u -> req3 . tp_sizeof_priv ) ) <= 0 ) goto out ;if ( unlikely ( req -> tp_frame_size < po -> tp_hdrlen + po -> tp_reserve ) ) goto out ;if ( unlikely ( req -> tp_frame_size & ( TPACKET_ALIGNMENT - 1 ) ) ) goto out ;rb -> frames_per_block = req -> tp_block_size / req -> tp_frame_size ;if ( unlikely ( rb -> frames_per_block == 0 ) ) goto out ;if ( unlikely ( ( rb -> frames_per_block * req -> tp_block_nr ) != req -> tp_frame_nr ) ) goto out ;err = - ENOMEM ;order = get_order ( req -> tp_block_size ) ;pg_vec = alloc_pg_vec ( req , order ) ;if ( unlikely ( ! pg_vec ) ) goto out ;switch ( po -> tp_version ) {case TPACKET_V3 : if ( ! tx_ring ) init_prb_bdqc ( po , rb , pg_vec , req_u ) ;break ;default : break ;}}else {err = - EINVAL ;if ( unlikely ( req -> tp_frame_nr ) ) goto out ;}lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;spin_unlock ( & po -> bind_lock ) ;","struct tpacket_req * req = & req_u -> req ;lock_sock ( sk ) ;if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) {spin_lock ( & po -> bind_lock ) ;if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ;out : spin_unlock ( & po -> bind_lock ) ;",1384
751,"release_sock ( sk ) ;if ( pg_vec )  free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ;","release_sock ( sk ) ;if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ;",1384
752,"if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 &&  ! no_port_forwarding_flag && ! options . disable_forwarding ) {c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ;","if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 && ! no_port_forwarding_flag && ! options . disable_forwarding && use_privsep ) {c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ;",1385
753,"RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ;RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ;RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ;RANGE_CHECK ( cfg , ss_number_layers , 1 , VPX_SS_MAX_LAYERS ) ;RANGE_CHECK ( cfg , ts_number_layers , 1 , VPX_TS_MAX_LAYERS ) ;if ( cfg -> ts_number_layers > 1 ) {unsigned int i ;for ( i = 1 ;++ i )  if ( cfg -> ts_target_bitrate [ i ] < cfg -> ts_target_bitrate [ i - 1 ] )  ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ;RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ;for ( i = cfg -> ts_number_layers - 2 ;i > 0 ;-- i )   if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] )   ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ;}if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ;RANGE_CHECK_BOOL ( extra_cfg , enable_auto_alt_ref ) ;RANGE_CHECK ( extra_cfg , cpu_used , - 16 , 16 ) ;RANGE_CHECK_HI ( extra_cfg , noise_sensitivity , 6 ) ;RANGE_CHECK ( extra_cfg , tile_columns , 0 , 6 ) ;RANGE_CHECK ( extra_cfg , tile_rows , 0 , 2 ) ;RANGE_CHECK_HI ( extra_cfg , sharpness , 7 ) ;RANGE_CHECK ( extra_cfg , arnr_max_frames , 0 , 15 ) ;RANGE_CHECK_HI ( extra_cfg , arnr_strength , 6 ) ;RANGE_CHECK ( extra_cfg , arnr_type , 1 , 3 ) ;RANGE_CHECK ( extra_cfg , cq_level , 0 , 63 ) ;if ( extra_cfg -> tuning == VP8_TUNE_SSIM ) ERROR ( ""Option<S2SV_blank>--tune=ssim<S2SV_blank>is<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>VP9."" ) ;size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ;int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ;const FIRSTPASS_STATS * stats ;if ( cfg -> ss_number_layers > 1 ) {int i ;","RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 100 ) ;RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 100 ) ;RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ;RANGE_CHECK ( extra_cfg , min_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ;RANGE_CHECK ( extra_cfg , max_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ;if ( extra_cfg -> max_gf_interval > 0 ) {RANGE_CHECK ( extra_cfg , max_gf_interval , 2 , ( MAX_LAG_BUFFERS - 1 ) ) ;}if ( extra_cfg -> min_gf_interval > 0 && extra_cfg -> max_gf_interval > 0 ) {RANGE_CHECK ( extra_cfg , max_gf_interval , extra_cfg -> min_gf_interval , ( MAX_LAG_BUFFERS - 1 ) ) ;}if ( cfg -> ss_number_layers * cfg -> ts_number_layers > VPX_MAX_LAYERS ) ERROR ( ""ss_number_layers<S2SV_blank>*<S2SV_blank>ts_number_layers<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ;if ( cfg -> ts_number_layers > 1 ) {RANGE_CHECK ( cfg , rc_scaled_width , 0 , cfg -> g_w ) ;RANGE_CHECK ( cfg , rc_scaled_height , 0 , cfg -> g_h ) ;}RANGE_CHECK ( cfg , ss_number_layers , 1 , VPX_SS_MAX_LAYERS ) ;RANGE_CHECK ( cfg , ts_number_layers , 1 , VPX_TS_MAX_LAYERS ) ;if ( cfg -> ts_number_layers > 1 ) {unsigned int sl , tl ;for ( i = 1 ;+ i )  if ( cfg -> ts_target_bitrate [ i ] < cfg -> ts_target_bitrate [ i - 1 ] )  ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ;++ tl ) {const int layer = LAYER_IDS_TO_IDX ( sl , tl , cfg -> ts_number_layers ) ;if ( cfg -> layer_target_bitrate [ layer ] < cfg -> layer_target_bitrate [ layer - 1 ] ) ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ;}}RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ;for ( tl = cfg -> ts_number_layers - 2 ;tl > 0 ;-- i ) if ( cfg -> ts_rate_decimator [ tl - 1 ] != 2 * cfg -> ts_rate_decimator [ tl ] ) ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ;}# if CONFIG_SPATIAL_SVC if ( ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) && cfg -> g_pass == VPX_RC_LAST_PASS ) {unsigned int i , alt_ref_sum = 0 ;for ( i = 0 ;i < cfg -> ss_number_layers ;++ i ) {if ( cfg -> ss_enable_auto_alt_ref [ i ] ) ++ alt_ref_sum ;}if ( alt_ref_sum > REF_FRAMES - cfg -> ss_number_layers ) ERROR ( ""Not<S2SV_blank>enough<S2SV_blank>ref<S2SV_blank>buffers<S2SV_blank>for<S2SV_blank>svc<S2SV_blank>alt<S2SV_blank>ref<S2SV_blank>frames"" ) ;if ( cfg -> ss_number_layers * cfg -> ts_number_layers > 3 && cfg -> g_error_resilient == 0 ) ERROR ( ""Multiple<S2SV_blank>frame<S2SV_blank>context<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>more<S2SV_blank>than<S2SV_blank>3<S2SV_blank>layers"" ) ;}# endif if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ;RANGE_CHECK ( extra_cfg , enable_auto_alt_ref , 0 , 2 ) ;RANGE_CHECK ( extra_cfg , cpu_used , - 8 , 8 ) ;RANGE_CHECK_HI ( extra_cfg , cq_level , 0 , 63 ) ;RANGE_CHECK ( cfg , g_bit_depth , VPX_BITS_8 , VPX_BITS_12 ) ;RANGE_CHECK ( cfg , g_input_bit_depth , 8 , 12 ) ;RANGE_CHECK ( extra_cfg , content , VP9E_CONTENT_DEFAULT , VP9E_CONTENT_INVALID - 1 ) ;if ( extra_cfg -> tuning == VP8_TUNE_SSIM ) ERROR ( ""Option<S2SV_blank>--tune=ssim<S2SV_blank>is<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>VP9."" ) ;const size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ;const int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ;const FIRSTPASS_STATS * stats ;if ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) {int i ;",1386
754,"if ( layer_id >= cfg -> ss_number_layers  || ( int ) ( stats -> count + 0.5 ) != n_packets_per_layer [ layer_id ] - 1 )  ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ;else {if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 &&   extra_cfg -> bit_depth > BITS_8 )  ERROR ( ""High<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ;if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 &&   extra_cfg -> bit_depth == BITS_8 )  ERROR ( ""Bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1"" ) ;","if ( layer_id >= cfg -> ss_number_layers || ( unsigned int ) ( stats -> count + 0.5 ) != n_packets_per_layer [ layer_id ] - 1 ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ;}# if ! CONFIG_VP9_HIGHBITDEPTH if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 ) {ERROR ( ""Profile<S2SV_blank>><S2SV_blank>1<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build<S2SV_blank>configuration"" ) ;# endif else {if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && cfg -> g_bit_depth > VPX_BITS_8 ) {ERROR ( ""Codec<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ;}if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && cfg -> g_input_bit_depth > 8 ) {ERROR ( ""Source<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ;}if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && cfg -> g_bit_depth == VPX_BITS_8 ) {ERROR ( ""Codec<S2SV_blank>bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1"" ) ;}RANGE_CHECK ( extra_cfg , color_space , VPX_CS_UNKNOWN , VPX_CS_SRGB ) ;",1386
755,"static vpx_codec_err_t vp8_get_last_ref_frame ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {","static vpx_codec_err_t vp8_get_last_ref_frame ( vpx_codec_alg_priv_t * ctx , va_list args ) {",1387
756,char added ;},},1388
757,"
",if ( ! cd -> disk ) continue ;,1389
758,blk_cleanup_queue ( cd -> disk -> queue ) ;cd -> disk -> queue = NULL ;,blk_cleanup_queue ( cd -> disk -> queue ) ;cd -> disk -> queue = NULL ;,1389
759,"
",if ( lha -> compsize < 0 ) goto invalid ;,1390
760,"if ( sum_calculated != headersum ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ;","if ( sum_calculated != headersum ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ;",1390
761,"int fd = accept ( s , ( struct sockaddr * ) & client_address , & clen ) ;APPL_TRACE_DEBUG ( ""accepted<S2SV_blank>fd:%d<S2SV_blank>for<S2SV_blank>server<S2SV_blank>fd:%d"" , fd , s ) ;","int fd = TEMP_FAILURE_RETRY ( accept ( s , ( struct sockaddr * ) & client_address , & clen ) ) ;APPL_TRACE_DEBUG ( ""accepted<S2SV_blank>fd:%d<S2SV_blank>for<S2SV_blank>server<S2SV_blank>fd:%d"" , fd , s ) ;",1391
762,if ( net != & init_net )  return - EAFNOSUPPORT ;,if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( net != & init_net ) return - EAFNOSUPPORT ;,1392
763,"
","rb_define_method ( req_class , ""remote_addr"" , remote_addr , 0 ) ;",1393
764,"rb_define_method ( req_class , ""rack_version"" , rack_version , 0 ) ;rb_define_method ( req_class , ""rack_url_scheme"" , rack_url_scheme , 0 ) ;","rb_define_method ( req_class , ""rack_version"" , rack_version , 0 ) ;rb_define_method ( req_class , ""rack_url_scheme"" , rack_url_scheme , 0 ) ;",1393
765,"rack_version_val = rb_str_new_cstr ( ""rack.version"" ) ;request_method_val = rb_str_new_cstr ( ""REQUEST_METHOD"" ) ;","rack_version_val = rb_str_new_cstr ( ""rack.version"" ) ;remote_addr_val = rb_str_new_cstr ( ""REMOTE_ADDR"" ) ;rb_gc_register_address ( & remote_addr_val ) ;request_method_val = rb_str_new_cstr ( ""REQUEST_METHOD"" ) ;",1393
766,"static void calc_segtree_probs ( int * segcounts , vp9_prob * segment_tree_probs ) {const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ;","static void calc_segtree_probs ( int * segcounts , vpx_prob * segment_tree_probs ) {const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ;",1394
767,"opt = xchg ( & np -> opt , NULL ) ;if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;pktopt = xchg ( & np -> pktoptions , NULL ) ;","opt = xchg ( ( __force struct ipv6_txoptions * * ) & np -> opt , NULL ) ;if ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}pktopt = xchg ( & np -> pktoptions , NULL ) ;",1395
768,"opt = ipv6_renew_options ( sk , np -> opt , optname ,  ( struct ipv6_opt_hdr __user * ) optval , optlen ) ;if ( IS_ERR ( opt ) ) {retv = PTR_ERR ( opt ) ;","opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ;opt = ipv6_renew_options ( sk , opt , optname , ( struct ipv6_opt_hdr __user * ) optval , optlen ) ;if ( IS_ERR ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}",1395
769,"sticky_done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;","sticky_done : if ( opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;",1395
770,"
","atomic_set ( & opt -> refcnt , 1 ) ;",1395
771,opt -> tot_len = sizeof ( * opt ) + optlen ;retv = - EFAULT ;,opt -> tot_len = sizeof ( * opt ) + optlen ;retv = - EFAULT ;,1395
772,"done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;","done : if ( opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;",1395
773,JSObjectRef globalobject ;JSStringRef var_name ;,JSObjectRef globalobject ;,1396
774,"globalobject = JSContextGetGlobalObject ( context ) ;var_name = JSStringCreateWithUTF8CString ( ""Uzbl"" ) ;JSObjectSetProperty ( context , globalobject , var_name , JSObjectMake ( context , uzbl . js . classref , NULL ) , kJSClassAttributeNone , NULL ) ;",globalobject = JSContextGetGlobalObject ( context ) ;,1396
775,"JSStringRelease ( js_result_string ) ;}JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ;JSStringRelease ( var_name ) ;","
",1396
776,"const int zbin = cpi -> zbin_mode_boost + x -> act_zbin_adj ;int i ;x -> plane [ 0 ] . quant = quants -> y_quant [ qindex ] ;x -> plane [ 0 ] . quant_shift = quants -> y_quant_shift [ qindex ] ;x -> plane [ 0 ] . zbin = quants -> y_zbin [ qindex ] ;x -> plane [ 0 ] . round = quants -> y_round [ qindex ] ;x -> plane [ 0 ] . zbin_extra = ( int16_t ) ( ( cm -> y_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ;xd -> plane [ 0 ] . dequant = cm -> y_dequant [ qindex ] ;x -> plane [ i ] . quant_shift = quants -> uv_quant_shift [ qindex ] ;x -> plane [ i ] . zbin = quants -> uv_zbin [ qindex ] ;x -> plane [ i ] . round = quants -> uv_round [ qindex ] ;x -> plane [ i ] . zbin_extra = ( int16_t ) ( ( cm -> uv_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ;xd -> plane [ i ] . dequant = cm -> uv_dequant [ qindex ] ;# if CONFIG_ALPHA  x -> plane [ 3 ] . quant = cpi -> a_quant [ qindex ] ;# endif  x -> skip_block = vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ;x -> q_index = qindex ;vp9_initialize_me_consts ( cpi , x -> q_index ) ;}","int i ;x -> plane [ 0 ] . quant_fp = quants -> y_quant_fp [ qindex ] ;xd -> plane [ 0 ] . dequant = cpi -> y_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ;xd -> plane [ 0 ] . dequant = cm -> y_dequant [ qindex ] ;x -> plane [ i ] . quant_shift = quants -> uv_quant_shift [ qindex ] ;x -> plane [ i ] . zbin = quants -> uv_zbin [ qindex ] ;xd -> plane [ i ] . dequant = cpi -> uv_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ;xd -> plane [ i ] . dequant = cm -> uv_dequant [ qindex ] ;# if CONFIG_ALPHA x -> plane [ 3 ] . quant = cpi -> a_quant [ qindex ] ;# endif x -> skip_block = segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ;x -> q_index = qindex ;vp9_initialize_me_consts ( cpi , x , x -> q_index ) ;}",1397
777,"
","if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( ""setsid"" ) ;",1398
778,"if ( label_exec ( opt_exec_label ) == - 1 )  die_with_error ( ""label_exec<S2SV_blank>%s"" , argv [ 0 ] ) ;","if ( label_exec ( opt_exec_label ) == - 1 ) die_with_error ( ""label_exec<S2SV_blank>%s"" , argv [ 0 ] ) ;",1398
779,"
",if ( unlikely ( page_count ( page ) <= 0 ) ) {if ( pages ) {spin_unlock ( ptl ) ;remainder = 0 ;err = - ENOMEM ;break ;}},1399
780,same_page :  if ( pages ) {,same_page : if ( pages ) {,1399
781,"
",# else ( void ) mr_cfg ;,1400
782,# endif  oxcf -> cpu_used = vp8_cfg . cpu_used ;,# endif oxcf -> cpu_used = vp8_cfg . cpu_used ;,1400
783,oxcf -> tuning = vp8_cfg . tuning ;return VPX_CODEC_OK ;,oxcf -> tuning = vp8_cfg . tuning ;oxcf -> screen_content_mode = vp8_cfg . screen_content_mode ;return VPX_CODEC_OK ;,1400
784,usleep ( us_delay ) ;pthread_mutex_unlock ( & in -> common . lock ) ;,TEMP_FAILURE_RETRY ( usleep ( us_delay ) ) ;pthread_mutex_unlock ( & in -> common . lock ) ;,1401
785,if ( ctx -> pbi ) {vp9_decoder_remove ( ctx -> pbi ) ;ctx -> pbi = NULL ;},if ( ctx -> frame_workers != NULL ) {int i ;for ( i = 0 ;i < ctx -> num_frame_workers ;++ i ) {VPxWorker * const worker = & ctx -> frame_workers [ i ] ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;vpx_get_worker_interface ( ) -> end ( worker ) ;vp9_remove_common ( & frame_worker_data -> pbi -> common ) ;# if CONFIG_VP9_POSTPROC vp9_free_postproc_buffers ( & frame_worker_data -> pbi -> common ) ;# endif vp9_decoder_remove ( frame_worker_data -> pbi ) ;vpx_free ( frame_worker_data -> scratch_buffer ) ;# if CONFIG_MULTITHREAD pthread_mutex_destroy ( & frame_worker_data -> stats_mutex ) ;pthread_cond_destroy ( & frame_worker_data -> stats_cond ) ;# endif vpx_free ( frame_worker_data ) ;}# if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ;# endif }if ( ctx -> buffer_pool ) {vp9_free_ref_frame_buffers ( ctx -> buffer_pool ) ;vp9_free_internal_frame_buffers ( & ctx -> buffer_pool -> int_frame_buffers ) ;}vpx_free ( ctx -> frame_workers ) ;vpx_free ( ctx -> buffer_pool ) ;,1402
786,"c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ;macinf -> lchid [ j + chan ] = c_t + 1 ;macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ;rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ;}","c_t = ( tvb_get_bits8 ( tvb , tb_bit_off , 4 ) + 1 ) % 0xf ;macinf -> lchid [ j + chan ] = c_t ;macinf -> content [ j + chan ] = lchId_type_table [ c_t ] ;rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t ] ;}",1403
787,"if ( setuid ( current_user . uid ) < 0 )  {if ( setgid ( current_user . gid ) < 0 )  sys_error ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>gid<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>effective<S2SV_blank>gid<S2SV_blank>%d"" ) , current_user . gid , current_user . egid ) ;","# if HAVE_DECL_SETRESUID if ( setresuid ( current_user . uid , current_user . uid , current_user . uid ) < 0 ) # endif # else if ( setuid ( current_user . uid ) < 0 ) {# if HAVE_DECL_SETRESGID if ( setresgid ( current_user . gid , current_user . gid , current_user . gid ) < 0 ) # endif # else if ( setgid ( current_user . gid ) < 0 ) sys_error ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>gid<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>effective<S2SV_blank>gid<S2SV_blank>%d"" ) , current_user . gid , current_user . egid ) ;",1404
788,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {ret = - ENOKEY ;goto error2 ;}",ret = key_read_state ( key ) ;if ( ret < 0 ) goto error2 ;,1405
789,"int copy = output_size - count ;if ( avail < copy ) copy = avail ;png_memcpy ( output + count , png_ptr -> zbuf , copy ) ;","png_size_t copy = output_size - count ;if ( ( png_size_t ) avail < copy ) copy = ( png_size_t ) avail ;png_memcpy ( output + count , png_ptr -> zbuf , copy ) ;",1406
790,"pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn +  pi -> picomp -> numrlvls - 1 ) ) ;pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn +  pi -> picomp -> numrlvls - 1 ) ) ;pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;","pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ;pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;",1407
791,"struct keydata * keyptr ;__u32 * hash = get_cpu_var ( get_random_int_hash ) ;int ret ;keyptr = get_keyptr ( ) ;hash [ 0 ] += current -> pid + jiffies + get_cycles ( ) ;ret = half_md4_transform ( hash , keyptr -> secret ) ;put_cpu_var ( get_random_int_hash ) ;","__u32 * hash = get_cpu_var ( get_random_int_hash ) ;int ret ;keyptr = get_keyptr ( ) ;md5_transform ( hash , keyptr -> secret ) ;put_cpu_var ( get_random_int_hash ) ;",1408
792,"struct task_struct * tsk = current ;struct fpu * fpu = & tsk -> thread . fpu ;int state_size = fpu_kernel_xstate_size ;u64 xfeatures = 0 ;int fx_only = 0 ;ia32_fxstate &= ( IS_ENABLED ( CONFIG_X86_32 ) || IS_ENABLED ( CONFIG_IA32_EMULATION ) ) ;if ( ! buf ) {fpu__clear ( fpu ) ;return 0 ;}if ( ! access_ok ( VERIFY_READ , buf , size ) ) return - EACCES ;fpu__activate_curr ( fpu ) ;if ( ! static_cpu_has ( X86_FEATURE_FPU ) ) return fpregs_soft_set ( current , NULL , 0 , sizeof ( struct user_i387_ia32_struct ) , NULL , buf ) != 0 ;if ( use_xsave ( ) ) {struct _fpx_sw_bytes fx_sw_user ;if ( unlikely ( check_for_xstate ( buf_fx , buf_fx , & fx_sw_user ) ) ) {state_size = sizeof ( struct fxregs_state ) ;fx_only = 1 ;trace_x86_fpu_xstate_check_failed ( fpu ) ;state_size = fx_sw_user . xstate_size ;xfeatures = fx_sw_user . xfeatures ;}}if ( ia32_fxstate ) {struct fpu * fpu = & tsk -> thread . fpu ;struct user_i387_ia32_struct env ;int err = 0 ;fpu__drop ( fpu ) ;if ( using_compacted_format ( ) )  err = copy_user_to_xstate ( & fpu -> state . xsave , buf_fx ) ;else   err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ;if ( err || __copy_from_user ( & env , buf , sizeof ( env ) ) ) {","err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ;if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ;}if ( err || __copy_from_user ( & env , buf , sizeof ( env ) ) ) {",1409
793,"static void  swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horAcc32 ( tif , cp0 , cc ) ;}","static int swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {return horAcc32 ( tif , cp0 , cc ) ;}",1410
794,while ( c -> chunked_encoding && ! c -> chunk_size && c -> buffer_end > c -> buffer_ptr ) {,while ( c -> chunked_encoding && ! c -> chunk_size <= 0 ) {c -> chunk_size = 0 ;goto fail ;}c -> buffer_ptr ) {,1411
795,if ( c -> chunk_size == 0 )  goto fail ;,if ( c -> chunk_size == 0 ) goto fail ;,1411
796,else {c -> chunk_size -= len ;,else {av_assert0 ( len <= c -> chunk_size ) ;c -> chunk_size -= len ;,1411
797,"u16 source_node_id ;u32 specifier_id ;u32 ver ;offset = dev -> rcv_buffer_size * dev -> broadcast_rcv_next_ptr ;buf_ptr = dev -> broadcast_rcv_buffer_ptrs [ dev -> broadcast_rcv_next_ptr ++ ] ;if ( dev -> broadcast_rcv_next_ptr == dev -> num_broadcast_rcv_ptrs ) dev -> broadcast_rcv_next_ptr = 0 ;spin_unlock_irqrestore ( & dev -> lock , flags ) ;specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8  | ( be32_to_cpu ( buf_ptr [ 1 ] ) & 0xff000000 ) >> 24 ;ver = be32_to_cpu ( buf_ptr [ 1 ] ) & 0xffffff ;source_node_id = be32_to_cpu ( buf_ptr [ 0 ] ) >> 16 ;if ( specifier_id == IANA_SPECIFIER_ID &&  ( ver == RFC2734_SW_VERSION  # if IS_ENABLED ( CONFIG_IPV6 )  || ver == RFC3146_SW_VERSION  # endif  ) ) {buf_ptr += 2 ;}packet . payload_length = dev -> rcv_buffer_size ;",if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) == IANA_SPECIFIER_ID && ( ver == RFC2734_SW_VERSION # if IS_ENABLED ( CONFIG_IPV6 ) || ver == RFC3146_SW_VERSION # endif ) ) {buf_ptr += 2 ;}packet . payload_length = dev -> rcv_buffer_size ;,1412
798,else  sc = create_spnego_ctx ( ) ;if ( sc == NULL ) {,else sc = create_spnego_ctx ( 0 ) ;if ( sc == NULL ) {,1413
799,len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;if ( ! EVP_CIPHER_CTX_encrypting ( c ) )   len -= EVP_GCM_TLS_TAG_LEN ;EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;,if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ;len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) {if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ;len -= EVP_GCM_TLS_TAG_LEN ;}EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;,1414
800,"int r , len , group = 0 ;Node * qn ;Node * * tp ;* np = NULL ;if ( tok -> type == ( enum TokenSyms ) term )  goto end_of_token ;switch ( tok -> type ) {","int r , len , group ;Node * qn ;Node * * tp ;unsigned int parse_depth ;group = 0 ;* np = NULL ;if ( tok -> type == ( enum TokenSyms ) term ) goto end_of_token ;parse_depth = env -> parse_depth ;switch ( tok -> type ) {",1415
801,"qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper ,  r == TK_INTERVAL ) ;","parse_depth ++ ;if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , r == TK_INTERVAL ) ;",1415
802,"static int bson_validate_string ( bson * b , const unsigned char * string ,  const int length , const char check_utf8 , const char check_dot ,  const char check_dollar ) {int position = 0 ;int sequence_length = 1 ;","static int bson_validate_string ( bson * b , const unsigned char * string , const size_t length , const char check_utf8 , const char check_dot , const char check_dollar ) {size_t position = 0 ;int sequence_length = 1 ;",1416
803,"q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) ,   Min ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;","q = QueueAuthenticPixels ( image , x , y , MagickMin ( 4 , dds_info -> width - x ) , MagickMin ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;",1417
804,"}SkipDXTMipmaps ( image , dds_info , 16 ) ;return MagickTrue ;","return ( }SkipDXTMipmaps ( image , dds_info , 16 , exception ) ) ;",1417
805,"if ( getCcalls ( L ) <= CSTACKERR )   luaE_freeCI ( L ) ;luaD_call ( L , func , nResults ) ;","if ( getCcalls ( L ) <= CSTACKERR ) {luaE_exitCcall ( L ) ;luaE_enterCcall ( L ) ;}luaD_call ( L , func , nResults ) ;",1418
806,"sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ;}",},1419
807,"ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ;return ;}if ( ! ndo -> ndo_eflag ) {ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ;}if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) {ND_PRINT ( ( ndo , ""%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ) ;case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;if ( ATMTHRD_LEN ( ap ) != 0 ) {ND_PRINT ( ( ndo , "")"" ) ) ;}ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_NAK :  ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;","ND_PRINT ( ( ndo , ""who-has<S2SV_blank>"" ) ) ;atmarp_tpaddr_print ( ndo , ap , pro ) ;case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;if ( ATMTHRD_LEN ( ap ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;break ;case ARPOP_REPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ""at<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""for<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_NAK : ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;",1420
808,"case kEmptyStream :  h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles ,  sizeof ( * h -> emptyStreamBools ) ) ;","case kEmptyStream : if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ;h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles , sizeof ( * h -> emptyStreamBools ) ) ;",1421
809,"h -> emptyFileBools = calloc ( empty_streams ,  sizeof ( * h -> emptyFileBools ) ) ;","if ( h -> emptyFileBools != NULL ) return ( - 1 ) ;h -> emptyFileBools = calloc ( empty_streams , sizeof ( * h -> emptyFileBools ) ) ;",1421
810,"h -> antiBools = calloc ( empty_streams ,  sizeof ( * h -> antiBools ) ) ;","if ( h -> antiBools != NULL ) return ( - 1 ) ;h -> antiBools = calloc ( empty_streams , sizeof ( * h -> antiBools ) ) ;",1421
811,if ( ( ll & 1 ) || ll < zip -> numFiles * 4 )  return ( - 1 ) ;,if ( ( ll & 1 ) || ll < zip -> numFiles * 4 ) return ( - 1 ) ;if ( zip -> entry_names != NULL ) return ( - 1 ) ;,1421
812,"h -> attrBools = calloc ( ( size_t ) zip -> numFiles ,  sizeof ( * h -> attrBools ) ) ;","if ( h -> attrBools != NULL ) return ( - 1 ) ;h -> attrBools = calloc ( ( size_t ) zip -> numFiles , sizeof ( * h -> attrBools ) ) ;",1421
813,static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx )  {if ( avctx -> bits_per_raw_sample > 8 ) {av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;return avctx -> pix_fmt ;,static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx ) {MpegEncContext * s = avctx -> priv_data ;if ( avctx -> bits_per_raw_sample > 8 ) {av_assert1 ( s -> studio_profile ) ;return avctx -> pix_fmt ;,1422
814,"len = file ? file -> size : 4096 ;p = realloc ( * data , len ) ;","len = file && file -> size > 0 ? file -> size : 4096 ;p = realloc ( * data , len ) ;",1423
815,"if ( data_sz <= 8 )  return VPX_CODEC_UNSUP_BITSTREAM ;if ( data + data_sz <= data ) return VPX_CODEC_INVALID_PARAM ;si -> is_kf = 0 ;si -> w = si -> h = 0 ;{struct vp9_read_bit_buffer rb = {data , data + data_sz , 0 , NULL , NULL };const int frame_marker = vp9_rb_read_literal ( & rb , 2 ) ;const int version = vp9_rb_read_bit ( & rb ) ;( void ) vp9_rb_read_bit ( & rb ) ;if ( frame_marker != VP9_FRAME_MARKER ) return VPX_CODEC_UNSUP_BITSTREAM ;if ( version > 1 ) return VPX_CODEC_UNSUP_BITSTREAM ;if ( vp9_rb_read_bit ( & rb ) ) {return VPX_CODEC_OK ;}si -> is_kf = ! vp9_rb_read_bit ( & rb ) ;if ( si -> is_kf ) {const int sRGB = 7 ;int colorspace ;rb . bit_offset += 1 ;rb . bit_offset += 1 ;if ( vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_0 || vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_1 || vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_2 ) {return VPX_CODEC_UNSUP_BITSTREAM ;}colorspace = vp9_rb_read_literal ( & rb , 3 ) ;if ( colorspace != sRGB ) {rb . bit_offset += 1 ;if ( version == 1 ) {rb . bit_offset += 2 ;rb . bit_offset += 1 ;}}else {if ( version == 1 ) {rb . bit_offset += 1 ;}else {return VPX_CODEC_UNSUP_BITSTREAM ;}}si -> w = vp9_rb_read_literal ( & rb , 16 ) + 1 ;si -> h = vp9_rb_read_literal ( & rb , 16 ) + 1 ;}}return VPX_CODEC_OK ;","return decoder_peek_si_internal ( data , data_sz , si , NULL , NULL , NULL ) ;",1424
816,"sdb_num_set ( sdb , ""num_entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) {if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) {goto beach ;}i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ;if ( i < 0 ) goto beach ;",st32 vnaux = entry -> vn_aux ;if ( vnaux < 1 ) {vstart += vnaux ;,1425
817,"vstart += entry -> vn_aux ;for ( j = 0 , isum = i + entry -> vn_aux ;","vstart += entry -> vn_aux ;for ( j = 0 , isum = i + entry -> vn_aux ;",1425
818,"if ( code )  return code ;code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ;","if ( code ) {* status = ""DECODE_PA_FOR_USER"" ;return code ;}code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ;",1426
819,"record_and_restart ( event , val , regs , nmi ) ;}","record_and_restart ( event , val , regs ) ;}",1427
820,if ( pSubSrc -> nSrc > 1 || isAgg || IsVirtual ( pSubSrc -> a [ 0 ] . pTab ) ) {return 0 ;,if ( pSubSrc -> nSrc > 1 || isAgg || IsVirtual ( pSubSrc -> a [ 0 ] . pTab ) || ( p -> selFlags & SF_Distinct ) != 0 ) {return 0 ;,1428
821,"DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , best_predictor , 16 * 4 ) ;DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff , 16 ) ;int dst_stride = x -> e_mbd . dst . y_stride ;","DECLARE_ALIGNED ( 16 , unsigned char , best_predictor [ 16 * 4 ) ;DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff [ 16 ] ) ;int dst_stride = x -> e_mbd . dst . y_stride ;",1429
822,"vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ;}","memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ;}",1429
823,"struct pipe_buffer * buf ;int idx = i -> idx ;size_t off = i -> iov_offset , orig_sz ;orig_sz = size ;if ( size ) {if ( off )   size += off - pipe -> bufs [ idx ] . offset ;while ( 1 ) {if ( size <= buf -> len )  break ;size -= buf -> len ;idx = next_idx ( idx , pipe ) ;}buf -> len = size ;i -> idx = idx ;off = i -> iov_offset = buf -> offset + size ;}if ( off ) idx = next_idx ( idx , pipe ) ;if ( pipe -> nrbufs ) {int unused = ( pipe -> curbuf + pipe -> nrbufs ) & ( pipe -> buffers - 1 ) ;while ( idx != unused ) {pipe_buf_release ( pipe , & pipe -> bufs [ idx ] ) ;pipe -> nrbufs -- ;i -> count -= orig_sz ;}","orig_sz = size ;if ( size ) {struct pipe_buffer * buf ;size_t off = i -> iov_offset , left = size ;int idx = i -> idx ;if ( off ) left += off - pipe -> bufs [ idx ] . offset ;while ( 1 ) {if ( left <= buf -> len ) break ;left -= buf -> len ;i -> idx = idx ;off = i -> iov_offset = buf -> offset + left ;}i -> count -= size ;pipe_truncate ( i ) ;",1430
824,"PyObject * logical = NULL ;FriBidiParType base = FRIBIDI_TYPE_RTL ;const char * encoding = ""utf-8"" ;static char * kwargs [ ] =  {""logical"" , ""base_direction"" , ""encoding"" , ""clean"" , ""reordernsm"" , NULL }if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""O|isii"" , kwargs ,   & logical , & base , & encoding , & clean , & reordernsm ) )   return NULL ;if ( ! ( base == FRIBIDI_TYPE_RTL ||  base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) )  return PyErr_Format ( PyExc_ValueError , ""invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON"" , base ) ;if ( PyUnicode_Check ( logical ) )  return log2vis_unicode ( logical , base , clean , reordernsm ) ;else if ( PyString_Check ( logical ) )  return log2vis_encoded_string ( logical , encoding , base , clean , reordernsm ) ;else return PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>unicode<S2SV_blank>or<S2SV_blank>str,<S2SV_blank>not<S2SV_blank>%s"" , logical -> ob_type -> tp_name ) ;","PyUnicodeObject * logical = NULL ;FriBidiParType base = FRIBIDI_TYPE_RTL ;static char * kwargs [ ] = {""logical"" , ""base_direction"" , ""clean"" , ""reordernsm"" , NULL }if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""U|iii"" , kwargs , & logical , & base , & clean , & reordernsm ) ) {return NULL ;}if ( ! ( base == FRIBIDI_TYPE_RTL || base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) {return PyErr_Format ( PyExc_ValueError , ""invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON"" , base ) ;}return unicode_log2vis ( logical , base , clean , reordernsm ) ;",1431
825,wp -> socket_mode = 0666 ;if ( ! c ) {,wp -> socket_mode = 0660 ;if ( ! c ) {,1432
826,"i1_is_end_of_poc = 0 ;if ( ! ps_dec -> u1_first_slice_in_stream ) {i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ;if ( ( ps_dec -> u4_first_slice_in_pic == 2 ) && ( i1_is_end_of_poc == 0 ) ) {}}",i1_is_end_of_poc = 1 ;}},1433
827,H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ;return OK ;,ps_dec -> u4_first_slice_in_pic = 0 ;H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ;return OK ;,1434
828,if ( g -> sect <= 0 ||   g -> head <= 0 ||  ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,if ( ( int ) g -> sect <= 0 || ( int ) g -> head <= 0 || ( int ) ( g -> sect * g -> head ) <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,1435
829,"u64 base_addr , size ;if ( flags && ( flags & ~ ( SETWA_FLAGS_APICID | SETWA_FLAGS_MEM | SETWA_FLAGS_PCIE_SBDF ) ) ) return - EINVAL ;","u64 base_addr , size ;if ( get_securelevel ( ) > 0 ) return - EPERM ;if ( flags && ( flags & ~ ( SETWA_FLAGS_APICID | SETWA_FLAGS_MEM | SETWA_FLAGS_PCIE_SBDF ) ) ) return - EINVAL ;",1436
830,"if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {error = - EOPNOTSUPP ;goto out_errno ;}error = fh_want_write ( fh ) ;error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ;if ( error ) goto out_drop_write ;error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  ACL_TYPE_DEFAULT ) ;out_drop_write :  fh_drop_write ( fh ) ;","error = fh_want_write ( fh ) ;}error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;fh_lock ( fh ) ;error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ;if ( error ) goto out_drop_lock ;error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default , ACL_TYPE_DEFAULT ) ;out_drop_lock : fh_unlock ( fh ) ;fh_drop_write ( fh ) ;",1437
831,dev -> netdev_ops = & bnep_netdev_ops ;dev -> watchdog_timeo = HZ * 2 ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & bnep_netdev_ops ;dev -> watchdog_timeo = HZ * 2 ;,1438
832,"uint32_t authResult = 0 , reasonLen = 0 ;char * reason = NULL ;",uint32_t authResult = 0 ;,1439
833,"if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return FALSE ;reasonLen = rfbClientSwap32IfLE ( reasonLen ) ;reason = malloc ( ( uint64_t ) reasonLen + 1 ) ;if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) {free ( reason ) ;",ReadReason ( client ) ;,1439
834,"}skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & error ) ;if ( error < 0 ) goto end ;m -> msg_namelen = 0 ;if ( skb ) {",if ( skb ) {,1440
835,"cJSON * cJSON_CreateIntArray ( int64_t * numbers , int count )  {for ( i = 0 ;++ i ) {n = cJSON_CreateInt ( numbers [ i ] ) ;if ( ! i )  a -> child = n ;","cJSON * cJSON_CreateIntArray ( const int * numbers , int count ) {for ( i = 0 ;+ i ) {i ++ ) {n = cJSON_CreateInt ( numbers [ i ] ) ;if ( ! n ) {cJSON_Delete ( a ) ;return 0 ;}if ( ! i ) a -> child = n ;",1441
836,f2fs_wait_discard_bios ( sbi ) ;if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) {,"f2fs_wait_discard_bios ( sbi , true ) ;if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) {",1442
837,"bitmap -> compressed = FALSE ;bitmap -> format = gdi -> dstFormat ;bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ;bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ;","UINT32 size = DstWidth * DstHeight ;bitmap -> compressed = FALSE ;bitmap -> format = gdi -> dstFormat ;if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ;size *= GetBytesPerPixel ( bitmap -> format ) ;bitmap -> length = size ;bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ;",1443
838,devc -> voc [ voice ] . panning = value ;},if ( voice < 0 || voice >= devc -> nr_voice ) return ;devc -> voc [ voice ] . panning = value ;},1444
839,"if ( server . vm_enabled && listLength ( server . io_ready_clients ) ) {listIter li ;server . vm_blocked_clients -- ;aeCreateFileEvent ( server . el , c -> fd , AE_READABLE , readQueryFromClient , c ) ;","if ( server . ds_enabled && listLength ( server . io_ready_clients ) ) {listIter li ;server . cache_blocked_clients -- ;aeCreateFileEvent ( server . el , c -> fd , AE_READABLE , readQueryFromClient , c ) ;",1445
840,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ;if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , sfar ) ;if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ;",1446
841,while ( entries -- )  {,# ifdef LIBRAW_LIBRARY_BUILD imgdata . process_warnings |= LIBRAW_WARN_PARSEFUJI_PROCESSED ;# endif while ( entries -- ) {,1447
842,int Q = cpi -> active_worst_quality ;cpi -> mb . zbin_over_quant = 0 ;,int Q = cpi -> active_worst_quality ;if ( cpi -> force_maxqp == 1 ) {cpi -> active_worst_quality = cpi -> worst_quality ;return cpi -> worst_quality ;}cpi -> mb . zbin_over_quant = 0 ;,1448
843,f = po -> fanout ;if ( ! f )  return ;,f = po -> fanout ;if ( f ) {,1449
844,"mutex_unlock ( & fanout_mutex ) ;if ( po -> rollover ) kfree_rcu ( po -> rollover , rcu ) ;}","if ( po -> rollover ) kfree_rcu ( po -> rollover , rcu ) ;}mutex_unlock ( & fanout_mutex ) ;}",1449
845,"void vp9_predict_intra_block ( const MACROBLOCKD * xd , int block_idx , int bwl_in ,   TX_SIZE tx_size , MB_PREDICTION_MODE mode ,  const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , int aoff , int loff , int plane ) {const int bwl = bwl_in - tx_size ;const int wmask = ( 1 << bwl ) - 1 ;const int have_top = ( block_idx >> bwl ) || xd -> up_available ;const int have_left = ( block_idx & wmask ) || xd -> left_available ;const int have_right = ( ( block_idx & wmask ) != wmask ) ;assert ( bwl >= 0 ) ;build_intra_predictors ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane ) ;","void vp9_predict_intra_block ( const MACROBLOCKD * xd , int bwl_in , TX_SIZE tx_size , MB_PREDICTION_MODE mode , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , int aoff , int loff , int plane ) {const int bw = ( 1 << bwl ) - 1 ;const int have_top = ( block_idx >> bwl ) || xd -> up_available ;const int have_left = aoff || xd -> left_available ;const int have_right = ( aoff + txw ) < bw ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {build_intra_predictors_high ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane , xd -> bd ) ;return ;}# endif build_intra_predictors ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane ) ;",1450
846,"z . kind = 0 ;z . class = 0 ;# define PARSE_STRING s = parse_field ( ndo , & parse , & parselen ) ;# define PARSE_FIELD_INT ( field ) PARSE_STRING if ( ! lose ) field = strtol ( s , 0 , 16 ) ;if ( lose ) return ;if ( strncmp ( z . version , ""ZEPH"" , 4 ) ) return ;PARSE_FIELD_INT ( z . numfields ) ;PARSE_FIELD_INT ( z . kind ) ;PARSE_FIELD_STR ( z . uid ) ;PARSE_FIELD_INT ( z . port ) ;PARSE_FIELD_INT ( z . auth ) ;PARSE_FIELD_INT ( z . authlen ) ;PARSE_FIELD_STR ( z . authdata ) ;PARSE_FIELD_STR ( z . class ) ;PARSE_FIELD_STR ( z . inst ) ;PARSE_FIELD_STR ( z . opcode ) ;PARSE_FIELD_STR ( z . sender ) ;PARSE_FIELD_STR ( z . recipient ) ;PARSE_FIELD_STR ( z . format ) ;PARSE_FIELD_INT ( z . cksum ) ;PARSE_FIELD_INT ( z . multi ) ;PARSE_FIELD_STR ( z . multi_uid ) ;if ( lose ) {ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ;","int truncated = 0 ;z . kind = 0 ;z . class = 0 ;# define PARSE_STRING s = parse_field ( ndo , & parse , & parselen , & truncated ) ;if ( truncated ) goto trunc ;# define PARSE_FIELD_INT ( field ) PARSE_STRING if ( ! lose ) field = strtol ( s , 0 , 16 ) ;if ( lose ) goto trunc ;ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ;return ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ;return ;",1451
847,},},1451
848,"if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse )  return ( ( void * ) NULL ) ;","if ( HeapOverflowSanityCheck ( count , quantum ) != MagickFalse ) return ( ( void * ) NULL ) ;",1452
849,"( void ) AcquireUniqueFilename ( postscript_file ) ;ps_file = fopen_utf8 ( postscript_file , ""wb"" ) ;if ( ps_file == ( FILE * ) NULL ) goto FINISH ;( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ;( void ) ReadBlob ( image , 2 * MagickPathExtent , magick ) ;( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ;while ( PS_Size -- > 0 ) {( void ) fputc ( ReadBlobByte ( image ) , ps_file ) ;}( void ) fclose ( ps_file ) ;magic_info = GetMagicInfo ( magick , 2 * MagickPathExtent , exception ) ;if ( magic_info == ( const MagicInfo * ) NULL ) goto FINISH_UNL ;if ( exception -> severity != UndefinedException ) goto FINISH_UNL ;if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ;( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MagickPathExtent ) ;FormatLocaleString ( clone_info -> filename , MagickPathExtent , ""%s"" , postscript_file ) ;","( void ) strncpy ( clone_info -> magick , magic_info -> name , MagickPathExtent ) ;FormatLocaleString ( clone_info -> filename , MagickPathExtent , ""%s"" , postscript_file ) ;",1453
850,for ( i = 0 ;i < len ;i ++ ) {if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) {szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ;j ++ ;else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;szLineConv [ j ] = szLine [ i ] ;i ++ ;szLineConv [ j ] = szLine [ i ] ;i ++ ;,"for ( i = 0 ;i < len && j < sizeof ( szLineConv ) - 1 ;i ++ , j ++ ) {if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) {if ( j + 1 < sizeof ( szLineConv ) - 1 ) {szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ;j ++ ;else break ;}else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) {if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;else {break ;}}if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;else {break ;}}if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;",1454
851,i += 1 ;continue ;szLineConv [ j ] = szLine [ i ] ;j ++ ;,break ;if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ;}if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ;else szLineConv [ j ] = szLine [ i ] ;j ++ ;,1454
852,"void rdp_read_flow_control_pdu ( wStream * s , UINT16 * type )  {UINT8 pduType ;Stream_Read_UINT8 ( s , pduType ) ;}","BOOL rdp_read_flow_control_pdu ( wStream * s , UINT16 * type ) {UINT8 pduType ;if ( ! type ) return FALSE ;if ( Stream_GetRemainingLength ( s ) < 6 ) return FALSE ;Stream_Read_UINT8 ( s , pduType ) ;return TRUE ;}",1455
853,"static const u_char *  ikev1_attr_print ( netdissect_options * ndo , const u_char * p , const u_char * ep )  {if ( p [ 0 ] & 0x80 )  totlen = 4 ;else  totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ep < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ;}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ;}return p + totlen ;}","static const u_char * ep2 ) {ND_TCHECK ( p [ 0 ] ) ;if ( p [ 0 ] & 0x80 ) totlen = 4 ;else {ND_TCHECK_16BITS ( & p [ 2 ] ) ;}if ( ep2 < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , totlen - 4 ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , totlen - 4 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}return p + totlen ;trunc : return NULL ;}",1456
854,uchar buf [ 2 ] ;assert ( JAS_STREAM_MAXPUTBACK >= 2 ) ;,jas_uchar buf [ 2 ] ;assert ( JAS_STREAM_MAXPUTBACK >= 2 ) ;,1457
855,"
",args -> rmtvaluelen = args -> valuelen ;,1458
856,"}xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ;","}xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ;",1458
857,reset_globals ( ) ;passert ( GLOBALS_ARE_RESET ( ) ) ;},},1459
858,"while ( bin )  {numones -= 1 ;numones = CLIP3 ( numones , 0 , 16 ) ;",while ( bin && ( numones <= 16 ) ) {numones -= 1 ;,1460
859,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",1461
860,"case PIMV2_HELLO_OPTION_HOLDTIME :  unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ;break ;","case PIMV2_HELLO_OPTION_HOLDTIME : if ( olen != 2 ) {ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ;}}else {unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ;break ;",1462
861,"case PIMV2_HELLO_OPTION_GENID :  ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ;break ;case PIMV2_HELLO_OPTION_REFRESH_CAP :  ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ;if ( * ( bp + 1 ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ;}","case PIMV2_HELLO_OPTION_GENID : if ( olen != 4 ) {ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ;}}else {ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ;break ;case PIMV2_HELLO_OPTION_REFRESH_CAP : if ( olen != 4 ) {ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ;}}else {ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ;if ( * ( bp + 1 ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ;}",1462
862,return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;},if ( node -> nd_item . ci_parent ) return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;else return NULL ;},1463
863,int64_t cur_offset = avio_tell ( pb ) ;if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) flags_size = 2 ;,"int64_t cur_offset = avio_tell ( pb ) ;if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) {av_log ( s , AV_LOG_WARNING , ""Empty<S2SV_blank>audio<S2SV_blank>Packet\\\return AVERROR ( EINVAL ) ;}if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) flags_size = 2 ;",1464
864,if ( count >= 4 ) {int retTIFFReadRawTile ;,if ( count > 4 ) {int retTIFFReadRawTile ;,1465
865,"
","{uint8_t computedHvi [ 32 ] ;uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ;uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ;uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ;memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ;memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ;zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ;free ( DHPartHelloMessageString ) ;if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) {free ( messageData ) ;return BZRTP_PARSER_ERROR_UNMATCHINGHVI ;}}",1466
866,}uint8_t checkH2 [ 32 ] ;,}uint8_t checkH2 [ 32 ] ;,1466
867,"ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;ND_TCHECK ( pim -> pim_rsv ) ;pimv2_addr_len = pim -> pim_rsv ;if ( pimv2_addr_len != 0 )  ND_PRINT ( ( ndo , "",<S2SV_blank>RFC2117-encoding"" ) ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>"" , EXTRACT_16BITS ( & pim -> pim_cksum ) ) ) ;","int pimv2_addr_len ;ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;if ( len < 2 ) goto trunc ;ND_TCHECK ( pim -> pim_rsv ) ;pimv2_addr_len = pim -> pim_rsv ;if ( pimv2_addr_len != 0 ) ND_PRINT ( ( ndo , "",<S2SV_blank>RFC2117-encoding"" ) ) ;if ( len < 4 ) goto trunc ;ND_TCHECK ( pim -> pim_cksum ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>"" , EXTRACT_16BITS ( & pim -> pim_cksum ) ) ) ;",1467
868,"
",bp += 4 ;len -= 4 ;,1467
869,"switch ( PIM_TYPE ( pim -> pim_typever ) ) {case PIMV2_TYPE_HELLO : {bp += 4 ;while ( bp < ep ) {ND_TCHECK2 ( bp [ 0 ] , 4 ) ;otype = EXTRACT_16BITS ( & bp [ 0 ] ) ;olen = EXTRACT_16BITS ( & bp [ 2 ] ) ;ND_TCHECK2 ( bp [ 0 ] , 4 + olen ) ;ND_PRINT ( ( ndo , ""\\\bp += 4 ;","switch ( PIM_TYPE ( pim -> pim_typever ) ) {case PIMV2_TYPE_HELLO : {while ( len > 0 ) {if ( len < 4 ) goto trunc ;ND_TCHECK2 ( bp [ 0 ] , olen ) ;",1467
870,"while ( ptr < ( bp + olen ) ) {ND_PRINT ( ( ndo , ""\\\advance = pimv2_addr_print ( ndo , ptr , pimv2_unicast , 0 ) ;if ( advance < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}","u_int plen = len ;while ( ptr < ( bp + olen ) ) {ND_PRINT ( ( ndo , ""\\\advance = pimv2_addr_print ( ndo , ptr , plen , pimv2_unicast , pimv2_addr_len , 0 ) ;if ( advance < 0 ) goto trunc ;plen -= advance ;",1467
871,"bp += olen ;}ND_TCHECK2 ( * ( bp + 4 ) , PIMV2_REGISTER_FLAG_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]\\\bp += 8 ;ip = ( const struct ip * ) bp ;switch ( IP_V ( ip ) ) {case 0 :  ND_PRINT ( ( ndo , ""IP-Null-header<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ;","bp += olen ;len -= olen ;}if ( len < 4 ) goto trunc ;ND_TCHECK2 ( * bp , PIMV2_REGISTER_FLAG_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]\\\bp += 8 ;ip = ( const struct ip * ) bp ;switch ( IP_V ( ip ) ) {case 0 : ND_PRINT ( ( ndo , ""IP-Null-header<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ;",1467
872,"case PIMV2_TYPE_REGISTER_STOP :  bp += 4 ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;","case PIMV2_TYPE_REGISTER_STOP : bp += 4 ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;",1467
873,"int i , j ;bp += 4 ;if ( bp >= ep )  break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;}if ( bp + 4 > ep )  break ;ngroup = bp [ 1 ] ;holdtime = EXTRACT_16BITS ( & bp [ 2 ] ) ;ND_PRINT ( ( ndo , ""\\\","int i , j ;bp += 4 ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>source="" ) ) ;",1467
874,"if ( bp >= ep )  goto jp_done ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;goto jp_done ;}bp += advance ;len -= advance ;if ( bp + 4 > ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;goto jp_done ;}njoin = EXTRACT_16BITS ( & bp [ 0 ] ) ;nprune = EXTRACT_16BITS ( & bp [ 2 ] ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>joined<S2SV_blank>sources:<S2SV_blank>%u,<S2SV_blank>pruned<S2SV_blank>sources:<S2SV_blank>%u"" , njoin , nprune ) ) ;bp += 4 ;len -= 4 ;for ( j = 0 ;j < njoin ;j ++ ) {ND_PRINT ( ( ndo , ""\\\if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;goto jp_done ;}bp += advance ;len -= advance ;}for ( j = 0 ;j < nprune ;j ++ ) {ND_PRINT ( ( ndo , ""\\\if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;goto jp_done ;}bp += advance ;len -= advance ;}}jp_done :  break ;}case PIMV2_TYPE_BOOTSTRAP : {int i , j , frpcnt ;bp += 4 ;if ( bp + sizeof ( uint16_t ) >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>tag=%x"" , EXTRACT_16BITS ( bp ) ) ) ;bp += sizeof ( uint16_t ) ;if ( bp >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>hashmlen=%d"" , bp [ 0 ] ) ) ;if ( bp + 1 >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>BSRprio=%d"" , bp [ 1 ] ) ) ;bp += 2 ;if ( bp >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>BSR="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;","if ( bp >= ep ) goto jp_done ;if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;",1467
875,"if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) )  < 0 ) {if ( bp >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;if ( bp + 1 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>FRPcnt=%d"" , frpcnt = bp [ 1 ] ) ) ;bp += 4 ;for ( j = 0 ;if ( ( advance = pimv2_addr_print ( ndo , bp ,  pimv2_unicast , 0 ) ) < 0 ) {if ( bp + 1 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;if ( bp + 2 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;ND_PRINT ( ( ndo , "",prio=%d"" , bp [ 2 ] ) ) ;bp += 4 ;}ND_PRINT ( ( ndo , "")"" ) ) ;bs_done :  break ;case PIMV2_TYPE_ASSERT :  bp += 4 ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;if ( bp >= ep )  break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}","if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {if ( bp >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;if ( bp + 1 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>FRPcnt=%d"" , frpcnt = bp [ 1 ] ) ) ;bp += 4 ;for ( j = 0 ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {if ( bp + 1 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;if ( bp + 2 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;ND_PRINT ( ( ndo , "",prio=%d"" , bp [ 2 ] ) ) ;bp += 4 ;}ND_PRINT ( ( ndo , "")"" ) ) ;bs_done : break ;case PIMV2_TYPE_ASSERT : bp += 4 ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ;",1467
876,"bp += 4 ;if ( bp >= ep ) break ;if ( bp + 1 >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>prio=%d"" , bp [ 1 ] ) ) ;if ( bp + 3 >= ep ) break ;unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ;bp += 4 ;if ( bp >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>RP="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) )  < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}bp += advance ;ND_PRINT ( ( ndo , ""<S2SV_blank>grp="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}ND_PRINT ( ( ndo , ""<S2SV_blank>forwarder="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}ND_TCHECK2 ( bp [ 0 ] , 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>TUNR<S2SV_blank>"" ) ) ;","bp += 4 ;if ( bp >= ep ) break ;if ( bp + 1 >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>prio=%d"" , bp [ 1 ] ) ) ;if ( bp + 3 >= ep ) break ;unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ;bp += 4 ;if ( bp >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>RP="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ;if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ;if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_source , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ;ND_PRINT ( ( ndo , ""<S2SV_blank>grp="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_source , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ;ND_PRINT ( ( ndo , ""<S2SV_blank>forwarder="" ) ) ;if ( len < 2 ) goto trunc ;ND_TCHECK ( bp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>TUNR<S2SV_blank>"" ) ) ;",1467
877,"
",if ( pParse -> nErr ) goto multi_select_end ;,1468
878,if ( p -> selFlags & SF_UsesEphemeral ) {int i ;,if ( p -> selFlags & SF_UsesEphemeral ) {int i ;,1468
879,struct fscrypt_info * ci = inode -> i_crypt_info ;if ( ! ci ||  ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ) return fscrypt_get_crypt_info ( inode ) ;return 0 ;,"struct fscrypt_info * crypt_info ;struct fscrypt_context ctx ;struct crypto_skcipher * ctfm ;const char * cipher_str ;int keysize ;u8 * raw_key = NULL ;int res ;if ( inode -> i_crypt_info ) return 0 ;res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ;if ( res ) return res ;if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ;res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ;if ( res < 0 ) {if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ;memset ( & ctx , 0 , sizeof ( ctx ) ) ;ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ;ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ;ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ;memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ;}else if ( res != sizeof ( ctx ) ) {return - EINVAL ;}if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ;if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ;crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ;if ( ! crypt_info ) return - ENOMEM ;crypt_info -> ci_flags = ctx . flags ;crypt_info -> ci_data_mode = ctx . contents_encryption_mode ;crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ;crypt_info -> ci_ctfm = NULL ;memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ;res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ;if ( res ) goto out ;res = - ENOMEM ;raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ;if ( ! raw_key ) goto out ;res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ;if ( res && inode -> i_sb -> s_cop -> key_prefix ) {int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ;if ( res2 ) {if ( res2 == - ENOKEY ) res = - ENOKEY ;goto out ;}}else if ( res ) {goto out ;}ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ;if ( ! ctfm || IS_ERR ( ctfm ) ) {res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ;printk ( KERN_DEBUG ""%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\\goto out ;}crypt_info -> ci_ctfm = ctfm ;crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ;crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ;res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ;if ( res ) goto out ;if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ;out : if ( res == - ENOKEY ) res = 0 ;put_crypt_info ( crypt_info ) ;kzfree ( raw_key ) ;return res ;",1469
880,"struct macroblockd_plane * pd = & xd -> plane [ plane ] ;vp9_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) ,  16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) ,  pd -> dequant , p -> zbin_extra , & p -> eobs [ block ] , scan , iscan ) ;}","# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {vpx_highbd_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant , & p -> eobs [ block ] , scan , iscan ) ;return ;}# endif vpx_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant , & p -> eobs [ block ] , scan , iscan ) ;}",1470
881,"
",if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;},1471
882,jumpstack [ stackidx ++ ] = e ;},jumpstack [ stackidx ++ ] = e ;},1471
883,"CRM_LOG_ASSERT ( client_obj -> request_id ) ;rid = client_obj -> request_id ;crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" ,  rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}","if ( client_obj -> ipc ) {CRM_LOG_ASSERT ( client_obj -> request_id ) ;rid = client_obj -> request_id ;crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}else {crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}}",1472
884,"if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream ,  p_manager ) ) {","if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size , & l_current_nb_bytes_written , p_stream , p_manager ) ) {",1473
885,if ( payload_len > IPV6_MAXPLEN ) {,if ( fp && payload_len > IPV6_MAXPLEN ) {,1474
886,if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL )  fp = fp -> next ;,if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) fp = fp -> next ;,1474
887,int i ;for ( i = 0 ;,"int i ;account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ;free_uid ( pipe -> user ) ;for ( i = 0 ;",1475
888,"info = sdscatprintf ( sdsempty ( ) , ""redis_version:%s\\\\r\\\if ( server . vm_enabled ) {lockThreadedIO ( ) ;info = sdscatprintf ( info ,  ""vm_conf_max_memory:%llu\\\\r\\\","info = sdscatprintf ( sdsempty ( ) , ""redis_version:%s\\\\r\\\if ( server . ds_enabled ) {lockThreadedIO ( ) ;info = sdscatprintf ( info , ""cache_max_memory:%llu\\\\r\\\",1476
889,"p = strrchr ( context -> buffer , \\\'\\\\""\\\' ) ;p = strchr ( context -> buffer , \\\'\\\\""\\\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;","p = osStrchr ( context -> buffer , \\\'\\\\""\\\' ) ;p = strchr ( context -> buffer , \\\'\\\\""\\\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;",1477
890,"void imap_quote_string ( char * dest , size_t dlen , const char * src )  {static const char quote [ ] = ""\\\\""\\\\\\\\"" ;","void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) {const char * quote = ""`\\\\""\\\\\\\\"" ;if ( ! quote_backtick ) quote ++ ;",1478
891,"static inline void header_put_le_short ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 2 )   {psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;};}","static inline void header_put_le_short ( SF_PRIVATE * psf , int x ) {psf -> header ) - 2 ) {psf -> header . indx ++ ] = ( x >> 8 ) ;}",1479
892,"
",img -> bit_depth = 8 ;,1480
893,img -> bps = 12 ;img -> user_priv = user_priv ;,img -> bps = 12 ;img -> user_priv = user_priv ;,1480
894,s = & pit_state -> channels [ addr ] ;mutex_lock ( & pit_state -> lock ) ;,if ( addr == 3 ) return 0 ;s = & pit_state -> channels [ addr ] ;mutex_lock ( & pit_state -> lock ) ;,1481
895,"if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {error = - ENOENT ;","if ( ! dev_name || kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {error = - ENOENT ;",1482
896,"int i , n_items , end_lineno , end_col_offset ;asdl_seq * items , * body ;REQ ( n , with_stmt ) ;n_items = ( NCH ( n ) - 2 ) / 2 ;items = _Py_asdl_seq_new ( n_items , c -> c_arena ) ;for ( i = 1 ;i < NCH ( n ) - 2 ;withitem_ty item = ast_for_with_item ( c , CHILD ( n , i ) ) ;if ( is_async )   return AsyncWith ( items , body , LINENO ( n0 ) , n0 -> n_col_offset ,  end_lineno , end_col_offset , c -> c_arena ) ;else  return With ( items , body , LINENO ( n ) , n -> n_col_offset ,  end_lineno , end_col_offset , c -> c_arena ) ;","int i , n_items , nch_minus_type , has_type_comment , end_lineno , end_col_offset ;asdl_seq * items , * body ;string type_comment ;REQ ( n , with_stmt ) ;has_type_comment = TYPE ( CHILD ( n , NCH ( n ) - 2 ) ) == TYPE_COMMENT ;nch_minus_type = NCH ( n ) - has_type_comment ;n_items = ( nch_minus_type - 2 ) / 2 ;items = _Py_asdl_seq_new ( n_items , c -> c_arena ) ;for ( i = 1 ;i < nch_minus_type - 2 ;withitem_ty item = ast_for_with_item ( c , CHILD ( n , i ) ) ;if ( has_type_comment ) {type_comment = NEW_TYPE_COMMENT ( CHILD ( n , NCH ( n ) - 2 ) ) ;if ( ! type_comment ) return NULL ;}else type_comment = NULL ;if ( is_async ) return AsyncWith ( items , body , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;else return With ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;",1483
897,"while ( * s && * s != \\\'\\\\""\\\' )  * ptmp ++ = * s ++ ;","while ( * s && ( * s != \\\'\\\\""\\\' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) ) * ptmp ++ = * s ++ ;",1484
898,while ( isdigit ( ( unsigned char ) * s ) )  * ptmp ++ = * s ++ ;,while ( isdigit ( ( unsigned char ) * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) ) * ptmp ++ = * s ++ ;,1484
899,tlv = cp + i ;type = EXTRACT_16BITS ( tlv ) ;,if ( i + 4 > length ) return - 1 ;tlv = cp + i ;type = EXTRACT_16BITS ( tlv ) ;,1485
900,"ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ;switch ( type ) {","ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ;if ( i + 4 + optlen > length ) return - 1 ;switch ( type ) {",1485
901,"if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ;gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ;","gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\memcpy ( gr -> gr_ctx . length = 4 ;gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ;",1486
902,"s -> off = strtoll ( p , NULL , 10 ) ;if ( ( slash = strchr ( p , \'/\' ) ) && strlen ( slash ) > 0 )  s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ;}","s -> off = strtoull ( p , NULL , 10 ) ;if ( ( slash = strchr ( p , \'/\' ) ) && strlen ( slash ) > 0 ) s -> filesize = strtoull ( slash + 1 , NULL , 10 ) ;}",1487
903,"if ( count != ( ssize_t ) length )  ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ;","if ( count != ( ssize_t ) length ) {quantum_info = DestroyQuantumInfo ( quantum_info ) ;ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;}( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ;",1488
904,const VP9_CONFIG * oxcf = & cpi -> oxcf ;RATE_CONTROL * const rc = & cpi -> rc ;,const VP9EncoderConfig * oxcf = & cpi -> oxcf ;RATE_CONTROL * const rc = & cpi -> rc ;,1489
905,int drop_mark = ( int ) ( oxcf -> drop_frames_water_mark *  oxcf -> optimal_buffer_level / 100 ) ;if ( ( rc -> buffer_level > drop_mark ) && ( rc -> decimation_factor > 0 ) ) {,int drop_mark = ( int ) ( oxcf -> drop_frames_water_mark * rc -> optimal_buffer_level / 100 ) ;if ( ( rc -> buffer_level > drop_mark ) && ( rc -> decimation_factor > 0 ) ) {,1489
906,register struct enamemem * tp ;char buf [ BUFSIZE ] ;if ( tp -> e_name )   return ( tp -> e_name ) ;cp = buf ;,register struct bsnamemem * tp ;char buf [ BUFSIZE ] ;if ( tp -> bs_name ) return ( tp -> e_name ) ;cp = buf ;,1490
907,"tp -> e_name = strdup ( buf ) ;if ( tp -> e_name == NULL )  ( * ndo -> ndo_error ) ( ndo , ""le64addr_string:<S2SV_blank>strdup(buf)"" ) ;return ( tp -> e_name ) ;}","tp -> bs_name = strdup ( buf ) ;if ( tp -> bs_name == NULL ) ( * ndo -> ndo_error ) ( ndo , ""le64addr_string:<S2SV_blank>strdup(buf)"" ) ;return ( tp -> bs_name ) ;}",1490
908,"static int can_open_cached ( struct nfs4_state * state , int mode )  {switch ( mode & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) {case FMODE_READ : ret |= test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) != 0 ;return ret ;}","static int can_open_cached ( struct nfs4_state * state , fmode_t mode , int open_mode ) {if ( open_mode & O_EXCL ) goto out ;switch ( mode & ( FMODE_READ | FMODE_WRITE ) ) {case FMODE_READ : ret |= test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) != 0 ;out : return ret ;}",1491
909,if ( src < ( uint8_t * ) buf || src > ( uint8_t * ) buf + buf_size )  goto done ;,if ( src < ( uint8_t * ) buf || src + src_size < src || src + src_size > ( uint8_t * ) buf + buf_size ) goto done ;,1492
910,"if ( * p == FAC_CCITT_DEST_NSAP ) {memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ;","if ( l < 10 || l > 20 ) return - 1 ;if ( * p == FAC_CCITT_DEST_NSAP ) {memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ;",1493
911,"int i ;for ( i = 0 ;i < pWith -> nCte ;i ++ ) {if ( sqlite3StrICmp ( zName , pWith -> a [ i ] . zName ) == 0 ) {sqlite3ErrorMsg ( pParse , ""duplicate<S2SV_blank>WITH<S2SV_blank>table<S2SV_blank>name:<S2SV_blank>%s"" , zName ) ;}}}if ( pWith ) {int nByte = sizeof ( * pWith ) + ( sizeof ( pWith -> a [ 1 ] ) * pWith -> nCte ) ;pNew = sqlite3DbRealloc ( db , pWith , nByte ) ;","sqlite3_int64 nByte = sizeof ( * pWith ) + ( sizeof ( pWith -> a [ 1 ] ) * pWith -> nCte ) ;pNew = sqlite3DbRealloc ( db , pWith , nByte ) ;",1494
912,"if ( offset >= ARRAY_SIZE ( sysinfo_table ) ) {printk ( ""sysinfo(%d)"" , command ) ;goto out ;}down_read ( & uts_sem ) ;res = sysinfo_table [ offset ] ;len = strlen ( res ) + 1 ;if ( len > count )  len = count ;",if ( ( unsigned long ) len > ( unsigned long ) count ) len = count ;,1495
913,"ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ;","ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;",1496
914,"trunc :  ND_PRINT ( ( ndo , ""\\\}","trunc : ND_PRINT ( ( ndo , ""\\\}",1496
915,"cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;error = PTR_ERR ( cookie ) ;","nd -> last_type = LAST_BIND ;cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;error = PTR_ERR ( cookie ) ;",1497
916,return - 1 ;}return - 1 ;}return - 1 ;}return - 1 ;}return - 1 ;}return - 1 ;},goto bail ;}goto bail ;}goto bail ;}goto bail ;}goto bail ;}goto bail ;},1498
917,},bail : free ( tmpbuf ) ;tmpbuf = NULL ;return - 1 ;},1498
918,"static void  ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) {return ;}ptr = cp [ 2 ] - 1 ;len = 0 ;switch ( cp [ 3 ] & 0xF ) {case IPOPT_TS_TSONLY : ND_PRINT ( ( ndo , ""TSONLY"" ) ) ;","static int ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) {return ( 0 ) ;}ND_TCHECK ( cp [ 2 ] ) ;ND_TCHECK ( cp [ 3 ] ) ;ptr = cp [ 2 ] - 1 ;len = 0 ;switch ( cp [ 3 ] & 0xF ) {case IPOPT_TS_TSONLY : ND_PRINT ( ( ndo , ""TSONLY"" ) ) ;",1499
919,"if ( ptr == len )  type = ""<S2SV_blank>^<S2SV_blank>"" ;ND_PRINT ( ( ndo , ""%s%d@%s"" , type , EXTRACT_32BITS ( & cp [ len + hoplen - 4 ] ) , hoplen != 8 ? """" : ipaddr_string ( ndo , & cp [ len ] ) ) ) ;","if ( ptr == len ) type = ""<S2SV_blank>^<S2SV_blank>"" ;ND_TCHECK2 ( cp [ len ] , hoplen ) ;ND_PRINT ( ( ndo , ""%s%d@%s"" , type , EXTRACT_32BITS ( & cp [ len + hoplen - 4 ] ) , hoplen != 8 ? """" : ipaddr_string ( ndo , & cp [ len ] ) ) ) ;return ( 0 ) ;trunc : return ( - 1 ) ;",1499
920,},},1499
921,void impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec )  {,WORD32 impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) {,1500
922,ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ;ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},1500
923,ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ;ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},1500
924,},return 0 ;},1500
925,"comics_document -> selected_command = g_find_program_in_path ( ""unrar-free"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = GNAUNRAR ;return TRUE ;}comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}}","
",1501
926,"comics_document -> selected_command = g_find_program_in_path ( ""7z"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = P7ZIP ;return TRUE ;}comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}","
",1501
927,"comics_document -> selected_command = g_find_program_in_path ( ""7z"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = P7ZIP ;return TRUE ;}comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}}else if ( g_content_type_is_a ( mime_type , ""application/x-cbt"" ) || g_content_type_is_a ( mime_type , ""application/x-tar"" ) ) {comics_document -> selected_command = g_find_program_in_path ( ""tar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}comics_document -> selected_command = g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}","
",1501
928,"static u32 ip6_idents_hashrnd __read_mostly ;u32 id ;net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ;id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ;return htonl ( id ) ;","u32 id ;id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ;return htonl ( id ) ;",1502
929,"int mi_index = 0 ;FILE * mvs = fopen ( file , ""a"" ) ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ;int rows = cm -> mi_rows ;print_mi_data ( cm , mvs , ""Partitions:"" , offsetof ( MB_MODE_INFO , sb_type ) ) ;print_mi_data ( cm , mvs , ""Modes:"" , offsetof ( MB_MODE_INFO , mode ) ) ;print_mi_data ( cm , mvs , ""Skips:"" , offsetof ( MB_MODE_INFO , skip ) ) ;print_mi_data ( cm , mvs , ""Ref<S2SV_blank>frame:"" , offsetof ( MB_MODE_INFO , ref_frame [ 0 ] ) ) ;log_frame_info ( cm , ""Vectors<S2SV_blank>"" , mvs ) ;fprintf ( mvs , ""V<S2SV_blank>"" ) ;for ( mi_col = 0 ;fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row ,  mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . col ) ;mi_index ++ ;mi_index += 8 ;}fclose ( mvs ) ;}","FILE * mvs = fopen ( file , ""a"" ) ;MODE_INFO * * mi = cm -> mi_grid_visible ;int rows = cm -> mi_rows ;print_mi_data ( cm , mvs , ""Ref<S2SV_blank>frame:"" , offsetof ( MB_MODE_INFO , ref_frame [ 0 ] ) ) ;log_frame_info ( cm , ""Skips:"" , mvs ) ;fprintf ( mvs , ""V<S2SV_blank>"" ) ;for ( mi_col = 0 ;fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , mi_8x8 [ mi_index ] -> mbmi . skip ) ;mi ++ ;mi_index += 8 ;}fclose ( mvs ) ;}",1503
930,"}else if ( caught_signal ) status = caught_signal + 128 ;if ( caught_signal )  {sleep ( 2 ) ;kill ( child , SIGKILL ) ;fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\\switch ( caught_signal ) {","child = ( pid_t ) - 1 ;}else if ( caught_signal && child != ( pid_t ) - 1 ) status = caught_signal + 128 ;if ( caught_signal ) {if ( child != ( pid_t ) - 1 ) {}sleep ( 2 ) ;kill ( child , SIGKILL ) ;fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\\switch ( caught_signal ) {",1504
931,}if ( ret ) fpstate_init ( & fpu -> state ) ;,if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;}if ( ret ) fpstate_init ( & fpu -> state ) ;,1505
932,return le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ;},if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;return le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ;},1506
933,"if ( level != SOL_PPPOL2TP )  return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ;if ( optlen < sizeof ( int ) ) return - EINVAL ;",if ( level != SOL_PPPOL2TP ) return - EINVAL ;if ( optlen < sizeof ( int ) ) return - EINVAL ;,1507
934,"static void write_frame_size_with_refs ( VP9_COMP * cpi ,  struct vp9_write_bit_buffer * wb ) {VP9_COMMON * const cm = & cpi -> common ;found = cm -> width == cfg -> y_crop_width &&  cm -> height == cfg -> y_crop_height ;if ( cpi -> use_svc ) {found = 0 ;vp9_wb_write_bit ( wb , found ) ;vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ;vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ;}","static void write_frame_size_with_refs ( VP9_COMP * cpi , struct vpx_write_bit_buffer * wb ) {VP9_COMMON * const cm = & cpi -> common ;if ( cpi -> use_svc && ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( cpi -> svc . number_spatial_layers > 1 && cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . is_key_frame ) || ( is_two_pass_svc ( cpi ) && cpi -> svc . encode_empty_frame_state == ENCODING && cpi -> svc . layer_context [ 0 ] . frames_from_key_frame < cpi -> svc . number_temporal_layers + 1 ) ) ) {found = 0 ;else if ( cfg != NULL ) {found = cm -> width == cfg -> y_crop_width && cm -> height == cfg -> y_crop_height ;}vpx_wb_write_bit ( wb , found ) ;vpx_wb_write_literal ( wb , cm -> width - 1 , 16 ) ;vpx_wb_write_literal ( wb , cm -> height - 1 , 16 ) ;}",1508
935,"BUG_IF ( tree_root == NULL ) ;fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ;","if ( tree_root == NULL ) return 0 ;fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ;",1509
936,int err ;sock -> state = SS_UNCONNECTED ;,int err ;if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL ;sock -> state = SS_UNCONNECTED ;,1510
937,"VTermState * state = vterm_allocator_malloc ( vt , sizeof ( VTermState ) ) ;state -> vt = vt ;","VTermState * state = vterm_allocator_malloc ( vt , sizeof ( VTermState ) ) ;if ( state == NULL ) return NULL ;state -> vt = vt ;",1511
938,"static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res )  {","static int _nfs4_do_open ( struct inode * dir , struct path * path , fmode_t fmode , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res ) {",1512
939,"if ( path -> dentry -> d_inode != NULL )  nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , flags & ( FMODE_READ | FMODE_WRITE ) ) ;status = - ENOMEM ;opendata = nfs4_opendata_alloc ( path , sp , flags , sattr ) ;if ( opendata == NULL ) goto err_put_state_owner ;","if ( path -> dentry -> d_inode != NULL ) nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , fmode ) ;status = - ENOMEM ;opendata = nfs4_opendata_alloc ( path , sp , fmode , flags , sattr ) ;if ( opendata == NULL ) goto err_put_state_owner ;",1512
940,commonlen = COMPUTESIZE ( state . num ) ;query = ( QUERYTYPE * ) palloc ( commonlen ) ;,"if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ;commonlen = COMPUTESIZE ( state . num ) ;query = ( QUERYTYPE * ) palloc ( commonlen ) ;",1513
941,"while ( tmp && alen < tmp ) {ND_PRINT ( ( ndo , ""\\\","while ( tmp && alen < tmp ) {ND_TCHECK2 ( * tptr , alen ) ;ND_PRINT ( ( ndo , ""\\\",1514
942,libettercap_init ( ) ;ef_globals_alloc ( ) ;,int ret_value = 0 ;libettercap_init ( ) ;ef_globals_alloc ( ) ;,1515
943,"if ( write_output ( ) != E_SUCCESS )  FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ;","ret_value = write_output ( ) != E_SUCCESS ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ;",1515
944,"printf ( ""Boot<S2SV_blank>sector<S2SV_blank>contents:\\\if ( ! atari_format ) {char id [ 9 ] ;strncpy ( id , ( const char * ) b -> system_id , 8 ) ;id [ 8 ] = 0 ;printf ( ""System<S2SV_blank>ID<S2SV_blank>\\\\""%s\\\\""\\\}else {printf ( ""Serial<S2SV_blank>number<S2SV_blank>0x%x\\\}printf ( ""Media<S2SV_blank>byte<S2SV_blank>0x%02x<S2SV_blank>(%s)\\\printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>logical<S2SV_blank>sector\\\printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>cluster\\\printf ( ""%10d<S2SV_blank>reserved<S2SV_blank>sector%s\\\printf ( ""First<S2SV_blank>FAT<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\printf ( ""%10d<S2SV_blank>FATs,<S2SV_blank>%d<S2SV_blank>bit<S2SV_blank>entries\\\printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\\if ( ! fs -> root_cluster ) {","printf ( ""%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\\if ( ! fs -> root_cluster ) {",1516
945,"static void update_stats ( VP9_COMP * cpi ) {VP9_COMMON * const cm = & cpi -> common ;const MACROBLOCK * const x = & cpi -> mb ;if ( ! frame_is_intra_only ( cm ) ) {const int seg_ref_active = vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id ,  SEG_LVL_REF_FRAME ) ;FRAME_COUNTS * const counts = & cm -> counts ;const int inter_block = is_inter_block ( mbmi ) ;","static void update_stats ( VP9_COMMON * cm , ThreadData * td ) {const MACROBLOCK * x = & td -> mb ;const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ;const BLOCK_SIZE bsize = mbmi -> sb_type ;if ( ! frame_is_intra_only ( cm ) ) {FRAME_COUNTS * const counts = td -> counts ;const int inter_block = is_inter_block ( mbmi ) ;const int seg_ref_active = segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_REF_FRAME ) ;",1517
946,}},"if ( inter_block && ! segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) {const int mode_ctx = mbmi_ext -> mode_context [ mbmi -> ref_frame [ 0 ] ] ;if ( bsize >= BLOCK_8X8 ) {const PREDICTION_MODE mode = mbmi -> mode ;++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ;}else {const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ;const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ;int idx , idy ;for ( idy = 0 ;idy < 2 ;idy += num_4x4_h ) {for ( idx = 0 ;idx < 2 ;idx += num_4x4_w ) {const int j = idy * 2 + idx ;const PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ;++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( b_mode ) ] ;}}}}}}",1517
947,"attach_shadowed ( mnt , parent , shadows ) ;touch_mnt_namespace ( n ) ;","n -> mounts += n -> pending_mounts ;n -> pending_mounts = 0 ;attach_shadowed ( mnt , parent , shadows ) ;touch_mnt_namespace ( n ) ;",1518
948,"const char * errstr ;if ( ( pw = getpwnam ( s ) ) != NULL ) {# else  sscanf ( s , ""%d"" , uid ) ;# endif  if ( errstr ) return - 1 ;return 0 ;}","# if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) const char * errstr = NULL ;# else int status ;# endif if ( ( pw = getpwnam ( s ) ) != NULL ) {if ( errstr ) return - 1 ;# else status = sscanf ( s , ""%d"" , uid ) ;if ( status != 1 ) return - 1 ;# endif return 0 ;}",1519
949,"SkipRGBMipmaps ( image , dds_info , 3 ) ;return MagickTrue ;","return ( SkipRGBMipmaps ( image , dds_info , 3 , exception ) ) ;",1520
950,"void vp9_fht8x8_sse2 ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {case DCT_DCT :  vp9_fdct8x8_sse2 ( input , output , stride ) ;break ;","void vp9_fht8x8_sse2 ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {case DCT_DCT : vpx_fdct8x8_sse2 ( input , output , stride ) ;break ;",1521
951,"
","if ( c16 -> Curves [ i ] == NULL ) {for ( j = 0 ;j < i ;j ++ ) {_cmsFree ( ContextID , c16 -> Curves [ j ] ) ;}_cmsFree ( ContextID , c16 -> Curves ) ;_cmsFree ( ContextID , c16 ) ;return NULL ;}",1522
952,"c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;if ( nElements == 256 ) {","c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;if ( nElements == 256 ) {",1522
953,"if ( osStrlen ( topicName ) == 2 && strchr ( topicName , '#' ) == NULL &&   strchr ( topicName , '+' ) == NULL )  {","if ( osStrlen ( topicName ) == 2 && osStrchr ( topicName , '#' ) == NULL && osStrchr ( topicName , '+' ) == NULL ) {",1523
954,"len = min_t ( unsigned int , len , sizeof ( sec ) ) ;if ( copy_to_user ( optval , ( char * ) & sec , len ) ) err = - EFAULT ;","sec . key_size = 0 ;len = min_t ( unsigned int , len , sizeof ( sec ) ) ;if ( copy_to_user ( optval , ( char * ) & sec , len ) ) err = - EFAULT ;",1524
955,"if ( ! data )   return 0 ;memset ( op , '\\\\0' , sizeof ( RAnalOp ) ) ;","if ( ! data || len < 2 ) {return 0 ;}memset ( op , '\\\\0' , sizeof ( RAnalOp ) ) ;",1525
956,"void show_object_with_name ( FILE * out , struct object * obj ,  struct strbuf * path , const char * component )  {fputc ( \'\\\free ( name ) ;}","void show_object_with_name ( FILE * out , struct object * obj , const char * component ) {}",1526
957,"int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {","int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {",1527
958,int max_bytes_matched = input_size ;input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;,int max_bytes_matched ;max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size ;input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;,1527
959,"void vp9_rc_init ( const VP9_CONFIG * oxcf , int pass , RATE_CONTROL * rc ) {if ( pass == 0 && oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) {rc -> avg_frame_qindex [ 0 ] = oxcf -> worst_allowed_q ;rc -> avg_frame_qindex [ 1 ] = oxcf -> worst_allowed_q ;rc -> avg_frame_qindex [ 2 ] = oxcf -> worst_allowed_q ;else {rc -> avg_frame_qindex [ 0 ] = ( oxcf -> worst_allowed_q +  oxcf -> best_allowed_q ) / 2 ;rc -> avg_frame_qindex [ 1 ] = ( oxcf -> worst_allowed_q +  oxcf -> best_allowed_q ) / 2 ;rc -> avg_frame_qindex [ 2 ] = ( oxcf -> worst_allowed_q +  oxcf -> best_allowed_q ) / 2 ;}rc -> last_q [ 0 ] = oxcf -> best_allowed_q ;rc -> last_q [ 1 ] = oxcf -> best_allowed_q ;","void vp9_rc_init ( const VP9EncoderConfig * oxcf , int pass , RATE_CONTROL * rc ) {int i ;if ( pass == 0 && oxcf -> rc_mode == VPX_CBR ) {rc -> avg_frame_qindex [ KEY_FRAME ] = oxcf -> worst_allowed_q ;rc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ;rc -> avg_frame_qindex [ KEY_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ;rc -> avg_frame_qindex [ 1 ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ;rc -> avg_frame_qindex [ INTER_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ;rc -> last_q [ 0 ] = oxcf -> best_allowed_q ;rc -> last_q [ 1 ] = oxcf -> best_allowed_q ;",1528
960,char * typespec = 0 ;unsigned char doc_stack [ DOC_STACK_SIZE ] ;size_t doc_stack_pointer = 0 ;size_t array_index = 0 ;unsigned int array_index_stack [ ARRAY_INDEX_STACK_SIZE ] ;size_t array_index_stack_pointer = 0 ;,size_t array_index_stack [ ARRAY_INDEX_STACK_SIZE ] ;size_t array_index_stack_pointer = 0 ;,1529
961,"index_session_authenticated = SSL_SESSION_get_ex_new_index ( 0 ,  ""session<S2SV_blank>authenticated"" , NULL , NULL , NULL ) ;index_session_connect_address = SSL_SESSION_get_ex_new_index ( 0 , ""session<S2SV_blank>connect<S2SV_blank>address"" , NULL , cb_dup_addr , cb_free_addr ) ;","index_session_authenticated = SSL_SESSION_get_ex_new_index ( 0 , ""session<S2SV_blank>authenticated"" , cb_new_auth , NULL , NULL ) ;index_session_connect_address = SSL_SESSION_get_ex_new_index ( 0 , ""session<S2SV_blank>connect<S2SV_blank>address"" , NULL , cb_dup_addr , cb_free_addr ) ;",1530
962,"LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ;for ( ++ x ;","LINE_OP ( output [ x ] , inverse_db_table [ y & 255 ] ) ;for ( ++ x ;",1531
963,"LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ;}","LINE_OP ( output [ x ] , inverse_db_table [ y & 255 ] ) ;}",1531
964,"static MB_PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , vp9_reader * r ,  int ctx ) {const int mode = vp9_read_tree ( r , vp9_inter_mode_tree ,   cm -> fc . inter_mode_probs [ ctx ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ cm -> counts . inter_mode [ ctx ] [ mode ] ;","static PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , MACROBLOCKD * xd , vpx_reader * r , int ctx ) {const int mode = vpx_read_tree ( r , vp9_inter_mode_tree , cm -> fc -> inter_mode_probs [ ctx ] ) ;FRAME_COUNTS * counts = xd -> counts ;if ( counts ) ++ counts -> inter_mode [ ctx ] [ mode ] ;",1532
965,"if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )   return - ENOMEM ;if ( info -> count < 1 ) return - EINVAL ;down_write ( & card -> controls_rwsem ) ;_kctl = snd_ctl_find_id ( card , & info -> id ) ;err = 0 ;if ( _kctl ) {if ( replace ) err = snd_ctl_remove ( card , _kctl ) ;else err = - EBUSY ;}else {if ( replace ) err = - ENOENT ;up_write ( & card -> controls_rwsem ) ;if ( err < 0 ) return err ;","if ( info -> count < 1 ) return - EINVAL ;if ( replace ) {err = snd_ctl_remove_user_ctl ( file , & info -> id ) ;if ( err ) return err ;if ( card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ;",1533
966,"static void optimize_b ( int plane , int block , BLOCK_SIZE plane_bsize ,   TX_SIZE tx_size , MACROBLOCK * mb ,  ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) {struct macroblock_plane * p = & mb -> plane [ plane ] ;struct macroblockd_plane * pd = & xd -> plane [ plane ] ;const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ;unsigned best_index [ 1025 ] [ 2 ] ;const int16_t * coeff = BLOCK_OFFSET ( mb -> plane [ plane ] . coeff , block ) ;int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;int16_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;int eob = p -> eobs [ block ] , final_eob , sz = 0 ;const int i0 = 0 ;int rc , x , next , i ;int64_t rdmult , rddiv , rd_cost0 , rd_cost1 ;int rate0 , rate1 , error0 , error1 , t0 , t1 ;int best , band , pt ;PLANE_TYPE type = pd -> plane_type ;int err_mult = plane_rd_mult [ type ] ;uint8_t token_cache [ 1024 ] ;const int16_t * dequant_ptr = pd -> dequant ;const uint8_t * const band_translate = get_band_translate ( tx_size ) ;const int16_t * scan = so -> scan ;const int16_t * nb = so -> neighbors ;assert ( ( ! type && ! plane ) || ( type && plane ) ) ;rdmult = mb -> rdmult * err_mult ;if ( ! is_inter_block ( & mb -> e_mbd . mi [ 0 ] -> mbmi ) )  rdmult = ( rdmult * 9 ) >> 4 ;rddiv = mb -> rddiv ;tokens [ eob ] [ 0 ] . rate = 0 ;tokens [ eob ] [ 0 ] . next = default_eob ;tokens [ eob ] [ 0 ] . token = EOB_TOKEN ;tokens [ eob ] [ 0 ] . qc = 0 ;* ( tokens [ eob ] + 1 ) = * ( tokens [ eob ] + 0 ) ;next = eob ;i ++ )  token_cache [ scan [ i ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [   qcoeff [ scan [ i ] ] ] . token ] ;for ( i = eob ;i -- > i0 ;int base_bits , d2 , dx ;rc = scan [ i ] ;x = qcoeff [ rc ] ;if ( x ) {rate1 = tokens [ next ] [ 1 ] . rate ;t0 = ( vp9_dct_value_tokens_ptr + x ) -> token ;if ( next < default_eob ) {","static int optimize_b ( MACROBLOCK * mb , int plane , int block , TX_SIZE tx_size , MACROBLOCK * mb , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) {struct macroblock_plane * const p = & mb -> plane [ plane ] ;struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ;uint8_t token_cache [ 1024 ] ;const tran_low_t * const coeff = BLOCK_OFFSET ( mb -> plane [ plane ] . coeff , block ) ;tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;const int eob = p -> eobs [ block ] ;const PLANE_TYPE type = pd -> plane_type ;int err_mult = plane_rd_mult [ type ] ;uint8_t token_cache [ 1024 ] ;const int16_t * dequant_ptr = pd -> dequant ;const uint8_t * const band_translate = get_band_translate ( tx_size ) ;const int16_t * const scan = so -> scan ;const int16_t * const nb = so -> neighbors ;int next = eob , sz = 0 ;int64_t rdmult = mb -> rdmult * plane_rd_mult [ type ] , rddiv = mb -> rddiv ;int64_t rd_cost0 , rd_cost1 ;int rate0 , rate1 , error0 , error1 ;int16_t t0 , t1 ;EXTRABIT e0 ;int best , band , pt , i , final_eob ;# if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ;# endif assert ( ( ! type && ! plane ) || ( type && plane ) ) ;if ( ! is_inter_block ( & mb -> e_mbd . mi [ 0 ] -> mbmi ) ) rdmult = ( rdmult * 9 ) >> 4 ;tokens [ eob ] [ 0 ] . rate = 0 ;tokens [ eob ] [ 1 ] = tokens [ eob ] [ 0 ] . token = EOB_TOKEN ;tokens [ eob ] [ 0 ] ;i ++ ) token_cache [ scan [ i ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ qcoeff [ scan [ i ] ] ] . token ] ;for ( i = eob ;i -- > 0 ;int base_bits , d2 , dx ;const int rc = scan [ i ] ;int x = qcoeff [ rc ] ;if ( x ) {vp9_get_token_extra ( x , & t0 , & e0 ) ;if ( next < default_eob ) {",1534
967,base_bits = * ( vp9_dct_value_cost_ptr + x ) ;dx = mul * ( dqcoeff [ rc ] - coeff [ rc ] ) ;d2 = dx * dx ;,"base_bits = vp9_get_cost ( t0 , e0 , cat6_high_cost ) ;dx = mul * ( dqcoeff [ rc ] - coeff [ rc ] ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {dx >>= xd -> bd - 8 ;}# endif d2 = dx * dx ;",1534
968,}t0 = t1 = ( vp9_dct_value_tokens_ptr + x ) -> token ;},"e0 = 0 ;}vp9_get_token_extra ( x , & t0 , & e0 ) ;t1 = t0 ;}",1534
969,base_bits = * ( vp9_dct_value_cost_ptr + x ) ;if ( shortcut ) {dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ;d2 = dx * dx ;,"base_bits = vp9_get_cost ( t0 , e0 , cat6_high_cost ) ;if ( shortcut ) {# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {dx -= ( ( dequant_ptr [ rc != 0 ] >> ( xd -> bd - 8 ) ) + sz ) ^ sz ;}else {dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ;}# else dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ;# endif d2 = dx * dx ;",1534
970,"t0 = tokens [ next ] [ 0 ] . token ;t1 = tokens [ next ] [ 1 ] . token ;if ( t0 != EOB_TOKEN ) {tokens [ next ] [ 0 ] . rate += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 1 ] [ 0 ] [ t0 ] ;tokens [ next ] [ 0 ] . token = ZERO_TOKEN ;}if ( t1 != EOB_TOKEN ) {tokens [ next ] [ 1 ] . rate += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 1 ] [ 0 ] [ t1 ] ;tokens [ next ] [ 1 ] . token = ZERO_TOKEN ;}best_index [ i ] [ 0 ] = best_index [ i ] [ 1 ] = 0 ;}}band = band_translate [ i + 1 ] ;pt = combine_entropy_contexts ( * a , * l ) ;rate0 = tokens [ next ] [ 0 ] . rate ;rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t0 ] ;rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t1 ] ;UPDATE_RD_COST ( ) ;final_eob = i0 - 1 ;vpx_memset ( qcoeff , 0 , sizeof ( * qcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ;vpx_memset ( dqcoeff , 0 , sizeof ( * dqcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ;for ( i = next ;x = tokens [ i ] [ best ] . qc ;if ( x ) {final_eob = i ;rc = scan [ i ] ;qcoeff [ rc ] = x ;* a = * l = ( final_eob > 0 ) ;}","rate0 = tokens [ next ] [ 0 ] . rate ;rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t0 ] ;rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t1 ] ;UPDATE_RD_COST ( ) ;final_eob = i0 - 1 ;vpx_memset ( qcoeff , 0 , sizeof ( * qcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ;vpx_memset ( dqcoeff , 0 , sizeof ( * dqcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ;for ( i = next ;const int x = tokens [ i ] [ best ] . qc ;const int rc = scan [ i ] ;if ( x ) {final_eob = i ;qcoeff [ rc ] = x ;return final_eob ;}",1534
971,"int vp9_decode_block_tokens ( VP9_COMMON * cm , MACROBLOCKD * xd ,   int plane , int block , BLOCK_SIZE plane_bsize ,   int x , int y , TX_SIZE tx_size , vp9_reader * r ) {struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;const int ctx = get_entropy_context ( tx_size , pd -> above_context + x , pd -> left_context + y ) ;const scan_order * so = get_scan ( xd , tx_size , pd -> plane_type , block ) ;const int eob = decode_coefs ( cm , xd , pd -> plane_type ,   BLOCK_OFFSET ( pd -> dqcoeff , block ) , tx_size ,   pd -> dequant , ctx , so -> scan , so -> neighbors , r ) ;vp9_set_contexts ( xd , pd , plane_bsize , tx_size , eob > 0 , x , y ) ;return eob ;","int vp9_decode_block_tokens ( MACROBLOCKD * xd , int plane , int block , BLOCK_SIZE plane_bsize , int x , int y , TX_SIZE tx_size , vpx_reader * r , int seg_id ) {struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;const int16_t * const dequant = pd -> seg_dequant [ seg_id ] ;const int ctx = get_entropy_context ( tx_size , pd -> above_context + x , pd -> left_context + y ) ;const int eob = decode_coefs ( cm , xd , pd -> plane_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , tx_size , pd -> dequant , ctx , sc -> scan , so -> neighbors , r ) ;dec_set_contexts ( xd , pd , plane_bsize , tx_size , eob > 0 , x , y ) ;return eob ;",1535
972,free_called += 1 ;free ( ptr ) ;,free_called = 1 ;free ( ptr ) ;,1536
973,goto chpwfail ;},goto bailout ;},1537
974,goto chpwfail ;}goto chpwfail ;}goto chpwfail ;},goto bailout ;}goto bailout ;}goto bailout ;},1537
975,"goto err_free_mem ;}buf [ BUF_SIZE - 1 ] = \'\\\\0\' ;dev_info ( s -> dev , ""Board<S2SV_blank>ID:<S2SV_blank>%02x\\\dev_info ( s -> dev , ""Firmware<S2SV_blank>version:<S2SV_blank>%s\\\s -> vb_queue . type = V4L2_BUF_TYPE_SDR_CAPTURE ;s -> vb_queue . io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ ;s -> vb_queue . drv_priv = s ;s -> vb_queue . buf_struct_size = sizeof ( struct airspy_frame_buf ) ;s -> vb_queue . ops = & airspy_vb2_ops ;s -> vb_queue . mem_ops = & vb2_vmalloc_memops ;s -> vb_queue . timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ;ret = vb2_queue_init ( & s -> vb_queue ) ;if ( ret ) {dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>vb2<S2SV_blank>queue\\\goto err_free_mem ;}s -> vdev = airspy_template ;s -> vdev . queue = & s -> vb_queue ;s -> vdev . queue -> lock = & s -> vb_queue_lock ;video_set_drvdata ( & s -> vdev , s ) ;s -> v4l2_dev . release = airspy_video_release ;ret = v4l2_device_register ( & intf -> dev , & s -> v4l2_dev ) ;if ( ret ) {dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>v4l2-device<S2SV_blank>(%d)\\\goto err_free_mem ;}v4l2_ctrl_handler_init ( & s -> hdl , 5 ) ;s -> lna_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN_AUTO , 0 , 1 , 1 , 0 ) ;s -> lna_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN , 0 , 14 , 1 , 8 ) ;v4l2_ctrl_auto_cluster ( 2 , & s -> lna_gain_auto , 0 , false ) ;s -> mixer_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO , 0 , 1 , 1 , 0 ) ;s -> mixer_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN , 0 , 15 , 1 , 8 ) ;v4l2_ctrl_auto_cluster ( 2 , & s -> mixer_gain_auto , 0 , false ) ;s -> if_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_IF_GAIN , 0 , 15 , 1 , 0 ) ;if ( s -> hdl . error ) {ret = s -> hdl . error ;dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>controls\\\v4l2_ctrl_handler_setup ( & s -> hdl ) ;s -> v4l2_dev . ctrl_handler = & s -> hdl ;s -> vdev . v4l2_dev = & s -> v4l2_dev ;s -> vdev . lock = & s -> v4l2_lock ;ret = video_register_device ( & s -> vdev , VFL_TYPE_SDR , - 1 ) ;if ( ret ) {dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\\goto err_unregister_v4l2_dev ;}err_unregister_v4l2_dev :  v4l2_device_unregister ( & s -> v4l2_dev ) ;",err_unregister_v4l2_dev : v4l2_device_unregister ( & s -> v4l2_dev ) ;,1538
976,"if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;status = AcquireImageColormap ( image , image -> colors , exception ) ;if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {unsigned char * viff_colormap ;switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;break ;case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}image -> colors = viff_info . map_columns ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;lsb_first = 1 ;if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : {MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}default : break ;}for ( i = 0 ;i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;i ++ ) {switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;break ;default : value = 1.0 * viff_colormap [ i ] ;break ;}if ( i < ( ssize_t ) image -> colors ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ;image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;switch ( ( int ) viff_info . data_storage_type ) {case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}if ( viff_info . data_storage_type == VFF_TYP_BIT )  max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ;else  max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ;pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ;","if ( viff_info . data_storage_type == VFF_TYP_BIT ) {if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ;else max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ;pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ;",1539
977,# endif  # if HAVA_LZMA_H && HAVE_LIBLZMA  if ( zip -> zipx_lzma_valid ) {,# endif # if HAVE_LZMA_H && HAVE_LIBLZMA if ( zip -> zipx_lzma_valid ) {,1540
978,"mcryptd_check_internal ( tb , & type , & mask ) ;halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ;","if ( ! mcryptd_check_internal ( tb , & type , & mask ) ) return - EINVAL ;halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ;",1541
979,"static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up )  {","static TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , struct tee_ta_param * p , struct utee_params * up ) {",1542
980,"switch ( TEE_PARAM_TYPE_GET ( types , n ) ) {case TEE_PARAM_TYPE_MEMREF_INPUT :  case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : p -> u [ n ] . mem . mobj = & mobj_virt ;break ;case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ;}}","uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ;switch ( TEE_PARAM_TYPE_GET ( types , n ) ) {case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ;case TEE_PARAM_TYPE_MEMREF_INPUT : p -> u [ n ] . mem . mobj = & mobj_virt ;if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ;break ;case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ;}return TEE_SUCCESS ;}",1542
981,"mcryptd_check_internal ( tb , & type , & mask ) ;halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ;","if ( ! mcryptd_check_internal ( tb , & type , & mask ) ) return - EINVAL ;halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ;",1543
982,"void fdct8_sse2 ( __m128i * in ) {const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;","static void fdct8_sse2 ( __m128i * in ) {const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;",1544
983,"if ( output )   strcpy ( output , ( const char * ) output_u8 ) ;free ( output_u8 ) ;","size_t len = strlen ( ( char * ) output_u8 ) ;if ( len > 63 ) {free ( output_u8 ) ;return IDN2_TOO_BIG_DOMAIN ;}if ( output ) strcpy ( output , ( char * ) output_u8 ) ;free ( output_u8 ) ;",1545
984,if ( ! unconditional ( & e -> ip ) )  return false ;,if ( ! unconditional ( e ) ) return false ;,1546
985,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;if ( error == 0 )  acl = NULL ;}","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( error < 0 ) return error ;",1547
986,"if ( key_is_instantiated ( keyring ) ) {if ( keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf ( m , "":<S2SV_blank>%lu"" , keyring -> keys . nr_leaves_on_tree ) ;","if ( key_is_positive ( keyring ) ) {if ( keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf ( m , "":<S2SV_blank>%lu"" , keyring -> keys . nr_leaves_on_tree ) ;",1548
987,"int isopen ;char * s ;size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ;poly = ( POLYGON * ) palloc0 ( size ) ;","int base_size ;int isopen ;char * s ;base_size = sizeof ( poly -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) ;poly = ( POLYGON * ) palloc0 ( size ) ;",1549
988,"void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride )  {nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ;if ( context -> ChromaSubsamplingLevel ) {nsc_encode_subsampling ( context ) ;}","BOOL nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) {if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ;if ( ! nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ) return FALSE ;if ( context -> ChromaSubsamplingLevel ) {if ( ! nsc_encode_subsampling ( context ) ) return FALSE ;}return TRUE ;",1550
989,* ( * fill ) ++ = suffix [ code ] ;firstchar = oldcode = code ;,"if ( code >= clear ) {fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\\return 0 ;}* ( * fill ) ++ = suffix [ code ] ;firstchar = oldcode = code ;",1551
990,"zip_error_set ( error , ZIP_ER_INTERNAL , 0 ) ;if ( ! from_buffer ) {_zip_buffer_free ( buffer ) ;}","
",1552
991,if ( ! from_buffer ) {_zip_buffer_free ( buffer ) ;,if ( ! from_buffer ) {_zip_buffer_free ( buffer ) ;,1552
992,char added ;},},1553
993,"separator = strchr ( context -> buffer , \':\' ) ;if ( separator ) {","separator = osStrchr ( context -> buffer , \':\' ) ;if ( separator ) {",1554
994,"if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) {return MSPACK_ERR_SEEK ;}}num_chunks = chm -> last_pmgl - x + 1 ;if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) {return MSPACK_ERR_NOMEMORY ;errors = 0 ;while ( num_chunks -- ) {if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) {sys -> free ( chunk ) ;return MSPACK_ERR_READ ;if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ;if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) {sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small"" ) ;if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) {sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ;}p = & chunk [ pmgl_Entries ] ;end = & chunk [ chm -> chunk_size - 2 ] ;num_entries = EndGetI16 ( end ) ;while ( num_entries -- ) {READ_ENCINT ( name_len ) ;if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ;name = p ;p += name_len ;READ_ENCINT ( section ) ;READ_ENCINT ( offset ) ;READ_ENCINT ( length ) ;if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ;if ( ( offset == 0 ) && ( length == 0 ) ) {if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == \'/\' ) ) continue ;}if ( section > 1 ) {sys -> message ( fh , ""invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\\\'%u\\\'."" , section ) ;continue ;}if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) {sys -> free ( chunk ) ;return MSPACK_ERR_NOMEMORY ;}fi -> next = NULL ;fi -> filename = ( char * ) & fi [ 1 ] ;fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ;fi -> offset = offset ;fi -> length = length ;sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ;fi -> filename [ name_len ] = \'\\\\0\' ;if ( name [ 0 ] == \':\' && name [ 1 ] == \':\' ) {if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) {if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . content = fi ;}else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) {chm -> sec1 . control = fi ;}else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . spaninfo = fi ;}}}","if ( name_len == 40 && memcmp ( name , content_name , 40 ) == 0 ) {if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . content = fi ;else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) {chm -> sec1 . control = fi ;else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . spaninfo = fi ;}}",1555
995,"void generate_filename ( const char * pattern , char * out , size_t q_len ,  unsigned int d_w , unsigned int d_h , unsigned int frame_in ) {","static void generate_filename ( const char * pattern , char * out , size_t q_len , unsigned int d_w , unsigned int d_h , unsigned int frame_in ) {",1556
996,}pat_len = strlen ( q ) ;,break ;}pat_len = strlen ( q ) ;,1556
997,"if ( args -> skip )  return ;if ( ! is_inter_block ( mbmi ) )   vp9_encode_block_intra ( x , plane , block , plane_bsize , tx_size , & mbmi -> skip ) ;else vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;dist_block ( plane , block , tx_size , args ) ;rate_block ( plane , block , plane_bsize , tx_size , args ) ;rd1 = RDCOST ( x -> rdmult , x -> rddiv , args -> rate , args -> dist ) ;rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , args -> sse ) ;rd = MIN ( rd1 , rd2 ) ;args -> this_rate += args -> rate ;args -> this_dist += args -> dist ;args -> this_sse += args -> sse ;args -> this_rd += rd ;args -> skip = 1 ;return ;}","int rate ;int64_t dist ;int64_t sse ;if ( args -> exit_early ) return ;if ( ! is_inter_block ( mbmi ) ) {struct encode_b_args arg = {x , NULL , & mbmi -> skip };vp9_encode_block_intra ( plane , block , plane_bsize , tx_size , & arg ) ;dist_block ( x , plane , block , tx_size , & dist , & sse ) ;}else if ( max_txsize_lookup [ plane_bsize ] == tx_size ) {if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_NONE ) {vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;dist_block ( x , plane , block , tx_size , & dist , & sse ) ;}else if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_AC_ONLY ) {tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ plane ] . coeff , block ) ;tran_low_t * const dqcoeff = BLOCK_OFFSET ( xd -> plane [ plane ] . dqcoeff , block ) ;vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ;sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ;dist = sse ;if ( x -> plane [ plane ] . eobs [ block ] ) {const int64_t orig_sse = ( int64_t ) coeff [ 0 ] * coeff [ 0 ] ;const int64_t resd_sse = coeff [ 0 ] - dqcoeff [ 0 ] ;int64_t dc_correct = orig_sse - resd_sse * resd_sse ;# if CONFIG_VP9_HIGHBITDEPTH dc_correct >>= ( ( xd -> bd - 8 ) * 2 ) ;# endif if ( tx_size != TX_32X32 ) dc_correct >>= 2 ;dist = MAX ( 0 , sse - dc_correct ) ;}}else {x -> plane [ plane ] . eobs [ block ] = 0 ;sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ;dist = sse ;}}else {vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;dist_block ( x , plane , block , tx_size , & dist , & sse ) ;}rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ;if ( args -> this_rd + rd > args -> best_rd ) {args -> exit_early = 1 ;return ;}rate = rate_block ( plane , block , plane_bsize , tx_size , args ) ;rd1 = RDCOST ( x -> rdmult , x -> rddiv , args -> rate , args -> dist ) ;rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , sse ) ;rd = MIN ( rd1 , rd2 ) ;args -> this_rate += rate ;args -> this_dist += args -> dist ;args -> this_sse += sse ;args -> this_rd += rd ;args -> exit_early = 1 ;return ;}args -> skippable &= ! x -> plane [ plane ] . eobs [ block ] ;",1557
998,"if ( layer_info == ( LayerInfo * ) NULL ) {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>LayerInfo<S2SV_blank>failed"" ) ;ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;}( void ) ResetMagickMemory ( layer_info , 0 , ( size_t ) number_layers * sizeof ( * layer_info ) ) ;for ( i = 0 ;i < number_layers ;i ++ ) {ssize_t x , y ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>layer<S2SV_blank>#%.20g"" , ( double ) i + 1 ) ;layer_info [ i ] . page . y = ReadBlobSignedLong ( image ) ;layer_info [ i ] . page . x = ReadBlobSignedLong ( image ) ;y = ReadBlobSignedLong ( image ) ;x = ReadBlobSignedLong ( image ) ;layer_info [ i ] . page . width = ( size_t ) ( x - layer_info [ i ] . page . x ) ;layer_info [ i ] . page . height = ( size_t ) ( y - layer_info [ i ] . page . y ) ;layer_info [ i ] . channels = ReadBlobShort ( image ) ;if ( layer_info [ i ] . channels > MaxPSDChannels ) {layer_info = DestroyLayerInfo ( layer_info , number_layers ) ;ThrowBinaryException ( CorruptImageError , ""MaximumChannelsExceeded"" , image -> filename ) ;}if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>channels=%.20g"" , ( double ) layer_info [ i ] . page . x , ( double ) layer_info [ i ] . page . y , ( double ) layer_info [ i ] . page . height , ( double ) layer_info [ i ] . page . width , ( double ) layer_info [ i ] . channels ) ;for ( j = 0 ;j < ( ssize_t ) layer_info [ i ] . channels ;j ++ ) {layer_info [ i ] . channel_info [ j ] . type = ( short ) ReadBlobShort ( image ) ;layer_info [ i ] . channel_info [ j ] . size = ( size_t ) GetPSDSize ( psd_info , image ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>channel[%.20g]:<S2SV_blank>type=%.20g,<S2SV_blank>size=%.20g"" , ( double ) j , ( double ) layer_info [ i ] . channel_info [ j ] . type , ( double ) layer_info [ i ] . channel_info [ j ] . size ) ;}count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ;ReversePSDString ( image , type , 4 ) ;if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>layer<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%.4s<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>8BIM"" , type ) ;layer_info = DestroyLayerInfo ( layer_info , number_layers ) ;ThrowBinaryException ( CorruptImageError , ""ImproperImageHeader"" , image -> filename ) ;}count = ReadBlob ( image , 4 , ( unsigned char * ) layer_info [ i ] . blendkey ) ;ReversePSDString ( image , layer_info [ i ] . blendkey , 4 ) ;layer_info [ i ] . opacity = ( Quantum ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;layer_info [ i ] . clipping = ( unsigned char ) ReadBlobByte ( image ) ;layer_info [ i ] . flags = ( unsigned char ) ReadBlobByte ( image ) ;layer_info [ i ] . visible = ! ( layer_info [ i ] . flags & 0x02 ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>blend=%.4s,<S2SV_blank>opacity=%.20g,<S2SV_blank>clipping=%s,<S2SV_blank>flags=%d,<S2SV_blank>visible=%s"" , layer_info [ i ] . blendkey , ( double ) layer_info [ i ] . opacity , layer_info [ i ] . clipping ? ""true"" : ""false"" , layer_info [ i ] . flags , layer_info [ i ] . visible ? ""true"" : ""false"" ) ;( void ) ReadBlobByte ( image ) ;size = ReadBlobLong ( image ) ;if ( size != 0 ) {MagickSizeType combined_length , length ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>contains<S2SV_blank>additional<S2SV_blank>info"" ) ;length = ReadBlobLong ( image ) ;combined_length = length + 4 ;if ( length != 0 ) {layer_info [ i ] . mask . page . y = ReadBlobSignedLong ( image ) ;layer_info [ i ] . mask . page . x = ReadBlobSignedLong ( image ) ;layer_info [ i ] . mask . page . height = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . y ) ;layer_info [ i ] . mask . page . width = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . x ) ;layer_info [ i ] . mask . background = ( unsigned char ) ReadBlobByte ( image ) ;layer_info [ i ] . mask . flags = ( unsigned char ) ReadBlobByte ( image ) ;if ( ! ( layer_info [ i ] . mask . flags & 0x01 ) ) {layer_info [ i ] . mask . page . y = layer_info [ i ] . mask . page . y - layer_info [ i ] . page . y ;layer_info [ i ] . mask . page . x = layer_info [ i ] . mask . page . x - layer_info [ i ] . page . x ;}if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>mask:<S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>length=%.20g"" , ( double ) layer_info [ i ] . mask . page . x , ( double ) layer_info [ i ] . mask . page . y , ( double ) layer_info [ i ] . mask . page . width , ( double ) layer_info [ i ] . mask . page . height , ( double ) ( ( MagickOffsetType ) length ) - 18 ) ;if ( DiscardBlobBytes ( image , ( MagickSizeType ) ( length - 18 ) ) == MagickFalse ) {","if ( DiscardBlobBytes ( image , length ) == MagickFalse ) {",1558
999,"for ( j = 0 ;j += 8 )  {ThrowBinaryException ( CorruptImageError ,  ""InsufficientImageDataInFile"" , image -> filename ) ;}","for ( j = 0 ;j += 8 ) {ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ;}",1558
1000,"u8 * gb_cur , * version_tlv , version , version_length ;u8 * lto_tlv , lto_length ;u8 * wks_tlv , wks_length ;u8 * miux_tlv , miux_length ;gb_len += version_length ;lto_tlv = nfc_llcp_build_tlv ( LLCP_TLV_LTO , & local -> lto , 1 , & lto_length ) ;gb_len += lto_length ;pr_debug ( ""Local<S2SV_blank>wks<S2SV_blank>0x%lx\\\gb_len += wks_length ;miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & local -> miux , 0 ,  & miux_length ) ;gb_len += miux_length ;","u8 * gb_cur , version , version_length ;u8 lto_length , wks_length , miux_length ;u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL ;if ( ! version_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += version_length ;lto_tlv = nfc_llcp_build_tlv ( LLCP_TLV_LTO , & local -> lto , 1 , & lto_length ) ;if ( ! lto_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += lto_length ;pr_debug ( ""Local<S2SV_blank>wks<S2SV_blank>0x%lx\\\if ( ! wks_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += wks_length ;miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & local -> miux , 0 , & miux_length ) ;if ( ! miux_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += miux_length ;",1559
1001,return 0 ;},if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ;return 0 ;},1560
1002,"mrb_value value ;fiber_check_cfunc ( mrb , c ) ;if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>transferred<S2SV_blank>fiber"" ) ;}if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""double<S2SV_blank>resume<S2SV_blank>(fib)"" ) ;}if ( c -> status == MRB_FIBER_TERMINATED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>dead<S2SV_blank>fiber"" ) ;}mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ;c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ;if ( c -> status == MRB_FIBER_CREATED ) {mrb_value * b , * e ;if ( len >= c -> stend - c -> stack ) {mrb_raise ( mrb , E_FIBER_ERROR , ""too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>to<S2SV_blank>fiber"" ) ;}","enum mrb_fiber_state status ;mrb_value value ;fiber_check_cfunc ( mrb , c ) ;status = c -> status ;if ( resume && status == MRB_FIBER_TRANSFERRED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>transferred<S2SV_blank>fiber"" ) ;}if ( status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""double<S2SV_blank>resume<S2SV_blank>(fib)"" ) ;}if ( status == MRB_FIBER_TERMINATED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>dead<S2SV_blank>fiber"" ) ;}old_c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ;c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ;fiber_switch_context ( mrb , c ) ;if ( status == MRB_FIBER_CREATED ) {mrb_value * b , * e ;mrb_stack_extend ( mrb , len + 2 ) ;",1561
1003,"fiber_switch_context ( mrb , c ) ;if ( vmexec ) {",if ( vmexec ) {,1561
1004,uint_t i ;DhcpOption * option ;if ( length < sizeof ( DhcpMessage ) )   return NULL ;length -= sizeof ( DhcpMessage ) ;if ( option -> code == DHCP_OPT_PAD )  continue ;if ( option -> code == DHCP_OPT_END )  break ;if ( ( i + 1 ) >= length || ( i + 1 + option -> length ) >= length )  break ;return NULL ;},size_t i ;DhcpOption * option ;if ( length >= sizeof ( DhcpMessage ) ) return NULL ;length -= sizeof ( DhcpMessage ) ;if ( option -> code == DHCP_OPT_PAD ) {}else if ( option -> code == DHCP_OPT_END ) {break ;}else {if ( ( i + sizeof ( DhcpOption ) + option -> length ) >= length ) break ;}}return NULL ;},1562
1005,"ipv6_select_ident ( fptr ) ;segs = skb_segment ( skb , features ) ;","ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ;segs = skb_segment ( skb , features ) ;",1563
1006,"rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ;rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ;rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ;","rb_define_singleton_method ( klass , ""read_memory"" , read_memory , - 1 ) ;rb_define_singleton_method ( klass , ""from_document"" , from_document , - 1 ) ;rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ;",1564
1007,"status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else if ( image -> storage_class == PseudoClass ) for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}else {number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ;SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ;if ( image -> colors != 0 ) {ssize_t index ;index = ( ssize_t ) GetPixelRed ( image , q ) ;SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red ) , q ) ;index = ( ssize_t ) GetPixelGreen ( image , q ) ;SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green ) , q ) ;index = ( ssize_t ) GetPixelBlue ( image , q ) ;SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue ) , q ) ;}SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ;p ++ ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;count = ReadBlob ( image , 1 , & viff_info . identifier ) ;if ( ( count == 1 ) && ( viff_info . identifier == 0xab ) ) {AcquireNextImage ( image_info , image , exception ) ;if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;}",status = MagickFalse ;,1565
1008,# define MAXLINELEN 80  int i ;int j ;,# define MAXLINELEN 80 jas_matind_t i ;jas_matind_t j ;,1566
1009,"static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len ,  struct iovec * iovec )  {return 0 ;}","static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len , struct iovec * iovec , struct iov_iter * iter ) {if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ;iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;return 0 ;}",1567
1010,if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) )  return ERR_PTR ( - EINVAL ) ;,if ( ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ;if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) return ERR_PTR ( - EINVAL ) ;,1568
1011,void ntlm_print_negotiate_flags ( UINT32 flags )  {,static void ntlm_print_negotiate_flags ( UINT32 flags ) {,1569
1012,"new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ;","new_fname = safe_calloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ;",1570
1013,"# line 496 ""ext/standard/var_unserializer.c""  {","# line 501 ""ext/standard/var_unserializer.c"" {",1571
1014,"yy3 :  # line 861 ""ext/standard/var_unserializer.re""  {# line 558 ""ext/standard/var_unserializer.c""  yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;","yy3 : # line 875 ""ext/standard/var_unserializer.re"" {# line 563 ""ext/standard/var_unserializer.c"" yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;",1571
1015,"# line 855 ""ext/standard/var_unserializer.re""  {# line 607 ""ext/standard/var_unserializer.c""  yy16 : yych = * ++ YYCURSOR ;","# line 869 ""ext/standard/var_unserializer.re"" {# line 612 ""ext/standard/var_unserializer.c"" yy16 : yych = * ++ YYCURSOR ;",1571
1016,"# line 708 ""ext/standard/var_unserializer.re""  {","# line 717 ""ext/standard/var_unserializer.re"" {",1571
1017,"
",if ( elements < 0 ) {efree ( class_name ) ;return 0 ;},1571
1018,"if ( incomplete_class ) {php_store_class_name ( * rval , class_name , len2 ) ;# line 785 ""ext/standard/var_unserializer.c""  yy25 : yych = * ++ YYCURSOR ;","if ( incomplete_class ) {php_store_class_name ( * rval , class_name , len2 ) ;# line 795 ""ext/standard/var_unserializer.c"" yy25 : yych = * ++ YYCURSOR ;",1571
1019,"# line 699 ""ext/standard/var_unserializer.re""  {return object_common2 ( UNSERIALIZE_PASSTHRU ,   object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ;}# line 819 ""ext/standard/var_unserializer.c""  yy32 : yych = * ++ YYCURSOR ;","# line 704 ""ext/standard/var_unserializer.re"" {long elements ;elements = object_common1 ( UNSERIALIZE_PASSTHRU , elements ) ;}# line 819 ""ext/standard/var_unserializer.c"" yy32 : yych = * ++ YYCURSOR ;",1571
1020,"# line 678 ""ext/standard/var_unserializer.re""  {","# line 683 ""ext/standard/var_unserializer.re"" {",1571
1021,"# line 861 ""ext/standard/var_unserializer.c""  yy39 : yych = * ++ YYCURSOR ;","# line 875 ""ext/standard/var_unserializer.c"" yy39 : yych = * ++ YYCURSOR ;",1571
1022,"# line 643 ""ext/standard/var_unserializer.re""  {","# line 648 ""ext/standard/var_unserializer.re"" {",1571
1023,"# line 917 ""ext/standard/var_unserializer.c""  yy46 : yych = * ++ YYCURSOR ;","# line 931 ""ext/standard/var_unserializer.c"" yy46 : yych = * ++ YYCURSOR ;",1571
1024,"# line 610 ""ext/standard/var_unserializer.re""  {","# line 615 ""ext/standard/var_unserializer.re"" {",1571
1025,"# line 971 ""ext/standard/var_unserializer.c""  yy53 : yych = * ++ YYCURSOR ;","# line 985 ""ext/standard/var_unserializer.c"" yy53 : yych = * ++ YYCURSOR ;",1571
1026,"# line 600 ""ext/standard/var_unserializer.re""  {# line 1069 ""ext/standard/var_unserializer.c""  yy65 : yych = * ++ YYCURSOR ;","# line 605 ""ext/standard/var_unserializer.re"" {# line 1083 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ;",1571
1027,"# line 585 ""ext/standard/var_unserializer.re""  {","# line 590 ""ext/standard/var_unserializer.re"" {",1571
1028,"# line 1143 ""ext/standard/var_unserializer.c""  yy76 : yych = * ++ YYCURSOR ;","# line 1157 ""ext/standard/var_unserializer.c"" yy76 : yych = * ++ YYCURSOR ;",1571
1029,"# line 558 ""ext/standard/var_unserializer.re""  {","# line 563 ""ext/standard/var_unserializer.re"" {",1571
1030,"# line 1197 ""ext/standard/var_unserializer.c""  yy83 : yych = * ++ YYCURSOR ;# line 551 ""ext/standard/var_unserializer.re""  {# line 1212 ""ext/standard/var_unserializer.c""  yy87 : ++ YYCURSOR ;# line 544 ""ext/standard/var_unserializer.re""  {# line 1222 ""ext/standard/var_unserializer.c""  yy89 : yych = * ++ YYCURSOR ;","# line 1211 ""ext/standard/var_unserializer.c"" yy83 : yych = * ++ YYCURSOR ;# line 556 ""ext/standard/var_unserializer.re"" {# line 1226 ""ext/standard/var_unserializer.c"" yy87 : ++ YYCURSOR ;# line 549 ""ext/standard/var_unserializer.re"" {# line 1236 ""ext/standard/var_unserializer.c"" yy89 : yych = * ++ YYCURSOR ;",1571
1031,"# line 521 ""ext/standard/var_unserializer.re""  {","# line 526 ""ext/standard/var_unserializer.re"" {",1571
1032,"# line 1268 ""ext/standard/var_unserializer.c""  yy95 : yych = * ++ YYCURSOR ;","# line 1282 ""ext/standard/var_unserializer.c"" yy95 : yych = * ++ YYCURSOR ;",1571
1033,"# line 500 ""ext/standard/var_unserializer.re""  {","# line 505 ""ext/standard/var_unserializer.re"" {",1571
1034,"# line 1312 ""ext/standard/var_unserializer.c""  }# line 863 ""ext/standard/var_unserializer.re""  return 0 ;","# line 1326 ""ext/standard/var_unserializer.c"" }# line 863 ""ext/standard/var_unserializer.re"" return 0 ;",1571
1035,"if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) )  {","if ( TEMP_FAILURE_RETRY ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) ) == sizeof ( cmd ) ) {",1572
1036,* ( * fill ) ++ = suffix [ code ] ;firstchar = oldcode = code ;,"if ( code >= clear ) {fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\\return 0 ;}* ( * fill ) ++ = suffix [ code ] ;firstchar = oldcode = code ;",1573
1037,"msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ;","skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ;",1574
1038,p -> exit_signal = - 1 ;p -> group_leader = current -> group_leader ;if ( clone_flags & CLONE_PARENT )  p -> exit_signal = current -> group_leader -> exit_signal ;else p -> exit_signal = args -> exit_signal ;,p -> group_leader = current -> group_leader ;,1575
1039,}p -> real_parent = current ;}klp_copy_process ( p ) ;,if ( clone_flags & CLONE_THREAD ) p -> exit_signal = - 1 ;else p -> exit_signal = current -> group_leader -> exit_signal ;}p -> real_parent = current ;p -> exit_signal = args -> exit_signal ;}klp_copy_process ( p ) ;,1575
1040,"static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len ,  const u_char * ep , uint32_t phase , uint32_t doi0 _U_ ,   uint32_t proto0 _U_ , int depth )  {","static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) {",1576
1041,"ND_PRINT ( ( ndo , ""<S2SV_blank>orig=("" ) ) ;switch ( ntohs ( n . type ) ) {size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ;while ( cp < ep && cp < ep2 ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;break ;}case IPSECDOI_NTYPE_REPLAY_STATUS :  ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ;break ;case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN : if ( ikev1_sub_print ( ndo , ISAKMP_NPTYPE_SA , ( const struct isakmp_gen * ) cp , ep , phase , doi , proto , depth ) == NULL ) return NULL ;default :  isakmp_print ( ndo , cp ,  item_len - sizeof ( * p ) - n . spi_size , NULL ) ;ND_PRINT ( ( ndo , "")"" ) ) ;}","switch ( ntohs ( n . type ) ) {size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) ) ;ND_PRINT ( ( ndo , "")"" ) ) ;break ;}case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ;ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ;break ;case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN : if ( ikev1_sub_print ( ndo , ISAKMP_NPTYPE_SA , ( const struct isakmp_gen * ) cp , ep , phase , doi , proto , depth ) == NULL ) return NULL ;break ;default : if ( ndo -> ndo_vflag > 3 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ;}else {if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ;if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ;ND_PRINT ( ( ndo , "")"" ) ) ;}",1576
1042,"iframe -> iv = nghttp2_mem_malloc ( mem , sizeof ( nghttp2_settings_entry ) *  iframe -> max_niv ) ;","if ( iframe -> max_niv - 1 > session -> max_settings ) {rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_ENHANCE_YOUR_CALM , ""SETTINGS:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>setting<S2SV_blank>entries"" ) ;if ( nghttp2_is_fatal ( rv ) ) {return rv ;}return ( ssize_t ) inlen ;}iframe -> iv = nghttp2_mem_malloc ( mem , sizeof ( nghttp2_settings_entry ) * iframe -> max_niv ) ;",1577
1043,"if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! xfs_sb_version_hasprojid32bit ( & ip -> i_mount -> m_sb ) ) return XFS_ERROR ( EINVAL ) ;if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & FSX_PROJID ) ) {code = xfs_qm_vop_dqalloc ( ip , ip -> i_d . di_uid , ip -> i_d . di_gid , fa -> fsx_projid , XFS_QMOPT_PQUOTA , & udqp , NULL , & pdqp ) ;if ( code ) return code ;}tp = xfs_trans_alloc ( mp , XFS_TRANS_SETATTR_NOT_SIZE ) ;code = xfs_trans_reserve ( tp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ) ;if ( code ) goto error_return ;lock_flags = XFS_ILOCK_EXCL ;xfs_ilock ( ip , lock_flags ) ;if ( ! inode_owner_or_capable ( VFS_I ( ip ) ) ) {",if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! capable_wrt_inode_uidgid ( VFS_I ( ip ) ) ) {,1578
1044,"if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) &&  ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) )  ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ;","if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ;",1578
1045,"update_open_stateid ( state , & data -> o_res . stateid , NULL ,  data -> o_arg . open_flags ) ;iput ( inode ) ;","update_open_stateid ( state , & data -> o_res . stateid , NULL , data -> o_arg . fmode ) ;iput ( inode ) ;",1579
1046,"# define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\\","# define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\\",1580
1047,"}# define EXIFMultipleFractions ( size , format , arg1 , arg2 ) {","\\\\\# define EXIFMultipleFractions ( size , format , arg1 , arg2 ) \\\\\",1580
1048,}typedef struct _DirectoryInfo {,\\\\\typedef struct _DirectoryInfo {,1580
1049,"
",if ( q > ( exif + length - 12 ) ) break ;,1580
1050,"
",if ( components < 0 ) break ;,1580
1051,"if ( GetValueFromSplayTree ( exif_resources , q ) == q )  break ;components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;number_bytes = ( size_t ) components * tag_bytes [ format ] ;","if ( GetValueFromSplayTree ( exif_resources , q ) == q ) break ;components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;number_bytes = ( size_t ) components * tag_bytes [ format ] ;",1580
1052,if ( ! static_key_enabled ( work -> key ) )  static_key_slow_inc ( work -> key ) ;,BUG_ON ( ! static_key_enabled ( work -> key ) ) ;static_key_slow_dec ( work -> key ) ;,1581
1053,goto errout_locked ;},goto errout_free ;},1582
1054,kfree ( family -> attrbuf ) ;errout_locked : genl_unlock_all ( ) ;,errout_free : kfree ( family -> attrbuf ) ;errout_locked : genl_unlock_all ( ) ;,1582
1055,"memcpy ( & bss_cfg -> wmm_info , wmm_ie +   sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;priv -> wmm_enabled = 1 ;","if ( * ( wmm_ie + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return ;memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;priv -> wmm_enabled = 1 ;",1583
1056,"separator = strchr ( connection -> buffer , '=' ) ;if ( ! separator ) return ERROR_INVALID_TAG ;","separator = osStrchr ( connection -> buffer , '=' ) ;if ( ! separator ) return ERROR_INVALID_TAG ;",1584
1057,* ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ;editpos += 4 ;,* ( buf + insertpos ) = _x2c ( & buf [ editpos + 3 ] ) ;editpos += 4 ;,1585
1058,"if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;else  ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;goto out ;if ( flags == EXT4_GET_BLOCKS_CONVERT ) {ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;","if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) {ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;goto out ;if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) {ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;",1586
1059,"size = urb -> transfer_buffer_length ;if ( usb_pipeout ( urb -> pipe ) ) return 0 ;size = urb -> actual_length ;if ( ! ( size > 0 ) ) return 0 ;ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ;if ( ret != size ) {}usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ;return ret ;}","if ( size > urb -> transfer_buffer_length ) {if ( ud -> side == USBIP_STUB ) {usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ;return 0 ;usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ;return - EPIPE ;}ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ;if ( ret != size ) {}usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ;return ret ;}",1587
1060,net -> dev_base_seq = 1 ;net -> user_ns = user_ns ;,"get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;net -> dev_base_seq = 1 ;net -> user_ns = user_ns ;",1588
1061,"strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ;strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name ,  sizeof ( ualg -> cru_driver_name ) ) ;strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) ,  sizeof ( ualg -> cru_module_name ) ) ;","strncpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ;strncpy ( ualg -> cru_driver_name , alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ) ;strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ;",1589
1062,"strlcpy ( rl . type , ""larval"" , sizeof ( rl . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ;","strncpy ( rl . type , ""larval"" , sizeof ( rl . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ;",1589
1063,"cJSON * c ;ep = 0 ;if ( ! ( c = cJSON_New_Item ( ) ) ) return 0 ;if ( ! parse_value ( c , skip ( value ) ) ) {cJSON_Delete ( c ) ;return 0 ;}return c ;","return cJSON_ParseWithOpts ( value , 0 , 0 ) ;",1590
1064,"
",if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) {return ( - 1 ) ;},1591
1065,unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ;},unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ;},1591
1066,BUG_ON ( direction != ITER_PIPE ) ;i -> type = direction ;,BUG_ON ( direction != ITER_PIPE ) ;WARN_ON ( pipe -> nrbufs == pipe -> buffers ) ;i -> type = direction ;,1592
1067,mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ;mnt -> mnt . mnt_flags = mnt_flags ;,mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ;mnt -> mnt . mnt_flags = mnt_flags ;,1593
1068,"static int fsmVerify ( const char * path , rpmfi fi )  {","static int fsmVerify ( const char * path , rpmfi fi , const struct stat * fsb ) {",1594
1069,"
",uid_t luid = dsb . st_uid ;,1594
1070,"if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;rc = fsmStat ( path , 0 , & dsb ) ;if ( rc == RPMERR_ENOENT ) rc = 0 ;if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;}","if ( S_ISDIR ( dsb . st_mode ) && ( luid == 0 || luid == fsb -> st_uid ) ) return 0 ;rc = fsmStat ( path , 0 , & dsb ) ;if ( rc == RPMERR_ENOENT ) rc = 0 ;if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;}",1594
1071,"# endif _end :  snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;kill_fasync ( & runtime -> fasync , SIGIO , POLL_IN ) ;}","# endif _end : kill_fasync ( & runtime -> fasync , SIGIO , POLL_IN ) ;snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;}",1595
1072,"for ( plane = 0 ;in -> data [ plane ] && plane < 4 ;plane ++ )  hblur ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;for ( plane = 0 ;in -> data [ plane ] && plane < 4 ;plane ++ )  vblur ( out -> data [ plane ] , out -> linesize [ plane ] , out -> data [ plane ] , out -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;","for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;plane ++ ) hblur ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;plane ++ ) vblur ( out -> data [ plane ] , out -> linesize [ plane ] , out -> data [ plane ] , out -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;",1596
1073,"bool valid_handle ;BUG_ON ( client != handle -> client ) ;valid_handle = ion_handle_validate ( client , handle ) ;if ( ! valid_handle ) {return ;}mutex_unlock ( & client -> lock ) ;ion_handle_put ( handle ) ;","BUG_ON ( client != handle -> client ) ;ion_free_nolock ( client , handle ) ;if ( ! valid_handle ) {",1597
1074,WORD16 i2_level_arr [ 16 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,WORD16 ai2_level_arr [ 19 ] ;WORD16 * i2_level_arr = & ai2_level_arr [ 3 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,1598
1075,"print_int ( ""coded_picture_number"" , frame -> coded_picture_number ) ;print_int ( ""display_picture_number"" , frame -> display_picture_number ) ;print_int ( ""interlaced_frame"" , frame -> interlaced_frame ) ;print_int ( ""top_field_first"" , frame -> top_field_first ) ;print_int ( ""repeat_pict"" , frame -> repeat_pict ) ;if ( frame -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ;else print_str_opt ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ;if ( frame -> colorspace != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ;else print_str_opt ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ;if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED )  print_str ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ;","print_primaries ( w , frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) print_str ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ;",1599
1076,"if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>seperation\\\","if ( ! s -> cdx [ i ] || s -> cdx [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>seperation\\\",1600
1077,"char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;",1601
1078,else  follow_dotdot ( nd ) ;},else return follow_dotdot ( nd ) ;},1602
1079,"dname = malloc ( strlen ( name ) + 16 ) ;sprintf ( dname , ""%s-versions"" , name ) ;","dname = safe_calloc ( strlen ( name ) + 16 ) ;sprintf ( dname , ""%s-versions"" , name ) ;",1603
1080,"while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END )  {","check_stack_depth ( ) ;while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) {",1604
1081,"struct sock * sk ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;","struct sock * sk ;if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;",1605
1082,"static void usage ( char * progname ) {printf ( ""Usage:\\\printf ( ""%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>"" ,  progname ) ;printf ( ""<output_yuv><S2SV_blank>[<frames>]\\\","static void usage ( ) {printf ( ""Usage:\\\printf ( ""%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>"" , exec_name ) ;printf ( ""<output_yuv><S2SV_blank>[<frames>]\\\",1606
1083,# endif  int watchdog = 0 ;ssize_t num ;,# endif int watchdog = 0 ;,1607
1084,"SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;}}if ( c -> reneg_state == RENEG_DETECTED && ! c -> opt -> option . renegotiation ) {s_log ( LOG_ERR , ""Aborting<S2SV_blank>due<S2SV_blank>to<S2SV_blank>renegotiation<S2SV_blank>request"" ) ;throw_exception ( c , 1 ) ;}if ( shutdown_wants_read || shutdown_wants_write ) {num = SSL_shutdown ( c -> ssl ) ;if ( num < 0 )  err = SSL_get_error ( c -> ssl , ( int ) num ) ;else err = SSL_ERROR_NONE ;case SSL_ERROR_SYSCALL :  if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ;case SSL_ERROR_ZERO_RETURN :  SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_WANT_WRITE :  s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ;","SSL_set_shutdown ( c -> ssl , num ) ;else err = SSL_ERROR_NONE ;case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ;case SSL_ERROR_ZERO_RETURN : SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ;",1607
1085,"default : s_log ( LOG_ERR , ""SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ;throw_exception ( c , 1 ) ;}}if ( sock_open_wr && sock_can_wr ) {num = writesocket ( c -> sock_wfd -> fd , c -> ssl_buff , c -> ssl_ptr ) ;switch ( num ) {case - 1 : if ( parse_socket_error ( c , ""writesocket"" ) ) break ;sock_open_rd = sock_open_wr = 0 ;break ;case 0 : s_log ( LOG_DEBUG , ""writesocket<S2SV_blank>returned<S2SV_blank>0"" ) ;break ;default : memmove ( c -> ssl_buff , c -> ssl_buff + num , c -> ssl_ptr - ( size_t ) num ) ;c -> ssl_ptr -= ( size_t ) num ;memset ( c -> ssl_buff + c -> ssl_ptr , 0 , ( size_t ) num ) ;c -> sock_bytes += ( size_t ) num ;watchdog = 0 ;}}if ( sock_open_rd && sock_can_rd ) {num = readsocket ( c -> sock_rfd -> fd ,  c -> sock_buff + c -> sock_ptr , BUFFSIZE - c -> sock_ptr ) ;switch ( num ) {case - 1 : if ( parse_socket_error ( c , ""readsocket"" ) ) break ;sock_open_rd = sock_open_wr = 0 ;break ;case 0 : s_log ( LOG_INFO , ""Read<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(readsocket)"" ) ;sock_open_rd = 0 ;break ;default : c -> sock_ptr += ( size_t ) num ;watchdog = 0 ;}}read_wants_read |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && c -> ssl_ptr < BUFFSIZE && ! read_wants_write ;write_wants_write |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && c -> sock_ptr && ! write_wants_read ;if ( ( write_wants_read && ssl_can_rd ) || ( write_wants_write && ssl_can_wr ) ) {write_wants_read = 0 ;write_wants_write = 0 ;num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ;switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) {case SSL_ERROR_NONE : if ( num == 0 ) {s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>0"" ) ;break ;}memmove ( c -> sock_buff , c -> sock_buff + num , c -> sock_ptr - ( size_t ) num ) ;c -> sock_ptr -= ( size_t ) num ;memset ( c -> sock_buff + c -> sock_ptr , 0 , ( size_t ) num ) ;c -> ssl_bytes += ( size_t ) num ;watchdog = 0 ;break ;case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ;write_wants_write = 1 ;break ;case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ;write_wants_read = 1 ;break ;case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ;break ;case SSL_ERROR_SYSCALL :   if ( num && parse_socket_error ( c , ""SSL_write"" ) )  break ;if ( c -> sock_ptr ) {s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ;throw_exception ( c , 1 ) ;}s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ;SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_ZERO_RETURN :   s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ;if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_SSL :  sslerror ( ""SSL_write"" ) ;","case SSL_ERROR_ZERO_RETURN : SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_ZERO_RETURN : s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ;if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_SSL : sslerror ( ""SSL_write"" ) ;int num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ;",1607
1086,"break ;case SSL_ERROR_ZERO_RETURN : s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ;","break ;case SSL_ERROR_ZERO_RETURN : s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ;",1607
1087,"s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(read<S2SV_blank>hangup)"" ) ;SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_RECEIVED_SHUTDOWN ) ;}if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && s_poll_hup ( c -> fds , c -> ssl_wfd -> fd ) ) {if ( c -> sock_ptr || write_wants_write ) {s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ;throw_exception ( c , 1 ) ;}s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)"" ) ;SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_SENT_SHUTDOWN ) ;}if ( sock_open_wr && SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN && ! c -> ssl_ptr ) {sock_open_wr = 0 ;if ( ! c -> sock_wfd -> is_socket ) {s_log ( LOG_DEBUG , ""Closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>descriptor"" ) ;sock_open_rd = 0 ;}else if ( ! shutdown ( c -> sock_wfd -> fd , SHUT_WR ) ) {s_log ( LOG_DEBUG , ""Sent<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown"" ) ;}else {s_log ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown"" ) ;sock_open_rd = 0 ;}}if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && ! sock_open_rd && ! c -> sock_ptr && ! write_wants_write ) {if ( SSL_version ( c -> ssl ) != SSL2_VERSION ) {s_log ( LOG_DEBUG , ""Sending<S2SV_blank>close_notify<S2SV_blank>alert"" ) ;shutdown_wants_write = 1 ;}else {s_log ( LOG_DEBUG , ""Closing<S2SV_blank>SSLv2<S2SV_blank>socket"" ) ;","s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ;",1607
1088,if ( err )  return err ;if ( priv_ctx ) {,if ( err ) goto free_data ;if ( priv_ctx ) {,1608
1089,"elm_win_title_set ( app_data -> window , APP_NAME ) ;evas_object_smart_callback_add ( app_data -> window , ""delete,request"" , on_window_deletion , & app_data ) ;Evas_Object * bg = elm_bg_add ( app_data -> window ) ;elm_bg_color_set ( bg , 193 , 192 , 191 ) ;evas_object_size_hint_weight_set ( bg , EVAS_HINT_EXPAND , EVAS_HINT_EXPAND ) ;elm_win_resize_object_add ( app_data -> window , bg ) ;","elm_win_title_set ( app_data -> window , window_width , window_height ) ;",1609
1090,"evas_object_resize ( app_data -> window , DEFAULT_WIDTH , DEFAULT_HEIGHT ) ;evas_object_show ( app_data -> window ) ;","evas_object_resize ( app_data -> window , DEFAULT_WIDTH , DEFAULT_HEIGHT ) ;evas_object_show ( app_data -> window ) ;",1609
1091,if ( refill_pi_state_cache ( ) )  return - ENOMEM ;,if ( uaddr1 == uaddr2 ) return - EINVAL ;if ( refill_pi_state_cache ( ) ) return - ENOMEM ;,1610
1092,if ( unlikely ( ret != 0 ) )  goto out_put_key1 ;hb1 = hash_futex ( & key1 ) ;,"if ( unlikely ( ret != 0 ) ) goto out_put_key1 ;if ( requeue_pi && match_futex ( & key1 , & key2 ) ) {ret = - EINVAL ;goto out_put_keys ;}hb1 = hash_futex ( & key1 ) ;",1610
1093,sctp_addiphdr_t * hdr ;union sctp_addr_param * addr_param ;int all_param_pass = 1 ;chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ;,sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ;bool all_param_pass = true ;union sctp_params param ;sctp_addiphdr_t * hdr ;union sctp_addr_param * addr_param ;chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ;,1611
1094,"while ( chunk_len > 0 ) {err_code = sctp_process_asconf_param ( asoc , asconf ,  asconf_param ) ;if ( SCTP_ERROR_NO_ERROR != err_code )  all_param_pass = 0 ;if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack ,  asconf_param -> crr_id , err_code ,  asconf_param ) ;length = ntohs ( asconf_param -> param_hdr . length ) ;asconf_param = ( void * ) asconf_param + length ;chunk_len -= length ;","sctp_walk_params ( param , addip , addip_hdr . params ) {if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ;err_code = sctp_process_asconf_param ( asoc , asconf , param . addip ) ;if ( err_code != SCTP_ERROR_NO_ERROR ) all_param_pass = 0 ;if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , param . addip -> crr_id , err_code , asconf_param ) ;",1611
1095,cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;,cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ;cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;,1612
1096,cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;break ;,cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ;break ;,1612
1097,while ( c != EOF && c != \'\\\c = tok_nextc ( tok ) ;},"const char * prefix , * p , * type_start ;while ( c != EOF && c != \'\\\c = tok_nextc ( tok ) ;}if ( tok -> type_comments ) {p = tok -> start ;prefix = type_comment_prefix ;while ( * prefix && p < tok -> cur ) {if ( * prefix == \'<S2SV_blank>\' ) {while ( * p == \'<S2SV_blank>\' || * p == \'\\\\t\' ) {p ++ ;}}else if ( * prefix == * p ) {p ++ ;}else {break ;}prefix ++ ;}if ( ! * prefix ) {int is_type_ignore = 1 ;tok_backup ( tok , c ) ;type_start = p ;is_type_ignore = tok -> cur >= p + 6 && memcmp ( p , ""ignore"" , 6 ) == 0 ;p += 6 ;while ( is_type_ignore && p < tok -> cur ) {if ( * p == \'#\' ) break ;is_type_ignore = is_type_ignore && ( * p == \'<S2SV_blank>\' || * p == \'\\\\t\' ) ;p ++ ;}if ( is_type_ignore ) {if ( blankline ) {tok_nextc ( tok ) ;tok -> atbol = 1 ;}return TYPE_IGNORE ;}else {* p_start = ( char * ) type_start ;* p_end = tok -> cur ;return TYPE_COMMENT ;}}}",1613
1098,LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ;const int old_frame_since_key = cpi -> rc . frames_since_key ;cpi -> rc = lc -> rc ;cpi -> twopass = lc -> twopass ;cpi -> oxcf . target_bandwidth = lc -> target_bandwidth ;cpi -> oxcf . starting_buffer_level = lc -> starting_buffer_level ;cpi -> oxcf . optimal_buffer_level = lc -> optimal_buffer_level ;cpi -> oxcf . maximum_buffer_size = lc -> maximum_buffer_size ;cpi -> output_framerate = lc -> framerate ;,LAYER_CONTEXT * const lc = get_layer_context ( cpi ) ;const int old_frame_since_key = cpi -> rc . frames_since_key ;cpi -> alt_ref_source = lc -> rc ;cpi -> twopass = lc -> alt_ref_source ;,1614
1099,"status = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ;if ( ( status & ISR_LCIS ) != 0 ) {ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_LCIS ) ;status = ksz8851ReadReg ( interface , KSZ8851_REG_P1SR ) ;if ( ( status & P1SR_LINK_GOOD ) != 0 ) {if ( ( status & P1SR_OPERATION_SPEED ) != 0 ) {if ( ( status & P1SR_OPERATION_DUPLEX ) != 0 )  {","status = ksz8851ReadReg ( interface , KSZ8851_ISR ) ;if ( ( status & KSZ8851_ISR_LCIS ) != 0 ) {ksz8851WriteReg ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS ) ;status = ksz8851ReadReg ( interface , KSZ8851_P1SR ) ;if ( ( status & KSZ8851_P1SR_LINK_GOOD ) != 0 ) {if ( ( status & KSZ8851_P1SR_OPERATION_DUPLEX ) != 0 ) {if ( ( status & KSZ8851_ISR_RXIS ) != 0 ) {if ( ( status & P1SR_OPERATION_DUPLEX ) != 0 ) {",1615
1100,"if ( ( status & ISR_RXIS ) != 0 )  {ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_RXIS ) ;frameCount = MSB ( ksz8851ReadReg ( interface , KSZ8851_REG_RXFCTR ) ) ;while ( frameCount > 0 ) {ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_RXIE ) ;}","if ( ( status & ISR_RXIS ) != 0 ) {ksz8851WriteReg ( interface , KSZ8851_ISR , KSZ8851_ISR_RXIS ) ;frameCount = MSB ( ksz8851ReadReg ( interface , KSZ8851_RXFCTR ) ) ;while ( frameCount > 0 ) {ksz8851SetBit ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_RXIE ) ;}",1615
1101,case IS_STRING :  convert_to_double_ex ( zval_affine_elem ) ;affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ;break ;,case IS_STRING : {zval dval ;dval = * * zval_affine_elem ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;affine [ i ] = Z_DVAL ( dval ) ;}break ;,1616
1102,"convert_to_long_ex ( tmp ) ;rect . x = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ;convert_to_long_ex ( tmp ) ;rect . y = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ;convert_to_long_ex ( tmp ) ;rect . width = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ;convert_to_long_ex ( tmp ) ;rect . height = Z_LVAL_PP ( tmp ) ;}","if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . x = Z_LVAL ( lval ) ;}}rect . x = Z_LVAL_PP ( tmp ) ;}else {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . y = Z_LVAL ( lval ) ;}}else {rect . y = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . width = Z_LVAL ( lval ) ;}}else {rect . width = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . height = Z_LVAL ( lval ) ;}else {rect . height = Z_LVAL_PP ( tmp ) ;}}",1616
1103,fail :  vp9_free_context_buffers ( cm ) ;return 1 ;,"fail : vp9_set_mb_mi ( cm , 0 , 0 ) ;vp9_free_context_buffers ( cm ) ;return 1 ;",1617
1104,"__mincore_unmapped_range ( addr , end , vma , vec ) ;goto out ;if ( pte_none ( pte ) )  __mincore_unmapped_range ( addr , addr + PAGE_SIZE ,  vma , vec ) ;if ( non_swap_entry ( entry ) ) {* vec = 1 ;}else {# ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ;# else WARN_ON ( 1 ) ;* vec = 1 ;# endif }","memset ( vec , 1 , nr ) ;goto out ;if ( pte_none ( pte ) ) * vec = 0 ;* vec = ! ! non_swap_entry ( entry ) ;",1618
1105,"buffer = zend_string_alloc ( len , 0 ) ;n = zip_fread ( zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ;","buffer = zend_string_safe_alloc ( 1 , len , 0 , 0 ) ;n = zip_fread ( zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ;",1619
1106,if ( addr > ( vdev -> config_len - sizeof ( val ) ) )  return ;,if ( addr + sizeof ( val ) ) ) return ;,1620
1107,"u64 nsec = ( u64 ) jiffies * TICK_NSEC ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ;}","u32 rem ;value -> tv_sec = div_u64_rem ( ( u64 ) jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) ;value -> tv_nsec = rem ;}",1621
1108,if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ;,if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) sanitize_dead_code ( env ) ;if ( ret == 0 ) return - EINVAL ;,1622
1109,if ( ret == 0 )  ret = convert_ctx_accesses ( env ) ;if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ;,if ( ret == 0 ) ret = convert_ctx_accesses ( env ) ;if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ;,1622
1110,"int align = DEFAULT_ALIGNMENT ;if ( ! memblk ) new_addr = vpx_malloc ( size ) ;else if ( ! size ) vpx_free ( memblk ) ;else {addr = ( void * ) ( ( ( size_t * ) memblk ) [ - 1 ] ) ;memblk = NULL ;# if CONFIG_MEM_MANAGER  new_addr = vpx_mm_realloc ( addr , size + align + ADDRESS_STORAGE_SIZE ) ;# else  new_addr = VPX_REALLOC_L ( addr , size + align + ADDRESS_STORAGE_SIZE ) ;","new_addr = realloc ( addr , size + align + ADDRESS_STORAGE_SIZE ) ;# else new_addr = VPX_REALLOC_L ( addr , size + align + ADDRESS_STORAGE_SIZE ) ;",1623
1111,egress :  if ( errcode != 0 )  assert ( state -> status != 0 ) ;,"egress : if ( errcode != 0 && state -> status == NULL ) state -> status = ""UNKNOWN_REASON"" ;",1624
1112,"if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ;( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ;( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ;( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ;( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ;( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ;( void ) ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ;viff_info . comment [ 511 ] = \'\\\\0\' ;if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment ) ;if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ;else image -> endian = MSBEndian ;viff_info . rows = ReadBlobLong ( image ) ;viff_info . columns = ReadBlobLong ( image ) ;viff_info . subrows = ReadBlobLong ( image ) ;viff_info . x_offset = ReadBlobSignedLong ( image ) ;viff_info . y_offset = ReadBlobSignedLong ( image ) ;viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;viff_info . location_type = ReadBlobLong ( image ) ;viff_info . location_dimension = ReadBlobLong ( image ) ;viff_info . number_of_images = ReadBlobLong ( image ) ;viff_info . number_data_bands = ReadBlobLong ( image ) ;viff_info . data_storage_type = ReadBlobLong ( image ) ;viff_info . data_encode_scheme = ReadBlobLong ( image ) ;viff_info . map_scheme = ReadBlobLong ( image ) ;viff_info . map_storage_type = ReadBlobLong ( image ) ;viff_info . map_rows = ReadBlobLong ( image ) ;viff_info . map_columns = ReadBlobLong ( image ) ;viff_info . map_subrows = ReadBlobLong ( image ) ;viff_info . map_enable = ReadBlobLong ( image ) ;viff_info . maps_per_cycle = ReadBlobLong ( image ) ;viff_info . color_space_model = ReadBlobLong ( image ) ;for ( i = 0 ;i < 420 ;i ++ ) ( void ) ReadBlobByte ( image ) ;if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ;number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ;if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ;if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ;if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ;if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ;if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ;if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ;if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ;if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ;switch ( ( int ) viff_info . map_scheme ) {case VFF_MS_NONE : {if ( viff_info . number_data_bands < 3 ) {if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {unsigned char * viff_colormap ;switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;break ;case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}image -> colors = viff_info . map_columns ;if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;lsb_first = 1 ;if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : {MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}default : break ;}for ( i = 0 ;i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;i ++ ) {switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;break ;default : value = 1.0 * viff_colormap [ i ] ;break ;}if ( i < ( ssize_t ) image -> colors ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> matte = viff_info . number_data_bands == 4 ? MagickTrue : MagickFalse ;image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}switch ( ( int ) viff_info . data_storage_type ) {case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}if ( viff_info . data_storage_type == VFF_TYP_BIT ) {if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",1625
1113,"if ( ( r = sshbuf_get_u32 ( b , & comp -> type ) ) != 0 ||  ( r = sshbuf_get_u32 ( b , ( u_int * ) & comp -> enabled ) ) != 0 || ( r = sshbuf_get_cstring ( b , & comp -> name , NULL ) ) != 0 ) goto out ;","if ( ( r = sshbuf_get_u32 ( b , & comp -> type ) ) != 0 || ( r = sshbuf_get_u32 ( b , ( u_int * ) & comp -> enabled ) ) != 0 || ( r = sshbuf_get_cstring ( b , & comp -> name , NULL ) ) != 0 ) goto out ;",1626
1114,END_OF_READING :  if ( clone_info )  clone_info = DestroyImageInfo ( clone_info ) ;CloseBlob ( image ) ;,END_OF_READING : CloseBlob ( image ) ;,1627
1115,DeleteImageFromList ( & tmp ) ;},if ( tmp == image2 ) image2 = ( Image * ) NULL ;DeleteImageFromList ( & tmp ) ;},1627
1116,"int open_mode = opendata -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ;nfs4_stateid stateid ;if ( can_open_cached ( state , open_mode ) ) {spin_lock ( & state -> owner -> so_lock ) ;if ( can_open_cached ( state , open_mode ) ) {update_open_stateflags ( state , open_mode ) ;spin_unlock ( & state -> owner -> so_lock ) ;if ( delegation == NULL ||  ! can_open_delegated ( delegation , open_mode ) ) {rcu_read_unlock ( ) ;","int open_mode = opendata -> o_arg . open_flags & O_EXCL ;fmode_t fmode = opendata -> o_arg . fmode ;nfs4_stateid stateid ;if ( can_open_cached ( state , fmode ) ;spin_unlock ( & state -> owner -> so_lock ) ;if ( delegation == NULL || ! can_open_delegated ( delegation , fmode ) ) {rcu_read_unlock ( ) ;",1628
1117,"if ( update_open_stateid ( state , NULL , & stateid , open_mode ) )  goto out_return_state ;","if ( update_open_stateid ( state , NULL , & stateid , fmode ) ) goto out_return_state ;",1628
1118,else {err = - EINVAL ;goto out ;}}else {* policy = pol == & default_policy ? MPOL_DEFAULT : pol -> mode ;* policy |= ( pol -> flags & MPOL_MODE_FLAGS ) ;}if ( vma ) {up_read ( & current -> mm -> mmap_sem ) ;vma = NULL ;},"
",1629
1119,"bitmap -> compressed = FALSE ;bitmap -> format = gdi -> dstFormat ;bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ;bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ;","UINT32 size = DstWidth * DstHeight ;bitmap -> compressed = FALSE ;bitmap -> format = gdi -> dstFormat ;if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ;size *= GetBytesPerPixel ( bitmap -> format ) ;bitmap -> length = size ;bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ;",1630
1120,"const VP9_CONFIG * const oxcf = & cpi -> oxcf ;int active_best_quality ;int active_worst_quality = calc_active_worst_quality_one_pass_vbr ( cpi ) ;if ( frame_is_intra_only ( cm ) ) {active_best_quality = rc -> best_quality ;# if ! CONFIG_MULTIPLE_ARF if ( rc -> this_key_frame_forced ) {double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ;int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q ,  last_boosted_q * 0.75 ) ;active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ;}else if ( cm -> current_video_frame > 0 ) {double q_adj_factor = 1.0 ;active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] ,   rc -> kf_boost ,  kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;q_val = vp9_convert_qindex_to_q ( active_best_quality ) ;active_best_quality += vp9_compute_qdelta ( rc , q_val ,  q_val * q_adj_factor ) ;}active_best_quality = active_worst_quality + vp9_compute_qdelta ( rc , current_q , current_q * 0.3 ) ;# endif }else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) {if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) {if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) {if ( q < cpi -> cq_target_quality )  q = cpi -> cq_target_quality ;","const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;const int cq_level = get_active_cq_level ( rc , oxcf ) ;int active_best_quality ;int active_worst_quality = calc_active_worst_quality_one_pass_vbr ( cpi ) ;int * inter_minq ;ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ;if ( frame_is_intra_only ( cm ) ) {if ( rc -> this_key_frame_forced ) {double last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ;int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 0.75 , cm -> bit_depth ) ;active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ;}else {double q_adj_factor = 1.0 ;active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , rc -> kf_boost , kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;q_val = vp9_convert_qindex_to_q ( active_best_quality ) ;active_best_quality += vp9_compute_qdelta ( rc , q_val , q_val * q_adj_factor ) ;}active_best_quality = get_kf_active_quality ( rc , rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) {if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) {if ( q < cpi -> cq_target_quality ) q = cpi -> cq_target_quality ;",1631
1121,}else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) {if ( ! cpi -> refresh_alt_ref_frame ) {active_best_quality = cpi -> cq_target_quality ;},}else if ( oxcf -> rc_mode == VPX_CQ ) {if ( ! cpi -> refresh_alt_ref_frame ) {active_best_quality = cpi -> cq_target_quality ;},1631
1122,if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) {active_best_quality = cpi -> cq_target_quality ;}else {if ( cm -> current_video_frame > 1 ) active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ;else active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ;if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) &&   ( active_best_quality < cpi -> cq_target_quality ) ) {if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ;,if ( oxcf -> rc_mode == VPX_Q ) {if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ;,1631
1123,# if LIMIT_QRANGE_FOR_ALTREF_AND_KEY   if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) {if ( ! ( cm -> current_video_frame == 0 ) )  * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ;}# endif  if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) {q = active_best_quality ;,# if LIMIT_QRANGE_FOR_ALTREF_AND_KEY if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) {if ( ! ( cm -> current_video_frame == 0 ) ) * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ;}# endif if ( oxcf -> rc_mode == VPX_Q ) {active_best_quality = cq_level ;,1631
1124,"# if CONFIG_MULTIPLE_ARF  if ( cpi -> multi_arf_enabled && ( cm -> frame_type != KEY_FRAME ) && cpi -> oxcf . end_usage != USAGE_CONSTANT_QUALITY ) {double new_q ;double current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ;int level = cpi -> this_frame_weight ;assert ( level >= 0 ) ;new_q = current_q * ( 1.0 - ( 0.2 * ( cpi -> max_arf_level - level ) ) ) ;q = active_worst_quality + vp9_compute_qdelta ( rc , current_q , new_q ) ;* bottom_index = q ;* top_index = q ;printf ( ""frame:%d<S2SV_blank>q:%d\\\}# endif assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ;",assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ;,1631
1125,"for ( j = 1 ;lua_pushnumber ( L , j ) ;","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array"" ) ;for ( j = 1 ;lua_pushnumber ( L , j ) ;",1632
1126,guint32 off = offset ;guint32 len ;,"guint32 off = offset , last_off ;guint32 len ;",1633
1127,"DebugLog ( ( ""parse_wbxml_tag<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\\while ( off < tvb_len ) {","DebugLog ( ( ""parse_wbxml_tag<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\\last_off = off ;while ( off < tvb_len ) {",1633
1128,"
",if ( off < last_off ) {THROW ( ReportedBoundsError ) ;}last_off = off ;,1633
1129,"}DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\\","}DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\\",1633
1130,"Py_INCREF ( id ) ;PyDict_DelItemString ( value , ""$id"" ) ;if ( database == NULL ) {","if ( id == NULL ) {id = Py_None ;Py_INCREF ( id ) ;}else {Py_INCREF ( id ) ;PyDict_DelItemString ( value , ""$id"" ) ;}if ( database == NULL ) {",1634
1131,"case BGP_CAPCODE_RESTART :  ND_PRINT ( ( ndo , ""\\\","case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ;ND_PRINT ( ( ndo , ""\\\",1635
1132,"
",if ( idx > 63 ) return AVERROR_INVALIDDATA ;,1636
1133,"j = scantable [ idx ++ ] ;block [ j ] = sign ? 1 : - 1 ;j = scantable [ idx ++ ] ;block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ;}j = scantable [ idx ++ ] ;","j = scantable [ idx ++ ] ;block [ j ] = sign ? 1 : - 1 ;if ( idx > 63 ) return AVERROR_INVALIDDATA ;j = scantable [ idx ++ ] ;block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ;}if ( idx > 63 ) return AVERROR_INVALIDDATA ;j = scantable [ idx ++ ] ;",1636
1134,"static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) {vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] ,   MODEL_NODES * sizeof ( vp9_prob ) ) ;}","static void extend_to_full_distribution ( vpx_prob * probs , vp9_prob p ) {memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , MODEL_NODES * sizeof ( vpx_prob ) ) ;}",1637
1135,"PNG_UNUSED ( png_ptr ) # ifdef PNG_STRING_COPYRIGHT return PNG_STRING_COPYRIGHT # else # ifdef __STDC__  return ( ( png_charp ) PNG_STRING_NEWLINE ""libpng<S2SV_blank>version<S2SV_blank>1.2.52<S2SV_blank>-<S2SV_blank>November<S2SV_blank>20,<S2SV_blank>2014"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1998-2014<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" PNG_STRING_NEWLINE ) ;# else  return ( ( png_charp ) ""libpng<S2SV_blank>version<S2SV_blank>1.2.52<S2SV_blank>-<S2SV_blank>November<S2SV_blank>20,<S2SV_blank>2014\\\\\# endif # endif }","PNG_UNUSED ( png_ptr ) # ifdef PNG_STRING_COPYRIGHT return PNG_STRING_COPYRIGHT # else # ifdef __STDC__ return ( ( png_charp ) PNG_STRING_NEWLINE ""libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" PNG_STRING_NEWLINE ) ;# else return ( ( png_charp ) ""libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015\\\\\# endif # endif }",1638
1136,case PKT_STARTUP : if ( client -> pool ) {,"case PKT_STARTUP : if ( ! client -> auth_user ) {disconnect_client ( client , true , ""client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet"" ) ;return false ;}if ( client -> pool ) {",1639
1137,"case \'p\' :  if ( cf_auth_type <= AUTH_TRUST ) {disconnect_client ( client , true , ""unrequested<S2SV_blank>passwd<S2SV_blank>pkt"" ) ;","case \'p\' : if ( cf_auth_type <= AUTH_TRUST ) {disconnect_client ( client , true , ""unrequested<S2SV_blank>passwd<S2SV_blank>pkt"" ) ;",1639
1138,"rc = cmd_start ( adata , cmdstr , flags ) ;if ( rc < 0 ) {","if ( flags & IMAP_CMD_SINGLE ) {if ( adata -> nextcmd != adata -> lastcmd ) imap_exec ( adata , NULL , IMAP_CMD_POLL ) ;}rc = cmd_start ( adata , cmdstr , flags ) ;if ( rc < 0 ) {if ( ( flags & IMAP_CMD_SINGLE ) && ( adata -> nextcmd == adata -> lastcmd ) ) break ;",1640
1139,}mutt_sig_allow_interrupt ( false ) ;,}mutt_sig_allow_interrupt ( false ) ;,1640
1140,"return PNG_OUT_OF_MEMORY_ERROR ;}if ( setjmp ( mainprog_ptr -> jmpbuf ) ) {png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ;return LIBPNG_FATAL_ERROR ;}# if defined ( PNG_SKIP_sRGB_CHECK_PROFILE ) && defined ( PNG_SET_OPTION_SUPPORTED ) png_set_option ( png_ptr , PNG_SKIP_sRGB_CHECK_PROFILE , PNG_OPTION_ON ) ;# endif # if PNG_LIBPNG_VER >= 10500 && defined ( PNG_UNKNOWN_CHUNKS_SUPPORTED ) png_set_keep_unknown_chunks ( png_ptr , PNG_HANDLE_CHUNK_IF_SAFE , ( png_const_bytep ) ""pHYs\\\\0iTXt\\\\0tEXt\\\\0zTXt"" , 4 ) ;# endif png_set_read_user_chunk_fn ( png_ptr , & mainprog_ptr -> chunks , read_chunk_callback ) ;struct rwpng_read_data read_data = {infile , 0 };png_set_read_fn ( png_ptr , & read_data , user_read_data ) ;png_read_info ( png_ptr , info_ptr ) ;png_get_IHDR ( png_ptr , info_ptr , & mainprog_ptr -> width , & mainprog_ptr -> height , & bit_depth , & color_type , NULL , NULL , NULL ) ;if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) {png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ;return PNG_OUT_OF_MEMORY_ERROR ;}","
",1641
1141,"
","if ( rowbytes > INT_MAX / mainprog_ptr -> height ) {png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ;return PNG_OUT_OF_MEMORY_ERROR ;}",1641
1142,"if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) {fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\\","if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) {fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\\",1641
1143,"ar2 -> intf [ 0 ] = interface ;ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ;r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ;if ( r ) goto fail1 ;alt = ar2 -> intf [ 1 ] -> cur_altsetting ;ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ;r = ati_remote2_urb_init ( ar2 ) ;if ( r )  goto fail2 ;ar2 -> channel_mask = channel_mask ;if ( r )  goto fail2 ;usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ;if ( r )  goto fail2 ;r = ati_remote2_input_init ( ar2 ) ;if ( r )  goto fail3 ;usb_set_intfdata ( interface , ar2 ) ;fail3 :  sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ;fail2 :  ati_remote2_urb_cleanup ( ar2 ) ;usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ;","if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) {dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\\r = - ENODEV ;goto fail1 ;}ar2 -> intf [ 0 ] = interface ;ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ;if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) {dev_err ( & interface -> dev , ""%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\\r = - ENODEV ;goto fail1 ;}r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ;if ( r ) goto fail3 ;ar2 -> channel_mask = channel_mask ;if ( r ) goto fail2 ;usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ;if ( r ) goto fail3 ;r = ati_remote2_input_init ( ar2 ) ;if ( r ) goto fail4 ;usb_set_intfdata ( interface , ar2 ) ;fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ;fail3 : ati_remote2_urb_cleanup ( ar2 ) ;fail2 : usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ;",1642
1144,"pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ;RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ;","pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size + EXTRA_BS_OFFSET ) ;RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ;",1643
1145,"
",if ( unlikely ( page_count ( page ) <= 0 ) ) {if ( pages ) {spin_unlock ( ptl ) ;remainder = 0 ;err = - ENOMEM ;break ;}},1644
1146,same_page :  if ( pages ) {,same_page : if ( pages ) {,1644
1147,u8 odata [ 16 ] ;u8 idata [ 16 ] ;,u8 * odata = pctx -> odata ;u8 * idata = pctx -> idata ;,1645
1148,"if ( status ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\","if ( ! urb -> actual_length ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\\return ;}if ( status ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\",1646
1149,"else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) {}else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) {memcpy ( command_info -> result_buffer , & data [ 1 ] ,  urb -> actual_length - 1 ) ;command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;","else if ( ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) {}else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) && ( urb -> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) {memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 ) ;command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;",1646
1150,"static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header ,  struct mb_cache_entry * * pce )  {struct mb_cache_entry * ce ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;again :   ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev ,  hash ) ;if ( IS_ERR ( ce ) ) {if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ;break ;}","static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header , struct mb2_cache_entry * * pce ) {struct mb2_cache_entry * ce ;struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ce = mb2_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , hash ) ;",1647
1151,"ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ;}","ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce ) ;}",1647
1152,"if ( vm_flags & VM_NORESERVE )  return 0 ;if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ;else {struct resv_map * resv_map = resv_map_alloc ( ) ;if ( ! resv_map ) return - ENOMEM ;chg = to - from ;set_vma_resv_map ( vma , resv_map ) ;set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ;}if ( chg < 0 ) return chg ;if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return - ENOSPC ;hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ret ;","struct hugepage_subpool * spool = subpool_inode ( inode ) ;if ( hugepage_subpool_get_pages ( spool , chg ) ) return - ENOSPC ;hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ret ;",1648
1153,"lua_pushvalue ( L , i ) ;mp_encode_lua_type ( L , buf , 0 ) ;","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_check"" ) ;lua_pushvalue ( L , i ) ;mp_encode_lua_type ( L , buf , 0 ) ;",1649
1154,drop_futex_key_refs ( & q -> key ) ;},},1650
1155,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",1651
1156,if ( sk_hashed ( sk ) ) {write_lock_bh ( & ping_table . lock ) ;hlist_nulls_del ( & sk -> sk_nulls_node ) ;write_unlock_bh ( & ping_table . lock ) ;}},write_lock_bh ( & ping_table . lock ) ;if ( sk_hashed ( sk ) ) {hlist_nulls_del ( & sk -> sk_nulls_node ) ;}write_unlock_bh ( & ping_table . lock ) ;},1652
1157,msc -> ntouches = 0 ;for ( ii = 0 ;npoints = ( size - 6 ) / 8 ;msc -> ntouches = 0 ;,"if ( npoints > 15 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\\return 0 ;}msc -> ntouches = 0 ;for ( ii = 0 ;npoints = ( size - 6 ) / 8 ;if ( npoints > 15 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\\return 0 ;}msc -> ntouches = 0 ;",1653
1158,"int hdrlen ;uint16_t fc ;if ( caplen < 3 ) {ND_PRINT ( ( ndo , ""[|802.15.4]<S2SV_blank>%x"" , caplen ) ) ;return caplen ;}fc = EXTRACT_LE_16BITS ( p ) ;hdrlen = extract_header_length ( fc ) ;seq = EXTRACT_LE_8BITS ( p + 2 ) ;p += 3 ;caplen -= 3 ;ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ fc & 0x7 ] ) ) ;if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ;if ( hdrlen == - 1 ) {ND_PRINT ( ( ndo , ""invalid!<S2SV_blank>"" ) ) ;return caplen ;}if ( ! ndo -> ndo_vflag ) {p += hdrlen ;caplen -= hdrlen ;}else {switch ( ( fc >> 10 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;p += 2 ;case 0x03 :  panid = EXTRACT_LE_16BITS ( p ) ;ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;break ;}ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ;switch ( ( fc >> 14 ) & 0x3 ) {case 0x00 :  ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;case 0x01 :  ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;case 0x02 :   if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p ) ;}ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;break ;case 0x03 :   if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p ) ;}ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;break ;}caplen -= hdrlen ;}return 0 ;}","u_int hdrlen ;uint16_t fc ;switch ( ( fc >> 10 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;caplen -= 2 ;hdrlen += 2 ;if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;p += 2 ;case 0x03 : panid = EXTRACT_LE_16BITS ( p ) ;ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;break ;}ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ;switch ( ( fc >> 14 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;case 0x01 : ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;case 0x02 : if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p + 2 ) ) ) ;caplen -= 2 ;hdrlen += 2 ;}ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;break ;case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}panid = EXTRACT_LE_16BITS ( p ) ;caplen -= 2 ;hdrlen += 2 ;caplen -= 2 ;hdrlen += 2 ;}if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) }ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ;caplen -= 8 ;hdrlen += 8 ;caplen -= 8 ;hdrlen += 8 ;break ;}return hdrlen ;}",1654
1159,struct pmu * leader_pmu = event -> group_leader -> pmu ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;,struct pmu * leader_pmu = event -> group_leader -> pmu ;if ( is_software_event ( event ) ) return 1 ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;,1655
1160,"id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ;if ( id < 0 ) {ipc_rcu_putref ( msq , msg_rcu_free ) ;return id ;}msq -> q_stime = msq -> q_rtime = 0 ;msq -> q_ctime = get_seconds ( ) ;","msq -> q_stime = msq -> q_rtime = 0 ;msq -> q_ctime = get_seconds ( ) ;id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ;if ( id < 0 ) {ipc_rcu_putref ( msq , msg_rcu_free ) ;return id ;}",1656
1161,"VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;if ( ! load -> real ) {if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ;# ifdef DEBUG printf ( ""vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\\# endif load -> real -> progress_signal = load -> out ;g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ;if ( class -> load ( load ) ||  vips_image_pio_input ( load -> real ) )  return ( NULL ) ;if ( ! vips_foreign_load_iscompat ( load -> real , out ) )  return ( NULL ) ;vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ;","VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;if ( load -> error ) return ( NULL ) ;if ( ! load -> real ) || vips_foreign_load_iscompat ( load -> real , out ) ) return ( NULL ) ;vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ;",1657
1162,"vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;}vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;}","memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;}memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;}",1658
1163,"if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {dptr = & xargs -> tktpolicydn ;","arg = ( arg != NULL ) ? arg : """" ;if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {dptr = & xargs -> tktpolicydn ;",1659
1164,"
",if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;,1660
1165,line += PKT_LEN_SIZE ;if ( len == PKT_LEN_SIZE ) {,line += PKT_LEN_SIZE ;if ( len == PKT_LEN_SIZE ) {,1660
1166,"flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ;if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ;","flen = udf_get_filename ( dir -> i_sb , nameptr , lfi , fname , UDF_NAME_LEN ) ;if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ;",1661
1167,"outpos +=  sprintf ( outpos , ""\\\}","sprintf ( outputbuffer , ""\\\sendClean ( outputbuffer ) ;}",1662
1168,"
","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",1663
1169,"pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 *  sizeof ( * pixels ) ) ;","pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ;",1663
1170,"if ( copy_from_user ( & sas , optval , len ) )  return - EFAULT ;","len = min_t ( size_t , len , sizeof ( sas ) ) ;if ( copy_from_user ( & sas , optval , len ) ) return - EFAULT ;",1664
1171,"len = min_t ( size_t , len , sizeof ( sas ) ) ;if ( put_user ( len , optlen ) ) return - EFAULT ;","if ( put_user ( len , optlen ) ) return - EFAULT ;",1664
1172,for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src + i ) ;,for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src + i ) ;,1665
1173,"char buffer [ 4096 ] ;char buffer2 [ 4096 ] ;char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;}else {memcpy ( buf , name , name_len ) ;buf [ name_len ] = 0 ;}encrypt_return_plain :  if ( buf != buffer ) {efree ( buf ) ;}","char * buf , * buf2 , * d , * d_url ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;encrypt_return_plain : efree ( buf ) ;",1666
1174,"if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {memcpy ( buf2 , value , value_len ) ;buf2 [ value_len ] = 0 ;}else {}if ( buf != buffer ) {efree ( buf ) ;}if ( buf2 != buffer2 ) {}",efree ( buf ) ;,1666
1175,if ( ! ( vmx -> exit_reason == EXIT_REASON_MCE_DURING_VMENTRY || vmx -> exit_reason == EXIT_REASON_EXCEPTION_NMI ) ) return ;vmx -> exit_intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ;exit_intr_info = vmx -> exit_intr_info ;if ( is_machine_check ( exit_intr_info ) ) kvm_machine_check ( ) ;if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR &&  ( exit_intr_info & INTR_INFO_VALID_MASK ) ) {,if ( is_nmi ( exit_intr_info ) ) {,1667
1176,"static REFERENCE_MODE read_frame_reference_mode ( const VP9_COMMON * cm ,  vp9_reader * r ) {if ( is_compound_reference_allowed ( cm ) ) {return vp9_read_bit ( r ) ? ( vp9_read_bit ( r ) ? REFERENCE_MODE_SELECT  : COMPOUND_REFERENCE ) : SINGLE_REFERENCE ;","static REFERENCE_MODE read_frame_reference_mode ( const VP9_COMMON * cm , vpx_reader * r ) {if ( is_compound_reference_allowed ( cm ) ) {return vpx_read_bit ( r ) ? ( vp9_read_bit ( r ) ? REFERENCE_MODE_SELECT : COMPOUND_REFERENCE ) : SINGLE_REFERENCE ;",1668
1177,if ( outlength16 >= inlength * 16 )  return vp9_filteredinterp_filters1000 ;else if ( outlength16 >= inlength * 13 )  return vp9_filteredinterp_filters875 ;else if ( outlength16 >= inlength * 11 )  return vp9_filteredinterp_filters750 ;else if ( outlength16 >= inlength * 9 )  return vp9_filteredinterp_filters625 ;else  return vp9_filteredinterp_filters500 ;},if ( outlength16 >= inlength * 16 ) return filteredinterp_filters1000 ;else if ( outlength16 >= inlength * 13 ) return filteredinterp_filters875 ;else if ( outlength16 >= inlength * 11 ) return filteredinterp_filters750 ;else if ( outlength16 >= inlength * 9 ) return filteredinterp_filters625 ;else return filteredinterp_filters500 ;},1669
1178,"case 0x00 :  p += 2 ;n += 2 ;case 0x40 :  if ( * p == FAC_NATIONAL_RAND )  facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ;case 0x80 :  p += 4 ;n += 4 ;case 0xC0 :  l = p [ 1 ] ;if ( * p == FAC_NATIONAL_DEST_DIGI ) {memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> source_ndigis = 1 ;memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> dest_ndigis = 1 ;memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ;}memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ;}else if ( * p == FAC_NATIONAL_DIGIS ) {fac_national_digis_received = 1 ;","case 0x00 : if ( len < 2 ) return - 1 ;p += 2 ;n += 2 ;case 0x40 : if ( len < 3 ) return - 1 ;if ( * p == FAC_NATIONAL_RAND ) facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ;case 0x80 : if ( len < 4 ) return - 1 ;p += 4 ;n += 4 ;case 0xC0 : if ( len < 2 ) return - 1 ;l = p [ 1 ] ;if ( len < 2 + l ) return - 1 ;if ( * p == FAC_NATIONAL_DEST_DIGI ) {if ( l < AX25_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> source_ndigis = 1 ;if ( l < AX25_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> dest_ndigis = 1 ;if ( l < AX25_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ;}if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ;}else if ( * p == FAC_NATIONAL_DIGIS ) {if ( l % AX25_ADDR_LEN ) return - 1 ;fac_national_digis_received = 1 ;",1670
1179,"static void update_coef_probs_common ( vp9_writer * const bc , VP9_COMP * cpi ,  TX_SIZE tx_size ,  vp9_coeff_stats * frame_branch_ct ) {vp9_coeff_probs_model * new_frame_coef_probs = cpi -> frame_coef_probs [ tx_size ] ;vp9_coeff_probs_model * old_frame_coef_probs =  cpi -> common . fc . coef_probs [ tx_size ] ;const vp9_prob upd = DIFF_UPDATE_PROB ;","static void update_coef_probs_common ( vpx_writer * const bc , VP9_COMP * cpi , TX_SIZE tx_size , vp9_coeff_stats * frame_branch_ct , vp9_coeff_probs_model * new_coef_probs ) {vp9_coeff_probs_model * old_coef_probs = cpi -> common . fc . coef_probs [ tx_size ] ;const vp9_prob upd = DIFF_UPDATE_PROB ;",1671
1180,"vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;const vp9_prob oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;int s ;if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] ,  old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ;else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , oldp , & newp , upd ) ;","vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;const vpx_prob oldp = old_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;int s ;if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd , stepsize ) ;else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , oldp , & newp , upd ) ;",1671
1181,"vp9_write_bit ( bc , 0 ) ;return ;vp9_write_bit ( bc , 1 ) ;for ( i = 0 ;","vpx_write_bit ( bc , 0 ) ;return ;vpx_write_bit ( bc , 1 ) ;for ( i = 0 ;",1671
1182,"vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ;const vp9_prob upd = DIFF_UPDATE_PROB ;int s ;if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] ,  old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ;else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ;vp9_write ( bc , u , upd ) ;if ( u ) {","vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vpx_prob * oldp = old_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ;const vpx_prob upd = DIFF_UPDATE_PROB ;int s ;if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd , stepsize ) ;else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ;vpx_write ( bc , u , upd ) ;if ( u ) {",1671
1183,case ONE_LOOP :  case ONE_LOOP_REDUCED : {const int prev_coef_contexts_to_update =  cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEFF_CONTEXTS >> 1 : COEFF_CONTEXTS ;,case ONE_LOOP_REDUCED : {const int prev_coef_contexts_to_update = cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEFF_CONTEXTS >> 1 : COEFF_CONTEXTS ;,1671
1184,"vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ;if ( l >= prev_coef_contexts_to_update ||  k >= coef_band_to_update ) {u = 0 ;if ( t == PIVOT_NODE )  s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] ,  old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ;else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ;if ( s > 0 && newp != * oldp )  u = 1 ;}updates += u ;vp9_write_bit ( bc , 1 ) ;for ( v = 0 ;++ v )  vp9_write ( bc , 0 , upd ) ;}vp9_write ( bc , u , upd ) ;if ( u ) {","vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vpx_prob * oldp = old_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ;if ( t == PIVOT_NODE ) {s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd , stepsize ) ;s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ;}if ( s > 0 && newp != * oldp ) u = 1 ;updates += u ;vpx_write_bit ( bc , 1 ) ;for ( v = 0 ;+ v )  vp9_write ( bc , 0 , upd ) ;++ v ) vpx_write ( bc , 0 , upd ) ;}vpx_write ( bc , u , upd ) ;if ( u ) {",1671
1185,"vp9_write_bit ( bc , 0 ) ;}","vpx_write_bit ( bc , 0 ) ;}",1671
1186,if ( ! retval ) {r = strdup ( realm ) ;if ( ! r ) {retval = ENOMEM ;}},"if ( ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ;",1672
1187,"void vp9_fht16x16_sse2 ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {case DCT_DCT :  vp9_fdct16x16_sse2 ( input , output , stride ) ;break ;","void vp9_fht16x16_sse2 ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {case DCT_DCT : vpx_fdct16x16_sse2 ( input , output , stride ) ;break ;",1673
1188,if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) {if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO )  c -> idct_put = ff_simple_idct_put_int32_10bit ;,if ( c -> mpeg4_studio_profile ) c -> idct_put = ff_simple_idct_put_int32_10bit ;,1674
1189,int c_sz ;_dst += _y4m -> pic_w * _y4m -> pic_h ;,int c_sz ;( void ) _aux ;_dst += _y4m -> pic_w * _y4m -> pic_h ;,1675
1190,"rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ;","rc = fsmMkfile ( fi , fpath , files , psm , 0 , nodigest , & setmeta , & firsthardlink ) ;",1676
1191,"rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ;firsthardlink = - 1 ;","rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ;firsthardlink = - 1 ;",1676
1192,"size_t ss = CDF_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;if ( pos > ss * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;","size_t ss = CDF_SHORT_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;",1677
1193,struct fb_vblank vblank ;vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ;,"struct fb_vblank vblank ;memset ( & vblank , 0 , sizeof ( vblank ) ) ;vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ;",1678
1194,int ret = 0 ;mutex_lock ( & inode -> i_mutex ) ;if ( ret >= 0 ) {if ( ! list_empty ( & io -> list ) ) list_del_init ( & io -> list ) ;ext4_free_io_end ( io ) ;}},"struct ext4_inode_info * ei = EXT4_I ( inode ) ;unsigned long flags ;int ret ;mutex_lock ( & inode -> i_mutex ) ;if ( ret < 0 ) {return ;}spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ;if ( ! list_empty ( & io -> list ) ) list_del_init ( & io -> list ) ;spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ;mutex_unlock ( & inode -> i_mutex ) ;ext4_free_io_end ( io ) ;}",1679
1195,"if ( recvd ) {clear_sock ( pool ) ;sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;}else {if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\"",<S2SV_blank>\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\""]}"" , swork_id ++ ) ;}if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) {",if ( n2size < 1 ) {,1680
1196,"if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;","if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;",1680
1197,if ( s ) {struct unix_sock * u = unix_sk ( s ) ;spin_lock ( & unix_gc_lock ) ;,spin_lock ( & unix_gc_lock ) ;if ( s ) {struct unix_sock * u = unix_sk ( s ) ;,1681
1198,spin_unlock ( & unix_gc_lock ) ;}},}fp -> f_cred -> user -> unix_inflight ++ ;spin_unlock ( & unix_gc_lock ) ;},1681
1199,BOOL ret = FALSE ;WCHAR * data = NULL ;goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}data = NULL ;ret = TRUE ;out : free ( data ) ;return ret ;},WCHAR * data = NULL ;goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}return TRUE ;err : sud -> directory = NULL ;free ( data ) ;return FALSE ;},1682
1200,"in_uint16_le ( s , length ) ;in_uint16_le ( s , flags ) ;in_uint8 ( s , type ) ;next_order = s -> p + ( sint16 ) length + 7 ;","struct stream packet = * s ;in_uint16_le ( s , length ) ;in_uint16_le ( s , flags ) ;in_uint8 ( s , type ) ;if ( ! s_check_rem ( s , length + 7 ) ) {rdp_protocol_error ( ""process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream"" , & packet ) ;}next_order = s -> p + ( sint16 ) length + 7 ;",1683
1201,if ( cpi -> common . frame_type == KEY_FRAME ) {cpi -> rc . key_frame_rate_correction_factor = factor ;}if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) &&  ! cpi -> rc . is_src_frame_alt_ref &&   ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) )  cpi -> rc . gf_rate_correction_factor = factor ;else  cpi -> rc . rate_correction_factor = factor ;},"RATE_CONTROL * const rc = & cpi -> rc ;factor /= rcf_mult [ cpi -> rc . frame_size_selector ] ;factor = fclamp ( factor , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ;if ( cpi -> common . frame_type == KEY_FRAME ) {rc -> rate_correction_factors [ KF_STD ] = factor ;}else if ( cpi -> oxcf . pass == 2 ) {RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ;rc -> rate_correction_factors [ rf_lvl ] = factor ;}if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && ! rc -> is_src_frame_alt_ref && ! ( cpi -> use_svc && ( cpi -> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rc -> rate_correction_factors [ GF_ARF_STD ] = factor ;else rc -> rate_correction_factors [ INTER_NORMAL ] = factor ;}",1684
1202,spin_lock_init ( & tu -> qlock ) ;init_waitqueue_head ( & tu -> qchange_sleep ) ;mutex_init ( & tu -> tread_sem ) ;tu -> ticks = 1 ;,spin_lock_init ( & tu -> ioctl_lock ) ;tu -> ticks = 1 ;,1685
1203,"
","if ( u1_nal_ref_idc != 0 ) {if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) {memcpy ( ( void * ) ps_dec -> ps_dpb_cmds , ( void * ) ( & ( ps_dec -> s_dpb_cmds_scratch ) ) , sizeof ( dpb_commands_t ) ) ;}}",1686
1204,ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ;ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ;,ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ;ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ;,1686
1205,"char buf [ 32 ] ;js_Object * self = js_toobject ( J , 0 ) ;","char buf [ 100 ] ;js_Object * self = js_toobject ( J , 0 ) ;",1687
1206,char buf [ 100 ] ;double number = self -> u . number ;,double number = self -> u . number ;,1687
1207,"
",if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;,1688
1208,"
",if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;,1688
1209,"temp = ( struct sackhole * )  pool_get ( & sackhl_pool , PR_NOWAIT ) ;","temp = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ;",1688
1210,"temp = ( struct sackhole * )  pool_get ( & sackhl_pool , PR_NOWAIT ) ;","temp = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ;",1688
1211,"return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , apr_psprintf ( r -> pool ,  ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request:<S2SV_blank>%s"" ,  r -> args ) , HTTP_INTERNAL_SERVER_ERROR ) ;","return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , apr_psprintf ( r -> pool , ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request"" ) , HTTP_INTERNAL_SERVER_ERROR ) ;",1689
1212,# endif EVP_MD_CTX md_ctx ;,# endif EVP_MD_CTX_init ( & md_ctx ) ;EVP_MD_CTX md_ctx ;,1690
1213,"# endif  n = s -> method -> ssl_get_message ( s ,  SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ;if ( ! ok ) return ( ( int ) n ) ;if ( s -> s3 -> tmp . message_type != SSL3_MT_SERVER_KEY_EXCHANGE ) {# ifndef OPENSSL_NO_PSK   if ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK )  {","# endif n = s -> method -> ssl_get_message ( s , SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ;if ( ! ok ) return ( ( int ) n ) ;alg_k = s -> s3 -> tmp . new_cipher -> algorithm_auth ;al = SSL_AD_UNEXPECTED_MESSAGE ;goto f_err ;}# ifndef OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) {s -> session -> sess_cert = ssl_sess_cert_new ( ) ;if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ;s -> ctx -> psk_identity_hint = NULL ;}# endif s -> s3 -> tmp . reuse_message = 1 ;return ( 1 ) ;}param = p = ( unsigned char * ) s -> init_msg ;if ( s -> session -> sess_cert != NULL ) {# ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) {RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ;s -> session -> sess_cert -> peer_rsa_tmp = NULL ;}# endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) {DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ;s -> session -> sess_cert -> peer_dh_tmp = NULL ;}# endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) {EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ;s -> session -> sess_cert -> peer_ecdh_tmp = NULL ;}# endif }else {s -> session -> sess_cert = ssl_sess_cert_new ( ) ;}param_len = 0 ;alg_a = s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) {",1690
1214,"OPJ_UINT32 x , y ;OPJ_UINT8 * pix ;x = y = 0U ;while ( y < height ) {","OPJ_UINT32 x , y , written ;OPJ_UINT8 * pix ;x = y = written = 0U ;while ( y < height ) {",1691
1215,* pix = c1 ;},* pix = c1 ;written ++ ;},1691
1216,}if ( ( OPJ_UINT32 ) c & 1U ) {return OPJ_TRUE ;},"written ++ ;}if ( ( OPJ_UINT32 ) c & 1U ) {if ( written != width * height ) {fprintf ( stderr , ""warning,<S2SV_blank>image\\\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\\return OPJ_FALSE ;}}return OPJ_TRUE ;",1691
1217,"int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( fd == - 1 ) {","int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( fd == - 1 ) {",1692
1218,"static void  l2tp_proto_ver_print ( netdissect_options * ndo , const uint16_t * dat )  {","static void l2tp_proto_ver_print ( netdissect_options * ndo , const uint16_t * dat , u_int length ) {if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}",1693
1219,"kvmclock_reset ( vcpu ) ;vcpu -> arch . time = data ;vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ;if ( vcpu -> arch . time_offset &  ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ;vcpu -> arch . time_page =   gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ;if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ;if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ;vcpu -> arch . st . msr_val = data ;if ( ! ( data & KVM_MSR_ENABLED ) ) break ;vcpu -> arch . st . last_steal = current -> sched_info . run_delay ;preempt_disable ( ) ;accumulate_steal_time ( vcpu ) ;preempt_enable ( ) ;kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ;","u64 gpa_offset ;kvmclock_reset ( vcpu ) ;vcpu -> arch . time = data ;gpa_offset = data & ~ ( PAGE_MASK | 1 ) ;if ( gpa_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ;if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , data >> PAGE_SHIFT ) ;if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ;if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ;else vcpu -> arch . pv_time_enabled = true ;",1694
1220,if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 &&  rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) {if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 &&  rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) {,if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 91 && rdesc [ 83 ] == 0x26 && rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) {if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 51 && rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) {,1695
1221,"static int enable ( void ) {LOG_INFO ( ""%s"" , __func__ ) ;if ( ! interface_ready ( ) ) return BT_STATUS_NOT_READY ;","static int enable ( bool start_restricted ) {LOG_INFO ( ""%s"" , __func__ ) ;if ( ! interface_ready ( ) ) return BT_STATUS_NOT_READY ;",1696
1222,"if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 )   OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {done :  if ( buf ) oe_free ( buf ) ;","size_t data_size = 0 ;if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( ret > ( ssize_t ) data_size ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : if ( buf ) oe_free ( buf ) ;",1697
1223,return 1000000 - count ;# else return 1000000 ;,const uint32_t max_stack = 1000000 ;if ( count > max_stack ) return 0 ;return max_stack - count ;# else return 1000000 ;,1698
1224,while ( * s && * s != '}' ) {if ( * s == '\\\if ( ( * s == '<S2SV_blank>' || * s == '\\\else * t ++ = * s ++ ;while ( * s ) * t ++ = * s ++ ;,while ( * s ) {if ( * s == '\\\* s = '<S2SV_blank>' ;}if ( ( * s == '<S2SV_blank>' ) && ( s [ 1 ] == '<S2SV_blank>' || s [ 1 ] == '\\\s ++ ;}else {* t ++ = * s ++ ;},1699
1225,else if ( * s == '-' && s [ 1 ] == '0' && s [ 2 ] == '<S2SV_blank>' ) {,else if ( isdigit ( * s ) ) {* t ++ = * s ++ ;}else if ( period ) {while ( t > str && t [ - 1 ] == '0' ) {t -- ;}if ( t > str && t [ - 1 ] == '.' ) {t -- ;if ( t > str && ! isdigit ( t [ - 1 ] ) ) {* t ++ = '0' ;}}period = 0 ;* t ++ = * s ++ ;}else {period = 0 ;* t ++ = * s ++ ;}}* t = 0 ;s = t = str ;while ( * s ) {if ( * s == '-' && s [ 1 ] == '0' && s [ 2 ] == '<S2SV_blank>' ) {,1699
1226,"int res , ret ;if ( ! bitset ) return - EINVAL ;","int res , ret ;if ( uaddr == uaddr2 ) return - EINVAL ;if ( ! bitset ) return - EINVAL ;",1700
1227,"static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id )   {if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , ""ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>"" ""addr<S2SV_blank>%pM\\\}","static int iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) {if ( sta_id >= IWLAGN_STATION_COUNT ) {IWL_ERR ( priv , ""invalid<S2SV_blank>sta_id<S2SV_blank>%u"" , sta_id ) ;return - EINVAL ;}if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , ""ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>"" ""addr<S2SV_blank>%pM\\\return 0 ;}",1701
1228,int remaining = s -> icy_metaint - s -> icy_data_read ;if ( remaining < 0 ) return AVERROR_INVALIDDATA ;,uint64_t remaining ;if ( s -> icy_metaint < s -> icy_data_read ;if ( remaining < 0 ) return AVERROR_INVALIDDATA ;,1702
1229,end = dup ;for ( ;,if ( dup == NULL ) {return PyErr_NoMemory ( ) ;}end = dup ;for ( ;,1703
1230,netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ;netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ;,netdev -> hw_features = NETIF_F_HW_VLAN_CTAG_RX ;netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ;,1704
1231,if ( split_flag ) {int new_size = size / 2 ;,if ( split_flag && size >= MIN_BLOCK_SIZE ) {int new_size = size / 2 ;,1705
1232,if ( count < sizeof ( cmd ) ) {ret = - EINVAL ;,if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ;if ( count < sizeof ( cmd ) ) {ret = - EINVAL ;,1706
1233,"sprintf ( descriptor -> msg , ""\\\","sprintf ( descriptor -> msg , ""\\\",1707
1234,if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 )  {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT   && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&   value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )  {,if ( field_identifier == SQL_DESC_COUNT && ( intptr_t ) value < 0 ) {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) value != SQL_PARAM_OUTPUT_STREAM ) {,1707
1235,"* skipped_file = TRUE ;return ;}unique_name_nr = 1 ;handled_invalid_filename = * dest_fs_type != NULL ;if ( unique_names ) {dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ;}else if ( copy_job -> target_name != NULL ) {dest = get_target_file_with_custom_name ( src , dest_dir , * dest_fs_type , same_fs , copy_job -> target_name ) ;}else {dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ;}if ( test_dir_is_parent ( dest_dir , src ) ) {if ( job -> skip_all_error ) {goto out ;}primary = copy_job -> is_move ? g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>move<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself."" ) ) : g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>copy<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself."" ) ) ;secondary = g_strdup ( _ ( ""The<S2SV_blank>destination<S2SV_blank>folder<S2SV_blank>is<S2SV_blank>inside<S2SV_blank>the<S2SV_blank>source<S2SV_blank>folder."" ) ) ;response = run_cancel_or_skip_warning ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ;","mark_desktop_file_executable ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ;",1708
1236,"mark_desktop_file_trusted ( job ,  job -> cancellable , dest , FALSE ) ;","mark_desktop_file_trusted ( job , job -> cancellable , dest , FALSE ) ;",1708
1237,return 1000000 - count ;# else return 1000000 ;,const uint32_t max_stack = 1000000 ;if ( count > max_stack ) return 0 ;return max_stack - count ;# else return 1000000 ;,1709
1238,msg -> msg_namelen = sizeof ( * sipx ) ;if ( sipx ) {,if ( sipx ) {msg -> msg_namelen = sizeof ( * sipx ) ;,1710
1239,"
",last_name = 0 ;,1711
1240,if ( gfs )  gfs -> errors = gfc . errors [ 1 ] ;,if ( gfs ) gfs -> errors = gfc . errors [ 1 ] ;,1711
1241,if ( ! addr || addr -> sa_family != AF_BLUETOOTH )  return - EINVAL ;,if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ;if ( addr_len < sizeof ( struct sockaddr_sco ) ) return - EINVAL ;,1712
1242,"down_write ( & card -> controls_rwsem ) ;if ( snd_ctl_find_id ( card , & id ) ) {","if ( id . index > UINT_MAX - kcontrol -> count ) goto error ;down_write ( & card -> controls_rwsem ) ;if ( snd_ctl_find_id ( card , & id ) ) {",1713
1243,"Browser_Window * window ;Ecore_Getopt_Value values [ ] = {ECORE_GETOPT_VALUE_STR ( evas_engine_name ) ,  ECORE_GETOPT_VALUE_BOOL ( quitOption ) ,  ECORE_GETOPT_VALUE_BOOL ( frame_flattening_enabled ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_NONE }","Browser_Window * window ;char * window_size_string = NULL ;Ecore_Getopt_Value values [ ] = {ECORE_GETOPT_VALUE_STR ( evas_engine_name ) , ECORE_GETOPT_VALUE_STR ( window_size_string ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_BOOL ( frame_flattening_enabled ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_NONE }if ( window_size_string ) parse_window_size ( window_size_string , & window_width , & window_height ) ;",1714
1244,if ( args < argc ) {char * url = url_from_user_input ( argv [ args ] ) ;,if ( args < argc ) {char * url = url_from_user_input ( argv [ args ] ) ;,1714
1245,"int perf_output_begin ( struct perf_output_handle * handle , struct perf_event * event , unsigned int size ,  int nmi , int sample )  {","int perf_output_begin ( struct perf_output_handle * handle , struct perf_event * event , unsigned int size , int sample ) {",1715
1246,handle -> rb = rb ;handle -> event = event ;handle -> nmi = nmi ;handle -> sample = sample ;,handle -> sample = sample ;,1715
1247,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) {","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) {",1716
1248,"line = data + npy * wpl ;val = GET_DATA_BIT ( line , npx ) ;","if ( npx < 0 || npx >= w || npy < 0 || npy >= h ) continue ;line = data + npy * wpl ;val = GET_DATA_BIT ( line , npx ) ;",1717
1249,image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;image -> rows = ( size_t ) floor floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,1718
1250,width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,width = ( size_t ) floor floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;height = ( size_t ) floor floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,1718
1251,width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;,width = ( size_t ) floor floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;,1718
1252,"if ( image -> columns == 0 )  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;if ( image -> columns == 0 )  image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 )  image -> rows = ( size_t ) ( metrics . ascent - metrics . descent +  draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 )  image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;status = SetImageExtent ( image , image -> columns , image -> rows ) ;","if ( image -> columns == 0 ) image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;if ( image -> columns == 0 ) image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 ) image -> rows = ( size_t ) ( metrics . ascent - metrics . descent + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 ) image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;status = SetImageExtent ( image , image -> columns , image -> rows ) ;",1718
1253,passert ( GLOBALS_ARE_RESET ( ) ) ;},},1719
1254,"
",cpu = cpumask_first ( mask ) ;,1720
1255,"event_data -> snk_config =  sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ;","event_data -> snk_config = sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ;",1720
1256,"case 0x00 :  p += 2 ;n += 2 ;case 0x40 :  if ( * p == FAC_NATIONAL_RAND )  facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ;case 0x80 :  p += 4 ;n += 4 ;case 0xC0 :  l = p [ 1 ] ;if ( * p == FAC_NATIONAL_DEST_DIGI ) {memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> source_ndigis = 1 ;memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> dest_ndigis = 1 ;memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ;}memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ;}else if ( * p == FAC_NATIONAL_DIGIS ) {fac_national_digis_received = 1 ;","case 0x00 : if ( len < 2 ) return - 1 ;p += 2 ;n += 2 ;case 0x40 : if ( len < 3 ) return - 1 ;if ( * p == FAC_NATIONAL_RAND ) facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ;case 0x80 : if ( len < 4 ) return - 1 ;p += 4 ;n += 4 ;case 0xC0 : if ( len < 2 ) return - 1 ;l = p [ 1 ] ;if ( len < 2 + l ) return - 1 ;if ( * p == FAC_NATIONAL_DEST_DIGI ) {if ( l < AX25_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> source_ndigis = 1 ;if ( l < AX25_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> dest_ndigis = 1 ;if ( l < AX25_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ;}if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ;}else if ( * p == FAC_NATIONAL_DIGIS ) {if ( l % AX25_ADDR_LEN ) return - 1 ;fac_national_digis_received = 1 ;",1721
1257,DevInfo . MaxRDMBufferSize = BUFFER_4K ;DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ;,"memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;DevInfo . MaxRDMBufferSize = BUFFER_4K ;DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ;",1722
1258,"using_ecc = using_ecc && ( s -> session -> tlsext_ecpointformatlist != NULL ) ;# endif ret += 2 ;if ( ret >= limit ) return NULL ;if ( s -> s3 -> send_connection_binding ) {int el ;if ( ! ssl_add_serverhello_renegotiate_ext ( s , 0 , & el , 0 ) ) {SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ;return NULL ;}if ( CHECKLEN ( ret , 4 + el , limit ) ) return NULL ;s2n ( TLSEXT_TYPE_renegotiate , ret ) ;s2n ( el , ret ) ;if ( ! ssl_add_serverhello_renegotiate_ext ( s , ret , & el , el ) ) {SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ;return NULL ;}ret += el ;}if ( s -> version == SSL3_VERSION ) goto done ;if ( ! s -> hit && s -> servername_done == 1 && s -> session -> tlsext_hostname != NULL ) {",using_ecc = using_ecc && ( s -> tlsext_use_etm ) {,1723
1259,if ( s -> s3 -> flags & TLS1_FLAGS_ENCRYPT_THEN_MAC ) {if ( SSL_IS_DTLS ( s ) || s -> s3 -> tmp . new_cipher -> algorithm_mac == SSL_AEAD || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_RC4 || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_eGOST2814789CNT || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_eGOST2814789CNT12 )  s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ;else {,if ( s -> s3 -> flags & TLS1_FLAGS_ENCRYPT_THEN_MAC ) {if ( SSL_IS_DTLS ( s ) || s -> s3 -> tmp . new_cipher -> algorithm_mac == SSL_AEAD || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_RC4 || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_eGOST2814789CNT || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_eGOST2814789CNT12 ) s -> tlsext_use_etm = 0 ;else {,1723
1260,"variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride ,   vp9_64_zeros , 0 , bw , bh , & sse , & avg ) ;var = sse - ( ( ( int64_t ) avg * avg ) / ( bw * bh ) ) ;return ( 256 * var ) / ( bw * bh ) ;var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf ,  x -> plane [ 0 ] . src . stride ,  vp9_64_zeros , 0 , & sse ) ;return ( 256 * var ) >> num_pels_log2_lookup [ bs ] ;","# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {aq_highbd_8_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , CONVERT_TO_BYTEPTR ( vp9_highbd_64_zeros ) , 0 , bw , bh , & sse , & avg ) ;}# else aq_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , bw , bh , & sse , & avg ) ;# endif sse >>= 2 * ( xd -> bd - 8 ) ;avg >>= ( xd -> bd - 8 ) ;}else {# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {aq_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , CONVERT_TO_BYTEPTR ( vp9_highbd_64_zeros ) , 0 , & sse ) ;}# else var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , & sse ) ;# endif }else {var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , bw , bh , & sse , & avg ) ;var = sse - ( ( ( int64_t ) avg * avg ) / ( bw * bh ) ) ;return ( 256 * var ) / ( bw * bh ) ;var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , & sse ) ;return ( 256 * var ) >> num_pels_log2_lookup [ bs ] ;",1724
1261,if ( image -> numcomps < 4 ) return ;max = w * h ;,"if ( ( image -> numcomps < 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) {fprintf ( stderr , ""%s:%d:color_cmyk_to_rgb\\\return ;}max = w * h ;",1725
1262,goto discard ;},consume_skb ( skb ) ;return 0 ;},1726
1263,"if ( layer_info == ( LayerInfo * ) NULL ) {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>LayerInfo<S2SV_blank>failed"" ) ;ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;}( void ) ResetMagickMemory ( layer_info , 0 , ( size_t ) number_layers * sizeof ( * layer_info ) ) ;for ( i = 0 ;i < number_layers ;i ++ ) {ssize_t x , y ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>layer<S2SV_blank>#%.20g"" , ( double ) i + 1 ) ;layer_info [ i ] . page . y = ReadBlobSignedLong ( image ) ;layer_info [ i ] . page . x = ReadBlobSignedLong ( image ) ;y = ReadBlobSignedLong ( image ) ;x = ReadBlobSignedLong ( image ) ;layer_info [ i ] . page . width = ( size_t ) ( x - layer_info [ i ] . page . x ) ;layer_info [ i ] . page . height = ( size_t ) ( y - layer_info [ i ] . page . y ) ;layer_info [ i ] . channels = ReadBlobShort ( image ) ;if ( layer_info [ i ] . channels > MaxPSDChannels ) {layer_info = DestroyLayerInfo ( layer_info , number_layers ) ;ThrowBinaryException ( CorruptImageError , ""MaximumChannelsExceeded"" , image -> filename ) ;}if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>channels=%.20g"" , ( double ) layer_info [ i ] . page . x , ( double ) layer_info [ i ] . page . y , ( double ) layer_info [ i ] . page . height , ( double ) layer_info [ i ] . page . width , ( double ) layer_info [ i ] . channels ) ;for ( j = 0 ;j < ( ssize_t ) layer_info [ i ] . channels ;j ++ ) {layer_info [ i ] . channel_info [ j ] . type = ( short ) ReadBlobShort ( image ) ;layer_info [ i ] . channel_info [ j ] . size = ( size_t ) GetPSDSize ( psd_info , image ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>channel[%.20g]:<S2SV_blank>type=%.20g,<S2SV_blank>size=%.20g"" , ( double ) j , ( double ) layer_info [ i ] . channel_info [ j ] . type , ( double ) layer_info [ i ] . channel_info [ j ] . size ) ;}count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ;ReversePSDString ( image , type , 4 ) ;if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>layer<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%.4s<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>8BIM"" , type ) ;layer_info = DestroyLayerInfo ( layer_info , number_layers ) ;ThrowBinaryException ( CorruptImageError , ""ImproperImageHeader"" , image -> filename ) ;}count = ReadBlob ( image , 4 , ( unsigned char * ) layer_info [ i ] . blendkey ) ;ReversePSDString ( image , layer_info [ i ] . blendkey , 4 ) ;layer_info [ i ] . opacity = ( Quantum ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;layer_info [ i ] . clipping = ( unsigned char ) ReadBlobByte ( image ) ;layer_info [ i ] . flags = ( unsigned char ) ReadBlobByte ( image ) ;layer_info [ i ] . visible = ! ( layer_info [ i ] . flags & 0x02 ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>blend=%.4s,<S2SV_blank>opacity=%.20g,<S2SV_blank>clipping=%s,<S2SV_blank>flags=%d,<S2SV_blank>visible=%s"" , layer_info [ i ] . blendkey , ( double ) layer_info [ i ] . opacity , layer_info [ i ] . clipping ? ""true"" : ""false"" , layer_info [ i ] . flags , layer_info [ i ] . visible ? ""true"" : ""false"" ) ;( void ) ReadBlobByte ( image ) ;size = ReadBlobLong ( image ) ;if ( size != 0 ) {MagickSizeType combined_length , length ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>contains<S2SV_blank>additional<S2SV_blank>info"" ) ;length = ReadBlobLong ( image ) ;combined_length = length + 4 ;if ( length != 0 ) {layer_info [ i ] . mask . page . y = ReadBlobSignedLong ( image ) ;layer_info [ i ] . mask . page . x = ReadBlobSignedLong ( image ) ;layer_info [ i ] . mask . page . height = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . y ) ;layer_info [ i ] . mask . page . width = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . x ) ;layer_info [ i ] . mask . background = ( unsigned char ) ReadBlobByte ( image ) ;layer_info [ i ] . mask . flags = ( unsigned char ) ReadBlobByte ( image ) ;if ( ! ( layer_info [ i ] . mask . flags & 0x01 ) ) {layer_info [ i ] . mask . page . y = layer_info [ i ] . mask . page . y - layer_info [ i ] . page . y ;layer_info [ i ] . mask . page . x = layer_info [ i ] . mask . page . x - layer_info [ i ] . page . x ;}if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>mask:<S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>length=%.20g"" , ( double ) layer_info [ i ] . mask . page . x , ( double ) layer_info [ i ] . mask . page . y , ( double ) layer_info [ i ] . mask . page . width , ( double ) layer_info [ i ] . mask . page . height , ( double ) ( ( MagickOffsetType ) length ) - 18 ) ;if ( DiscardBlobBytes ( image , ( MagickSizeType ) ( length - 18 ) ) == MagickFalse ) {","if ( DiscardBlobBytes ( image , length ) == MagickFalse ) {",1727
1264,"for ( j = 0 ;j += 8 )  {ThrowBinaryException ( CorruptImageError ,  ""InsufficientImageDataInFile"" , image -> filename ) ;}","for ( j = 0 ;j += 8 ) {ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ;}",1727
1265,"static PixelChannels * * AcquirePixelThreadSet ( const Image * image )  {size_t  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ;for ( i = 0 ;i < ( ssize_t ) number_threads ;i ++ )  {register ssize_t j ;pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns ,  sizeof ( * * pixels ) ) ;if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ;for ( j = 0 ;j < ( ssize_t ) image -> columns ;j ++ )  {","static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) {const Image * next ;size_t columns , number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( columns , sizeof ( * pixels ) ) ;columns = images -> columns ;for ( next = images ;next != ( Image * ) NULL ;next = next -> next ) columns = MagickMax ( next -> columns , columns ) ;for ( i = 0 ;i < ( ssize_t ) columns ;j ++ ) {",1728
1266,"if ( kwonlyargs == NULL ) {ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ;return - 1 ;}assert ( kwdefaults != NULL ) ;while ( i < NCH ( n ) ) {ch = CHILD ( n , i ) ;switch ( TYPE ( ch ) ) {case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) {","if ( TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) {",1729
1267,"if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;","if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;",1729
1268,"static void model_rd_for_sb_y ( VP9_COMP * cpi , BLOCK_SIZE bsize , MACROBLOCK * x , MACROBLOCKD * xd ,  int * out_rate_sum , int64_t * out_dist_sum ) {unsigned int sse ;struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ;int var = cpi -> fn_ptr [ bsize ] . vf ( p -> src . buf , p -> src . stride ,  pd -> dst . buf , pd -> dst . stride , & sse ) ;vp9_model_rd_from_var_lapndz ( sse + var , 1 << num_pels_log2_lookup [ bsize ] ,  pd -> dequant [ 1 ] >> 3 , & rate , & dist ) ;* out_rate_sum = rate ;}","static void model_rd_for_sb_y ( VP9_COMP * cpi , BLOCK_SIZE bsize , MACROBLOCK * x , MACROBLOCKD * xd , int * out_rate_sum , int64_t * out_dist_sum , unsigned int * var_y , unsigned int * sse_y ) {unsigned int sse ;const int64_t dc_thr = p -> quant_thred [ 0 ] >> 6 ;const int64_t ac_thr = p -> quant_thred [ 1 ] >> 6 ;const uint32_t dc_quant = pd -> dequant [ 0 ] ;const uint32_t ac_quant = pd -> dequant [ 1 ] ;unsigned struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ;int var = cpi -> fn_ptr [ bsize ] . vf ( p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride , & sse ) ;int skip_dc = 0 ;* var_y = var ;* sse_y = sse ;if ( cpi -> common . tx_mode == TX_MODE_SELECT ) {if ( sse > ( var << 2 ) ) xd -> mi [ 0 ] -> mbmi . tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ;else xd -> mi [ 0 ] -> mbmi . tx_size = TX_8X8 ;if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) ) xd -> mi [ 0 ] -> mbmi . tx_size = TX_8X8 ;else if ( xd -> mi [ 0 ] -> mbmi . tx_size > TX_16X16 ) xd -> mi [ 0 ] -> mbmi . tx_size = TX_16X16 ;}else {xd -> mi [ 0 ] -> mbmi . tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ;}{const BLOCK_SIZE unit_size = txsize_to_bsize [ xd -> mi [ 0 ] -> mbmi . tx_size ] ;const unsigned int num_blk_log2 = ( b_width_log2_lookup [ bsize ] - b_width_log2_lookup [ unit_size ] ) + ( b_height_log2_lookup [ bsize ] - b_height_log2_lookup [ unit_size ] ) ;const unsigned int sse_tx = sse >> num_blk_log2 ;const unsigned int var_tx = var >> num_blk_log2 ;x -> skip_txfm [ 0 ] = SKIP_TXFM_NONE ;if ( var_tx < ac_thr || var == 0 ) {x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_ONLY ;if ( sse_tx - var_tx < dc_thr || sse == var ) x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ;}else {if ( sse_tx - var_tx < dc_thr || sse == var ) skip_dc = 1 ;}}if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC ) {* out_rate_sum = 0 ;* out_dist_sum = sse << 4 ;return ;}if ( ! skip_dc ) {# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> ( xd -> bd - 5 ) , & rate , & dist ) ;}else {vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> 3 , & rate , & dist ) ;}# else vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> 3 , & rate , & dist ) ;# endif }if ( ! skip_dc ) {* out_rate_sum = rate >> 1 ;}else {* out_rate_sum = 0 ;* out_dist_sum = ( sse - var ) << 4 ;}# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> ( xd -> bd - 5 ) , & rate , & dist ) ;}else {vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> 3 , & rate , & dist ) ;}# else vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> 3 , & rate , & dist ) ;# endif * out_rate_sum += rate ;* out_dist_sum += dist << 4 ;}",1730
1269,"bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress ,  in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , in_what_stride ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",1731
1270,"thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;this_mv . as_mv . col = c ;","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride ) ;this_mv . as_mv . col = c ;",1731
1271,while ( buf [ len - 1 ] == 0x20 ) len -- ;},while ( ( len > 0 ) && ( buf [ len - 1 ] == 0x20 ) ) len -- ;},1732
1272,"* prev = NULL ;if ( vma -> vm_flags & ( VM_LOCKED | VM_NONLINEAR | VM_HUGETLB ) ) return - EINVAL ;if ( ! vma -> vm_file || ! vma -> vm_file -> f_mapping   || ! vma -> vm_file -> f_mapping -> host ) {return - EINVAL ;up_read ( & current -> mm -> mmap_sem ) ;error = do_fallocate ( vma -> vm_file ,  FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE ,  offset , end - start ) ;down_read ( & current -> mm -> mmap_sem ) ;","struct file * f ;* prev = NULL ;if ( vma -> vm_flags & ( VM_LOCKED | VM_NONLINEAR | VM_HUGETLB ) ) return - EINVAL ;f = vma -> vm_file ;if ( ! f || ! f -> f_mapping || ! vma -> vm_file -> f_mapping -> host ) {return - EINVAL ;get_file ( f ) ;up_read ( & current -> mm -> mmap_sem ) ;error = do_fallocate ( f , FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE , offset , end - start ) ;fput ( f ) ;down_read ( & current -> mm -> mmap_sem ) ;",1733
1273,"# endif  while ( ( ch = getopt ( ac , av , ""cDdksE:a:t:"" ) ) != - 1 ) {switch ( ch ) {case \'k\' :  k_flag ++ ;break ;","# endif while ( ( ch = getopt ( ac , av , ""cDdksE:a:P:t:"" ) ) != - 1 ) {switch ( ch ) {case \'k\' : k_flag ++ ;break ;case \'P\' : if ( pkcs11_whitelist != NULL ) fatal ( ""-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified"" ) ;pkcs11_whitelist = xstrdup ( optarg ) ;break ;",1734
1274,"if ( ac == 0 && ! c_flag && ! s_flag ) {shell = getenv ( ""SHELL"" ) ;","if ( pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ;if ( ac == 0 && ! c_flag && ! s_flag ) {shell = getenv ( ""SHELL"" ) ;",1734
1275,"if ( pledge ( ""stdio<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 )  fatal ( ""%s:<S2SV_blank>pledge:<S2SV_blank>%s"" , __progname , strerror ( errno ) ) ;","if ( pledge ( ""stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 ) fatal ( ""%s:<S2SV_blank>pledge:<S2SV_blank>%s"" , __progname , strerror ( errno ) ) ;",1734
1276,"register struct enamemem * tp ;if ( len == 0 ) return ( ""<empty>"" ) ;if ( tp -> e_name )  return ( tp -> e_name ) ;tp -> e_name = cp = ( char * ) malloc ( len * 3 ) ;if ( tp -> e_name == NULL )  ( * ndo -> ndo_error ) ( ndo , ""linkaddr_string:<S2SV_blank>malloc"" ) ;","register struct bsnamemem * tp ;if ( len == 0 ) return ( ""<empty>"" ) ;if ( tp -> bs_name ) return ( tp -> bs_name ) ;tp -> bs_name = cp = ( char * ) malloc ( len * 3 ) ;if ( tp -> bs_name == NULL ) ( * ndo -> ndo_error ) ( ndo , ""linkaddr_string:<S2SV_blank>malloc"" ) ;",1735
1277,return ( tp -> e_name ) ;},return ( tp -> bs_name ) ;},1735
1278,"truncate_pagecache ( inode , ioffset ) ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;goto out_dio ;}","ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;truncate_pagecache ( inode , ioffset ) ;goto out_mmap ;}",1736
1279,"inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ;ext4_mark_inode_dirty ( handle , inode ) ;out_stop : ext4_journal_stop ( handle ) ;out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ;",out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;ext4_inode_resume_unlocked_dio ( inode ) ;,1736
1280,"uint8_t buf [ 64 ] ;memcpy ( buf , msg , sizeof ( buf ) ) ;uint16_t msgId = buf [ 4 ] | ( ( uint16_t ) buf [ 3 ] ) << 8 ;uint32_t msgSize = buf [ 8 ] | ( ( uint32_t ) buf [ 7 ] ) << 8 | ( ( uint32_t ) buf [ 6 ] ) << 16 | ( ( uint32_t ) buf [ 5 ] ) << 24 ;if ( msgSize > 64 - 9 ) {( * msg_failure ) ( FailureType_Failure_UnexpectedMessage , ""Malformed<S2SV_blank>tiny<S2SV_blank>packet"" ) ;return ;}const MessagesMap_t * entry = message_map_entry ( NORMAL_MSG , msgId , IN_MSG ) ;if ( ! entry ) {( * msg_failure ) ( FailureType_Failure_UnexpectedMessage , ""Unknown<S2SV_blank>message"" ) ;return ;}tiny_dispatch ( entry , buf + 9 , msgSize ) ;","msg_read_tiny ( msg , len ) ;",1737
1281,kfree ( sbi ) ;},if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ;kfree ( sbi ) ;},1738
1282,return key ;},"rb_ivar_set ( self , id_key_set , Qtrue ) ;return key ;}",1739
1283,if ( NAPI_GRO_CB ( skb ) -> udp_mark ||  ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB ( skb ) -> csum_cnt == 0 && ! NAPI_GRO_CB ( skb ) -> csum_valid ) ) goto out ;NAPI_GRO_CB ( skb ) -> udp_mark = 1 ;rcu_read_lock ( ) ;,if ( NAPI_GRO_CB ( skb ) -> encap_mark || ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB ( skb ) -> encap_mark = 1 ;rcu_read_lock ( ) ;,1740
1284,if ( ! bitstream_read_bit ( bc ) ) {if ( hc -> current >= 256 ) {,"if ( length > SMKTREE_DECODE_MAX_RECURSION ) {av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\\return AVERROR_INVALIDDATA ;}if ( ! bitstream_read_bit ( bc ) ) {if ( hc -> current >= 256 ) {",1741
1285,ether_setup ( dev ) ;dev -> netdev_ops = & veth_netdev_ops ;,ether_setup ( dev ) ;dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & veth_netdev_ops ;,1742
1286,unsigned int h = 0 ;const char * data = ( const char * ) k ;while ( * data != 0 ) h = h * 129 + ( unsigned int ) ( * data ++ ) + LH_PRIME ;return h ;,"static volatile int random_seed = - 1 ;if ( random_seed == - 1 ) {int seed ;while ( ( seed = json_c_get_random_seed ( ) ) == - 1 ) ;# if defined __GNUC__ __sync_val_compare_and_swap ( & random_seed , - 1 , seed ) ;# elif defined _MSC_VER InterlockedCompareExchange ( & random_seed , seed , - 1 ) ;# else # warning ""racy<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>initializtion<S2SV_blank>if<S2SV_blank>used<S2SV_blank>by<S2SV_blank>multiple<S2SV_blank>threads"" random_seed = seed ;# endif }return hashlittle ( ( const char * ) k , strlen ( ( const char * ) k ) , random_seed ) ;",1743
1287,uid_t uid = getuid ( ) ;gid_t gid = getgid ( ) ;,"
",1744
1288,"if ( chown ( ""/tmp/"" , uid , gid ) < 0 ) {die ( ""cannot<S2SV_blank>change<S2SV_blank>ownership<S2SV_blank>of<S2SV_blank>/tmp"" ) ;","if ( chown ( ""/tmp/"" , 0 , 0 ) < 0 ) {die ( ""cannot<S2SV_blank>change<S2SV_blank>ownership<S2SV_blank>of<S2SV_blank>/tmp"" ) ;",1744
1289,if ( tsk -> io_context )  exit_io_context ( ) ;if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ;,if ( tsk -> io_context ) exit_io_context ( tsk ) ;if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ;,1745
1290,"if ( sock == INVALID_FD ) goto error ;if ( connect ( sock , ( const struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 )  goto error ;if ( send ( sock , & type , 1 , 0 ) != 1 )  goto error ;if ( send ( sock , & length , 2 , 0 ) != 2 )  goto error ;if ( send ( sock , packet , length , 0 ) != ( ssize_t ) length )  goto error ;","if ( TEMP_FAILURE_RETRY ( sock == INVALID_FD ) goto error ;if ( connect ( sock , ( const struct sockaddr * ) & addr , sizeof ( addr ) ) ) == - 1 ) goto error ;if ( TEMP_FAILURE_RETRY ( send ( sock , & type , 1 , 0 ) ) != 1 ) goto error ;if ( TEMP_FAILURE_RETRY ( send ( sock , & length , 2 , 0 ) ) != 2 ) goto error ;if ( TEMP_FAILURE_RETRY ( send ( sock , packet , length , 0 ) ) != ( ssize_t ) length ) goto error ;",1746
1291,"char buf [ L_BUF_SIZE ] ;char * rootname , * title , * xlabel , * ylabel , * ignores ;ret = fscanf ( fp , ""Gplot<S2SV_blank>Version<S2SV_blank>%d\\\if ( ret != 1 ) {fclose ( fp ) ;return ( GPLOT * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>gplot<S2SV_blank>file"" , procName , NULL ) ;}if ( version != GPLOT_VERSION_NUMBER ) {fclose ( fp ) ;return ( GPLOT * ) ERROR_PTR ( ""invalid<S2SV_blank>gplot<S2SV_blank>version"" , procName , NULL ) ;}ignore = fscanf ( fp , ""Rootname:<S2SV_blank>%s\\\rootname = stringNew ( buf ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;title = stringNew ( buf + 7 ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;xlabel = stringNew ( buf + 14 ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;ylabel = stringNew ( buf + 14 ) ;","char buf [ L_BUFSIZE ] ;char * rootname , * title , * xlabel , * ylabel , * ignores ;ret = fscanf ( fp , ""Rootname:<S2SV_blank>%511s\\\rootname = stringNew ( buf ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;title = stringNew ( buf + 7 ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;xlabel = stringNew ( buf + 14 ) ;ignores = fgets ( buf , L_BUFSIZE , fp ) ;ylabel = stringNew ( buf + 14 ) ;",1747
1292,"ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%s\\\stringReplace ( & gplot -> cmdname , buf ) ;ignore = fscanf ( fp , ""\\\gplot -> cmddata = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> datanames = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> plotdata = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> plottitles = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> plotstyles = numaReadStream ( fp ) ;ignore = fscanf ( fp , ""Number<S2SV_blank>of<S2SV_blank>plots:<S2SV_blank>%d\\\ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\\stringReplace ( & gplot -> outname , buf ) ;","ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\\stringReplace ( & gplot -> cmdname , buf ) ;ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\\stringReplace ( & gplot -> outname , buf ) ;",1747
1293,if ( addr > ( vdev -> config_len - sizeof ( val ) ) )  return ;,if ( addr + sizeof ( val ) ) ) return ;,1748
1294,"gdImagePtr pim = 0 , tim = im ;int interlace , BitsPerPixel ;interlace = im -> interlace ;if ( im -> trueColor ) {pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ;if ( ! pim ) {","_gdImageGifCtx ( im , 1 , 256 ) ;if ( ! pim ) {",1749
1295,},"
",1749
1296,"rc = fsmVerify ( fpath , fi ) ;}","rc = fsmVerify ( fpath , fi , & sb ) ;}",1750
1297,"n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ;n2s ( p , ticklen ) ;","if ( s -> session -> session_id_length > 0 ) {int i = s -> session_ctx -> session_cache_mode ;SSL_SESSION * new_sess ;if ( i & SSL_SESS_CACHE_CLIENT ) {if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) {if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ;}else {SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ;}}if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) {al = SSL_AD_INTERNAL_ERROR ;SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ;goto f_err ;}SSL_SESSION_free ( s -> session ) ;s -> session = new_sess ;}n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ;n2s ( p , ticklen ) ;",1751
1298,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ;switch ( dir ) {","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , addr ) ;switch ( dir ) {",1752
1299,"char data [ 8 ] ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;return - EIO ;}return - EIO ;}return brightness ;","char * data ;data = kmalloc ( 8 , GFP_KERNEL ) ;if ( ! data ) return - ENOMEM ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;ret = - EIO ;goto out ;}ret = - EIO ;goto out ;}ret = brightness ;out : kfree ( data ) ;return ret ;",1753
1300,error = 0 ;if ( pkt == NULL ) continue ;,error = 0 ;,1754
1301,"imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ;imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ;if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , ""Sending<S2SV_blank>LOGIN<S2SV_blank>command<S2SV_blank>for<S2SV_blank>%s...\\\","imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user , false ) ;imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass , false ) ;if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , ""Sending<S2SV_blank>LOGIN<S2SV_blank>command<S2SV_blank>for<S2SV_blank>%s...\\\",1755
1302,"netdev_dbg ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\\return - EBADR ;netdev_dbg ( vif -> dev ,   ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\\return - EINVAL ;","netdev_err ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\\netbk_fatal_tx_err ( vif ) ;return - EBADR ;netdev_err ( vif -> dev , ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;",1756
1303,"else if ( ! im -> gdes [ i ] . strftm && strstr ( im -> gdes [ i ] . format , ""%s"" ) != NULL ) {","else if ( bad_format_print ( im -> gdes [ i ] . format , ""%s"" ) != NULL ) {",1757
1304,"}rrd_set_error  ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>PRINT<S2SV_blank>in<S2SV_blank>\\\'%s\\\'"" , im -> gdes [ i ] . format ) ;",},1757
1305,"if ( im -> gdes [ i ] . strftm ) {strftime ( im -> gdes [ i ] . legend , FMT_LEG_LEN , im -> gdes [ i ] . format , & tmvdef ) ;if ( bad_format ( im -> gdes [ i ] . format ) ) {rrd_set_error  ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>GPRINT<S2SV_blank>in<S2SV_blank>\\\'%s\\\'"" , im -> gdes [ i ] . format ) ;","if ( bad_format_print ( im -> gdes [ i ] . legend , FMT_LEG_LEN , im -> gdes [ i ] . format , & tmvdef ) ;if ( bad_format ( im -> gdes [ i ] . format ) ) {",1757
1306,"umount_tree ( mnt , 0 ) ;}","if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) {struct mount * p , * tmp ;list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) {hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ;umount_mnt ( p ) ;}}else umount_tree ( mnt , 0 ) ;}",1758
1307,c -> sock = sock ;c -> id = id ;,"struct sockaddr_storage addr ;socklen_t len = sizeof ( addr ) ;getpeername ( sock , ( struct sockaddr * ) & addr , & len ) ;if ( addr . ss_family == AF_INET ) {struct sockaddr_in * s = ( struct sockaddr_in * ) & addr ;inet_ntop ( AF_INET , & s -> sin_addr , c -> remote , sizeof ( c -> remote ) ) ;}else {struct sockaddr_in6 * s = ( struct sockaddr_in6 * ) & addr ;inet_ntop ( AF_INET6 , & s -> sin6_addr , c -> remote , sizeof ( c -> remote ) ) ;}c -> sock = sock ;c -> id = id ;",1759
1308,"static int find_best_16x16_intra ( VP9_COMP * cpi ,  MB_PREDICTION_MODE * pbest_mode ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;MB_PREDICTION_MODE best_mode = - 1 , mode ;unsigned int best_err = INT_MAX ;vp9_predict_intra_block ( xd , 0 , 2 , TX_16X16 , mode ,  x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , 0 , 0 , 0 ) ;err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride ,  xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , best_err ) ;","static int find_best_16x16_intra ( VP9_COMP * cpi , PREDICTION_MODE * pbest_mode ) {MACROBLOCK * const x = & cpi -> td . mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PREDICTION_MODE best_mode = - 1 , mode ;unsigned int best_err = INT_MAX ;vp9_predict_intra_block ( xd , 2 , TX_16X16 , mode , x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , 0 , 0 , 0 ) ;err = vpx_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride ) ;",1760
1309,"printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;","printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;",1761
1310,s ++ )  if ( isupper ( * s ) || isdigit ( * s ) ) {* x ++ = * s ;}else if ( islower ( * s ) ) {if ( len < ( part <= 1 ? 5 : 3 ) ) * x ++ = * s ;,s ++ ) if ( isupper ( ( unsigned char ) * s ) || isdigit ( ( unsigned char ) * s ) ) {* x ++ = * s ;}else if ( islower ( ( unsigned char ) * s ) ) {if ( len < ( part <= 1 ? 5 : 3 ) ) * x ++ = * s ;,1761
1311,"err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen ,  transhdrlen , mtu , flags ) ;if ( err ) goto error ;","err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , transhdrlen , mtu , flags , rt ) ;if ( err ) goto error ;",1762
1312,"static vpx_codec_err_t vp8e_set_scalemode ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_set_scalemode ( vpx_codec_alg_priv_t * ctx , va_list args ) {",1763
1313,"memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) ,  vs_ie , vs_ie -> len + 2 ) ;","if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , vs_ie , vs_ie -> len + 2 ) ;",1764
1314,if ( serial -> port [ 0 ] == usbcons_info . port ) {usb_serial_console_exit ( ) ;,if ( serial -> port [ 0 ] && serial -> port [ 0 ] == usbcons_info . port ) {usb_serial_console_exit ( ) ;,1765
1315,PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;for ( p = val ;zval * * tmp ;namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ;,int skip = 0 ;PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;for ( p = val ;zval * * tmp ;skip = 0 ;namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ;,1766
1316,"efree ( name ) ;continue ;php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;}PS_ADD_VARL ( name , namelen ) ;efree ( name ) ;","skip = 1 ;if ( ! skip ) {php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;}}if ( ! skip ) {PS_ADD_VARL ( name , namelen ) ;}efree ( name ) ;",1766
1317,"char * decoded = url_decode ( url ) ;int has_nl = ! ! strchr ( decoded , '\\\free ( decoded ) ;if ( has_nl )  return - 1 ;","char * decoded ;const char * next ;int has_nl ;decoded = url_decode ( url ) ;has_nl = ! ! strchr ( decoded , '\\\free ( decoded ) ;if ( has_nl ) return - 1 ;if ( count_leading_dotdots ( url , & next ) > 0 && * next == ':' ) return - 1 ;",1767
1318,"static int64_t handle_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x ,  const TileInfo * const tile ,  BLOCK_SIZE bsize ,  int64_t txfm_cache [ ] ,   int * rate2 , int64_t * distortion ,   int * skippable ,  int * rate_y , int64_t * distortion_y ,  int * rate_uv , int64_t * distortion_uv ,  int * mode_excluded , int * disable_skip , INTERP_FILTER * best_filter , int_mv ( * mode_mv ) [ MAX_REF_FRAMES ] , int mi_row , int mi_col ,  int_mv single_newmv [ MAX_REF_FRAMES ] ,  int64_t * psse ,  const int64_t ref_best_rd ) {VP9_COMMON * cm = & cpi -> common ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;const int is_comp_pred = has_second_ref ( mbmi ) ;const int num_refs = is_comp_pred ? 2 : 1 ;const int this_mode = mbmi -> mode ;int64_t this_rd = 0 ;DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , tmp_buf , MAX_MB_PLANE * 64 * 64 ) ;int pred_exists = 0 ;int64_t rd , best_rd = INT64_MAX ;int best_needs_copy = 0 ;int rs = 0 ;if ( is_comp_pred ) {}if ( this_mode == NEWMV ) {","static int64_t handle_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int64_t txfm_cache [ ] , int * rate2 , int64_t * distortion , int * skippable , int * rate_y , int64_t * distortion_y , int * rate_y , int * rate_uv , int * mode_excluded , int * disable_skip , int_mv ( * mode_mv ) [ MAX_REF_FRAMES ] , int mi_row , int mi_col , int_mv single_newmv [ MAX_REF_FRAMES ] , INTERP_FILTER ( * single_filter ) [ MAX_REF_FRAMES ] , int ( * single_skippable ) [ MAX_REF_FRAMES ] , int64_t * psse , const int64_t ref_best_rd , int64_t * mask_filter , int64_t filter_cache [ ] ) {VP9_COMMON * cm = & cpi -> common ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ;const int this_mode = mbmi -> mode ;# if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint8_t , tmp_buf , MAX_MB_PLANE * 64 * 64 ] ) ;# endif int pred_exists = 0 ;int64_t rd , tmp_rd , best_rd = INT64_MAX ;int best_needs_copy = 0 ;INTERP_FILTER best_filter = SWITCHABLE ;uint8_t skip_txfm [ MAX_MB_PLANE << 2 ] = {0 };int64_t bsse [ MAX_MB_PLANE << 2 ] = {0 };int bsl = mi_width_log2_lookup [ bsize ] ;int pred_filter_search = cpi -> sf . cb_pred_filter_search ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ;int skip_txfm_sb = 0 ;int64_t skip_sse_sb = INT64_MAX ;int64_t distortion_y = 0 , distortion_uv = 0 ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {tmp_buf = CONVERT_TO_BYTEPTR ( tmp_buf16 ) ;}else {tmp_buf = ( uint8_t * ) tmp_buf16 ;}# endif if ( pred_filter_search ) {INTERP_FILTER af = SWITCHABLE , lf = SWITCHABLE ;if ( xd -> up_available ) af = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ;if ( xd -> left_available ) lf = xd -> mi [ - 1 ] -> mbmi . interp_filter ;if ( ( this_mode != NEWMV ) || ( af == lf ) ) best_filter = af ;}int rs = 0 ;if ( is_comp_pred ) {if ( cpi -> sf . adaptive_mode_search ) {if ( single_filter [ this_mode ] [ refs [ 0 ] ] == single_filter [ this_mode ] [ refs [ 1 ] ] ) best_filter = single_filter [ this_mode ] [ refs [ 0 ] ] ;}}if ( this_mode == NEWMV ) {",1768
1319,"rate_mv = vp9_mv_bit_cost ( & frame_mv [ refs [ 0 ] ] . as_mv ,  & mbmi -> ref_mvs [ refs [ 0 ] ] [ 0 ] . as_mv ,  x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ 1 ] ] . as_mv ,  & mbmi -> ref_mvs [ refs [ 1 ] ] [ 0 ] . as_mv ,  x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;single_motion_search ( cpi , x , tile , bsize , mi_row , mi_col ,  & tmp_mv , & rate_mv ) ;* rate2 += rate_mv ;frame_mv [ refs [ 0 ] ] . as_int =  xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ;for ( i = 0 ;cur_mv [ i ] = frame_mv [ refs [ i ] ] ;i < MAX_MB_PLANE ;i ++ ) {orig_dst [ i ] = xd -> plane [ i ] . dst . buf ;orig_dst_stride [ i ] = xd -> plane [ i ] . dst . stride ;}* rate2 += cost_mv_ref ( cpi , this_mode , mbmi -> mode_context [ refs [ 0 ] ] ) ;if ( ! ( * mode_excluded ) ) * mode_excluded = is_comp_pred ? cm -> reference_mode == SINGLE_REFERENCE : cm -> reference_mode == COMPOUND_REFERENCE ;pred_exists = 0 ;intpel_mv = ! mv_has_subpel ( & mbmi -> mv [ 0 ] . as_mv ) ;if ( is_comp_pred ) intpel_mv &= ! mv_has_subpel ( & mbmi -> mv [ 1 ] . as_mv ) ;cpi -> mask_filter_rd = 0 ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;++ i )  cpi -> rd_filter_cache [ i ] = INT64_MAX ;if ( cm -> interp_filter != BILINEAR ) {* best_filter = EIGHTTAP ;if ( x -> source_variance < cpi -> sf . disable_filter_search_var_thresh ) {* best_filter = EIGHTTAP ;}else {int newbest ;","rate_mv = vp9_mv_bit_cost ( & frame_mv [ refs [ 0 ] ] . as_mv , & x -> mbmi_ext -> ref_mvs [ refs [ 0 ] ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ 1 ] ] . as_mv , & x -> mbmi_ext -> ref_mvs [ refs [ 1 ] ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;single_motion_search ( cpi , x , bsize , mi_row , mi_col , & tmp_mv , & rate_mv ) ;frame_mv [ refs [ 0 ] ] . as_int = xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ;if ( discount_newmv_test ( cpi , this_mode , tmp_mv , mode_mv , refs [ 0 ] ) ) {* rate2 += MAX ( ( rate_mv / NEW_MV_DISCOUNT_FACTOR ) , 1 ) ;}else {* rate2 += rate_mv ;}for ( i = 0 ;cur_mv [ i ] = frame_mv [ refs [ i ] ] ;+ i )  cpi -> rd_filter_cache [ i ] = INT64_MAX ;i < is_comp_pred + 1 ;++ i ) cpi -> rd_filter_cache [ i ] = INT64_MAX ;if ( cm -> interp_filter != BILINEAR ) {* best_filter = EIGHTTAP ;if ( x -> source_variance < cpi -> sf . disable_filter_search_var_thresh ) {* best_filter = EIGHTTAP ;}else if ( best_filter == SWITCHABLE ) {int newbest ;",1768
1320,"mbmi -> interp_filter = i ;rs = vp9_get_switchable_rate ( x ) ;rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ;cpi -> rd_filter_cache [ i ] = rd ;cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] =   MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ;if ( cm -> interp_filter == SWITCHABLE ) rd += rs_rd ;cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ;}int64_t dist_sum = 0 ;if ( ( cm -> interp_filter == SWITCHABLE && ( ! i || best_needs_copy ) ) || ( cm -> interp_filter != SWITCHABLE && ( cm -> interp_filter == mbmi -> interp_filter || ( i == 0 && intpel_mv ) ) ) ) {","int tmp_skip_sb = 0 ;int64_t tmp_skip_sse = INT64_MAX ;mbmi -> interp_filter = i ;rs = vp9_get_switchable_rate ( x ) ;rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ;filter_cache [ i ] = rd ;cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ;if ( cm -> interp_filter == SWITCHABLE ) rd += rs_rd ;cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ;}int64_t dist_sum = 0 ;if ( ( cm -> interp_filter == SWITCHABLE && ( ! i || best_needs_copy ) ) || ( cm -> interp_filter != SWITCHABLE && ( cm -> interp_filter == mbmi -> interp_filter || ( i == 0 && intpel_mv ) ) ) ) {",1768
1321,"model_rd_for_sb ( cpi , bsize , x , xd , & rate_sum , & dist_sum ) ;rd = RDCOST ( x -> rdmult , x -> rddiv , rate_sum , dist_sum ) ;cpi -> rd_filter_cache [ i ] = rd ;cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] =   MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ;if ( cm -> interp_filter == SWITCHABLE ) rd += rs_rd ;cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ;if ( i == 0 && intpel_mv ) {","model_rd_for_sb ( cpi , bsize , x , xd , & rate_sum , & dist_sum ) ;rd = RDCOST ( x -> rdmult , x -> rddiv , rate_sum , dist_sum ) ;cpi -> rd_filter_cache [ i ] = rd ;filter_cache [ SWITCHABLE_FILTERS ] = MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ;if ( cm -> interp_filter == SWITCHABLE ) rd += rs_rd ;* mask_filter = MAX ( cpi -> mask_filter_rd , rd ) ;if ( i == 0 && intpel_mv ) {",1768
1322,"* best_filter = mbmi -> interp_filter ;if ( cm -> interp_filter == SWITCHABLE && i && ! intpel_mv ) best_needs_copy = ! best_needs_copy ;}}mbmi -> interp_filter = cm -> interp_filter != SWITCHABLE ?  cm -> interp_filter : * best_filter ;rs = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( x ) : 0 ;if ( pred_exists ) {}vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ;}if ( cpi -> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) {int tmp_rate ;int64_t tmp_dist ;model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist ) ;if ( cm -> interp_filter == SWITCHABLE )  * rate2 += vp9_get_switchable_rate ( x ) ;if ( ! is_comp_pred ) {if ( ! x -> in_active_map ) {if ( psse ) * psse = 0 ;* distortion = 0 ;x -> skip = 1 ;}const BLOCK_SIZE y_size = get_plane_block_size ( bsize , & xd -> plane [ 0 ] ) ;","best_filter = mbmi -> interp_filter ;if ( cm -> interp_filter == SWITCHABLE && i && ! intpel_mv ) best_needs_copy = ! best_needs_copy ;tmp_rd = best_rd ;skip_txfm_sb = tmp_skip_sb ;skip_sse_sb = tmp_skip_sse ;memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ;memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ;}}mbmi -> interp_filter = cm -> interp_filter != SWITCHABLE ? cm -> interp_filter : best_filter ;rs = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( cpi , xd ) : 0 ;if ( pred_exists ) {if ( i > 0 && cpi -> sf . adaptive_interp_filter_search && ( cpi -> sf . interp_filter_search_mask & ( 1 << i ) ) ) {rate_sum = INT_MAX ;dist_sum = INT64_MAX ;continue ;}rd = tmp_rd + RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ;}int tmp_rate ;int64_t tmp_dist ;vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ;model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist , & skip_txfm_sb , & skip_sse_sb ) ;memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ;memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ;}if ( ! is_comp_pred ) single_filter [ this_mode ] [ refs [ 0 ] ] = mbmi -> interp_filter ;if ( cpi -> sf . adaptive_mode_search ) if ( is_comp_pred ) if ( single_skippable [ this_mode ] [ refs [ 0 ] ] && single_skippable [ this_mode ] [ refs [ 1 ] ] ) memset ( skip_txfm , SKIP_TXFM_AC_DC , sizeof ( skip_txfm ) ) ;if ( cpi -> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) {if ( cm -> interp_filter == SWITCHABLE ) * rate2 += vp9_get_switchable_rate ( x ) ;if ( ! is_comp_pred ) {if ( ! x -> in_active_map ) {if ( psse ) * psse = 0 ;* distortion = 0 ;x -> skip = 1 ;}const BLOCK_SIZE y_size = get_plane_block_size ( bsize , & xd -> plane [ 0 ] ) ;",1768
1323,"* rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;* distortion_uv = ( sse_u + sse_v ) << 4 ;* distortion = ( sse << 4 ) + * distortion_uv ;* disable_skip = 1 ;this_rd = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ;}}}}}}if ( ! x -> skip ) {int skippable_y , skippable_uv ;int64_t sseuv = INT64_MAX ;int64_t rdcosty = INT64_MAX ;inter_super_block_yrd ( cpi , x , rate_y , distortion_y , & skippable_y , psse , bsize , txfm_cache , ref_best_rd ) ;return INT64_MAX ;}","* rate2 += rs ;memcpy ( x -> skip_txfm , skip_txfm , sizeof ( skip_txfm ) ) ;memcpy ( x -> bsse , bsse , sizeof ( bsse ) ) ;return INT64_MAX ;}",1768
1324,"return INT64_MAX ;}* psse += sseuv ;* rate2 += * rate_uv ;* distortion += * distortion_uv ;* skippable = skippable_y && skippable_uv ;}restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ;return this_rd ;",return 0 ;,1768
1325,"char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;",1769
1326,"return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb ,  jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ;","return ( tsfb -> numlvls > 0 && jas_seq2d_size ( a ) ) ? jpc_tsfb_synthesize2 ( tsfb , jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ;",1770
1327,for ( y = 0 ;y += ( ssize_t ) level )  {,"status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}for ( y = 0 ;y += ( ssize_t ) level ) {",1771
1328,"void vp9_entropy_mv_init ( ) {vp9_tokens_from_tree ( mv_joint_encodings , vp9_mv_joint_tree ) ;","void vp9_entropy_mv_init ( void ) {vp9_tokens_from_tree ( mv_joint_encodings , vp9_mv_joint_tree ) ;",1772
1329,"
",lsa -> l2tp_conn_id = 0 ;,1773
1330,if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL )  lsa -> l2tp_scope_id = IP6CB ( skb ) -> iif ;,if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) lsa -> l2tp_scope_id = IP6CB ( skb ) -> iif ;,1773
1331,char buf [ L_BUF_SIZE ] ;l_int32 badchar ;,char buf [ L_BUFSIZE ] ;l_int32 badchar ;,1774
1332,"snprintf ( buf , L_BUF_SIZE , ""%s.cmd"" , rootname ) ;gplot -> cmdname = stringNew ( buf ) ;if ( outformat == GPLOT_PNG )  snprintf ( buf , L_BUF_SIZE , ""%s.png"" , newroot ) ;else if ( outformat == GPLOT_PS )  snprintf ( buf , L_BUF_SIZE , ""%s.ps"" , newroot ) ;else if ( outformat == GPLOT_EPS )  snprintf ( buf , L_BUF_SIZE , ""%s.eps"" , newroot ) ;else if ( outformat == GPLOT_LATEX )  snprintf ( buf , L_BUF_SIZE , ""%s.tex"" , newroot ) ;gplot -> outname = stringNew ( buf ) ;","snprintf ( buf , L_BUFSIZE , ""%s.cmd"" , rootname ) ;gplot -> cmdname = stringNew ( buf ) ;if ( outformat == GPLOT_PNG ) snprintf ( buf , L_BUFSIZE , ""%s.png"" , newroot ) ;else if ( outformat == GPLOT_PS ) snprintf ( buf , L_BUFSIZE , ""%s.ps"" , newroot ) ;else if ( outformat == GPLOT_EPS ) snprintf ( buf , L_BUFSIZE , ""%s.eps"" , newroot ) ;else if ( outformat == GPLOT_LATEX ) snprintf ( buf , L_BUFSIZE , ""%s.tex"" , newroot ) ;gplot -> outname = stringNew ( buf ) ;",1774
1333,if ( sbinfo -> max_blocks >= 0 ) {buf -> f_blocks = sbinfo -> max_blocks ;buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ;buf -> f_files = sbinfo -> max_inodes ;,if ( sbinfo -> spool ) {long free_pages ;spin_lock ( & sbinfo -> spool -> lock ) ;buf -> f_blocks = sbinfo -> spool -> max_hpages ;free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages ;buf -> f_bavail = buf -> f_bfree = free_pages ;spin_unlock ( & sbinfo -> spool -> lock ) ;buf -> f_files = sbinfo -> max_inodes ;,1775
1334,"static inline void header_put_le_int ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 )   {psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ;psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ;};}","static inline void header_put_le_int ( SF_PRIVATE * psf , int x ) {psf -> header ) - 4 ) {psf -> header . ptr [ psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ;psf -> header . indx ++ ] = ( x >> 24 ) ;}",1776
1335,"ret = _krb5_principalname2krb5_principal ( context , & r -> server_princ , * ( b -> sname ) , b -> realm ) ;if ( ret == 0 ) ret = krb5_unparse_name ( context , r -> server_princ , & r -> server_name ) ;}if ( ret ) {kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>malformed<S2SV_blank>server<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s"" , from ) ;goto out ;}if ( b -> cname == NULL ) {ret = KRB5KRB_ERR_GENERIC ;_kdc_set_e_text ( r , ""No<S2SV_blank>client<S2SV_blank>in<S2SV_blank>request"" ) ;}else {ret = _krb5_principalname2krb5_principal ( context , & r -> client_princ , * ( b -> cname ) , b -> realm ) ;","ret = _krb5_principalname2krb5_principal ( context , & r -> server_princ , r -> client_princ , * ( b -> cname ) , b -> realm ) ;",1777
1336,"ret = _kdc_db_fetch ( context , config , r -> client_princ , HDB_F_GET_CLIENT | flags , NULL , & r -> clientdb , & r -> client ) ;if ( ret == HDB_ERR_NOT_FOUND_HERE ) {kdc_log ( context , config , 5 , ""client<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> client_name ) ;goto out ;}else if ( ret == HDB_ERR_WRONG_REALM ) {char * fixed_client_name = NULL ;ret = krb5_unparse_name ( context , r -> client -> entry . principal , & fixed_client_name ) ;if ( ret ) {goto out ;}kdc_log ( context , config , 0 , ""WRONG_REALM<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s"" , r -> client_name , fixed_client_name ) ;free ( fixed_client_name ) ;ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , KRB5_KDC_ERR_WRONG_REALM , NULL , r -> server_princ , NULL , & r -> client -> entry . principal -> realm , NULL , NULL , reply ) ;goto out ;}else if ( ret ) {const char * msg = krb5_get_error_message ( context , ret ) ;kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> client_name , msg ) ;krb5_free_error_message ( context , msg ) ;ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ;goto out ;}ret = _kdc_db_fetch ( context , config , r -> server_princ , HDB_F_GET_SERVER | HDB_F_GET_KRBTGT | flags , NULL , NULL , & r -> server ) ;if ( ret == HDB_ERR_NOT_FOUND_HERE ) {kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> server_name ) ;goto out ;}else if ( ret ) {const char * msg = krb5_get_error_message ( context , ret ) ;kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> server_name , msg ) ;krb5_free_error_message ( context , msg ) ;ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ;goto out ;}ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , r -> server_princ ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , r -> client , b -> etype . val , b -> etype . len , & r -> sessionetype , NULL ) ;if ( ret ) {kdc_log ( context , config , 0 , ""Client<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>common<S2SV_blank>enctypes<S2SV_blank>with<S2SV_blank>KDC<S2SV_blank>"" ""to<S2SV_blank>use<S2SV_blank>for<S2SV_blank>the<S2SV_blank>session<S2SV_blank>key"" , r -> client_name , from ) ;goto out ;}if ( req -> padata ) {unsigned int n ;log_patypes ( context , config , req -> padata ) ;for ( n = 0 ;! found_pa && n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ;n ++ ) {if ( pat [ n ] . validate == NULL ) continue ;if ( r -> armor_crypto == NULL && ( pat [ n ] . flags & PA_REQ_FAST ) ) continue ;kdc_log ( context , config , 5 , ""Looking<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>pa-data<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ;i = 0 ;pa = _kdc_find_padata ( req , & i , pat [ n ] . type ) ;if ( pa ) {ret = pat [ n ] . validate ( r , pa ) ;if ( ret != 0 ) {goto out ;}kdc_log ( context , config , 0 , ""%s<S2SV_blank>pre-authentication<S2SV_blank>succeeded<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ;found_pa = 1 ;r -> et . flags . pre_authent = 1 ;}}}if ( found_pa == 0 ) {Key * ckey = NULL ;size_t n ;for ( n = 0 ;n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ;n ++ ) {if ( ( pat [ n ] . flags & PA_ANNOUNCE ) == 0 ) continue ;ret = krb5_padata_add ( context , & error_method , pat [ n ] . type , NULL , 0 ) ;if ( ret ) goto out ;}ret = _kdc_find_etype ( context , config -> preauth_use_strongest_session_key , TRUE , r -> client , b -> etype . val , b -> etype . len , NULL , & ckey ) ;if ( ret == 0 ) {if ( older_enctype ( ckey -> key . keytype ) ) {ret = get_pa_etype_info ( context , config , & error_method , ckey ) ;if ( ret ) goto out ;}ret = get_pa_etype_info2 ( context , config , & error_method , ckey ) ;if ( ret ) goto out ;}if ( require_preauth_p ( r ) || _kdc_is_anon_request ( b ) ) {ret = KRB5KDC_ERR_PREAUTH_REQUIRED ;_kdc_set_e_text ( r , ""Need<S2SV_blank>to<S2SV_blank>use<S2SV_blank>PA-ENC-TIMESTAMP/PA-PK-AS-REQ"" ) ;goto out ;}if ( ckey == NULL ) {ret = KRB5KDC_ERR_CLIENT_NOTYET ;_kdc_set_e_text ( r , ""Doesn\\\'t<S2SV_blank>have<S2SV_blank>a<S2SV_blank>client<S2SV_blank>key<S2SV_blank>available"" ) ;goto out ;}krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ;ret = krb5_copy_keyblock_contents ( r -> context , & ckey -> key , & r -> reply_key ) ;if ( ret ) goto out ;}if ( r -> clientdb -> hdb_auth_status ) {r -> clientdb -> hdb_auth_status ( context , r -> clientdb , r -> client , HDB_AUTH_SUCCESS ) ;}ret = _kdc_check_access ( context , config , r -> client , r -> client_name , r -> server , r -> server_name , req , & error_method ) ;if ( ret ) goto out ;ret = _kdc_get_preferred_key ( context , config , r -> server , r -> server_name , & setype , & skey ) ;if ( ret ) goto out ;if ( f . renew || f . validate || f . proxy || f . forwarded || f . enc_tkt_in_skey || ( _kdc_is_anon_request ( b ) && ! config -> allow_anonymous ) ) {ret = KRB5KDC_ERR_BADOPTION ;_kdc_set_e_text ( r , ""Bad<S2SV_blank>KDC<S2SV_blank>options"" ) ;goto out ;}rep . pvno = 5 ;rep . msg_type = krb_as_rep ;if ( _kdc_is_anonymous ( context , r -> client_princ ) ) {","ret = _kdc_db_fetch ( context , config , r -> client_princ ? & r -> client_princ -> name : NULL , r -> client_princ ) ) {",1777
1337,"ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , ret , r -> e_text , r -> server_princ ,  & r -> client_princ -> name ,   & r -> client_princ -> realm ,  NULL , NULL , reply ) ;","ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , ret , r -> e_text , r -> server_princ , & r -> client_princ ? & r -> client_princ -> realm : NULL , NULL , NULL , reply ) ;",1777
1338,"while ( bytes ) {int copy = min ( bytes , iov -> iov_len - base ) ;","while ( bytes || ! iov -> iov_len ) {int copy = min ( bytes , iov -> iov_len - base ) ;",1778
1339,reordered [ len + 1 ] = Mymr_C_RA ;,if ( len > 0 ) reordered [ len + 1 ] = Mymr_C_RA ;,1779
1340,reordered [ len + 1 ] = Mymr_C_VIRAMA ;properties [ len - 1 ] = AboveForm ;,reordered [ len + 1 ] = Mymr_C_VIRAMA ;properties [ len - 1 ] = AboveForm ;,1779
1341,"struct gs_host_config hconf = {. byte_order = 0x0000beef , };struct gs_device_config dconf ;rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber ,  & hconf ,   sizeof ( hconf ) ,  1000 ) ;if ( rc < 0 ) {dev_err ( & intf -> dev , ""Couldn\\\'t<S2SV_blank>send<S2SV_blank>data<S2SV_blank>format<S2SV_blank>(err=%d)\\\}rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber ,  & dconf ,   sizeof ( dconf ) ,  1000 ) ;return rc ;}icount = dconf . icount + 1 ;return - EINVAL ;}if ( ! dev )  return - ENOMEM ;init_usb_anchor ( & dev -> rx_submitted ) ;atomic_set ( & dev -> active_channels , 0 ) ;dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ;if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) {kfree ( dev ) ;return rc ;return 0 ;}","struct gs_host_config * hconf ;struct gs_device_config dconf ;rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , hconf , sizeof ( * hconf ) , 1000 ) ;kfree ( hconf ) ;if ( rc < 0 ) {dev_err ( & intf -> dev , ""Couldn\\\'t<S2SV_blank>send<S2SV_blank>data<S2SV_blank>format<S2SV_blank>(err=%d)\\\}dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ;if ( ! dconf ) return - ENOMEM ;rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , dconf , sizeof ( * dconf ) , 1000 ) ;kfree ( dconf ) ;return rc ;}icount = dconf -> icount + 1 ;kfree ( dconf ) ;return - EINVAL ;}if ( ! dev ) {kfree ( dconf ) ;return - ENOMEM ;}init_usb_anchor ( & dev -> rx_submitted ) ;atomic_set ( & dev -> active_channels , 0 ) ;dev -> canch [ i ] = gs_make_candev ( i , intf , dconf ) ;if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) {kfree ( dconf ) ;kfree ( dev ) ;return rc ;kfree ( dconf ) ;return 0 ;}",1780
1342,mlock_vma_page ( page ) ;if ( page == check_page )   ret = SWAP_MLOCK ;continue ;,if ( page == check_page ) {mlock_vma_page ( page ) ;ret = SWAP_MLOCK ;}else if ( trylock_page ( page ) ) {mlock_vma_page ( page ) ;unlock_page ( page ) ;}continue ;,1781
1343,"
","run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""%2f?"" ) , CONST_STR_LEN ( ""/?"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f?"" ) , CONST_STR_LEN ( ""//?"" ) ) ;",1782
1344,"run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;","run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;",1782
1345,"char * ext , szName [ 1000 ] , szExt [ 20 ] ;const char * szExtList ;","char * ext , szName [ 1024 ] , szExt [ 20 ] ;const char * szExtList ;",1783
1346,"strcpy ( szName , url ) ;ext = strrchr ( szName , \'#\' ) ;if ( ext && strlen ( ext ) > 1 ) {strcpy ( szExt , & ext [ 1 ] ) ;","if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ;strcpy ( szName , url ) ;ext = strrchr ( szName , \'#\' ) ;if ( ext && strlen ( ext ) > 1 && strlen ( ext ) <= sizeof ( szExt ) ) {strcpy ( szExt , & ext [ 1 ] ) ;",1783
1347,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><N-M|N/M>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><N-M|N/M>\\\",1784
1348,"static void  l2tp_msgtype_print ( netdissect_options * ndo , const u_char * dat )  {const uint16_t * ptr = ( const uint16_t * ) dat ;ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_msgtype2str , ""MSGTYPE-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ;","static void l2tp_msgtype_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint16_t * ptr = ( const uint16_t * ) dat ;if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_msgtype2str , ""MSGTYPE-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ;",1785
1349,while ( isspace ( * p ) )  p ++ ;,while ( isspace ( ( unsigned char ) * p ) ) p ++ ;,1786
1350,"if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) {ret = ext4_jbd2_file_inode ( handle , inode ) ;if ( ret ) {unlock_page ( page ) ;put_page ( page ) ;goto errout ;}}","
",1787
1351,"
",GTextFieldSaved ( gt ) ;,1788
1352,},},1788
1353,"static struct ip_options * tcp_v4_save_options ( struct sock * sk ,  struct sk_buff * skb ) {struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ;struct ip_options * dopt = NULL ;if ( opt && opt -> optlen ) {int opt_size = optlength ( opt ) ;dopt = kmalloc ( opt_size , GFP_ATOMIC ) ;if ( ip_options_echo ( dopt , skb ) ) {kfree ( dopt ) ;","static struct ip_options_rcu * tcp_v4_save_options ( struct sock * sk , struct sk_buff * skb ) {const struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ;struct ip_options_rcu * dopt = NULL ;if ( opt && opt -> optlen ) {int opt_size = sizeof ( * dopt ) + opt -> optlen ;dopt = kmalloc ( opt_size , GFP_ATOMIC ) ;if ( ip_options_echo ( & dopt -> opt , skb ) ) {kfree ( dopt ) ;",1789
1354,"env -> used_maps [ env -> used_map_cnt ++ ] = map ;bpf_map_inc ( map , false ) ;fdput ( f ) ;","map = bpf_map_inc ( map , false ) ;if ( IS_ERR ( map ) ) {fdput ( f ) ;return PTR_ERR ( map ) ;}env -> used_maps [ env -> used_map_cnt ++ ] = map ;fdput ( f ) ;",1790
1355,unsigned fat_length ;unsigned total_fat_entries ;,off_t fat_length ;unsigned total_fat_entries ;,1791
1356,"fs -> fat_start = ( off_t ) le16toh ( b . reserved ) * logical_sector_size ;fs -> root_start = ( ( off_t ) le16toh ( b . reserved ) + b . fats * fat_length ) * logical_sector_size ;fs -> data_start = fs -> root_start + ROUND_TO_MULTIPLE ( fs -> root_entries << MSDOS_DIR_BITS , logical_sector_size ) ;data_size = ( off_t ) total_sectors * logical_sector_size - fs -> data_start ;fs -> data_clusters = data_size / fs -> cluster_size ;","if ( ! fat_length ) die ( ""FAT<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ;fs -> fat_start = ( off_t ) le16toh ( b . reserved ) * logical_sector_size ;fs -> root_start = ( ( off_t ) le16toh ( b . reserved ) + b . fats * fat_length ) * logical_sector_size ;fs -> data_start ;if ( data_size < fs -> cluster_size ) die ( ""Filesystem<S2SV_blank>has<S2SV_blank>no<S2SV_blank>space<S2SV_blank>for<S2SV_blank>any<S2SV_blank>data<S2SV_blank>clusters"" ) = fs -> root_start + ROUND_TO_MULTIPLE ( fs -> root_entries << MSDOS_DIR_BITS , logical_sector_size ) ;data_size = ( off_t ) total_sectors * logical_sector_size - fs -> data_start ;fs -> data_clusters = data_size / fs -> cluster_size ;",1791
1357,"if ( ! rta )  return 0 ;p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ;if ( ! p ) return - ENOMEM ;pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ;if ( ! pp ) {* replay_esn = p ;* preplay_esn = pp ;","int klen , ulen ;if ( ! rta ) return 0 ;klen = xfrm_replay_state_esn_len ( up ) ;ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ;p = kzalloc ( klen , GFP_KERNEL ) ;if ( ! p ) return - ENOMEM ;pp = kzalloc ( klen , GFP_KERNEL ) ;if ( ! pp ) {memcpy ( p , up , ulen ) ;memcpy ( pp , up , ulen ) ;* replay_esn = p ;* preplay_esn = pp ;",1792
1358,"u64 nsec = ( u64 ) jiffies * TICK_NSEC ;long tv_usec ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tv_usec ) ;tv_usec /= NSEC_PER_USEC ;value -> tv_usec = tv_usec ;}","u32 rem ;value -> tv_sec = div_u64_rem ( ( u64 ) jiffies * TICK_NSEC , NSEC_PER_SEC , & tv_usec ) ;tv_usec /= NSEC_PER_USEC ;value -> tv_usec = rem / NSEC_PER_USEC ;}",1793
1359,"for ( i = 1 ;i <= SYSTEM_ID_LEN ;snprintf ( pos , sizeof ( id ) - ( pos - id ) , ""%02x"" , * cp ++ ) ;","int sysid_len ;sysid_len = SYSTEM_ID_LEN ;if ( sysid_len > id_len ) sysid_len = id_len ;for ( i = 1 ;i <= sysid_len ;snprintf ( pos , sizeof ( id ) - ( pos - id ) , ""%02x"" , * cp ++ ) ;",1794
1360,assert ( 0 ) ;return NULL ;,return NULL ;,1795
1361,size_t len = 0 ;lua_pushnil ( L ) ;,"size_t len = 0 ;luaL_checkstack ( L , 3 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map"" ) ;lua_pushnil ( L ) ;",1796
1362,struct ip_options * opt ;struct inet_sock * sk_inet ;opt = sk_inet -> opt ;if ( opt == NULL || opt -> cipso == 0 )  return ;hdr_delta = cipso_v4_delopt ( & sk_inet -> opt ) ;if ( sk_inet -> is_icsk && hdr_delta > 0 ) {,"struct ip_options_rcu * opt ;struct inet_sock * sk_inet ;opt = rcu_dereference_protected ( sk_inet -> inet_opt , 1 ) ;if ( opt == NULL || opt -> opt . cipso == 0 ) return ;hdr_delta = cipso_v4_delopt ( & sk_inet -> inet_opt ) ;if ( sk_inet -> is_icsk && hdr_delta > 0 ) {",1797
1363,if ( p -> question -> n_keys != 1 )  return 0 ;,if ( ! p -> question ) return 0 ;if ( p -> question -> n_keys != 1 ) return 0 ;,1798
1364,if ( tu -> timeri )   snd_timer_close ( tu -> timeri ) ;kfree ( tu -> queue ) ;,mutex_lock ( & tu -> ioctl_lock ) ;if ( tu -> timeri ) ;mutex_unlock ( & tu -> ioctl_lock ) snd_timer_close ( tu -> timeri ) ;kfree ( tu -> queue ) ;,1799
1365,si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ;if ( ! ( si -> h | si -> w ) )   res = VPX_CODEC_UNSUP_BITSTREAM ;}else  {,si -> h && si -> w ) ) res = VPX_CODEC_CORRUPT_FRAME ;}else {res = VPX_CODEC_UNSUP_BITSTREAM ;}else {,1800
1366,"int xmkstemp ( char * * tmpname , char * dir )  {char * tmpenv ;mode_t old_mode ;if ( dir != NULL )   tmpenv = dir ;else tmpenv = getenv ( ""TMPDIR"" ) ;if ( tmpenv )  rc = asprintf ( & localtmp , ""%s/%s.XXXXXX"" , tmpenv ,  program_invocation_short_name ) ;else rc = asprintf ( & localtmp , ""%s/%s.XXXXXX"" , _PATH_TMP , program_invocation_short_name ) ;","int xmkstemp ( char * * tmpname , const char * dir , const char * prefix ) {const char * tmpenv ;mode_t old_mode ;tmpenv = dir ;else tmpenv = getenv ( ""TMPDIR"" ) ;if ( ! tmpenv ) tmpenv = _PATH_TMP ;rc = asprintf ( & localtmp , ""%s/%s.XXXXXX"" , tmpenv , prefix ) ;",1801
1367,"
",if ( left == 0 && extend ) return 0 ;,1802
1368,if ( left > 0 && n > left )  n = left ;,if ( left > 0 && n > left ) n = left ;,1802
1369,"struct usmStateReference * retval = ( struct usmStateReference * )  calloc ( 1 , sizeof ( struct usmStateReference ) ) ;return retval ;}","struct usmStateReference * retval ;retval = calloc ( 1 , sizeof ( struct usmStateReference ) ) ;if ( retval ) retval -> refcnt = 1 ;return retval ;}",1803
1370,return v % 2 ? m - ( v + 1 ) / 2 : m + v / 2 ;},return ( v & 1 ) ? m - ( ( v + 1 ) >> 1 ) : m + ( v >> 1 ) ;},1804
1371,"ND_TCHECK2 ( * ( p + 2 ) , 1 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 1 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 1 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u"" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? ""zlib"" : ""unknown"" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ;","ND_TCHECK ( p [ 2 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ;ND_TCHECK ( p [ 3 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ;ND_TCHECK ( p [ 3 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u"" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? ""zlib"" : ""unknown"" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ;",1805
1372,"stmt_ty FunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq *  decorator_list , expr_ty returns , int lineno , int col_offset , int  end_lineno , int end_col_offset , PyArena * arena ) {","stmt_ty FunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq * decorator_list , expr_ty returns , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",1806
1373,p -> v . FunctionDef . returns = returns ;p -> lineno = lineno ;,p -> v . FunctionDef . returns = returns ;p -> v . FunctionDef . type_comment = type_comment ;p -> lineno = lineno ;,1806
1374,"struct request * rq = tags -> rqs [ tag ] ;struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ;if ( ! is_flush_request ( rq , fq , tag ) ) return rq ;return fq -> flush_rq ;",return tags -> rqs [ tag ] ;,1807
1375,free ( name ) ;return 0 ;,"if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;free ( name ) ;return 0 ;",1808
1376,"static void read_ref_frames ( VP9_COMMON * const cm , MACROBLOCKD * const xd ,  vp9_reader * r ,  int segment_id , MV_REFERENCE_FRAME ref_frame [ 2 ] ) {FRAME_CONTEXT * const fc = & cm -> fc ;FRAME_COUNTS * const counts = & cm -> counts ;if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) {ref_frame [ 0 ] = ( MV_REFERENCE_FRAME ) vp9_get_segdata ( & cm -> seg , segment_id ,  SEG_LVL_REF_FRAME ) ;","static void read_ref_frames ( VP9_COMMON * const cm , MACROBLOCKD * const xd , vpx_reader * r , int segment_id , MV_REFERENCE_FRAME ref_frame [ 2 ] ) {FRAME_CONTEXT * const fc = cm -> fc ;FRAME_COUNTS * counts = xd -> counts ;if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) {ref_frame [ 0 ] = ( MV_REFERENCE_FRAME ) vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ;",1809
1377,"const int bit = vp9_read ( r , fc -> comp_ref_prob [ ctx ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ counts -> comp_ref [ ctx ] [ bit ] ;const int bit0 = vp9_read ( r , fc -> single_ref_prob [ ctx0 ] [ 0 ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ counts -> single_ref [ ctx0 ] [ 0 ] [ bit0 ] ;const int bit1 = vp9_read ( r , fc -> single_ref_prob [ ctx1 ] [ 1 ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ counts -> single_ref [ ctx1 ] [ 1 ] [ bit1 ] ;","const int bit = vpx_read ( r , fc -> comp_ref_prob [ ctx ] ) ;if ( counts ) ++ counts -> comp_ref [ ctx ] [ bit ] ;const int bit0 = vpx_read ( r , fc -> single_ref_prob [ ctx0 ] [ 0 ] ) ;if ( counts ) ++ counts -> single_ref [ ctx0 ] [ 0 ] [ bit0 ] ;const int bit1 = vpx_read ( r , fc -> single_ref_prob [ ctx1 ] [ 1 ] ) ;if ( counts ) ++ counts -> single_ref [ ctx1 ] [ 1 ] [ bit1 ] ;",1809
1378,if ( ( error_code >> 16 ) != 0x8009 )  return WindowsErrorString ( ) ;,if ( ( ( error_code >> 16 ) != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) return WindowsErrorString ( ) ;,1810
1379,"case CRYPT_E_NO_TRUSTED_SIGNER :  return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ;default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ;","case CRYPT_E_NO_TRUSTED_SIGNER : return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ;case CERT_E_UNTRUSTEDROOT : return ""The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted."" ;case TRUST_E_NOSIGNATURE : return ""Not<S2SV_blank>digitally<S2SV_blank>signed."" ;case TRUST_E_EXPLICIT_DISTRUST : return ""One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."" ;default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ;",1810
1380,"uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm ,  KEY_ALLOC_IN_QUOTA ,  NULL , NULL ) ;","uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_UID_KEYRING | KEY_ALLOC_IN_QUOTA , NULL , NULL ) ;",1811
1381,"session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm ,  KEY_ALLOC_IN_QUOTA ,  NULL , NULL ) ;","session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_UID_KEYRING | KEY_ALLOC_IN_QUOTA , NULL , NULL ) ;",1811
1382,"if ( ! access_ok ( VERIFY_WRITE , name , namelen ) ) return - EFAULT ;len = namelen ;if ( namelen > 32 )  len = 32 ;",if ( len > 32 ) len = 32 ;,1812
1383,if ( bytecnt ) {wpc -> file_format = * byteptr ++ ;,if ( bytecnt >= 2 ) {wpc -> file_format = * byteptr ++ ;if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ;,1813
1384,bytecnt -- ;},bytecnt -- ;},1813
1385,"printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;","printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;",1814
1386,s ++ )  if ( isupper ( * s ) || isdigit ( * s ) ) {* x ++ = * s ;}else if ( islower ( * s ) ) {if ( len < ( part <= 1 ? 5 : 3 ) ) * x ++ = * s ;,s ++ ) if ( isupper ( ( unsigned char ) * s ) || isdigit ( ( unsigned char ) * s ) ) {* x ++ = * s ;}else if ( islower ( ( unsigned char ) * s ) ) {if ( len < ( part <= 1 ? 5 : 3 ) ) * x ++ = * s ;,1814
1387,"uint16 nstrips = 0 , ntiles = 0 , planar = 0 ;uint16 bps = 0 , spp = 0 , res_unit = 0 ;","uint32 nstrips = 0 , ntiles = 0 ;uint16 planar = 0 ;uint16 bps = 0 , spp = 0 , res_unit = 0 ;",1815
1388,"if ( ! read_buff )  read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ;else  {if ( prev_readsize < buffsize )  {new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ;","if ( ! read_buff ) {if ( buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ;return ( - 1 ) ;}read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ;}else {if ( prev_readsize < buffsize ) {if ( buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ;return ( - 1 ) ;}new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ;",1815
1389,"struct task_struct * tsk = current ;struct fpu * fpu = & tsk -> thread . fpu ;int state_size = fpu_kernel_xstate_size ;u64 xfeatures = 0 ;int fx_only = 0 ;ia32_fxstate &= ( IS_ENABLED ( CONFIG_X86_32 ) || IS_ENABLED ( CONFIG_IA32_EMULATION ) ) ;if ( ! buf ) {fpu__clear ( fpu ) ;return 0 ;}if ( ! access_ok ( VERIFY_READ , buf , size ) ) return - EACCES ;fpu__activate_curr ( fpu ) ;if ( ! static_cpu_has ( X86_FEATURE_FPU ) ) return fpregs_soft_set ( current , NULL , 0 , sizeof ( struct user_i387_ia32_struct ) , NULL , buf ) != 0 ;if ( use_xsave ( ) ) {struct _fpx_sw_bytes fx_sw_user ;if ( unlikely ( check_for_xstate ( buf_fx , buf_fx , & fx_sw_user ) ) ) {state_size = sizeof ( struct fxregs_state ) ;fx_only = 1 ;trace_x86_fpu_xstate_check_failed ( fpu ) ;state_size = fx_sw_user . xstate_size ;xfeatures = fx_sw_user . xfeatures ;}}if ( ia32_fxstate ) {struct fpu * fpu = & tsk -> thread . fpu ;struct user_i387_ia32_struct env ;int err = 0 ;fpu__drop ( fpu ) ;if ( using_compacted_format ( ) )  err = copy_user_to_xstate ( & fpu -> state . xsave , buf_fx ) ;else   err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ;if ( err || __copy_from_user ( & env , buf , sizeof ( env ) ) ) {","err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ;if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ;}if ( err || __copy_from_user ( & env , buf , sizeof ( env ) ) ) {",1816
1390,qemu_vfree ( r -> iov . iov_base ) ;},if ( r -> iov . iov_base ) {qemu_vfree ( r -> iov . iov_base ) ;}},1817
1391,"ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR0 , hashTable [ 0 ] ) ;ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR1 , hashTable [ 1 ] ) ;ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR2 , hashTable [ 2 ] ) ;ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR3 , hashTable [ 3 ] ) ;TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR0<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\return NO_ERROR ;","ksz8851WriteReg ( interface , KSZ8851_MAHTR0 , hashTable [ 0 ] ) ;ksz8851WriteReg ( interface , KSZ8851_MAHTR2 , hashTable [ 0 ] ) ;ksz8851WriteReg ( interface , KSZ8851_MAHTR3 , hashTable [ 1 ] ) ;ksz8851WriteReg ( interface , KSZ8851_MAHTR0 ) ) ;TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\return NO_ERROR ;",1818
1392,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,1819
1393,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",1819
1394,"
","if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ;",1820
1395,"if ( current_entry + n > ( int ) c -> entries ) {memset ( lengths + current_entry , current_length , n ) ;","if ( current_entry + n > ( int ) c -> entries ) {memset ( lengths + current_entry , current_length , n ) ;",1820
1396,"c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ;}","int values = lookup1_values ( c -> entries , c -> dimensions ) ;if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ;c -> lookup_values = ( uint32 ) values ;}",1820
1397,g -> values = 2 ;,"g -> values - 1 ;++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ;for ( j = 0 ;j < g -> values = 2 ;",1820
1398,for ( j = 0 ;++ j )  g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ;,for ( j = 0 ;+ j )  g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ;++ j ) g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ;,1820
1399,"
","if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup ) ;",1820
1400,"m -> coupling_steps = get_bits ( f , 8 ) + 1 ;for ( k = 0 ;","m -> coupling_steps = get_bits ( f , 8 ) + 1 ;for ( k = 0 ;",1820
1401,"goto reset ;}SAS_DPRINTK ( ""trying<S2SV_blank>to<S2SV_blank>find<S2SV_blank>task<S2SV_blank>0x%p\\\res = sas_scsi_find_task ( task ) ;switch ( res ) {case TASK_IS_DONE : SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>done\\\sas_eh_defer_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;sas_scsi_clear_queue_lu ( work_q , cmd ) ;tmf_resp = sas_recover_I_T ( task -> dev ) ;if ( tmf_resp == TMF_RESP_FUNC_COMPLETE || tmf_resp == - ENODEV ) {struct domain_device * dev = task -> dev ;SAS_DPRINTK ( ""I_T<S2SV_blank>%016llx<S2SV_blank>recovered\\\","sas_eh_finish_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;sas_scsi_clear_queue_lu ( work_q , cmd ) ;",1821
1402,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {smp_rmb ( ) ;return key -> reject_error ;}",ret = key_read_state ( key ) ;if ( ret < 0 ) return ret ;,1822
1403,"static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vpx_ref_frame_t * const data = va_arg ( args , vpx_ref_frame_t * ) ;if ( data ) {image2yuvconfig ( & frame -> img , & sd ) ;return vp9_set_reference_dec ( & ctx -> pbi -> common ,  ( VP9_REFFRAME ) frame -> frame_type , & sd ) ;","static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {vpx_ref_frame_t * const data = va_arg ( args , vpx_ref_frame_t * ) ;if ( ctx -> frame_parallel_decode ) {set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ;return VPX_CODEC_INCAPABLE ;}if ( data ) {VPxWorker * const worker = ctx -> frame_workers ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;image2yuvconfig ( & frame -> img , & sd ) ;return vp9_set_reference_dec ( & frame_worker_data -> pbi -> common , ( VP9_REFFRAME ) frame -> frame_type , & sd ) ;",1823
1404,"Stream_Read_UINT32 ( irp -> input , Length ) ;Stream_Read_UINT64 ( irp -> input , Offset ) ;if ( printer_dev -> printer )  printjob = printer_dev -> printer -> FindPrintJob ( printer_dev -> printer , irp -> FileId ) ;error = printjob -> Write ( printjob , Stream_Pointer ( irp -> input ) , Length ) ;}","void * ptr ;if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ;Stream_Read_UINT32 ( irp -> input , Length ) ;Stream_Read_UINT64 ( irp -> input , Offset ) ;ptr = Stream_Pointer ( irp -> input ) ;if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ;if ( printer_dev -> printer ) printjob = printer_dev -> printer -> FindPrintJob ( printer_dev -> printer , irp -> FileId ) ;error = printjob -> Write ( printjob , ptr , Length ) ;}",1824
1405,"int ret ;( void ) rng ;if ( hash_data == NULL || hash_len <= 0 || sig == NULL || sig_len == NULL || * sig_len <= 0 || key == NULL || key_len <= 0 ) {return BAD_FUNC_ARG ;}if ( ( int ) * sig_len < wc_SignatureGetSize ( sig_type , key , key_len ) ) {WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>sig<S2SV_blank>type/len"" ) ;","return wc_SignatureGenerateHash_ex ( hash_type , sig_type , hash_data , hash_len , sig , sig_len , key , key_len ) ) {WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>sig<S2SV_blank>type/len"" ) ;",1825
1406,"}while ( ret == WC_PENDING_E ) ;# else ret = SIG_TYPE_E ;# endif break ;case WC_SIGNATURE_TYPE_RSA_W_ENC : case WC_SIGNATURE_TYPE_RSA : # if ! defined ( NO_RSA ) && ! defined ( WOLFSSL_RSA_PUBLIC_ONLY ) do {# ifdef WOLFSSL_ASYNC_CRYPT ret = wc_AsyncWait ( ret , & ( ( RsaKey * ) key ) -> asyncDev , WC_ASYNC_FLAG_CALL_AGAIN ) ;# endif if ( ret >= 0 ) ret = wc_RsaSSL_Sign ( hash_data , hash_len , sig , * sig_len , ( RsaKey * ) key , rng ) ;}while ( ret == WC_PENDING_E ) ;if ( ret >= 0 ) {* sig_len = ret ;ret = 0 ;}# else ret = SIG_TYPE_E ;# endif break ;case WC_SIGNATURE_TYPE_NONE : default : ret = BAD_FUNC_ARG ;break ;}return ret ;","
",1825
1407,"int err ;if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) {struct frag_hdr fhdr ;skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;skb -> ip_summed = CHECKSUM_PARTIAL ;skb -> csum = 0 ;__skb_queue_tail ( & sk -> sk_write_queue , skb ) ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;","struct frag_hdr fhdr ;int err ;if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) {skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;skb -> csum = 0 ;__skb_queue_tail ( & sk -> sk_write_queue , skb ) ;}else if ( skb_is_gso ( skb ) ) {goto append ;}skb -> ip_summed = CHECKSUM_PARTIAL ;append : return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",1826
1408,"spin_lock ( & key -> user -> lock ) ;key -> user -> qnkeys -- ;key -> user -> qnbytes -= key -> quotalen ;spin_unlock ( & key -> user -> lock ) ;}atomic_dec ( & key -> user -> nkeys ) ;if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) atomic_dec ( & key -> user -> nikeys ) ;key_user_put ( key -> user ) ;if ( key -> type -> destroy ) key -> type -> destroy ( key ) ;",spin_lock ( & key -> user ) ;,1827
1409,"handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ;if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ;data . allocation . handle = handle -> id ;cleanup_handle = handle ;break ;case ION_IOC_FREE : {struct ion_handle * handle ;handle = ion_handle_get_by_id ( client , data . handle . handle ) ;if ( IS_ERR ( handle ) )  return PTR_ERR ( handle ) ;ion_free ( client , handle ) ;ion_handle_put ( handle ) ;","mutex_lock ( & client -> lock ) ;handle = ion_handle_get_by_id_nolock ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ;if ( IS_ERR ( handle ) ) {mutex_unlock ( & client -> lock ) ;return PTR_ERR ( handle ) ;ion_free_nolock ( client , handle ) ;ion_handle_put_nolock ( handle ) ;mutex_unlock ( & client -> lock ) ;",1828
1410,"int rv ;clear_bit ( WDM_RESETTING , & desc -> flags ) ;","int rv ;clear_bit ( WDM_OVERFLOW , & desc -> flags ) ;clear_bit ( WDM_RESETTING , & desc -> flags ) ;",1829
1411,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;if ( insn & 0x2000 ) {","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;if ( insn & 0x2000 ) {",1830
1412,"
","jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\",1831
1413,"if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) {goto error ;","if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) {goto error ;",1831
1414,mnt_flags |= MNT_NODEV ;},mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV ;},1832
1415,bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ;,bond_dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ;,1833
1416,"}else if ( strstr ( url , ""/"" ) != url ) {* err_str = apr_pstrdup ( r -> pool , ""Malformed<S2SV_blank>URL"" ) ;","}else if ( ( uri . hostname == NULL ) && ( strstr ( url , ""/"" ) != url ) ) {* err_str = apr_pstrdup ( r -> pool , ""Malformed<S2SV_blank>URL"" ) ;",1834
1417,"r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ;if ( r ) return - EFAULT ;","r = __copy_from_user ( data , ( void __user * ) addr + offset , len ) ;if ( r ) return - EFAULT ;",1835
1418,get_task_struct ( owner ) ;}rcu_read_unlock ( ) ;if ( owner ) {mutex_lock ( & owner -> perf_event_mutex ) ;if ( event -> owner ) list_del_init ( & event -> owner_entry ) ;,"mutex_lock_nested ( & owner -> perf_event_mutex , SINGLE_DEPTH_NESTING ) ;if ( event -> owner ) list_del_init ( & event -> owner_entry ) ;",1836
1419,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_INET_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",1837
1420,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\",1838
1421,bpm -> family = AF_BRIDGE ;bpm -> ifindex = dev -> ifindex ;,"memset ( bpm , 0 , sizeof ( * bpm ) ) ;bpm -> family = AF_BRIDGE ;bpm -> ifindex = dev -> ifindex ;",1839
1422,if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size &&  old_inode -> i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT ) filemap_flush ( old_inode -> i_mapping ) ;,"ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ;if ( ret ) {if ( ret == - EEXIST ) {if ( ! new_inode ) {WARN_ON ( 1 ) ;return ret ;}}else {return ret ;}}ret = 0 ;if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && old_inode -> i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT ) filemap_flush ( old_inode -> i_mapping ) ;",1840
1423,return result ;},if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;return result ;},1841
1424,cpi -> force_next_frame_intra = 0 ;# if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 2 ) {if ( cpi -> common . refresh_alt_ref_frame ) {cpi -> per_frame_bandwidth = cpi -> twopass . gf_bits ;cpi -> target_bandwidth = ( int ) ( cpi -> twopass . gf_bits * cpi -> output_framerate ) ;}}else # endif cpi -> per_frame_bandwidth = ( int ) ( cpi -> target_bandwidth / cpi -> output_framerate ) ;cm -> copy_buffer_to_gf = 0 ;cm -> copy_buffer_to_arf = 0 ;cpi -> mb . zbin_over_quant = 0 ;cpi -> mb . zbin_mode_boost = 0 ;cpi -> mb . zbin_mode_boost_enabled = 1 ;if ( cpi -> pass == 2 ) {if ( cpi -> gfu_boost <= 400 ) {cpi -> mb . zbin_mode_boost_enabled = 0 ;}}if ( cpi -> source_alt_ref_active ) cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ;else cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 0 ;if ( ( cm -> current_video_frame == 0 ) || ( cm -> frame_flags & FRAMEFLAGS_KEY ) || ( cpi -> oxcf . auto_key && ( cpi -> frames_since_key % cpi -> key_frame_frequency == 0 ) ) ) {cm -> frame_type = KEY_FRAME ;}# if CONFIG_MULTI_RES_ENCODING  if ( cpi -> oxcf . mr_encoder_id )  {LOWER_RES_FRAME_INFO * low_res_frame_info  = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ;cm -> frame_type = low_res_frame_info -> frame_type ;if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME )   cpi -> mr_low_res_mv_avail &= ( cpi -> current_ref_frames [ ALTREF_FRAME ]  == low_res_frame_info -> low_res_ref_frames [ ALTREF_FRAME ] ) ;,"# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity == 4 ) {vp8_denoiser_set_parameters ( & cpi -> denoiser , kDenoiserOnYUV ) ;# endif }# if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id ) {LOWER_RES_FRAME_INFO * low_res_frame_info = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ;cm -> frame_type = low_res_frame_info -> frame_type ;if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) cpi -> mr_low_res_mv_avail &= ( cpi -> current_ref_frames [ ALTREF_FRAME ] == low_res_frame_info -> low_res_ref_frames [ ALTREF_FRAME ] ) ;",1842
1425,}},}},1842
1426,"switch ( cpi -> decimation_factor ) {case 1 : cpi -> per_frame_bandwidth = cpi -> per_frame_bandwidth * 3 / 2 ;break ;case 2 : cpi -> per_frame_bandwidth = cpi -> per_frame_bandwidth * 5 / 4 ;break ;case 3 : cpi -> per_frame_bandwidth = cpi -> per_frame_bandwidth * 5 / 4 ;break ;}if ( cm -> frame_type == KEY_FRAME ) {cpi -> decimation_count = cpi -> decimation_factor ;}else if ( cpi -> decimation_count > 0 ) {cpi -> decimation_count -- ;cpi -> bits_off_target += cpi -> av_per_frame_bandwidth ;if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ;# if CONFIG_MULTI_RES_ENCODING vp8_store_drop_frame_info ( cpi ) ;# endif cm -> current_video_frame ++ ;cpi -> frames_since_key ++ ;cpi -> temporal_pattern_counter ++ ;# if CONFIG_INTERNAL_STATS cpi -> count ++ ;# endif cpi -> buffer_level = cpi -> bits_off_target ;if ( cpi -> oxcf . number_of_layers > 1 ) {unsigned int i ;for ( i = cpi -> current_layer + 1 ;i < cpi -> oxcf . number_of_layers ;i ++ ) {LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ;lc -> bits_off_target += ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;if ( lc -> bits_off_target > lc -> maximum_buffer_size ) lc -> bits_off_target = lc -> maximum_buffer_size ;lc -> buffer_level = lc -> bits_off_target ;}}return ;}else cpi -> decimation_count = cpi -> decimation_factor ;}else cpi -> decimation_count = 0 ;if ( ! vp8_pick_frame_size ( cpi ) ) {# if CONFIG_MULTI_RES_ENCODING vp8_store_drop_frame_info ( cpi ) ;# endif cm -> current_video_frame ++ ;cpi -> frames_since_key ++ ;cpi -> temporal_pattern_counter ++ ;return ;}if ( ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) && ( cpi -> buffer_level >= cpi -> oxcf . optimal_buffer_level ) && cpi -> buffered_mode ) {int Adjustment = cpi -> active_worst_quality / 4 ;if ( Adjustment ) {int buff_lvl_step ;if ( cpi -> buffer_level < cpi -> oxcf . maximum_buffer_size ) {buff_lvl_step = ( int ) ( ( cpi -> oxcf . maximum_buffer_size - cpi -> oxcf . optimal_buffer_level ) / Adjustment ) ;if ( buff_lvl_step ) Adjustment = ( int ) ( ( cpi -> buffer_level - cpi -> oxcf . optimal_buffer_level ) / buff_lvl_step ) ;else Adjustment = 0 ;}cpi -> active_worst_quality -= Adjustment ;if ( cpi -> active_worst_quality < cpi -> active_best_quality ) cpi -> active_worst_quality = cpi -> active_best_quality ;}}if ( ( cpi -> pass == 2 ) || ( cpi -> ni_frames > 150 ) ) {vp8_clear_system_state ( ) ;Q = cpi -> active_worst_quality ;if ( cm -> frame_type == KEY_FRAME ) {if ( cpi -> pass == 2 ) {if ( cpi -> gfu_boost > 600 ) cpi -> active_best_quality = kf_low_motion_minq [ Q ] ;else cpi -> active_best_quality = kf_high_motion_minq [ Q ] ;if ( cpi -> this_key_frame_forced ) {if ( cpi -> active_best_quality > cpi -> avg_frame_qindex * 7 / 8 ) cpi -> active_best_quality = cpi -> avg_frame_qindex * 7 / 8 ;else if ( cpi -> active_best_quality < cpi -> avg_frame_qindex >> 2 ) cpi -> active_best_quality = cpi -> avg_frame_qindex >> 2 ;}}else cpi -> active_best_quality = kf_high_motion_minq [ Q ] ;}else if ( cpi -> oxcf . number_of_layers == 1 && ( cm -> refresh_golden_frame || cpi -> common . refresh_alt_ref_frame ) ) {if ( ( cpi -> frames_since_key > 1 ) && ( cpi -> avg_frame_qindex < cpi -> active_worst_quality ) ) {Q = cpi -> avg_frame_qindex ;}if ( ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) && ( Q < cpi -> cq_target_quality ) ) {Q = cpi -> cq_target_quality ;}if ( cpi -> pass == 2 ) {if ( cpi -> gfu_boost > 1000 ) cpi -> active_best_quality = gf_low_motion_minq [ Q ] ;else if ( cpi -> gfu_boost < 400 ) cpi -> active_best_quality = gf_high_motion_minq [ Q ] ;else cpi -> active_best_quality = gf_mid_motion_minq [ Q ] ;if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) {cpi -> active_best_quality = cpi -> active_best_quality * 15 / 16 ;}}else cpi -> active_best_quality = gf_high_motion_minq [ Q ] ;}else {cpi -> active_best_quality = inter_minq [ Q ] ;if ( ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) && ( cpi -> active_best_quality < cpi -> cq_target_quality ) ) {if ( cpi -> rolling_actual_bits < cpi -> min_frame_bandwidth ) cpi -> active_best_quality = cpi -> oxcf . cq_level ;else cpi -> active_best_quality = cpi -> cq_target_quality ;}}if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) {if ( cpi -> buffer_level >= cpi -> oxcf . maximum_buffer_size ) cpi -> active_best_quality = cpi -> best_quality ;else if ( cpi -> buffer_level > cpi -> oxcf . optimal_buffer_level ) {int Fraction = ( int ) ( ( ( cpi -> buffer_level - cpi -> oxcf . optimal_buffer_level ) * 128 ) / ( cpi -> oxcf . maximum_buffer_size - cpi -> oxcf . optimal_buffer_level ) ) ;int min_qadjustment = ( ( cpi -> active_best_quality - cpi -> best_quality ) * Fraction ) / 128 ;cpi -> active_best_quality -= min_qadjustment ;}}}else if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) {if ( ( cm -> frame_type == KEY_FRAME ) || cm -> refresh_golden_frame || cpi -> common . refresh_alt_ref_frame ) {cpi -> active_best_quality = cpi -> best_quality ;}else if ( cpi -> active_best_quality < cpi -> cq_target_quality ) {cpi -> active_best_quality = cpi -> cq_target_quality ;}}if ( cpi -> active_worst_quality > cpi -> worst_quality ) cpi -> active_worst_quality = cpi -> worst_quality ;if ( cpi -> active_best_quality < cpi -> best_quality ) cpi -> active_best_quality = cpi -> best_quality ;if ( cpi -> active_worst_quality < cpi -> active_best_quality ) cpi -> active_worst_quality = cpi -> active_best_quality ;Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ;# if ! ( CONFIG_REALTIME_ONLY ) if ( cm -> frame_type == KEY_FRAME ) zbin_oq_high = 0 ;else if ( ( cpi -> oxcf . number_of_layers == 1 ) && ( ( cm -> refresh_alt_ref_frame || ( cm -> refresh_golden_frame && ! cpi -> source_alt_ref_active ) ) ) ) {zbin_oq_high = 16 ;}else zbin_oq_high = ZBIN_OQ_MAX ;# endif if ( cpi -> cyclic_refresh_mode_enabled ) {if ( cpi -> current_layer == 0 )  cyclic_background_refresh ( cpi , Q , 0 ) ;else disable_segmentation ( cpi ) ;}vp8_compute_frame_size_bounds ( cpi , & frame_under_shoot_limit , & frame_over_shoot_limit ) ;# if ! ( CONFIG_REALTIME_ONLY ) bottom_index = cpi -> active_best_quality ;top_index = cpi -> active_worst_quality ;q_low = cpi -> active_best_quality ;q_high = cpi -> active_worst_quality ;# endif vp8_save_coding_context ( cpi ) ;loop_count = 0 ;scale_and_extend_source ( cpi -> un_scaled_source , cpi ) ;# if ! ( CONFIG_REALTIME_ONLY ) && CONFIG_POSTPROC && ! ( CONFIG_TEMPORAL_DENOISING ) if ( cpi -> oxcf . noise_sensitivity > 0 ) {unsigned char * src ;int l = 0 ;switch ( cpi -> oxcf . noise_sensitivity ) {case 1 : l = 20 ;break ;case 2 : l = 40 ;break ;case 3 : l = 60 ;break ;case 4 : l = 80 ;break ;case 5 : l = 100 ;break ;case 6 : l = 150 ;break ;}if ( cm -> frame_type == KEY_FRAME ) {vp8_de_noise ( cm , cpi -> Source , cpi -> Source , l , 1 , 0 ) ;}else {vp8_de_noise ( cm , cpi -> Source , cpi -> Source , l , 1 , 0 ) ;src = cpi -> Source -> y_buffer ;if ( cpi -> Source -> y_stride < 0 ) {src += cpi -> Source -> y_stride * ( cpi -> Source -> y_height - 1 ) ;}}}# endif # ifdef OUTPUT_YUV_SRC  vp8_write_yuv_frame ( cpi -> Source ) ;# endif do {vp8_clear_system_state ( ) ;vp8_set_quantizer ( cpi , Q ) ;if ( cpi -> common . mb_no_coeff_skip ) {cpi -> prob_skip_false = cpi -> base_skip_false_prob [ Q ] ;if ( cm -> frame_type != KEY_FRAME ) {if ( cpi -> common . refresh_alt_ref_frame ) {if ( cpi -> last_skip_false_probs [ 2 ] != 0 ) cpi -> prob_skip_false = cpi -> last_skip_false_probs [ 2 ] ;}else if ( cpi -> common . refresh_golden_frame ) {if ( cpi -> last_skip_false_probs [ 1 ] != 0 ) cpi -> prob_skip_false = cpi -> last_skip_false_probs [ 1 ] ;}else {if ( cpi -> last_skip_false_probs [ 0 ] != 0 ) cpi -> prob_skip_false = cpi -> last_skip_false_probs [ 0 ] ;}if ( cpi -> prob_skip_false < 5 ) cpi -> prob_skip_false = 5 ;if ( cpi -> prob_skip_false > 250 ) cpi -> prob_skip_false = 250 ;if ( cpi -> oxcf . number_of_layers == 1 && cpi -> is_src_frame_alt_ref ) cpi -> prob_skip_false = 1 ;# if 0 if ( cpi -> pass != 1 ) {FILE * f = fopen ( ""skip.stt"" , ""a"" ) ;fprintf ( f , ""%d,<S2SV_blank>%d,<S2SV_blank>%4d<S2SV_blank>"" , cpi -> common . refresh_golden_frame , cpi -> common . refresh_alt_ref_frame , cpi -> prob_skip_false ) ;fclose ( f ) ;}# endif }if ( cm -> frame_type == KEY_FRAME ) {if ( resize_key_frame ( cpi ) ) {Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ;if ( cpi -> cyclic_refresh_mode_enabled ) {if ( cpi -> current_layer == 0 ) cyclic_background_refresh ( cpi , Q , 0 ) ;else disable_segmentation ( cpi ) ;}vp8_set_quantizer ( cpi , Q ) ;}vp8_setup_key_frame ( cpi ) ;}# if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING {if ( cpi -> oxcf . error_resilient_mode ) cm -> refresh_entropy_probs = 0 ;if ( cpi -> oxcf . error_resilient_mode & VPX_ERROR_RESILIENT_PARTITIONS ) {if ( cm -> frame_type == KEY_FRAME ) cm -> refresh_entropy_probs = 1 ;}if ( cm -> refresh_entropy_probs == 0 ) {vpx_memcpy ( & cm -> lfc , & cm -> fc , sizeof ( cm -> fc ) ) ;}# else  vp8_encode_frame ( cpi ) ;cpi -> projected_frame_size -= vp8_estimate_entropy_savings ( cpi ) ;","memcpy ( & cm -> lfc , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cpi -> oxcf . screen_content_mode == 2 ) {if ( vp8_drop_encodedframe_overshoot ( cpi , Q ) ) return ;}# else vp8_encode_frame ( cpi ) ;cpi -> projected_frame_size -= vp8_estimate_entropy_savings ( cpi ) ;",1842
1427,if ( kf_err > ( ( cpi -> ambient_err * 7 ) >> 3 ) ) {,}}if ( cm -> frame_type == KEY_FRAME ) {if ( cpi -> oxcf . mr_encoder_id ) {if ( cpi -> common . current_video_frame == 0 && cpi -> buffer_level == 0 ) {unsigned int i ;cpi -> bits_off_target = cpi -> oxcf . starting_buffer_level ;cpi -> buffer_level = cpi -> oxcf . starting_buffer_level ;for ( i = 0 ;i < cpi -> oxcf . number_of_layers ;i ++ ) {LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ;lc -> bits_off_target = lc -> starting_buffer_level ;lc -> buffer_level = lc -> starting_buffer_level ;}}cpi -> common . current_video_frame = low_res_frame_info -> key_frame_counter_value ;}else {low_res_frame_info -> key_frame_counter_value = cpi -> common . current_video_frame ;}}}# endif cpi -> closest_reference_frame = LAST_FRAME ;if ( cm -> frame_type != KEY_FRAME ) {int i ;MV_REFERENCE_FRAME closest_ref = INTRA_FRAME ;if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) {closest_ref = LAST_FRAME ;}else if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) {closest_ref = GOLDEN_FRAME ;}else if ( kf_err > ( ( cpi -> ambient_err * 7 ) >> 3 ) ) {,1842
1428,loop_count ++ ;,"# if CONFIG_TEMPORAL_DENOISING && CONFIG_POSTPROC if ( cpi -> oxcf . noise_sensitivity >= 3 ) {if ( cpi -> denoiser . denoise_pars . spatial_blur != 0 ) {vp8_de_noise ( cm , cpi -> Source , cpi -> Source , cpi -> denoiser . denoise_pars . spatial_blur , 1 , 0 , 1 , 0 , 1 ) ;}memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ;memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ;}# endif loop_count ++ ;",1842
1429,if ( tmp -> mbmi . mode == ZEROMV )  cpi -> zeromv_count ++ ;,if ( tmp -> mbmi . mode == ZEROMV && tmp -> mbmi . ref_frame == LAST_FRAME ) cpi -> zeromv_count ++ ;,1842
1430,"# if 0 {FILE * f = fopen ( ""gfactive.stt"" , ""a"" ) ;fprintf ( f , ""%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d\\\fclose ( f ) ;}# endif if ( ! cpi -> oxcf . error_resilient_mode && cm -> refresh_golden_frame ) cm -> copy_buffer_to_arf = 2 ;else cm -> copy_buffer_to_arf = 0 ;cm -> frame_to_show = & cm -> yv12_fb [ cm -> new_fb_idx ] ;# if CONFIG_MULTITHREAD  if ( cpi -> b_multi_threaded ) {sem_post ( & cpi -> h_event_start_lpf ) ;cpi -> b_lpf_running = 1 ;update_reference_frames ( cpi ) ;# if ! ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cpi -> oxcf . error_resilient_mode ) {",# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && cpi -> oxcf . noise_sensitivity < 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) {cpi -> mse_source_denoised = measure_square_diff_partial ( & cpi -> h_event_start_lpf ) ;cpi -> b_lpf_running = 1 ;update_reference_frames ( cpi ) ;# if ! ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cpi -> oxcf . error_resilient_mode ) {,1842
1431,},"# ifdef OUTPUT_YUV_DENOISED vp8_write_yuv_frame ( yuv_denoised_file , & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] ) ;# endif }",1842
1432,if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size )  cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ;cpi -> rolling_target_bits = ( ( cpi -> rolling_target_bits * 3 ) + cpi -> this_frame_target + 2 ) / 4 ;,if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ;if ( cpi -> drop_frames_allowed == 0 && cpi -> oxcf . screen_content_mode && cpi -> bits_off_target < - cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = - cpi -> oxcf . maximum_buffer_size ;cpi -> rolling_target_bits = ( ( cpi -> rolling_target_bits * 3 ) + cpi -> this_frame_target + 2 ) / 4 ;,1842
1433,"if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ;if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ;ret = 0 ;if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ;key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , KEY_NEED_SETATTR ) ;if ( IS_ERR ( key_ref ) ) {ret = PTR_ERR ( key_ref ) ;goto error ;}key = key_ref_to_ptr ( key_ref ) ;ret = - EACCES ;down_write ( & key -> sem ) ;if ( ! capable ( CAP_SYS_ADMIN ) ) {if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ;if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ;}if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) {ret = - ENOMEM ;newowner = key_user_lookup ( uid ) ;if ( ! newowner ) goto error_put ;if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) {unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ;unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ;spin_lock ( & newowner -> lock ) ;if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ;newowner -> qnkeys ++ ;newowner -> qnbytes += key -> quotalen ;spin_unlock ( & newowner -> lock ) ;spin_lock ( & key -> user -> lock ) ;key -> user -> qnkeys -- ;key -> user -> qnbytes -= key -> quotalen ;spin_unlock ( & key -> user -> lock ) ;}atomic_dec ( & key -> user -> nkeys ) ;atomic_inc ( & newowner -> nkeys ) ;if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {atomic_dec ( & key -> user -> nikeys ) ;",if ( key -> state != KEY_IS_UNINSTANTIATED ) {atomic_dec ( & key -> user -> nikeys ) ;,1843
1434,"if ( ( ! strcmp ( s -> name , ""unixlogin"" ) ||  ! strcmp ( & s -> name [ strlen ( s -> name ) - 5 ] , ""plain"" ) ) && s -> enabled )  return TRUE ;","if ( ( ! strcmp ( s -> name , ""unixlogin"" ) || strstr ( s -> name ) - 5 ] , ""plain"" ) ) && s -> enabled ) return TRUE ;",1844
1435,if ( ret < 0 )  btrfs_release_path ( p ) ;,if ( ret < 0 && ! p -> skip_release_on_error ) btrfs_release_path ( p ) ;,1845
1436,"unsigned int i , j ;for ( i = 0 ;","unsigned int i , j ;( void ) bothclamp ;for ( i = 0 ;",1846
1437,"sctp_sock_rfree ( skb ) ;__skb_unlink ( skb , & oldsk -> sk_receive_queue ) ;sctp_skb_set_owner_r ( skb , newsk ) ;}","sctp_sock_rfree_frag ( skb ) ;__skb_unlink ( skb , & oldsk -> sk_receive_queue ) ;sctp_skb_set_owner_r_frag ( skb , newsk ) ;}",1847
1438,"sctp_sock_rfree ( skb ) ;__skb_unlink ( skb , & oldsp -> pd_lobby ) ;sctp_skb_set_owner_r ( skb , newsk ) ;}if ( assoc -> ulpq . pd_mode )  sctp_clear_pd ( oldsk ) ;}","sctp_sock_rfree_frag ( skb ) ;__skb_unlink ( skb , & oldsp -> pd_lobby ) ;sctp_skb_set_owner_r_frag ( skb , newsk ) ;}}if ( assoc -> ulpq . pd_mode ) sctp_clear_pd ( oldsk ) ;}sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) {sctp_sock_rfree_frag ( skb ) ;sctp_skb_set_owner_r_frag ( skb , newsk ) ;}sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) {sctp_sock_rfree_frag ( skb ) ;sctp_skb_set_owner_r_frag ( skb , newsk ) ;",1847
1439,if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size &&  old_inode -> i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT ) filemap_flush ( old_inode -> i_mapping ) ;,"ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ;if ( ret ) {if ( ret == - EEXIST ) {if ( ! new_inode ) {WARN_ON ( 1 ) ;return ret ;}}else {return ret ;}}ret = 0 ;if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && old_inode -> i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT ) filemap_flush ( old_inode -> i_mapping ) ;",1848
1440,p = find_eoq ( cmd + 1 ) ;if ( ! p || ! * p ) {,p = cmd [ 0 ] ? find_eoq ( cmd + 1 ) : NULL ;if ( ! p || ! * p ) {,1849
1441,"static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env ,  int insn_idx , int prev_insn_idx )  {if ( err )  goto err ;if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) {","static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env , int insn_idx , int prev_insn_idx , bool speculative ) {elem -> st . speculative |= speculative ;if ( err ) goto err ;if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) {",1850
1442,"copy_file ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ;IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ;strcpy ( source_filename + source_base_ofs , ""limits"" ) ;copy_file ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ;IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ;strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ;copy_file ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ;IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ;strcpy ( dest_base , FILENAME_OPEN_FDS ) ;if ( dump_fd_info ( dest_filename , source_filename , source_base_ofs ) )   IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ;free ( dest_filename ) ;","copy_file_ext ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ;IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ;strcpy ( source_filename + source_base_ofs , ""limits"" ) ;copy_file ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid ) ) ;strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ;copy_file ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ;IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ;strcpy ( dest_base , FILENAME_OPEN_FDS ) ;dump_fd_info ( dest_filename , source_filename , source_base_ofs ) ) IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ;free ( dest_filename ) ;",1851
1443,if ( flags & MSG_OOB )  goto out ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,if ( flags & MSG_OOB ) goto out ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,1852
1444,"}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;","* addr_len = sizeof ( * sin ) ;}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;",1852
1445,"
","if ( overflow2 ( sidx , nc ) ) {goto fail1 ;}",1853
1446,"sidx = sizeof ( t_chunk_info ) * nc ;if ( sidx <= 0 ) {cidx = gdCalloc ( sidx , 1 ) ;for ( i = 0 ;","sidx = sizeof ( t_chunk_info ) * nc ;if ( sidx <= 0 ) {cidx = gdCalloc ( sidx , 1 ) ;if ( cidx == NULL ) {goto fail1 ;}for ( i = 0 ;",1853
1447,"if ( result == L2CAP_CONF_SUCCESS ) {if ( rfc . mode == L2CAP_MODE_BASIC ) {if ( mtu < pi -> omtu )  result = L2CAP_CONF_UNACCEPT ;else {pi -> omtu = mtu ;pi -> conf_state |= L2CAP_CONF_OUTPUT_DONE ;}l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> omtu ) ;else {","if ( pi -> num_conf_rsp || pi -> num_conf_req ) goto done ;switch ( pi -> mode ) {case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ;if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) return - ECONNREFUSED ;break ;default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ;break ;done : if ( pi -> mode != rfc . mode ) {rfc . mode = pi -> mode ;if ( pi -> num_conf_rsp == 1 ) return - ECONNREFUSED ;l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ;}if ( result == L2CAP_CONF_SUCCESS ) {if ( mtu < L2CAP_DEFAULT_MIN_MTU ) result = L2CAP_CONF_UNACCEPT ;else {pi -> omtu ) result = L2CAP_CONF_UNACCEPT ;else {pi -> omtu = mtu ;pi -> conf_state |= L2CAP_CONF_MTU_DONE ;}l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> omtu ) ;switch ( rfc . mode ) {case L2CAP_MODE_BASIC : pi -> fcs = L2CAP_FCS_NONE ;pi -> conf_state |= L2CAP_CONF_MODE_DONE ;break ;case L2CAP_MODE_ERTM : pi -> remote_tx_win = rfc . txwin_size ;pi -> remote_max_tx = rfc . max_transmit ;pi -> max_pdu_size = rfc . max_pdu_size ;rfc . retrans_timeout = L2CAP_DEFAULT_RETRANS_TO ;rfc . monitor_timeout = L2CAP_DEFAULT_MONITOR_TO ;pi -> conf_state |= L2CAP_CONF_MODE_DONE ;break ;case L2CAP_MODE_STREAMING : pi -> remote_tx_win = rfc . txwin_size ;pi -> max_pdu_size = rfc . max_pdu_size ;pi -> conf_state |= L2CAP_CONF_MODE_DONE ;break ;default : result = L2CAP_CONF_UNACCEPT ;",1854
1448,"static int inv_map_table [ MAX_PROB - 1 ] = {6 , 19 , 32 , 45 , 58 , 71 , 84 , 97 , 110 , 123 , 136 , 149 , 162 , 175 , 188 ,  201 , 214 , 227 , 240 , 253 , 0 , 1 , 2 , 3 , 4 , 5 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 176 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 202 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 215 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 }return 1 + inv_recenter_nonneg ( v + 1 , m ) ;}return MAX_PROB - inv_recenter_nonneg ( v + 1 , MAX_PROB - 1 - m ) ;}","static int inv_map_table [ MAX_PROB ] = {6 , 19 , 32 , 45 , 58 , 71 , 84 , 97 , 110 , 123 , 136 , 149 , 162 , 175 , 188 , 201 , 214 , 227 , 240 , 253 , 0 , 1 , 2 , 3 , 4 , 5 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 176 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 202 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 215 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 }return 1 + inv_recenter_nonneg ( v , m ) ;}return MAX_PROB - inv_recenter_nonneg ( v , MAX_PROB - 1 - m ) ;}",1855
1449,"if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 )  return 1 ;","if ( th -> fin ) goto discard ;if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) return 1 ;",1856
1450,"if ( ret == 0 ) goto can_read_key ;if ( ret != - EACCES ) goto error ;if ( ! is_key_possessed ( key_ref ) ) {ret = - EACCES ;goto error2 ;}can_read_key :  ret = key_validate ( key ) ;if ( ret == 0 ) {ret = - EOPNOTSUPP ;if ( key -> type -> read ) {down_read ( & key -> sem ) ;ret = key -> type -> read ( key , buffer , buflen ) ;up_read ( & key -> sem ) ;}","if ( ret == 0 ) ret = key -> type -> read ) {down_read ( & key -> sem ) ;ret = key_validate ( key ) ;if ( ret == 0 ) {ret = - EOPNOTSUPP ;if ( key -> type -> read ) {down_read ( & key -> sem ) ;ret = key -> type -> read ( key , buffer , buflen ) ;up_read ( & key -> sem ) ;",1857
1451,long timeo ;lock_sock ( sk ) ;,long timeo ;msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,1858
1452,"int count , i ;count = be32_to_cpu ( aclp -> acl_cnt ) ;","unsigned int count , i ;count = be32_to_cpu ( aclp -> acl_cnt ) ;",1859
1453,"static vpx_codec_err_t ctrl_set_dbg_options ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {# if CONFIG_POSTPROC_VISUALIZER && CONFIG_POSTPROC  int data = va_arg ( args , int ) ;","static vpx_codec_err_t ctrl_set_dbg_options ( vpx_codec_alg_priv_t * ctx , va_list args ) {# if CONFIG_POSTPROC_VISUALIZER && CONFIG_POSTPROC int data = va_arg ( args , int ) ;",1860
1454,# endif  },},1860
1455,assert ( bi != NULL ) ;si = & bi -> slotinfo [ slot ] ;,if ( bi == NULL ) return NULL ;si = & bi -> slotinfo [ slot ] ;,1861
1456,"ar2 -> intf [ 0 ] = interface ;ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ;r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ;if ( r ) goto fail1 ;alt = ar2 -> intf [ 1 ] -> cur_altsetting ;ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ;r = ati_remote2_urb_init ( ar2 ) ;if ( r )  goto fail2 ;ar2 -> channel_mask = channel_mask ;if ( r )  goto fail2 ;usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ;if ( r )  goto fail2 ;r = ati_remote2_input_init ( ar2 ) ;if ( r )  goto fail3 ;usb_set_intfdata ( interface , ar2 ) ;fail3 :  sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ;fail2 :  ati_remote2_urb_cleanup ( ar2 ) ;usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ;","if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) {dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\\r = - ENODEV ;goto fail1 ;}ar2 -> intf [ 0 ] = interface ;ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ;if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) {dev_err ( & interface -> dev , ""%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\\r = - ENODEV ;goto fail1 ;}r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ;if ( r ) goto fail3 ;ar2 -> channel_mask = channel_mask ;if ( r ) goto fail2 ;usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ;if ( r ) goto fail3 ;r = ati_remote2_input_init ( ar2 ) ;if ( r ) goto fail4 ;usb_set_intfdata ( interface , ar2 ) ;fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ;fail3 : ati_remote2_urb_cleanup ( ar2 ) ;fail2 : usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ;",1862
1457,"gss_buffer_desc client_name , service_name ;OM_uint32 minor_stat ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;OM_uint32 minor_stat ;,1863
1458,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",1863
1459,"struct usbdevfs_connectinfo ci = {. devnum = ps -> dev -> devnum ,  . slow = ps -> dev -> speed == USB_SPEED_LOW  };if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ;","struct usbdevfs_connectinfo ci ;memset ( & ci , 0 , sizeof ( ci ) ) ;ci . devnum = ps -> dev -> devnum ;ci . slow = ps -> dev -> speed == USB_SPEED_LOW ;if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ;",1864
1460,"save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ;if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) {","save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ;problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) {",1865
1461,"if ( url && * url ) {register int x , y ;for ( x = 0 , y = 0 ;url [ y ] ;if ( ( url [ x ] = url [ y ] ) == '+' )  url [ x ] = '<S2SV_blank>' ;else if ( url [ x ] == '%' ) {if ( ! ( url [ x + 1 ] && url [ x + 2 ] ) )  break ;url [ x ] = x2c ( url + y + 1 ) ;y += 2 ;}",if ( url [ y ] ;if ( ( url [ x ] = url [ y ] ) == '+' ) {url [ x ] = '<S2SV_blank>' ;}else if ( url [ y ] == '%' ) {if ( ! url [ y + 1 ] && url [ x + 2 ] ) break ;url [ x ] = _x2c ( url + y + 1 ) ;y += 2 ;}else {url [ x ] = url [ y ] ;},1866
1462,"ret = _krb5_principalname2krb5_principal ( context , & r -> server_princ , * ( b -> sname ) , b -> realm ) ;if ( ret == 0 ) ret = krb5_unparse_name ( context , r -> server_princ , & r -> server_name ) ;}if ( ret ) {kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>malformed<S2SV_blank>server<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s"" , from ) ;goto out ;}if ( b -> cname == NULL ) {ret = KRB5KRB_ERR_GENERIC ;_kdc_set_e_text ( r , ""No<S2SV_blank>client<S2SV_blank>in<S2SV_blank>request"" ) ;}else {ret = _krb5_principalname2krb5_principal ( context , & r -> client_princ , * ( b -> cname ) , b -> realm ) ;","ret = _krb5_principalname2krb5_principal ( context , & r -> server_princ , r -> client_princ , * ( b -> cname ) , b -> realm ) ;",1867
1463,"ret = _kdc_db_fetch ( context , config , r -> client_princ , HDB_F_GET_CLIENT | flags , NULL , & r -> clientdb , & r -> client ) ;if ( ret == HDB_ERR_NOT_FOUND_HERE ) {kdc_log ( context , config , 5 , ""client<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> client_name ) ;goto out ;}else if ( ret == HDB_ERR_WRONG_REALM ) {char * fixed_client_name = NULL ;ret = krb5_unparse_name ( context , r -> client -> entry . principal , & fixed_client_name ) ;if ( ret ) {goto out ;}kdc_log ( context , config , 0 , ""WRONG_REALM<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s"" , r -> client_name , fixed_client_name ) ;free ( fixed_client_name ) ;ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , KRB5_KDC_ERR_WRONG_REALM , NULL , r -> server_princ , NULL , & r -> client -> entry . principal -> realm , NULL , NULL , reply ) ;goto out ;}else if ( ret ) {const char * msg = krb5_get_error_message ( context , ret ) ;kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> client_name , msg ) ;krb5_free_error_message ( context , msg ) ;ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ;goto out ;}ret = _kdc_db_fetch ( context , config , r -> server_princ , HDB_F_GET_SERVER | HDB_F_GET_KRBTGT | flags , NULL , NULL , & r -> server ) ;if ( ret == HDB_ERR_NOT_FOUND_HERE ) {kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> server_name ) ;goto out ;}else if ( ret ) {const char * msg = krb5_get_error_message ( context , ret ) ;kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> server_name , msg ) ;krb5_free_error_message ( context , msg ) ;ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ;goto out ;}ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , r -> server_princ ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , r -> client , b -> etype . val , b -> etype . len , & r -> sessionetype , NULL ) ;if ( ret ) {kdc_log ( context , config , 0 , ""Client<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>common<S2SV_blank>enctypes<S2SV_blank>with<S2SV_blank>KDC<S2SV_blank>"" ""to<S2SV_blank>use<S2SV_blank>for<S2SV_blank>the<S2SV_blank>session<S2SV_blank>key"" , r -> client_name , from ) ;goto out ;}if ( req -> padata ) {unsigned int n ;log_patypes ( context , config , req -> padata ) ;for ( n = 0 ;! found_pa && n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ;n ++ ) {if ( pat [ n ] . validate == NULL ) continue ;if ( r -> armor_crypto == NULL && ( pat [ n ] . flags & PA_REQ_FAST ) ) continue ;kdc_log ( context , config , 5 , ""Looking<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>pa-data<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ;i = 0 ;pa = _kdc_find_padata ( req , & i , pat [ n ] . type ) ;if ( pa ) {ret = pat [ n ] . validate ( r , pa ) ;if ( ret != 0 ) {goto out ;}kdc_log ( context , config , 0 , ""%s<S2SV_blank>pre-authentication<S2SV_blank>succeeded<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ;found_pa = 1 ;r -> et . flags . pre_authent = 1 ;}}}if ( found_pa == 0 ) {Key * ckey = NULL ;size_t n ;for ( n = 0 ;n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ;n ++ ) {if ( ( pat [ n ] . flags & PA_ANNOUNCE ) == 0 ) continue ;ret = krb5_padata_add ( context , & error_method , pat [ n ] . type , NULL , 0 ) ;if ( ret ) goto out ;}ret = _kdc_find_etype ( context , config -> preauth_use_strongest_session_key , TRUE , r -> client , b -> etype . val , b -> etype . len , NULL , & ckey ) ;if ( ret == 0 ) {if ( older_enctype ( ckey -> key . keytype ) ) {ret = get_pa_etype_info ( context , config , & error_method , ckey ) ;if ( ret ) goto out ;}ret = get_pa_etype_info2 ( context , config , & error_method , ckey ) ;if ( ret ) goto out ;}if ( require_preauth_p ( r ) || _kdc_is_anon_request ( b ) ) {ret = KRB5KDC_ERR_PREAUTH_REQUIRED ;_kdc_set_e_text ( r , ""Need<S2SV_blank>to<S2SV_blank>use<S2SV_blank>PA-ENC-TIMESTAMP/PA-PK-AS-REQ"" ) ;goto out ;}if ( ckey == NULL ) {ret = KRB5KDC_ERR_CLIENT_NOTYET ;_kdc_set_e_text ( r , ""Doesn\\\'t<S2SV_blank>have<S2SV_blank>a<S2SV_blank>client<S2SV_blank>key<S2SV_blank>available"" ) ;goto out ;}krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ;ret = krb5_copy_keyblock_contents ( r -> context , & ckey -> key , & r -> reply_key ) ;if ( ret ) goto out ;}if ( r -> clientdb -> hdb_auth_status ) {r -> clientdb -> hdb_auth_status ( context , r -> clientdb , r -> client , HDB_AUTH_SUCCESS ) ;}ret = _kdc_check_access ( context , config , r -> client , r -> client_name , r -> server , r -> server_name , req , & error_method ) ;if ( ret ) goto out ;ret = _kdc_get_preferred_key ( context , config , r -> server , r -> server_name , & setype , & skey ) ;if ( ret ) goto out ;if ( f . renew || f . validate || f . proxy || f . forwarded || f . enc_tkt_in_skey || ( _kdc_is_anon_request ( b ) && ! config -> allow_anonymous ) ) {ret = KRB5KDC_ERR_BADOPTION ;_kdc_set_e_text ( r , ""Bad<S2SV_blank>KDC<S2SV_blank>options"" ) ;goto out ;}rep . pvno = 5 ;rep . msg_type = krb_as_rep ;if ( _kdc_is_anonymous ( context , r -> client_princ ) ) {","ret = _kdc_db_fetch ( context , config , r -> client_princ ? & r -> client_princ -> name : NULL , r -> client_princ ) ) {",1867
1464,"ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , ret , r -> e_text , r -> server_princ ,  & r -> client_princ -> name ,   & r -> client_princ -> realm ,  NULL , NULL , reply ) ;","ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , ret , r -> e_text , r -> server_princ , & r -> client_princ ? & r -> client_princ -> realm : NULL , NULL , NULL , reply ) ;",1867
1465,usb_kill_urb ( mixer -> urb ) ;usb_kill_urb ( mixer -> rc_urb ) ;},if ( mixer -> disconnected ) return ;if ( mixer -> urb ) usb_kill_urb ( mixer -> urb ) ;if ( mixer -> rc_urb ) usb_kill_urb ( mixer -> rc_urb ) ;mixer -> disconnected = true ;},1868
1466,"call = ast_for_call ( c , CHILD ( n , 3 ) , dummy ) ;if ( ! call ) return NULL ;","call = ast_for_call ( c , CHILD ( n , 3 ) , dummy , false ) ;if ( ! call ) return NULL ;",1869
1467,"struct iovec iov ;iov_for_each ( iov , i , * iter ) {if ( end < start ) return ERR_PTR ( - EINVAL ) ;","struct iovec iov ;struct bio_vec * bvec ;iov_for_each ( iov , i , * iter ) {if ( unlikely ( end < start ) return ERR_PTR ( - EINVAL ) ;",1870
1468,if ( ret < local_nr_pages ) {ret = - EFAULT ;,if ( ret < local_nr_pages ) ) {for ( j = cur_page ;j < page_limit ;j ++ ) {if ( ! pages [ j ] ) break ;put_page ( pages [ j ] ) ;}ret = - EFAULT ;,1870
1469,out_unmap :  for ( j = 0 ;j < nr_pages ;j ++ ) {if ( ! pages [ j ] ) break ;put_page ( pages [ j ] ) ;,"out_unmap : bio_for_each_segment_all ( bvec , bio , j ) {put_page ( bvec -> bv_page ) ;",1870
1470,while ( ret < nr ) {long avail ;,head %= ctx -> nr_events ;tail %= ctx -> nr_events ;while ( ret < nr ) {long avail ;,1871
1471,"strcpy ( algo -> alg_name , auth -> alg_name ) ;memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ) ;","strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ) ;memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ) ;",1872
1472,BT_HDR * p_buf = GKI_getbuf ( ( UINT16 ) ( len + BTA_HH_MIN_OFFSET + sizeof ( BT_HDR ) ) ) ;if ( p_buf ) {,"UINT16 buflen = ( UINT16 ) ( len + BTA_HH_MIN_OFFSET + sizeof ( BT_HDR ) ) ;if ( buflen < len ) {android_errorWriteWithInfoLog ( 0x534e4554 , ""28672558"" , - 1 , NULL , 0 ) ;return NULL ;}BT_HDR * p_buf = GKI_getbuf ( buflen ) ;if ( p_buf ) {",1873
1473,"if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 2 ) && ( img -> comps [ 2 ] . dy == 2 ) ) {sycc420_to_rgb ( img ) ;else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) {sycc422_to_rgb ( img ) ;}else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 1 ) && ( img -> comps [ 2 ] . dx == 1 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) {sycc444_to_rgb ( img ) ;}else {fprintf ( stderr , ""%s:%d:color_sycc_to_rgb\\\return ;}img -> color_space = OPJ_CLRSPC_SRGB ;}","
",1874
1474,"sas_discover_event ( dev -> port , DISCE_PROBE ) ;return 0 ;",return 0 ;,1875
1475,ether_setup ( dev ) ;if ( iface ) {,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;ether_setup ( dev ) ;if ( iface ) {,1876
1476,"if ( poll ( & pfd , 1 , 0 ) == 0 )  {if ( ( fd = accept ( sfd , ( struct sockaddr * ) & remote , & len ) ) == - 1 )  {","if ( TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , 0 ) ) == 0 ) {if ( ( fd = TEMP_FAILURE_RETRY ( accept ( sfd , ( struct sockaddr * ) & remote , & len ) ) ) == - 1 ) {",1877
1477,"if ( in_creds -> client == NULL && subject_cert == NULL ) {return EINVAL ;}if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) {int anonymous ;anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ;return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ;}memset ( & creds , 0 , sizeof ( creds ) ) ;memset ( & userid , 0 , sizeof ( userid ) ) ;if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ;code = krb5_get_init_creds_opt_alloc ( context , & opts ) ;if ( code != 0 ) goto cleanup ;krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ;krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ;krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ;krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ;krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ;krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ;if ( in_creds -> client != NULL ) {client = * in_creds -> client ;client . realm = in_creds -> server -> realm ;}else {client . magic = KV5M_PRINCIPAL ;client . realm = in_creds -> server -> realm ;client . data = NULL ;client . length = 0 ;client . type = KRB5_NT_ENTERPRISE_PRINCIPAL ;}code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ;if ( code == 0 || code == KRB5_PREAUTH_FAILED ) {* canon_user = userid . user ;",if ( ! code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP ) {* canon_user = userid . user ;,1878
1478,"char * driver_override , * old = pdev -> driver_override , * cp ;if ( count > PATH_MAX ) return - EINVAL ;if ( strlen ( driver_override ) ) {pdev -> driver_override = driver_override ;kfree ( old ) ;return count ;","char * driver_override , * old , * cp ;if ( count > PATH_MAX ) return - EINVAL ;device_lock ( dev ) ;old = pdev -> driver_override ;if ( strlen ( driver_override ) ) {pdev -> driver_override = driver_override ;device_unlock ( dev ) ;kfree ( old ) ;return count ;",1879
1479,trace_kvm_emulate_insn_failed ( vcpu ) ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;,trace_kvm_emulate_insn_failed ( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0 ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;,1880
1480,"int res , bytes , i , indexes , index_bytes , ids ;long long * index , start , end ;if ( res == 0 ) return 0 ;SQUASHFS_INSWAP_XATTR_TABLE ( & id_table ) ;if ( flag ) {* table_start = id_table . xattr_table_start ;return id_table . xattr_ids ;}index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ids ) ;indexes = SQUASHFS_XATTR_BLOCKS ( ids ) ;res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) ,  index_bytes , index ) ;bytes = SQUASHFS_XATTR_BYTES ( ids ) ;xattr_ids = malloc ( bytes ) ;int length = read_block ( fd , index [ i ] , NULL , expected , ( ( unsigned char * ) xattr_ids ) +  ( i * SQUASHFS_METADATA_SIZE ) ) ;TRACE ( ""Read<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>from<S2SV_blank>0x%llx,<S2SV_blank>length<S2SV_blank>"" ""%d\\\","int res , i , indexes , index_bytes ;unsigned int ids ;long long bytes ;long long * index , start , end ;return id_table . xattr_ids ;}ids = id_table . xattr_ids ;xattr_table_start = id_table . xattr_table_start ;index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ;indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ;if ( index_bytes != ( sBlk -> bytes_used - ( sBlk -> xattr_id_table_start + sizeof ( id_table ) ) ) ) {ERROR ( ""read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\return 0 ;}if ( table_start != NULL ) * table_start = id_table . xattr_table_start ;if ( flag ) return id_table . xattr_ids ;res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) , index_bytes , index ) ;bytes = SQUASHFS_XATTR_BYTES ( ( long long ) ids ) ;xattr_ids = malloc ( bytes ) ;int length = read_block ( fd , index [ i ] , NULL , expected , ( ( unsigned char * ) xattr_ids ) + ( ( long long ) i * SQUASHFS_METADATA_SIZE ) ) ;TRACE ( ""Read<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>from<S2SV_blank>0x%llx,<S2SV_blank>length<S2SV_blank>"" ""%d\\\",1881
1481,while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) {lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ;dest = ( rose_address * ) ( skb -> data + 4 ) ;lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ;,while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) {if ( skb -> len < ROSE_MIN_LEN ) {kfree_skb ( skb ) ;continue ;}lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ;if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) {kfree_skb ( skb ) ;continue ;}dest = ( rose_address * ) ( skb -> data + ROSE_CALL_REQ_DEST_ADDR_OFF ) ;lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ;,1882
1482,if ( * p != IAC )  goto pktend ;,ND_TCHECK ( * p ) ;if ( * p != IAC ) goto pktend ;,1883
1483,"j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ;if ( j < 0 ) goto partno ;len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ;j += PCI_VPD_INFO_FLD_HDR_SIZE ;if ( j + len > block_end ) goto partno ;memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ;strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ;}","if ( len >= sizeof ( tp -> fw_ver , & vpd_data [ j ] , len ) ;strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ;}",1884
1484,int err ;lookup_protocol : err = - ESOCKTNOSUPPORT ;,int err ;if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL ;lookup_protocol : err = - ESOCKTNOSUPPORT ;,1885
1485,"static struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root ,  struct btrfs_path * path , const char * name , int name_len ) {","struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root , struct btrfs_path * path , const char * name , int name_len ) {",1886
1486,"static void ip6_append_data_mtu ( int * mtu ,  int * maxfraglen , unsigned int fragheaderlen , struct sk_buff * skb ,  struct rt6_info * rt )  {* mtu = * mtu - rt -> dst . header_len ;* mtu = dst_mtu ( rt -> dst . path ) ;}","static void ip6_append_data_mtu ( unsigned int * mtu , int * maxfraglen , unsigned int fragheaderlen , struct sk_buff * skb , struct rt6_info * rt , bool pmtuprobe ) {* mtu = min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : * mtu - rt -> dst . header_len ;* mtu = dst_mtu ( rt -> dst . path ) ) ;}",1887
1487,"alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ;data . period = event -> hw . last_period ;if ( alpha_perf_event_set_period ( event , hwc , idx ) ) {if ( perf_event_overflow ( event , 1 , & data , regs ) ) {alpha_pmu_stop ( event , 0 ) ;","alpha_perf_event_update ( event , & data , regs ) ) {alpha_pmu_stop ( event , 0 ) ;",1888
1488,else  bitlen = slen * 4 ;if ( atttypmod <= 0 ) atttypmod = bitlen ;,"else {if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ;bitlen = slen * 4 ;}if ( atttypmod <= 0 ) atttypmod = bitlen ;",1889
1489,"if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;","if ( NULL == siocb -> scm , false ) siocb -> scm = & tmp_scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;",1890
1490,static int udp_push_pending_frames ( struct sock * sk )  {,int udp_push_pending_frames ( struct sock * sk ) {,1891
1491,"if ( mount ( ""none"" , path , ""tmpfs"" , 0 , ""size=100000,mode=755"" ) ) {SYSERROR ( ""Failed<S2SV_blank>mounting<S2SV_blank>tmpfs<S2SV_blank>onto<S2SV_blank>%s\\\","if ( safe_mount ( ""none"" , path , ""tmpfs"" , 0 , ""size=100000,mode=755"" , rootfs -> path ? rootfs -> mount : NULL ) ) {SYSERROR ( ""Failed<S2SV_blank>mounting<S2SV_blank>tmpfs<S2SV_blank>onto<S2SV_blank>%s\\\",1892
1492,"# line 495 ""ext/standard/var_unserializer.c""  {","# line 496 ""ext/standard/var_unserializer.c"" {",1893
1493,"yy3 :  # line 860 ""ext/standard/var_unserializer.re""  {# line 557 ""ext/standard/var_unserializer.c""  yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;","yy3 : # line 861 ""ext/standard/var_unserializer.re"" {# line 558 ""ext/standard/var_unserializer.c"" yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;",1893
1494,"# line 854 ""ext/standard/var_unserializer.re""  {# line 606 ""ext/standard/var_unserializer.c""  yy16 : yych = * ++ YYCURSOR ;","# line 855 ""ext/standard/var_unserializer.re"" {# line 607 ""ext/standard/var_unserializer.c"" yy16 : yych = * ++ YYCURSOR ;",1893
1495,"# line 707 ""ext/standard/var_unserializer.re""  {","# line 708 ""ext/standard/var_unserializer.re"" {",1893
1496,"# line 784 ""ext/standard/var_unserializer.c""  yy25 : yych = * ++ YYCURSOR ;","# line 785 ""ext/standard/var_unserializer.c"" yy25 : yych = * ++ YYCURSOR ;",1893
1497,"# line 698 ""ext/standard/var_unserializer.re""  {# line 818 ""ext/standard/var_unserializer.c""  yy32 : yych = * ++ YYCURSOR ;","# line 699 ""ext/standard/var_unserializer.re"" {# line 819 ""ext/standard/var_unserializer.c"" yy32 : yych = * ++ YYCURSOR ;",1893
1498,"# line 677 ""ext/standard/var_unserializer.re""  {","# line 678 ""ext/standard/var_unserializer.re"" {",1893
1499,"# line 860 ""ext/standard/var_unserializer.c""  yy39 : yych = * ++ YYCURSOR ;","# line 861 ""ext/standard/var_unserializer.c"" yy39 : yych = * ++ YYCURSOR ;",1893
1500,"# line 642 ""ext/standard/var_unserializer.re""  {","# line 643 ""ext/standard/var_unserializer.re"" {",1893
1501,"# line 916 ""ext/standard/var_unserializer.c""  yy46 : yych = * ++ YYCURSOR ;","# line 917 ""ext/standard/var_unserializer.c"" yy46 : yych = * ++ YYCURSOR ;",1893
1502,"# line 609 ""ext/standard/var_unserializer.re""  {","# line 610 ""ext/standard/var_unserializer.re"" {",1893
1503,"# line 970 ""ext/standard/var_unserializer.c""  yy53 : yych = * ++ YYCURSOR ;","# line 971 ""ext/standard/var_unserializer.c"" yy53 : yych = * ++ YYCURSOR ;",1893
1504,"# line 599 ""ext/standard/var_unserializer.re""  {# line 1068 ""ext/standard/var_unserializer.c""  yy65 : yych = * ++ YYCURSOR ;","# line 600 ""ext/standard/var_unserializer.re"" {# line 1069 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ;",1893
1505,"# line 584 ""ext/standard/var_unserializer.re""  {","# line 585 ""ext/standard/var_unserializer.re"" {",1893
1506,"# line 1142 ""ext/standard/var_unserializer.c""  yy76 : yych = * ++ YYCURSOR ;","# line 1143 ""ext/standard/var_unserializer.c"" yy76 : yych = * ++ YYCURSOR ;",1893
1507,"# line 557 ""ext/standard/var_unserializer.re""  {","# line 558 ""ext/standard/var_unserializer.re"" {",1893
1508,"# line 1196 ""ext/standard/var_unserializer.c""  yy83 : yych = * ++ YYCURSOR ;# line 550 ""ext/standard/var_unserializer.re""  {# line 1211 ""ext/standard/var_unserializer.c""  yy87 : ++ YYCURSOR ;# line 543 ""ext/standard/var_unserializer.re""  {# line 1221 ""ext/standard/var_unserializer.c""  yy89 : yych = * ++ YYCURSOR ;","# line 1197 ""ext/standard/var_unserializer.c"" yy83 : yych = * ++ YYCURSOR ;# line 551 ""ext/standard/var_unserializer.re"" {# line 1212 ""ext/standard/var_unserializer.c"" yy87 : ++ YYCURSOR ;# line 544 ""ext/standard/var_unserializer.re"" {# line 1222 ""ext/standard/var_unserializer.c"" yy89 : yych = * ++ YYCURSOR ;",1893
1509,"# line 520 ""ext/standard/var_unserializer.re""  {","# line 521 ""ext/standard/var_unserializer.re"" {",1893
1510,"# line 1267 ""ext/standard/var_unserializer.c""  yy95 : yych = * ++ YYCURSOR ;","# line 1268 ""ext/standard/var_unserializer.c"" yy95 : yych = * ++ YYCURSOR ;",1893
1511,"# line 499 ""ext/standard/var_unserializer.re""  {","# line 500 ""ext/standard/var_unserializer.re"" {",1893
1512,"# line 1311 ""ext/standard/var_unserializer.c""  }# line 862 ""ext/standard/var_unserializer.re""  return 0 ;","# line 1312 ""ext/standard/var_unserializer.c"" }# line 862 ""ext/standard/var_unserializer.re"" return 0 ;",1893
1513,bad_fork_cleanup_io :  put_io_context ( p -> io_context ) ;bad_fork_cleanup_namespaces : exit_task_namespaces ( p ) ;,bad_fork_cleanup_io : if ( p -> io_context ) exit_io_context ( p ) ;bad_fork_cleanup_namespaces : exit_task_namespaces ( p ) ;,1894
1514,"void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr )  {vcpu -> arch . apic -> vapic_addr = vapic_addr ;if ( vapic_addr ) __set_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ;else  __clear_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ;}","int kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr ) {if ( vapic_addr ) {if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , vapic_addr , sizeof ( u32 ) ) ) return - EINVAL ;__set_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ;}else {__clear_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ;}vcpu -> arch . apic -> vapic_addr = vapic_addr ;return 0 ;}",1895
1515,"else if ( errno == ENOENT )  touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ;}","else if ( errno == ENOENT ) touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , MODE_INVALID ) ;}",1896
1516,"skb -> sk = sk ;llc_sap_state_process ( sap , skb ) ;","skb_orphan ( skb ) ;sock_hold ( sk ) ;skb -> sk = sk ;skb -> destructor = sock_efree ;llc_sap_state_process ( sap , skb ) ;",1897
1517,if ( res )  return res ;res = register_netdevice ( hsr_dev ) ;,if ( res ) goto err_add_port ;res = register_netdevice ( hsr_dev ) ;,1898
1518,return res ;},err_add_port : hsr_del_node ( & hsr -> self_node_db ) ;return res ;},1898
1519,"vpx_memset ( cm -> above_context , 0 ,  sizeof ( ENTROPY_CONTEXT_PLANES ) * cm -> mb_cols ) ;","memset ( cm -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * cm -> mb_cols ) ;",1899
1520,"if ( tpgt > TL_TPGS_PER_HBA ) {printk ( KERN_ERR ""Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:"" ""<S2SV_blank>%u\\\","if ( tpgt >= TL_TPGS_PER_HBA ) {printk ( KERN_ERR ""Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:"" ""<S2SV_blank>%u\\\",1900
1521,"static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env ,  int insn_idx , int prev_insn_idx )  {if ( err )  goto err ;if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) {","static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env , int insn_idx , int prev_insn_idx , bool speculative ) {elem -> st . speculative |= speculative ;if ( err ) goto err ;if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) {",1901
1522,"vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ;for ( i = 0 ;vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;for ( i = 0 ;vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;for ( i = 0 ;","memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ;for ( i = 0 ;memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;for ( i = 0 ;memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;for ( i = 0 ;",1902
1523,"SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\\","sas_probe_devices ( port ) ;SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\\",1903
1524,if ( key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) {return AIRPDCAP_RET_NO_VALID_HANDSHAKE ;,if ( ( key_bytes_len < GROUP_KEY_MIN_LEN ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) ) || ( key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) {return AIRPDCAP_RET_NO_VALID_HANDSHAKE ;,1904
1525,"}got_buffer_from_side ( side , buffer ) ;","else if ( auth_end == FIND_AUTH_END_ABORT ) {buffer_unref ( buffer ) ;if ( client -> proxy -> log_messages ) g_print ( ""Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\\side_closed ( side ) ;break ;}}got_buffer_from_side ( side , buffer ) ;",1905
1526,"int error ;ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ;","int error ;struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache ;ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ;",1906
1527,"if ( ext2_xattr_cache_insert ( bh ) )  ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ;if ( ext2_xattr_cache_insert ( bh ) )  ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ;","if ( ext2_xattr_cache_insert ( ext2_mb_cache , bh ) ) ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ;if ( ext2_xattr_cache_insert ( ext2_mb_cache , bh ) ) ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ;",1906
1528,"av_bprint_init ( bp , 0 , - 1 ) ;while ( zstream . avail_in > 0 ) {av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ;if ( ! buf_size ) {zstream . avail_out = buf_size ;ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ;","av_bprint_init ( bp , 2 , & buf , & buf_size ) ;if ( buf_size < 2 ) {zstream . avail_out = buf_size - 1 ;ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ;",1907
1529,pid_t my_pid = getpid ( ) ;unsigned idx = 0 ;,"if ( g_settings_privatereports ) {if ( world_readable_dump ) log ( ""Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on"" ) ;mode = DEFAULT_DUMP_DIR_MODE ;my_euid = 0 ;}pid_t my_pid = getpid ( ) ;unsigned idx = 0 ;",1908
1530,"FILE * file ;file = fopen ( stats_file , ""w"" ) ;if ( ! file ) {for ( e = LIST_HEAD ( l ) ;e ;ELEMENT_NEXT ( e ) ) {vrrp = ELEMENT_DATA ( e ) ;","FILE * file = fopen_safe ( stats_file , ""w"" ) ;if ( ! file ) {if ( ! file ) {log_message ( LOG_INFO , ""Can\\\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ;return ;}LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) {",1909
1531,"if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return false ;}Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ;if ( ! defs ) {return false ;}if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) {section_name = & bin -> shstrtab [ shdr -> sh_name ] ;}if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) {link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ;}if ( ! defs ) {bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\return NULL ;}sdb = sdb_new0 ( ) ;end = ( char * ) defs + shdr -> sh_size ;sdb_set ( sdb , ""section_name"" , section_name , 0 ) ;sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( end - ( char * ) defs > i ) ;++ cnt ) {Sdb * sdb_verdef = sdb_new0 ( ) ;char * vstart = ( ( char * ) defs ) + i ;char key [ 32 ] = {0 };Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ;Elf_ ( Verdaux ) aux = {0 };int j = 0 ;int isum = 0 ;r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ;verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ;if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) {sdb_free ( sdb_verdef ) ;",+ cnt ) {if ( shdr -> sh_size < 1 || vstart + vdaux < vstart ) {sdb_free ( sdb_verdef ) ;,1910
1532,"case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ;","case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN + 4 ) ;",1911
1533,pptr += BGP_VPN_RD_LEN ;,pptr += BGP_VPN_RD_LEN + 4 ;,1911
1534,"case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN : case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN :  ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ;offset = strlen ( buf ) ;pptr += BGP_VPN_RD_LEN ;bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ;","case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN : case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ;offset = strlen ( buf ) ;pptr += BGP_VPN_RD_LEN ;bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ;",1911
1535,prefix = report [ i ] ;i ++ ;size = PREF_SIZE ( prefix ) ;case 2 : data16 = get_unaligned_le16 ( & report [ i ] ) ;break ;case 3 :  size = 4 ;data32 = get_unaligned_le32 ( & report [ i ] ) ;,"prefix = report [ i ++ ] ;size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ;if ( i + size > length ) {dev_err ( ddev , ""Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\\break ;}case 4 : data32 = get_unaligned_le32 ( & report [ i ] ) ;",1912
1536,const char * bufptr ;bufptr = buf ;,"const char * bufptr ;if ( cnt < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write"" ) ;}bufptr = buf ;",1913
1537,if ( ALWAYS ( p -> pEList ) ) {ExprList * pList = p -> pEList ;,if ( p -> selFlags & SF_View ) return WRC_Prune ;if ( ALWAYS ( p -> pEList ) ) {ExprList * pList = p -> pEList ;,1914
1538,"ssize_t ret = write ( fd , ev , sizeof ( * ev ) ) ;if ( ret < 0 ) {","ssize_t ret = TEMP_FAILURE_RETRY ( write ( fd , ev , sizeof ( * ev ) ) ) ;if ( ret < 0 ) {",1915
1539,"if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) {log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\\\""%s\\\\"";","if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) || ! expr -> action . args ) {log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\\\""%s\\\\"";",1916
1540,"keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) ,   ( wchar_t * ) kvp_data -> data . key ) ;kvp_data -> data . key_size = 2 * ( keylen + 1 ) ;valuelen = utf8s_to_utf16s ( value , strlen ( value ) ,   ( wchar_t * ) kvp_data -> data . value ) ;kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ;","keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , UTF16_HOST_ENDIAN , ( wchar_t * ) kvp_data -> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 ) ;kvp_data -> data . key_size = 2 * ( keylen + 1 ) ;valuelen = utf8s_to_utf16s ( value , strlen ( value ) , UTF16_HOST_ENDIAN , ( wchar_t * ) kvp_data -> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2 ) ;kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ;",1917
1541,"page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx ) ) ;xen_netbk_idx_release ( netbk , pending_idx ) ;}","page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ) ;xen_netbk_idx_release ( netbk , pending_idx ) ;}",1918
1542,kfree ( umidi ) ;,"
",1919
1543,snd_usbmidi_free ( umidi ) ;return err ;,snd_usbmidi_free ( umidi ) ;return err ;,1919
1544,"struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ;if ( cnt == 1 ) return 0 ;env -> insn_aux_data = new_data ;vfree ( old_data ) ;","struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ;int i ;if ( cnt == 1 ) return 0 ;for ( i = off ;i < off + cnt - 1 ;i ++ ) new_data [ i ] . seen = true ;env -> insn_aux_data = new_data ;vfree ( old_data ) ;",1920
1545,"# ifdef __linux__   sun . sun_path [ 0 ] = \'\\\\0\' ;memcpy ( sun . sun_path + 1 , path , strlen ( path ) ) ;sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( path ) + 1 ;remove_control_socket ( path ) ;# endif if ( bind ( fd , ( const struct sockaddr * ) & sun , sun_len ) < 0 ) {","memcpy ( sun . sun_path [ 0 ] = \'\\\\0\' ;memcpy ( sun . sun_path , path , strlen ( path ) ) ;sun_len = sizeof ( struct sockaddr_un , sun_path ) + strlen ( path ) + 1 ;remove_control_socket ( path ) ;if ( bind ( fd , ( const struct sockaddr * ) & sun , sun_len ) < 0 ) {",1921
1546,"return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" ,  name ) ;","return try_then_request_module ( __crypto_lookup_template ( name ) , ""crypto-%s"" , name ) ;",1922
1547,"SET_NETDEV_DEV ( dev , dmdev ) ;reset_card ( dev , 1 ) ;","dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;SET_NETDEV_DEV ( dev , dmdev ) ;reset_card ( dev , 1 ) ;",1923
1548,"# line 1661 ""grammar.c"" break ;case 10 : # line 251 ""grammar.y"" {YR_RULE * rule = ( yyvsp [ - 4 ] . rule ) ;rule -> tags = ( yyvsp [ - 3 ] . c_string ) ;rule -> metas = ( yyvsp [ - 1 ] . meta ) ;rule -> strings = ( yyvsp [ 0 ] . string ) ;}# line 1686 ""grammar.c"" break ;case 11 : # line 259 ""grammar.y"" {YR_RULE * rule = ( yyvsp [ - 7 ] . rule ) ;compiler -> last_result = yr_parser_reduce_rule_declaration_phase_2 ( yyscanner , rule ) ;yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 1701 ""grammar.c"" break ;case 12 : # line 274 ""grammar.y"" {( yyval . meta ) = NULL ;}# line 1709 ""grammar.c"" break ;case 13 : # line 278 ""grammar.y"" {YR_META null_meta ;memset ( & null_meta , 0xFF , sizeof ( YR_META ) ) ;null_meta . type = META_TYPE_NULL ;compiler -> last_result = yr_arena_write_data ( compiler -> metas_arena , & null_meta , sizeof ( YR_META ) , NULL ) ;( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 1736 ""grammar.c"" break ;case 14 : # line 305 ""grammar.y"" {( yyval . string ) = NULL ;}# line 1744 ""grammar.c"" break ;case 15 : # line 309 ""grammar.y"" {YR_STRING null_string ;memset ( & null_string , 0xFF , sizeof ( YR_STRING ) ) ;null_string . g_flags = STRING_GFLAGS_NULL ;compiler -> last_result = yr_arena_write_data ( compiler -> strings_arena , & null_string , sizeof ( YR_STRING ) , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . string ) = ( yyvsp [ 0 ] . string ) ;}# line 1771 ""grammar.c"" break ;case 17 : # line 340 ""grammar.y"" {( yyval . integer ) = 0 ;}# line 1777 ""grammar.c"" break ;case 18 : # line 341 ""grammar.y"" {( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ;}# line 1783 ""grammar.c"" break ;case 19 : # line 346 ""grammar.y"" {( yyval . integer ) = RULE_GFLAGS_PRIVATE ;}# line 1789 ""grammar.c"" break ;case 20 : # line 347 ""grammar.y"" {( yyval . integer ) = RULE_GFLAGS_GLOBAL ;}# line 1795 ""grammar.c"" break ;case 21 : # line 353 ""grammar.y"" {( yyval . c_string ) = NULL ;}# line 1803 ""grammar.c"" break ;case 22 : # line 357 ""grammar.y"" {compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , """" , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ;}# line 1821 ""grammar.c"" break ;case 23 : # line 375 ""grammar.y"" {char * identifier ;compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & identifier ) ;yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . c_string ) = identifier ;}# line 1838 ""grammar.c"" break ;case 24 : # line 388 ""grammar.y"" {char * tag_name = ( yyvsp [ - 1 ] . c_string ) ;size_t tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ;while ( tag_length > 0 ) {if ( strcmp ( tag_name , ( yyvsp [ 0 ] . c_string ) ) == 0 ) {yr_compiler_set_error_extra_info ( compiler , tag_name ) ;compiler -> last_result = ERROR_DUPLICATED_TAG_IDENTIFIER ;break ;}tag_name = ( char * ) yr_arena_next_address ( yyget_extra ( yyscanner ) -> sz_arena , tag_name , tag_length + 1 ) ;tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ;}if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , NULL ) ;yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . c_string ) = ( yyvsp [ - 1 ] . c_string ) ;}# line 1874 ""grammar.c"" break ;case 25 : # line 424 ""grammar.y"" {( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ;}# line 1880 ""grammar.c"" break ;case 26 : # line 425 ""grammar.y"" {( yyval . meta ) = ( yyvsp [ - 1 ] . meta ) ;}# line 1886 ""grammar.c"" break ;case 27 : # line 431 ""grammar.y"" {SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ;( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_STRING , ( yyvsp [ - 2 ] . c_string ) , sized_string -> c_string , 0 ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1906 ""grammar.c"" break ;case 28 : # line 447 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 2 ] . c_string ) , NULL , ( yyvsp [ 0 ] . integer ) ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1923 ""grammar.c"" break ;case 29 : # line 460 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 3 ] . c_string ) , NULL , - ( yyvsp [ 0 ] . integer ) ) ;yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1940 ""grammar.c"" break ;case 30 : # line 473 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , TRUE ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1957 ""grammar.c"" break ;case 31 : # line 486 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , FALSE ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1974 ""grammar.c"" break ;case 32 : # line 502 ""grammar.y"" {( yyval . string ) = ( yyvsp [ 0 ] . string ) ;}# line 1980 ""grammar.c"" break ;case 33 : # line 503 ""grammar.y"" {( yyval . string ) = ( yyvsp [ - 1 ] . string ) ;}# line 1986 ""grammar.c"" break ;case 34 : # line 509 ""grammar.y"" {compiler -> error_line = yyget_lineno ( yyscanner ) ;}# line 1994 ""grammar.c"" break ;case 35 : # line 513 ""grammar.y"" {( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ;yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ;yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ;ERROR_IF ( ( yyval . string ) == NULL ) ;compiler -> error_line = 0 ;}# line 2009 ""grammar.c"" break ;case 36 : # line 524 ""grammar.y"" {compiler -> error_line = yyget_lineno ( yyscanner ) ;}# line 2017 ""grammar.c"" break ;case 37 : # line 528 ""grammar.y"" {( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) | STRING_GFLAGS_REGEXP , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ;yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ;yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ;ERROR_IF ( ( yyval . string ) == NULL ) ;compiler -> error_line = 0 ;}# line 2033 ""grammar.c"" break ;case 38 : # line 540 ""grammar.y"" {( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , STRING_GFLAGS_HEXADECIMAL , ( yyvsp [ - 2 ] . c_string ) , ( yyvsp [ 0 ] . sized_string ) ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ;ERROR_IF ( ( yyval . string ) == NULL ) ;}# line 2047 ""grammar.c"" break ;case 39 : # line 553 ""grammar.y"" {( yyval . integer ) = 0 ;}# line 2053 ""grammar.c"" break ;case 40 : # line 554 ""grammar.y"" {( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ;}# line 2059 ""grammar.c"" break ;case 41 : # line 559 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_WIDE ;}# line 2065 ""grammar.c"" break ;case 42 : # line 560 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_ASCII ;}# line 2071 ""grammar.c"" break ;case 43 : # line 561 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_NO_CASE ;}# line 2077 ""grammar.c"" break ;case 44 : # line 562 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_FULL_WORD ;}# line 2083 ""grammar.c"" break ;case 45 : # line 568 ""grammar.y"" {","# line 2628 ""grammar.c"" break ;case 64 : # line 1054 ""grammar.y"" {",1924
1549,"# line 2451 ""grammar.c"" break ;","# line 2667 ""grammar.c"" break ;",1924
1550,"case 55 : # line 936 ""grammar.y"" {compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ;}# line 2487 ""grammar.c"" break ;case 56 : # line 945 ""grammar.y"" {compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 0 , NULL , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ;}# line 2500 ""grammar.c"" break ;case 57 : # line 954 ""grammar.y"" {CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , ""matches"" ) ;CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_REGEXP , ""matches"" ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit ( yyscanner , OP_MATCHES , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ;}# line 2519 ""grammar.c"" break ;case 58 : # line 969 ""grammar.y"" {CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , ""contains"" ) ;CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_STRING , ""contains"" ) ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_CONTAINS , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ;}# line 2535 ""grammar.c"" break ;case 59 : # line 981 ""grammar.y"" {","case 65 : # line 1089 ""grammar.y"" {",1924
1551,int var_index ;if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ;,"compiler -> loop_depth -- ;compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ;}# line 2594 ""grammar.c"" break ;case 63 : # line 1024 ""grammar.y"" {int var_index ;if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ;",1924
1552,"# line 2619 ""grammar.c""  break ;case 63 :  # line 1049 ""grammar.y"" {","# line 2750 ""grammar.c"" break ;case 63 : # line 1049 ""grammar.y"" {",1924
1553,"# line 2658 ""grammar.c""  break ;case 64 :  # line 1084 ""grammar.y"" {","# line 2658 ""grammar.c"" break ;case 66 : # line 1168 ""grammar.y"" {",1924
1554,"# line 2741 ""grammar.c""  break ;case 65 :  # line 1163 ""grammar.y"" {","# line 2784 ""grammar.c"" break ;case 65 : # line 1163 ""grammar.y"" {",1924
1555,"# line 2775 ""grammar.c""  break ;case 66 :  # line 1193 ""grammar.y"" {","# line 2775 ""grammar.c"" break ;case 67 : # line 1198 ""grammar.y"" {",1924
1556,"# line 2828 ""grammar.c""  break ;case 67 : # line 1242 ""grammar.y"" {# line 2838 ""grammar.c"" break ;case 68 :  # line 1248 ""grammar.y""  {yr_parser_emit ( yyscanner , OP_NOT , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ;# line 2848 ""grammar.c""  break ;case 69 :  # line 1254 ""grammar.y""  {","# line 2837 ""grammar.c"" break ;case 67 : # line 1247 ""grammar.y"" {# line 2847 ""grammar.c"" break ;case 68 : # line 1253 ""grammar.y"" {yr_parser_emit ( yyscanner , OP_NOT , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ;# line 2857 ""grammar.c"" break ;case 70 : # line 1259 ""grammar.y"" {",1924
1557,"# line 2878 ""grammar.c""  break ;case 70 :  # line 1280 ""grammar.y"" {","# line 2887 ""grammar.c"" break ;case 70 : # line 1280 ""grammar.y"" {",1924
1558,"# line 2918 ""grammar.c""  break ;case 71 :  # line 1316 ""grammar.y"" {","# line 2918 ""grammar.c"" break ;case 71 : # line 1285 ""grammar.y"" {",1924
1559,"# line 2947 ""grammar.c""  break ;case 72 :  # line 1341 ""grammar.y"" {","# line 2927 ""grammar.c"" break ;case 72 : # line 1341 ""grammar.y"" {",1924
1560,"# line 2987 ""grammar.c""  break ;case 73 :  # line 1377 ""grammar.y"" {# line 3000 ""grammar.c""  break ;case 74 :  # line 1386 ""grammar.y"" {# line 3013 ""grammar.c""  break ;case 75 :  # line 1395 ""grammar.y"" {# line 3026 ""grammar.c""  break ;case 76 :  # line 1404 ""grammar.y"" {# line 3039 ""grammar.c""  break ;case 77 :  # line 1413 ""grammar.y"" {# line 3052 ""grammar.c""  break ;case 78 :  # line 1422 ""grammar.y"" {# line 3065 ""grammar.c""  break ;case 79 : # line 1431 ""grammar.y"" {( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ;}# line 3073 ""grammar.c"" break ;case 80 :  # line 1435 ""grammar.y""  {( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ;}# line 3081 ""grammar.c""  break ;case 81 : # line 1442 ""grammar.y"" {( yyval . integer ) = INTEGER_SET_ENUMERATION ;}# line 3087 ""grammar.c"" break ;case 82 :  # line 1443 ""grammar.y""   {( yyval . integer ) = INTEGER_SET_RANGE ;}# line 3093 ""grammar.c"" break ;case 83 :  # line 1449 ""grammar.y""  {if ( ( yyvsp [ - 3 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) {yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\\\'s<S2SV_blank>lower<S2SV_blank>bound"" ) ;compiler -> last_result = ERROR_WRONG_TYPE ;}if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) {yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\\\'s<S2SV_blank>upper<S2SV_blank>bound"" ) ;compiler -> last_result = ERROR_WRONG_TYPE ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 3115 ""grammar.c""  break ;case 84 :  # line 1471 ""grammar.y"" {if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) {yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item"" ) ;compiler -> last_result = ERROR_WRONG_TYPE ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 3131 ""grammar.c""  break ;case 85 :  # line 1483 ""grammar.y"" {if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) {yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item"" ) ;compiler -> last_result = ERROR_WRONG_TYPE ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 3146 ""grammar.c""  break ;case 86 : # line 1498 ""grammar.y"" {yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ;}# line 3155 ""grammar.c"" break ;case 88 :  # line 1504 ""grammar.y"" {yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ;yr_parser_emit_pushes_for_strings ( yyscanner , ""$*"" ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 3166 ""grammar.c""  break ;case 91 :  # line 1521 ""grammar.y"" {yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ;yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 3177 ""grammar.c""  break ;case 92 :  # line 1528 ""grammar.y"" {yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ;yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 3188 ""grammar.c""  break ;case 94 : # line 1540 ""grammar.y"" {yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ;}# line 3196 ""grammar.c"" break ;case 95 :  # line 1544 ""grammar.y""  {yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ;}# line 3204 ""grammar.c"" break ;case 96 :  # line 1552 ""grammar.y""  {( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ;}# line 3212 ""grammar.c""  break ;case 97 :  # line 1556 ""grammar.y"" {# line 3226 ""grammar.c""  break ;case 98 :  # line 1566 ""grammar.y"" {# line 3244 ""grammar.c""  break ;case 99 :  # line 1580 ""grammar.y"" {# line 3264 ""grammar.c""  break ;case 100 :  # line 1596 ""grammar.y"" {# line 3278 ""grammar.c""  break ;case 101 :  # line 1606 ""grammar.y"" {# line 3291 ""grammar.c""  break ;case 102 :  # line 1615 ""grammar.y"" {","# line 2956 ""grammar.c"" break ;case 73 : # line 1377 ""grammar.y"" {# line 2996 ""grammar.c"" break ;case 74 : # line 1386 ""grammar.y"" {# line 3013 ""grammar.c"" break ;case 74 : # line 1382 ""grammar.y"" {# line 3009 ""grammar.c"" break ;case 76 : # line 1404 ""grammar.y"" {# line 3039 ""grammar.c"" break ;case 75 : # line 1391 ""grammar.y"" {# line 3022 ""grammar.c"" break ;case 78 : # line 1422 ""grammar.y"" {# line 3065 ""grammar.c"" break ;case 76 : # line 1400 ""grammar.y"" {# line 3226 ""grammar.c"" break ;case 98 : # line 1566 ""grammar.y"" {# line 3244 ""grammar.c"" break ;case 99 : # line 1580 ""grammar.y"" {# line 3264 ""grammar.c"" break ;case 100 : # line 1596 ""grammar.y"" {# line 3278 ""grammar.c"" break ;case 101 : # line 1606 ""grammar.y"" {# line 3291 ""grammar.c"" break ;case 102 : # line 1615 ""grammar.y"" {",1924
1561,"# line 3320 ""grammar.c""  break ;case 103 :  # line 1640 ""grammar.y"" {# line 3336 ""grammar.c""  break ;case 104 :  # line 1652 ""grammar.y"" {# line 3352 ""grammar.c""  break ;case 105 :  # line 1664 ""grammar.y"" {","# line 3320 ""grammar.c"" break ;case 103 : # line 1640 ""grammar.y"" {# line 3336 ""grammar.c"" break ;case 104 : # line 1652 ""grammar.y"" {# line 3035 ""grammar.c"" break ;case 105 : # line 1664 ""grammar.y"" {",1924
1562,"# line 3372 ""grammar.c""  break ;case 106 :  # line 1680 ""grammar.y"" {# line 3388 ""grammar.c""  break ;case 107 :  # line 1692 ""grammar.y"" {","# line 3372 ""grammar.c"" break ;case 77 : # line 1409 ""grammar.y"" {# line 3048 ""grammar.c"" break ;case 107 : # line 1692 ""grammar.y"" {",1924
1563,"# line 3408 ""grammar.c""  break ;case 108 :  # line 1708 ""grammar.y"" {if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) {( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;}else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_BOOLEAN ) {( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ;( yyval . expression ) . value . integer = UNDEFINED ;}else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_OBJECT ) {compiler -> last_result = yr_parser_emit ( yyscanner , OP_OBJ_VALUE , NULL ) ;switch ( ( yyvsp [ 0 ] . expression ) . value . object -> type ) {case OBJECT_TYPE_INTEGER : ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;break ;case OBJECT_TYPE_FLOAT : ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ;break ;case OBJECT_TYPE_STRING : ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ;( yyval . expression ) . value . sized_string = NULL ;break ;default : yr_compiler_set_error_extra_info_fmt ( compiler , ""wrong<S2SV_blank>usage<S2SV_blank>of<S2SV_blank>identifier<S2SV_blank>\\\\""%s\\\\"""" , ( yyvsp [ 0 ] . expression ) . identifier ) ;compiler -> last_result = ERROR_WRONG_TYPE ;}}else {assert ( FALSE ) ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 3457 ""grammar.c""  break ;case 109 :  # line 1753 ""grammar.y"" {CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT , ""-"" ) ;if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) {( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : - ( ( yyvsp [ 0 ] . expression ) . value . integer ) ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_INT_MINUS , NULL ) ;}else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_FLOAT ) {( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_DBL_MINUS , NULL ) ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 3480 ""grammar.c""  break ;case 110 :  # line 1772 ""grammar.y"" {","# line 3408 ""grammar.c"" break ;case 78 : # line 1418 ""grammar.y"" {",1924
1564,"# line 3502 ""grammar.c""  break ;case 111 :  # line 1790 ""grammar.y"" {","# line 3502 ""grammar.c"" break ;case 111 : # line 1790 ""grammar.y"" {",1924
1565,"# line 3524 ""grammar.c""  break ;case 112 :  # line 1808 ""grammar.y"" {","# line 3524 ""grammar.c"" break ;case 112 : # line 1808 ""grammar.y"" {",1924
1566,"# line 3546 ""grammar.c""  break ;case 113 :  # line 1826 ""grammar.y"" {","# line 3061 ""grammar.c"" break ;case 113 : # line 1826 ""grammar.y"" {",1924
1567,"# line 3576 ""grammar.c""  break ;case 114 :  # line 1852 ""grammar.y"" {CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""%"" ) ;CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""%"" ) ;yr_parser_emit ( yyscanner , OP_MOD , NULL ) ;if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) {( yyval . expression ) . value . integer = OPERATION ( % , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;}else {compiler -> last_result = ERROR_DIVISION_BY_ZERO ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}}# line 3598 ""grammar.c""  break ;case 115 :  # line 1870 ""grammar.y"" {CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ;CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ;yr_parser_emit ( yyscanner , OP_BITWISE_XOR , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = OPERATION ( ^ , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ;}# line 3612 ""grammar.c""  break ;case 116 :  # line 1880 ""grammar.y"" {CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ;CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ;yr_parser_emit ( yyscanner , OP_BITWISE_AND , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = OPERATION ( & , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ;}# line 3626 ""grammar.c""  break ;case 117 :  # line 1890 ""grammar.y"" {CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""|"" ) ;CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""|"" ) ;yr_parser_emit ( yyscanner , OP_BITWISE_OR , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = OPERATION ( | , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ;}# line 3640 ""grammar.c""  break ;case 118 :  # line 1900 ""grammar.y"" {CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""~"" ) ;yr_parser_emit ( yyscanner , OP_BITWISE_NOT , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : ~ ( ( yyvsp [ 0 ] . expression ) . value . integer ) ;}# line 3654 ""grammar.c""  break ;case 119 :  # line 1910 ""grammar.y"" {CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""<<"" ) ;CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""<<"" ) ;yr_parser_emit ( yyscanner , OP_SHL , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = OPERATION ( << , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ;}# line 3668 ""grammar.c""  break ;case 120 :  # line 1920 ""grammar.y"" {CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , "">>"" ) ;CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "">>"" ) ;yr_parser_emit ( yyscanner , OP_SHR , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = OPERATION ( >> , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ;# line 3682 ""grammar.c""  break ;case 121 :  # line 1930 ""grammar.y"" {# line 3690 ""grammar.c""  break ;# line 3694 ""grammar.c""  default : break ;","# line 3074 ""grammar.c"" break ;case 114 : # line 1436 ""grammar.y"" {( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ;# line 3082 ""grammar.c"" break ;case 81 : # line 1440 ""grammar.y"" {# line 3690 ""grammar.c"" break ;# line 3694 ""grammar.c"" default : break ;",1924
1568,"rpc_delay ( task , 3 * HZ ) ;goto retry_timeout ;","if ( task -> tk_rebind_retry == 0 ) break ;task -> tk_rebind_retry -- ;rpc_delay ( task , 3 * HZ ) ;goto retry_timeout ;",1925
1569,"gboolean devel ;child_setup_data . instance_id_fd = - 1 ;if ( fd_list != NULL ) fds = g_unix_fd_list_peek_fds ( fd_list , & fds_len ) ;","gboolean devel ;g_autoptr ( GString ) env_string = g_string_new ( """" ) ;child_setup_data . instance_id_fd = - 1 ;child_setup_data . env_fd = - 1 ;if ( fd_list != NULL ) fds = g_unix_fd_list_peek_fds ( fd_list , & fds_len ) ;",1926
1570,"
","if ( g_str_has_prefix ( extra_args [ i ] ) ) ;}}}if ( env_string -> len > 0 ) {g_auto ( GLnxTmpfile ) env_tmpf = {0 , };if ( ! flatpak_buffer_to_sealed_memfd_or_tmpfile ( & env_tmpf , ""environ"" , env_string -> str , env_string -> len , & error ) ) {g_dbus_method_invocation_return_gerror ( invocation , error ) ;return G_DBUS_METHOD_INVOCATION_HANDLED ;}child_setup_data . env_fd = glnx_steal_fd ( & env_tmpf . fd ) ;g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--env-fd=%d"" , child_setup_data . env_fd , ""--env="" ) ) {const char * var_val = extra_args [ i ] + strlen ( ""--env="" ) ;if ( var_val [ 0 ] == \'\\\\0\' || var_val [ 0 ] == \'=\' ) {g_warning ( ""Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>empty<S2SV_blank>name"" ) ;continue ;}if ( strchr ( var_val , \'=\' ) == NULL ) {g_warning ( ""Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value"" ) ;continue ;}g_string_append ( env_string , var_val ) ;g_string_append_c ( env_string , \'\\\\0\' ) ;}else {{",1926
1571,"i ++ )  g_ptr_array_add ( flatpak_argv , g_strdup ( extra_args [ i ] ) ) ;}","i ++ ) g_ptr_array_add ( flatpak_argv , g_strdup ( extra_args [ i ] ) ) ;}",1926
1572,"
","baud = min ( baud , 461550 ) ;{",1927
1573,"}else   tty_encode_baud_rate ( tty , baud , baud ) ;edge_port -> baud_rate = baud ;","}else tty_encode_baud_rate ( tty , baud , baud ) ;}edge_port -> baud_rate = baud ;",1927
1574,"rcu_read_lock ( ) ;dev = dev_get_by_name_rcu ( net , name ) ;rcu_read_unlock ( ) ;if ( ! dev && capable ( CAP_NET_ADMIN ) )   request_module ( ""%s"" , name ) ;}","int no_module ;rcu_read_lock ( ) ;no_module = ! dev ;if ( no_module && capable ( CAP_NET_ADMIN ) ) no_module = request_module ( ""netdev-%s"" , name ) ) pr_err ( ""Loading<S2SV_blank>kernel<S2SV_blank>module<S2SV_blank>for<S2SV_blank>a<S2SV_blank>network<S2SV_blank>device<S2SV_blank>"" ""with<S2SV_blank>CAP_SYS_MODULE<S2SV_blank>(deprecated).<S2SV_blank><S2SV_blank>Use<S2SV_blank>CAP_NET_ADMIN<S2SV_blank>and<S2SV_blank>alias<S2SV_blank>netdev-%s<S2SV_blank>"" ""instead\\\}}",1928
1575,InitializeCriticalSection ( & finalizer_mutex ) ;MONO_GC_REGISTER_ROOT_FIXED ( gc_handles [ HANDLE_NORMAL ] . entries ) ;,InitializeCriticalSection ( & finalizer_mutex ) ;InitializeCriticalSection ( & reference_queue_mutex ) ;MONO_GC_REGISTER_ROOT_FIXED ( gc_handles [ HANDLE_NORMAL ] . entries ) ;,1929
1576,StringValue ( data ) ;in = ( unsigned char * ) RSTRING_PTR ( data ) ;,"if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ;StringValue ( data ) ;in = ( unsigned char * ) RSTRING_PTR ( data ) ;",1930
1577,"vpx_memcpy ( & local_next_frame , next_frame , sizeof ( * next_frame ) ) ;start_pos = cpi -> twopass . stats_in ;","memcpy ( & local_next_frame , next_frame , sizeof ( * next_frame ) ) ;start_pos = cpi -> twopass . stats_in ;",1931
1578,"if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 )   OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {done :  if ( buf ) oe_free ( buf ) ;","size_t data_size = 0 ;if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( ret > ( ssize_t ) data_size ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : if ( buf ) oe_free ( buf ) ;",1932
1579,"if ( x )  VPX_MEMSET_L ( x , 0 , num * size ) ;return x ;","if ( x ) memset ( x , 0 , num * size ) ;return x ;",1933
1580,if ( TYPE ( n ) == parameters ) {,if ( i < NCH ( n ) && TYPE ( n ) == parameters ) {,1934
1581,"if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;","if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;",1934
1582,"
",oidc_scrub_headers ( r ) ;,1935
1583,char * authn_header = oidc_cfg_dir_authn_header ( r ) ;int pass_headers = oidc_cfg_dir_pass_info_in_headers ( r ) ;,char * authn_header = oidc_cfg_dir_authn_header ( r ) ;int pass_headers = oidc_cfg_dir_pass_info_in_headers ( r ) ;,1935
1584,"int points ;if ( oom_unkillable_task ( p , mem , nodemask ) ) return 0 ;","long points ;if ( oom_unkillable_task ( p , mem , nodemask ) ) return 0 ;",1936
1585,"
",if ( ! imapd_userisadmin ) goto badcmd ;,1937
1586,"
",if ( ! imapd_userisadmin ) goto badcmd ;if ( ! imapd_userisadmin ) goto badcmd ;if ( ! imapd_userisadmin ) goto badcmd ;,1937
1587,"struct dlist * kl = sync_parseline ( imapd_in ) ;if ( kl ) {struct dlist * kl = sync_parseline ( imapd_in ) ;if ( kl ) {if ( c == \'\\\\r\' ) c = prot_getc ( imapd_in ) ;if ( c != \'\\\else if ( ! strcmp ( cmd . s , ""Syncrestore"" ) ) {struct dlist * kl = sync_parseline ( imapd_in ) ;","struct dlist * kl = sync_parseline ( imapd_in ) ;if ( kl ) {struct dlist * kl = sync_parseline ( imapd_in ) ;if ( kl ) {if ( c == \'\\\\r\' ) c = prot_getc ( imapd_in ) ;if ( c != \'\\\else if ( ! strcmp ( cmd . s , ""Syncrestore"" ) ) {struct dlist * kl = sync_parseline ( imapd_in ) ;",1937
1588,"if ( copy_from_user ( & u_ent . id , & uent -> id , sizeof ( u_ent . id ) ) )  return - EFAULT ;","memset ( & u_ent , 0 , sizeof ( u_ent ) ) ;if ( copy_from_user ( & u_ent . id , & uent -> id , sizeof ( u_ent . id ) ) ) return - EFAULT ;",1938
1589,"if ( keyring_key -> type != & key_type_logon ) {printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\\down_read ( & keyring_key -> sem ) ;ukp = user_key_payload ( keyring_key ) ;if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) {up_read ( & keyring_key -> sem ) ;","down_read ( & keyring_key -> sem ) ;if ( keyring_key -> type != & key_type_logon ) {printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\\ukp = user_key_payload ( keyring_key ) ;if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) {",1939
1590,up_read ( & keyring_key -> sem ) ;up_read ( & keyring_key -> sem ) ;if ( res ) goto out ;crypt_info -> ci_keyring_key = keyring_key ;return 0 ;out : key_put ( keyring_key ) ;,out : up_read ( & keyring_key -> sem ) ;key_put ( keyring_key ) ;,1939
1591,"# line 495 ""ext/standard/var_unserializer.c""  {","# line 496 ""ext/standard/var_unserializer.c"" {",1940
1592,"yy3 :  # line 860 ""ext/standard/var_unserializer.re""  {# line 557 ""ext/standard/var_unserializer.c""  yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;","yy3 : # line 861 ""ext/standard/var_unserializer.re"" {# line 558 ""ext/standard/var_unserializer.c"" yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;",1940
1593,"# line 854 ""ext/standard/var_unserializer.re""  {# line 606 ""ext/standard/var_unserializer.c""  yy16 : yych = * ++ YYCURSOR ;","# line 855 ""ext/standard/var_unserializer.re"" {# line 607 ""ext/standard/var_unserializer.c"" yy16 : yych = * ++ YYCURSOR ;",1940
1594,"# line 707 ""ext/standard/var_unserializer.re""  {","# line 708 ""ext/standard/var_unserializer.re"" {",1940
1595,"# line 784 ""ext/standard/var_unserializer.c""  yy25 : yych = * ++ YYCURSOR ;","# line 785 ""ext/standard/var_unserializer.c"" yy25 : yych = * ++ YYCURSOR ;",1940
1596,"# line 698 ""ext/standard/var_unserializer.re""  {# line 818 ""ext/standard/var_unserializer.c""  yy32 : yych = * ++ YYCURSOR ;","# line 699 ""ext/standard/var_unserializer.re"" {# line 819 ""ext/standard/var_unserializer.c"" yy32 : yych = * ++ YYCURSOR ;",1940
1597,"# line 677 ""ext/standard/var_unserializer.re""  {","# line 678 ""ext/standard/var_unserializer.re"" {",1940
1598,"# line 860 ""ext/standard/var_unserializer.c""  yy39 : yych = * ++ YYCURSOR ;","# line 861 ""ext/standard/var_unserializer.c"" yy39 : yych = * ++ YYCURSOR ;",1940
1599,"# line 642 ""ext/standard/var_unserializer.re""  {","# line 643 ""ext/standard/var_unserializer.re"" {",1940
1600,"# line 916 ""ext/standard/var_unserializer.c""  yy46 : yych = * ++ YYCURSOR ;","# line 917 ""ext/standard/var_unserializer.c"" yy46 : yych = * ++ YYCURSOR ;",1940
1601,"# line 609 ""ext/standard/var_unserializer.re""  {","# line 610 ""ext/standard/var_unserializer.re"" {",1940
1602,"# line 970 ""ext/standard/var_unserializer.c""  yy53 : yych = * ++ YYCURSOR ;","# line 971 ""ext/standard/var_unserializer.c"" yy53 : yych = * ++ YYCURSOR ;",1940
1603,"# line 599 ""ext/standard/var_unserializer.re""  {# line 1068 ""ext/standard/var_unserializer.c""  yy65 : yych = * ++ YYCURSOR ;","# line 600 ""ext/standard/var_unserializer.re"" {# line 1069 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ;",1940
1604,"# line 584 ""ext/standard/var_unserializer.re""  {","# line 585 ""ext/standard/var_unserializer.re"" {",1940
1605,"# line 1142 ""ext/standard/var_unserializer.c""  yy76 : yych = * ++ YYCURSOR ;","# line 1143 ""ext/standard/var_unserializer.c"" yy76 : yych = * ++ YYCURSOR ;",1940
1606,"# line 557 ""ext/standard/var_unserializer.re""  {","# line 558 ""ext/standard/var_unserializer.re"" {",1940
1607,"# line 1196 ""ext/standard/var_unserializer.c""  yy83 : yych = * ++ YYCURSOR ;# line 550 ""ext/standard/var_unserializer.re""  {# line 1211 ""ext/standard/var_unserializer.c""  yy87 : ++ YYCURSOR ;# line 543 ""ext/standard/var_unserializer.re""  {# line 1221 ""ext/standard/var_unserializer.c""  yy89 : yych = * ++ YYCURSOR ;","# line 1197 ""ext/standard/var_unserializer.c"" yy83 : yych = * ++ YYCURSOR ;# line 551 ""ext/standard/var_unserializer.re"" {# line 1212 ""ext/standard/var_unserializer.c"" yy87 : ++ YYCURSOR ;# line 544 ""ext/standard/var_unserializer.re"" {# line 1222 ""ext/standard/var_unserializer.c"" yy89 : yych = * ++ YYCURSOR ;",1940
1608,"# line 520 ""ext/standard/var_unserializer.re""  {","# line 521 ""ext/standard/var_unserializer.re"" {",1940
1609,"# line 1267 ""ext/standard/var_unserializer.c""  yy95 : yych = * ++ YYCURSOR ;","# line 1268 ""ext/standard/var_unserializer.c"" yy95 : yych = * ++ YYCURSOR ;",1940
1610,"# line 499 ""ext/standard/var_unserializer.re""  {","# line 500 ""ext/standard/var_unserializer.re"" {",1940
1611,"# line 1311 ""ext/standard/var_unserializer.c""  }# line 862 ""ext/standard/var_unserializer.re""  return 0 ;","# line 1312 ""ext/standard/var_unserializer.c"" }# line 862 ""ext/standard/var_unserializer.re"" return 0 ;",1940
1612,unsigned fat_length ;unsigned total_fat_entries ;,off_t fat_length ;unsigned total_fat_entries ;,1941
1613,"fs -> fat_start = ( off_t ) le16toh ( b . reserved ) * logical_sector_size ;fs -> root_start = ( ( off_t ) le16toh ( b . reserved ) + b . fats * fat_length ) * logical_sector_size ;fs -> data_start = fs -> root_start + ROUND_TO_MULTIPLE ( fs -> root_entries << MSDOS_DIR_BITS , logical_sector_size ) ;data_size = ( off_t ) total_sectors * logical_sector_size - fs -> data_start ;fs -> data_clusters = data_size / fs -> cluster_size ;","if ( ! fat_length ) die ( ""FAT<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ;fs -> fat_start = ( off_t ) le16toh ( b . reserved ) * logical_sector_size ;fs -> root_start = ( ( off_t ) le16toh ( b . reserved ) + b . fats * fat_length ) * logical_sector_size ;fs -> data_start ;if ( data_size < fs -> cluster_size ) die ( ""Filesystem<S2SV_blank>has<S2SV_blank>no<S2SV_blank>space<S2SV_blank>for<S2SV_blank>any<S2SV_blank>data<S2SV_blank>clusters"" ) = fs -> root_start + ROUND_TO_MULTIPLE ( fs -> root_entries << MSDOS_DIR_BITS , logical_sector_size ) ;data_size = ( off_t ) total_sectors * logical_sector_size - fs -> data_start ;fs -> data_clusters = data_size / fs -> cluster_size ;",1941
1614,"if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ;__TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ;if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ;th = ( const struct tcphdr * ) skb -> data ;if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ;if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ;if ( skb_checksum_init ( skb , IPPROTO_TCP , inet_compute_pseudo ) ) goto csum_error ;th = ( const struct tcphdr * ) skb -> data ;iph = ip_hdr ( skb ) ;memmove ( & TCP_SKB_CB ( skb ) -> header . h4 , IPCB ( skb ) , sizeof ( struct inet_skb_parm ) ) ;barrier ( ) ;TCP_SKB_CB ( skb ) -> seq = ntohl ( th -> seq ) ;TCP_SKB_CB ( skb ) -> end_seq = ( TCP_SKB_CB ( skb ) -> seq + th -> syn + th -> fin + skb -> len - th -> doff * 4 ) ;TCP_SKB_CB ( skb ) -> ack_seq = ntohl ( th -> ack_seq ) ;TCP_SKB_CB ( skb ) -> tcp_flags = tcp_flag_byte ( th ) ;TCP_SKB_CB ( skb ) -> tcp_tw_isn = 0 ;TCP_SKB_CB ( skb ) -> ip_dsfield = ipv4_get_dsfield ( iph ) ;TCP_SKB_CB ( skb ) -> sacked = 0 ;lookup : sk = __inet_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , & refcounted ) ;if ( ! sk ) goto no_tcp_socket ;process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ;if ( sk -> sk_state == TCP_NEW_SYN_RECV ) {struct request_sock * req = inet_reqsk ( sk ) ;struct sock * nsk ;sk = req -> rsk_listener ;if ( unlikely ( tcp_v4_inbound_md5_hash ( sk , skb ) ) ) {","if ( tcp_filter ( sk , skb ) ) ) {",1942
1615,"if ( sk_filter ( sk , skb ) )   goto discard_and_relse ;skb -> dev = NULL ;","th = ( const struct tcphdr * ) skb -> data ;iph = ip_hdr ( skb ) ;if ( sk_filter ( sk , skb ) ) goto discard_and_relse ;skb -> dev = NULL ;",1942
1616,while ( lp -> s != NULL ) {if ( lp -> pictype == l2info -> pictype ) {case LS_COOKIE_ID : l2info -> cookie_type = LS_COOKIE_ID ;,"ND_TCHECK ( p [ 0 ] ) ;while ( lp -> s != NULL ) {if ( lp -> pictype == l2info -> pictype ) {case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;l2info -> cookie_type = LS_COOKIE_ID ;",1943
1617,case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ;,"case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;l2info -> bundle = l2info -> cookie [ 1 ] ;",1943
1618,case LS_COOKIE_ID :  l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,1943
1619,case LS_COOKIE_ID :  l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,1943
1620,return ep ;},return global_ep ;},1944
1621,"if ( u4_temp & MASK_ERR_PIC_SET_ID )  return ERROR_INV_SPS_PPS_T ;COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ;return ERROR_INV_SPS_PPS_T ;}if ( ! ps_seq )  return ERROR_INV_SPS_PPS_T ;if ( FALSE == ps_seq -> u1_is_valid )  return ERROR_INV_SPS_PPS_T ;u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ;","if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ;COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ;return ERROR_INV_SLICE_HDR_T ;}if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ;if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ;u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ;",1945
1622,"if ( u4_idr_pic_id > 65535 )  return ERROR_INV_SPS_PPS_T ;COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ;","if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SLICE_HDR_T ;COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ;",1945
1623,if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb )  return ERROR_INV_SPS_PPS_T ;s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ;,if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T ;s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ;,1945
1624,if ( u4_temp > MAX_REDUNDANT_PIC_CNT )  return ERROR_INV_SPS_PPS_T ;u1_redundant_pic_cnt = u4_temp ;,if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T ;u1_redundant_pic_cnt = u4_temp ;,1945
1625,if ( ptr_hbe_txposer -> k_start < 0 ) return - 1 ;,if ( ptr_hbe_txposer -> ptr_hbe_txposer -> k_start < 0 ) return - 1 ;,1946
1626,"if ( ixheaacd_real_synth_fft != NULL )   ( * ixheaacd_real_synth_fft ) ( synth_buf_r , synth_out , synth_size * 2 ) ;else return - 1 ;","if ( ixheaacd_real_synth_fft != NULL ) ( * ( ptr_hbe_txposer -> ixheaacd_real_synth_fft ) ) ( synth_buf_r , synth_out , synth_size * 2 ) ;else return - 1 ;",1946
1627,"if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 )  return 0 ;","if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 || apic -> lapic_timer . period == 0 ) return 0 ;",1947
1628,"struct tmComResBusInfo * bus = & dev -> bus ;u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ;struct tmComResInfo msg_tmp ;int ret = SAA_ERR_BAD_PARAMETER ;saa7164_bus_verify ( dev ) ;if ( msg == NULL ) return ret ;if ( msg -> size > dev -> bus . m_wMaxReqSize ) {printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\\return ret ;}if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) {printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\\return ret ;}mutex_lock ( & bus -> lock ) ;curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ;curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ;if ( curr_gwp == curr_grp ) {ret = SAA_ERR_EMPTY ;goto out ;}bytes_to_read = sizeof ( * msg ) ;write_distance = 0 ;if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ;else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ;if ( bytes_to_read > write_distance ) {printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\\ret = SAA_ERR_INVALID_COMMAND ;goto out ;}new_grp = curr_grp + bytes_to_read ;if ( new_grp > bus -> m_dwSizeGetRing ) {new_grp -= bus -> m_dwSizeGetRing ;space_rem = bus -> m_dwSizeGetRing - curr_grp ;memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ;}else {memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ;}msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ;msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ;msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ;if ( peekonly ) {memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ;goto peekout ;",goto peekout ;,1948
1629,"memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing ,  sizeof ( * msg ) - space_rem ) ;if ( buf )  memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) -  space_rem , buf_size ) ;}memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;","memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing , sizeof ( * msg ) - space_rem ) ;if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ;}memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;",1948
1630,"memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ;msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ;msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ;msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ;","memcpy_fromio ( msg , bus -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ;}else if ( space_rem == sizeof ( * msg ) ) {if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ;memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ;",1948
1631,"stream -> bufbase_ = JAS_CAST ( uchar * , buf ) ;stream -> bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK ;","stream -> bufbase_ = JAS_CAST ( jas_uchar * , buf ) ;stream -> bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK ;",1949
1632,"pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * PIPE_DEF_BUFFERS , GFP_KERNEL ) ;if ( pipe -> bufs ) {pipe -> buffers = PIPE_DEF_BUFFERS ;mutex_init ( & pipe -> mutex ) ;kfree ( pipe ) ;}","unsigned long pipe_bufs = PIPE_DEF_BUFFERS ;struct user_struct * user = get_current_user ( ) ;if ( ! too_many_pipe_buffers_hard ( user ) ) {if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ;pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * pipe_bufs , GFP_KERNEL ) ;}if ( pipe -> bufs ) {pipe -> buffers = pipe_bufs ;pipe -> user = user ;account_pipe_buffers ( pipe , 0 , pipe_bufs ) ;mutex_init ( & pipe -> mutex ) ;free_uid ( user ) ;kfree ( pipe ) ;}",1950
1633,"memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ;memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ;if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ;","strlcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ;strlcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ;if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ;",1951
1634,"
",if ( ! cd -> disk ) continue ;,1952
1635,blk_cleanup_queue ( cd -> disk -> queue ) ;cd -> disk -> queue = NULL ;,blk_cleanup_queue ( cd -> disk -> queue ) ;cd -> disk -> queue = NULL ;,1952
1636,if ( include_level > 10 ) {,if ( ( len > 12 ) && include_level > 10 ) {,1953
1637,"if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) {do_ssi_include ( conn , path , buf + 12 , include_level + 1 ) ;# if ! defined ( NO_POPEN )  }else if ( ! memcmp ( buf + 5 , ""exec"" , 4 ) ) {do_ssi_exec ( conn , buf + 9 ) ;","if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) {do_ssi_include ( conn , path , buf + 12 , include_level + 1 ) ;# if ! defined ( NO_POPEN ) }else if ( ( len > 9 ) && ! memcmp ( buf + 5 , ""exec"" , 4 ) ) {do_ssi_exec ( conn , buf + 9 ) ;",1953
1638,if (  # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) {,p -> replacement_session_keyring = NULL ;if ( # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) {,1954
1639,"if ( obj -> size > 0x100000 ) {LOG_ERROR ( ""Object<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>overflow"" , obj -> size ) ;return DWG_ERR_VALUEOUTOFBOUNDS ;}while ( dat -> byte + obj -> size >= dat -> size ) bit_chain_alloc ( dat ) ;bit_write_MS ( dat , obj -> size ) ;obj -> address = dat -> byte ;PRE ( R_2010 ) {bit_write_BS ( dat , obj -> type ) ;LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS],<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[BS]\\\LATER_VERSIONS {if ( ! obj -> handlestream_size && obj -> bitsize ) obj -> handlestream_size = obj -> size * 8 - obj -> bitsize ;bit_write_UMC ( dat , obj -> handlestream_size ) ;obj -> address = dat -> byte ;bit_write_BOT ( dat , obj -> type ) ;LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS],<S2SV_blank>Hdlsize:<S2SV_blank>%lu<S2SV_blank>[UMC],<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[BOT]\\\switch ( obj -> type ) {case DWG_TYPE_TEXT : error = dwg_encode_TEXT ( dat , obj ) ;break ;case DWG_TYPE_ATTRIB : error = dwg_encode_ATTRIB ( dat , obj ) ;break ;case DWG_TYPE_ATTDEF : error = dwg_encode_ATTDEF ( dat , obj ) ;break ;case DWG_TYPE_BLOCK : error = dwg_encode_BLOCK ( dat , obj ) ;break ;case DWG_TYPE_ENDBLK : error = dwg_encode_ENDBLK ( dat , obj ) ;break ;case DWG_TYPE_SEQEND : error = dwg_encode_SEQEND ( dat , obj ) ;break ;case DWG_TYPE_INSERT : error = dwg_encode_INSERT ( dat , obj ) ;break ;case DWG_TYPE_MINSERT : error = dwg_encode_MINSERT ( dat , obj ) ;break ;case DWG_TYPE_VERTEX_2D : error = dwg_encode_VERTEX_2D ( dat , obj ) ;break ;case DWG_TYPE_VERTEX_3D : error = dwg_encode_VERTEX_3D ( dat , obj ) ;break ;case DWG_TYPE_VERTEX_MESH : error = dwg_encode_VERTEX_MESH ( dat , obj ) ;break ;case DWG_TYPE_VERTEX_PFACE : error = dwg_encode_VERTEX_PFACE ( dat , obj ) ;break ;case DWG_TYPE_VERTEX_PFACE_FACE : error = dwg_encode_VERTEX_PFACE_FACE ( dat , obj ) ;break ;case DWG_TYPE_POLYLINE_2D : error = dwg_encode_POLYLINE_2D ( dat , obj ) ;break ;case DWG_TYPE_POLYLINE_3D : error = dwg_encode_POLYLINE_3D ( dat , obj ) ;break ;case DWG_TYPE_ARC : error = dwg_encode_ARC ( dat , obj ) ;break ;case DWG_TYPE_CIRCLE : error = dwg_encode_CIRCLE ( dat , obj ) ;break ;case DWG_TYPE_LINE : error = dwg_encode_LINE ( dat , obj ) ;break ;case DWG_TYPE_DIMENSION_ORDINATE : error = dwg_encode_DIMENSION_ORDINATE ( dat , obj ) ;break ;case DWG_TYPE_DIMENSION_LINEAR : error = dwg_encode_DIMENSION_LINEAR ( dat , obj ) ;break ;case DWG_TYPE_DIMENSION_ALIGNED : error = dwg_encode_DIMENSION_ALIGNED ( dat , obj ) ;break ;case DWG_TYPE_DIMENSION_ANG3PT : error = dwg_encode_DIMENSION_ANG3PT ( dat , obj ) ;break ;case DWG_TYPE_DIMENSION_ANG2LN : error = dwg_encode_DIMENSION_ANG2LN ( dat , obj ) ;break ;case DWG_TYPE_DIMENSION_RADIUS : error = dwg_encode_DIMENSION_RADIUS ( dat , obj ) ;break ;case DWG_TYPE_DIMENSION_DIAMETER : error = dwg_encode_DIMENSION_DIAMETER ( dat , obj ) ;break ;case DWG_TYPE_POINT : error = dwg_encode_POINT ( dat , obj ) ;break ;case DWG_TYPE__3DFACE : error = dwg_encode__3DFACE ( dat , obj ) ;break ;case DWG_TYPE_POLYLINE_PFACE : error = dwg_encode_POLYLINE_PFACE ( dat , obj ) ;break ;case DWG_TYPE_POLYLINE_MESH : error = dwg_encode_POLYLINE_MESH ( dat , obj ) ;break ;case DWG_TYPE_SOLID : error = dwg_encode_SOLID ( dat , obj ) ;break ;case DWG_TYPE_TRACE : error = dwg_encode_TRACE ( dat , obj ) ;break ;case DWG_TYPE_SHAPE : error = dwg_encode_SHAPE ( dat , obj ) ;break ;case DWG_TYPE_VIEWPORT : error = dwg_encode_VIEWPORT ( dat , obj ) ;break ;case DWG_TYPE_ELLIPSE : error = dwg_encode_ELLIPSE ( dat , obj ) ;break ;case DWG_TYPE_SPLINE : error = dwg_encode_SPLINE ( dat , obj ) ;break ;case DWG_TYPE_REGION : error = dwg_encode_REGION ( dat , obj ) ;break ;case DWG_TYPE__3DSOLID : error = dwg_encode__3DSOLID ( dat , obj ) ;break ;case DWG_TYPE_BODY : error = dwg_encode_BODY ( dat , obj ) ;break ;case DWG_TYPE_RAY : error = dwg_encode_RAY ( dat , obj ) ;break ;case DWG_TYPE_XLINE : error = dwg_encode_XLINE ( dat , obj ) ;break ;case DWG_TYPE_DICTIONARY : error = dwg_encode_DICTIONARY ( dat , obj ) ;break ;case DWG_TYPE_MTEXT : error = dwg_encode_MTEXT ( dat , obj ) ;break ;case DWG_TYPE_LEADER : error = dwg_encode_LEADER ( dat , obj ) ;break ;case DWG_TYPE_TOLERANCE : error = dwg_encode_TOLERANCE ( dat , obj ) ;break ;case DWG_TYPE_MLINE : error = dwg_encode_MLINE ( dat , obj ) ;break ;case DWG_TYPE_BLOCK_CONTROL : error = dwg_encode_BLOCK_CONTROL ( dat , obj ) ;break ;case DWG_TYPE_BLOCK_HEADER : error = dwg_encode_BLOCK_HEADER ( dat , obj ) ;break ;case DWG_TYPE_LAYER_CONTROL : error = dwg_encode_LAYER_CONTROL ( dat , obj ) ;break ;case DWG_TYPE_LAYER : error = dwg_encode_LAYER ( dat , obj ) ;break ;case DWG_TYPE_STYLE_CONTROL : error = dwg_encode_STYLE_CONTROL ( dat , obj ) ;break ;case DWG_TYPE_STYLE : error = dwg_encode_STYLE ( dat , obj ) ;break ;case DWG_TYPE_LTYPE_CONTROL : error = dwg_encode_LTYPE_CONTROL ( dat , obj ) ;break ;case DWG_TYPE_LTYPE : error = dwg_encode_LTYPE ( dat , obj ) ;break ;case DWG_TYPE_VIEW_CONTROL : error = dwg_encode_VIEW_CONTROL ( dat , obj ) ;break ;case DWG_TYPE_VIEW : error = dwg_encode_VIEW ( dat , obj ) ;break ;case DWG_TYPE_UCS_CONTROL : error = dwg_encode_UCS_CONTROL ( dat , obj ) ;break ;case DWG_TYPE_UCS : error = dwg_encode_UCS ( dat , obj ) ;break ;case DWG_TYPE_VPORT_CONTROL : error = dwg_encode_VPORT_CONTROL ( dat , obj ) ;break ;case DWG_TYPE_VPORT : error = dwg_encode_VPORT ( dat , obj ) ;break ;case DWG_TYPE_APPID_CONTROL : error = dwg_encode_APPID_CONTROL ( dat , obj ) ;break ;case DWG_TYPE_APPID : error = dwg_encode_APPID ( dat , obj ) ;break ;case DWG_TYPE_DIMSTYLE_CONTROL : error = dwg_encode_DIMSTYLE_CONTROL ( dat , obj ) ;break ;case DWG_TYPE_DIMSTYLE : error = dwg_encode_DIMSTYLE ( dat , obj ) ;break ;case DWG_TYPE_VPORT_ENTITY_CONTROL : error = dwg_encode_VPORT_ENTITY_CONTROL ( dat , obj ) ;break ;case DWG_TYPE_VPORT_ENTITY_HEADER : error = dwg_encode_VPORT_ENTITY_HEADER ( dat , obj ) ;break ;case DWG_TYPE_GROUP : error = dwg_encode_GROUP ( dat , obj ) ;break ;case DWG_TYPE_MLINESTYLE : error = dwg_encode_MLINESTYLE ( dat , obj ) ;( void ) dwg_encode_get_class ( obj -> parent , obj ) ;break ;case DWG_TYPE_OLE2FRAME : error = dwg_encode_OLE2FRAME ( dat , obj ) ;( void ) dwg_encode_get_class ( obj -> parent , obj ) ;break ;case DWG_TYPE_DUMMY : error = dwg_encode_DUMMY ( dat , obj ) ;break ;case DWG_TYPE_LONG_TRANSACTION : error = dwg_encode_LONG_TRANSACTION ( dat , obj ) ;break ;case DWG_TYPE_LWPOLYLINE : error = dwg_encode_LWPOLYLINE ( dat , obj ) ;( void ) dwg_encode_get_class ( obj -> parent , obj ) ;break ;case DWG_TYPE_HATCH : error = dwg_encode_HATCH ( dat , obj ) ;( void ) dwg_encode_get_class ( obj -> parent , obj ) ;break ;case DWG_TYPE_XRECORD : error = dwg_encode_XRECORD ( dat , obj ) ;( void ) dwg_encode_get_class ( obj -> parent , obj ) ;break ;case DWG_TYPE_PLACEHOLDER : error = dwg_encode_PLACEHOLDER ( dat , obj ) ;( void ) dwg_encode_get_class ( obj -> parent , obj ) ;break ;case DWG_TYPE_OLEFRAME : error = dwg_encode_OLEFRAME ( dat , obj ) ;( void ) dwg_encode_get_class ( obj -> parent , obj ) ;break ;case DWG_TYPE_VBA_PROJECT : LOG_ERROR ( ""Unhandled<S2SV_blank>Object<S2SV_blank>VBA_PROJECT.<S2SV_blank>Has<S2SV_blank>its<S2SV_blank>own<S2SV_blank>section"" ) ;break ;case DWG_TYPE_LAYOUT : error |= dwg_encode_LAYOUT ( dat , obj ) ;( void ) dwg_encode_get_class ( obj -> parent , obj ) ;break ;case DWG_TYPE_PROXY_ENTITY : error = dwg_encode_PROXY_ENTITY ( dat , obj ) ;break ;case DWG_TYPE_PROXY_OBJECT : error = dwg_encode_PROXY_OBJECT ( dat , obj ) ;break ;default : if ( obj -> type == obj -> parent -> layout_type && obj -> fixedtype == DWG_TYPE_LAYOUT ) {error = dwg_encode_LAYOUT ( dat , obj ) ;( void ) dwg_encode_get_class ( obj -> parent , obj ) ;}else if ( ( error = dwg_encode_variable_type ( obj -> parent , dat , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) {Dwg_Data * dwg = obj -> parent ;int is_entity ;int i = obj -> type - 500 ;Dwg_Class * klass = dwg_encode_get_class ( dwg , obj ) ;assert ( address ) ;dat -> byte = address ;dat -> bit = 0 ;bit_write_MS ( dat , obj -> size ) ;if ( dat -> version >= R_2010 ) {bit_write_UMC ( dat , obj -> handlestream_size ) ;bit_write_BOT ( dat , obj -> type ) ;}else bit_write_BS ( dat , obj -> type ) ;if ( klass && obj -> supertype == DWG_SUPERTYPE_UNKNOWN ) is_entity = dwg_class_is_entity ( klass ) ;else is_entity = obj -> supertype == DWG_SUPERTYPE_ENTITY ;if ( klass && ! is_entity )   error = dwg_encode_UNKNOWN_OBJ ( dat , obj ) ;else if ( klass )  error = dwg_encode_UNKNOWN_ENT ( dat , obj ) ;","if ( is_entity ) error = dwg_encode_UNKNOWN_ENT ( dat , obj ) ;else error = dwg_encode_UNKNOWN_OBJ ( dat , obj ) ;else if ( klass ) error = dwg_encode_UNKNOWN_ENT ( dat , obj ) ;",1955
1640,"r_buf_set_bytes ( tbuf , buf , sz ) ;struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ;","if ( ! tbuf ) {return NULL ;}r_buf_set_bytes ( tbuf , buf , sz ) ;struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ;",1956
1641,"guint32 off = offset ;guint32 len ;DebugLog ( ( ""parse_wbxml_attr<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\\while ( off < tvb_len ) {","guint32 off = offset , last_off ;guint32 len ;DebugLog ( ( ""parse_wbxml_attr<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\\last_off = off ;while ( off < tvb_len ) {",1957
1642,"}DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\\","if ( off < last_off ) {THROW ( ReportedBoundsError ) ;}last_off = off ;}DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\\",1957
1643,"u_char showspi , showdata , showsomedata ;const char * notify_name ;showdata = 0 ;showsomedata = 0 ;","u_char showspi , showsomedata ;const char * notify_name ;showsomedata = 0 ;",1958
1644,showsomedata = 1 ;showdata = 0 ;,showsomedata = 1 ;,1958
1645,"if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ;cp = ( const u_char * ) ( p + 1 ) + n . spi_size ;if ( 3 < ndo -> ndo_vflag ) {showdata = 1 ;}if ( ( showdata || ( showsomedata && ep - cp < 30 ) ) && cp < ep ) {ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ;}else if ( showsomedata && cp < ep ) {if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ;}","if ( cp < ep ) {if ( ndo -> ndo_vflag ) {showdata = 1 ;if ( ( showdata || ( showsomedata && ep - cp < 30 ) ) && cp < ep ) {ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ;}else if ( showsomedata ) {if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ;}}",1958
1646,if ( gf -> file && gf -> file -> device )   free ( gf -> file -> device -> disk ) ;free ( gf -> file ) ;,if ( gf -> file && gf -> file -> device ) {free ( gf -> file -> device -> disk ) ;}free ( gf -> file ) ;,1959
1647,# ifndef OPENSSL_NO_COMP  compression = SSL_get_current_compression ( c -> ssl ) ;,# if OPENSSL_VERSION_NUMBER >= 0x10101000L print_tmp_key ( c -> ssl ) ;# endif # ifndef OPENSSL_NO_COMP compression = SSL_get_current_compression ( c -> ssl ) ;,1960
1648,"unregister_savevm ( DEVICE ( s ) , ""stellaris_enet"" , s ) ;memory_region_destroy ( & s -> mmio ) ;",memory_region_destroy ( & s -> mmio ) ;,1961
1649,if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen )  return - EINVAL ;,if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen || replay_esn -> bmp_len != up -> bmp_len ) return - EINVAL ;,1962
1650,"if ( packet -> size + length > MT_PACKET_LEN ) {fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\\","if ( length > MT_PACKET_LEN - packet -> size ) {fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\\",1963
1651,const VP9_CONFIG * const oxcf = & cpi -> oxcf ;LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ;lc -> rc = cpi -> rc ;lc -> twopass = cpi -> twopass ;lc -> target_bandwidth = ( int ) oxcf -> target_bandwidth ;lc -> starting_buffer_level = oxcf -> starting_buffer_level ;lc -> optimal_buffer_level = oxcf -> optimal_buffer_level ;lc -> maximum_buffer_size = oxcf -> maximum_buffer_size ;lc -> framerate = cpi -> output_framerate ;},const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;LAYER_CONTEXT * const lc = get_layer_context ( cpi ) ;lc -> rc = cpi -> rc ;lc -> alt_ref_source = cpi -> alt_ref_source ;},1964
1652,struct br_mdb_entry entry ;entry . ifindex = port -> dev -> ifindex ;,"struct br_mdb_entry entry ;memset ( & entry , 0 , sizeof ( entry ) ) ;entry . ifindex = port -> dev -> ifindex ;",1965
1653,case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE :  case RAPTOR_OPTION_RELATIVE_URIS :  case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ;,case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case RAPTOR_OPTION_RELATIVE_URIS : case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ;,1966
1654,case L2CAP_MODE_ERTM :  if ( enable_ertm )  break ;,case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING : if ( enable_ertm ) break ;,1967
1655,"if ( vp9_segfeature_active ( & cpi -> common . seg , 1 , SEG_LVL_REF_FRAME ) ) {return 0 ;","if ( segfeature_active ( & cpi -> common . seg , 1 , SEG_LVL_REF_FRAME ) ) {return 0 ;",1968
1656,"slapi_pblock_get ( pb , SLAPI_BACKEND , & be ) ;slapi_pblock_get ( pb , SLAPI_PLUGIN_PRIVATE , & li ) ;slapi_pblock_get ( pb , SLAPI_TARGET_ADDRESS , & addr ) ;slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & method ) ;slapi_pblock_get ( pb , SLAPI_BIND_CREDENTIALS , & cred ) ;slapi_pblock_get ( pb , SLAPI_TXN , & txn . back_txn_txn ) ;if ( ! txn . back_txn_txn ) {dblayer_txn_init ( li , & txn ) ;slapi_pblock_set ( pb , SLAPI_TXN , txn . back_txn_txn ) ;}inst = ( ldbm_instance * ) be -> be_instance_info ;if ( inst -> inst_ref_count ) {slapi_counter_increment ( inst -> inst_ref_count ) ;}else {slapi_log_err ( SLAPI_LOG_ERR , ""ldbm_back_bind"" , ""instance<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist.\\\return ( SLAPI_BIND_FAIL ) ;}if ( method == LDAP_AUTH_SIMPLE && cred -> bv_len == 0 ) {rc = SLAPI_BIND_ANONYMOUS ;goto bail ;}if ( ( e = find_entry ( pb , be , addr , & txn , & result_sent ) ) == NULL ) {rc = SLAPI_BIND_FAIL ;if ( ! result_sent ) {slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , NULL , 0 , NULL ) ;","slapi_pblock_get ( pb , LDAP_INVALID_CREDENTIALS , NULL , NULL , 0 , NULL ) ;",1969
1657,"slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL ,  NULL , 0 , NULL ) ;","slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , NULL , 0 , NULL ) ;",1969
1658,ps_dec -> u4_first_slice_in_pic = 2 ;ps_dec -> u1_first_pb_nal_in_pic = 1 ;,ps_dec -> u4_first_slice_in_pic = 1 ;ps_dec -> u1_first_pb_nal_in_pic = 1 ;,1970
1659,"return ""DPC""  # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL )  ""<S2SV_blank>Modules"" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT )  ""<S2SV_blank>HDRI""  # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) ""<S2SV_blank>OpenCL"" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) ""<S2SV_blank>OpenMP"" # endif  ;}","return ""DPC"" # if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) ""<S2SV_blank>Debug"" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) ""<S2SV_blank>Cipher"" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) ""<S2SV_blank>HDRI"" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) ""<S2SV_blank>Modules"" # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) ""<S2SV_blank>OpenCL"" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) ""<S2SV_blank>OpenMP"" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) ""<S2SV_blank>Zero-configuration"" # endif ;}",1971
1660,case VNC_MSG_CLIENT_SET_PIXEL_FORMAT : if ( len == 1 ) return 20 ;,case VNC_MSG_CLIENT_SET_PIXEL_FORMAT : if ( len == 1 ) {return 20 ;,1972
1661,"case VNC_MSG_CLIENT_CUT_TEXT :  if ( len == 1 )   return 8 ;if ( len == 8 ) {uint32_t dlen = read_u32 ( data , 4 ) ;if ( dlen > 0 )   return 8 + dlen ;}","}case VNC_MSG_CLIENT_CUT_TEXT : if ( len == 1 ) return 8 ;if ( len == 8 ) {uint32_t dlen = read_u32 ( data , 4 ) ;if ( dlen > ( 1 << 20 ) ) {error_report ( ""vnc:<S2SV_blank>client_cut_text<S2SV_blank>msg<S2SV_blank>payload<S2SV_blank>has<S2SV_blank>%u<S2SV_blank>bytes"" ""<S2SV_blank>which<S2SV_blank>exceeds<S2SV_blank>our<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB."" , dlen ) ;vnc_client_error ( vs ) ;break ;}if ( dlen > 0 ) {return 8 + dlen ;}}",1972
1662,"case TUNNEL_PASS : if ( length < 3 )  {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return ;}",case TUNNEL_PASS : if ( length < 3 ) goto trunc ;,1973
1663,"if ( length < 1 )  {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return ;}case EGRESS_VLAN_NAME :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , tok2str ( rfc4675_tagged , ""Unknown<S2SV_blank>tag"" , * data ) , * data ) ) ;for ( i = 0 ;* data && i < length ;i ++ , data ++ )  ND_PRINT ( ( ndo , ""%c"" , ( * data < 32 || * data > 126 ) ? \'.\' : * data ) ) ;","if ( length < 1 ) goto trunc ;case EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ;ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , tok2str ( rfc4675_tagged , ""Unknown<S2SV_blank>tag"" , * data ) , * data ) ) ;for ( i = 0 ;i < length && * data ;i ++ , data ++ ) ND_PRINT ( ( ndo , ""%c"" , ( * data < 32 || * data > 126 ) ? \'.\' : * data ) ) ;",1973
1664,if ( ( s -> options & SSL_OP_EPHEMERAL_RSA )  # ifndef OPENSSL_NO_KRB5 && ! ( alg_k & SSL_kKRB5 ) # endif )  s -> s3 -> tmp . use_rsa_tmp = 1 ;else s -> s3 -> tmp . use_rsa_tmp = 0 ;,s -> s3 -> tmp . use_rsa_tmp = 1 ;else s -> s3 -> tmp . use_rsa_tmp = 0 ;,1974
1665,int tlen ;uint8_t nitems ;ND_TCHECK ( * vqp_common_header ) ;if ( VQP_EXTRACT_VERSION ( vqp_common_header -> version ) != VQP_VERSION ) {,u_int tlen ;uint8_t nitems ;ND_TCHECK ( * vqp_common_header ) ;if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc ;if ( VQP_EXTRACT_VERSION ( vqp_common_header -> version ) != VQP_VERSION ) {,1975
1666,vqp_obj_type = EXTRACT_32BITS ( vqp_obj_tlv -> obj_type ) ;vqp_obj_len = EXTRACT_16BITS ( vqp_obj_tlv -> obj_length ) ;,ND_TCHECK ( * vqp_obj_tlv ) ;if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ;vqp_obj_type = EXTRACT_32BITS ( vqp_obj_tlv -> obj_type ) ;vqp_obj_len = EXTRACT_16BITS ( vqp_obj_tlv -> obj_length ) ;,1975
1667,"switch ( vqp_obj_type ) {case VQP_OBJ_IP_ADDRESS :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr ) ) ) ;break ;case VQP_OBJ_MAC_ADDRESS :  case VQP_OBJ_MAC_NULL :  ND_PRINT ( ( ndo , ""%s"" , etheraddr_string ( ndo , tptr ) ) ) ;","if ( vqp_obj_len > tlen ) goto trunc ;switch ( vqp_obj_type ) {case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ;ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr ) ) ) ;break ;case VQP_OBJ_MAC_ADDRESS : case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""%s"" , etheraddr_string ( ndo , tptr ) ) ) ;",1975
1668,"TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg ,  TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {TPM2B_DIGEST tmpResult ;TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;TPM_RC rval ;int i , j ;","TPM_RC tpm_kdfa ( TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;TPM_RC rval = TPM_RC_SUCCESS ;int i , j ;",1976
1669,"while ( resultKey -> t . size < bytes )  {i_Swizzled = string_bytes_endian_convert_32 ( i ) ;* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;if ( rval != TPM_RC_SUCCESS )  {return ( rval ) ;return TSS2_SYS_RC_BAD_VALUE ;}return TPM_RC_SUCCESS ;","const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ;if ( ! md ) {LOG_ERR ( ""Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x"" , hashAlg ) ;return TPM_RC_HASH ;}HMAC_CTX ctx ;HMAC_CTX_init ( & ctx ) ;int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;return TPM_RC_MEMORY ;}while ( resultKey -> t . size < bytes ) {TPM2B_DIGEST tmpResult ;i_Swizzled = string_bytes_endian_convert_32 ( i ) ;* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ;int c ;for ( c = 0 ;c < j ;c ++ ) {TPM2B_DIGEST * digest = bufferList [ c ] ;int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;rval = TPM_RC_MEMORY ;goto err ;tmpResult . t . size = size ;rval = TSS2_SYS_RC_BAD_VALUE ;goto err ;}err : HMAC_CTX_cleanup ( & ctx ) ;return rval ;",1976
1670,"ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & ke , ext , sizeof ( ke ) ) ;","ND_TCHECK ( * k ) ;UNALIGNED_MEMCPY ( & ke , ext , sizeof ( ke ) ) ;",1977
1671,fid -> udf . generation = inode -> i_generation ;if ( parent ) {,fid -> udf . parent_partref = 0 ;fid -> udf . generation = inode -> i_generation ;if ( parent ) {,1978
1672,"BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;addr -> sa_family = AF_BLUETOOTH ;","BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;memset ( la , 0 , sizeof ( struct sockaddr_l2 ) ) ;addr -> sa_family = AF_BLUETOOTH ;",1979
1673,"client -> auth_user = client -> db -> auth_user ;client -> pool = get_pool ( client -> db , client -> db -> auth_user ) ;","client -> pool = get_pool ( client -> db , client -> db -> auth_user ) ;",1980
1674,if ( ( 1 != ps_dec_state -> u2_decode_header ) && ( ( bytes_remaining > 0 ) || ps_dec_state -> u1_flushfrm ) )  {,if ( ( 1 != ps_dec_state -> u2_decode_header ) && ( ( ( bytes_remaining > 0 ) && ( 1 == ps_dec_state -> u2_header_done ) ) || ps_dec_state -> u1_flushfrm ) ) {,1981
1675,"if ( ! IS_ERR ( state ) )  nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ;out_free : nfs4_opendata_put ( data ) ;","if ( ! IS_ERR ( state ) ) nfs4_close_state ( & data -> path , state , data -> o_arg . fmode ) ;out_free : nfs4_opendata_put ( data ) ;",1982
1676,"static void duplicate_mode_info_in_sb ( VP9_COMMON * const cm ,   MACROBLOCKD * const xd ,  int mi_row , int mi_col , BLOCK_SIZE bsize ) {","static void duplicate_mode_info_in_sb ( VP9_COMMON * cm , MACROBLOCKD * const xd , int mi_row , int mi_col , BLOCK_SIZE bsize ) {",1983
1677,msg -> msg_namelen = 0 ;do {,do {,1984
1678,if ( ctx -> might_cancel ) {ctx -> might_cancel = false ;spin_lock ( & cancel_lock ) ;list_del_rcu ( & ctx -> clist ) ;spin_unlock ( & cancel_lock ) ;}},spin_lock ( & ctx -> cancel_lock ) ;list_del_rcu ( & ctx -> clist ) ;spin_unlock ( & cancel_lock ) ;}},1985
1679,"int xt_check_entry_offsets ( const void * base ,  unsigned int target_offset , unsigned int next_offset ) {const struct xt_entry_target * t ;const char * e = base ;if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ;","int xt_check_entry_offsets ( const void * base , const char * elems , unsigned int target_offset , unsigned int next_offset ) {long size_of_base_struct = elems - ( const char * ) base ;const struct xt_entry_target * t ;const char * e = base ;if ( target_offset < size_of_base_struct ) return - EINVAL ;if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ;",1986
1680,"int rc = 0 ;memset ( & sllc , 0 , sizeof ( sllc ) ) ;* uaddrlen = sizeof ( sllc ) ;memset ( uaddr , 0 , * uaddrlen ) ;","int rc = - EBADF ;memset ( & sllc , 0 , sizeof ( sllc ) ) ;* uaddrlen = sizeof ( sllc ) ;",1987
1681,"# ifdef HAVE_SECCOMP  if ( arg_seccomp_block_secondary )  copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ;","# ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;if ( arg_seccomp_block_secondary ) copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ;",1988
1682,int error ;address &= PAGE_MASK ;error = security_mmap_addr ( address ) ;if ( error ) return error ;,int error = 0 ;address &= PAGE_MASK ;if ( address < mmap_min_addr ) return - EPERM ;,1989
1683,"
",ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;,1990
1684,"ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ;break ;","ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ;break ;",1990
1685,"printf ( ""Using<S2SV_blank>%s\\\if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) )  die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ;","printf ( ""Using<S2SV_blank>%s\\\if ( vpx_codec_dec_init ( & codec , decoder -> codec_interface ( ) , NULL , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ;",1991
1686,"static u32 ip6_idents_hashrnd __read_mostly ;u32 id ;net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ;id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ;return htonl ( id ) ;","u32 id ;id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ;return htonl ( id ) ;",1992
1687,rxent -> serviceId = EXTRACT_32BITS ( & rxh -> serviceId ) ;rxent -> opcode = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ;,rxent -> serviceId = EXTRACT_16BITS ( & rxh -> serviceId ) ;rxent -> opcode = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ;,1993
1688,"void vp9_model_to_full_probs ( const vp9_prob * model , vp9_prob * full ) {if ( full != model )  vpx_memcpy ( full , model , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ;extend_to_full_distribution ( & full [ UNCONSTRAINED_NODES ] , model [ PIVOT_NODE ] ) ;","void vp9_model_to_full_probs ( const vpx_prob * model , vp9_prob * full ) {if ( full != model ) memcpy ( full , model , sizeof ( vpx_prob ) * UNCONSTRAINED_NODES ) ;extend_to_full_distribution ( & full [ UNCONSTRAINED_NODES ] , model [ PIVOT_NODE ] ) ;",1994
1689,struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ;struct net * net = sock_net ( cb -> skb -> sk ) ;,struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ;struct net * net = sock_net ( cb -> skb -> sk ) ;,1995
1690,"if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) {bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ;","if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ( ICANON | EXTPROC ) ) {bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ;",1996
1691,"static ssize_t  pipe_write ( struct kiocb * iocb , const struct iovec * _iov ,  unsigned long nr_segs , loff_t ppos ) {ssize_t ret ;int do_wakeup ;struct iovec * iov = ( struct iovec * ) _iov ;size_t total_len ;ssize_t chars ;total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) )  return 0 ;do_wakeup = 0 ;ret = 0 ;","static ssize_t pipe_write ( struct kiocb * iocb , struct iov_iter * from ) {ssize_t ret = 0 ;int do_wakeup = 0 ;size_t total_len = iov_iter_count ( from ) ;ssize_t chars ;total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) ) return 0 ;",1997
1692,"int error , atomic = 1 ;void * addr ;error = ops -> confirm ( pipe , buf ) ;iov_fault_in_pages_read ( iov , chars ) ;redo1 : if ( atomic ) addr = kmap_atomic ( buf -> page ) ;else addr = kmap ( buf -> page ) ;error = pipe_iov_copy_from_user ( offset + addr , iov , chars , atomic ) ;if ( atomic ) kunmap_atomic ( addr ) ;else kunmap ( buf -> page ) ;ret = error ;do_wakeup = 1 ;if ( error ) {if ( atomic ) {atomic = 0 ;goto redo1 ;}}buf -> len += chars ;total_len -= chars ;ret = chars ;","int error = ops -> confirm ( pipe , buf ) ;ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ;if ( unlikely ( ret < chars ) ) {error = - EFAULT ;}do_wakeup = 1 ;buf -> len += chars ;total_len -= chars ;ret = chars ;",1997
1693,"char * src ;int error , atomic = 1 ;",int copied ;,1997
1694,"chars = PAGE_SIZE ;if ( chars > total_len ) chars = total_len ;iov_fault_in_pages_read ( iov , chars ) ;redo2 : if ( atomic ) src = kmap_atomic ( page ) ;else src = kmap ( page ) ;error = pipe_iov_copy_from_user ( src , iov , chars , atomic ) ;if ( unlikely ( error ) ) {if ( atomic ) {ret += chars ;buf -> page = page ;buf -> len = chars ;buf -> flags = 0 ;total_len -= chars ;if ( ! total_len ) break ;","copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from ) ;if ( unlikely ( error ) ) {if ( atomic ) {ret += copied ;buf -> page = page ;buf -> len = copied ;buf -> flags = 0 ;if ( ! iov_iter_count ( from ) ) break ;",1997
1695,"u32 i , j , page_count = 0 , sg_per_table ;struct rd_dev_sg_table * sg_table ;struct page * pg ;struct scatterlist * sg ;sg_table = rd_dev -> sg_table_array ;for ( i = 0 ;sg = sg_table [ i ] . sg_table ;",u32 page_count ;sg_table = rd_dev -> sg_table_array ;for ( i = 0 ;sg = sg_table [ i ] . sg_table ;,1998
1696,kfree ( sg_table ) ;rd_dev -> sg_table_array = NULL ;rd_dev -> sg_table_count = 0 ;,"kfree ( sg_table ) ;rd_dev -> sg_table_array , rd_dev -> sg_table_count = 0 ;",1998
1697,"uint16 bitspersample , samplesperpixel = 1 ;uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ;","uint16 bitspersample = 1 , samplesperpixel = 1 ;uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ;",1999
1698,if ( pbi -> b_multithreaded_rd )  {if ( pbi -> mt_yabove_row )  {for ( i = 0 ;i ++ ) {if ( pbi -> mt_uabove_row )  {for ( i = 0 ;i ++ ) {if ( pbi -> mt_vabove_row )  {for ( i = 0 ;i ++ ) {if ( pbi -> mt_yleft_col )  {for ( i = 0 ;i ++ ) {if ( pbi -> mt_uleft_col )  {for ( i = 0 ;i ++ ) {if ( pbi -> mt_vleft_col )  {for ( i = 0 ;i ++ ) {,if ( pbi -> mt_yabove_row ) {for ( i = 0 ;++ i ) {if ( pbi -> mt_uabove_row ) {for ( i = 0 ;++ i ) {if ( pbi -> mt_vabove_row ) {for ( i = 0 ;++ i ) {if ( pbi -> mt_yleft_col ) {for ( i = 0 ;++ i ) {if ( pbi -> mt_uleft_col ) {for ( i = 0 ;++ i ) {if ( pbi -> mt_vleft_col ) {for ( i = 0 ;++ i ) {,2000
1699,},"
",2000
1700,"# ifdef __linux__   sun . sun_path [ 0 ] = '\\\\0' ;memcpy ( sun . sun_path + 1 , address , strlen ( address ) ) ;sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ;# else memcpy ( sun . sun_path , address , strlen ( address ) ) ;# endif client -> control = socket ( AF_UNIX , SOCK_STREAM , 0 ) ;","memcpy ( sun . sun_path [ 0 ] = '\\\\0' ;memcpy ( sun . sun_path , address , strlen ( address ) ) ;sun_len = sizeof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ;# else memcpy ( sun . sun_path , address , strlen ( address ) ) ;client -> control = socket ( AF_UNIX , SOCK_STREAM , 0 ) ;",2001
1701,"snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ;rcipher . blocksize = alg -> cra_blocksize ;","strncpy ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ;rcipher . blocksize = alg -> cra_blocksize ;",2002
1702,case DH6OPT_RECONF_MSG :  tp = ( const u_char * ) ( dh6o + 1 ) ;,"case DH6OPT_RECONF_MSG : if ( optlen != 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ;break ;}tp = ( const u_char * ) ( dh6o + 1 ) ;",2003
1703,"# endif # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ;# endif  openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ;","# endif umask ( 022 ) ;# ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ;# endif openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ;",2004
1704,"}if ( ! os_major ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>%s"" , uname_buf . release ) ;if ( ! config_id ) {end = strchrnul ( uname_buf . nodename , \'.\' ) ;config_id = MALLOC ( ( size_t ) ( end - uname_buf . nodename ) + 1 ) ;strncpy ( config_id , uname_buf . nodename , ( size_t ) ( end - uname_buf . nodename ) ) ;config_id [ end - uname_buf . nodename ] = \'\\\\0\' ;}}if ( parse_cmdline ( argc , argv ) ) {closelog ( ) ;if ( ! __test_bit ( NO_SYSLOG_BIT , & debug ) ) openlog ( PACKAGE_NAME , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ;}if ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) enable_console_log ( ) ;# ifdef GIT_COMMIT log_message ( LOG_INFO , ""Starting<S2SV_blank>%s,<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s"" , version_string , GIT_COMMIT ) ;# else log_message ( LOG_INFO , ""Starting<S2SV_blank>%s"" , version_string ) ;# endif core_dump_init ( ) ;if ( os_major ) {if ( KERNEL_VERSION ( os_major , os_minor , os_release ) < LINUX_VERSION_CODE ) {log_message ( LOG_INFO , ""WARNING<S2SV_blank>-<S2SV_blank>keepalived<S2SV_blank>was<S2SV_blank>build<S2SV_blank>for<S2SV_blank>newer<S2SV_blank>Linux<S2SV_blank>%d.%d.%d,<S2SV_blank>running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s"" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff , uname_buf . sysname , uname_buf . release , uname_buf . version ) ;}else {log_message ( LOG_INFO , ""Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>(built<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d)"" , uname_buf . sysname , uname_buf . release , uname_buf . version , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ;}}# ifndef _DEBUG_ log_command_line ( 0 ) ;# endif if ( ! check_conf_file ( conf_file ) ) {if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) config_test_exit ( ) ;goto end ;}global_data = alloc_global_data ( ) ;read_config_file ( ) ;init_global_data ( global_data , NULL ) ;# if HAVE_DECL_CLONE_NEWNET if ( override_namespace ) {if ( global_data -> network_namespace ) {log_message ( LOG_INFO , ""Overriding<S2SV_blank>config<S2SV_blank>net_namespace<S2SV_blank>\\\'%s\\\'<S2SV_blank>with<S2SV_blank>command<S2SV_blank>line<S2SV_blank>namespace<S2SV_blank>\\\'%s\\\'"" , global_data -> network_namespace , override_namespace ) ;FREE ( global_data -> network_namespace ) ;}global_data -> network_namespace = override_namespace ;override_namespace = NULL ;}# endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) && ( global_data -> instance_name # if HAVE_DECL_CLONE_NEWNET || global_data -> network_namespace # endif ) ) {if ( ( syslog_ident = make_syslog_ident ( PACKAGE_NAME ) ) ) {log_message ( LOG_INFO , ""Changing<S2SV_blank>syslog<S2SV_blank>ident<S2SV_blank>to<S2SV_blank>%s"" , syslog_ident ) ;closelog ( ) ;openlog ( syslog_ident , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ;}else log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>syslog<S2SV_blank>ident"" ) ;use_pid_dir = true ;open_log_file ( log_file_name , NULL , # if HAVE_DECL_CLONE_NEWNET global_data -> network_namespace , # else NULL , # endif global_data -> instance_name ) ;}set_child_finder_name ( find_keepalived_child_name ) ;if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) {if ( use_pid_dir ) {create_pid_dir ( ) ;}}# if HAVE_DECL_CLONE_NEWNET if ( global_data -> network_namespace ) {if ( global_data -> network_namespace && ! set_namespaces ( global_data -> network_namespace ) ) {log_message ( LOG_ERR , ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>exiting"" , global_data -> network_namespace ) ;goto end ;}}# endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) {if ( global_data -> instance_name ) {if ( ! main_pidfile && ( main_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_main_pidfile = true ;# ifdef _WITH_LVS_ if ( ! checkers_pidfile && ( checkers_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR CHECKERS_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_checkers_pidfile = true ;# endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile && ( vrrp_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_vrrp_pidfile = true ;# endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile && ( bfd_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_bfd_pidfile = true ;# endif }if ( use_pid_dir ) {if ( ! main_pidfile ) main_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ;# ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION ;# endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION ;# endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION ;# endif }else {if ( ! main_pidfile ) main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ;# ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION ;# endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION ;# endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION ;# endif }if ( keepalived_running ( daemon_mode ) ) {log_message ( LOG_INFO , ""daemon<S2SV_blank>is<S2SV_blank>already<S2SV_blank>running"" ) ;report_stopped = false ;goto end ;}}if ( ! __test_bit ( DONT_FORK_BIT , & debug ) && xdaemon ( false , false , true ) > 0 ) {closelog ( ) ;FREE_PTR ( config_id ) ;FREE_PTR ( orig_core_dump_pattern ) ;close_std_fd ( ) ;exit ( 0 ) ;}umask ( 0 ) ;# ifdef _MEM_CHECK_ enable_mem_log_termination ( ) ;",# ifdef _MEM_CHECK_ enable_mem_log_termination ( ) ;,2004
1705,if ( ! ( opt_len == 12 && flags & TH_SYN ) &&  ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ;,if ( ! ( opt_len == 12 && ( flags & TH_SYN ) ) && ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ;,2005
1706,"static void encode_unsigned_max ( struct vp9_write_bit_buffer * wb ,  int data , int max ) {vp9_wb_write_literal ( wb , data , get_unsigned_bits ( max ) ) ;}","static void encode_unsigned_max ( struct vpx_write_bit_buffer * wb , int data , int max ) {vpx_wb_write_literal ( wb , data , get_unsigned_bits ( max ) ) ;}",2006
1707,"hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset ,  src_fd . entrylength ) ;","if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) {err = - EIO ;goto out ;}hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , src_fd . entrylength ) ;",2007
1708,"if ( xmlPushInput ( ctxt , input ) < 0 )  return ;","if ( xmlPushInput ( ctxt , input ) < 0 ) {xmlFreeInputStream ( input ) ;return ;}",2008
1709,"
",it = it -> next ;,2009
1710,}if ( it != NULL ) {,}if ( it != NULL ) {,2009
1711,"stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;switch ( stlv_type ) {ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_MCID_MIN_LEN ) ;subtlv_spb_mcid = ( const struct isis_subtlv_spb_mcid * ) tptr ;tptr = tptr + sizeof ( struct isis_subtlv_spb_mcid ) ;len = len - sizeof ( struct isis_subtlv_spb_mcid ) ;ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) ;ND_PRINT ( ( ndo , ""\\\","ND_TCHECK2 ( * tptr , 2 ) ;stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;if ( len < stlv_len ) goto trunc ;ND_TCHECK2 ( * ( tptr ) , stlv_len ) ;switch ( stlv_type ) {if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc ;subtlv_spb_mcid = ( const struct isis_subtlv_spb_mcid * ) tptr ;tptr = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN ;len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ;stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ;if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""\\\",2010
1712,"break ;}ND_TCHECK2 ( * ( tptr ) , stlv_len ) ;while ( len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) {ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_BVID_MIN_LEN ) ;ND_PRINT ( ( ndo , ""\\\}break ;}return 0 ;","stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ;break ;}while ( stlv_len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) {ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_BVID_MIN_LEN ) ;ND_PRINT ( ( ndo , ""\\\stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ;break ;}tptr += stlv_len ;len -= stlv_len ;}return 0 ;",2010
1713,"int i , protocol ;host_iface = & usb_ifnum_to_if ( dev , ctrlif ) -> altsetting [ 0 ] ;","int i , protocol ;int rest_bytes ;host_iface = & usb_ifnum_to_if ( dev , ctrlif ) -> altsetting [ 0 ] ;",2011
1714,"switch ( protocol ) {default : dev_warn ( & dev -> dev , ""unknown<S2SV_blank>interface<S2SV_blank>protocol<S2SV_blank>%#02x,<S2SV_blank>assuming<S2SV_blank>v1\\\if ( ! h1 -> bInCollection ) {dev_info ( & dev -> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\\return - EINVAL ;","rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ;if ( rest_bytes < sizeof ( * h1 ) ) {dev_err ( & dev -> dev , ""too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\\return - EINVAL ;}if ( rest_bytes <= 0 ) {dev_err ( & dev -> dev , ""invalid<S2SV_blank>control<S2SV_blank>header\\\return - EINVAL ;}switch ( protocol ) {default : dev_warn ( & dev -> dev , ""unknown<S2SV_blank>interface<S2SV_blank>protocol<S2SV_blank>%#02x,<S2SV_blank>assuming<S2SV_blank>v1\\\if ( ! h1 -> bInCollection ) {dev_info ( & dev -> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\\return - EINVAL ;}if ( rest_bytes < h1 -> bLength ) {dev_err ( & dev -> dev , ""invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\\return - EINVAL ;",2011
1715,user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user )  return ERR_PTR ( - ENOMEM ) ;construct_get_dest_keyring ( & dest_keyring ) ;,ret = construct_get_dest_keyring ( & dest_keyring ) ;if ( ret ) goto error ;user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user ) {ret = - ENOMEM ;goto error_put_dest_keyring ;},2012
1716,"goto couldnt_alloc_key ;}couldnt_alloc_key :   key_put ( dest_keyring ) ;kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ;","goto error_put_dest_keyring ;}error_put_dest_keyring : key_put ( dest_keyring ) ;error : kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ;",2012
1717,"static void rd_auto_partition_range ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , int mi_col ,  BLOCK_SIZE * min_block_size , BLOCK_SIZE * max_block_size ) {MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;MODE_INFO * * mi_8x8 = xd -> mi ;const int left_in_image = xd -> left_available && mi_8x8 [ - 1 ] ;const int above_in_image = xd -> up_available &&  mi_8x8 [ - xd -> mi_stride ] ;MODE_INFO * * above_sb64_mi_8x8 ;MODE_INFO * * left_sb64_mi_8x8 ;int row8x8_remaining = tile -> mi_row_end - mi_row ;int col8x8_remaining = tile -> mi_col_end - mi_col ;int bh , bw ;BLOCK_SIZE max_size = BLOCK_64X64 ;if ( left_in_image || above_in_image || cm -> frame_type != KEY_FRAME ) {MODE_INFO * * const prev_mi =  & cm -> prev_mi_grid_visible [ mi_row * xd -> mi_stride + mi_col ] ;get_sb_partition_size_range ( cpi , prev_mi , & min_size , & max_size ) ;}left_sb64_mi_8x8 = & mi_8x8 [ - MI_BLOCK_SIZE ] ;get_sb_partition_size_range ( cpi , left_sb64_mi_8x8 ,  & min_size , & max_size ) ;above_sb64_mi_8x8 = & mi_8x8 [ - xd -> mi_stride * MI_BLOCK_SIZE ] ;get_sb_partition_size_range ( cpi , above_sb64_mi_8x8 ,  & min_size , & max_size ) ;","static void rd_auto_partition_range ( VP9_COMP * cpi , const TileInfo * const tile , MACROBLOCKD * const xd , int mi_row , int mi_col , BLOCK_SIZE * min_block_size , BLOCK_SIZE * max_block_size ) {MODE_INFO * * mi_8x8 = xd -> mi ;const int left_in_image = xd -> left_available && mi_8x8 [ - 1 ] ;const int above_in_image = xd -> up_available && mi [ - xd -> mi_stride ] ;const int row8x8_remaining = tile -> mi_row_end - mi_row ;const int col8x8_remaining = tile -> mi_col_end - mi_col ;int bh , bw ;BLOCK_SIZE max_size = BLOCK_64X64 ;int bs_hist [ BLOCK_SIZES ] = {0 };if ( left_in_image || above_in_image || cm -> frame_type != KEY_FRAME ) {MODE_INFO * * prev_mi = & cm -> prev_mi_grid_visible [ mi_row * xd -> mi_stride + mi_col ] ;get_sb_partition_size_range ( xd , prev_mi , & min_size , & max_size , bs_hist ) ;}MODE_INFO * * left_sb64_mi = & mi [ - MI_BLOCK_SIZE ] ;get_sb_partition_size_range ( xd , left_sb64_mi , & min_size , & max_size , bs_hist ) ;MODE_INFO * * above_sb64_mi = & mi [ - xd -> mi_stride * MI_BLOCK_SIZE ] ;get_sb_partition_size_range ( xd , above_sb64_mi , & min_size , & max_size , bs_hist ) ;",2013
1718,"min_size = MIN ( min_size , max_size ) ;if ( cpi -> sf . use_square_partition_only && next_square_size [ max_size ] < min_size ) {","if ( vp9_active_edge_sb ( cpi , mi_row , mi_col ) ) {min_size = BLOCK_4X4 ;}else {min_size = MIN ( cpi -> sf . rd_auto_partition_min_limit , MIN ( min_size , max_size ) ) ;}if ( cpi -> sf . use_square_partition_only && next_square_size [ max_size ] < min_size ) {",2013
1719,"# endif install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ;","# endif install_keyword ( ""umask"" , & umask_handler ) ;install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ;",2014
1720,# endif  },# endif },2014
1721,while ( ret < nr ) {long avail ;,head %= ctx -> nr_events ;tail %= ctx -> nr_events ;while ( ret < nr ) {long avail ;,2015
1722,"if ( ! IS_ERR ( state ) )  nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ;out_free : nfs4_opendata_put ( data ) ;","if ( ! IS_ERR ( state ) ) nfs4_close_state ( & data -> path , state , data -> o_arg . fmode ) ;out_free : nfs4_opendata_put ( data ) ;",2016
1723,"if ( ! n || ! buf || ! buf_size ) {datao = 6 + n -> offset ;if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || ( datao + 2 > buf_size ) ) {exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ;return ;}if ( ! n -> entries ) {EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , sizeof ( MnoteCanonEntry ) * c ) ;return ;}tcount = 0 ;for ( i = c , o = datao ;i ;-- i , o += 12 ) {size_t s ;if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) {exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA ,  ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\\\'%s\\\')..."" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ;","if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) {if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ;if ( exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) ;continue ;}",2017
1724,"if ( ( dataofs + s < s ) || ( dataofs + s < dataofs ) || ( dataofs + s > buf_size ) ) {exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ;","if ( ( dataofs + s < s ) || ( dataofs + s < dataofs ) || ( dataofs + s > buf_size ) ) {exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ;",2017
1725,"
","if ( ! n -> entries [ tcount ] . data ) {EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , s ) ;continue ;}memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ;",2017
1726,"if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) {tp -> tv_sec = div_long_long_rem ( cpu . sched ,  NSEC_PER_SEC , & tp -> tv_nsec ) ;else {cputime_to_timespec ( cpu . cpu , tp ) ;}}","if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) * tp = ns_to_timespec ( cpu . sched , NSEC_PER_SEC , & tp -> tv_nsec ) ;",2018
1727,mnt_flags |= MNT_NODEV ;},mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV ;},2019
1728,params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,"size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;",2020
1729,"void vp9_diff_update_prob ( vp9_reader * r , vp9_prob * p ) {if ( vp9_read ( r , DIFF_UPDATE_PROB ) ) {const int delp = decode_term_subexp ( r ) ;* p = ( vp9_prob ) inv_remap_prob ( delp , * p ) ;}","void vp9_diff_update_prob ( vpx_reader * r , vp9_prob * p ) {if ( vpx_read ( r , DIFF_UPDATE_PROB ) ) {const int delp = decode_term_subexp ( r ) ;* p = ( vpx_prob ) inv_remap_prob ( delp , * p ) ;}",2021
1730,"struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode )  {","struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , fmode_t mode ) {",2022
1731,"if ( ! port -> interrupt_in_urb ) {dev_err ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>interrupt_in_urb<S2SV_blank>is<S2SV_blank>empty!\\\return - 1 ;}","
",2023
1732,return FALSE ;,return TEMP_FAILURE_RETRY ( FALSE ;,2024
1733,"return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ;}","return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) ) == sizeof ( cmd ) ;}",2024
1734,"size_t len , next_len ;sc_apdu_t apdu ;next_len = MIN ( left , 100 ) ;for ( ;left -= len , out_ptr += len ) {len = next_len ;","size_t len ;sc_apdu_t apdu ;len = MIN ( left , 100 ) ;for ( ;) {",2025
1735,"if ( apdu . resplen == 0 ) {r = SC_ERROR_INTERNAL ;break ;}if ( apdu . sw1 != 0x63 || apdu . sw2 < 1 ) {r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ;break ;next_len = MIN ( left , apdu . sw2 ) ;}","out_ptr += len ;len = MIN ( left , apdu . sw2 ) ;",2025
1736,case FRAME_TYPE_JOIN_ACCEPT :  macMsgJoinAccept . Buffer = payload ;if ( MacCtx . NvmCtx -> NetworkActivation != ACTIVATION_TYPE_NONE ) {,case FRAME_TYPE_JOIN_ACCEPT : if ( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE ) {MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ;PrepareRxDoneAbort ( ) ;return ;}macMsgJoinAccept . Buffer = payload ;if ( ( MacCtx . NvmCtx -> NetworkActivation != ACTIVATION_TYPE_NONE ) {,2026
1737,"if ( MAX ( 0 , ( int16_t ) ( ( int16_t ) size - ( int16_t ) LORA_MAC_FRMPAYLOAD_OVERHEAD ) ) > ( int16_t ) phyParam . Value )  {","if ( MAX ( 0 , ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t ) phyParam . Value ) || ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE ) ) {",2026
1738,lxc_attach_options_t * options = payload -> options ;struct lxc_proc_context_info * init_ctx = payload -> init_ctx ;,int procfd = payload -> procfd ;lxc_attach_options_t * options = payload -> options ;struct lxc_proc_context_info * init_ctx = payload -> init_ctx ;,2027
1739,"if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) ) {int on_exec ;int proc_mounted ;on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;proc_mounted = mount_proc_if_needed ( ""/"" ) ;if ( proc_mounted == - 1 ) {ERROR ( ""Error<S2SV_blank>mounting<S2SV_blank>a<S2SV_blank>sane<S2SV_blank>/proc"" ) ;rexit ( - 1 ) ;}ret = lsm_process_label_set ( init_ctx -> lsm_label ,  init_ctx -> container -> lxc_conf , 0 , on_exec ) ;","if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) {int on_exec ;on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label , init_ctx -> container -> lxc_conf , 0 , on_exec ) ;",2027
1740,rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;},close ( procfd ) ;rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;},2027
1741,"struct fsnotify_group * group ;struct user_struct * user ;user = get_current_user ( ) ;if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) {ret = - EMFILE ;}group = inotify_new_group ( user , inotify_max_queued_events ) ;if ( IS_ERR ( group ) ) {ret = PTR_ERR ( group ) ;goto out_free_uid ;if ( ret >= 0 )  return ret ;fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;","struct fsnotify_group * group ;group = inotify_new_group ( user , inotify_max_queued_events ) ;if ( IS_ERR ( group ) ) {ret = PTR_ERR ( group ) ;if ( ret < 0 ) fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;",2028
1742,i += 1 ;},i ++ ;},2029
1743,"static vpx_codec_err_t vp8e_use_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_use_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2030
1744,"# ifdef CONFIG_SMP  s -> s_files = alloc_percpu ( struct list_head ) ;if ( ! s -> s_files ) goto fail ;for_each_possible_cpu ( i )  INIT_LIST_HEAD ( per_cpu_ptr ( s -> s_files , i ) ) ;# else INIT_LIST_HEAD ( & s -> s_files ) ;# endif for ( i = 0 ;lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] ,  & type -> s_writers_key [ i ] , 0 ) ;","for ( i = 0 ;lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ;",2031
1745,if ( list_lru_init ( & s -> s_dentry_lru ) )  goto fail ;if ( list_lru_init ( & s -> s_inode_lru ) )  goto fail ;,if ( list_lru_init ( & s -> s_dentry_lru ) ) goto fail ;if ( list_lru_init ( & s -> s_dentry_lru ) ) goto fail ;if ( list_lru_init ( & s -> s_inode_lru ) ) goto fail ;,2031
1746,"struct page * pages [ NFS4ACL_MAXPAGES ] ;struct nfs_getaclargs args = {. fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , }struct nfs_getaclres res = {. acl_len = buflen , };void * resp_buf ;struct rpc_message msg = {. rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , };struct page * localpage = NULL ;int ret ;if ( buflen < PAGE_SIZE ) {localpage = alloc_page ( GFP_KERNEL ) ;resp_buf = page_address ( localpage ) ;if ( localpage == NULL )  return - ENOMEM ;args . acl_pages [ 0 ] = localpage ;args . acl_pgbase = 0 ;args . acl_len = PAGE_SIZE ;else {resp_buf = buf ;buf_to_pages ( buf , buflen , args . acl_pages , & args . acl_pgbase ) ;if ( res . acl_len > args . acl_len )   nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ;else  nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ;if ( buf ) {ret = - ERANGE ;if ( res . acl_len > buflen )  goto out_free ;if ( localpage )   memcpy ( buf , resp_buf , res . acl_len ) ;}out_free :  if ( localpage )   __free_page ( localpage ) ;return ret ;","struct page * pages [ NFS4ACL_MAXPAGES ] = {NULL , }int ret = - ENOMEM , npages , i , acl_len = 0 ;npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ;if ( npages == 0 ) npages = 1 ;for ( i = 0 ;i < npages ;i ++ ) {pages [ i ] = alloc_page ( GFP_KERNEL ) ;if ( ! pages [ i ] ) goto out_free ;if ( npages > 1 ) {args . acl_scratch = alloc_page ( GFP_KERNEL ) ;if ( ! args . acl_scratch ) goto out_free ;args . acl_len = npages * PAGE_SIZE ;args . acl_pgbase = 0 ;if ( buf == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ;resp_buf = page_address ( pages [ 0 ] ) ;dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\\acl_len = res . acl_len - res . acl_data_offset ;if ( acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , NULL , acl_len ) ;else nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ) ;if ( acl_len > buflen ) goto out_free ;if ( localpage ) memcpy ( buf , resp_buf , res . acl_len ) ;}out_free : for ( i = 0 ;i < npages ;i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ;if ( args . acl_scratch ) __free_page ( args . acl_scratch ) ;return ret ;",2032
1747,"size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;size += rw_tlv_length ;skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ;","if ( ! miux_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;if ( ! rw_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += rw_tlv_length ;skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ;",2033
1748,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,2034
1749,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",2034
1750,# endif if ( * src == \'/\' )  separator = * src ++ ;for ( ;,"# endif if ( * src == \'/\' ) {if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ;return ( ARCHIVE_FAILED ) ;}separator = * src ++ ;}for ( ;",2035
1751,if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ;if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR )  return 1 ;,if ( is_nmi ( intr_info ) ) return 1 ;,2036
1752,if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ;,if ( skb_is_err_queue ( skb ) && need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ;,2037
1753,"if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) )  put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ;","if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ;",2037
1754,Py_ssize_t i ;PyMemoTable * new = PyMemoTable_New ( ) ;,PyMemoTable * new = PyMemoTable_New ( ) ;,2038
1755,for ( i = 0 ;Py_XINCREF ( self -> mt_table [ i ] . me_key ) ;,for ( size_t i = 0 ;Py_XINCREF ( self -> mt_table [ i ] . me_key ) ;,2038
1756,"static int handle_emulation_failure ( struct kvm_vcpu * vcpu )  {++ vcpu -> stat . insn_emulation_fail ;trace_kvm_emulate_insn_failed ( vcpu ) ;vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;kvm_queue_exception ( vcpu , UD_VECTOR ) ;return EMULATE_FAIL ;}","+ vcpu -> stat . insn_emulation_fail ;static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) {int r = EMULATE_DONE ;++ vcpu -> stat . insn_emulation_fail ;trace_kvm_emulate_insn_failed ( vcpu ) ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;r = EMULATE_FAIL ;}kvm_queue_exception ( vcpu , UD_VECTOR ) ;return r ;}",2039
1757,struct sk_buff * list_skb = skb_shinfo ( head_skb ) -> frag_list ;unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ;unsigned int offset = doffset ;,struct sk_buff * list_skb = skb_shinfo ( head_skb ) ;struct sk_buff * frag_skb = head_skb -> frag_list ;frag_skb = list_skb ;unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ;unsigned int offset = doffset ;,2040
1758,pos += skb_headlen ( list_skb ) ;while ( pos < offset + len ) {,frag_skb = list_skb ;pos += skb_headlen ( list_skb ) ;while ( pos < offset + len ) {,2040
1759,"
","if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ;",2040
1760,BUG_ON ( ! nfrags ) ;list_skb = list_skb -> next ;* nskb_frag = * frag ;__skb_frag_ref ( nskb_frag ) ;,BUG_ON ( ! nfrags ) ;list_skb = list_skb -> next ;* nskb_frag = * frag ;__skb_frag_ref ( nskb_frag ) ;,2040
1761,"next_byte :  b = cpu_ldub_code ( env , s -> pc ) ;","next_byte : if ( s -> pc - pc_start > 14 ) {goto illegal_op ;}b = cpu_ldub_code ( env , s -> pc ) ;",2041
1762,"
","if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",2042
1763,break ;},break ;},2042
1764,"
","if ( 1 == ps_dec -> i4_num_cores && 0 == ps_dec -> u2_num_mbs_left ) {i4_continue_decode = 0 ;android_errorWriteLog ( 0x534e4554 , ""26070014"" ) ;}",2043
1765,if ( i4_continue_decode )  {,if ( i4_continue_decode ) {,2043
1766,"flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ;if ( ! flen ) continue ;","flen = udf_get_filename ( dir -> i_sb , nameptr , lfi , fname , UDF_NAME_LEN ) ;if ( ! flen ) continue ;",2044
1767,"static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx )  {make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ;index = pending_index ( netbk -> pending_prod ++ ) ;","static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx , u8 status ) {make_tx_response ( vif , & pending_tx_info -> req , status ) ;index = pending_index ( netbk -> pending_prod ++ ) ;",2045
1768,"if ( ! cfg . shell )  cfg . shell = guess_shell ( ) ;if ( ! cfg . shell ) {fprintf ( stderr , ""Error:<S2SV_blank>no<S2SV_blank>POSIX<S2SV_blank>shell<S2SV_blank>found,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>--shell<S2SV_blank>command<S2SV_blank>line<S2SV_blank>option\\\exit ( 1 ) ;}arg [ 0 ] = cfg . shell ;arg [ 1 ] = ""-c"" ;","arg [ 0 ] = cfg . shell ;arg [ 1 ] = ""-c"" ;",2046
1769,"int64_t vp9_rd_pick_inter_mode_sb ( VP9_COMP * cpi , MACROBLOCK * x ,   const TileInfo * const tile ,  int mi_row , int mi_col ,  int * returnrate ,  int64_t * returndistortion , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd_so_far ) {MACROBLOCKD * const xd = & x -> e_mbd ;MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;const struct segmentation * const seg = & cm -> seg ;MB_PREDICTION_MODE this_mode ;MV_REFERENCE_FRAME ref_frame , second_ref_frame ;int comp_pred , i ;int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ;int_mv single_newmv [ MAX_REF_FRAMES ] = {static const int flag_list [ 4 ] = {int64_t best_tx_rd [ TX_MODES ] ;int64_t best_tx_diff [ TX_MODES ] ;MB_MODE_INFO best_mbmode = {0 };int mode_index , best_mode_index = 0 ;unsigned int ref_costs_single [ MAX_REF_FRAMES ] , ref_costs_comp [ MAX_REF_FRAMES ] ;vp9_prob comp_mode_p ;int64_t best_intra_rd = INT64_MAX ;int64_t best_inter_rd = INT64_MAX ;MB_PREDICTION_MODE best_intra_mode = DC_PRED ;MV_REFERENCE_FRAME best_inter_ref_frame = LAST_FRAME ;int64_t dist_uv [ TX_SIZES ] ;int skip_uv [ TX_SIZES ] ;MB_PREDICTION_MODE mode_uv [ TX_SIZES ] ;int64_t mode_distortions [ MB_MODE_COUNT ] = {int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ;const int bws = num_8x8_blocks_wide_lookup [ bsize ] / 2 ;int mode_skip_mask = 0 ;int mode_skip_start = cpi -> sf . mode_skip_start + 1 ;const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ;const int * const rd_thresh_freq_fact = cpi -> rd_thresh_freq_fact [ bsize ] ;const int mode_search_skip_flags = cpi -> sf . mode_search_skip_flags ;const int intra_y_mode_mask = cpi -> sf . intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] ;int disable_inter_mode_mask = cpi -> sf . disable_inter_mode_mask [ bsize ] ;x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ;estimate_ref_frame_costs ( cpi , segment_id , ref_costs_single , ref_costs_comp ,  & comp_mode_p ) ;for ( i = 0 ;i < REFERENCE_MODES ;++ i ) best_pred_rd [ i ] = INT64_MAX ;for ( i = 0 ;i < TX_MODES ;i ++ )  best_tx_rd [ i ] = INT64_MAX ;","void vp9_rd_pick_inter_mode_sb ( VP9_COMP * cpi , TileDataEnc * tile_data , MACROBLOCK * x , int mi_row , int mi_col , int * returnrate , int64_t * returndistortion , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd_so_far ) {TileInfo * const tile_info = & tile_data -> tile_info ;RD_OPT * const rd_opt = & cpi -> rd ;SPEED_FEATURES * const sf = & cpi -> sf ;MACROBLOCKD * const xd = & x -> e_mbd ;MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ;const struct segmentation * const seg = & cm -> seg ;PREDICTION_MODE this_mode ;MV_REFERENCE_FRAME ref_frame , second_ref_frame ;int comp_pred , i , k ;int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ;int_mv single_newmv [ MAX_REF_FRAMES ] = {INTERP_FILTER single_inter_filter [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ;int single_skippable [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ;static const int flag_list [ 4 ] = {MB_MODE_INFO best_mbmode ;int best_mode_skippable = 0 ;int midx , best_mode_index = 0 ;unsigned int ref_costs_single [ MAX_REF_FRAMES ] , ref_costs_comp [ MAX_REF_FRAMES ] ;vpx_prob comp_mode_p ;int64_t best_intra_rd = INT64_MAX ;unsigned int best_pred_sse = UINT_MAX ;PREDICTION_MODE best_intra_mode = DC_PRED ;MV_REFERENCE_FRAME best_inter_ref_frame = LAST_FRAME ;PREDICTION_MODE mode_uv [ TX_SIZES ] ;int64_t mode_distortions [ MB_MODE_COUNT ] = {int intra_cost_penalty = vp9_get_intra_cost_penalty ( cm -> base_qindex , cm -> y_dc_delta_q ) ;const int bws = num_8x8_blocks_wide_lookup [ bsize ] / 2 ;+ i ) best_pred_rd [ i ] = INT64_MAX ;uint8_t ref_frame_skip_mask [ 2 ] = {0 };uint16_t mode_skip_mask [ MAX_REF_FRAMES ] = {0 };int mode_skip_start = sf -> mode_skip_start + 1 ;const int * const rd_threshes = rd_opt -> threshes [ segment_id ] [ bsize ] ;const int * const rd_thresh_freq_fact = tile_data -> thresh_freq_fact [ bsize ] ;int64_t mode_threshold [ MAX_MODES ] ;int * mode_map = tile_data -> mode_map [ bsize ] ;const int mode_search_skip_flags = sf -> mode_search_skip_flags ;int64_t mask_filter = 0 ;int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ;vp9_zero ( best_mbmode ) ;x -> skip_encode = sf -> skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ;estimate_ref_frame_costs ( cpi , segment_id , ref_costs_single , ref_costs_comp , & comp_mode_p ) ;",2047
1770,"* returnrate = INT_MAX ;for ( ref_frame = LAST_FRAME ;vp9_setup_buffer_inter ( cpi , x , tile ,  ref_frame , bsize , mi_row , mi_col , frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ;","for ( i = 0 ;i < MB_MODE_COUNT ;++ i ) {for ( k = 0 ;k < MAX_REF_FRAMES ;++ k ) {single_inter_filter [ i ] [ k ] = SWITCHABLE ;single_skippable [ i ] [ k ] = 0 ;}}rd_cost -> rate = INT_MAX ;for ( ref_frame = LAST_FRAME ;assert ( get_ref_frame_buffer ( cpi , x , tile , ref_frame , bsize , mi_row , mi_col , frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ;",2047
1771,"static const int ref_frame_mask_all [ ] = {0x0 , 0x123291 , 0x25c444 , 0x39b722 };static const int ref_frame_mask_fixedmv [ ] = {0x0 , 0x121281 , 0x24c404 , 0x080102 };mode_skip_mask |= ref_frame_mask_all [ ref_frame ] ;}for ( i = LAST_FRAME ;mode_skip_mask |= ref_frame_mask_fixedmv [ ref_frame ] ;break ;if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) &&   vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) {mode_skip_mask |= ref_frame_mask_all [ ref_frame ] ;}const int inter_non_zero_mode_mask = 0x1F7F7 ;mode_skip_mask |= inter_non_zero_mode_mask ;}if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) {if ( cpi -> rc . is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) {const int altref_zero_mask =  ~ ( ( 1 << THR_NEARESTA ) | ( 1 << THR_NEARA ) | ( 1 << THR_ZEROA ) ) ;mode_skip_mask |= altref_zero_mask ;if ( frame_mv [ NEARMV ] [ ALTREF_FRAME ] . as_int != 0 )  mode_skip_mask |= ( 1 << THR_NEARA ) ;if ( frame_mv [ NEARESTMV ] [ ALTREF_FRAME ] . as_int != 0 )  mode_skip_mask |= ( 1 << THR_NEARESTA ) ;}}if ( ( mi_row + bhs ) > cm -> mi_rows || ( mi_col + bws ) > cm -> mi_cols ) {const int new_modes_mask = ( 1 << THR_NEWMV ) | ( 1 << THR_NEWG ) | ( 1 << THR_NEWA ) | ( 1 << THR_COMP_NEWLA ) | ( 1 << THR_COMP_NEWGA ) ;mode_skip_mask |= new_modes_mask ;}if ( bsize > cpi -> sf . max_intra_bsize ) {mode_skip_mask |= 0xFF30808 ;}if ( ! x -> in_active_map ) {int mode_index ;assert ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ;if ( frame_mv [ NEARESTMV ] [ LAST_FRAME ] . as_int == 0 ) mode_index = THR_NEARESTMV ;else if ( frame_mv [ NEARMV ] [ LAST_FRAME ] . as_int == 0 ) mode_index = THR_NEARMV ;else mode_index = THR_ZEROMV ;mode_skip_mask = ~ ( 1 << mode_index ) ;mode_skip_start = MAX_MODES ;disable_inter_mode_mask = 0 ;}for ( mode_index = 0 ;mode_index < MAX_MODES ;++ mode_index ) {int mode_excluded = 0 ;int64_t this_rd = INT64_MAX ;int disable_skip = 0 ;int compmode_cost = 0 ;int rate2 = 0 , rate_y = 0 , rate_uv = 0 ;int64_t distortion2 = 0 , distortion_y = 0 , distortion_uv = 0 ;int skippable = 0 ;int64_t tx_cache [ TX_MODES ] ;int i ;int this_skip2 = 0 ;int64_t total_sse = INT64_MAX ;int early_term = 0 ;if ( mode_index == mode_skip_start ) {switch ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] ) {case INTRA_FRAME : break ;case LAST_FRAME :  mode_skip_mask |= LAST_FRAME_MODE_MASK ;break ;case GOLDEN_FRAME :  mode_skip_mask |= GOLDEN_FRAME_MODE_MASK ;break ;case ALTREF_FRAME :  mode_skip_mask |= ALT_REF_MODE_MASK ;break ;case NONE : case MAX_REF_FRAMES : assert ( 0 && ""Invalid<S2SV_blank>Reference<S2SV_blank>frame"" ) ;}}if ( mode_skip_mask & ( 1 << mode_index ) )  continue ;if ( best_rd < ( ( int64_t ) rd_threshes [ mode_index ] *  rd_thresh_freq_fact [ mode_index ] >> 5 ) || rd_threshes [ mode_index ] == INT_MAX ) continue ;this_mode = vp9_mode_order [ mode_index ] . mode ;ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 0 ] ;if ( ref_frame != INTRA_FRAME && disable_inter_mode_mask & ( 1 << INTER_OFFSET ( this_mode ) ) ) continue ;second_ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 1 ] ;comp_pred = second_ref_frame > INTRA_FRAME ;if ( comp_pred ) {if ( ( mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) &&   vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME )  continue ;if ( ( mode_search_skip_flags & FLAG_SKIP_COMP_REFMISMATCH ) && ref_frame != best_inter_ref_frame && second_ref_frame != best_inter_ref_frame ) continue ;mode_excluded = cm -> reference_mode == SINGLE_REFERENCE ;if ( ! ( intra_y_mode_mask & ( 1 << this_mode ) ) )  continue ;if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] > INTRA_FRAME )  continue ;","mode_skip_mask |= ref_frame_mask_all [ ref_frame ] ;}for ( i = LAST_FRAME ;mode_skip_mask |= ref_frame_mask_fixedmv [ ref_frame ] ;break ;if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) {mode_skip_mask |= ref_frame_mask_all [ ref_frame ] ;}+ mode_index ) {ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ;ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ;if ( ! ( intra_y_mode_mask & ( 1 << this_mode ) ) ) continue ;if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] > INTRA_FRAME ) continue ;",2047
1772,"if ( x -> in_active_map &&  ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) )  if ( ! check_best_zero_mv ( cpi , mbmi -> mode_context , frame_mv ,  disable_inter_mode_mask , this_mode , ref_frame , second_ref_frame ) ) continue ;x -> skip = 0 ;set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ;for ( i = 0 ;++ i )  tx_cache [ i ] = INT64_MAX ;intra_super_block_yrd ( cpi , x , & rate_y , & distortion_y , & skippable , NULL ,   bsize , tx_cache , best_rd ) ;if ( rate_y == INT_MAX ) continue ;uv_tx = get_uv_tx_size_impl ( mbmi -> tx_size , bsize ) ;if ( rate_uv_intra [ uv_tx ] == INT_MAX ) {choose_intra_uv_mode ( cpi , ctx , bsize , uv_tx ,  & rate_uv_intra [ uv_tx ] , & rate_uv_tokenonly [ uv_tx ] , & dist_uv [ uv_tx ] , & skip_uv [ uv_tx ] , & mode_uv [ uv_tx ] ) ;rate2 = rate_y + x -> mbmode_cost [ mbmi -> mode ] + rate_uv_intra [ uv_tx ] ;if ( this_mode != DC_PRED && this_mode != TM_PRED ) rate2 += intra_cost_penalty ;this_rd = handle_inter_mode ( cpi , x , tile , bsize ,  tx_cache , & rate2 , & distortion2 , & skippable ,  & rate_y , & distortion_y ,  & rate_uv , & distortion_uv , & mode_excluded , & disable_skip ,  & tmp_best_filter , frame_mv ,  mi_row , mi_col ,  single_newmv , & total_sse , best_rd ) ;if ( this_rd == INT64_MAX ) continue ;if ( comp_pred ) {rate2 += ref_costs_comp [ ref_frame ] ;}else {rate2 += ref_costs_single [ ref_frame ] ;}if ( ! disable_skip ) {const int mb_skip_allowed = ! vp9_segfeature_active ( seg , segment_id ,  SEG_LVL_SKIP ) ;rate_uv = 0 ;if ( mb_skip_allowed ) {","if ( x -> in_active_map && ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) if ( ! check_best_zero_mv ( cpi , mbmi -> mode_context , frame_mv , disable_inter_mode_mask , this_mode , ref_frame , second_ref_frame ) ) continue ;x -> skip = 0 ;set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ;for ( i = 0 ;+ i )  tx_cache [ i ] = INT64_MAX ;++ i ) tx_cache [ i ] = INT64_MAX ;intra_super_block_yrd ( cpi , x , & rate_y , & distortion_y , & skippable , NULL , bsize , tx_cache , best_rd ) ;if ( rate_y == INT_MAX ) continue ;uv_tx = get_uv_tx_size_impl ( mbmi -> tx_size , bsize ) ;if ( rate_uv_intra [ uv_tx ] == INT_MAX ) {choose_intra_uv_mode ( cpi , ctx , bsize , uv_tx , & rate_uv_intra [ uv_tx ] , & rate_uv_tokenonly [ uv_tx ] , & dist_uv [ uv_tx ] , & skip_uv [ uv_tx ] , & mode_uv [ uv_tx ] ) ;rate2 = rate_y + x -> mbmode_cost [ mbmi -> mode ] + rate_uv_intra [ uv_tx ] ;if ( this_mode != DC_PRED && this_mode != TM_PRED ) rate2 += intra_cost_penalty ;this_rd = handle_inter_mode ( cpi , x , tile , bsize , tx_cache , & rate2 , & distortion2 , & skippable , & rate_y , & distortion_y , & rate_uv , & distortion_uv , & mode_excluded , & disable_skip , & tmp_best_filter , frame_mv , mi_row , mi_col , single_newmv , & total_sse , best_rd ) ;if ( this_rd == INT64_MAX ) continue ;if ( segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ;rate_uv = 0 ;if ( mb_skip_allowed ) {",2047
1773,"}else if ( mb_skip_allowed && ref_frame != INTRA_FRAME && ! xd -> lossless ) {if ( RDCOST ( x -> rdmult , x -> rddiv , rate_y + rate_uv , distortion2 ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) {rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;}else {rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;distortion2 = total_sse ;assert ( total_sse >= 0 ) ;rate2 -= ( rate_y + rate_uv ) ;rate_y = 0 ;rate_uv = 0 ;this_skip2 = 1 ;}}else if ( mb_skip_allowed ) {rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;}this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;}if ( ref_frame == INTRA_FRAME ) {if ( this_rd < best_intra_rd ) {best_intra_rd = this_rd ;best_intra_mode = mbmi -> mode ;}}else {if ( ! comp_pred && ! mode_excluded && this_rd < best_inter_rd ) {best_inter_rd = this_rd ;best_inter_ref_frame = ref_frame ;}}if ( ! disable_skip && ref_frame == INTRA_FRAME ) {for ( i = 0 ;i < REFERENCE_MODES ;++ i ) best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;i ++ )  best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , this_rd ) ;}if ( mode_distortions [ this_mode ] == - 1 || distortion2 < mode_distortions [ this_mode ] ) {mode_distortions [ this_mode ] = distortion2 ;if ( this_rd < best_rd || x -> skip ) {int max_plane = MAX_MB_PLANE ;* returnrate = rate2 ;* returndistortion = distortion2 ;best_rd = this_rd ;if ( ! x -> select_txfm_size )   swap_block_ptr ( x , ctx , max_plane ) ;vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] ,   sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ;if ( ( mode_search_skip_flags & FLAG_EARLY_TERMINATE ) && ( mode_index > MIN_EARLY_TERM_INDEX ) ) {const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ;int scale = 4 ;if ( x -> source_variance < UINT_MAX ) {","+ i ) best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ;else if ( mb_skip_allowed && ref_frame != INTRA_FRAME && ! xd -> lossless ) {if ( RDCOST ( x -> rdmult , x -> rddiv , rate_y + rate_uv , distortion2 ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) {ref_frame_skip_mask [ 0 ] = ( 1 << LAST_FRAME ) | ( 1 << GOLDEN_FRAME ) ;ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ;mode_skip_mask [ ALTREF_FRAME ] = ~ INTER_NEAREST_NEAR_ZERO ;* returnrate = rate2 ;* returndistortion = distortion2 ;best_rd = this_rd ;if ( ! x -> select_txfm_size ) swap_block_ptr ( x , ctx , max_plane ) ;vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] , sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ;if ( ( mode_search_skip_flags & FLAG_EARLY_TERMINATE ) && ( mode_index > MIN_EARLY_TERM_INDEX ) ) {const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ;int scale = 4 ;if ( x -> source_variance < UINT_MAX ) {",2047
1774,if ( single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) {best_pred_rd [ SINGLE_REFERENCE ] = single_rd ;}}if ( single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) {best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ;}}int64_t ref = cpi -> rd_filter_cache [ cm -> interp_filter == SWITCHABLE ?  SWITCHABLE_FILTERS : cm -> interp_filter ] ;else if ( cpi -> rd_filter_cache [ i ] == INT64_MAX )   adj_rd = cpi -> mask_filter_rd - ref + 10 ;else  adj_rd = cpi -> rd_filter_cache [ i ] - ref ;adj_rd += this_rd ;}},if ( single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) {best_pred_rd [ SINGLE_REFERENCE ] = single_rd ;}}if ( single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) {best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ;}}int64_t ref = cpi -> rd_filter_cache [ cm -> interp_filter == SWITCHABLE ? SWITCHABLE_FILTERS : cm -> interp_filter ] ;else if ( cpi -> rd_filter_cache [ i ] == INT64_MAX ) adj_rd = cpi -> mask_filter_rd - ref + 10 ;else adj_rd = cpi -> rd_filter_cache [ i ] - ref ;adj_rd += this_rd ;}},2047
1775,"if ( best_rd >= best_rd_so_far )  return INT64_MAX ;if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) {TX_SIZE uv_tx_size ;* mbmi = best_mbmode ;uv_tx_size = get_uv_tx_size ( mbmi ) ;rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra [ uv_tx_size ] , & rate_uv_tokenonly [ uv_tx_size ] , & dist_uv [ uv_tx_size ] , & skip_uv [ uv_tx_size ] , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize , uv_tx_size ) ;}}assert ( ( cm -> interp_filter == SWITCHABLE ) || ( cm -> interp_filter == best_mbmode . interp_filter ) || ! is_inter_block ( & best_mbmode ) ) ;if ( cpi -> sf . adaptive_rd_thresh ) {for ( mode_index = 0 ;mode_index < MAX_MODES ;++ mode_index ) {int * const fact = & cpi -> rd_thresh_freq_fact [ bsize ] [ mode_index ] ;if ( mode_index == best_mode_index ) {* fact -= ( * fact >> 3 ) ;}else {* fact = MIN ( * fact + RD_THRESH_INC , cpi -> sf . adaptive_rd_thresh * RD_THRESH_MAX_FACT ) ;}}}* mbmi = best_mbmode ;x -> skip |= best_skip2 ;for ( i = 0 ;i < REFERENCE_MODES ;++ i ) {","if ( best_rd >= best_rd_so_far ) return INT64_MAX ;+ mode_index ) {+ i ) {if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) continue ;if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ;if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ;",2047
1776,for ( i = 0 ;if ( best_tx_rd [ i ] == INT64_MAX ) best_tx_diff [ i ] = 0 ;,for ( i = 0 ;if ( best_tx_rd [ i ] == INT64_MAX ) best_tx_diff [ i ] = 0 ;,2047
1777,"assert ( mbmi -> mode == mbmi -> uv_mode ) ;set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ;store_coding_context ( x , ctx , best_mode_index , & mbmi -> ref_mvs [ mbmi -> ref_frame [ 0 ] ] [ 0 ] , & mbmi -> ref_mvs [ mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] ] [ 0 ] , best_pred_diff , best_tx_diff , best_filter_diff ) ;return best_rd ;","rd_variance_adjustment ( cpi , x , bsize , & this_rd , ref_frame , x -> source_variance ) ;else {vp9_zero ( best_filter_diff ) ;}x -> skip |= best_mode_skippable ;if ( ! x -> skip && ! x -> select_tx_size ) {int has_high_freq_coeff = 0 ;int plane ;int max_plane = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ? MAX_MB_PLANE : 1 ;for ( plane = 0 ;plane < max_plane ;++ plane ) {x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 1 ] ;has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ;}for ( plane = max_plane ;plane < MAX_MB_PLANE ;++ plane ) {x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 2 ] ;has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ;}best_mode_skippable |= ! has_high_freq_coeff ;}assert ( best_mode_index >= 0 ) ;store_coding_context ( x , ctx , best_mode_index , best_pred_diff , best_filter_diff , best_mode_skippable ) ;",2047
1778,g_object_unref ( subdir ) ;dir = GSF_INFILE_TAR ( subdir ) ;},dir = GSF_IS_INFILE_TAR ( subdir ) ? GSF_INFILE_TAR ( subdir ) : dir ;g_object_unref ( subdir ) ;},2048
1779,"int i , attr_id = 0 , nattr ;q = ( * s ) + 1 ;","int i , attr_id = 0 , nattr ;tagname [ 0 ] = '\\\\0' ;q = ( * s ) + 1 ;",2049
1780,# ifdef CONFIG_SCHED_STACK_END_CHECK  BUG_ON ( task_stack_end_corrupted ( prev ) ) ;# endif if ( unlikely ( in_atomic_preempt_off ( ) ) ) {,"# ifdef CONFIG_SCHED_STACK_END_CHECK if ( task_stack_end_corrupted ( prev ) ) panic ( ""corrupted<S2SV_blank>stack<S2SV_blank>end<S2SV_blank>detected<S2SV_blank>inside<S2SV_blank>scheduler\\\# endif if ( unlikely ( in_atomic_preempt_off ( ) ) ) {",2050
1781,"
","memset ( newserv , 0 , sizeof ( struct service ) ) ;",2051
1782,"if ( containsForbiddenChars ( p , l ) ) {syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ;","if ( containsForbiddenChars ( p , l ) ) {syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ;",2051
1783,"n = r -> iov . iov_len / 512 ;if ( n ) {qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ;","n = r -> qiov . size / 512 ;if ( n ) {bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ;",2052
1784,if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) {static uint64_t next_id = 0 ;,if ( rh . command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) {static uint64_t next_id = 0 ;,2053
1785,"return PyBytes_DecodeEscape ( s , len , NULL , 0 , NULL ) ;}","const char * first_invalid_escape ;PyObject * result = _PyBytes_DecodeEscape ( s , len , NULL , 0 , NULL , & first_invalid_escape ) ;if ( result == NULL ) return NULL ;if ( first_invalid_escape != NULL ) {if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) {Py_DECREF ( result ) ;return NULL ;}}return result ;}",2054
1786,"vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;","memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;",2055
1787,free ( szSepLine ) ;return 0 ;,return 0 ;,2056
1788,state -> space_before = NULL ;state -> space_before_len = 0 ;}}else {if ( state -> space_before ) ruby_xfree ( state -> space_before ) ;state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ;state -> space_before_len = len ;,"state -> space_before = fstrndup ( RSTRING_PTR ( space_before ) , len ) ;state -> space_before_len = len ;",2057
1789,"struct user_element * ue = kcontrol -> private_data ;change = memcmp ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) != 0 ;return change ;}","struct user_element * ue = kcontrol -> private_data ;mutex_lock ( & ue -> card -> user_ctl_lock ) ;change = memcmp ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) != 0 ;mutex_unlock ( & ue -> card -> user_ctl_lock ) ;return change ;}",2058
1790,"stat ( options -> in_file , & filestats ) ;plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ;","stat ( options -> in_file , & filestats ) ;if ( filestats . st_size < 8 ) {printf ( ""ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\\return - 1 ;}plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ;",2059
1791,"unsigned long off ;unsigned long start ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) )  return - EINVAL ;off = vma -> vm_pgoff << PAGE_SHIFT ;fb = info -> fbops ;if ( fb -> fb_mmap ) {int res ;len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . smem_len ) ;if ( off >= len ) {off -= len ;if ( info -> var . accel_flags ) {mutex_unlock ( & info -> mm_lock ) ;return - EINVAL ;}len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . mmio_len ) ;start &= PAGE_MASK ;if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) return - EINVAL ;off += start ;vma -> vm_pgoff = off >> PAGE_SHIFT ;fb_pgprotect ( file , vma , off ) ;if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) return - EAGAIN ;return 0 ;","unsigned long mmio_pgoff ;unsigned long start ;fb = info -> fbops ;if ( fb -> fb_mmap ) {int res ;len = info -> fix . smem_len ;mmio_pgoff = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ;if ( vma -> vm_pgoff >= mmio_pgoff ) {vma -> vm_pgoff -= mmio_pgoff ;len = info -> fix . mmio_len ;if ( fb -> fb_mmap ) {int res ;res = fb -> fb_mmap ( info , vma ) ;mutex_unlock ( & info -> mm_lock ) ;fb_pgprotect ( file , vma , start ) ;return vm_iomap_memory ( vma , start , len ) ;",2060
1792,"break ;case Interactive_kind : result = PyType_GenericNew ( Interactive_type , NULL , NULL ) ;","value = ast2obj_list ( o -> v . Module . type_ignores , ast2obj_type_ignore ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_ignores , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;break ;case FunctionType_kind : result = PyType_GenericNew ( FunctionType_type , NULL , NULL ) ;if ( ! result ) goto failed ;value = ast2obj_list ( o -> v . FunctionType . argtypes , ast2obj_expr ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_argtypes , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_expr ( o -> v . FunctionType . returns ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;break ;case Interactive_kind : result = PyType_GenericNew ( Interactive_type , NULL , NULL ) ;",2061
1793,"case Suite_kind :  result = PyType_GenericNew ( Suite_type , NULL , NULL ) ;","case Suite_kind : result = PyType_GenericNew ( Suite_type , NULL , NULL ) ;",2061
1794,quantum_info = DestroyQuantumInfo ( quantum_info ) ;return ( DestroyImageList ( image ) ) ;,quantum_info = DestroyQuantumInfo ( quantum_info ) ;canvas_image = DestroyImage ( canvas_image ) ;return ( DestroyImageList ( image ) ) ;,2062
1795,"if ( ! sock_flag ( sk , SOCK_ZAPPED ) )  return - EINVAL ;if ( addr_len < sizeof ( struct sockaddr_l2tpip ) )  return - EINVAL ;if ( addr -> l2tp_family != AF_INET )  return - EINVAL ;lock_sock ( sk ) ;if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ;","if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ;if ( addr -> l2tp_family != AF_INET ) return - EINVAL ;if ( addr -> l2tp_family != AF_INET ) return - EINVAL ;lock_sock ( sk ) ;if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out ;if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ;",2063
1796,"case VTP_SUBSET_ADV :  ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ;tptr += 4 ;while ( tptr < ( pptr + length ) ) {len = * tptr ;","case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ;tptr += 4 ;while ( tptr < ( pptr + length ) ) {ND_TCHECK_8BITS ( tptr ) ;len = * tptr ;",2064
1797,if ( op -> op > 0xbf ) return 1 ;WasmOpDef * opdef = & opcodes [ op -> op ] ;,if ( op -> op > 0xbf ) {return 1 ;}WasmOpDef * opdef = & opcodes [ op -> op ] ;,2065
1798,if ( ! ( n > 0 && n < buf_len ) ) goto err ;,if ( ! ( n > 0 && n < buf_len ) ) {goto err ;},2065
1799,"if ( ! ( n > 0 && n < buf_len ) ) goto err ;if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ;int i = 0 ;if ( ! ( op -> len + n <= buf_len ) ) goto beach ;op -> len += n ;}if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ;op -> len += n ;for ( i = 0 ;i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ;snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ;}","if ( ! ( n > 0 && n < buf_len ) ) goto err ;if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) {) goto err ;}int i = 0 ;if ( ! ( op -> len + n <= buf_len ) ) {goto beach ;}op -> len += n ;}if ( ! ( n > 0 && n + op -> len < buf_len ) ) {goto beach ;}op -> len += n ;for ( i = 0 ;i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ;int optxtlen = strlen ( op -> txt ) ;snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ;}",2065
1800,dst [ dst_byte_offset ] = 0 ;current_bit_offset = 0 ;,current_bit_offset = 0 ;,2066
1801,nPath ++ ;},nPath = ( int ) strlen ( zPath ) ;},2067
1802,"BN_ULONG t1 , t2 ;BN_ULONG c1 , c2 , c3 ;","BN_ULONG c1 , c2 , c3 ;",2068
1803,"int ret ;ret = usb_control_msg ( pegasus -> usb , usb_rcvctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_GET_REGS , PEGASUS_REQT_READ , 0 ,  indx , data , size , 1000 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\return ret ;}","u8 * buf ;int ret ;buf = kmalloc ( size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( pegasus -> usb , usb_rcvctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_GET_REGS , PEGASUS_REQT_READ , 0 , indx , buf , size , 1000 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\else if ( ret <= size ) memcpy ( data , buf , ret ) ;kfree ( buf ) ;return ret ;}",2069
1804,"guint uint_val = GST_READ_UINT32_LE ( value ) ;g_value_init ( & tag_value , G_TYPE_UINT ) ;gboolean bool_val = GST_READ_UINT32_LE ( value ) ;if ( strncmp ( ""Stereoscopic"" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {","guint uint_val ;if ( value_len < 4 ) break ;uint_val = GST_READ_UINT32_LE ( value ) ;g_value_init ( & tag_value , G_TYPE_UINT ) ;gboolean bool_val ;if ( value_len < 4 ) break ;bool_val = GST_READ_UINT32_LE ( value ) ;if ( strncmp ( ""Stereoscopic"" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {",2070
1805,uint16_t auxsize ;if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ;,uint16_t auxsize ;int ret ;if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ;,2071
1806,"av_get_packet ( pb , pkt , vsize ) ;pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ;","if ( ( ret = av_get_packet ( pb , pkt , vsize ) ) < 0 ) return ret ;pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ;",2071
1807,"av_get_packet ( pb , pkt , asize ) ;pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ;","if ( ( ret = av_get_packet ( pb , pkt , asize ) ) < 0 ) return ret ;pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ;",2071
1808,"op = queue_remove_if ( att -> req_queue , match_op_id , UINT_TO_PTR ( id ) ) ;if ( op ) goto done ;","if ( att -> in_disc ) return bt_att_disc_cancel ( att , id ) ;op = queue_remove_if ( att -> req_queue , match_op_id , UINT_TO_PTR ( id ) ) ;if ( op ) goto done ;",2072
1809,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,2073
1810,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",2073
1811,"unsigned int maxw , maxh , max , i ;int offset , upb ;maxw = ( unsigned int ) img -> comps [ 0 ] . w ;maxh = ( unsigned int ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;","size_t maxw , maxh , max , i ;int offset , upb ;maxw = ( size_t ) img -> comps [ 0 ] . w ;maxh = ( size_t ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;",2074
1812,return ;fails :  if ( r ) free ( r ) ;if ( g ) free ( g ) ;if ( b ) free ( b ) ;,img -> color_space = OPJ_CLRSPC_SRGB ;return ;fails : free ( r ) ;free ( g ) ;free ( b ) ;,2074
1813,if ( ( entry -> flags & SC_ASN1_UNSIGNED )  && obj [ 0 ] == 0x00 && objlen > 1 ) {objlen -- ;,if ( ( entry -> flags & SC_ASN1_UNSIGNED ) && objlen > 1 && obj [ 0 ] == 0x00 ) {objlen -- ;,2075
1814,get_page ( page ) ;spin_unlock ( ptl ) ;,if ( unlikely ( ! try_get_page ( page ) ) ) {spin_unlock ( ptl ) ;return ERR_PTR ( - ENOMEM ) ;}spin_unlock ( ptl ) ;,2076
1815,mntput ( ns -> proc_mnt ) ;},kern_unmount ( ns -> proc_mnt ) ;},2077
1816,switch ( bps / 8 )  {,"if ( bytes_per_pixel > sizeof ( swapbuff ) ) {TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ;return ( 1 ) ;}switch ( bps / 8 ) {",2078
1817,"next_frame_start = ( cfg -> g_timebase . den * ( int64_t ) ( frames_in ) * global -> framerate . den ) / cfg -> g_timebase . num / global -> framerate . num ;if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) {if ( ! stream -> img )   stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 ,  cfg -> g_w , cfg -> g_h , 16 ) ;img = stream -> img ;}","# if CONFIG_VP9_HIGHBITDEPTH if ( img ) {if ( img -> fmt != VPX_IMG_FMT_I42016 ) {fprintf ( stderr , ""%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>inputs\\\exit ( EXIT_FAILURE ) ;}# if CONFIG_LIBYUV if ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) {if ( ! stream -> img ) {stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I42016 , cfg -> g_w , cfg -> g_h , 16 ) ;}I420Scale_16 ( ( uint16 * ) img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] / 2 , img -> d_w , img -> d_h , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_Y ] , stream -> img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_U ] , stream -> img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_V ] , stream -> img -> stride [ VPX_PLANE_V ] / 2 , stream -> img -> d_w , stream -> img -> d_h , kFilterBox ) ;img = stream -> img ;# else stream -> encoder . err = 1 ;ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\\# endif # else stream -> encoder . err = 1 ;ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\\# endif }}# endif if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) {if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) {fprintf ( stderr , ""%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>8bpp<S2SV_blank>inputs\\\exit ( EXIT_FAILURE ) ;}# if CONFIG_LIBYUV if ( ! stream -> img ) stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , cfg -> g_w , cfg -> g_h , 16 ) ;img = stream -> img ;}",2079
1818,if ( params -> buffer . fragment_size == 0 ||  params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size )  return - EINVAL ;,if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > INT_MAX / params -> buffer . fragment_size ) return - EINVAL ;,2080
1819,dev -> netdev_ops = & l2tp_eth_netdev_ops ;dev -> destructor = free_netdev ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & l2tp_eth_netdev_ops ;dev -> destructor = free_netdev ;,2081
1820,"int ret , wo ;if ( 1 + wlen > MAX_XFER_SIZE ) {wo = ( rbuf == NULL || rlen == 0 ) ;mutex_lock ( & d -> data_mutex ) ;if ( wo )  ret = dvb_usb_generic_write ( d , st -> data , 1 + wlen ) ;else ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen ,  rbuf , rlen , 0 ) ;mutex_unlock ( & d -> data_mutex ) ;","int ret ;if ( 1 + wlen > MAX_XFER_SIZE ) {if ( rlen > MAX_XFER_SIZE ) {warn ( ""i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\\return - EOPNOTSUPP ;}mutex_lock ( & d -> data_mutex ) ;ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen , rbuf , rlen , 0 ) ;if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen ) ;mutex_unlock ( & d -> data_mutex ) ;",2082
1821,"
","if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;",2083
1822,"return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ;}","return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ;}",2083
1823,"cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>fixed\\\p [ 8 ] = \'=\' ;if ( * p )  cli_dbgmsg ( ""messageAddArgument,<S2SV_blank>\\\'%s\\\'<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>\\\'=\\\'\\\","if ( strlen ( p ) > 8 ) {cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>fixed\\\p [ 8 ] = \'=\' ;cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>not<S2SV_blank>fixed\\\}}else {if ( * p ) cli_dbgmsg ( ""messageAddArgument,<S2SV_blank>\\\'%s\\\'<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>\\\'=\\\'\\\",2084
1824,"if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ;if ( NULL == siocb -> scm ) siocb -> scm = & scm ;err = scm_send ( sock , msg , siocb -> scm , true ) ;if ( err < 0 ) return err ;if ( msg -> msg_namelen ) {err = - EINVAL ;if ( addr -> nl_family != AF_NETLINK ) goto out ;dst_pid = addr -> nl_pid ;dst_group = ffs ( addr -> nl_groups ) ;err = - EPERM ;if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) )  goto out ;","if ( ( dst_group || dst_pid ) && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) goto out ;",2085
1825,"err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( err < 0 ) return err ;","err = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( err < 0 ) return err ;",2086
1826,"* ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data ,  cmd -> vsize , cmd -> data + sizeof ( int32_t ) ) ;","if ( cmd -> psize != sizeof ( int32_t ) ) {android_errorWriteLog ( 0x534e4554 , ""63662938"" ) ;return - EINVAL ;}* ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data , cmd -> vsize , cmd -> data + sizeof ( int32_t ) ) ;",2087
1827,"static void choose_intra_uv_mode ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx ,  BLOCK_SIZE bsize , TX_SIZE max_tx_size , int * rate_uv , int * rate_uv_tokenonly , int64_t * dist_uv , int * skip_uv ,  MB_PREDICTION_MODE * mode_uv ) {MACROBLOCK * const x = & cpi -> mb ;if ( cpi -> sf . use_uv_intra_rd_estimate ) {","static void choose_intra_uv_mode ( VP9_COMP * cpi , MACROBLOCK * const x , PICK_MODE_CONTEXT * ctx , BLOCK_SIZE bsize , TX_SIZE max_tx_size , int * rate_uv , int * rate_uv_tokenonly , int64_t * dist_uv , int * skip_uv , PREDICTION_MODE * mode_uv ) {MACROBLOCK * const x = & cpi -> mb ;if ( cpi -> sf . use_uv_intra_rd_estimate ) {",2088
1828,"void nfs4_close_state ( struct path * path , struct nfs4_state * state , mode_t mode )  {__nfs4_close ( path , state , mode , 0 ) ;}","void nfs4_close_state ( struct path * path , struct nfs4_state * state , fmode_t fmode ) {__nfs4_close ( path , state , fmode , 0 ) ;}",2089
1829,"return mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ;}","struct dentry * root = mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ;if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ;return root ;}",2090
1830,"static void cpStripToTile ( uint8 * out , uint8 * in ,  uint32 rows , uint32 cols , int outskew , int inskew )  {","static void cpStripToTile ( uint8 * out , uint8 * in , uint32 rows , uint32 cols , int outskew , int64 inskew ) {",2091
1831,"memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;}","s -> append_char ( s , 0 ) ;strncpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;}",2092
1832,if ( ! chan ) {err = - EINVAL ;goto out_free ;}if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ;request -> channels [ i ] = chan ;,request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;,2093
1833,if ( request -> ssids [ i ] . ssid_len >  IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;,if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;,2093
1834,"fc = EXTRACT_LE_16BITS ( p ) ;seq = EXTRACT_LE_8BITS ( p + 2 ) ;p += 3 ;caplen -= 3 ;ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ;if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ;switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) {case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;break ;case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;return hdrlen ;case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}panid = EXTRACT_LE_16BITS ( p ) ;if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag )  ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ;p += 2 ;caplen -= 2 ;hdrlen += 2 ;",fc = EXTRACT_LE_16BITS ( p ) ) ) ;,2094
1835,o4 = o * sizeof ( uint32_t ) ;},if ( q + o >= e ) goto out ;o4 = o * sizeof ( uint32_t ) ;},2095
1836,for ( plane = 0 ;uint8_t * ptr ;const int w = ( plane ? ( 1 + yuv_frame -> d_w ) / 2 : yuv_frame -> d_w ) ;const int h = ( plane ? ( 1 + yuv_frame -> d_h ) / 2 : yuv_frame -> d_h ) ;int r ;,"const int bytespp = ( yuv_frame -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ;for ( plane = 0 ;uint8_t * ptr ;const int w = vpx_img_plane_width ( yuv_frame , plane ) ;const int h = ( plane ? ( 1 + yuv_frame -> d_h ) / 2 : yuv_frame -> d_h ) ;int r ;",2096
1837,size_t needed = w ;size_t buf_position = 0 ;,size_t needed = w * bytespp ;size_t buf_position = 0 ;,2096
1838,"struct keydata * keyptr ;__u32 * hash = get_cpu_var ( get_random_int_hash ) ;int ret ;keyptr = get_keyptr ( ) ;hash [ 0 ] += current -> pid + jiffies + get_cycles ( ) ;ret = half_md4_transform ( hash , keyptr -> secret ) ;put_cpu_var ( get_random_int_hash ) ;","__u32 * hash = get_cpu_var ( get_random_int_hash ) ;int ret ;keyptr = get_keyptr ( ) ;md5_transform ( hash , keyptr -> secret ) ;put_cpu_var ( get_random_int_hash ) ;",2097
1839,"CallInfo * ci = next_ci ( L ) ;checkstackp ( L , LUA_MINSTACK , func ) ;ci -> func = func ;L -> ci = ci ;","CallInfo * ci ;checkstackGCp ( L , LUA_MINSTACK , func ) ;L -> ci = ci = next_ci ( L ) ;ci -> func = func ;",2098
1840,"CallInfo * ci = next_ci ( L ) ;Proto * p = clLvalue ( s2v ( func ) ) -> p ;checkstackp ( L , fsize , func ) ;ci -> nresults = nresults ;","CallInfo * ci ;Proto * p = clLvalue ( s2v ( func ) ) -> p ;checkstackGCp ( L , fsize , func ) ;L -> ci = ci = next_ci ( L ) ;ci -> nresults = nresults ;",2098
1841,"checkstackp ( L , 1 , func ) ;luaD_tryfuncTM ( L , func ) ;","checkstackGCp ( L , 1 , func ) ;luaD_tryfuncTM ( L , func ) ;",2098
1842,"ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ;ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ;return ;}","cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ;cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ;}",2099
1843,kfree ( umidi ) ;,"
",2100
1844,snd_usbmidi_free ( umidi ) ;return err ;,snd_usbmidi_free ( umidi ) ;return err ;,2100
1845,"ND_PRINT ( ( ndo , ""<S2SV_blank>who-are-you<S2SV_blank>request"" ) ) ;","ND_PRINT ( ( ndo , ""%s"" , icmp6_tstr ) ) ;",2101
1846,"trunc :  ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;}","trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;}",2101
1847,"if ( ret == 0 )  clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ;up_write ( & key -> sem ) ;","if ( ret == 0 ) mark_key_instantiated ( key , 0 ) ;up_write ( & key -> sem ) ;",2102
1848,"sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ;","sigev_none = timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ;",2103
1849,"if ( server . syslog_enabled ) {openlog ( server . syslog_ident , LOG_PID | LOG_NDELAY | LOG_NOWAIT , server . syslog_facility ) ;}server . mainthread = pthread_self ( ) ;server . clients = listCreate ( ) ;server . slaves = listCreate ( ) ;server . monitors = listCreate ( ) ;server . unblocked_clients = listCreate ( ) ;createSharedObjects ( ) ;server . el = aeCreateEventLoop ( ) ;server . db = zmalloc ( sizeof ( redisDb ) * server . dbnum ) ;server . ipfd = anetTcpServer ( server . neterr , server . port , server . bindaddr ) ;if ( server . ipfd == ANET_ERR ) {redisLog ( REDIS_WARNING , ""Opening<S2SV_blank>port:<S2SV_blank>%s"" , server . neterr ) ;exit ( 1 ) ;}if ( server . unixsocket != NULL ) {unlink ( server . unixsocket ) ;server . sofd = anetUnixServer ( server . neterr , server . unixsocket ) ;if ( server . sofd == ANET_ERR ) {redisLog ( REDIS_WARNING , ""Opening<S2SV_blank>socket:<S2SV_blank>%s"" , server . neterr ) ;exit ( 1 ) ;}}if ( server . ipfd < 0 && server . sofd < 0 ) {redisLog ( REDIS_WARNING , ""Configured<S2SV_blank>to<S2SV_blank>not<S2SV_blank>listen<S2SV_blank>anywhere,<S2SV_blank>exiting."" ) ;exit ( 1 ) ;}for ( j = 0 ;j < server . dbnum ;j ++ ) {server . db [ j ] . dict = dictCreate ( & dbDictType , NULL ) ;server . db [ j ] . expires = dictCreate ( & keyptrDictType , NULL ) ;server . db [ j ] . blocking_keys = dictCreate ( & keylistDictType , NULL ) ;server . db [ j ] . watched_keys = dictCreate ( & keylistDictType , NULL ) ;if ( server . vm_enabled )  server . db [ j ] . io_keys = dictCreate ( & keylistDictType , NULL ) ;","if ( server . ds_enabled ) server . db [ j ] . io_keys = dictCreate ( & keylistDictType , NULL ) ;",2104
1850,if ( server . vm_enabled ) vmInit ( ) ;},if ( server . vm_enabled ) vmInit ( ) ;},2104
1851,"<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a.{1,2}b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>6<S2SV_blank>}"" , ""a\\\\0x\\\\0b\\\\0"" ) ;assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a.{1,2}b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>8<S2SV_blank>}"" , ""a\\\\0x\\\\0x\\\\0b\\\\0"" ) ;assert_regexp_syntax_error ( "")"" ) ;assert_true_regexp ( ""abc"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""abc"" , ""xbc"" ) ;assert_false_regexp ( ""abc"" , ""axc"" ) ;assert_false_regexp ( ""abc"" , ""abx"" ) ;assert_true_regexp ( ""abc"" , ""xabcx"" , ""abc"" ) ;assert_true_regexp ( ""abc"" , ""ababc"" , ""abc"" ) ;assert_true_regexp ( ""a.c"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""a.b"" , ""a\\\assert_false_regexp ( ""a.*b"" , ""acc\\\assert_false_regexp ( ""a.{4,5}b"" , ""acc\\\assert_true_regexp ( ""a.b"" , ""a\\\\rb"" , ""a\\\\rb"" ) ;assert_true_regexp ( ""ab*c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab*c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""ab*bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab*bc"" , ""abbc"" , ""abbc"" ) ;assert_true_regexp ( ""a.*bb"" , ""abbbb"" , ""abbbb"" ) ;assert_true_regexp ( ""a.*?bbb"" , ""abbbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""a.*c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""a.*c"" , ""axyzc"" , ""axyzc"" ) ;assert_true_regexp ( ""ab+c"" , ""abbc"" , ""abbc"" ) ;assert_false_regexp ( ""ab+c"" , ""ac"" ) ;assert_true_regexp ( ""ab+"" , ""abbbb"" , ""abbbb"" ) ;assert_true_regexp ( ""ab+?"" , ""abbbb"" , ""ab"" ) ;assert_false_regexp ( ""ab+bc"" , ""abc"" ) ;assert_false_regexp ( ""ab+bc"" , ""abq"" ) ;assert_true_regexp ( ""a+b+c"" , ""aabbabc"" , ""abc"" ) ;assert_false_regexp ( ""ab?bc"" , ""abbbbc"" ) ;assert_true_regexp ( ""ab?c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab*?"" , ""abbb"" , ""a"" ) ;assert_true_regexp ( ""ab?c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""ab??"" , ""ab"" , ""a"" ) ;assert_true_regexp ( ""a(b|x)c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a(b|x)c"" , ""axc"" , ""axc"" ) ;assert_true_regexp ( ""a(b|.)c"" , ""axc"" , ""axc"" ) ;assert_true_regexp ( ""a(b|x|y)c"" , ""ayc"" , ""ayc"" ) ;assert_true_regexp ( ""(a+|b)*"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a|b|c|d|e"" , ""e"" , ""e"" ) ;assert_true_regexp ( ""(a|b|c|d|e)f"" , ""ef"" , ""ef"" ) ;assert_true_regexp ( "".b{2}"" , ""abb"" , ""abb"" ) ;assert_true_regexp ( "".b{2,3}"" , ""abbb"" , ""abbb"" ) ;assert_true_regexp ( "".b{2,3}?"" , ""abbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{2,3}c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{2,3}?c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( "".b{2,3}cccc"" , ""abbbcccc"" , ""abbbcccc"" ) ;assert_true_regexp ( "".b{2,3}?cccc"" , ""abbbcccc"" , ""bbbcccc"" ) ;assert_true_regexp ( ""a.b{2,3}cccc"" , ""aabbbcccc"" , ""aabbbcccc"" ) ;assert_true_regexp ( ""ab{2,3}c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{2,3}?c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{0,1}?c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a{0,1}?bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a{0,1}bc"" , ""bbc"" , ""bc"" ) ;assert_true_regexp ( ""a{0,1}?bc"" , ""abc"" , ""bc"" ) ;assert_true_regexp ( ""aa{0,1}?bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""aa{0,1}?bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""aa{0,1}bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab{1}c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab{1,2}c"" , ""abbc"" , ""abbc"" ) ;assert_true_regexp ( ""ab{1,}c"" , ""abbbc"" , ""abbbc"" ) ;assert_false_regexp ( ""ab{1,}b"" , ""ab"" ) ;assert_false_regexp ( ""ab{1}c"" , ""abbc"" ) ;assert_true_regexp ( ""ab{0,}c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""ab{1,1}c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab{0,}c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{,3}c"" , ""abbbc"" , ""abbbc"" ) ;assert_false_regexp ( ""ab{,2}c"" , ""abbbc"" ) ;assert_false_regexp ( ""ab{4,5}bc"" , ""abbbbc"" ) ;assert_true_regexp ( ""ab{0,1}"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{0,2}"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{0,3}"" , ""abbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""ab{0,4}"" , ""abbbbb"" , ""abbbb"" ) ;assert_true_regexp ( ""ab{1,1}"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{1,2}"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{1,3}"" , ""abbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""ab{2,2}"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{2,3}"" , ""abbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""ab{1,3}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{0,1}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{0,2}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{0,3}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{0,4}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{1,1}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{1,2}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{1,3}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{2,2}?"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{2,3}?"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( "".(abc){0,1}"" , ""xabcabcabcabc"" , ""xabc"" ) ;assert_true_regexp ( "".(abc){0,2}"" , ""xabcabcabcabc"" , ""xabcabc"" ) ;assert_true_regexp ( ""x{1,2}abcd"" , ""xxxxabcd"" , ""xxabcd"" ) ;assert_true_regexp ( ""x{1,2}abcd"" , ""xxxxabcd"" , ""xxabcd"" ) ;assert_true_regexp ( ""ab{.*}"" , ""ab{c}"" , ""ab{c}"" ) ;assert_true_regexp ( "".(aa){1,2}"" , ""aaaaaaaaaa"" , ""aaaaa"" ) ;assert_true_regexp ( ""a.(bc.){2}"" , ""aabcabca"" , ""aabcabca"" ) ;assert_true_regexp ( ""(ab{1,2}c){1,3}"" , ""abbcabc"" , ""abbcabc"" ) ;assert_true_regexp ( ""ab(c|cc){1,3}d"" , ""abccccccd"" , ""abccccccd"" ) ;assert_true_regexp ( ""a[bx]c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a[bx]c"" , ""axc"" , ""axc"" ) ;assert_true_regexp ( ""a[0-9]*b"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a[0-9]*b"" , ""a0123456789b"" , ""a0123456789b"" ) ;assert_true_regexp ( ""[0-9a-f]+"" , ""0123456789abcdef"" , ""0123456789abcdef"" ) ;assert_true_regexp ( ""[0-9a-f]+"" , ""xyz0123456789xyz"" , ""0123456789"" ) ;assert_true_regexp ( ""a[\\\\\\\\s\\\\\\\\S]b"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ;assert_true_regexp ( ""a[\\\\\\\\d\\\\\\\\D]b"" , ""a1b"" , ""a1b"" ) ;assert_false_regexp ( ""[x-z]+"" , ""abc"" ) ;assert_true_regexp ( ""a[-]?c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""a[-b]"" , ""a-"" , ""a-"" ) ;assert_true_regexp ( ""a[-b]"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a[b-]"" , ""a-"" , ""a-"" ) ;assert_true_regexp ( ""a[b-]"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""[a-c-e]"" , ""b"" , ""b"" ) ;assert_true_regexp ( ""[a-c-e]"" , ""-"" , ""-"" ) ;assert_false_regexp ( ""[a-c-e]"" , ""d"" ) ;assert_regexp_syntax_error ( ""[b-a]"" ) ;assert_regexp_syntax_error ( ""(abc"" ) ;assert_regexp_syntax_error ( ""abc)"" ) ;assert_regexp_syntax_error ( ""a[]b"" ) ;assert_true_regexp ( ""a[\\\\\\\\-b]"" , ""a-"" , ""a-"" ) ;assert_true_regexp ( ""a[\\\\\\\\-b]"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a]"" , ""a]"" , ""a]"" ) ;assert_true_regexp ( ""a[]]b"" , ""a]b"" , ""a]b"" ) ;assert_true_regexp ( ""a[\\\\\\\\]]b"" , ""a]b"" , ""a]b"" ) ;assert_true_regexp ( ""a[^bc]d"" , ""aed"" , ""aed"" ) ;assert_false_regexp ( ""a[^bc]d"" , ""abd"" ) ;assert_true_regexp ( ""a[^-b]c"" , ""adc"" , ""adc"" ) ;assert_false_regexp ( ""a[^-b]c"" , ""a-c"" ) ;assert_false_regexp ( ""a[^]b]c"" , ""a]c"" ) ;assert_true_regexp ( ""a[^]b]c"" , ""adc"" , ""adc"" ) ;assert_true_regexp ( ""[^ab]*"" , ""cde"" , ""cde"" ) ;assert_regexp_syntax_error ( "")("" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\tb"" , ""a\\\\tb"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\rb"" , ""a\\\\rb"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\vb"" , ""a\\\\vb"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\fb"" , ""a\\\\fb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a<S2SV_blank>b"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\tb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\rb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\vb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\fb"" ) ;assert_true_regexp ( ""\\\\\\\assert_true_regexp ( ""[\\\\\\\assert_true_regexp ( ""\\\\\\\\x01\\\\\\\\x02\\\\\\\\x03"" , ""\\\\x01\\\\x02\\\\x03"" , ""\\\\x01\\\\x02\\\\x03"" ) ;assert_true_regexp ( ""[\\\\\\\\x01-\\\\\\\\x03]+"" , ""\\\\x01\\\\x02\\\\x03"" , ""\\\\x01\\\\x02\\\\x03"" ) ;assert_false_regexp ( ""[\\\\\\\\x00-\\\\\\\\x02]+"" , ""\\\\x03\\\\x04\\\\x05"" ) ;assert_true_regexp ( ""[\\\\\\\\x5D]"" , ""]"" , ""]"" ) ;assert_true_regexp ( ""[\\\\\\\\0x5A-\\\\\\\\x5D]"" , ""\\\\x5B"" , ""\\\\x5B"" ) ;assert_true_regexp ( ""[\\\\\\\\x5D-\\\\\\\\x5F]"" , ""\\\\x5E"" , ""\\\\x5E"" ) ;assert_true_regexp ( ""[\\\\\\\\x5C-\\\\\\\\x5F]"" , ""\\\\x5E"" , ""\\\\x5E"" ) ;assert_true_regexp ( ""[\\\\\\\\x5D-\\\\\\\\x5F]"" , ""\\\\x5E"" , ""\\\\x5E"" ) ;assert_true_regexp ( ""a\\\\\\\\wc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a\\\\\\\\wc"" , ""a_c"" , ""a_c"" ) ;assert_true_regexp ( ""a\\\\\\\\wc"" , ""a0c"" , ""a0c"" ) ;assert_false_regexp ( ""a\\\\\\\\wc"" , ""a*c"" ) ;assert_true_regexp ( ""\\\\\\\\w+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ;assert_true_regexp ( ""[\\\\\\\\w]+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ;assert_true_regexp ( ""\\\\\\\\D+"" , ""1234abc5678"" , ""abc"" ) ;assert_true_regexp ( ""[\\\\\\\\d]+"" , ""0123456789"" , ""0123456789"" ) ;assert_true_regexp ( ""[\\\\\\\\D]+"" , ""1234abc5678"" , ""abc"" ) ;assert_true_regexp ( ""[\\\\\\\\da-fA-F]+"" , ""123abc"" , ""123abc"" ) ;assert_false_regexp ( ""^(ab|cd)e"" , ""abcde"" ) ;assert_true_regexp ( ""(abc|)ef"" , ""abcdef"" , ""ef"" ) ;assert_true_regexp ( ""(abc|)ef"" , ""abcef"" , ""abcef"" ) ;assert_true_regexp ( ""\\\\\\\\babc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""abc\\\\\\\\b"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""\\\\\\\\babc"" , ""1abc"" ) ;assert_false_regexp ( ""abc\\\\\\\\b"" , ""abc1"" ) ;assert_true_regexp ( ""abc\\\\\\\\s\\\\\\\\b"" , ""abc<S2SV_blank>x"" , ""abc<S2SV_blank>"" ) ;assert_false_regexp ( ""abc\\\\\\\\s\\\\\\\\b"" , ""abc<S2SV_blank><S2SV_blank>"" ) ;assert_true_regexp ( ""\\\\\\\\babc\\\\\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\b\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\b"" , ""abcd"" , ""bcd"" ) ;assert_true_regexp ( ""\\\\\\\\b\\\\\\\\w\\\\\\\\w\\\\\\\\w"" , ""abcd"" , ""abc"" ) ;assert_false_regexp ( ""\\\\\\\\b\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\b"" , ""abcd"" ) ;assert_false_regexp ( ""\\\\\\\\Babc"" , ""abc"" ) ;assert_false_regexp ( ""abc\\\\\\\\B"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\Babc"" , ""1abc"" , ""abc"" ) ;assert_true_regexp ( ""abc\\\\\\\\B"" , ""abc1"" , ""abc"" ) ;assert_false_regexp ( ""abc\\\\\\\\s\\\\\\\\B"" , ""abc<S2SV_blank>x"" ) ;assert_true_regexp ( ""abc\\\\\\\\s\\\\\\\\B"" , ""abc<S2SV_blank><S2SV_blank>"" , ""abc<S2SV_blank>"" ) ;assert_true_regexp ( ""\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\B"" , ""abcd"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\B\\\\\\\\w\\\\\\\\w\\\\\\\\w"" , ""abcd"" , ""bcd"" ) ;assert_false_regexp ( ""\\\\\\\\B\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\B"" , ""abcd"" ) ;assert_regexp_syntax_error ( ""(|abc)ef"" ) ;assert_true_regexp ( ""((a)(b)c)(d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""(a|b)c*d"" , ""abcd"" , ""bcd"" ) ;assert_true_regexp ( ""(ab|ab*)bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a([bc]*)c*"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a([bc]*)c*"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""a([bc]*)c*"" , ""a"" , ""a"" ) ;assert_true_regexp ( ""a([bc]*)(c*d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""a([bc]+)(c*d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""a([bc]*)(c+d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""a[bcd]*dcdcde"" , ""adcdcde"" , ""adcdcde"" ) ;assert_false_regexp ( ""a[bcd]+dcdcde"" , ""adcdcde"" ) ;assert_true_regexp ( ""\\\\\\\\((.*),<S2SV_blank>(.*)\\\\\\\\)"" , ""(a,<S2SV_blank>b)"" , ""(a,<S2SV_blank>b)"" ) ;assert_true_regexp ( ""abc|123$"" , ""abcx"" , ""abc"" ) ;assert_false_regexp ( ""abc|123$"" , ""123x"" ) ;assert_true_regexp ( ""abc|^123"" , ""123"" , ""123"" ) ;assert_false_regexp ( ""abc|^123"" , ""x123"" ) ;assert_true_regexp ( ""^abc$"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""^abc$"" , ""abcc"" ) ;assert_true_regexp ( ""^abc"" , ""abcc"" , ""abc"" ) ;assert_false_regexp ( ""^abc$"" , ""aabc"" ) ;assert_false_regexp ( ""abc^"" , ""abc"" ) ;assert_false_regexp ( ""ab^c"" , ""abc"" ) ;assert_false_regexp ( ""a^bcdef"" , ""abcdef"" ) assert_true_regexp ( ""abc$"" , ""aabc"" , ""abc"" ) ;assert_false_regexp ( ""$abc"" , ""abc"" ) ;assert_true_regexp ( ""(a|a$)bcd"" , ""abcd"" , ""abcd"" ) ;assert_false_regexp ( ""(a$|a$)bcd"" , ""abcd"" ) ;assert_false_regexp ( ""(abc$|ab$)"" , ""abcd"" ) ;assert_true_regexp ( ""^a(bc+|b[eh])g|.h$"" , ""abhg"" , ""abhg"" ) ;assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effgz"" , ""effgz"" ) ;assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""ij"" , ""ij"" ) ;assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effg"" ) ;assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""bcdd"" ) ;assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""reffgz"" , ""effgz"" ) ;assert_true_regexp ( ""whatever|<S2SV_blank><S2SV_blank><S2SV_blank>x.<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x0"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x"" ) ;assert_regexp_syntax_error ( ""x{0,0}"" ) ;assert_regexp_syntax_error ( ""x{0}"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\xxy"" ) ;assert_error ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a\\\\\\\\/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ERROR_SYNTAX_ERROR ) ;assert_error ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/[a\\\\\\\\/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ERROR_SYNTAX_ERROR ) ;assert_true_rule_blob (  ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\\\t/<S2SV_blank>\\\\\"" ,  PE32_FILE ) ;assert_true_rule_blob (  ""rule<S2SV_blank>test<S2SV_blank>{"" ,  PE32_FILE ) ;","<S2SV_blank>\\\\\t/<S2SV_blank>\\\\\"" , PE32_FILE ) ;assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{"" , PE32_FILE ) ;",2105
1852,struct tcp_sock_t * tcp_socket ;while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL &&   g_options . only_desired_port == 0 ) {desired_port ++ ;}if ( tcp_socket == NULL ) goto cleanup_tcp ;uint16_t real_port = tcp_port_number_get ( tcp_socket ) ;if ( desired_port != 0 && g_options . only_desired_port == 1 && desired_port != real_port ) {uint16_t pid ;if ( ! g_options . nofork_mode && ( pid = fork ( ) ) > 0 ) {,"struct tcp_sock_t * tcp_socket = NULL , * tcp6_socket = NULL ;for ( ;;) {tcp_socket = tcp_open ( desired_port ) ;tcp6_socket = tcp6_open ( desired_port ) ;if ( tcp_socket || tcp6_socket || g_options . only_desired_port ) break ;desired_port ++ ;NOTE ( ""Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d"" , desired_port ) ;}if ( tcp_socket == NULL && tcp6_socket == NULL ) goto cleanup_tcp ;uint16_t real_port ;if ( tcp_socket ) real_port = tcp_port_number_get ( tcp_socket ) ;else real_port = tcp_port_number_get ( tcp6_socket ) ;if ( desired_port != 0 && g_options . only_desired_port == 1 && desired_port != real_port ) {NOTE ( ""Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable"" , real_port , tcp_socket ? """" : ""not<S2SV_blank>"" , tcp6_socket ? """" : ""not<S2SV_blank>"" ) ;uint16_t pid ;if ( ! g_options . nofork_mode && ( pid = fork ( ) ) > 0 ) {",2106
1853,args -> tcp = tcp_conn_accept ( tcp_socket ) ;if ( args -> tcp == NULL ) {,"args -> tcp = tcp_conn_select ( tcp_socket , tcp6_socket ) ;if ( args -> tcp == NULL ) {",2106
1854,cleanup_usb :  if ( usb_sock != NULL ) usb_close ( usb_sock ) ;,if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ;cleanup_usb : if ( usb_sock != NULL ) usb_close ( usb_sock ) ;,2106
1855,"file_sb_list_add ( f , inode -> i_sb ) ;if ( unlikely ( f -> f_mode & FMODE_PATH ) ) {",if ( unlikely ( f -> f_mode & FMODE_PATH ) ) {,2107
1856,file_sb_list_del ( f ) ;if ( f -> f_mode & FMODE_WRITE ) {,if ( f -> f_mode & FMODE_WRITE ) {,2107
1857,if ( * off >= skb -> len ) {* off -= skb -> len ;,if ( * off >= skb -> len && skb -> len ) {* off -= skb -> len ;,2108
1858,"if ( len < 6 ) goto invalid ;nonce = EXTRACT_16BITS ( message + 4 ) ;interval = EXTRACT_16BITS ( message + 6 ) ;ND_PRINT ( ( ndo , ""%04x<S2SV_blank>%s"" , nonce , format_interval ( interval ) ) ) ;}}break ;case MESSAGE_ACK : {u_short nonce ;if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ack"" ) ) ;","if ( len < 10 ) ND_PRINT ( ( ndo , ""<S2SV_blank>ack"" ) ) ;",2109
1859,"if ( len < 1 )  ND_PRINT ( ( ndo , ""/truncated"" ) ) ;","if ( len < 1 ) ND_PRINT ( ( ndo , ""/truncated"" ) ) ;",2109
1860,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  return - ENOKEY ;",if ( key_is_negative ( key ) ) return - ENOKEY ;,2110
1861,"if ( add_to_page_cache_lru ( page , mapping ,  page -> index ,  readahead_gfp_mask ( mapping ) ) ) goto next_page ;","if ( add_to_page_cache_lru ( page , mapping , page_index ( page ) , readahead_gfp_mask ( mapping ) ) ) goto next_page ;",2111
1862,},unlink ( RUN_LIB_FILE ) ;},2112
1863,if ( atomic_read ( & current -> mm -> mm_users ) > 1 )  return - EINVAL ;,if ( atomic_read ( & current -> mm -> mm_users ) > 1 ) return - EINVAL ;if ( current -> fs -> users != 1 ) return - EINVAL ;,2113
1864,if ( ! capable ( CAP_SYS_ADMIN ) ) {,if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( ! capable ( CAP_SYS_ADMIN ) ) {,2114
1865,if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) {rcode = - EINVAL ;,if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) ) {rcode = - EINVAL ;,2114
1866,"mpz_t numer , denom , lambda ;mpz_inits ( numer , denom , lambda , NULL ) ;","if ( pointZZ_pIsIdentityElement ( op ) ) {return pointZZ_pSetToIdentityElement ( rop ) ;}mpz_t numer , denom , lambda ;mpz_inits ( numer , denom , lambda , NULL ) ;",2115
1867,"vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;","memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;",2116
1868,"void * H264SwDecMalloc ( u32 size )  {numBytes += size ;DEBUG ( ( ""Allocated<S2SV_blank>%d<S2SV_blank>bytes,<S2SV_blank>total<S2SV_blank>%d\\\# endif  return malloc ( size ) ;}","void * H264SwDecMalloc ( u32 size , u32 num ) {if ( size > UINT32_MAX / num ) {return NULL ;}numBytes += size * num ;DEBUG ( ( ""Allocated<S2SV_blank>%d<S2SV_blank>bytes,<S2SV_blank>total<S2SV_blank>%d\\\# endif return malloc ( size * num ) ;}",2117
1869,bufp += bytes_read ;},bufp += stripsize ;},2118
1870,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( pool ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,2119
1871,"if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) &&  ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {","if ( ( creds -> pid == task_tgid_vnr ( current ) || ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {",2120
1872,coerce_reg_to_32 ( dst_reg ) ;coerce_reg_to_32 ( & src_reg ) ;},"coerce_reg_to_size ( dst_reg , 4 ) ;coerce_reg_to_size ( & src_reg , 4 ) ;}",2121
1873,"if ( key_is_instantiated ( key ) )  seq_printf ( m , ""<S2SV_blank>pid:%d<S2SV_blank>ci:%zu"" , rka -> pid , rka -> callout_len ) ;","if ( key_is_positive ( key ) ) seq_printf ( m , ""<S2SV_blank>pid:%d<S2SV_blank>ci:%zu"" , rka -> pid , rka -> callout_len ) ;",2122
1874,kfree ( tu -> queue ) ;tu -> queue = NULL ;,tu -> qhead = tu -> qtail = tu -> qused = 0 ;kfree ( tu -> queue ) ;tu -> queue = NULL ;,2123
1875,"if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) {EXT4_ERROR_INODE ( inode , ""p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!"" ) ;","size_t ext_size = 0 ;if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) {EXT4_ERROR_INODE ( inode , ""p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!"" ) ;ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ;memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ;memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;",2124
1876,"ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;","ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;",2124
1877,"ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;","ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;",2124
1878,"if ( ret ) {dma_free_coherent ( trans -> dev , sizeof ( * prph_scratch ) , prph_scratch , trans_pcie -> prph_scratch_dma_addr ) ;return ret ;}if ( ! prph_info )  return - ENOMEM ;ctxt_info_gen3 = dma_alloc_coherent ( trans -> dev ,  sizeof ( * ctxt_info_gen3 ) , & trans_pcie -> ctxt_info_dma_addr , GFP_KERNEL ) ;if ( ! ctxt_info_gen3 ) return - ENOMEM ;ctxt_info_gen3 -> prph_info_base_addr = cpu_to_le64 ( trans_pcie -> prph_info_dma_addr ) ;ctxt_info_gen3 -> prph_scratch_base_addr = cpu_to_le64 ( trans_pcie -> prph_scratch_dma_addr ) ;ctxt_info_gen3 -> prph_scratch_size = cpu_to_le32 ( sizeof ( * prph_scratch ) ) ;ctxt_info_gen3 -> cr_head_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> rb_stts_dma ) ;ctxt_info_gen3 -> tr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> tr_tail_dma ) ;ctxt_info_gen3 -> cr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> cr_tail_dma ) ;ctxt_info_gen3 -> cr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_COMPLETION_RINGS ) ;ctxt_info_gen3 -> tr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_TRANSFER_RINGS ) ;ctxt_info_gen3 -> mtr_base_addr = cpu_to_le64 ( trans_pcie -> txq [ trans_pcie -> cmd_queue ] -> dma_addr ) ;ctxt_info_gen3 -> mcr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> used_bd_dma ) ;ctxt_info_gen3 -> mtr_size = cpu_to_le16 ( TFD_QUEUE_CB_SIZE ( cmdq_size ) ) ;ctxt_info_gen3 -> mcr_size = cpu_to_le16 ( RX_QUEUE_CB_SIZE ( MQ_RX_TABLE_SIZE ) ) ;trans_pcie -> ctxt_info_gen3 = ctxt_info_gen3 ;trans_pcie -> prph_info = prph_info ;trans_pcie -> prph_scratch = prph_scratch ;iml_img = dma_alloc_coherent ( trans -> dev , trans -> iml_len , & trans_pcie -> iml_dma_addr , GFP_KERNEL ) ;if ( ! iml_img ) return - ENOMEM ;",if ( ret ) goto err_free_prph_scratch ;if ( ! prph_info ) {ret = - ENOMEM ;,2125
1879,},"err_free_prph_info : dma_free_coherent ( trans -> dev , sizeof ( * prph_info ) , prph_info , trans_pcie -> prph_info_dma_addr ) ;err_free_prph_scratch : dma_free_coherent ( trans -> dev , sizeof ( * prph_scratch ) , prph_scratch , trans_pcie -> prph_scratch_dma_addr ) ;return ret ;}",2125
1880,"if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>seperation\\\","if ( ! s -> cdx [ i ] || s -> cdx [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>seperation\\\",2126
1881,"err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 ,  & msg -> addrto , & msg -> ifindex ) ;if ( err ) {err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message"" ) ;goto free_msg ;}dbg ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u"" ,   str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ;if ( len < sizeof ( * msg -> icmp6_hdr ) ) {","err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 , & msg -> addrto , & msg -> ifindex , & msg -> hoplimit ) ;if ( err ) {err ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d"" , str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ;if ( len < sizeof ( * msg -> icmp6_hdr ) ) {",2127
1882,"memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , bs - sizeof ( struct extendedFileEntry ) ) ;","memcpy ( iinfo -> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ;if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ;if ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , bs - sizeof ( struct extendedFileEntry ) ) ;",2128
1883,if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) {if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ;,if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) {if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ;,2128
1884,"}if ( rctx -> topdown ) {iw_set_error ( rctx -> ctx , ""Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images"" ) ;}","goto done ;}if ( rctx -> topdown ) {iw_set_error ( rctx -> ctx , ""Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images"" ) ;goto done ;}",2129
1885,"vp9_copy ( cm -> fc . coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ;vp9_copy ( cm -> fc . coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ;vp9_copy ( cm -> fc . coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ;vp9_copy ( cm -> fc . coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ;}","vp9_copy ( cm -> fc -> coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ;vp9_copy ( cm -> fc -> coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ;vp9_copy ( cm -> fc -> coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ;vp9_copy ( cm -> fc -> coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ;}",2130
1886,"xmlNode * op_msg = NULL ;xmlNode * op_reply = NULL ;if ( sync_timer == NULL ) {sync_timer = calloc ( 1 , sizeof ( struct timer_rec_s ) ) ;}",int disconnected = 0 ;int remaining_time = 0 ;time_t start_time ;xmlNode * op_msg = NULL ;xmlNode * op_reply = NULL ;,2131
1887,"crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ;free_xml ( op_msg ) ;","if ( ! ( call_options & cib_sync_call ) ) {crm_send_remote_msg ( private -> callback . session , op_msg , private -> command . encrypted ) ;}}else {crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ;free_xml ( op_msg ) ;",2131
1888,"if ( cib -> call_timeout > 0 ) {timer_expired = FALSE ;sync_timer -> call_id = cib -> call_id ;sync_timer -> timeout = cib -> call_timeout * 1000 ;sync_timer -> ref = g_timeout_add ( sync_timer -> timeout , cib_timeout_handler , sync_timer ) ;}while ( timer_expired == FALSE ) {op_reply = crm_recv_remote_msg ( private -> command . session , private -> command . encrypted ) ;if ( op_reply == NULL ) {crm_element_value_int ( op_reply , F_CIB_CALLID , & reply_id ) ;CRM_CHECK ( reply_id > 0 , free_xml ( op_reply ) ;","start_time = time ( NULL ) ;remaining_time = cib -> call_timeout ? cib -> call_timeout : 60 ;while ( remaining_time > 0 && ! disconnected ) {op_reply = crm_recv_remote_msg ( private -> command . session , & private -> command . encrypted ) ;if ( op_reply == NULL ) {crm_element_value_int ( op_reply , F_CIB_CALLID , & reply_id ) ;",2131
1889,}if ( sync_timer -> ref > 0 ) {g_source_remove ( sync_timer -> ref ) ;sync_timer -> ref = 0 ;if ( timer_expired ) {return - ETIME ;if ( op_reply == NULL ) {,"remaining_time = time ( NULL ) - start_time ;if ( disconnected ) {crm_err ( ""Disconnected<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>reply."" ) ;return - ENOTCONN ;else if ( op_reply == NULL ) {",2131
1890,"pr_debug ( ""%p<S2SV_blank>%zu\\\lock_sock ( sk ) ;","pr_debug ( ""%p<S2SV_blank>%zu\\\msg -> msg_namelen = 0 ;lock_sock ( sk ) ;",2132
1891,sockaddr -> sa_family = AF_NFC ;sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ;,"memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ;sockaddr -> sa_family = AF_NFC ;sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ;",2132
1892,"ghash_flush ( ctx , dctx ) ;memcpy ( dst , buf , GHASH_BLOCK_SIZE ) ;","if ( ! ctx -> gf128 ) return - ENOKEY ;ghash_flush ( ctx , dctx ) ;memcpy ( dst , buf , GHASH_BLOCK_SIZE ) ;",2133
1893,"LPSTR tmp = NULL ;size_t cs = 0 , x , ds , len ;if ( s )  tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","LPSTR tmp = NULL ;LPSTR tmp2 = NULL ;size_t cs = 0 , x , ds , len ;if ( s ) {tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;}if ( NULL == tmp ) {",2134
1894,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",2134
1895,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",2134
1896,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",2134
1897,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",2134
1898,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp )  {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",2134
1899,"int number_bidders , i , bid , best_bid ;struct archive_read_filter_bidder * bidder , * best_bidder ;for ( ;;) {number_bidders = sizeof ( a -> bidders ) / sizeof ( a -> bidders [ 0 ] ) ;","int number_bidders , i , bid , best_bid , n ;struct archive_read_filter_bidder * bidder , * best_bidder ;for ( n = 0 ;n < 25 ;++ n ) {number_bidders = sizeof ( a -> bidders ) / sizeof ( a -> bidders [ 0 ] ) ;",2135
1900,"
","archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding"" ) ;return ( ARCHIVE_FATAL ) ;",2135
1901,},},2135
1902,if ( newlen < SDS_MAX_PREALLOC )  newlen *= 2 ;hdrlen = sdsHdrSize ( type ) ;if ( oldtype == type ) {,assert ( newlen > len ) ;if ( newlen < SDS_MAX_PREALLOC ) newlen *= 2 ;hdrlen = sdsHdrSize ( type ) ;assert ( hdrlen + newlen + 1 > len ) ;if ( oldtype == type ) {,2136
1903,"if ( ip_options_echo ( & icmp_param -> replyopts , skb ) )  return ;sk = icmp_xmit_lock ( net ) ;if ( sk == NULL ) return ;inet = inet_sk ( sk ) ;icmp_param -> data . icmph . checksum = 0 ;inet -> tos = ip_hdr ( skb ) -> tos ;daddr = ipc . addr = rt -> rt_src ;ipc . opt = NULL ;ipc . tx_flags = 0 ;if ( icmp_param -> replyopts . optlen ) {ipc . opt = & icmp_param -> replyopts ;if ( ipc . opt -> srr )  daddr = icmp_param -> replyopts . faddr ;}",if ( ip_options_echo ( & icmp_param -> replyopts . opt ;if ( ipc . opt -> opt . srr ) daddr = icmp_param -> replyopts . opt . opt . faddr ;},2137
1904,"if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;","if ( ( MagickSizeType ) image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;",2138
1905,"}if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ;if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;bmp_info . file_size = ReadBlobLSBLong ( image ) ;( void ) ReadBlobLSBLong ( image ) ;bmp_info . offset_bits = ReadBlobLSBLong ( image ) ;bmp_info . size = ReadBlobLSBLong ( image ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ;if ( bmp_info . size == 12 ) {( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ;bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ;bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ;bmp_info . planes = ReadBlobLSBShort ( image ) ;bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ;bmp_info . x_pixels = 0 ;bmp_info . y_pixels = 0 ;bmp_info . number_colors = 0 ;bmp_info . compression = BI_RGB ;bmp_info . image_size = 0 ;bmp_info . alpha_mask = 0 ;if ( image -> debug != MagickFalse ) {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ;( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ;}}else {if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ;bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;bmp_info . planes = ReadBlobLSBShort ( image ) ;bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ;bmp_info . compression = ReadBlobLSBLong ( image ) ;bmp_info . image_size = ReadBlobLSBLong ( image ) ;bmp_info . x_pixels = ReadBlobLSBLong ( image ) ;bmp_info . y_pixels = ReadBlobLSBLong ( image ) ;bmp_info . number_colors = ReadBlobLSBLong ( image ) ;if ( bmp_info . number_colors > GetBlobSize ( image ) )  ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;bmp_info . colors_important = ReadBlobLSBLong ( image ) ;if ( image -> debug != MagickFalse ) {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ;( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ;( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ;switch ( bmp_info . compression ) {case BI_RGB : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ;break ;}case BI_RLE4 : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ;break ;}case BI_RLE8 : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ;break ;}case BI_BITFIELDS : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ;break ;}case BI_PNG : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ;break ;}case BI_JPEG : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ;break ;}default : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ;}}( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ;}bmp_info . red_mask = ReadBlobLSBLong ( image ) ;bmp_info . green_mask = ReadBlobLSBLong ( image ) ;bmp_info . blue_mask = ReadBlobLSBLong ( image ) ;if ( bmp_info . size > 40 ) {double gamma ;bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ;bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ;# define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ;gamma = PerceptibleReciprocal ( gamma ) ;bmp_info . red_primary . x *= gamma ;bmp_info . red_primary . y *= gamma ;image -> chromaticity . red_primary . x = bmp_info . red_primary . x ;image -> chromaticity . red_primary . y = bmp_info . red_primary . y ;gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ;gamma = PerceptibleReciprocal ( gamma ) ;bmp_info . green_primary . x *= gamma ;bmp_info . green_primary . y *= gamma ;image -> chromaticity . green_primary . x = bmp_info . green_primary . x ;image -> chromaticity . green_primary . y = bmp_info . green_primary . y ;gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ;gamma = PerceptibleReciprocal ( gamma ) ;bmp_info . blue_primary . x *= gamma ;bmp_info . blue_primary . y *= gamma ;image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ;image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ;bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ;bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ;bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ;image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ;}else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ;if ( bmp_info . size > 108 ) {size_t intent ;intent = ReadBlobLSBLong ( image ) ;switch ( ( int ) intent ) {case LCS_GM_BUSINESS : {image -> rendering_intent = SaturationIntent ;break ;}case LCS_GM_GRAPHICS : {image -> rendering_intent = RelativeIntent ;break ;}case LCS_GM_IMAGES : {image -> rendering_intent = PerceptualIntent ;break ;}case LCS_GM_ABS_COLORIMETRIC : {image -> rendering_intent = AbsoluteIntent ;break ;}}( void ) ReadBlobLSBLong ( image ) ;( void ) ReadBlobLSBLong ( image ) ;( void ) ReadBlobLSBLong ( image ) ;}}if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\\\'"" , image -> filename ) ;else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\\\'"" , image -> filename ) ;if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ;if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ;if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ;if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ;if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;switch ( bmp_info . compression ) {case BI_RGB : image -> compression = NoCompression ;break ;case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ;break ;case BI_BITFIELDS : break ;case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ;case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ;default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ;}image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ;image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ;image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ;image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ;if ( bmp_info . bits_per_pixel < 16 ) {size_t one ;image -> storage_class = PseudoClass ;image -> colors = bmp_info . number_colors ;one = 1 ;if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ;}image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ;image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ;image -> units = PixelsPerCentimeterResolution ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( image -> storage_class == PseudoClass ) {unsigned char * bmp_colormap ;size_t packet_size ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ;if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ;else packet_size = 4 ;offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ;if ( offset < 0 ) {bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ;if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) {bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ;ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;}p = bmp_colormap ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) {image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ;image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ;image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ;if ( packet_size == 4 ) p ++ ;}bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ;}if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;offset_bits = bmp_info . offset_bits ;offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ;if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ;bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ;length = ( size_t ) bytes_per_line * image -> rows ;if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) {if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ;count = ReadBlob ( image , length , pixels ) ;if ( count != ( ssize_t ) length ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;}}else {pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ;if ( status == MagickFalse ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ;}}if ( bmp_info . compression == BI_RGB ) {if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) {bytes_per_line = 4 * ( image -> columns ) ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {if ( * ( p + 3 ) != 0 ) {image -> alpha_trait = BlendPixelTrait ;y = - 1 ;break ;}p += 4 ;}}}bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ;bmp_info . red_mask = 0x00ff0000U ;bmp_info . green_mask = 0x0000ff00U ;bmp_info . blue_mask = 0x000000ffU ;if ( bmp_info . bits_per_pixel == 16 ) {bmp_info . red_mask = 0x00007c00U ;bmp_info . green_mask = 0x000003e0U ;bmp_info . blue_mask = 0x0000001fU ;}}( void ) memset ( & shift , 0 , sizeof ( shift ) ) ;( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ;if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) {register unsigned int sample ;if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) {shift . red ++ ;if ( shift . red >= 32U ) break ;}if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) {shift . green ++ ;if ( shift . green >= 32U ) break ;}if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) {shift . blue ++ ;if ( shift . blue >= 32U ) break ;}if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) {shift . alpha ++ ;if ( shift . alpha >= 32U ) break ;}sample = shift . red ;while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;}quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ;sample = shift . green ;while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;}quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ;sample = shift . blue ;while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ;sample = shift . alpha ;while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;}quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ;}switch ( bmp_info . bits_per_pixel ) {case 1 : {for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ( ssize_t ) image -> columns - 7 ) ;x += 8 ) {for ( bit = 0 ;bit < 8 ;bit ++ ) {index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}p ++ ;}if ( ( image -> columns % 8 ) != 0 ) {for ( bit = 0 ;bit < ( image -> columns % 8 ) ;bit ++ ) {index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}p ++ ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;break ;}case 4 : {for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ( ssize_t ) image -> columns - 1 ) ;x += 2 ) {ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;p ++ ;}if ( ( image -> columns % 2 ) != 0 ) {ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;p ++ ;x ++ ;}if ( x < ( ssize_t ) image -> columns ) break ;if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;break ;}case 8 : {if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = ( ssize_t ) image -> columns ;x != 0 ;-- x ) {ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;break ;}case 16 : {unsigned int alpha , pixel ;if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ;}bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ;image -> storage_class = DirectClass ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {pixel = ( unsigned int ) ( * p ++ ) ;pixel |= ( * p ++ ) << 8 ;red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ;if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ;if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ;green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ;if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ;if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ;if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ;blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ;if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ;if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ;SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ;SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ;SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) {alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ;if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ;SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ;}q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}break ;}case 24 : {bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ;SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ;SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}break ;}case 32 : {if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ;}bytes_per_line = 4 * ( image -> columns ) ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {unsigned int alpha , pixel ;p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {pixel = ( unsigned int ) ( * p ++ ) ;pixel |= ( ( unsigned int ) * p ++ << 8 ) ;pixel |= ( ( unsigned int ) * p ++ << 16 ) ;pixel |= ( ( unsigned int ) * p ++ << 24 ) ;red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ;if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ;green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ;if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ;blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ;if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ;SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ;SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ;SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) {alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ;if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ;SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ;}q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}break ;}default : {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}}pixel_info = RelinquishVirtualMemory ( pixel_info ) ;if ( y > 0 ) break ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}if ( bmp_info . height < 0 ) {Image * flipped_image ;flipped_image = FlipImage ( image , exception ) ;if ( flipped_image != ( Image * ) NULL ) {DuplicateBlob ( flipped_image , image ) ;ReplaceImageInList ( & image , flipped_image ) ;image = flipped_image ;}}if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;* magick = \'\\\\0\' ;if ( bmp_info . ba_offset != 0 )   {offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ;if ( offset < 0 )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}count = ReadBlob ( image , 2 , magick ) ;","offset = ( MagickOffsetType ) bmp_info . ba_offset ;if ( offset != 0 ) {offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ;count = ReadBlob ( image , 2 , magick ) ;",2138
1906,"u_int tlen , pdu_type , pdu_len ;const u_char * tptr ;const rpki_rtr_pdu * pdu_header ;tptr = pptr ;tlen = len ;while ( tlen >= sizeof ( rpki_rtr_pdu ) ) {ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;","while ( tlen >= sizeof ( rpki_rtr_pdu ) ) {ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;",2139
1907,"if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) )  goto trunc ;tlen -= pdu_len ;tptr += pdu_len ;}return ;trunc : ND_PRINT ( ( ndo , ""\\\","if ( rpki_rtr_pdu_print ( ndo , pptr , len , 1 , 8 ) ;len -= pdu_len ;tptr += pdu_len ;}",2139
1908,"case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD :  ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" ,  ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ;ND_TCHECK2 ( * tptr , 4 ) ;bw . i = EXTRACT_32BITS ( tptr ) ;","case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ;ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ;ND_TCHECK2 ( * tptr , 4 ) ;bw . i = EXTRACT_32BITS ( tptr ) ;",2140
1909,settings . udpport = 11211 ;settings . inter = NULL ;,settings . udpport = 0 ;settings . inter = NULL ;,2141
1910,"CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ;CU_add_test ( parserTestSuite , ""State<S2SV_blank>machine"" , test_stateMachine ) ;","CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail"" , test_parser_hvi ) ;CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ;CU_add_test ( parserTestSuite , ""State<S2SV_blank>machine"" , test_stateMachine ) ;",2142
1911,"retval = copy_strings_kernel ( 1 , & iname_addr , bprm ) ;bprm -> argc ++ ;bprm -> interp = iname ;interp_file = open_exec ( iname ) ;","retval = bprm_change_interp ( iname , bprm ) ;interp_file = open_exec ( iname ) ;",2143
1912,"yyerror ( yyscanner , lex_env , ""repeat<S2SV_blank>interval<S2SV_blank>too<S2SV_blank>large"" ) ;yyerror ( yyscanner , lex_env , ""bad<S2SV_blank>repeat<S2SV_blank>interval"" ) ;","yyerror ( yyscanner , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" ) ;yyerror ( yyscanner , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" ) ;",2144
1913,"yyerror ( yyscanner , lex_env , ""repeat<S2SV_blank>interval<S2SV_blank>too<S2SV_blank>large"" ) ;","yyerror ( yyscanner , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" ) ;",2144
1914,"yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;","yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;",2144
1915,"yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;","yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;",2144
1916,"yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;","yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;",2144
1917,"unsigned int sse = INT_MAX , best_rd_sse = INT_MAX ;# if CONFIG_TEMPORAL_DENOISING  unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX ;# endif  int sf_improved_mv_pred = cpi -> sf . improved_mv_pred ;int_mv mvp ;int near_sadidx [ 8 ] = {0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 };int saddone = 0 ;int sr = 0 ;unsigned char * plane [ 4 ] [ 3 ] ;int ref_frame_map [ 4 ] ;int sign_bias = 0 ;# if CONFIG_MULTI_RES_ENCODING  int dissim = INT_MAX ;int parent_ref_valid = cpi -> oxcf . mr_encoder_id && cpi -> mr_low_res_mv_avail ;int_mv parent_ref_mv ;MB_PREDICTION_MODE parent_mode = 0 ;else if ( parent_ref_frame == GOLDEN_FRAME )  parent_ref_flag = ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ;else if ( parent_ref_frame == ALTREF_FRAME ) parent_ref_flag = ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) ;}# endif  mode_mv = mode_mv_sb [ sign_bias ] ;best_ref_mv . as_int = 0 ;vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ;vpx_memset ( & best_mbmode , 0 , sizeof ( best_mbmode ) ) ;# if CONFIG_MULTI_RES_ENCODING if ( parent_ref_valid && parent_ref_frame && dissim < 8 ) {","unsigned int sse = UINT_MAX , best_rd_sse = INT_MAX ;# if CONFIG_TEMPORAL_DENOISING unsigned int zero_mv_sse = UINT_MAX , best_sse = INT_MAX ;# endif int sf_improved_mv_pred = cpi -> sf . improved_mv_pred ;# if CONFIG_MULTI_RES_ENCODING int dissim = INT_MAX ;int dot_artifact_candidate = 0 ;get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ;if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) {unsigned char * target_y = x -> src . y_buffer ;unsigned char * target_u = x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src ;unsigned char * target_v = x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src ;int stride = x -> src . y_stride ;int stride_uv = x -> block [ 16 ] . src_stride ;# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) {const int uv_denoise = ( cpi -> oxcf . noise_sensitivity >= 2 ) ? 1 : 0 ;target_y = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_buffer + recon_yoffset ;stride = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_stride ;if ( uv_denoise ) {target_u = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . u_buffer + recon_uvoffset ;target_v = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . v_buffer + recon_uvoffset ;stride_uv = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . uv_stride ;}}# endif dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_y , stride , plane [ LAST_FRAME ] [ 0 ] , mb_row , mb_col , 0 ) ;if ( ! dot_artifact_candidate ) {dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_u , stride_uv , plane [ LAST_FRAME ] [ 1 ] , mb_row , mb_col , 1 ) ;if ( ! dot_artifact_candidate ) {dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_v , stride_uv , plane [ LAST_FRAME ] [ 2 ] , mb_row , mb_col , 2 ) ;}}}# if CONFIG_MULTI_RES_ENCODING parent_ref_valid = cpi -> oxcf . mr_encoder_id && cpi -> mr_low_res_mv_avail ;else if ( parent_ref_frame == GOLDEN_FRAME ) parent_ref_flag = ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ;if ( dot_artifact_candidate ) parent_ref_valid = 0 ;}# endif {const int y = x -> src . y_buffer [ 7 * x -> src . y_stride + 7 ] ;const int cb = x -> src . u_buffer [ 3 * x -> src . uv_stride + 3 ] ;const int cr = x -> src . v_buffer [ 3 * x -> src . uv_stride + 3 ] ;x -> is_skin = 0 ;memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ;vpx_memset ( & best_mbmode , 0 , sizeof ( best_mbmode ) ) ;# if CONFIG_MULTI_RES_ENCODING if ( parent_ref_valid && parent_ref_frame && dissim < 8 ) {",2145
1918,"get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ;x -> mbs_tested_so_far ++ ;calculate_zeromv_rd_adjustment ( cpi , x , & rd_adjustment ) ;for ( mode_index = 0 ;","get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ;x -> mbs_tested_so_far ++ ;calculate_zeromv_rd_adjustment ( cpi , x , & rd_adjustment ) ;for ( mode_index = 0 ;",2145
1919,"distortion2 = vp8_variance16x16 (  * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ;","distortion2 = vp8_variance16x16 ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ;",2145
1920,"distortion2 = vp8_variance16x16  ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ;","distortion2 = vp8_variance16x16 ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ;",2145
1921,# if CONFIG_MULTI_RES_ENCODING  if ( cpi -> oxcf . mr_encoder_id && ! parent_ref_valid )  sf_improved_mv_pred = 0 ;if ( parent_ref_valid && parent_ref_frame )  {,# if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id && ! parent_ref_valid ) sf_improved_mv_pred = 0 ;if ( parent_ref_valid && parent_ref_frame ) {,2145
1922,"# if CONFIG_MULTI_RES_ENCODING  if ( parent_ref_valid && parent_ref_frame && dissim <= 2 &&  MAX ( abs ( best_ref_mv . as_mv . row - parent_ref_mv . as_mv . row ) , abs ( best_ref_mv . as_mv . col - parent_ref_mv . as_mv . col ) ) <= 4 ) {","# if CONFIG_MULTI_RES_ENCODING if ( parent_ref_valid && parent_ref_frame && dissim <= 2 && MAX ( abs ( best_ref_mv . as_mv . row - parent_ref_mv . as_mv . row ) , abs ( best_ref_mv . as_mv . col - parent_ref_mv . as_mv . col ) ) <= 4 ) {",2145
1923,# if CONFIG_MULTI_RES_ENCODING  if ( ! parent_ref_valid )  step_param = 0 ;,# if CONFIG_MULTI_RES_ENCODING if ( ! parent_ref_valid ) step_param = 0 ;,2145
1924,"rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv ,  cpi -> mb . mvcost , 128 ) ;","rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , cpi -> mb . mvcost , 128 ) ;",2145
1925,# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity )  {if ( this_mode == ZEROMV && sse < zero_mv_sse )  {if ( x -> e_mbd . mode_info_context -> mbmi . mode == NEWMV &&  sse < best_sse )  {,# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) {if ( this_mode == ZEROMV && sse < zero_mv_sse ) {if ( x -> e_mbd . mode_info_context -> mbmi . mode == NEWMV && sse < best_sse ) {,2145
1926,"vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi ,  sizeof ( MB_MODE_INFO ) ) ;x -> rd_thresh_mult [ mode_index ] = ( x -> rd_thresh_mult [ mode_index ] >= ( MIN_THRESHMULT + 2 ) ) ? x -> rd_thresh_mult [ mode_index ] - 2 : MIN_THRESHMULT ;x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ;}else {x -> rd_thresh_mult [ mode_index ] += 4 ;if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ;x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ;}if ( x -> skip ) break ;}if ( ( cpi -> rd_baseline_thresh [ best_mode_index ] > 0 ) && ( cpi -> rd_baseline_thresh [ best_mode_index ] < ( INT_MAX >> 2 ) ) ) {int best_adjustment = ( x -> rd_thresh_mult [ best_mode_index ] >> 3 ) ;x -> rd_thresh_mult [ best_mode_index ] = ( x -> rd_thresh_mult [ best_mode_index ] >= ( MIN_THRESHMULT + best_adjustment ) ) ? x -> rd_thresh_mult [ best_mode_index ] - best_adjustment : MIN_THRESHMULT ;x -> rd_threshes [ best_mode_index ] = ( cpi -> rd_baseline_thresh [ best_mode_index ] >> 7 ) * x -> rd_thresh_mult [ best_mode_index ] ;}{int this_rdbin = ( * returndistortion >> 7 ) ;if ( this_rdbin >= 1024 ) {this_rdbin = 1023 ;}x -> error_bins [ this_rdbin ] ++ ;}# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) {if ( x -> best_sse_inter_mode == DC_PRED )  {x -> best_sse_inter_mode = best_mbmode . mode ;x -> best_sse_mv = best_mbmode . mv ;x -> need_to_clamp_best_mvs = best_mbmode . need_to_clamp_mvs ;x -> best_reference_frame = best_mbmode . ref_frame ;best_sse = best_rd_sse ;}vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse ,   recon_yoffset , recon_uvoffset ) ;if ( best_mbmode . ref_frame == INTRA_FRAME &&  x -> best_zeromv_reference_frame != INTRA_FRAME ) {int this_rd = 0 ;int this_ref_frame = x -> best_zeromv_reference_frame ;rate2 = x -> ref_frame_cost [ this_ref_frame ] +  vp8_cost_mv_ref ( ZEROMV , mdcounts ) ;distortion2 = 0 ;x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ;x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ;x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ;x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ;x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ;x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ;x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ;this_rd = evaluate_inter_mode ( & sse , rate2 , & distortion2 , cpi , x , rd_adjustment ) ;if ( this_rd < best_rd ) {vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi ,  sizeof ( MB_MODE_INFO ) ) ;","vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ;memset ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ;",2145
1927,"if ( ! x -> skip )  vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mbmode ,  sizeof ( MB_MODE_INFO ) ) ;","if ( ! x -> skip ) vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mbmode , sizeof ( MB_MODE_INFO ) ) ;vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ;",2145
1928,if ( err < 0 ) return err ;,if ( err < 0 < 0 ) return err ;,2146
1929,if ( err )  goto err_free_dev ;,if ( err ) goto err_free_dev ;,2146
1930,"if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) {* pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ;if ( * pgmap ) page = pte_page ( pte ) ;else goto no_page ;else if ( unlikely ( ! page ) ) {",if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) {if ( unlikely ( ! try_get_page ( page ) ) ) {page = ERR_PTR ( - ENOMEM ) ;goto out ;},2147
1931,if ( flags & FOLL_GET )  get_page ( page ) ;if ( flags & FOLL_TOUCH ) {,if ( flags & FOLL_GET ) get_page ( page ) ;if ( flags & FOLL_TOUCH ) {,2147
1932,"void vp9_rc_compute_frame_size_bounds ( const VP9_COMP * cpi ,  int this_frame_target ,  int * frame_under_shoot_limit , int * frame_over_shoot_limit ) {if ( cpi -> oxcf . end_usage == USAGE_CONSTANT_QUALITY ) {* frame_under_shoot_limit = 0 ;int recode_tolerance =   ( cpi -> sf . recode_tolerance * this_frame_target ) / 100 ;* frame_over_shoot_limit = this_frame_target + recode_tolerance ;* frame_under_shoot_limit = this_frame_target - recode_tolerance ;* frame_over_shoot_limit += 200 ;* frame_under_shoot_limit -= 200 ;if ( * frame_under_shoot_limit < 0 ) * frame_under_shoot_limit = 0 ;if ( * frame_over_shoot_limit > cpi -> rc . max_frame_bandwidth ) {* frame_over_shoot_limit = cpi -> rc . max_frame_bandwidth ;}","void vp9_rc_compute_frame_size_bounds ( const VP9_COMP * cpi , int frame_target , int * frame_under_shoot_limit , int * frame_over_shoot_limit ) {if ( cpi -> oxcf . rc_mode == VPX_Q ) {* frame_under_shoot_limit = 0 ;const int tolerance = ( cpi -> sf . recode_tolerance * frame_target ) / 100 ;* frame_over_shoot_limit = MIN ( frame_target + tolerance + 200 , cpi -> rc . max_frame_bandwidth ) {* frame_over_shoot_limit = cpi -> rc . max_frame_bandwidth ;",2148
1933,if ( asn1_com_prkey_attr -> flags & SC_ASN1_PRESENT &&  asn1_com_prkey_attr [ 0 ] . flags & SC_ASN1_PRESENT ) {free ( asn1_com_prkey_attr [ 0 ] . parm ) ;},free ( info . subject . value ) ;,2149
1934,"down_write ( & card -> controls_rwsem ) ;if ( snd_ctl_find_id ( card , & id ) ) {","if ( id . index > UINT_MAX - kcontrol -> count ) goto error ;down_write ( & card -> controls_rwsem ) ;if ( snd_ctl_find_id ( card , & id ) ) {",2150
1935,"if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",2151
1936,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\\",2152
1937,"ret = arg ( name , annotation , LINENO ( n ) , n -> n_col_offset ,  n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ;","ret = arg ( name , annotation , NULL , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ;",2153
1938,"else if ( strcasecmp ( arg , ""%u"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@u<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ;else if ( strcmp ( arg , ""@@"" ) == 0 || strcmp ( arg , ""@@u"" ) == 0 )  g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\\","else if ( g_str_has_prefix ( arg , ""%u"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@u<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ;else if ( strcmp ( arg , ""@@"" ) ) g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\\",2154
1939,const VP9_CONFIG * const oxcf = & cpi -> oxcf ;LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ;RATE_CONTROL * const lrc = & lc -> rc ;lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;lrc -> min_frame_bandwidth = ( int ) ( lrc -> av_per_frame_bandwidth *  oxcf -> two_pass_vbrmin_section / 100 ) ;lrc -> max_frame_bandwidth = ( int ) ( ( ( int64_t ) lrc -> av_per_frame_bandwidth *  oxcf -> two_pass_vbrmax_section ) / 100 ) ;lrc -> max_gf_interval = 16 ;lrc -> static_scene_max_gf_interval = cpi -> key_frame_frequency >> 1 ;if ( oxcf -> play_alternate && oxcf -> lag_in_frames ) {if ( lrc -> max_gf_interval > oxcf -> lag_in_frames - 1 ) lrc -> max_gf_interval = oxcf -> lag_in_frames - 1 ;if ( lrc -> static_scene_max_gf_interval > oxcf -> lag_in_frames - 1 ) lrc -> static_scene_max_gf_interval = oxcf -> lag_in_frames - 1 ;}if ( lrc -> max_gf_interval > lrc -> static_scene_max_gf_interval ) lrc -> max_gf_interval = lrc -> static_scene_max_gf_interval ;,"const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;LAYER_CONTEXT * const lc = get_layer_context ( cpi ) ;RATE_CONTROL * const lrc = & lc -> rc ;lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;lrc -> min_frame_bandwidth = ( int ) ( lrc -> avg_frame_bandwidth * oxcf -> two_pass_vbrmin_section / 100 ) ;lrc -> max_frame_bandwidth = ( int ) ( ( ( int64_t ) lrc -> avg_frame_bandwidth * oxcf -> two_pass_vbrmax_section ) / 100 ) ;vp9_rc_set_gf_interval_range ( cpi , lrc ) ;",2155
1940,register int i ;for ( i = 0 ;,int i ;char * tmps = 0 ;for ( i = 0 ;,2156
1941,"raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types?"" ) ;nh_terminate ( EXIT_FAILURE ) ;}if ( ! winchoices [ 1 ] . procs ) {","raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types<S2SV_blank>supported?"" ) ;nh_terminate ( EXIT_FAILURE ) ;}# define WINDOW_TYPE_MAXLEN 50 if ( strlen ( s ) >= WINDOW_TYPE_MAXLEN ) {tmps = ( char * ) alloc ( WINDOW_TYPE_MAXLEN ) ;( void ) strncpy ( tmps , s , WINDOW_TYPE_MAXLEN - 1 ) ;tmps [ WINDOW_TYPE_MAXLEN - 1 ] = \'\\\\0\' ;s = tmps ;}# undef WINDOW_TYPE_MAXLEN if ( ! winchoices [ 1 ] . procs ) {",2156
1942,"if ( windowprocs . win_raw_print == def_raw_print  || WINDOWPORT ( ""safe-startup"" ) ) nh_terminate ( EXIT_SUCCESS ) ;","if ( tmps ) free ( ( genericptr_t ) tmps ) ;if ( windowprocs . win_raw_print == def_raw_print || WINDOWPORT ( ""safe-startup"" ) ) nh_terminate ( EXIT_SUCCESS ) ;",2156
1943,ps_codec -> s_parse . i4_ctb_slice_x = 0 ;,ret = ps_codec -> s_parse . i4_ctb_slice_x = 0 ;,2157
1944,"ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac ,  & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ;}do {","ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ;if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) {ps_codec -> i4_slice_error = 1 ;end_of_slice_flag = 1 ;ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ;}}do {",2157
1945,"ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac ,  & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ;}}","ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ;if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) {ps_codec -> i4_slice_error = 1 ;end_of_slice_flag = 1 ;ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ;}}}",2157
1946,"ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac ,  & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ;}else {ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac ,  & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc ,  ( const UWORD8 * ) & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync ) ;}","ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ;if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) {ps_codec -> i4_slice_error = 1 ;end_of_slice_flag = 1 ;ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ;}}else {ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , ( const UWORD8 * ) & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync ) ;if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) {ps_codec -> i4_slice_error = 1 ;end_of_slice_flag = 1 ;ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ;}}",2157
1947,if ( 0 == end_of_pic )  {,ps_codec -> i4_slice_error = 0 ;if ( 0 == end_of_pic ) {,2157
1948,"if ( alcf -> protect == 0 ) {return NGX_DECLINED ;}ctx = ngx_http_get_module_ctx ( r , ngx_http_auth_spnego_module ) ;if ( NULL == ctx ) {ctx = ngx_palloc ( r -> pool , sizeof ( ngx_http_auth_spnego_ctx_t ) ) ;if ( NULL == ctx ) {return NGX_HTTP_INTERNAL_SERVER_ERROR ;}ctx -> token . len = 0 ;ctx -> token . data = NULL ;ctx -> head = 0 ;ctx -> ret = NGX_HTTP_UNAUTHORIZED ;ngx_http_set_ctx ( r , ctx , ngx_http_auth_spnego_module ) ;}spnego_debug3 ( ""SSO<S2SV_blank>auth<S2SV_blank>handling<S2SV_blank>IN:<S2SV_blank>token.len=%d,<S2SV_blank>head=%d,<S2SV_blank>ret=%d"" , ctx -> token . len , ctx -> head , ctx -> ret ) ;if ( ctx -> token . len && ctx -> head ) {spnego_debug1 ( ""Found<S2SV_blank>token<S2SV_blank>and<S2SV_blank>head,<S2SV_blank>returning<S2SV_blank>%d"" , ctx -> ret ) ;return ctx -> ret ;}if ( NULL != r -> headers_in . user . data ) {spnego_debug0 ( ""User<S2SV_blank>header<S2SV_blank>set"" ) ;return NGX_OK ;}spnego_debug0 ( ""Begin<S2SV_blank>auth"" ) ;if ( alcf -> allow_basic ) {spnego_debug0 ( ""Detect<S2SV_blank>basic<S2SV_blank>auth"" ) ;ret = ngx_http_auth_basic_user ( r ) ;if ( NGX_OK == ret ) {spnego_debug0 ( ""Basic<S2SV_blank>auth<S2SV_blank>credentials<S2SV_blank>supplied<S2SV_blank>by<S2SV_blank>client"" ) ;if ( NGX_DECLINED == ngx_http_auth_spnego_basic ( r , ctx , alcf ) ) {spnego_debug0 ( ""Basic<S2SV_blank>auth<S2SV_blank>failed"" ) ;","if ( NGX_OK != ngx_http_auth_spnego_basic ( r , ctx , alcf ) ) {spnego_debug0 ( ""Basic<S2SV_blank>auth<S2SV_blank>failed"" ) ;",2158
1949,"
",ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;,2159
1950,"ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" ,  EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ;","ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ;",2159
1951,return sizeof ( vpx_codec_alg_priv_t ) ;},( void ) flags ;return sizeof ( vpx_codec_alg_priv_t ) ;},2160
1952,"s -> packet_length = 0 ;goto err ;}# ifdef TLS_DEBUG printf ( ""dec<S2SV_blank>%d\\\{unsigned int z ;for ( z = 0 ;z < rr -> length ;z ++ ) printf ( ""%02X%c"" , rr -> data [ z ] , ( ( z + 1 ) % 16 ) ? \'<S2SV_blank>\' : \'\\\}printf ( ""\\\# endif if ( ( sess != NULL ) && ( s -> enc_read_ctx != NULL ) && ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) ) {unsigned char * mac = NULL ;unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ;mac_size = EVP_MD_CTX_size ( s -> read_hash ) ;OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ;if ( rr -> orig_len < mac_size || ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && rr -> orig_len < mac_size + 1 ) ) {al = SSL_AD_DECODE_ERROR ;SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_LENGTH_TOO_SHORT ) ;goto f_err ;}if ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE ) {mac = mac_tmp ;ssl3_cbc_copy_mac ( mac_tmp , rr , mac_size ) ;rr -> length -= mac_size ;}else {rr -> length -= mac_size ;mac = & rr -> data [ rr -> length ] ;}i = s -> method -> ssl3_enc -> mac ( s , md , 0 ) ;if ( i < 0 || mac == NULL || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) enc_err = - 1 ;if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size ) enc_err = - 1 ;}if ( enc_err < 0 ) {rr -> length = 0 ;s -> packet_length = 0 ;goto err ;}if ( s -> expand != NULL ) {if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH ) {al = SSL_AD_RECORD_OVERFLOW ;SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_COMPRESSED_LENGTH_TOO_LONG ) ;goto f_err ;}if ( ! ssl3_do_uncompress ( s ) ) {al = SSL_AD_DECOMPRESSION_FAILURE ;SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_BAD_DECOMPRESSION ) ;goto f_err ;}}if ( rr -> length > SSL3_RT_MAX_PLAIN_LENGTH ) {al = SSL_AD_RECORD_OVERFLOW ;SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_DATA_LENGTH_TOO_LONG ) ;goto f_err ;}rr -> off = 0 ;s -> packet_length = 0 ;dtls1_record_bitmap_update ( s , & ( s -> d1 -> bitmap ) ) ;return ( 1 ) ;",return ( 1 ) ;,2161
1953,"pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows *  sizeof ( * pixels ) ) ;","pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 257UL , image -> rows * sizeof ( * pixels ) ) ;",2162
1954,"struct pipe_buffer * buf ;int idx = i -> idx ;size_t off = i -> iov_offset , orig_sz ;orig_sz = size ;if ( size ) {if ( off )   size += off - pipe -> bufs [ idx ] . offset ;while ( 1 ) {if ( size <= buf -> len )  break ;size -= buf -> len ;idx = next_idx ( idx , pipe ) ;}buf -> len = size ;i -> idx = idx ;off = i -> iov_offset = buf -> offset + size ;}if ( off ) idx = next_idx ( idx , pipe ) ;if ( pipe -> nrbufs ) {int unused = ( pipe -> curbuf + pipe -> nrbufs ) & ( pipe -> buffers - 1 ) ;while ( idx != unused ) {pipe_buf_release ( pipe , & pipe -> bufs [ idx ] ) ;pipe -> nrbufs -- ;i -> count -= orig_sz ;}","orig_sz = size ;if ( size ) {struct pipe_buffer * buf ;size_t off = i -> iov_offset , left = size ;int idx = i -> idx ;if ( off ) left += off - pipe -> bufs [ idx ] . offset ;while ( 1 ) {if ( left <= buf -> len ) break ;left -= buf -> len ;i -> idx = idx ;off = i -> iov_offset = buf -> offset + left ;}i -> count -= size ;pipe_truncate ( i ) ;",2163
1955,"if ( cs > CQSPI_MAX_CHIPSELECT ) {dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\\","if ( cs >= CQSPI_MAX_CHIPSELECT ) {dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\\",2164
1956,"goto unmap_pages ;}unmap_pages :  kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ;return r ;","kvm_unpin_pages ( kvm , pfn , page_size ) ;goto unmap_pages ;}unmap_pages : kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn ) ;return r ;",2165
1957,"struct key * find_keyring_by_name ( const char * name , bool skip_perm_check )  {if ( ! name ) return ERR_PTR ( - EINVAL ) ;bucket = keyring_hash ( name ) ;read_lock ( & keyring_name_lock ) ;if ( keyring_name_hash [ bucket ] . next ) {list_for_each_entry ( keyring , & keyring_name_hash [ bucket ] , name_link ) {if ( ! kuid_has_mapping ( current_user_ns ( ) , keyring -> user -> uid ) ) continue ;if ( test_bit ( KEY_FLAG_REVOKED , & keyring -> flags ) ) continue ;if ( strcmp ( keyring -> description , name ) != 0 ) continue ;if ( ! skip_perm_check &&  key_permission ( make_key_ref ( keyring , 0 ) , KEY_NEED_SEARCH ) < 0 )  continue ;if ( ! refcount_inc_not_zero ( & keyring -> usage ) ) continue ;","struct key * find_keyring_by_name ( const char * name , bool uid_keyring ) {if ( uid_keyring ) {if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ;}}else {if ( key_permission ( make_key_ref ( keyring , 0 ) , KEY_NEED_SEARCH ) < 0 ) continue ;if ( ! refcount_inc_not_zero ( & keyring -> usage ) ) continue ;",2166
1958,char * identifier ;char * args_fmt ;,YR_OBJECT * * obj_ptr ;YR_ARENA * obj_arena ;char * identifier ;char * args_fmt ;,2167
1959,if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;while ( ! stop ) {,"if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ;FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) ;while ( ! stop ) {",2167
1960,# endif ip += sizeof ( uint64_t ) ;,# endif assert ( sp == 0 ) ;ip += sizeof ( uint64_t ) ;,2167
1961,# endif  break ;case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ;,# endif break ;case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ;,2167
1962,if ( result == ERROR_SUCCESS )  {r1 . o = function -> return_obj ;push ( r1 ) ;}else {stop = TRUE ;},"if ( result == ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & r1 . o ) ;if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ;stop = ( result != ERROR_SUCCESS ) ;push ( r1 ) ;",2167
1963,yr_modules_unload_all ( context ) ;yr_free ( stack ) ;,"obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ;while ( obj_ptr != NULL ) {yr_object_destroy ( * obj_ptr ) ;obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ;}yr_arena_destroy ( obj_arena ) ;yr_modules_unload_all ( context ) ;yr_free ( stack ) ;",2167
1964,"res = ctx -> iface -> dec . get_si ( ctx -> priv -> alg_priv , si ) ;}","res = ctx -> iface -> dec . get_si ( get_alg_priv ( ctx ) , si ) ;}",2168
1965,"static void nsc_encode_subsampling ( NSC_CONTEXT * context )  {BYTE * co_dst ;BYTE * cg_dst ;INT8 * co_src0 ;INT8 * co_src1 ;INT8 * cg_src0 ;INT8 * cg_src1 ;UINT32 tempHeight ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;for ( y = 0 ;y ++ )  {co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ;cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ;co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ;co_src1 = co_src0 + tempWidth ;cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ;cg_src1 = cg_src0 + tempWidth ;for ( x = 0 ;","static BOOL nsc_encode_subsampling ( NSC_CONTEXT * context ) {UINT32 tempHeight ;if ( ! context ) return FALSE ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;if ( tempHeight == 0 ) return FALSE ;if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ;for ( y = 0 ;y ++ ) {BYTE * co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ;BYTE * cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ;const INT8 * co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ;const INT8 * co_src1 = co_src0 + tempWidth ;const INT8 * cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ;const INT8 * cg_src1 = cg_src0 + tempWidth ;for ( x = 0 ;",2169
1966,},return TRUE ;},2169
1967,"static ngx_int_t  ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r )  {ngx_table_elt_t * header ;ngx_list_part_t * part ;ngx_uint_t i ;if ( ngx_list_init ( & sr -> headers_in . headers , sr -> pool , 20 , sizeof ( ngx_table_elt_t ) ) != NGX_OK ) {dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" ,   ( int ) r -> headers_in . headers . part . nelts ) ;part = & r -> headers_in . headers . part ;if ( part -> next == NULL ) {break ;dd ( ""setting<S2SV_blank>request<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ;}dd ( ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" ,  ( int ) r -> headers_in . headers . part . nelts ) ;return NGX_OK ;","static ngx_int_t ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * pr , int pr_not_chunked ) {ngx_table_elt_t * clh , * header ;ngx_list_part_t * part ;ngx_uint_t i ;u_char * p ;off_t len ;dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) pr -> headers_in . headers . part . nelts ) ;if ( ngx_list_init ( & sr -> headers_in . headers , sr -> pool , 20 , sizeof ( ngx_table_elt_t ) ) != NGX_OK ) {if ( sr -> request_body && ! pr_not_chunked ) {len = sr -> request_body -> buf ? ngx_buf_size ( sr -> request_body -> buf ) : 0 ;clh = ngx_list_push ( & sr -> headers_in . headers ) ;if ( clh == NULL ) {break ;}part = part -> next ;header = part -> elts ;i = 0 ;}dd ( ""setting<S2SV_blank>request<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ;if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) {return NGX_ERROR ;}clh -> hash = ngx_http_lua_content_length_hash ;clh -> key = ngx_http_lua_content_length_header_key ;clh -> lowcase_key = ngx_pnalloc ( sr -> pool , clh -> key . len ) ;if ( clh -> lowcase_key == NULL ) {return NGX_ERROR ;}ngx_strlow ( clh -> lowcase_key , clh -> key . data , clh -> key . len ) ;p = ngx_palloc ( sr -> pool , NGX_OFF_T_LEN ) ;if ( p == NULL ) {return NGX_ERROR ;}clh -> value . data = p ;clh -> value . len = ngx_sprintf ( clh -> value . data , ""%O"" , len ) - clh -> value . data ;sr -> headers_in . content_length = clh ;sr -> headers_in . content_length_n = len ;dd ( ""sr<S2SV_blank>crafted<S2SV_blank>content-length:<S2SV_blank>%.*s"" , ( int ) pr -> headers_in . content_length -> value . len , sr -> headers_in . content_length -> value . data ) ;}part = & pr -> headers_in . headers . part ;if ( part -> next == NULL ) {break ;if ( ! pr_not_chunked && header [ i ] . key . len == sizeof ( ""Content-Length"" ) - 1 && ngx_strncasecmp ( header [ i ] . key . data , ( u_char * ) ""Content-Length"" , sizeof ( ""Content-Length"" ) - 1 ) == 0 ) {continue ;}dd ( ""sr<S2SV_blank>copied<S2SV_blank>req<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ;}dd ( ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) r -> headers_in . headers . part . nelts ) ;return NGX_OK ;",2170
1968,"MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ;const int tmp_col_min = x -> mv_col_min ;int step_param = cpi -> sf . reduce_first_step_size +  ( cpi -> speed < 8 ? ( cpi -> speed > 5 ? 1 : 0 ) : 2 ) ;step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ;vp9_set_mv_search_range ( x , ref_mv ) ;vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , & v_fn_ptr , 0 ,  ref_mv , dst_mv ) ;{int distortion ;unsigned int sse ;cpi -> find_fractional_mv_step ( x , dst_mv , ref_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit ,  & v_fn_ptr , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion ,   & sse ) ;}","MACROBLOCK * const x = & cpi -> td . mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ;const vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ;const int tmp_col_min = x -> mv_col_min ;int cost_list [ 5 ] ;int step_param = mv_sf -> reduce_first_step_size ;step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ;vp9_set_mv_search_range ( x , ref_mv ) ;vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ;}",2171
1969,"return vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride ,   xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride ,  INT_MAX ) ;","return vpx_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride ) ;",2171
1970,"int secure_decrypt ( void * data , unsigned int data_length , int is_signed )  {at91_aes_key_size_t key_size ;unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ;init_keys ( & key_size , cipher_key , cmac_key , iv ) ;at91_aes_init ( ) ;if ( is_signed ) {if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ;fixed_length = at91_aes_roundup ( data_length ) ;cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ;if ( ! consttime_memequal ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) goto exit ;}if ( at91_aes_cbc ( data_length , data , data , 0 , key_size , cipher_key , iv ) ) goto exit ;rc = 0 ;exit : at91_aes_cleanup ( ) ;memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ;memset ( cipher_key , 0 , sizeof ( cipher_key ) ) ;memset ( iv , 0 , sizeof ( iv ) ) ;","static int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) {at91_aes_key_size_t key_size ;unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ;# if defined ( CONFIG_AES_KEY_SIZE_128 ) key_size = AT91_AES_KEY_SIZE_128 ;# elif defined ( CONFIG_AES_KEY_SIZE_192 ) key_size = AT91_AES_KEY_SIZE_192 ;# elif defined ( CONFIG_AES_KEY_SIZE_256 ) key_size = AT91_AES_KEY_SIZE_256 ;# else # error ""bad<S2SV_blank>AES<S2SV_blank>key<S2SV_blank>size"" # endif at91_aes_init ( ) ;",2172
1971,"
","if ( nelements == 0 ) {DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\\goto out ;}",2173
1972,o = 2 ;},o = 2 ;},2173
1973,"for ( j = 0 ;j < nelements ;uint32_t l = CDF_GETUINT32 ( q , o ) ;","for ( j = 0 ;j < nelements && i < sh . sh_properties ;uint32_t l = CDF_GETUINT32 ( q , o ) ;",2173
1974,default :  assert ( 0 ) ;},"default : pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\\return ;}",2174
1975,"
","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",2175
1976,if ( image_info -> ping != MagickFalse )  status = PingGIFImage ( image ) ;,if ( image_info -> ping != MagickFalse ) status = PingGIFImage ( image ) ;,2175
1977,if ( ! adis -> buffer )  return - ENOMEM ;tx = adis -> buffer + burst_length ;tx [ 0 ] = ADIS_READ_REG ( adis -> burst -> reg_cmd ) ;,if ( ! adis -> buffer ) {kfree ( adis -> xfer ) ;adis -> xfer = NULL ;return - ENOMEM ;}tx = adis -> buffer + burst_length ;tx [ 0 ] = ADIS_READ_REG ( adis -> burst -> reg_cmd ) ;,2176
1978,dst_reg -> id = ptr_reg -> id ;switch ( opcode ) {,"dst_reg -> id = ptr_reg -> id ;if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL ;switch ( opcode ) {",2177
1979,"
","if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;",2177
1980,__update_reg_bounds ( dst_reg ) ;__reg_deduce_bounds ( dst_reg ) ;,__update_reg_bounds ( dst_reg ) ;__reg_deduce_bounds ( dst_reg ) ;,2177
1981,"Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;}if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) {Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".cfg\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;",2178
1982,usleep ( 250000 ) ;return 0 ;,TEMP_FAILURE_RETRY ( usleep ( 250000 ) ) ;return 0 ;,2179
1983,"static void update_mv_probs ( vp9_prob * p , int n , vp9_reader * r ) {int i ;++ i )  if ( vp9_read ( r , MV_UPDATE_PROB ) )   p [ i ] = ( vp9_read_literal ( r , 7 ) << 1 ) | 1 ;}","static void update_mv_probs ( vpx_prob * p , int n , vpx_reader * r ) {int i ;+ i )  if ( vp9_read ( r , MV_UPDATE_PROB ) )   p [ i ] = ( vp9_read_literal ( r , 7 ) << 1 ) | 1 ;++ i ) if ( vpx_read ( r , MV_UPDATE_PROB ) ) p [ i ] = ( vpx_read_literal ( r , 7 ) << 1 ) | 1 ;}",2180
1984,"if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) )  return - EFAULT ;","if ( validate_core_offset ( reg ) ) return - EINVAL ;if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) return - EFAULT ;",2181
1985,mk_vhost_close ( sr ) ;},if ( sr -> fd_is_fdt == MK_TRUE ) {mk_vhost_close ( sr ) ;}else {close ( sr -> fd_file ) ;}},2182
1986,while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) {i ++ ;,while ( ( i < to_read ) && ( tmpName [ i ] != 0 ) ) {i ++ ;,2183
1987,"int err = 0 ;ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\\","int err = 0 ;BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) ;ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\\",2184
1988,"err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;","if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) {if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ;else err = ext4_ext_zeroout ( inode , ex ) ;}else err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;",2184
1989,"long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",2185
1990,hndl = sock_diag_lock_handler ( req -> sdiag_family ) ;if ( hndl == NULL ) err = - ENOENT ;,if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;hndl = sock_diag_lock_handler ( req -> sdiag_family ) ;if ( hndl == NULL ) err = - ENOENT ;,2186
1991,if ( sk -> sk_state & PPPOX_BOUND )  goto end ;msg -> msg_namelen = 0 ;,if ( sk -> sk_state & PPPOX_BOUND ) goto end ;,2187
1992,"static void  l2tp_bearer_type_print ( netdissect_options * ndo , const u_char * dat )  {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_ANALOG_MASK ) {","static void l2tp_bearer_type_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_ANALOG_MASK ) {",2188
1993,"case 16 :  # line 94 ""hex_grammar.y""  {# line 1023 ""hex_grammar.c"" break ;case 17 :  # line 95 ""hex_grammar.y""  {# line 1029 ""hex_grammar.c"" break ;case 18 :  # line 96 ""hex_grammar.y""  {# line 1035 ""hex_grammar.c"" break ;case 19 :  # line 97 ""hex_grammar.y""  {# line 1041 ""hex_grammar.c"" break ;case 21 :  # line 100 ""hex_grammar.y""  {# line 1047 ""hex_grammar.c"" break ;case 22 :  # line 99 ""hex_grammar.y""  {# line 1053 ""hex_grammar.c"" break ;case 23 :  # line 98 ""hex_grammar.y""  {# line 1059 ""hex_grammar.c"" break ;","case 16 : # line 101 ""hex_grammar.y"" {# line 1030 ""hex_grammar.c"" break ;case 17 : # line 102 ""hex_grammar.y"" {# line 1036 ""hex_grammar.c"" break ;case 18 : # line 103 ""hex_grammar.y"" {# line 1042 ""hex_grammar.c"" break ;case 19 : # line 104 ""hex_grammar.y"" {# line 1048 ""hex_grammar.c"" break ;case 21 : # line 107 ""hex_grammar.y"" {# line 1054 ""hex_grammar.c"" break ;case 22 : # line 106 ""hex_grammar.y"" {# line 1060 ""hex_grammar.c"" break ;case 23 : # line 105 ""hex_grammar.y"" {# line 1066 ""hex_grammar.c"" break ;",2189
1994,"if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) {pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\\","if ( assoc_array_ptr_is_leaf ( ptr ) && ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) {pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\\",2190
1995,"if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) {return MSPACK_ERR_SEEK ;}}num_chunks = chm -> last_pmgl - x + 1 ;if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) {return MSPACK_ERR_NOMEMORY ;errors = 0 ;while ( num_chunks -- ) {if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) {sys -> free ( chunk ) ;return MSPACK_ERR_READ ;if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ;if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) {sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small"" ) ;if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) {sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ;}p = & chunk [ pmgl_Entries ] ;end = & chunk [ chm -> chunk_size - 2 ] ;num_entries = EndGetI16 ( end ) ;while ( num_entries -- ) {READ_ENCINT ( name_len ) ;if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ;name = p ;p += name_len ;READ_ENCINT ( section ) ;READ_ENCINT ( offset ) ;READ_ENCINT ( length ) ;if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ;if ( ( offset == 0 ) && ( length == 0 ) ) {if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == \'/\' ) ) continue ;}if ( section > 1 ) {sys -> message ( fh , ""invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\\\'%u\\\'."" , section ) ;continue ;}if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) {sys -> free ( chunk ) ;return MSPACK_ERR_NOMEMORY ;}fi -> next = NULL ;fi -> filename = ( char * ) & fi [ 1 ] ;fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ;fi -> offset = offset ;fi -> length = length ;sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ;fi -> filename [ name_len ] = \'\\\\0\' ;if ( name [ 0 ] == \':\' && name [ 1 ] == \':\' ) {if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) {if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . content = fi ;}else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) {chm -> sec1 . control = fi ;}else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . spaninfo = fi ;}}}","if ( name_len == 40 && memcmp ( name , content_name , 40 ) == 0 ) {if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . content = fi ;else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) {chm -> sec1 . control = fi ;else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . spaninfo = fi ;}}",2191
1996,const char * args [ 11 ] ;{,"char tmp_directory [ ] = LARGE_DATA_TMP_DIR ""/abrt-tmp-debuginfo.XXXXXX"" ;if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ;log_info ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ;const char * args [ 13 ] ;{args [ i ++ ] = ""--tmpdir"" ;args [ i ++ ] = tmp_directory ;",2192
1997,"args [ i ++ ] = ""--"" ;args [ i ] = NULL ;","args [ i ++ ] = ""--"" ;args [ i ] = NULL ;",2192
1998,"
","pid_t pid = fork ( ) ;if ( pid < 0 ) perror_msg_and_die ( ""fork"" ) ;if ( pid == 0 ) {",2192
1999,"execvp ( EXECUTABLE , ( char * * ) args ) ;error_msg_and_die ( ""Can\\\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;}","int status ;if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( ""waitpid"" ) ;if ( rmdir ( tmp_directory ) >= 0 ) log_info ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ;else if ( errno != ENOENT ) perror_msg ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ;if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ;if ( WIFSIGNALED ( status ) ) error_msg_and_die ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , WTERMSIG ( status ) ) ;error_msg_and_die ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ;}execvp ( EXECUTABLE , ( char * * ) args ) ;error_msg_and_die ( ""Can\\\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;}",2192
2000,newinet -> inet_daddr = ireq -> rmt_addr ;newinet -> opt = ireq -> opt ;ireq -> opt = NULL ;,newinet -> inet_opt = ireq -> rmt_addr ;newinet -> opt = ireq -> opt ;ireq -> opt = NULL ;,2193
2001,"if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p - addr_len - ETHERTYPE_LEN , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ;","if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ;",2194
2002,"case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS :  isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ;break ;","case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS : isoclns_print ( ndo , p - 1 , length + 1 ) ;break ;case NLPID_SNAP : if ( snap_print ( ndo , p , length , ndo -> ndo_snapend - p + 1 ) ;break ;",2194
2003,return 1 ;},"# if OPENSSL_VERSION_NUMBER > 0x10002000L lua_pushliteral ( L , ""check_flag"" ) ;lua_newtable ( L ) ;auxiliar_enumerate ( L , - 1 , check_flags_const ) ;lua_settable ( L , - 3 ) ;# endif return 1 ;}",2195
2004,"struct perf_event_context * ctx = event -> ctx ;struct task_struct * task = ctx -> task ;if ( ! task ) {cpu_function_call ( event -> cpu , __perf_event_enable , event ) ;return ;raw_spin_lock_irq ( & ctx -> lock ) ;if ( event -> state >= PERF_EVENT_STATE_INACTIVE ) goto out ;if ( event -> state == PERF_EVENT_STATE_ERROR ) event -> state = PERF_EVENT_STATE_OFF ;retry : if ( ! ctx -> is_active ) {__perf_event_mark_enabled ( event ) ;goto out ;}",struct perf_event_context * ctx ;ctx = perf_event_ctx_lock ( event ) ;goto out ;,2196
2005,"static int  validate_event ( struct pmu_hw_events * hw_events ,  struct perf_event * event ) {struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ;struct hw_perf_event fake_event = event -> hw ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF )  return 1 ;return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;}","static int validate_event ( struct pmu * pmu , struct pmu_hw_events * hw_events , struct perf_event * event ) {struct arm_pmu * armpmu ;struct hw_perf_event fake_event = event -> hw ;if ( event -> pmu != pmu ) return 0 ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;armpmu = to_arm_pmu ( event -> pmu ) ;return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;}",2197
2006,BOOL ret = FALSE ;WCHAR * data = NULL ;goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}data = NULL ;ret = TRUE ;out : free ( data ) ;return ret ;},WCHAR * data = NULL ;goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}return TRUE ;err : sud -> directory = NULL ;free ( data ) ;return FALSE ;},2198
2007,u8 opcode = BPF_OP ( insn -> code ) ;dst_reg = & regs [ dst ] ;,u8 opcode = BPF_OP ( insn -> code ) ;int ret ;dst_reg = & regs [ dst ] ;,2199
2008,case BPF_ADD :  if ( known && ( ptr_reg -> off + smin_val ==  ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) {,"case BPF_ADD : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\\return ret ;}if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) {",2199
2009,"case BPF_SUB :  if ( dst_reg == off_reg ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\\","case BPF_SUB : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\\return ret ;}if ( dst_reg == off_reg ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\\",2199
2010,"struct mb_cache_entry * ce = NULL ;int error = 0 ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;# define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ;ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev ,  bs -> bh -> b_blocknr ) ;if ( ce ) {mb_cache_entry_free ( ce ) ;ce = NULL ;}}unlock_buffer ( bs -> bh ) ;if ( error == - EFSCORRUPTED ) goto bad_block ;if ( ! error ) error = ext4_handle_dirty_xattr_block ( handle , inode , bs -> bh ) ;if ( error ) goto cleanup ;goto inserted ;}else {int offset = ( char * ) s -> here - bs -> bh -> b_data ;unlock_buffer ( bs -> bh ) ;if ( ce ) {mb_cache_entry_release ( ce ) ;ce = NULL ;}","struct mb2_cache_entry * ce = NULL ;int error = 0 ;struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;# define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ;__u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ;mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ;",2200
2011,"le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;ea_bdebug ( new_bh , ""reusing;mb_cache_entry_release ( ce ) ;ce = NULL ;","if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) {unlock_buffer ( new_bh ) ;dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ;brelse ( new_bh ) ;mb2_cache_entry_put ( ext4_mb_cache , ce ) ;ce = NULL ;new_bh = NULL ;goto inserted ;}le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;ea_bdebug ( new_bh , ""reusing;mb2_cache_entry_touch ( ext4_mb_cache , ce ) ;mb2_cache_entry_put ( ext4_mb_cache , ce ) ;ce = NULL ;",2200
2012,cleanup : if ( ce )  mb_cache_entry_release ( ce ) ;brelse ( new_bh ) ;,"cleanup : if ( ce ) mb2_cache_entry_put ( ext4_mb_cache , ce ) ;brelse ( new_bh ) ;",2200
2013,"static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags ,  struct in6_addr * addr , uint32_t * ifindex )  {unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ;struct iovec iovec ;","static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags , struct in6_addr * addr , uint32_t * ifindex , int * hoplimit ) {unsigned char cbuf [ 2 * CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ;struct iovec iovec ;",2201
2014,if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 &&   cmsghdr -> cmsg_type == IPV6_PKTINFO &&  cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) {}* addr = sin6 . sin6_addr ;,if ( cmsghdr -> cmsg_level != IPPROTO_IPV6 ) continue ;switch ( cmsghdr -> cmsg_type ) {case IPV6_PKTINFO : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) {break ;case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) {int * val ;val = ( int * ) CMSG_DATA ( cmsghdr ) ;* hoplimit = * val ;}break ;}}* addr = sin6 . sin6_addr ;,2201
2015,"if ( mode > 0 ) {r = fchmod ( fd , mode ) ;","if ( mode != MODE_INVALID ) {r = fchmod ( fd , mode ) ;",2202
2016,"struct address_space * mapping = inode -> i_mapping ;unsigned int blkbits = inode -> i_blkbits ;}if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) {ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ;if ( ret ) return ret ;",unsigned int blkbits = inode -> i_blkbits ;,2203
2017,"truncate_pagecache_range ( inode , start , end - 1 ) ;inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size ,  flags , mode ) ;if ( ret ) goto out_dio ;","ext4_inode_block_unlocked_dio ( inode ) ;ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , flags , mode ) ;up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;if ( ret ) goto out_dio ;",2203
2018,"j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ;if ( j < 0 ) goto partno ;len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ;j += PCI_VPD_INFO_FLD_HDR_SIZE ;if ( j + len > block_end ) goto partno ;memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ;strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ;}","if ( len >= sizeof ( tp -> fw_ver , & vpd_data [ j ] , len ) ;strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ;}",2204
2019,"path -> mnt = mntget ( nd -> path . mnt ) ;if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ;follow_mount ( path ) ;error = 0 ;","path -> mnt = nd -> path . mnt ) ;if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ;mntget ( path -> mnt ) ;follow_mount ( path ) ;error = 0 ;",2205
2020,i ++ ;if ( file -> f_flags & O_NONBLOCK ) {,"if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) {clear_bit ( WDM_OVERFLOW , & desc -> flags ) ;rv = - ENOBUFS ;goto err ;}i ++ ;if ( file -> f_flags & O_NONBLOCK ) {",2206
2021,"enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , MICMD_MIIRD ) ;while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 )  {enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , 0 ) ;data = enc28j60ReadReg ( interface , ENC28J60_REG_MIRDL ) ;data |= enc28j60ReadReg ( interface , ENC28J60_REG_MIRDH ) << 8 ;return data ;","enc28j60WriteReg ( interface , ENC28J60_MIREGADR , address & REG_ADDR_MASK ) ;enc28j60WriteReg ( interface , ENC28J60_MICMD , ENC28J60_MICMD_MIIRD ) ;while ( ( enc28j60ReadReg ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY ) != 0 ) {enc28j60WriteReg ( interface , ENC28J60_MICMD , 0 ) ;data = enc28j60ReadReg ( interface , ENC28J60_MIRDL ) ;data |= enc28j60ReadReg ( interface , ENC28J60_MIRDH ) << 8 ;return data ;",2207
2022,"
",sas_destruct_devices ( port ) ;sas_destruct_ports ( port ) ;sas_probe_devices ( port ) ;,2208
2023,},},2208
2024,"static int  mptctl_readtest ( unsigned long arg )  {MPT_ADAPTER * ioc ;int iocnum ;}if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||  ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_readtest()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;","static int mptctl_readtest ( MPT_ADAPTER * ioc , unsigned long arg ) {",2209
2025,"static void choose_partitioning ( VP9_COMP * cpi ,  const TileInfo * const tile ,  int mi_row , int mi_col ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * x = & cpi -> mb ;MACROBLOCKD * xd = & cpi -> mb . e_mbd ;int i , j , k ;v64x64 vt ;uint8_t * s ;int_mv nearest_mv , near_mv ;const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ;vp9_zero ( vt ) ;set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;if ( xd -> mb_to_right_edge < 0 )  pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ;if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ;s = x -> plane [ 0 ] . src . buf ;sp = x -> plane [ 0 ] . src . stride ;if ( cm -> frame_type != KEY_FRAME ) {vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ;xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ;xd -> mi [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ;vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , xd -> mi [ 0 ] -> mbmi . ref_mvs [ LAST_FRAME ] , & nearest_mv , & near_mv ) ;xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = nearest_mv ;vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , BLOCK_64X64 ) ;dp = xd -> plane [ 0 ] . dst . stride ;}","static int choose_partitioning ( VP9_COMP * cpi , const TileInfo * const tile , MACROBLOCK * x = & cpi -> mb ;MACROBLOCKD * xd = & cpi -> mb . e_mbd ;int i , j , k , m ;v64x64 vt ;v16x16 vt2 [ 16 ] ;int force_split [ 21 ] ;uint8_t * s ;int64_t thresholds [ 4 ] = {cpi -> vbp_thresholds [ 0 ] , cpi -> vbp_thresholds [ 1 ] , cpi -> vbp_thresholds [ 2 ] , cpi -> vbp_thresholds [ 3 ] };const int is_key_frame = ( cm -> frame_type == KEY_FRAME ) ;const YV12_BUFFER_CONFIG * yv12_g = NULL ;unsigned int y_sad , y_sad_g ;const BLOCK_SIZE bsize = BLOCK_32X32 + ( mi_col + 4 < cm -> mi_cols ) * 2 + ( mi_row + 4 < cm -> mi_rows ) ;assert ( yv12 != NULL ) ;if ( ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . spatial_layer_id ) ) {yv12_g = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;}if ( yv12_g && yv12_g != yv12 && ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ) {vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ;mbmi -> ref_frame [ 0 ] = LAST_FRAME ;mbmi -> ref_frame [ 1 ] = NONE ;mbmi -> sb_type = BLOCK_64X64 ;mbmi -> mv [ 0 ] . as_int = 0 ;mbmi -> interp_filter = BILINEAR ;y_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ;if ( y_sad_g < y_sad ) {vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ;mbmi -> ref_frame [ 0 ] = GOLDEN_FRAME ;mbmi -> mv [ 0 ] . as_int = 0 ;y_sad = y_sad_g ;}else {x -> pred_mv [ LAST_FRAME ] = mbmi -> mv [ 0 ] . as_mv ;}vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , & cm -> seg , segment_id , cm -> base_qindex ) ;set_vbp_thresholds ( cpi , thresholds , q ) ;}}set_offsets ( cpi , tile , x , mi_row , mi_col , BLOCK_64X64 ) ;for ( i = 1 ;i <= 2 ;++ i ) {struct macroblock_plane * p = & x -> plane [ i ] ;struct macroblockd_plane * pd = & xd -> plane [ i ] ;const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ;if ( bs == BLOCK_INVALID ) uv_sad = UINT_MAX ;else uv_sad = cpi -> fn_ptr [ bs ] . sdf ( p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride ) ;x -> color_sensitivity [ i - 1 ] = uv_sad > ( y_sad >> 2 ) ;}dp = xd -> plane [ 0 ] . dst . stride ;if ( segment_id == CR_SEGMENT_ID_BASE && y_sad < cpi -> vbp_threshold_sad ) {const int block_width = num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ;const int block_height = num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ;if ( mi_col + block_width / 2 < cm -> mi_cols && mi_row + block_height / 2 < cm -> mi_rows ) {set_block_size ( cpi , x , xd , mi_row , mi_col , BLOCK_64X64 ) ;return 0 ;}}}else {d = VP9_VAR_OFFS ;dp = xd -> plane [ 0 ] . dst . stride ;}",2210
2026,for ( j = 0 ;const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ;const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ;v16x16 * vst = & vt . split [ i ] . split [ j ] ;for ( k = 0 ;k < 4 ;k ++ ) {int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ;int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ;unsigned int sse = 0 ;int sum = 0 ;,"const int i2 = i << 2 ;force_split [ i + 1 ] = 0 ;for ( j = 0 ;const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ;const int split_index = 5 + i2 + j ;const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ;v16x16 * vst = & vt . split [ i ] . split [ j ] ;force_split [ split_index ] = 0 ;variance4x4downsample [ i2 + j ] = 0 ;if ( ! is_key_frame ) {fill_variance_8x8avg ( s , sp , d , dp , x16_idx , y16_idx , vst , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ;fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ;get_variance ( & vt . split [ i ] . split [ j ] . part_variances . none ) ;if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 2 ] ) {force_split [ split_index ] = 1 ;force_split [ i + 1 ] = 1 ;force_split [ 0 ] = 1 ;}else if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 1 ] && ! cyclic_refresh_segment_id_boosted ( segment_id ) ) {int x8_idx = x16_idx + ( ( k & 1 ) << 3 ) ;int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ;unsigned int sse = 0 ;int sum = 0 ;",2210
2027,"for ( j = 0 ;fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ;}fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ;}fill_variance_tree ( & vt , BLOCK_64X64 ) ;if ( ! set_vt_partitioning ( cpi , & vt , tile , BLOCK_64X64 ,   mi_row , mi_col , 8 ) ) {for ( i = 0 ;if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , tile , BLOCK_32X32 ,   ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , 4 ) ) {for ( j = 0 ;const int y16_idx = ( ( j >> 1 ) << 1 ) ;# define DISABLE_8X8_VAR_BASED_PARTITION  # ifdef DISABLE_8X8_VAR_BASED_PARTITION  if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows &&   mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) {set_block_size ( cpi , tile , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , BLOCK_16X16 ) ;}else {const int y8_idx = ( k >> 1 ) ;set_block_size ( cpi , tile ,  ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ;}}# else  if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile ,  BLOCK_16X16 ,  ( mi_row + y32_idx + y16_idx ) ,   ( mi_col + x32_idx + x16_idx ) , 2 ) ) {for ( k = 0 ;set_block_size ( cpi , tile ,  ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ;# endif  }","const int i2 = i << 2 ;for ( j = 0 ;if ( variance4x4downsample [ i2 + j ] == 1 ) {v16x16 * vtemp = ( ! is_key_frame ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . part_variances . none ) ;if ( vt . split [ i ] . part_variances . none . variance > thresholds [ 1 ] ) {force_split [ i + 1 ] = 1 ;force_split [ 0 ] = 1 ;}}}if ( ! force_split [ 0 ] ) {fill_variance_tree ( & vtemp -> split [ m ] , BLOCK_8X8 ) ;fill_variance_tree ( vtemp , BLOCK_16X16 ) ;}}fill_variance_tree ( & vt , BLOCK_64X64 ) ;get_variance ( & vt . split [ j ] , BLOCK_16X16 ) ;}fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ;}fill_variance_tree ( & vt . part_variances . none ) ;}if ( mi_col + 8 > cm -> mi_cols || mi_row + 8 > cm -> mi_rows || ! set_vt_partitioning ( cpi , x , xd , & vt , BLOCK_64X64 , mi_row , mi_col , 8 ) ) {for ( i = 0 ;const int i2 = i << 2 ;if ( ! set_vt_partitioning ( cpi , x , xd , & vt . split [ i ] , BLOCK_32X32 , ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , thresholds [ 1 ] , BLOCK_16X16 , force_split [ i + 1 ] ) ) {for ( j = 0 ;v16x16 * vtemp = ( ! is_key_frame && variance4x4downsample [ i2 + j ] == 1 ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ;if ( ! set_vt_partitioning ( cpi , x , xd , vtemp , BLOCK_16X16 , mi_row + y32_idx + y16_idx , mi_col + x32_idx + x16_idx + 1 < cm -> mi_cols ) {set_block_size ( cpi , tile , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx , thresholds [ 2 ] , cpi -> vbp_bsize_min , force_split [ 5 + i2 + j ] ) ) {if ( use_4x4_partition ) {if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile , BLOCK_16X16 , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , 2 ) ) {for ( k = 0 ;set_block_size ( cpi , x , xd , & vtemp -> split [ k ] , BLOCK_8X8 , mi_row + y32_idx + y16_idx + y8_idx , mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ;}}return 0 ;",2210
2028,"static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de ,  struct inode * inode , int regard_xa )  {int cnt , sig ;struct inode * reloc ;if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ;init_rock_state ( & rs , inode ) ;setup_rock_ridge ( de , inode , & rs ) ;if ( regard_xa ) {rs . chr += 14 ;","static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de , struct inode * inode , int flags ) {int cnt , sig ;unsigned int reloc_block ;struct inode * reloc ;if ( flags & RR_REGARD_XA ) {rs . chr += 14 ;",2211
2029,"case SIG ( \'S\' , \'L\' ) : {","case SIG ( \'S\' , \'L\' ) : if ( flags & RR_RELOC_DE ) {printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\\goto eio ;}reloc_block = isonum_733 ( rr -> u . CL . location ) ;if ( reloc_block == {",2211
2030,"case SIG ( \'C\' , \'L\' ) :  ISOFS_I ( inode ) -> i_first_extent =  isonum_733 ( rr -> u . CL . location ) ;reloc =  isofs_iget ( inode -> i_sb ,   ISOFS_I ( inode ) -> i_first_extent ,  0 ) ;","case SIG ( \'C\' , \'L\' ) : ISOFS_I ( inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) {printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\\goto eio ;}ISOFS_I ( inode ) -> i_first_extent = reloc_block ;reloc = isofs_iget_reloc ( inode -> i_sb , ISOFS_I ( inode ) -> i_first_extent , 0 ) ;",2211
2031,"if ( regs && ! perf_exclude_event ( event , regs ) ) {if ( ! ( event -> attr . exclude_idle && current -> pid == 0 ) )  if ( perf_event_overflow ( event , 0 , & data , regs ) )  ret = HRTIMER_NORESTART ;","if ( regs && ! perf_exclude_event ( event , & data , regs ) ) ret = HRTIMER_NORESTART ;",2212
2032,"struct pstore * ps = get_info ( store ) ;uint32_t stride ;chunk_t next_free ;stride = ( ps -> exceptions_per_area + 1 ) ;next_free = ++ ps -> next_free ;if ( sector_div ( next_free , stride ) == 1 )  ps -> next_free ++ ;atomic_inc ( & ps -> pending_count ) ;","struct pstore * ps = get_info ( store ) ;ps -> next_free ;if ( sector_div ( next_free , stride ) == 1 ) ps -> next_free ++ ;skip_metadata ( ps ) ;atomic_inc ( & ps -> pending_count ) ;",2213
2033,return - ETIMEDOUT ;},kfree_skb ( skb ) ;return - ETIMEDOUT ;},2214
2034,"fc = EXTRACT_LE_16BITS ( p ) ;seq = EXTRACT_LE_8BITS ( p + 2 ) ;p += 3 ;caplen -= 3 ;ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ;if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ;switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) {case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;break ;case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;return hdrlen ;case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}panid = EXTRACT_LE_16BITS ( p ) ;if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag )  ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ;p += 2 ;caplen -= 2 ;hdrlen += 2 ;",fc = EXTRACT_LE_16BITS ( p ) ) ) ;,2215
2035,"stmt_ty AsyncFunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq  * decorator_list , expr_ty returns , int lineno , int col_offset ,  int end_lineno , int end_col_offset , PyArena * arena ) {","stmt_ty AsyncFunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq * decorator_list , expr_ty returns , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",2216
2036,p -> v . AsyncFunctionDef . returns = returns ;p -> lineno = lineno ;,p -> v . AsyncFunctionDef . returns = returns ;p -> v . AsyncFunctionDef . type_comment = type_comment ;p -> lineno = lineno ;,2216
2037,frag = ( hm_fragment * ) item -> data ;OPENSSL_free ( frag -> fragment ) ;,frag = ( hm_fragment * ) item -> data ;OPENSSL_free ( frag -> fragment ) ;,2217
2038,if ( ( entry -> flags & SC_ASN1_UNSIGNED )  && obj [ 0 ] == 0x00 && objlen > 1 ) {objlen -- ;,if ( ( entry -> flags & SC_ASN1_UNSIGNED ) && objlen > 1 && obj [ 0 ] == 0x00 ) {objlen -- ;,2218
2039,"err |= get_user ( length , & up -> length ) ;up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ;","err |= get_user ( length , & up -> length ) ;if ( err ) return - EFAULT ;up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ;",2219
2040,if ( map_data )  copy = true ;,if ( ! iter_is_iovec ( iter ) ) goto fail ;if ( map_data ) copy = true ;,2220
2041,rq -> bio = NULL ;return - EINVAL ;,fail : rq -> bio = NULL ;return - EINVAL ;,2220
2042,"opt = xchg ( & np -> opt , NULL ) ;if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;pktopt = xchg ( & np -> pktoptions , NULL ) ;","opt = xchg ( ( __force struct ipv6_txoptions * * ) & np -> opt , NULL ) ;if ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}pktopt = xchg ( & np -> pktoptions , NULL ) ;",2221
2043,"opt = ipv6_renew_options ( sk , np -> opt , optname ,  ( struct ipv6_opt_hdr __user * ) optval , optlen ) ;if ( IS_ERR ( opt ) ) {retv = PTR_ERR ( opt ) ;","opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ;opt = ipv6_renew_options ( sk , opt , optname , ( struct ipv6_opt_hdr __user * ) optval , optlen ) ;if ( IS_ERR ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}",2221
2044,"sticky_done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;","sticky_done : if ( opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;",2221
2045,"
","atomic_set ( & opt -> refcnt , 1 ) ;",2221
2046,opt -> tot_len = sizeof ( * opt ) + optlen ;retv = - EFAULT ;,opt -> tot_len = sizeof ( * opt ) + optlen ;retv = - EFAULT ;,2221
2047,"done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;","done : if ( opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;",2221
2048,uint16_t auxsize ;if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ;,uint16_t auxsize ;int ret ;if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ;,2222
2049,"av_get_packet ( pb , pkt , vsize ) ;pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ;","if ( ( ret = av_get_packet ( pb , pkt , vsize ) ) < 0 ) return ret ;pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ;",2222
2050,"av_get_packet ( pb , pkt , asize ) ;pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ;","if ( ( ret = av_get_packet ( pb , pkt , asize ) ) < 0 ) return ret ;pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ;",2222
2051,RBinWasmGlobalEntry * ptr = NULL ;int buflen = bin -> buf -> length ;if ( sec -> payload_data + 32 > buflen ) {return NULL ;},RBinWasmGlobalEntry * ptr = NULL ;int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ;,2223
2052,"if ( first_mb_in_slice == 0 ) {if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) {field_end ( h , 1 ) ;}h0 -> current_slice = 0 ;if ( ! h0 -> first_field ) {if ( h -> cur_pic_ptr && ! h -> droppable ) {ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ;}h -> cur_pic_ptr = NULL ;}}slice_type = get_ue_golomb_31 ( & h -> gb ) ;if ( slice_type > 9 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""slice<S2SV_blank>type<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>%d\\\return AVERROR_INVALIDDATA ;}if ( slice_type > 4 ) {slice_type -= 5 ;h -> slice_type_fixed = 1 ;}else h -> slice_type_fixed = 0 ;slice_type = golomb_to_pict_type [ slice_type ] ;h -> slice_type = slice_type ;h -> slice_type_nos = slice_type & 3 ;h -> pict_type = h -> slice_type ;pps_id = get_ue_golomb ( & h -> gb ) ;if ( pps_id >= MAX_PPS_COUNT ) {av_log ( h -> avctx , AV_LOG_ERROR , ""pps_id<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\return AVERROR_INVALIDDATA ;}if ( ! h0 -> pps_buffers [ pps_id ] ) {av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>PPS<S2SV_blank>%u<S2SV_blank>referenced\\\return AVERROR_INVALIDDATA ;}h -> pps = * h0 -> pps_buffers [ pps_id ] ;if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] ) {av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>SPS<S2SV_blank>%u<S2SV_blank>referenced\\\return AVERROR_INVALIDDATA ;}if ( h -> pps . sps_id != h -> current_sps_id || h0 -> sps_buffers [ h -> pps . sps_id ] -> new ) {h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 ;h -> current_sps_id = h -> pps . sps_id ;h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ] ;if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc ) needs_reinit = 1 ;if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc ) {h -> bit_depth_luma = h -> sps . bit_depth_luma ;h -> chroma_format_idc = h -> sps . chroma_format_idc ;needs_reinit = 1 ;}if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 ) return ret ;}h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ) ;h -> avctx -> level = h -> sps . level_idc ;h -> avctx -> refs = h -> sps . ref_frame_count ;must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ) ;if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) ) must_reinit = 1 ;h -> mb_width = h -> sps . mb_width ;h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ;h -> mb_num = h -> mb_width * h -> mb_height ;h -> mb_stride = h -> mb_width + 1 ;h -> b_stride = h -> mb_width * 4 ;h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1 ;h -> width = 16 * h -> mb_width ;h -> height = 16 * h -> mb_height ;ret = init_dimensions ( h ) ;if ( ret < 0 ) return ret ;if ( h -> sps . video_signal_type_present_flag ) {h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG ;if ( h -> sps . colour_description_present_flag ) {if ( h -> avctx -> colorspace != h -> sps . colorspace ) needs_reinit = 1 ;h -> avctx -> color_primaries = h -> sps . color_primaries ;h -> avctx -> color_trc = h -> sps . color_trc ;h -> avctx -> colorspace = h -> sps . colorspace ;}}if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) ) {if ( h != h0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""changing<S2SV_blank>width/height<S2SV_blank>on<S2SV_blank>"" ""slice<S2SV_blank>%d\\\return AVERROR_INVALIDDATA ;}flush_change ( h ) ;if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ;h -> avctx -> pix_fmt = ret ;av_log ( h -> avctx , AV_LOG_INFO , ""Reinit<S2SV_blank>context<S2SV_blank>to<S2SV_blank>%dx%d,<S2SV_blank>"" ""pix_fmt:<S2SV_blank>%s\\\if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\\return ret ;}}if ( ! h -> context_initialized ) {if ( h != h0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""Cannot<S2SV_blank>(re-)initialize<S2SV_blank>context<S2SV_blank>during<S2SV_blank>parallel<S2SV_blank>decoding.\\\return AVERROR_PATCHWELCOME ;}if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ;h -> avctx -> pix_fmt = ret ;if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\\return ret ;}}if ( h == h0 && h -> dequant_coeff_pps != pps_id ) {h -> dequant_coeff_pps = pps_id ;init_dequant_tables ( h ) ;}h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ) ;h -> mb_mbaff = 0 ;h -> mb_aff_frame = 0 ;last_pic_structure = h0 -> picture_structure ;last_pic_droppable = h0 -> droppable ;h -> droppable = h -> nal_ref_idc == 0 ;if ( h -> sps . frame_mbs_only_flag ) {h -> picture_structure = PICT_FRAME ;}else {if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B ) {av_log ( h -> avctx , AV_LOG_ERROR , ""This<S2SV_blank>stream<S2SV_blank>was<S2SV_blank>generated<S2SV_blank>by<S2SV_blank>a<S2SV_blank>broken<S2SV_blank>encoder,<S2SV_blank>invalid<S2SV_blank>8x8<S2SV_blank>inference\\\return - 1 ;}field_pic_flag = get_bits1 ( & h -> gb ) ;if ( field_pic_flag ) {bottom_field_flag = get_bits1 ( & h -> gb ) ;h -> picture_structure = PICT_TOP_FIELD + bottom_field_flag ;}else {h -> picture_structure = PICT_FRAME ;h -> mb_aff_frame = h -> sps . mb_aff ;}}h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME ;if ( h0 -> current_slice != 0 ) {if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable ) {av_log ( h -> avctx , AV_LOG_ERROR , ""Changing<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>(%d<S2SV_blank>-><S2SV_blank>%d)<S2SV_blank>between<S2SV_blank>slices<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\\h -> picture_structure = last_pic_structure ;h -> droppable = last_pic_droppable ;return AVERROR_INVALIDDATA ;}else if ( ! h0 -> cur_pic_ptr ) {",if ( h0 -> cur_pic_ptr ) {,2224
2053,"if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;","if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;",2224
2054,"const int v = ( int ) ( .5 + 256 * vp8_gaussian ( sigma , 0 , i ) ) ;if ( v ) {","const int v = ( int ) ( .5 + 256 * gaussian ( sigma , 0 , i ) ) ;if ( v ) {",2225
2055,uint64 nstrips64 ;uint32 nstrips32 ;,uint32 nstrips ;,2226
2056,"nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ;if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) )  return ;newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripByteCounts\\\\""<S2SV_blank>array"" ) ;newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripOffsets\\\\""<S2SV_blank>array"" ) ;for ( strip = 0 ;strip < nstrips32 ;if ( stripbytes > bytecount ) stripbytes = bytecount ;newcounts [ strip ] = stripbytes ;newoffsets [ strip ] = offset ;offset += stripbytes ;td -> td_stripsperimage = td -> td_nstrips = nstrips32 ;TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ;","nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ;if ( nstrips == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) return ;newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips , sizeof ( uint64 ) , ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripByteCounts\\\\""<S2SV_blank>array"" ) ;newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips , sizeof ( uint64 ) , ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripOffsets\\\\""<S2SV_blank>array"" ) ;for ( strip = 0 ;strip < nstrips ;if ( stripbytes > bytecount ) stripbytes = bytecount ;newcounts [ strip ] = stripbytes ? offset : 0 ;offset += stripbytes ;td -> td_stripsperimage = td -> td_nstrips = nstrips ;TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ;",2226
2057,"assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ;memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ;","memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ;",2227
2058,int result ;D_imp_xxh ( dbh ) ;,int result ;int fresh = 0 ;D_imp_xxh ( dbh ) ;,2228
2059,"Newz ( 908 , imp_dbh -> pmysql , 1 , MYSQL ) ;}if ( ! result )   Safefree ( imp_dbh -> pmysql ) ;return result ;","fresh = 1 ;Newz ( 908 , imp_dbh -> pmysql , 1 , MYSQL ) ;}if ( fresh && ! result ) {do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ;Safefree ( imp_dbh -> pmysql ) ;imp_dbh -> pmysql = NULL ;}return result ;",2228
2060,"strcpy ( cat_enum . szPath , fileName ) ;sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ;strcpy ( cat_enum . szRad1 , fileName ) ;}strcpy ( cat_enum . szRad1 , sep + 1 ) ;sep [ 0 ] = 0 ;}sep = strchr ( cat_enum . szRad1 , \'*\' ) ;strcpy ( cat_enum . szRad2 , sep + 1 ) ;sep [ 0 ] = 0 ;sep = strchr ( cat_enum . szRad2 , \'%\' ) ;if ( ! sep ) sep = strchr ( cat_enum . szRad2 , \'#\' ) ;if ( sep ) {strcpy ( cat_enum . szOpt , sep ) ;","if ( strlen ( fileName ) >= sizeof ( cat_enum . szPath ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\\return GF_NOT_SUPPORTED ;}strcpy ( cat_enum . szPath , fileName ) ;sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ;if ( strlen ( fileName ) >= sizeof ( cat_enum . szRad1 ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\\return GF_NOT_SUPPORTED ;}strcpy ( cat_enum . szRad1 , fileName ) ;}if ( strlen ( sep + 1 ) ;sep [ 0 ] = 0 ;}sep = strchr ( cat_enum . szRad1 , \'*\' ) ;strcpy ( cat_enum . szRad2 , sep + 1 ) >= sizeof ( cat_enum . szRad2 , \'%\' ) ;if ( ! sep ) sep = strchr ( cat_enum . szRad2 , \'#\' ) ;if ( sep ) {if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Invalid<S2SV_blank>option:<S2SV_blank>%s.\\\return GF_NOT_SUPPORTED ;}strcpy ( cat_enum . szOpt , sep ) ;}",2229
2061,"stbbr_send ( ""<presence<S2SV_blank>to=\\\'stabber@localhost\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ;assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\\\""On<S2SV_blank>my<S2SV_blank>mobile\\\\"""" ) ) ;prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ;assert_true ( prof_output_exact ( ""unencrypted"" ) ) ;stbbr_send (  ""<message<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost\\\'>""  ""<received<S2SV_blank>xmlns=\\\'urn:xmpp:carbons:2\\\'>"" ""<forwarded<S2SV_blank>xmlns=\\\'urn:xmpp:forward:0\\\'>"" ""<message<S2SV_blank>id=\\\'prof_msg_7\\\'<S2SV_blank>xmlns=\\\'jabber:client\\\'<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>lang=\\\'en\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ;","stbbr_send ( ""<message<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'stabber@localhost\\\'>"" ""<received<S2SV_blank>xmlns=\\\'urn:xmpp:carbons:2\\\'>"" ""<forwarded<S2SV_blank>xmlns=\\\'urn:xmpp:forward:0\\\'>"" ""<message<S2SV_blank>id=\\\'prof_msg_7\\\'<S2SV_blank>xmlns=\\\'jabber:client\\\'<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>lang=\\\'en\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ;",2230
2062,int n ;assert ( cnt >= 0 ) ;,ssize_t n ;assert ( cnt >= 0 ) ;,2231
2063,"# define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\\","# define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\\",2232
2064,"}# define EXIFMultipleFractions ( size , format , arg1 , arg2 ) {","\\\\\# define EXIFMultipleFractions ( size , format , arg1 , arg2 ) \\\\\",2232
2065,}typedef struct _DirectoryInfo {,\\\\\typedef struct _DirectoryInfo {,2232
2066,"
",if ( q > ( exif + length - 12 ) ) break ;,2232
2067,"
",if ( components < 0 ) break ;,2232
2068,"if ( GetValueFromSplayTree ( exif_resources , q ) == q )  break ;components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;number_bytes = ( size_t ) components * tag_bytes [ format ] ;","if ( GetValueFromSplayTree ( exif_resources , q ) == q ) break ;components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;number_bytes = ( size_t ) components * tag_bytes [ format ] ;",2232
2069,if ( fuji_width )  {,# ifdef LIBRAW_LIBRARY_BUILD if ( fuji_width && ! dng_version && ! ( imgdata . process_warnings & LIBRAW_WARN_PARSEFUJI_PROCESSED ) ) fuji_width = 0 ;# endif if ( fuji_width ) {,2233
2070,if ( daddr == 0 || rs -> rs_bound_addr == 0 ) {ret = - ENOTCONN ;goto out ;}if ( payload_len > rds_sk_sndbuf ( rs ) ) {,lock_sock ( sk ) ;if ( daddr == 0 || rs -> rs_bound_addr == 0 ) {release_sock ( sk ) ;ret = - ENOTCONN ;goto out ;}release_sock ( sk ) ;if ( payload_len > rds_sk_sndbuf ( rs ) ) {,2234
2071,fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ;fptr -> frag_off = htons ( offset ) ;,if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ;fptr -> frag_off = htons ( offset ) ;,2235
2072,# endif  if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) {,# else ( void ) mb_idx ;# endif if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) {,2236
2073,"vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;vp8_conceal_corrupt_mb ( xd ) ;vpx_memset ( xd -> eobs , 0 , 25 ) ;}","memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;vp8_conceal_corrupt_mb ( xd ) ;memset ( xd -> eobs , 0 , 25 ) ;}",2236
2074,"if ( xd -> mode_info_context -> mbmi . mb_skip_coeff )  vpx_memset ( xd -> eobs , 0 , 25 ) ;intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ;","if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) memset ( xd -> eobs , 0 , 25 ) ;intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ;",2236
2075,"else {vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}","memset ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;",2236
2076,"vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}","memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}",2236
2077,"static void show_object ( struct object * object , struct strbuf * path ,   const char * last , void * data )  {if ( bitmap_pos < 0 ) {char * name = path_name ( path , last ) ;bitmap_pos = ext_index_add_object ( object , name ) ;free ( name ) ;}","static void show_object ( struct object * object , const char * last , void * data ) {if ( bitmap_pos < 0 ) bitmap_pos = ext_index_add_object ( object , name ) ;free ( name ) ;}",2237
2078,"s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",2238
2079,"if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) {absolute_filename = g_strdup ( filename ) ;",if ( g_path_is_absolute ( filename ) ) {absolute_filename = g_strdup ( filename ) ;,2239
2080,if ( qop_req != 0 ) {if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,if ( ctx -> terminated || qop_req != 0 ) {if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,2240
2081,slave -> master = master ;slave -> timer = master -> timer ;spin_unlock_irq ( & slave_active_lock ) ;},spin_lock ( & master -> timer -> lock ) ;slave -> master = master ;slave -> timer = master -> timer ;spin_unlock ( & master -> timer -> lock ) ;spin_unlock_irq ( & slave_active_lock ) ;},2241
2082,"static char * print_number ( cJSON * item )  {char * str ;double f , f2 ;int64_t i ;str = ( char * ) cJSON_malloc ( 64 ) ;if ( str ) {f = item -> valuefloat ;i = f ;if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint <= LLONG_MAX )  sprintf ( str , ""%lld"" , ( long long ) item -> valueint ) ;else sprintf ( str , ""%g"" , item -> valuefloat ) ;","static char * print_number ( cJSON * item , printbuffer * p ) {char * str = 0 ;double d = item -> valuefloat ;i = f ;if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint ) - d ) <= DBL_EPSILON && d <= LLONG_MAX && d >= LLONG_MIN ) {if ( p ) str = ensure ( p , 64 ) ;else str = ( char * ) cJSON_malloc ( 64 ) ;if ( str ) sprintf ( str , ""%lld"" , ( long long ) item -> valueint ) ;}else {if ( p ) str = ensure ( p , 64 ) ;else str = ( char * ) cJSON_malloc ( 64 ) ;if ( str ) {if ( fpclassify ( d ) != FP_ZERO && ! isnormal ( d ) ) sprintf ( str , ""null"" ) ;else if ( fabs ( floor ( d ) - d ) <= DBL_EPSILON && fabs ( d ) < 1.0e60 ) sprintf ( str , ""%.0f"" , d ) ;else if ( fabs ( d ) < 1.0e-6 || fabs ( d ) > 1.0e9 ) sprintf ( str , ""%e"" , d ) ;else sprintf ( str , ""%f"" , d ) ;}",2242
2083,"static uint32_t scsi_init_iovec ( SCSIDiskReq * r )  {r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;","static uint32_t scsi_init_iovec ( SCSIDiskReq * r ) {SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ;if ( ! r -> iov . iov_base ) {r -> buflen = SCSI_DMA_BUF_SIZE ;r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ;}r -> iov . iov_len = MIN ( r -> sector_count * 512 , r -> buflen ) ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;",2243
2084,"return headcount ;err : vhost_discard_vq_desc ( vq , headcount ) ;","if ( unlikely ( datalen > 0 ) ) {r = UIO_MAXIOV + 1 ;goto err ;}return headcount ;err : vhost_discard_vq_desc ( vq , headcount ) ;",2244
2085,ps_cur_slice -> u1_field_pic_flag = 0 ;i4_frame_gaps = 0 ;,i4_frame_gaps = 0 ;,2245
2086,"memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ;if ( p -> fname ) {if ( priv -> ctrl . fname == NULL )  rc = - ENOMEM ;}","priv -> ctrl . fname = NULL ;memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ;if ( p -> fname ) {if ( priv -> ctrl . fname == NULL ) return - ENOMEM ;}",2246
2087,"if ( ( ctxt -> options & XML_PARSE_OLD10 ) == 0 ) {if ( ( c == \'<S2SV_blank>\' ) || ( c == \'>\' ) || ( c == \'/\' ) || ( ! ( ( ( c >= \'a\' ) && ( c <= \'z\' ) ) || ( ( c >= \'A\' ) && ( c <= \'Z\' ) ) || ( c == \'_\' ) || ( c == \':\' ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) ) {return ( NULL ) ;len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;while ( ( c != \'<S2SV_blank>\' ) && ( c != \'>\' ) && ( c != \'/\' ) && ( ( ( c >= \'a\' ) && ( c <= \'z\' ) ) || ( ( c >= \'A\' ) && ( c <= \'Z\' ) ) || ( ( c >= \'0\' ) && ( c <= \'9\' ) ) || ( c == \'_\' ) || ( c == \':\' ) || ( c == \'-\' ) || ( c == \'.\' ) || ( c == 0xB7 ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x300 ) && ( c <= 0x36F ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x203F ) && ( c <= 0x2040 ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) {if ( count ++ > XML_PARSER_CHUNK_SIZE ) {count = 0 ;GROW ;if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ;}len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;}else {if ( ( c == \'<S2SV_blank>\' ) || ( c == \'>\' ) || ( c == \'/\' ) || ( ! IS_LETTER ( c ) && ( c != \'_\' ) && ( c != \':\' ) ) ) {len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;while ( ( c != \'<S2SV_blank>\' ) && ( c != \'>\' ) && ( c != \'/\' ) && ( ( IS_LETTER ( c ) ) || ( IS_DIGIT ( c ) ) || ( c == \'.\' ) || ( c == \'-\' ) || ( c == \'_\' ) || ( c == \':\' ) || ( IS_COMBINING ( c ) ) || ( IS_EXTENDER ( c ) ) ) ) {if ( count ++ > XML_PARSER_CHUNK_SIZE ) {count = 0 ;GROW ;if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ;}len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;if ( c == 0 ) {count = 0 ;GROW ;if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ;c = CUR_CHAR ( l ) ;}}}if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) {xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ;return ( NULL ) ;","if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) {xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ;if ( ctxt -> input -> cur - ctxt -> input -> base < len ) {xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , ""unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"" ) ;return ( NULL ) ;",2247
2088,if ( image -> depth == 1 )  return ( ( image -> columns + 7 ) / 8 ) ;else return ( image -> columns * GetPSDPacketSize ( image ) ) ;,if ( image -> depth == 1 ) return ( ( ( image -> columns + 7 ) / 8 ) * GetPSDPacketSize ( image ) ) ;else return ( image -> columns * GetPSDPacketSize ( image ) ) ;,2248
2089,"p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_AUDIO_FORMAT ) ;sprintf ( nhml , ""bitsPerSample=\\\\""%d\\\\""<S2SV_blank>"" , gf_audio_fmt_bit_depth ( p -> value . uint ) ) ;","p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_AUDIO_FORMAT ) ;if ( p ) sprintf ( nhml , ""bitsPerSample=\\\\""%d\\\\""<S2SV_blank>"" , gf_audio_fmt_bit_depth ( p -> value . uint ) ) ;",2249
2090,"bit_set_position ( dat , restartpos ) ;if ( i >= 0 && i < ( int ) dwg -> num_classes ) {","bit_set_position ( dat , restartpos ) ;obj -> supertype = DWG_SUPERTYPE_UNKNOWN ;if ( i >= 0 && i < ( int ) dwg -> num_classes ) {",2250
2091,"obj -> supertype = DWG_SUPERTYPE_UNKNOWN ;obj -> type = 0 ;if ( klass && ! is_entity )  {int err = dwg_decode_UNKNOWN_OBJ ( dat , obj ) ;error |= err ;obj -> supertype = DWG_SUPERTYPE_UNKNOWN ;if ( err >= DWG_ERR_CRITICAL )  * dat = abs_dat ;}else if ( klass ) {","obj -> type = 0 ;if ( is_entity ) error |= dwg_decode_UNKNOWN_ENT ( dat , obj ) ;else error |= dwg_decode_UNKNOWN_OBJ ( dat , obj ) ;if ( err >= DWG_ERR_CRITICAL ) * dat = abs_dat ;}else if ( klass ) {",2250
2092,if ( ! dat ) return error ;if ( err >= DWG_ERR_CRITICAL ) * dat = abs_dat ;,if ( error >= DWG_ERR_CRITICAL ) * dat = abs_dat ;,2250
2093,value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ;return ( ( unsigned short ) ( value & 0xffff ) ) ;}value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) |  ( ( unsigned char * ) buffer ) [ 1 ] ) ;return ( ( unsigned short ) ( value & 0xffff ) ) ;},value = ( unsigned short ) buffer [ 1 ] << 8 ) | buffer [ 0 ] ;return ( ( unsigned short ) ( value & 0xffff ) ) ;}value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | ( ( unsigned char * ) buffer ) [ 1 ] ) ;return ( value & 0xffff ) ;},2251
2094,libettercap_init ( ) ;ef_globals_alloc ( ) ;,int ret_value = 0 ;libettercap_init ( ) ;ef_globals_alloc ( ) ;,2252
2095,"if ( write_output ( ) != E_SUCCESS )  FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ;","ret_value = write_output ( ) != E_SUCCESS ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ;",2252
2096,"down_write ( & mm -> mmap_sem ) ;mutex_lock ( & ufile -> umap_lock ) ;list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) {","down_write ( & mm -> mmap_sem ) ;if ( ! mmget_still_valid ( mm ) ) goto skip_mm ;mutex_lock ( & ufile -> umap_lock ) ;skip_mm : list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) {",2253
2097,up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,2253
2098,"kref_put ( & reservations -> refs , resv_map_release ) ;if ( reserve ) {",resv_map_put ( vma ) ;if ( reserve ) {,2254
2099,int err ;dp -> dccps_role = DCCP_ROLE_CLIENT ;if ( inet -> opt != NULL && inet -> opt -> srr ) {if ( daddr == 0 ) return - EINVAL ;nexthop = inet -> opt -> faddr ;},"int err ;struct ip_options_rcu * inet_opt ;dp -> dccps_role = DCCP_ROLE_CLIENT ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt != NULL && inet_opt -> opt . srr ) {if ( daddr == 0 ) return - EINVAL ;nexthop = inet_opt -> opt . faddr ;}",2255
2100,if ( inet -> opt == NULL || ! inet -> opt -> srr )  daddr = rt -> rt_dst ;if ( inet -> inet_saddr == 0 ) inet -> inet_saddr = rt -> rt_src ;inet -> inet_rcv_saddr = inet -> inet_saddr ;inet -> inet_dport = usin -> sin_port ;inet -> inet_daddr = daddr ;inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;if ( inet -> opt != NULL )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ;,if ( inet_opt == NULL || ! inet -> opt -> srr ) daddr = rt -> rt_dst ;if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . optlen ;,2255
2101,ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ;ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ;,if ( ps_dec -> u2_forw_f_code < 1 || ps_dec -> u2_forw_f_code > 7 || ps_dec -> u2_back_f_code < 1 || ps_dec -> u2_back_f_code > 7 ) {return IMPEG2D_UNKNOWN_ERROR ;}ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ;ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ;,2256
2102,"sas_discover_event ( dev -> port , DISCE_PROBE ) ;return 0 ;",return 0 ;,2257
2103,"if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) {ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ;","if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ;",2258
2104,for ( n = 0 ;n ++ )  {,"if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;for ( n = 0 ;n ++ ) {",2258
2105,"sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ;sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_port = 0 ;* addr_len = sizeof ( * sin6 ) ;if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;","if ( sin ) {sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;}if ( isk -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;if ( sin6 ) {sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_port = 0 ;* addr_len = sizeof ( * sin6 ) ;}if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;",2259
2106,pvc . sap_family = AF_ATMPVC ;pvc . sap_addr . itf = vcc -> dev -> number ;,"memset ( & pvc , 0 , sizeof ( pvc ) ) ;pvc . sap_family = AF_ATMPVC ;pvc . sap_addr . itf = vcc -> dev -> number ;",2260
2107,char * bufptr ;bufptr = buf ;,"char * bufptr ;if ( cnt < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ;}bufptr = buf ;",2261
2108,if ( ! retval ) {r = strdup ( realm ) ;if ( ! r ) {retval = ENOMEM ;}},"if ( ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ;",2262
2109,"if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) )   task -> task_state_flags |= SAS_TASK_STATE_ABORTED ;spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ;}","if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) {task -> task_state_flags |= SAS_TASK_STATE_ABORTED ;}spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ;}",2263
2110,"assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ;( void ) memcpy ( ( ( char * ) buf ) + offs ,  ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ;return len ;","size_t ss = CDF_SHORT_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;assert ( ss == len ) ;if ( sst -> sst_len < ( size_t ) id ) {DPRINTF ( ( ""bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\\return - 1 ;}( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ;return len ;",2264
2111,"static void  l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat )  {const uint16_t * ptr = ( const uint16_t * ) dat ;ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_authentype2str , ""AuthType-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ;","static void l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint16_t * ptr = ( const uint16_t * ) dat ;if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_authentype2str , ""AuthType-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ;",2265
2112,"oe_errno = 0 ;if ( ! sock )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( optlen )  optlen_in = * optlen ;if ( oe_syscall_getsockopt_ocall (  & ret , sock -> host_fd , level , optname , optval , optlen_in , optlen ) !=  OE_OK ) {done :  return ret ;","oe_socklen_t optlen_out = 0 ;oe_errno = 0 ;if ( ! sock || ! optval || ! optlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ;optlen_in = * optlen ;if ( oe_syscall_getsockopt_ocall ( & ret , sock -> host_fd , level , optname , optval , optlen_in , & optlen_out ) != OE_OK ) {if ( optlen_out > optlen_in ) optlen_out = optlen_in ;* optlen = optlen_out ;done : return ret ;",2266
2113,"return crypto_skcipher_setkey ( private , key , keylen ) ;}","struct skcipher_tfm * tfm = private ;int err ;err = crypto_skcipher_setkey ( tfm -> skcipher , key , keylen ) ;tfm -> has_key = ! err ;return err ;}",2267
2114,"if ( l_strnstart ( ""MSG"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>MSG"" ) ) ;else if ( l_strnstart ( ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>RPY"" ) ) ;else if ( l_strnstart ( ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ERR"" ) ) ;else if ( l_strnstart ( ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ANS"" ) ) ;else if ( l_strnstart ( ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>NUL"" ) ) ;else if ( l_strnstart ( ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>SEQ"" ) ) ;else if ( l_strnstart ( ""END"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>END"" ) ) ;","if ( l_strnstart ( ndo , ""MSG"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>MSG"" ) ) ;else if ( l_strnstart ( ndo , ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>RPY"" ) ) ;else if ( l_strnstart ( ndo , ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ERR"" ) ) ;else if ( l_strnstart ( ndo , ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ANS"" ) ) ;else if ( l_strnstart ( ndo , ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>NUL"" ) ) ;else if ( l_strnstart ( ndo , ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>SEQ"" ) ) ;else if ( l_strnstart ( ndo , ""END"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>END"" ) ) ;",2268
2115,"case BPLIST_DATA :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_STRING :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_UNICODE : if ( size * 2 < size ) {if ( * object + size * 2 > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_SET : case BPLIST_ARRAY :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\","case BPLIST_DATA : if ( * object + size < * object || * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_STRING : if ( * object + size < * object || * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_UNICODE : if ( size * 2 < * object || * object + size < * object || * object + size * 2 < size ) {if ( * object + size * 2 > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_SET : case BPLIST_ARRAY : if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\",2269
2116,"case BPLIST_DICT :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\","case BPLIST_DICT : if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\",2269
2117,"if ( error ) return error ;dentry = fhp -> fh_dentry ;inode = d_inode ( dentry ) ;if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) )  return nfserr_attrnotsupp ;host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ;if ( host_error < 0 )  goto out_release ;if ( S_ISDIR ( inode -> i_mode ) ) {host_error = inode -> i_op -> set_acl ( inode , dpacl ,  ACL_TYPE_DEFAULT ) ;out_release :  posix_acl_release ( pacl ) ;","fh_lock ( fhp ) ;host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl ) ;if ( host_error < 0 ) goto out_drop_lock ;if ( S_ISDIR ( inode -> i_mode ) ) {host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl ) ;out_release : posix_acl_release ( pacl ) ;",2270
2118,"sprintf ( descriptor -> msg , ""\\\","sprintf ( descriptor -> msg , ""\\\",2271
2119,if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 )  {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT   && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&   value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )  {,if ( field_identifier == SQL_DESC_COUNT && ( intptr_t ) value < 0 ) {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) value != SQL_PARAM_OUTPUT_STREAM ) {,2271
2120,"enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MIWR , data ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 )   {}","uint16_t status ;enc624j600WriteReg ( interface , ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT | address ) ;enc624j600WriteReg ( interface , ENC624J600_MIWR , data ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_MISTAT ) ;}while ( ( status & ENC624J600_MISTAT_BUSY ) != 0 ) ;",2272
2121,"wStream * s ;size_t length ;UINT32 flags ;NTLM_AV_PAIR * AvFlags ;UINT32 PayloadBufferOffset ;flags = 0 ;AvFlags = NULL ;if ( ntlm_read_message_header ( s , ( NTLM_MESSAGE_HEADER * ) message ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( message -> MessageType != MESSAGE_TYPE_AUTHENTICATE )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> LmChallengeResponse ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> NtChallengeResponse ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> DomainName ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> UserName ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> Workstation ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 )  {Stream_Free ( s , FALSE ) ;if ( ( context -> NegotiateKeyExchange && ! message -> EncryptedRandomSessionKey . Len ) || ( ! context -> NegotiateKeyExchange && message -> EncryptedRandomSessionKey . Len ) )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ! snt )  {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) < 0 ) {Stream_Free ( snt , FALSE ) ;return SEC_E_INVALID_TOKEN ;Stream_Free ( snt , FALSE ) ;","SECURITY_STATUS status = SEC_E_INVALID_TOKEN ;wStream * s ;size_t length ;UINT32 flags = 0 ;NTLM_AV_PAIR * AvFlags = NULL ;UINT32 PayloadBufferOffset ;if ( ntlm_read_message_header ( s , ( NTLM_MESSAGE_HEADER * ) message ) < 0 ) goto fail ;if ( message -> MessageType != MESSAGE_TYPE_AUTHENTICATE ) {Stream_Free ( s , FALSE ) ;if ( ntlm_read_message_fields ( s , & ( message -> LmChallengeResponse ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields ( s , & ( message -> NtChallengeResponse ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields ( s , & ( message -> DomainName ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields ( s , & ( message -> UserName ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields ( s , & ( message -> Workstation ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 ) goto fail ;if ( Stream_GetRemainingLength ( s ) < 4 ) goto fail ;if ( ( context -> NegotiateKeyExchange && ! message -> EncryptedRandomSessionKey . Len ) || ( ! context -> NegotiateKeyExchange && message -> EncryptedRandomSessionKey . Len ) ) goto fail ;if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) goto fail ;status = SEC_E_INTERNAL_ERROR ;if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) goto fail ;if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) goto fail ;int rc ;if ( ! snt ) {return SEC_E_INTERNAL_ERROR ;if ( ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) < 0 ) {Stream_Free ( s , FALSE ) ;if ( rc < 0 ) goto fail ;status = SEC_E_INTERNAL_ERROR ;",2273
2122,"if ( ntlm_read_message_fields_buffer ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( message -> EncryptedRandomSessionKey . Len != 16 )  {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}if ( ! sspi_SecBufferAlloc ( & context -> AuthenticateMessage , length ) )  {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( Stream_GetRemainingLength ( s ) < 16 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}","if ( ntlm_read_message_fields_buffer ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 ) goto fail ;if ( message -> EncryptedRandomSessionKey . Len != 16 ) goto fail ;if ( ! sspi_SecBufferAlloc ( & context -> AuthenticateMessage , length ) ) goto fail ;status = SEC_E_INVALID_TOKEN ;if ( Stream_GetRemainingLength ( s ) < 16 ) goto fail ;status = SEC_E_INTERNAL_ERROR ;",2273
2123,"if ( ! credentials -> identity . User )  {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}if ( ! credentials -> identity . Domain )  {Stream_Free ( s , FALSE ) ;return SEC_E_INTERNAL_ERROR ;}}","if ( ! credentials -> identity . User ) goto fail ;if ( ! credentials -> identity . Domain ) goto fail ;fail : Stream_Free ( s , FALSE ) ;return status ;}",2273
2124,"}else if ( caught_signal ) status = caught_signal + 128 ;if ( caught_signal )  {sleep ( 2 ) ;kill ( child , SIGKILL ) ;fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\\switch ( caught_signal ) {","child = ( pid_t ) - 1 ;}else if ( caught_signal && child != ( pid_t ) - 1 ) status = caught_signal + 128 ;if ( caught_signal ) {if ( child != ( pid_t ) - 1 ) {}sleep ( 2 ) ;kill ( child , SIGKILL ) ;fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\\switch ( caught_signal ) {",2274
2125,saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;saddr . sin_port = htons ( port ) ;,saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;saddr . sin_port = htons ( port ) ;,2275
2126,"xfs_daddr_t blkno = map [ 0 ] . bm_bn ;int numblks = 0 ;pag = xfs_perag_get ( btp -> bt_mount ,  xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ;","xfs_daddr_t blkno = map [ 0 ] . bm_bn ;xfs_daddr_t eofs ;int numblks = 0 ;eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ;if ( blkno >= eofs ) {xfs_alert ( btp -> bt_mount , ""%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>"" , __func__ , blkno , eofs ) ;return NULL ;}pag = xfs_perag_get ( btp -> bt_mount , xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ;",2276
2127,"int ret = - 1 ;s = DSA_SIG_new ( ) ;if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ;ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;err :  DSA_SIG_free ( s ) ;return ( ret ) ;","const unsigned char * p = sigbuf ;unsigned char * der = NULL ;int derlen = - 1 ;int ret = - 1 ;s = DSA_SIG_new ( ) ;if ( d2i_DSA_SIG ( & s , & p , siglen ) == NULL ) goto err ;derlen = i2d_DSA_SIG ( s , & der ) ;if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) goto err ;ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;err : if ( derlen > 0 ) {OPENSSL_cleanse ( der , derlen ) ;OPENSSL_free ( der ) ;}DSA_SIG_free ( s ) ;return ( ret ) ;",2277
2128,while ( res == 0 && dev ) {struct expander_device * ex = & dev -> ex_dev ;,if ( res == 0 && dev ) {struct expander_device * ex = & dev -> ex_dev ;,2278
2129,"dev = NULL ;res = sas_find_bcast_dev ( port_dev , & dev ) ;","
",2278
2130,netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ;netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ;,netdev -> hw_features = NETIF_F_HW_VLAN_CTAG_RX ;netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ;,2279
2131,goto next_desc ;},"goto next_desc ;}if ( ( buflen < elength ) || ( elength < 3 ) ) {dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\\break ;}",2280
2132,"f = fopen ( filepath , ""rb"" ) ;if ( f ) {","f = fopen ( filepath , ""r"" ) ;if ( f ) {",2281
2133,"if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO )  && ext4_can_extents_be_merged ( inode , ex , newext ) ) {","if ( ex && ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) && ext4_can_extents_be_merged ( inode , ex , newext ) ) {",2282
2134,"merge :  if ( flag != EXT4_GET_BLOCKS_PRE_IO )  ext4_ext_try_to_merge ( inode , path , nearex ) ;","merge : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) ) ext4_ext_try_to_merge ( inode , path , nearex ) ;",2282
2135,evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ;if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ;,evt -> event . lun [ 1 ] = tpg -> tport_tpgt ;if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ;,2283
2136,"struct btrfs_dir_item * di ;struct btrfs_root * root = BTRFS_I ( inode ) -> root ;if ( flags & XATTR_REPLACE ) {di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name ,  name_len , - 1 ) ;if ( IS_ERR ( di ) ) {ret = PTR_ERR ( di ) ;}ret = - ENODATA ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( ret ) goto out ;btrfs_release_path ( path ) ;if ( ! value ) goto out ;}else {di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ;if ( IS_ERR ( di ) ) {ret = PTR_ERR ( di ) ;goto out ;if ( flags & XATTR_CREATE )  goto out ;btrfs_release_path ( path ) ;di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;}else if ( ! di ) {btrfs_release_path ( path ) ;goto again ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( value ) {btrfs_release_path ( path ) ;goto again ;","struct btrfs_dir_item * di = NULL ;struct btrfs_root * root = BTRFS_I ( inode ) -> root ;path -> skip_release_on_error = 1 ;if ( ! value ) {di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;if ( ! di && ( flags & XATTR_REPLACE ) ) ret = - ENODATA ;else if ( di ) ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;}ret = - ENODATA ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( ret ) goto out ;btrfs_release_path ( path ) ;if ( ! value ) goto out ;if ( flags & XATTR_REPLACE ) {ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ;di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ;if ( flags & XATTR_CREATE ) goto out ;btrfs_release_path ( path ) ;di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;btrfs_release_path ( path ) ;di = NULL ;}ret = btrfs_insert_xattr_item ( trans , root , path , di ) ;btrfs_extend_item ( root , path , data_size ) ;item = btrfs_item_nr ( slot ) ;ptr = btrfs_item_ptr ( leaf , slot , char ) ;ptr += btrfs_item_size ( leaf , item ) - data_size ;di = ( struct btrfs_dir_item * ) ptr ;btrfs_set_dir_data_len ( leaf , di , size ) ;data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ;write_extent_buffer ( leaf , value , data_ptr , size ) ;btrfs_mark_buffer_dirty ( leaf ) ;}else {",2284
2137,char * old = x -> ptr ;int newlen ;newlen = x -> length * 6 / 5 ;if ( newlen == x -> length )  newlen += 2 ;,char * old = x -> area_size * 6 / 5 ;if ( newlen == x -> length ) newlen += 2 ;,2285
2138,lock_sock ( sk ) ;if ( sk -> sk_state != SS_CONNECTED ) {,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;if ( sk -> sk_state != SS_CONNECTED ) {,2286
2139,if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {char hexstr [ 3 ] ;,if ( ( '%' == in ) && ( alloc > 2 ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {char hexstr [ 3 ] ;,2287
2140,"res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;rcu_read_unlock ( ) ;","res = ip6_xmit ( sk , skb , & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ;rcu_read_unlock ( ) ;",2288
2141,skb_dst_drop ( skb ) ;},if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ;else skb_dst_drop ( skb ) ;},2289
2142,"
",if ( ctxt -> error ) return ;,2290
2143,"if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) {PUSH ( XSLT_OP_ANCESTOR , NULL , NULL , novar ) ;","if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) {PUSH ( XSLT_OP_ANCESTOR , NULL , NULL , novar ) ;",2290
2144,u32 offset ;msg -> msg_namelen = 0 ;,u32 offset ;,2291
2145,"if ( ( r = sshbuf_put_u32 ( m , state -> remote_protocol_flags ) ) != 0 || ( r = sshbuf_put_u32 ( m , ssh1cipher ) ) != 0 || ( r = sshbuf_put_string ( m , state -> ssh1_key , state -> ssh1_keylen ) ) != 0 || ( r = sshbuf_put_u32 ( m , slen ) ) != 0 || ( r = sshbuf_reserve ( m , slen , & p ) ) != 0 || ( r = cipher_get_keyiv ( state -> send_context , p , slen ) ) != 0 || ( r = sshbuf_put_u32 ( m , rlen ) ) != 0 || ( r = sshbuf_reserve ( m , rlen , & p ) ) != 0 || ( r = cipher_get_keyiv ( state -> receive_context , p , rlen ) ) != 0 ) return r ;}else {if ( ( r = kex_to_blob ( m , ssh -> kex ) ) != 0 || ( r = newkeys_to_blob ( m , ssh , MODE_OUT ) ) != 0 || ( r = newkeys_to_blob ( m , ssh , MODE_IN ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> rekey_limit ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> rekey_interval ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_send . seqnr ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_send . blocks ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_send . packets ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_send . bytes ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_read . seqnr ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_read . blocks ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_read . packets ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_read . bytes ) ) != 0 ) return r ;}slen = cipher_get_keycontext ( state -> send_context , NULL ) ;rlen = cipher_get_keycontext ( state -> receive_context , NULL ) ;if ( ( r = sshbuf_put_u32 ( m , slen ) ) != 0 || ( r = sshbuf_reserve ( m , slen , & p ) ) != 0 ) return r ;if ( cipher_get_keycontext ( state -> send_context , p ) != ( int ) slen ) return SSH_ERR_INTERNAL_ERROR ;if ( ( r = sshbuf_put_u32 ( m , rlen ) ) != 0 || ( r = sshbuf_reserve ( m , rlen , & p ) ) != 0 ) return r ;if ( cipher_get_keycontext ( state -> receive_context , p ) != ( int ) rlen ) return SSH_ERR_INTERNAL_ERROR ;if ( ( r = ssh_packet_get_compress_state ( m , ssh ) ) != 0 ||  ( r = sshbuf_put_stringb ( m , state -> input ) ) != 0 || ( r = sshbuf_put_stringb ( m , state -> output ) ) != 0 ) return r ;","if ( ( r = sshbuf_put_stringb ( m , state -> input ) ) != 0 || ( r = sshbuf_put_stringb ( m , state -> output ) ) != 0 ) return r ;",2292
2146,bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ;if ( bi -> pdwidth < bi -> npwidth ) {bi -> pdwidth = bi -> npwidth ;,if ( bi -> pixelsize > 0 ) {bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ;}if ( bi -> pdwidth < bi -> npwidth ) {bi -> pdwidth = bi -> npwidth ;,2293
2147,if ( phy -> port -> num_phys == 0 )  sas_port_delete ( phy -> port ) ;phy -> port = NULL ;,"if ( phy -> port -> num_phys == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list ) ;phy -> port = NULL ;",2294
2148,"static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd ,  const struct in6_addr * dst , const struct in6_addr * src ) {u32 hash , id ;hash = __ipv6_addr_jhash ( dst , hashrnd ) ;hash = __ipv6_addr_jhash ( src , hash ) ;hash ^= net_hash_mix ( net ) ;","static u32 __ipv6_select_ident ( struct net * net , const struct in6_addr * dst , const struct in6_addr * src ) {const struct {struct in6_addr dst ;struct in6_addr src ;}__aligned ( SIPHASH_ALIGNMENT ) combined = {. dst = * dst , . src = * src , };u32 hash , id ;if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) ) ;hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key ) ;",2295
2149,"if ( unlikely ( ! access_ok ( ! rw , buf , kiocb -> ki_nbytes ) ) )  return - EFAULT ;iovec -> iov_len = kiocb -> ki_nbytes ;* nr_segs = 1 ;","size_t len = kiocb -> ki_nbytes ;if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ;if ( unlikely ( ! access_ok ( ! rw , buf , len ) ) ) return - EFAULT ;iovec -> iov_len = len ;* nr_segs = 1 ;",2296
2150,"assert ( sp -> encodepfunc != NULL ) ;( * sp -> encodepfunc ) ( tif , bp , cc ) ;return ( * sp -> encoderow ) ( tif , bp , cc , s ) ;","if ( ! assert ( sp -> encodepfunc != NULL ) ;( * sp -> encodepfunc ) ( tif , bp , cc ) ) return 0 ;return ( * sp -> encoderow ) ( tif , bp , cc , s ) ;",2297
2151,"vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ;mod_frame_err = calculate_modified_err ( cpi , this_frame ) ;","memset ( & next_frame , 0 , sizeof ( next_frame ) ) ;mod_frame_err = calculate_modified_err ( cpi , this_frame ) ;",2298
2152,"if ( ( i >= cpi -> max_gf_interval && ( decay_accumulator < 0.995 ) ) || ( ( i > MIN_GF_INTERVAL ) && ( ( cpi -> twopass . frames_to_key - i ) >= MIN_GF_INTERVAL ) && ( ( boost_score > 20.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > 100.0 ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || ( ( boost_score - old_boost_score ) < 2.0 ) ) ) ) {boost_score = old_boost_score ;break ;}vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ;old_boost_score = boost_score ;","memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ;old_boost_score = boost_score ;",2298
2153,"char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ;printf ( ""Extracting<S2SV_blank>%s\\\","char * outname = create_output_name ( f [ i ] -> filename , NULL , 0 , 1 , 0 ) ;printf ( ""Extracting<S2SV_blank>%s\\\",2299
2154,"uint16_t numChannels , chansSpecified , chanMask = 0 ;uint32_t sampleRate ;","uint16_t numChannels = 0 , chansSpecified , chanMask = 0 ;uint32_t sampleRate ;",2300
2155,"if ( numChannels < chansSpecified || numChannels < 1 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;","if ( numChannels < chansSpecified || numChannels < 1 || numChannels > 256 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;",2300
2156,"
","if ( ! config -> num_channels ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}",2300
2157,total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;break ;,total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;break ;,2300
2158,"
",tty_driver_kref_put ( driver ) ;,2301
2159,return PTR_ERR ( tty ) ;},return PTR_ERR ( tty ) ;},2301
2160,"if ( ! sctp_verify_asconf ( asoc ,  ( sctp_paramhdr_t * ) addip_hdr -> params ,  ( void * ) asconf_ack -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;","if ( ! sctp_verify_asconf ( asoc , asconf_ack , false , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;",2302
2161,"memory_length += extra_length - available_length + BLOCK_QUEUE ;cp = new_memory ( memory_length , sizeof ( char ) ) ;if ( message_show ( MSG_INFO ) ) message ( ""Reallocating<S2SV_blank>queue<S2SV_blank>at<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p"" , qp -> d_memory , cp ) ;if ( qp -> d_read > qp -> d_write ) {size_t tail_len = qp -> d_memory_end - qp -> d_read ;memcpy ( cp , qp -> d_read , tail_len ) ;memcpy ( cp + tail_len , qp -> d_memory , ( size_t ) ( qp -> d_write - qp -> d_memory ) ) ;memcpy ( cp , qp -> d_memory , memory_length ) ;qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ;","size_t original_length = memory_length ;memory_length += extra_length - available_length + BLOCK_QUEUE ;cp = new_memory ( memory_length , sizeof ( char ) ) ;if ( message_show ( MSG_INFO ) ) message ( ""Reallocating<S2SV_blank>queue<S2SV_blank>at<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p"" , qp -> d_memory , original_length ) ;memcpy ( cp , qp -> d_memory , memory_length ) ;qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ;",2303
2162,"_copy_from_pages ( buf , pages , res . acl_data_offset ,  res . acl_len ) ;}","_copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ;}",2304
2163,"q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) ,   Min ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;","q = QueueAuthenticPixels ( image , x , y , MagickMin ( 4 , dds_info -> width - x ) , MagickMin ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;",2305
2164,"}SkipDXTMipmaps ( image , dds_info , 16 ) ;return MagickTrue ;","return ( }SkipDXTMipmaps ( image , dds_info , 16 , exception ) ) ;",2305
2165,"id = idr_alloc ( & ids -> ipcs_idr , new ,  ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ;","current_euid_egid ( & euid , & egid ) ;new -> cuid = new -> uid = euid ;new -> gid = new -> cgid = egid ;id = idr_alloc ( & ids -> ipcs_idr , new , ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ;",2306
2166,"current_euid_egid ( & euid , & egid ) ;new -> cuid = new -> uid = euid ;new -> gid = new -> cgid = egid ;","
",2306
2167,__be32 * pdata = ( __be32 * ) data ;if ( * pdata == ctx -> from ) {,__be32 * pdata ;if ( datalen != 4 ) return - EINVAL ;pdata = ( __be32 * ) data ;if ( * pdata == ctx -> from ) {,2307
2168,if ( unlikely ( len == 0 ) ) {,if ( unlikely ( len + ring -> frameoffset == 0 ) ) {,2308
2169,if ( unlikely ( len > ring -> rx_buffersize ) ) {int cnt = 0 ;,if ( unlikely ( len > ring -> rx_buffersize ) ) {int cnt = 0 ;,2308
2170,"set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ;","set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ;set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ;",2309
2171,"WARN_ON_ONCE ( ctx -> parent_ctx ) ;mutex_lock ( & ctx -> mutex ) ;list_for_each_entry ( sibling , & event -> sibling_list , group_entry ) perf_event_for_each_child ( sibling , func ) ;mutex_unlock ( & ctx -> mutex ) ;}",lockdep_assert_held ( & ctx -> mutex ) ;},2310
2172,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;else  pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",2311
2173,"xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ;if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;","xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) , sizeof ( * xcfdata ) ) ;if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;",2312
2174,"struct sshbuf * b ;struct sshkey * key = NULL ;char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;u_char * pkblob , * sig , have_sig ;size_t blen , slen ;if ( ! authctxt -> valid ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;return 0 ;}","struct sshbuf * b = NULL ;struct sshkey * key = NULL ;char * pkalg = NULL , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;u_char * pkblob = NULL , * sig = NULL , have_sig ;size_t blen , slen ;}if ( ! authctxt -> valid || authctxt -> user == NULL ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;goto done ;",2313
2175,"if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" ,  __func__ , ssh_err ( r ) ) ;}","if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;}",2313
2176,"free ( sig ) ;auth2_record_key ( authctxt , authenticated , key ) ;if ( ( r = sshpkt_get_end ( ssh ) ) != 0 )  fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) {","auth2_record_key ( authctxt , authenticated , key ) ;if ( ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;if ( ! authctxt -> valid || authctxt -> user == NULL ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;goto done ;}if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) {",2313
2177,return authenticated ;},free ( sig ) ;return authenticated ;},2313
2178,"NameContext sNC ;memset ( & sNC , 0 , sizeof ( sNC ) ) ;sNC . pParse = & sParse ;sqlite3SelectPrep ( & sParse , pTab -> pSelect , & sNC ) ;","Select * pSelect = pTab -> pSelect ;NameContext sNC ;memset ( & sNC , 0 , sizeof ( sNC ) ) ;sNC . pParse = & sParse ;assert ( pSelect -> selFlags & SF_View ) ;pSelect -> selFlags &= ~ SF_View ;sqlite3SelectPrep ( & sParse , pTab -> pSelect , & sNC ) ;",2314
2179,args -> rmtblkcnt2 = args -> rmtblkcnt ;args -> rmtblkno = 0 ;args -> rmtblkcnt = 0 ;},args -> rmtvaluelen2 = args -> rmtvaluelen ;args -> rmtblkcnt2 = args -> rmtblkcnt = 0 ;args -> rmtvaluelen ;args -> rmtblkno = 0 ;args -> rmtblkcnt = 0 ;},2315
2180,args -> rmtblkcnt = args -> rmtblkcnt2 ;if ( args -> rmtblkno ) {,args -> rmtblkcnt = args -> rmtblkcnt2 ;args -> rmtvaluelen = args -> rmtvaluelen2 ;if ( args -> rmtblkno ) {,2315
2181,"int i , j ;p = buff1 ;i = ctm -> length ;str = ( char * ) ctm -> data ;if ( ( i < 11 ) || ( i > 17 ) )  return 0 ;}if ( i < 13 )  return 0 ;}if ( ( * str == \'Z\' ) || ( * str == \'-\' ) || ( * str == \'+\' ) ) {* ( p ++ ) = * ( str ++ ) ;* ( p ++ ) = * ( str ++ ) ;if ( * str == \'.\' ) {while ( ( * str >= \'0\' ) && ( * str <= \'9\' ) )  str ++ ;if ( * str == \'Z\' )  offset = 0 ;else {if ( ( * str != \'+\' ) && ( * str != \'-\' ) )  return 0 ;","int i , j , remaining ;p = buff1 ;remaining = ctm -> length ;str = ( char * ) ctm -> data ;int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ;int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ;if ( remaining < min_length || remaining > max_length ) return 0 ;remaining -= 10 ;}int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ;int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ;if ( remaining < min_length || remaining > max_length ) return 0 ;remaining -= 12 ;}if ( ( * str == \'Z\' ) || ( * str == \'-\' ) || ( * str == \'+\' ) ) {if ( remaining < 2 ) return 0 ;* ( p ++ ) = * ( str ++ ) ;* ( p ++ ) = * ( str ++ ) ;remaining -= 2 ;if ( remaining && * str == \'.\' ) {remaining -- ;for ( i = 0 ;i < 3 && remaining ;i ++ , str ++ , remaining -- ) {if ( * str < \'0\' || * str > \'9\' ) break ;}if ( ! remaining ) return 0 ;if ( * str == \'Z\' ) {if ( remaining != 1 ) return 0 ;offset = 0 ;}else {if ( ( * str != \'+\' ) && ( * str != \'-\' ) ) return 0 ;if ( remaining != 5 ) return 0 ;if ( str [ 1 ] < \'0\' || str [ 1 ] > \'9\' || str [ 2 ] < \'0\' || str [ 2 ] > \'9\' || str [ 3 ] < \'0\' || str [ 3 ] > \'9\' || str [ 4 ] < \'0\' || str [ 4 ] > \'9\' ) return 0 ;",2316
2182,"
",{BOOL rc ;,2317
2183,"PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data )   nsc_rle_decompress_data ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data )  PROFILER_ENTER ( context -> priv -> prof_nsc_decode )   context -> decode ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_decode )  if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ;","PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) rc = nsc_rle_decompress_data ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ;}{BOOL rc ;PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) rc = context -> decode ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) if ( ! rc ) return FALSE ;}if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ;",2317
2184,"if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) )  break ;","if ( js_doregexec ( J , re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) break ;",2318
2185,"int ret ;assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;ret = hns_nic_net_xmit_hw ( ndev , skb ,  & tx_ring_data ( priv , skb -> queue_mapping ) ) ;if ( ret == NETDEV_TX_OK ) {netif_trans_update ( ndev ) ;ndev -> stats . tx_bytes += skb -> len ;ndev -> stats . tx_packets ++ ;}return ( netdev_tx_t ) ret ;","assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;return hns_nic_net_xmit_hw ( ndev , skb , & tx_ring_data ( priv , skb -> queue_mapping ) ) ;",2319
2186,"void HTML_put_string ( HTStructured * me , const char * s )  {# ifdef USE_PRETTYSRC char * translated_string = NULL ;","void HTML_put_string ( HTStructured * me , const char * s ) {HTChunk * target = NULL ;# ifdef USE_PRETTYSRC char * translated_string = NULL ;",2320
2187,"case HTML_TITLE :  HTChunkPuts ( & me -> title , s ) ;break ;case HTML_STYLE :  HTChunkPuts ( & me -> style_block , s ) ;break ;case HTML_SCRIPT :  HTChunkPuts ( & me -> script , s ) ;break ;case HTML_OBJECT :  HTChunkPuts ( & me -> object , s ) ;break ;case HTML_TEXTAREA :  HTChunkPuts ( & me -> textarea , s ) ;break ;case HTML_SELECT : case HTML_OPTION :  HTChunkPuts ( & me -> option , s ) ;break ;case HTML_MATH :  HTChunkPuts ( & me -> math , s ) ;break ;","case HTML_TITLE : target = & me -> title , s ) ;break ;case HTML_STYLE : target = & me -> style_block , s ) ;break ;case HTML_SCRIPT : target = & me -> script , s ) ;break ;case HTML_OBJECT : target = & me -> object , s ) ;break ;case HTML_TEXTAREA : target = & me -> textarea , s ) ;break ;case HTML_SELECT : case HTML_OPTION : target = & me -> option , s ) ;break ;case HTML_MATH : target = & me -> math , s ) ;break ;",2320
2188,"
","if ( target != NULL ) {if ( target -> data == s ) {CTRACE ( ( tfp , ""BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\\\'\\\}else {HTChunkPuts ( target , s ) ;}}",2320
2189,# ifdef USE_PRETTYSRC  if ( psrc_convert_string ) {,# ifdef USE_PRETTYSRC if ( psrc_convert_string ) {,2320
2190,return error ;},return error < 0 ? error : 0 ;},2321
2191,kiocb -> ki_nr_segs = kiocb -> ki_nbytes ;kiocb -> ki_cur_seg = 0 ;,"ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ;if ( ret < 0 ) goto out ;kiocb -> ki_nr_segs = kiocb -> ki_nbytes ;kiocb -> ki_cur_seg = 0 ;",2322
2192,"sas_discover_event ( dev -> port , DISCE_PROBE ) ;return 0 ;",return 0 ;,2323
2193,},pdo_row_ce -> unserialize = zend_class_unserialize_deny ;},2324
2194,"int error ;ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ;","int error ;struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache ;ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ;",2325
2195,"if ( ext2_xattr_cache_insert ( bh ) )  ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ;","if ( ext2_xattr_cache_insert ( ext2_mb_cache , bh ) ) ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ;",2325
2196,if ( client -> type == USER_CLIENT )  snd_seq_fifo_clear ( client -> data . user . fifo ) ;,if ( client -> type == USER_CLIENT && client -> data . user . fifo ) snd_seq_fifo_clear ( client -> data . user . fifo ) ;,2326
2197,if ( IS_ERR ( index_key . type ) ) {key_ref = ERR_PTR ( - ENODEV ) ;goto error ;}key_ref = ERR_PTR ( - EINVAL ) ;if ( ! index_key . type -> match || ! index_key . type -> instantiate ||  ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ;,if ( ! index_key . type -> match || ! index_key . type -> instantiate || ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ;,2327
2198,"file = fopen ( ""/tmp/keepalived.json"" , ""w"" ) ;if ( ! file ) {","file = fopen_safe ( ""/tmp/keepalived.json"" , ""w"" ) ;if ( ! file ) {",2328
2199,"pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ;ver = 1 ;",pdf -> xrefs = safe_calloc ( sizeof ( xref_t ) * pdf -> n_xrefs ) ;ver = 1 ;,2329
2200,"if ( err )  return err ;return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ;","if ( err ) {kfree_skb ( skb ) ;return err ;}return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ;",2330
2201,int delta_munlocked ;struct pagevec pvec_putback ;,int delta_munlocked = - nr ;struct pagevec pvec_putback ;,2331
2202,"}pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ;delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ;__mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ;","}else {delta_munlocked ++ ;}pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ;__mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ;",2331
2203,"skipsize = LOGICAL_BLOCK_SIZE * vd -> location ;skipsize = __archive_read_consume ( a , skipsize ) ;","skipsize = LOGICAL_BLOCK_SIZE * ( int64_t ) vd -> location ;skipsize = __archive_read_consume ( a , skipsize ) ;",2332
2204,skipsize = LOGICAL_BLOCK_SIZE * vd -> location ;skipsize -= iso9660 -> current_position ;,skipsize = LOGICAL_BLOCK_SIZE * ( int64_t ) vd -> location ;skipsize -= iso9660 -> current_position ;,2332
2205,"int val = 1 ;cFYI ( 1 , ""Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u"" , smb_buf_length ) ;","int val = 1 ;if ( ssocket == NULL ) return - ENOTSOCK ;cFYI ( 1 , ""Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u"" , smb_buf_length ) ;",2333
2206,"const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width ,  16 ) ;","const int er_y = MAX ( src -> y_height , 6 ) ) ) - src -> y_crop_width ;const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_crop_height ;",2334
2207,"# if CONFIG_ALPHA  const int et_a = dst -> border >> ( dst -> alpha_height != dst -> y_height ) ;const int el_a = dst -> border >> ( dst -> alpha_width != dst -> y_width ) ;const int eb_a = et_a + dst -> alpha_height - src -> alpha_height ;const int er_a = el_a + dst -> alpha_width - src -> alpha_width ;copy_and_extend_plane ( src -> alpha_buffer , src -> alpha_stride , dst -> alpha_buffer , dst -> alpha_stride , src -> alpha_width , src -> alpha_height , et_a , el_a , eb_a , er_a ) ;# endif copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride ,  src -> y_width , src -> y_height ,  et_y , el_y , eb_y , er_y ) ;copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride ,  src -> uv_width , src -> uv_height ,  et_uv , el_uv , eb_uv , er_uv ) ;copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride ,  src -> uv_width , src -> uv_height ,  et_uv , el_uv , eb_uv , er_uv ) ;","# if CONFIG_VP9_HIGHBITDEPTH if ( src -> flags & YV12_FLAG_HIGHBITDEPTH ) {highbd_copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ;highbd_copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ;highbd_copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ;return ;}# endif copy_and_extend_plane ( src -> y_buffer , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ;copy_and_extend_plane ( src -> u_buffer , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ;copy_and_extend_plane ( src -> v_buffer , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ;",2334
2208,void * base = dlmalloc ( bytes + sizeof ( AllocationEntry ) ) ;if ( base != NULL ) {,size_t size = bytes + sizeof ( AllocationEntry ) ;if ( size < bytes ) {return NULL ;}void * base = dlmalloc ( size ) ;if ( base != NULL ) {,2335
2209,"
",ps_dec -> u2_total_mbs_coded += u1_num_mbs ;,2336
2210,ps_dec -> u1_mb_idx = 0 ;ps_dec -> u4_num_mbs_cur_nmb = 0 ;,ps_dec -> u1_mb_idx = 0 ;ps_dec -> u4_num_mbs_cur_nmb = 0 ;,2336
2211,ps_dec -> u2_total_mbs_coded ++ ;u1_num_mbsNby2 ++ ;,u1_num_mbsNby2 ++ ;,2336
2212,if ( u1_tfr_n_mb )  u1_num_mbs = 0 ;,ps_dec -> u2_total_mbs_coded += u1_num_mbs ;if ( u1_tfr_n_mb ) u1_num_mbs = 0 ;,2336
2213,"af = EXTRACT_16BITS ( tptr ) ;safi = tptr [ 2 ] ;ND_PRINT ( ( ndo , ""\\\switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ;default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""\\\if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\goto done ;break ;}tptr += 3 ;ND_TCHECK ( tptr [ 0 ] ) ;nhlen = tptr [ 0 ] ;tlen = nhlen ;tptr ++ ;if ( tlen ) {int nnh = 0 ;ND_PRINT ( ( ndo , ""\\\while ( tlen > 0 ) {if ( nnh ++ > 0 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ;}switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ;tlen -= sizeof ( struct in_addr ) ;tptr += sizeof ( struct in_addr ) ;}break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ;tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;}break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ;tlen -= sizeof ( struct in6_addr ) ;tptr += sizeof ( struct in6_addr ) ;}break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ;tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;}break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ;tlen -= ( sizeof ( struct in_addr ) ) ;tptr += ( sizeof ( struct in_addr ) ) ;}break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ;tptr += tlen ;tlen = 0 ;break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ;if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ;else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ;tptr += tlen ;tlen = 0 ;}break ;default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ;if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\tptr += tlen ;tlen = 0 ;goto done ;break ;}}}ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ;tptr += tlen ;ND_TCHECK ( tptr [ 0 ] ) ;snpa = tptr [ 0 ] ;tptr ++ ;if ( snpa ) {ND_PRINT ( ( ndo , ""\\\for ( ;snpa > 0 ;snpa -- ) {ND_TCHECK ( tptr [ 0 ] ) ;ND_PRINT ( ( ndo , ""\\\tptr += tptr [ 0 ] + 1 ;}}else {ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ;}while ( len - ( tptr - pptr ) > 0 ) {switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;default : ND_TCHECK2 ( * tptr , tlen ) ;ND_PRINT ( ( ndo , ""\\\if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\advance = 0 ;tptr = pptr + len ;break ;}if ( advance < 0 ) break ;tptr += advance ;}done : break ;case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ;af = EXTRACT_16BITS ( tptr ) ;safi = tptr [ 2 ] ;ND_PRINT ( ( ndo , ""\\\if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\\while ( len - ( tptr - pptr ) > 0 ) {switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ;ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ;if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\\advance = 0 ;tptr = pptr + len ;break ;}if ( advance < 0 ) break ;tptr += advance ;}break ;case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;break ;}while ( tlen > 0 ) {uint16_t extd_comm ;ND_TCHECK2 ( tptr [ 0 ] , 2 ) ;extd_comm = EXTRACT_16BITS ( tptr ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ;switch ( extd_comm ) {case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ;break ;case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ;break ;case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ;break ;case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ;break ;case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ;break ;case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ;break ;case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ;break ;case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ;break ;default : ND_TCHECK2 ( * tptr , 8 ) ;print_unknown_data ( ndo , tptr , ""\\\break ;}tlen -= 8 ;tptr += 8 ;}break ;case BGPTYPE_PMSI_TUNNEL : {uint8_t tunnel_type , flags ;tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;ND_PRINT ( ( ndo , ""\\\tptr += 5 ;tlen -= 5 ;switch ( tunnel_type ) {case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\print_unknown_data ( ndo , tptr , ""\\\break ;}case BGPTYPE_AIGP : {uint8_t type ;uint16_t length ;ND_TCHECK2 ( tptr [ 0 ] , 3 ) ;tlen = len ;while ( tlen >= 3 ) {type = * tptr ;length = EXTRACT_16BITS ( tptr + 1 ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ;switch ( type ) {case BGP_AIGP_TLV :  ND_TCHECK2 ( tptr [ 3 ] , 8 ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 ,  EXTRACT_64BITS ( tptr + 3 ) ) ) ;break ;default : if ( ndo -> ndo_vflag <= 1 ) {print_unknown_data ( ndo , tptr + 3 , ""\\\}}","type = * tptr ;length = EXTRACT_16BITS ( tptr + 1 ) ;tlen -= 3 ;ND_PRINT ( ( ndo , ""\\\if ( length < 3 ) goto trunc ;length -= 3 ;ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ;switch ( type ) {case BGP_AIGP_TLV : ND_TCHECK2 ( tptr [ 3 ] , 8 ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr + 3 ) ) ) ;print_unknown_data ( ndo , tptr + 3 , ""\\\",2337
2214,"case 2 :  # line 106 ""hex_grammar.y""  {# line 1330 ""hex_grammar.c""  break ;case 3 :  # line 115 ""hex_grammar.y""  {# line 1338 ""hex_grammar.c""  break ;case 4 :  # line 119 ""hex_grammar.y""  {# line 1351 ""hex_grammar.c""  break ;case 5 :  # line 128 ""hex_grammar.y""  {RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;( yyval . re_node ) = NULL ;","case 2 : # line 113 ""hex_grammar.y"" {# line 1337 ""hex_grammar.c"" break ;case 3 : # line 122 ""hex_grammar.y"" {# line 1345 ""hex_grammar.c"" break ;case 4 : # line 126 ""hex_grammar.y"" {incr_ast_levels ( ) ;# line 1360 ""hex_grammar.c"" break ;case 5 : # line 137 ""hex_grammar.y"" {RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;incr_ast_levels ( ) ;( yyval . re_node ) = NULL ;",2338
2215,"# line 1413 ""hex_grammar.c""  break ;case 6 :  # line 190 ""hex_grammar.y""  {# line 1421 ""hex_grammar.c""  break ;case 7 :  # line 194 ""hex_grammar.y""  {# line 1434 ""hex_grammar.c""  break ;case 8 :  # line 207 ""hex_grammar.y""  {# line 1442 ""hex_grammar.c""  break ;case 9 :  # line 211 ""hex_grammar.y""  {# line 1451 ""hex_grammar.c""  break ;case 10 :  # line 220 ""hex_grammar.y""  {","# line 1424 ""hex_grammar.c"" break ;case 6 : # line 201 ""hex_grammar.y"" {# line 1432 ""hex_grammar.c"" break ;case 7 : # line 205 ""hex_grammar.y"" {incr_ast_levels ( ) ;# line 1447 ""hex_grammar.c"" break ;case 8 : # line 220 ""hex_grammar.y"" {# line 1455 ""hex_grammar.c"" break ;case 9 : # line 224 ""hex_grammar.y"" {# line 1464 ""hex_grammar.c"" break ;case 10 : # line 233 ""hex_grammar.y"" {",2338
2216,"# line 1468 ""hex_grammar.c""  break ;case 11 :  # line 233 ""hex_grammar.y""  {# line 1476 ""hex_grammar.c""  break ;case 12 :  # line 237 ""hex_grammar.y""  {# line 1485 ""hex_grammar.c""  break ;case 13 :  # line 246 ""hex_grammar.y""  {","# line 1481 ""hex_grammar.c"" break ;case 11 : # line 246 ""hex_grammar.y"" {# line 1489 ""hex_grammar.c"" break ;case 12 : # line 250 ""hex_grammar.y"" {# line 1498 ""hex_grammar.c"" break ;case 13 : # line 259 ""hex_grammar.y"" {",2338
2217,"# line 1512 ""hex_grammar.c""  break ;case 14 :  # line 269 ""hex_grammar.y""  {","# line 1525 ""hex_grammar.c"" break ;case 14 : # line 282 ""hex_grammar.y"" {",2338
2218,"# line 1548 ""hex_grammar.c""  break ;case 15 :  # line 301 ""hex_grammar.y""  {","# line 1561 ""hex_grammar.c"" break ;case 15 : # line 314 ""hex_grammar.y"" {",2338
2219,"# line 1574 ""hex_grammar.c""  break ;case 16 :  # line 323 ""hex_grammar.y""  {","# line 1587 ""hex_grammar.c"" break ;case 16 : # line 336 ""hex_grammar.y"" {",2338
2220,"# line 1594 ""hex_grammar.c""  break ;case 17 :  # line 343 ""hex_grammar.y""  {# line 1602 ""hex_grammar.c""  break ;case 18 :  # line 347 ""hex_grammar.y""  {( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1617 ""hex_grammar.c""  break ;case 19 :  # line 361 ""hex_grammar.y""  {# line 1629 ""hex_grammar.c""  break ;case 20 :  # line 369 ""hex_grammar.y""  {","# line 1607 ""hex_grammar.c"" break ;case 17 : # line 356 ""hex_grammar.y"" {# line 1615 ""hex_grammar.c"" break ;case 18 : # line 360 ""hex_grammar.y"" {incr_ast_levels ( ) ;( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1631 ""hex_grammar.c"" break ;case 19 : # line 375 ""hex_grammar.y"" {# line 1643 ""hex_grammar.c"" break ;case 20 : # line 383 ""hex_grammar.y"" {",2338
2221,"# line 1653 ""hex_grammar.c""  break ;# line 1657 ""hex_grammar.c""  default : break ;","# line 1667 ""hex_grammar.c"" break ;# line 1657 ""hex_grammar.c"" default : break ;",2338
2222,"char group [ LONG_STRING ] ;char desc [ HUGE_STRING ] = """" ;if ( sscanf ( line , ""%s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\\nntp_data = nntp_data_find ( nserv , group ) ;","char group [ LONG_STRING ] = """" ;char desc [ HUGE_STRING ] = """" ;if ( sscanf ( line , ""%1023s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\\mutt_debug ( 4 , ""Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\\return 0 ;}nntp_data = nntp_data_find ( nserv , group ) ;",2339
2223,pStorage -> picSizeInMbs =  pStorage -> activeSps -> picWidthInMbs *  pStorage -> activeSps -> picHeightInMbs ;pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ;,if ( pStorage -> activeSps -> picWidthInMbs == 0 ) {pStorage -> picSizeInMbs = 0 ;}else if ( pStorage -> activeSps -> picHeightInMbs > UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) {return ( MEMORY_ALLOCATION_ERROR ) ;}else {pStorage -> picSizeInMbs = pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs ;}pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ;,2340
2224,"if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {coerce_reg_to_size ( dst_reg , 4 ) ;coerce_reg_to_size ( & src_reg , 4 ) ;}",u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;,2341
2225,"if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}break ;case BPF_AND : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = dst_reg -> var_off . value ;dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ;dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ;dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_LSH :  if ( umax_val > 63 ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;","if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {coerce_reg_to_size ( dst_reg , 4 ) ;coerce_reg_to_size ( & src_reg , 4 ) ;",2341
2226,"case BPF_RSH :  if ( umax_val > 63 ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;","case BPF_RSH : if ( umax_val > 63 ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;",2341
2227,__reg_deduce_bounds ( dst_reg ) ;__reg_bound_offset ( dst_reg ) ;,__reg_deduce_bounds ( dst_reg ) ;__reg_bound_offset ( dst_reg ) ;,2341
2228,tdata_t tilebuf ;uint32 imagew = TIFFScanlineSize ( in ) ;uint32 tilew = TIFFTileRowSize ( in ) ;int iskew = imagew - tilew ;uint8 * bufp = ( uint8 * ) buf ;,int64 iskew = ( int64 ) imagew - ( int64 ) tilew ;uint8 * bufp = ( uint8 * ) buf ;,2342
2229,if ( colb + tilew > imagew ) {uint32 width = imagew - colb ;,if ( colb > iskew ) {uint32 width = imagew - colb ;,2342
2230,"if ( ! ( dev -> flags & IFF_UP ) )  return NET_RX_DROP ;if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) )   return NET_RX_DROP ;skb_set_dev ( skb , dev ) ;","if ( ! ( dev -> flags & IFF_UP ) || ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) ) {kfree_skb ( skb ) ;return NET_RX_DROP ;}skb_set_dev ( skb , dev ) ;",2343
2231,"else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL )  {else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL )  {","else if ( anope_flags_compat && ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL ) {else if ( anope_flags_compat && ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL ) {",2344
2232,"else if ( ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL )  {","else if ( anope_flags_compat && ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL ) {",2344
2233,user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user )  return ERR_PTR ( - ENOMEM ) ;construct_get_dest_keyring ( & dest_keyring ) ;,ret = construct_get_dest_keyring ( & dest_keyring ) ;if ( ret ) goto error ;user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user ) {ret = - ENOMEM ;goto error_put_dest_keyring ;},2345
2234,"goto couldnt_alloc_key ;}couldnt_alloc_key :   key_put ( dest_keyring ) ;kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ;","goto error_put_dest_keyring ;}error_put_dest_keyring : key_put ( dest_keyring ) ;error : kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ;",2345
2235,"if ( s -> chunksize >= 0 ) {if ( ! s -> chunksize ) {s -> chunksize = strtoll ( line , NULL , 16 ) ;av_log ( NULL , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\\\'\\\if ( ! s -> chunksize )  return 0 ;}int64_t target = h -> is_streamed ? 0 : s -> off ;if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ;av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 ""<S2SV_blank>error=%s.\\\av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ;av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 "".\\\return read_ret ;","if ( s -> chunksize != UINT64_MAX ) {if ( ! s -> chunksize ) {s -> chunksize = strtoull ( line , NULL , 16 ) ;av_log ( h , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\\\'\\\if ( ! s -> chunksize ) return 0 ;else if ( s -> chunksize == UINT64_MAX ) {av_log ( h , AV_LOG_ERROR , ""Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%"" PRIu64 ""\\\return AVERROR ( EINVAL ) ;}}uint64_t target = h -> is_streamed ? 0 : s -> off ;if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ;av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRIu64 ""<S2SV_blank>error=%s.\\\av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ;av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRIu64 "".\\\return read_ret ;",2346
2236,"long tmp = * old ;* old = atomic_long_cmpxchg ( & sem -> count , * old , new ) ;return * old == tmp ;}","long tmp = atomic_long_cmpxchg ( & sem -> count , * old , new ) ;if ( tmp == * old ) {* old = new ;return 1 ;}else {* old = tmp ;return 0 ;}}",2347
2237,"static void write_sync_code ( struct vp9_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ;vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ;vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ;}","static void write_sync_code ( struct vpx_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ;vpx_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ;vpx_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ;}",2348
2238,"static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) {}","static BOOL nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , UINT32 scanline ) {return TRUE ;}",2349
2239,switch ( sun_info . maptype )  {case RMT_EQUAL_RGB : {,switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {,2350
2240,"other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ;if ( ! other_branch ) return - EFAULT ;","other_branch = push_stack ( env , * insn_idx , false + insn -> off + 1 , * insn_idx ) ;if ( ! other_branch ) return - EFAULT ;",2351
2241,"
","if ( stats -> file == NULL ) fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist!"" ) ;",2352
2242,"if ( fseek ( stats -> file , 0 , SEEK_END ) )  fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>must<S2SV_blank>be<S2SV_blank>seekable!"" ) ;","if ( fseek ( stats -> file , 0 , SEEK_END ) ) fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>must<S2SV_blank>be<S2SV_blank>seekable!"" ) ;",2352
2243,"if ( name && memchr ( name , '\\\\0' , namelen ) )  return 0 ;","if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ;if ( name && memchr ( name , '\\\\0' , namelen ) ) return 0 ;",2353
2244,"static int mem_resize ( jas_stream_memobj_t * m , int bufsize )  {assert ( bufsize >= 0 ) ;JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\\if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {","static int mem_resize ( jas_stream_memobj_t * m , size_t bufsize ) {JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\\if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {if ( ! bufsize ) {jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\\}",2354
2245,unsigned int i ;cmap -> numchans = ( box -> datalen ) / 4 ;,unsigned int i ;cmap -> ents = 0 ;cmap -> numchans = ( box -> datalen ) / 4 ;,2355
2246,"BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ;}","if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ;}",2356
2247,ut8 opcode = * ( p4 ++ ) & 0xff ;while ( keep ) {,if ( p4 <= 0 ) {return ;}ut8 opcode = * ( p4 ++ ) & 0xff ;while ( keep ) {,2357
2248,"h = __archive_read_ahead ( a ,  ( size_t ) cpio -> entry_bytes_remaining , NULL ) ;","if ( cpio -> entry_bytes_remaining > 1024 * 1024 ) {archive_set_error ( & a -> archive , ENOMEM , ""Rejecting<S2SV_blank>malformed<S2SV_blank>cpio<S2SV_blank>archive:<S2SV_blank>symlink<S2SV_blank>contents<S2SV_blank>exceed<S2SV_blank>1<S2SV_blank>megabyte"" ) ;return ( ARCHIVE_FATAL ) ;}h = __archive_read_ahead ( a , ( size_t ) cpio -> entry_bytes_remaining , NULL ) ;",2358
2249,". index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = user_match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",". index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",2359
2250,"if ( pos + 8 > len ) {return op -> size ;int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) ,  max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ;","if ( pos + 8 + 8 > len ) {return op -> size ;const int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) ;const int max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ;",2360
2251,"RD_BOOL  ber_parse_header ( STREAM s , int tagval , int * length )  {","RD_BOOL ber_parse_header ( STREAM s , int tagval , uint32 * length ) {",2361
2252,"if ( cid <= 0 )  continue ;dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( dctx -> remaining <= 0 ) {dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( dctx -> remaining <= 0 )   return dctx -> remaining ;}","int remaining ;if ( cid <= 0 ) continue ;remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( remaining <= 0 ) {dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( remaining <= 0 ) return dctx -> remaining ;}",2362
2253,"first_block_offset = round_up ( offset , sb -> s_blocksize ) ;last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;ext4_std_error ( sb , ret ) ;goto out_dio ;}ret = ext4_zero_partial_blocks ( handle , inode , offset , length ) ;if ( ret ) goto out_stop ;first_block = ( offset + sb -> s_blocksize - 1 ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ;stop_block = ( offset + length ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ;if ( first_block >= stop_block ) goto out_stop ;down_write ( & EXT4_I ( inode ) -> i_data_sem ) ;ext4_discard_preallocations ( inode ) ;ret = ext4_es_remove_extent ( inode , first_block , stop_block - first_block ) ;if ( ret ) {up_write ( & EXT4_I ( inode ) -> i_data_sem ) ;goto out_stop ;}if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ret = ext4_ext_remove_space ( inode , first_block , stop_block - 1 ) ;else ret = ext4_ind_remove_space ( handle , inode , first_block , stop_block ) ;up_write ( & EXT4_I ( inode ) -> i_data_sem ) ;if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ;if ( last_block_offset > first_block_offset )  truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ;out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ;out_mutex : mutex_unlock ( & inode -> i_mutex ) ;","ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;first_block_offset = round_up ( offset , sb -> s_blocksize ) ;last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ;out_dio : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;ext4_inode_resume_unlocked_dio ( inode ) ;out_mutex : mutex_unlock ( & inode -> i_mutex ) ;",2363
2254,"printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL ,  VPX_CODEC_USE_POSTPROC ) ;","printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_dec_init ( & codec , decoder -> codec_interface ( ) , NULL , VPX_CODEC_USE_POSTPROC ) ;",2364
2255,"if ( strlen ( str ) >= sizeof ( lowstr ) )  {if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 ||  DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {","if ( strlen ( str ) > MAXDATELEN ) {if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {errno = PGTYPES_TS_BAD_TIMESTAMP ;return ( noresult ) ;}switch ( dtype ) {case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {",2365
2256,"Huff_transmit ( & huff , ch , seq ) ;Huff_addRef ( & huff , ( byte ) ch ) ;","Huff_transmit ( & huff , ch , seq , size << 3 ) ;Huff_addRef ( & huff , ( byte ) ch ) ;",2366
2257,"cmd = kmalloc ( sizeof ( * cmd ) , GFP_ATOMIC ) ;if ( ! cmd ) return - ENOMEM ;","cmd = kzalloc ( sizeof ( * cmd ) , GFP_ATOMIC ) ;if ( ! cmd ) return - ENOMEM ;",2367
2258,for ( i = 0 ;i <= SERDES_MAX ;struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ;,for ( i = 0 ;i < SERDES_MAX ;struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ;,2368
2259,"assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ;return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) ,  ( ( char * ) buf ) + offs , len ) ;","size_t ss = CDF_SEC_SIZE ( h ) ;size_t pos = CDF_SEC_POS ( h , id ) ;assert ( ss == len ) ;return cdf_read ( info , ( off_t ) pos , ( ( char * ) buf ) + offs , len ) ;",2369
2260,"int client_socket = accept ( listen_socket_ , NULL , NULL ) ;if ( client_socket == - 1 ) {","int client_socket = TEMP_FAILURE_RETRY ( accept ( listen_socket_ , NULL , NULL ) ) ;if ( client_socket == - 1 ) {",2370
2261,"send ( client_socket_ , ""btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea"" , 16 , 0 ) ;pthread_mutex_unlock ( & client_socket_lock_ ) ;","TEMP_FAILURE_RETRY ( send ( client_socket_ , ""btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea"" , 16 , 0 ) ) ;pthread_mutex_unlock ( & client_socket_lock_ ) ;",2370
2262,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,2371
2263,struct buffer_head * page_bufs ;struct inode * inode = page -> mapping -> host ;,struct buffer_head * page_bufs = NULL ;struct inode * inode = page -> mapping -> host ;,2372
2264,"else  ret = block_write_full_page ( page , noalloc_get_block_write , wbc ) ;","else if ( page_bufs && buffer_uninit ( page_bufs ) ) {ext4_set_bh_endio ( page_bufs , inode ) ;ret = block_write_full_page_endio ( page , noalloc_get_block_write , wbc , ext4_end_io_buffer_write ) ;}else ret = block_write_full_page ( page , noalloc_get_block_write , wbc ) ;",2372
2265,"for ( i = 0 ;++ i )  resize_multistep ( input + in_stride * i , width , intbuf + width2 * i , width2 , tmpbuf ) ;","assert ( width > 0 ) ;assert ( height > 0 ) ;assert ( width2 > 0 ) ;assert ( height2 > 0 ) ;for ( i = 0 ;+ i )  resize_multistep ( input + in_stride * i , width , intbuf + width2 * i , width2 , tmpbuf ) ;++ i ) resize_multistep ( input + in_stride * i , width , intbuf + width2 * i , width2 , tmpbuf ) ;",2373
2266,case SUNKBD_RET_RESET :  schedule_work ( & sunkbd -> tq ) ;sunkbd -> reset = - 1 ;,case SUNKBD_RET_RESET : if ( sunkbd -> enabled ) schedule_work ( & sunkbd -> tq ) ;sunkbd -> reset = - 1 ;,2374
2267,# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) {,# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) # define GIFOutputCode ( code ) \\\\\,2375
2268,}Quantum index ;,\\\\\Quantum index ;,2375
2269,"
",next_pixel = MagickFalse ;displacement = 1 ;,2375
2270,"index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;p += GetPixelChannels ( image ) ;next_pixel = MagickFalse ;displacement = 1 ;","index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;p += GetPixelChannels ( image ) ;if ( k < 0 ) continue ;",2375
2271,"else umount_tree ( mnt , 0 ) ;}","else umount_tree ( mnt , UMOUNT_CONNECTED ) ;}",2376
2272,if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) )  return CURLE_OUT_OF_MEMORY ;,if ( ( ulen > SIZE_T_MAX / 4 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;,2377
2273,"char buffer [ 4096 ] ;char buffer2 [ 4096 ] ;char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;int l ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;}else {memcpy ( buf , name , name_len ) ;buf [ name_len ] = 0 ;decrypt_return_plain :  if ( buf != buffer ) {efree ( buf ) ;}","char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;int l ;buf = estrndup ( name , name_len ) ;else {memcpy ( buf , name , name_len ) ;decrypt_return_plain : efree ( buf ) ;",2378
2274,"else if ( SUHOSIN_G ( cookie_cryptlist ) ) {if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) {goto decrypt_return_plain ;}}if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {memcpy ( buf2 , value , value_len ) ;buf2 [ value_len ] = 0 ;}else {}","
",2378
2275,skip_cookie :  if ( buf != buffer ) {efree ( buf ) ;}if ( buf2 != buffer2 ) {},skip_cookie : efree ( buf ) ;,2378
2276,"static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high ,  int q ) {const double error_term = err_per_mb / err_divisor ;const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low ,  pt_high ) ;","static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high , int q , vpx_bit_depth_t bit_depth ) {const double error_term = err_per_mb / err_divisor ;const double power_term = MIN ( vp9_convert_qindex_to_q ( q , bit_depth ) * 0.01 + pt_low , pt_high ) ;",2379
2277,"
",icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;,2380
2278,"tcp_init_send_head ( sk ) ;memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ;","tcp_init_send_head ( sk ) ;memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ;",2380
2279,return true ;},return nf_generic_should_process ( nf_ct_protonum ( ct ) ) ;},2381
2280,return ;update_idle_timeout ( conn ) ;parse_input ( conn ) ;if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {,if ( return ;update_idle_timeout ( conn ) != 0 ) return ;parse_input ( conn ) ;if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {,2382
2281,MATLAB_KO :  clone_info = DestroyImageInfo ( clone_info ) ;,MATLAB_KO : if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ;,2383
2282,"if ( ! bgp_attr_print ( ndo , atype , p , alen ) )  goto trunc ;","if ( ! bgp_attr_print ( ndo , atype , p , alen , 0 ) ) goto trunc ;",2384
2283,ext2_xattr_put_super ( sb ) ;if ( ! ( sb -> s_flags & MS_RDONLY ) ) {,if ( sbi -> s_mb_cache ) {ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;sbi -> s_mb_cache = NULL ;}if ( ! ( sb -> s_flags & MS_RDONLY ) ) {,2385
2284,if ( plen > PAGE_SIZE ) goto error ;payload = NULL ;if ( _payload ) {ret = - ENOMEM ;,if ( plen ) {ret = - ENOMEM ;,2386
2285,i < MAX_MODES ;i ++ ) {cpi -> mode_check_freq [ i ] = 0 ;}cpi -> mb . mbs_tested_so_far = 0 ;sf -> RD = 1 ;sf -> search_method = NSTEP ;sf -> improved_quant = 1 ;sf -> improved_dct = 1 ;sf -> auto_filter = 1 ;sf -> recode_loop = 1 ;sf -> quarter_pixel_search = 1 ;sf -> half_pixel_search = 1 ;sf -> iterative_sub_pixel = 1 ;sf -> optimize_coefficients = 1 ;sf -> use_fastquant_for_pick = 0 ;sf -> no_skip_block4x4_search = 1 ;sf -> first_step = 0 ;sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ;sf -> improved_mv_pred = 1 ;for ( i = 0 ;i < MAX_MODES ;i ++ ) sf -> thresh_mult [ i ] = 0 ;ref_frames = 1 ;if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ref_frames ++ ;,memset ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ref_frames ++ ;,2387
2286,"sf -> thresh_mult [ THR_SPLIT2 ] =  sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ;cpi -> mode_check_freq [ THR_ZERO1 ] = cpi -> mode_check_freq [ THR_NEAREST1 ] = cpi -> mode_check_freq [ THR_NEAR1 ] = cpi -> mode_check_freq [ THR_TM ] = cpi -> mode_check_freq [ THR_DC ] = 0 ;","sf -> thresh_mult [ THR_SPLIT2 ] = sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ;if ( ( cpi -> Speed <= 6 ) && ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) && ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ) {if ( cpi -> closest_reference_frame == GOLDEN_FRAME ) {sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 3 ;sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 3 ;sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 3 ;}else {sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 1 ;sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 1 ;sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 1 ;}}cpi -> mode_check_freq [ THR_ZERO1 ] = cpi -> mode_check_freq [ THR_NEAREST1 ] = cpi -> mode_check_freq [ THR_NEAR1 ] = cpi -> mode_check_freq [ THR_TM ] = cpi -> mode_check_freq [ THR_DC ] = 0 ;",2387
2287,"sum += cpi -> mb . error_bins [ i ] ;}total_skip = sum ;sum = 0 ;for ( ;i < 1024 ;i ++ ) {sum += cpi -> mb . error_bins [ i ] ;if ( 10 * sum >= ( unsigned int ) ( cpi -> Speed - 6 ) * ( total_mbs - total_skip ) ) break ;}i -- ;thresh = ( i << 7 ) ;if ( thresh < 2000 ) thresh = 2000 ;if ( ref_frames > 1 ) {sf -> thresh_mult [ THR_NEW1 ] = thresh ;sf -> thresh_mult [ THR_NEAREST1 ] = thresh >> 1 ;sf -> thresh_mult [ THR_NEAR1 ] = thresh >> 1 ;}if ( ref_frames > 2 ) {sf -> thresh_mult [ THR_NEW2 ] = thresh << 1 ;sf -> thresh_mult [ THR_NEAREST2 ] = thresh ;sf -> thresh_mult [ THR_NEAR2 ] = thresh ;}if ( ref_frames > 3 ) {sf -> thresh_mult [ THR_NEW3 ] = thresh << 1 ;sf -> thresh_mult [ THR_NEAREST3 ] = thresh ;sf -> thresh_mult [ THR_NEAR3 ] = thresh ;}sf -> improved_mv_pred = 0 ;}if ( Speed > 8 ) sf -> quarter_pixel_search = 0 ;if ( cm -> version == 0 ) {cm -> filter_type = NORMAL_LOOPFILTER ;if ( Speed >= 14 ) cm -> filter_type = SIMPLE_LOOPFILTER ;}else {cm -> filter_type = SIMPLE_LOOPFILTER ;}if ( Speed >= 15 ) sf -> half_pixel_search = 0 ;vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ;};if ( cpi -> pass == 1 ) {sf -> improved_quant = 0 ;sf -> optimize_coefficients = 0 ;sf -> improved_dct = 0 ;}if ( cpi -> sf . search_method == NSTEP ) {vp8_init3smotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ;}else if ( cpi -> sf . search_method == DIAMOND ) {vp8_init_dsmotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ;}if ( cpi -> sf . improved_dct ) {cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ;cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ;}else {cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ;cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ;}cpi -> mb . short_walsh4x4 = vp8_short_walsh4x4 ;if ( cpi -> sf . improved_quant ) {cpi -> mb . quantize_b = vp8_regular_quantize_b ;cpi -> mb . quantize_b_pair = vp8_regular_quantize_b_pair ;}else {cpi -> mb . quantize_b = vp8_fast_quantize_b ;cpi -> mb . quantize_b_pair = vp8_fast_quantize_b_pair ;",sum += cpi -> mb . quantize_b = vp8_fast_quantize_b ;cpi -> mb . quantize_b_pair = vp8_fast_quantize_b_pair ;,2387
2288,char * bufptr ;bufptr = buf ;,"char * bufptr ;if ( cnt < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ;}bufptr = buf ;",2388
2289,"struct r_bin_dyldcache_obj_t * bin ;if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) {return NULL ;memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ;if ( ! buf ) {if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) {return r_bin_dyldcache_free ( bin ) ;","struct r_bin_dyldcache_obj_t * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) ;if ( ! bin ) {return NULL ;memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ;if ( ! bin -> b || ! buf ) {if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) {return r_bin_dyldcache_free ( bin ) ;",2389
2290,"else  img = ctx -> iface -> dec . get_frame ( ctx -> priv -> alg_priv , iter ) ;return img ;","else img = ctx -> iface -> dec . get_frame ( get_alg_priv ( ctx ) , iter ) ;return img ;",2390
2291,if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ;BeginOfThisString = Offset - SizeOfHeader - 8 ;,if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ;if ( ( Offset + Len ) > SizeOfTag + 8 ) goto Error ;BeginOfThisString = Offset - SizeOfHeader - 8 ;,2391
2292,"static u32 ip_idents_hashrnd __read_mostly ;u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ;hash = jhash_3words ( ( __force u32 ) iph -> daddr ,  ( __force u32 ) iph -> saddr ,  iph -> protocol ^ net_hash_mix ( net ) ,  ip_idents_hashrnd ) ;","u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( net -> ipv4 . ip_id_key ) ) ;hash = siphash_3u32 ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , iph -> protocol , & net -> ipv4 . ip_id_key ) ;",2392
2293,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;buf [ 1 ] |= 1 << offset ;buf [ 2 ] = gpio_push_pull ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ;if ( ret < 0 ) {hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\\goto fail ;}spin_unlock_irqrestore ( & dev -> lock , flags ) ;cp2112_gpio_set ( chip , offset , value ) ;fail :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret < 0 ? ret : - EIO ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;mutex_unlock ( & dev -> lock , flags ) ;cp2112_gpio_set ( chip , offset , value ) ;fail : spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret < 0 ? ret : - EIO ;",2393
2294,"if ( t -> stamp_path )  touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ;timer_set_state ( t , TIMER_RUNNING ) ;","if ( t -> stamp_path ) touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , MODE_INVALID ) ;timer_set_state ( t , TIMER_RUNNING ) ;",2394
2295,"skb_dst_force ( skb ) ;skb_queue_tail ( & sk -> sk_error_queue , skb ) ;","skb_set_err_queue ( skb ) ;skb_dst_force ( skb ) ;skb_queue_tail ( & sk -> sk_error_queue , skb ) ;",2395
2296,"lua_authz_provider_spec * spec ;apr_pool_userdata_get ( ( void * * ) & provider_name , AUTHZ_PROVIDER_NAME_NOTE , cmd -> temp_pool ) ;if ( require_line && * require_line ) {const char * arg ;spec -> args = apr_array_make ( cmd -> pool , 2 , sizeof ( const char * ) ) ;while ( ( arg = ap_getword_conf ( cmd -> pool , & require_line ) ) && * arg ) {APR_ARRAY_PUSH ( spec -> args , const char * ) = arg ;}* parsed_require_line = spec ;return NULL ;","lua_authz_provider_spec * spec ;lua_authz_provider_func * func = apr_pcalloc ( cmd -> pool , sizeof ( lua_authz_provider_func ) ) ;apr_pool_userdata_get ( ( void * * ) & provider_name , AUTHZ_PROVIDER_NAME_NOTE , cmd -> temp_pool ) ;func -> spec = spec ;if ( require_line && * require_line ) {const char * arg ;func -> args = apr_array_make ( cmd -> pool , 2 , sizeof ( const char * ) ) ;while ( ( arg = ap_getword_conf ( cmd -> pool , & require_line ) ) && * arg ) {APR_ARRAY_PUSH ( func -> args , const char * ) = arg ;}* parsed_require_line = func ;return NULL ;",2396
2297,len -= cut ;},len -= cut + 1 ;},2397
2298,"authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ;if ( authpending_file_descriptor < 0 ) {","authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY , 0664 ) ;if ( authpending_file_descriptor < 0 ) {if ( cfg -> is_custom_debug_file ) {fclose ( cfg -> debug_file ) ;}",2398
2299,return retval ;},return retval ;},2398
2300,"vpx_memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ;vpx_memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) ,  SIMD_WIDTH ) ;","memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ;memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) , SIMD_WIDTH ) ;",2399
2301,"recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ;}","TEMP_FAILURE_RETRY ( recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ) ;}",2400
2302,ASSERT ( redir_index < IOAPIC_NUM_PINS ) ;redir_content = ioapic -> redirtbl [ redir_index ] . bits ;result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ;,if ( redir_index < IOAPIC_NUM_PINS ) ;redir_content = ioapic -> redirtbl [ redir_index ] . bits ;else redir_content = ~ 0ULL ;result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ;,2401
2303,"void  crm_send_remote_msg ( void * session , xmlNode * msg , gboolean encrypted ) {if ( encrypted ) {# ifdef HAVE_GNUTLS_GNUTLS_H cib_send_tls ( session , msg ) ;# else  CRM_ASSERT ( encrypted == FALSE ) ;# endif }cib_send_plaintext ( GPOINTER_TO_INT ( session ) , msg ) ;}}","int crm_send_remote_msg ( void * session , xmlNode * msg , gboolean encrypted ) {int rc = - 1 ;char * xml_text = NULL ;int len = 0 ;xml_text = dump_xml_unformatted ( msg ) ;if ( xml_text ) {len = strlen ( xml_text ) ;}free ( xml_text ) ;return rc ;cib_send_plaintext ( GPOINTER_TO_INT ( session ) , msg ) ;}}",2402
2304,ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ;ps_dec -> pv_dec_out = ps_dec_op ;,"ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ;{UWORD32 u4_size ;u4_size = ps_dec_op -> u4_size ;memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ;ps_dec_op -> u4_size = u4_size ;}ps_dec -> pv_dec_out = ps_dec_op ;",2403
2305,"if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ;perf_read_regs ( regs ) ;nmi = perf_intr_is_nmi ( regs ) ;if ( nmi ) nmi_enter ( ) ;else irq_enter ( ) ;for ( i = 0 ;i < cpuhw -> n_events ;++ i ) {event = cpuhw -> event [ i ] ;if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ;val = read_pmc ( event -> hw . idx ) ;if ( ( int ) val < 0 ) {found = 1 ;record_and_restart ( event , val , regs , nmi ) ;}}if ( ! found ) {for ( i = 0 ;i < ppmu -> n_counter ;++ i ) {if ( is_limited_pmc ( i + 1 ) ) continue ;val = read_pmc ( i + 1 ) ;if ( ( int ) val < 0 )  write_pmc ( i + 1 , 0 ) ;","+ i ) {+ i ) {if ( pmc_overflow ( val ) ) write_pmc ( i + 1 , 0 ) ;",2404
2306,}else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) )   ses -> server -> ops = & smb311_operations ;},ses -> server -> vals = & smb21_values ;}else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) {ses -> server -> ops = & smb311_operations ;ses -> server -> vals = & smb311_values ;}},2405
2307,"err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( err < 0 ) return err ;","err = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( err < 0 ) return err ;",2406
2308,"if ( report -> id == REPORT_KEY_STATE ) {if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ;","if ( size > 64 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\\return 0 ;}if ( report -> id == REPORT_KEY_STATE ) {if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ;",2407
2309,"struct rt6_info * rt = ( struct rt6_info * ) dst ;if ( ! dst )  goto out ;if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) {","struct rt6_info * rt ;if ( ! dst ) goto out ;if ( dst -> ops -> family != AF_INET6 ) {dst_release ( dst ) ;return NULL ;}rt = ( struct rt6_info * ) dst ;if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) {",2408
2310,"if ( rc != X86EMUL_CONTINUE ) goto done ;rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ;if ( rc != X86EMUL_CONTINUE ) goto done ;rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ;done :  if ( ctxt -> rip_relative )  ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ;return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ;",if ( ctxt -> rip_relative ) ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ;done : return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ;,2409
2311,"json_t * object , * foo , * bar , * baz ;void * iter ;if ( json_object_iter ( NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>NULL"" ) ;","int i ;json_t * object , * foo , * bar , * baz ;const char * iter_keys [ 3 ] ;int have_key [ 3 ] = {0 , 0 , 0 };json_t * iter_values [ 3 ] ;void * iter ;if ( json_object_iter ( NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>NULL"" ) ;",2410
2312,"if ( strcmp ( json_object_iter_key ( iter ) , ""a"" ) )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != foo )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;iter = json_object_iter_next ( object , iter ) ;if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ;if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != bar )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != baz )  fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;","iter_keys [ 0 ] = json_object_iter_key ( iter ) ;iter_values [ 0 ] = json_object_iter_value ( iter ) ;iter_keys [ 1 ] = json_object_iter_key ( iter ) ;iter_values [ 1 ] = json_object_iter_value ( iter ) ;iter = json_object_iter_next ( object , iter ) ;if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ;iter_keys [ 2 ] = json_object_iter_key ( iter ) ;iter_values [ 2 ] = json_object_iter_value ( iter ) ;if ( json_object_iter_next ( object , iter ) != NULL ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>the<S2SV_blank>end"" ) ;for ( i = 0 ;i < 3 ;i ++ ) {if ( strcmp ( iter_keys [ i ] , ""a"" ) ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>a"" ) ;else have_key [ 0 ] = 1 ;}else if ( strcmp ( iter_keys [ i ] , ""b"" ) == 0 ) {if ( iter_values [ i ] != bar ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>b"" ) ;else have_key [ 1 ] = 1 ;}else if ( strcmp ( iter_keys [ i ] , ""c"" ) == 0 ) {if ( iter_values [ i ] != baz ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>c"" ) ;else have_key [ 2 ] = 1 ;}}for ( i = 0 ;i < 3 ;i ++ ) {if ( ! have_key [ i ] ) fail ( ""a<S2SV_blank>key<S2SV_blank>wasn\\\'t<S2SV_blank>iterated<S2SV_blank>over"" ) ;}if ( json_object_iter_at ( object , ""foo"" ) ) fail ( ""json_object_iter_at()<S2SV_blank>succeeds<S2SV_blank>for<S2SV_blank>non-existent<S2SV_blank>key"" ) ;iter = json_object_iter_at ( object , ""b"" ) ;if ( ! iter ) fail ( ""json_object_iter_at()<S2SV_blank>fails<S2SV_blank>for<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>key"" ) ;if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != bar ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != foo ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;if ( json_object_iter_set ( object , iter , baz ) ) fail ( ""json_object_iter_key()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ;if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ;if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ;if ( json_object_iter_value ( iter ) != baz ) fail ( ""json_object_iter_value()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ;if ( json_object_get ( object , ""b"" ) != baz ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ;",2410
2313,"memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ;SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ;","memcpy ( serial -> value , priv -> cac_id , serial -> len ) ;SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ;",2411
2314,for ( i = 0 ;i < 4 && out -> data [ i ] ;int hsub = s -> draw . hsub [ i ] ;,for ( i = 0 ;i < 4 && out -> data [ i ] && out -> linesize [ i ] ;int hsub = s -> draw . hsub [ i ] ;,2412
2315,if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ;if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR )  return 1 ;,if ( is_nmi ( intr_info ) ) return 1 ;,2413
2316,unsigned char * data ;uint32_t * data32 ;,unsigned char * data ;,2414
2317,errno = EIO ;* sockRet = - 1 ;return WS_HYBI_STATE_ERR ;}data = ( unsigned char * ) ( wsctx -> writePos - toDecode ) ;data32 = ( uint32_t * ) data ;for ( i = 0 ;data32 [ i ] ^= wsctx -> header . mask . u ;}data [ i ] ^= wsctx -> header . mask . c [ i % 4 ] ;,"for ( i = 0 ;data32 [ i ] ^= wsctx -> header . mask . u ;}uint32_t tmp ;memcpy ( & tmp , data + i * sizeof ( tmp ) , sizeof ( tmp ) ) ;tmp ^= wsctx -> header . mask . c [ i % 4 ] ;",2414
2318,"return mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ;}","struct dentry * root = mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ;if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ;return root ;}",2415
2319,"case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ;* dptr ++ = lci2 ;* dptr ++ = frametype ;* dptr ++ = 0xAA ;memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;","case ROSE_CALL_REQUEST : * dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL ;memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;",2416
2320,"
",if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ;if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 ) ) return ( 0 ) ;,2417
2321,xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ;xmep -> vers = EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) ;,xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ;xmep -> vers = EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) ;,2417
2322,"vmcs_write32 ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ;}","vmcs_write32 ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ;}else {# ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ;# endif }",2418
2323,"if ( table_base + v != ipt_next_entry ( e ) &&  ! ( e -> ip . flags & IPT_F_GOTO ) )  jumpstack [ stackidx ++ ] = e ;e = get_entry ( table_base , v ) ;continue ;","if ( table_base + v != ipt_next_entry ( e ) && ! ( e -> ip . flags & IPT_F_GOTO ) ) {if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;}jumpstack [ stackidx ++ ] = e ;}e = get_entry ( table_base , v ) ;continue ;",2419
2324,int nNew = pSorter -> nMemory * 2 ;while ( nNew < nMin ) nNew = nNew * 2 ;,sqlite3_int64 nNew = 2 * ( sqlite3_int64 ) pSorter -> nMemory ;while ( nNew < nMin ) nNew = nNew * 2 ;,2420
2325,return ;}return ;},}}return ;ND_TCHECK_16BITS ( bp ) ;,2421
2326,"switch ( EXTRACT_16BITS ( bp ) ) {case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ;","switch ( EXTRACT_16BITS ( bp ) ) {case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ;",2421
2327,"struct net * net = sock_net ( asoc -> base . sk ) ;int error = 0 ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_association_put ( asoc ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;int error = 0 ;bh_lock_sock ( sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_association_put ( asoc ) ;",2422
2328,"static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem )  {uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ;return TEE_SUCCESS ;}","static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem ) {size_t req_size = 0 ;uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ;if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;return TEE_SUCCESS ;}",2423
2329,"int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ;if ( ret || ! write ) return ret ;","int ret = proc_dointvec_minmax ( table , write , buffer , lenp , ppos ) ;if ( ret || ! write ) return ret ;",2424
2330,return ret <= 0 ? ret : - EIO ;},return ret < 0 ? ret : - EIO ;},2425
2331,int rc = 0 ;if ( ! ss_initialized ) {,int rc = 0 ;if ( ! scontext_len ) return - EINVAL ;if ( ! ss_initialized ) {,2426
2332,char * identifier ;char * args_fmt ;,YR_OBJECT * * obj_ptr ;YR_ARENA * obj_arena ;char * identifier ;char * args_fmt ;,2427
2333,if ( stack == NULL )  return ERROR_INSUFFICIENT_MEMORY ;while ( ! stop ) {,"if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ;FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) ;while ( ! stop ) {",2427
2334,# endif ip += sizeof ( uint64_t ) ;,# endif assert ( sp == 0 ) ;ip += sizeof ( uint64_t ) ;,2427
2335,# endif  break ;case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ;,# endif break ;case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ;,2427
2336,if ( result == ERROR_SUCCESS )  {r1 . o = function -> return_obj ;push ( r1 ) ;}else {stop = TRUE ;},"if ( result == ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & r1 . o ) ;if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ;stop = ( result != ERROR_SUCCESS ) ;push ( r1 ) ;",2427
2337,yr_modules_unload_all ( context ) ;yr_free ( stack ) ;,"obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ;while ( obj_ptr != NULL ) {yr_object_destroy ( * obj_ptr ) ;obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ;}yr_arena_destroy ( obj_arena ) ;yr_modules_unload_all ( context ) ;yr_free ( stack ) ;",2427
2338,err = - EINVAL ;ds = salg -> digestsize ;ss = salg -> statesize ;alg = & salg -> base ;,alg = & salg -> base ;err = - EINVAL ;if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ;ds = salg -> digestsize ;ss = salg -> statesize ;,2428
2339,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;",2429
2340,"_pam_log ( LOG_DEBUG , ""sending<S2SV_blank>server<S2SV_blank>address<S2SV_blank>to<S2SV_blank>getaddrinfo<S2SV_blank>as:<S2SV_blank>%s<S2SV_blank>"" , server_name ) ;if ( ( rv = getaddrinfo ( server_name , ( port == NULL ) ? ""49"" : port , & hints , & servers ) ) == 0 ) {for ( server = servers ;server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS ;server = server -> ai_next ) {set_tac_srv_addr ( tac_srv_no , server ) ;set_tac_srv_key ( tac_srv_no , current_secret ) ;tac_srv_no ++ ;}_pam_log ( LOG_DEBUG , ""%s:<S2SV_blank>server<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>"" , __FUNCTION__ , tac_srv_no ) ;freeaddrinfo ( servers ) ;}else {_pam_log ( LOG_ERR , ""skip<S2SV_blank>invalid<S2SV_blank>server:<S2SV_blank>%s<S2SV_blank>(getaddrinfo:<S2SV_blank>%s)"" , server_name , gai_strerror ( rv ) ) ;}}else {_pam_log ( LOG_ERR , ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>servers<S2SV_blank>(%d)<S2SV_blank>exceeded,<S2SV_blank>skipping"" , TAC_PLUS_MAXSERVERS ) ;}}else if ( ! strncmp ( * argv , ""secret="" , 7 ) ) {current_secret = * argv + 7 ;if ( tac_srv_no == 0 ) {_pam_log ( LOG_ERR , ""secret<S2SV_blank>set<S2SV_blank>but<S2SV_blank>no<S2SV_blank>servers<S2SV_blank>configured<S2SV_blank>yet"" ) ;}else {set_tac_srv_key ( tac_srv_no - 1 , current_secret ) ;}}else if ( ! strncmp ( * argv , ""timeout="" , 8 ) ) {# ifdef HAVE_STRTOL tac_timeout = strtol ( * argv + 8 , NULL , 10 ) ;# else tac_timeout = atoi ( * argv + 8 ) ;# endif if ( tac_timeout == LONG_MAX ) {_pam_log ( LOG_ERR , ""timeout<S2SV_blank>parameter<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>parsed<S2SV_blank>as<S2SV_blank>integer:<S2SV_blank>%s"" , * argv ) ;tac_timeout = 0 ;}else {tac_readtimeout_enable = 1 ;}}else {_pam_log ( LOG_WARNING , ""unrecognized<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ;}}if ( ctrl & PAM_TAC_DEBUG ) {unsigned long n ;_pam_log ( LOG_DEBUG , ""%d<S2SV_blank>servers<S2SV_blank>defined"" , tac_srv_no ) ;for ( n = 0 ;n < tac_srv_no ;n ++ ) {_pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\\\'%s\\\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) ,  tac_srv [ n ] . key ) ;","_pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\\\'********\\\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) , tac_srv [ n ] . key ) ;",2430
2341,"vpx_memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ;}","memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ;}",2431
2342,client -> connectTimeout = DEFAULT_CONNECT_TIMEOUT ;client -> CurrentKeyboardLedState = 0 ;,client -> connectTimeout = DEFAULT_CONNECT_TIMEOUT ;client -> readTimeout = DEFAULT_READ_TIMEOUT ;client -> CurrentKeyboardLedState = 0 ;,2432
2343,"for ( plane = 0 ;inpic -> data [ plane ] && plane < 4 ;h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ;","plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ] ;h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ;",2433
2344,"map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ;if ( NULL == map ) return - ENOMEM ;","map = q -> bufs [ first ] -> map = kzalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ;if ( NULL == map ) return - ENOMEM ;",2434
2345,sock -> sk -> sk_uid = iattr -> ia_uid ;}return err ;,if ( sock -> sk ) sock -> sk -> sk_uid = iattr -> ia_uid ;else err = - ENOENT ;}return err ;,2435
2346,struct sk_buff * skb ;if ( len > 0xFFFF ) return - EMSGSIZE ;,struct sk_buff * skb ;struct ip_options_data opt_copy ;if ( len > 0xFFFF ) return - EMSGSIZE ;,2436
2347,"if ( ipc . opt ) free = 1 ;connected = 0 ;if ( ! ipc . opt )  ipc . opt = inet -> opt ;saddr = ipc . addr ;if ( ipc . opt && ipc . opt -> srr ) {if ( ! daddr ) return - EINVAL ;faddr = ipc . opt -> faddr ;connected = 0 ;if ( sock_flag ( sk , SOCK_LOCALROUTE ) || ( msg -> msg_flags & MSG_DONTROUTE ) ||  ( ipc . opt && ipc . opt -> is_strictroute ) ) {tos |= RTO_ONLINK ;","if ( ipc . opt ) {struct ip_options_rcu * inet_opt ;rcu_read_lock ( ) ;inet_opt = rcu_dereference ( inet -> inet_opt ) ;if ( inet_opt ) {memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ;ipc . opt = & opt_copy . opt ;}rcu_read_unlock ( ) ;saddr = ipc . addr ;if ( ipc . opt && ipc . opt -> opt . srr ) {if ( ! daddr ) return - EINVAL ;faddr = ipc . opt -> opt . faddr ;connected = 0 ;if ( sock_flag ( sk , SOCK_LOCALROUTE ) || ( msg -> msg_flags & MSG_DONTROUTE ) || ( ipc . opt && ipc . opt -> opt . is_strictroute ) ) {tos |= RTO_ONLINK ;",2436
2348,for ( vma = mm -> mmap ;vma = vma -> vm_next )  if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) {,VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;for ( vma = mm -> mmap ;vma = vma -> vm_next ) if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) {,2437
2349,"ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ;","ret = ext4_split_unwritten_extents ( handle , inode , map , map , path , flags ) ;",2438
2350,"ret = ext4_convert_unwritten_extents_endio ( handle , inode ,  path ) ;","ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;",2438
2351,"if ( mi < 0 )  return - EINVAL ;return remap_pfn_range ( vma , vma -> vm_start ,  idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;","struct uio_mem * mem ;if ( mi < 0 ) return - EINVAL ;mem = idev -> info -> mem + mi ;if ( vma -> vm_end - vma -> vm_start > mem -> size ) return - EINVAL ;return remap_pfn_range ( vma , vma -> vm_start , mem -> addr >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;",2439
2352,"mpz_t xdiff , ydiff , lambda ;mpz_inits ( xdiff , ydiff , lambda , NULL ) ;","if ( pointZZ_pIsIdentityElement ( op1 ) && pointZZ_pIsIdentityElement ( op2 ) ) {return pointZZ_pSetToIdentityElement ( rop ) ;}else if ( pointZZ_pIsIdentityElement ( op1 ) ) {mpz_set ( rop -> x , op2 -> x ) ;mpz_set ( rop -> y , op2 -> y ) ;return ;}else if ( pointZZ_pIsIdentityElement ( op2 ) ) {mpz_set ( rop -> x , op1 -> x ) ;mpz_set ( rop -> y , op1 -> y ) ;return ;}if ( pointZZ_pEqual ( op1 , op2 ) ) {pointZZ_pDouble ( rop , op1 , curve ) ;return ;}mpz_t negy ;mpz_init ( negy ) ;mpz_sub ( negy , curve -> p , op2 -> y ) ;if ( mpz_cmp ( op1 -> x , op2 -> x ) == 0 && mpz_cmp ( op1 -> y , negy ) == 0 ) {mpz_clear ( negy ) ;return pointZZ_pSetToIdentityElement ( rop ) ;}mpz_t xdiff , ydiff , lambda ;mpz_inits ( xdiff , ydiff , lambda , NULL ) ;",2440
2353,"mpz_clears ( xdiff , ydiff , lambda , NULL ) ;}","mpz_clears ( negy , xdiff , ydiff , lambda , NULL ) ;}",2440
2354,"char * ext , szName [ 1000 ] , szExt [ 20 ] ;const char * szExtList ;","char * ext , szName [ 1024 ] , szExt [ 20 ] ;const char * szExtList ;",2441
2355,"strcpy ( szName , url ) ;ext = strrchr ( szName , \'#\' ) ;if ( ext && strlen ( ext ) > 1 ) {strcpy ( szExt , & ext [ 1 ] ) ;","if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ;strcpy ( szName , url ) ;ext = strrchr ( szName , \'#\' ) ;if ( ext && strlen ( ext ) > 1 && strlen ( ext ) <= sizeof ( szExt ) ) {strcpy ( szExt , & ext [ 1 ] ) ;",2441
2356,"vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ;if ( ! vdev -> ctx ) return - ENOMEM ;","vdev -> ctx = kcalloc ( nvec , sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ;if ( ! vdev -> ctx ) return - ENOMEM ;",2442
2357,"int rc = 0 ;memset ( & sllc , 0 , sizeof ( sllc ) ) ;* uaddrlen = sizeof ( sllc ) ;memset ( uaddr , 0 , * uaddrlen ) ;","int rc = - EBADF ;memset ( & sllc , 0 , sizeof ( sllc ) ) ;* uaddrlen = sizeof ( sllc ) ;",2443
2358,static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu )  {if ( ! to_vmx ( vcpu ) -> nested . vmxon ) {,"static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu ) {if ( vmx_get_cpl ( vcpu ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;return 0 ;}if ( ! to_vmx ( vcpu ) -> nested . vmxon ) {",2444
2359,"if ( atomic_dec_and_test ( & ucounts -> count ) ) {spin_lock_irqsave ( & ucounts_lock , flags ) ;hlist_del_init ( & ucounts -> node ) ;spin_unlock_irqrestore ( & ucounts_lock , flags ) ;}","spin_lock_irqsave ( & ucounts_lock , flags ) ;ucounts -> count -= 1 ;if ( ! ucounts -> count ) hlist_del_init ( & ucounts -> node ) ;else ucounts = NULL ;spin_unlock_irqrestore ( & ucounts_lock , flags ) ;",2445
2360,data = img -> img_data ;if ( img -> fmt & VPX_IMG_FMT_HAS_ALPHA ) {img -> planes [ VPX_PLANE_ALPHA ] =  data + x + y * img -> stride [ VPX_PLANE_ALPHA ] ;data += img -> h * img -> stride [ VPX_PLANE_ALPHA ] ;img -> planes [ VPX_PLANE_Y ] = data + x + y * img -> stride [ VPX_PLANE_Y ] ;data += img -> h * img -> stride [ VPX_PLANE_Y ] ;img -> planes [ VPX_PLANE_U ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;img -> planes [ VPX_PLANE_V ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;}img -> planes [ VPX_PLANE_V ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;img -> planes [ VPX_PLANE_U ] = data  + ( x >> img -> x_chroma_shift )  + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;},const int bytes_per_sample = ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ;data = img -> img_data ;if ( img -> fmt & VPX_IMG_FMT_HAS_ALPHA ) {img -> planes [ VPX_PLANE_ALPHA ] = data + x * bytes_per_sample + y * img -> stride [ VPX_PLANE_ALPHA ] ;data += img -> h * img -> stride [ VPX_PLANE_ALPHA ] ;img -> planes [ VPX_PLANE_Y ] = data + x + y * img -> stride [ VPX_PLANE_Y ] ;data += img -> h * img -> stride [ VPX_PLANE_Y ] ;img -> planes [ VPX_PLANE_U ] = data + ( x >> img -> x_chroma_shift ) * bytes_per_sample + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;img -> planes [ VPX_PLANE_V ] = data + ( x >> img -> x_chroma_shift ) * bytes_per_sample + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;}img -> planes [ VPX_PLANE_V ] = data + ( x >> img -> x_chroma_shift ) * bytes_per_sample + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ;img -> planes [ VPX_PLANE_U ] = data + ( x >> img -> x_chroma_shift ) * bytes_per_sample + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ;},2446
2361,"JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\\result = realloc ( ptr , size ) ;","JAS_DBGLOG ( 101 , ( ""jas_realloc(%x,<S2SV_blank>%zu)\\\result = realloc ( ptr , size ) ;",2447
2362,passert ( GLOBALS_ARE_RESET ( ) ) ;},},2448
2363,"vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cm -> fc . mvc , flag ) ;","memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cm -> fc . mvc , flag ) ;",2449
2364,"
",int nb_bits = req [ offset + 5 ] ;,2450
2365,"int mapping_address = address - mb_mapping -> start_bits ;if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\\","int mapping_address = address - mb_mapping -> start_bits ;if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\\",2450
2366,"int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;int mapping_address = address - mb_mapping -> start_registers ;if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\\","int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;int nb_bytes = req [ offset + 5 ] ;int mapping_address = address - mb_mapping -> start_registers ;if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\\",2450
2367,"int ret = 0 , found = 0 ;char * repo_config = NULL ;","int ret = 0 , found = 0 ;",2451
2368,"repo_config = perf_pathdup ( ""config"" ) ;if ( ! access ( repo_config , R_OK ) ) {ret += perf_config_from_file ( fn , repo_config , data ) ;found += 1 ;}free ( repo_config ) ;","
",2451
2369,"static void  horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 4 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 4 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horDiff32"" , ""%s"" , ""(cc%(4*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",2452
2370,},return 1 ;},2452
2371,"bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",2453
2372,"thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride ) ;if ( thissad < bestsad ) {",2453
2373,if ( A > skb -> len - sizeof ( struct nlattr ) )  return 0 ;if ( nla -> nla_len > A - skb -> len )  return 0 ;,if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ;if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ;if ( nla -> nla_len > skb -> len - A ) return 0 ;,2454
2374,total = le32_to_cpu ( raw_super -> segment_count ) ;fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ;,"unsigned int main_segs , blocks_per_seg ;int i ;total = le32_to_cpu ( raw_super -> segment_count ) ;fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ;",2455
2375,"if ( unlikely ( f2fs_cp_error ( sbi ) ) ) {f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ;","main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ;blocks_per_seg = sbi -> blocks_per_seg ;for ( i = 0 ;i < NR_CURSEG_NODE_TYPE ;i ++ ) {if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ;}for ( i = 0 ;i < NR_CURSEG_DATA_TYPE ;i ++ ) {if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ;}if ( unlikely ( f2fs_cp_error ( sbi ) ) ) {f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ;",2455
2376,"REQ ( n , suite ) ;total = num_stmts ( n ) ;","if ( TYPE ( n ) != func_body_suite ) {REQ ( n , suite ) ;}total = num_stmts ( n ) ;",2456
2377,"for ( i = 2 ;ch = CHILD ( n , i ) ;","i = 2 ;if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) {i += 2 ;REQ ( CHILD ( n , 2 ) , NEWLINE ) ;}for ( ;ch = CHILD ( n , i ) ;",2456
2378,"int status = - 1 ;bool recompute_flag = false ;ALOGV ( ""%s<S2SV_blank>context<S2SV_blank>%p"" , __func__ , handle ) ;pthread_mutex_lock ( & vol_listner_init_lock ) ;list_for_each_safe ( node , temp_node_next , & vol_effect_list ) {if ( ( memcmp ( & ( context -> desc -> uuid ) , & ( recv_contex -> desc -> uuid ) , sizeof ( effect_uuid_t ) ) == 0 )   && ( context -> session_id == recv_contex -> session_id )   && ( context -> stream_type == recv_contex -> stream_type ) ) {ALOGV ( ""---<S2SV_blank>Found<S2SV_blank>something<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>---"" ) ;list_remove ( & context -> effect_list_node ) ;PRINT_STREAM_TYPE ( context -> stream_type ) ;","int status = - EINVAL ;bool recompute_flag = false ;uint32_t session_id ;uint32_t stream_type ;effect_uuid_t uuid ;ALOGV ( ""%s<S2SV_blank>context<S2SV_blank>%p"" , __func__ , handle ) ;if ( recv_contex == NULL ) {return status ;}pthread_mutex_lock ( & vol_listner_init_lock ) ;session_id = recv_contex -> session_id ;stream_type = recv_contex -> stream_type ;uuid = recv_contex -> desc -> uuid ;list_for_each_safe ( node , temp_node_next , & vol_effect_list ) {if ( ( memcmp ( & ( context -> desc -> uuid ) , & uuid , sizeof ( effect_uuid_t ) ) == 0 ) && ( context -> session_id == session_id ) && ( context -> stream_type == stream_type ) ) {ALOGV ( ""---<S2SV_blank>Found<S2SV_blank>something<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>---"" ) ;list_remove ( node ) ;PRINT_STREAM_TYPE ( context -> stream_type ) ;",2457
2379,}if ( active_stream_count == 0 ) {,pthread_mutex_unlock ( & vol_listner_init_lock ) ;return status ;}if ( active_stream_count == 0 ) {,2457
2380,break_type = 1 ;,if ( w -> linebreak || w == text_info -> glyphs ) text_info -> n_lines -- ;if ( w != text_info -> glyphs ) break_type = 1 ;,2458
2381,w -> linebreak = 1 ;s2 -> linebreak = 0 ;,w -> linebreak = 1 ;s2 -> linebreak = 0 ;,2458
2382,"if ( state -> expr_list . size == 0 ) {if ( ! state -> last_str ) {}return make_str_node_and_del ( & state -> last_str , c , n ) ;}if ( state -> last_str ) {expr_ty str = make_str_node_and_del ( & state -> last_str , c , n ) ;if ( ! str || ExprList_Append ( & state -> expr_list , str ) < 0 ) goto error ;}assert ( state -> last_str == NULL ) ;seq = ExprList_Finish ( & state -> expr_list , c -> c_arena ) ;if ( ! seq ) goto error ;if ( seq -> size == 1 )  return seq -> elements [ 0 ] ;",if ( ! state -> fmode ) {assert ( ! state -> expr_list . size ) ;if ( ! state -> last_str ) {,2459
2383,if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) {if ( new_len > old_len ) goto Efault ;,if ( new_len > old_len ) {unsigned long pgoff ;if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) goto Efault ;pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ;pgoff += vma -> vm_pgoff ;if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval ;,2460
2384,kvm_async_pf_hash_reset ( vcpu ) ;kvm_pmu_init ( vcpu ) ;,vcpu -> arch . pv_time_enabled = false ;kvm_async_pf_hash_reset ( vcpu ) ;kvm_pmu_init ( vcpu ) ;,2461
2385,tfrc . tfrctx_x = hc -> tx_x ;tfrc . tfrctx_x_recv = hc -> tx_x_recv ;,"memset ( & tfrc , 0 , sizeof ( tfrc ) ) ;tfrc . tfrctx_x = hc -> tx_x ;tfrc . tfrctx_x_recv = hc -> tx_x_recv ;",2462
2386,case EXIT_REASON_EXCEPTION_NMI :  if ( ! is_exception ( intr_info ) )  return false ;,case EXIT_REASON_EXCEPTION_NMI : if ( is_nmi ( intr_info ) ) return false ;,2463
2387,"}else   n ++ ;log_debug ( ""%s:<S2SV_blank>%u<S2SV_blank>=<S2SV_blank>%d"" , __func__ , n - 1 , p [ n - 1 ] ) ;","}else {n ++ ;if ( n == nitems ( p ) ) {free ( copy ) ;return ;}}log_debug ( ""%s:<S2SV_blank>%u<S2SV_blank>=<S2SV_blank>%d"" , __func__ , n - 1 , p [ n - 1 ] ) ;",2464
2388,void ext4_xattr_destroy_cache ( struct mb_cache * cache )  {if ( cache )  mb_cache_destroy ( cache ) ;},void ext4_xattr_destroy_cache ( struct mb2_cache * cache ) {if ( cache ) mb2_cache_destroy ( cache ) ;},2465
2389,"static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs )  {","static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) {",2466
2390,fclose ( fp ) ;return true ;,"const int dest_fd = fileno ( fp ) ;if ( fchown ( dest_fd , uid , gid ) < 0 ) {perror_msg ( ""Can\\\'t<S2SV_blank>change<S2SV_blank>\\\'%s\\\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu"" , dest_filename , ( long ) uid , ( long ) gid ) ;fclose ( fp ) ;unlink ( dest_filename ) ;return false ;}fclose ( fp ) ;return true ;",2466
2391,u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ;ps_dec -> u1_nal_unit_type = u1_nal_unit_type ;,u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ;if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) {return ERROR_INCOMPLETE_FRAME ;}ps_dec -> u1_nal_unit_type = u1_nal_unit_type ;,2467
2392,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;return 0 ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;return 0 ;",2468
2393,PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;for ( p = val ;zval * * tmp ;namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ;,int skip = 0 ;PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;for ( p = val ;zval * * tmp ;skip = 0 ;namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ;,2469
2394,"efree ( name ) ;continue ;php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;}PS_ADD_VARL ( name , namelen ) ;efree ( name ) ;","skip = 1 ;if ( ! skip ) {php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;}}if ( ! skip ) {PS_ADD_VARL ( name , namelen ) ;}efree ( name ) ;",2469
2395,"if ( mode > 0 ) {r = fchmod ( fd , mode ) ;","if ( mode != MODE_INVALID ) {r = fchmod ( fd , mode ) ;",2470
2396,"if ( skb -> protocol == htons ( ETH_P_IP ) ) return tcp_v4_do_rcv ( sk , skb ) ;if ( sk_filter ( sk , skb ) )  goto discard ;","if ( tcp_filter ( sk , skb ) ;if ( sk_filter ( sk , skb ) ) goto discard ;",2471
2397,uint32_t bcount ;infilesize = DoGetFileSize ( infile ) ;,int format_chunk = 0 ;uint32_t bcount ;infilesize = DoGetFileSize ( infile ) ;,2472
2398,"int supported = TRUE , format ;chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ;","int supported = TRUE , format ;if ( format_chunk ++ ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ;",2472
2399,static int get_max_filter_level ( VP9_COMP * cpi ) {return cpi -> twopass . section_intra_rating > 8 ? MAX_LOOP_FILTER * 3 / 4 : MAX_LOOP_FILTER ;},static int get_max_filter_level ( const VP9_COMP * cpi ) {if ( cpi -> oxcf . pass == 2 ) {return cpi -> twopass . section_intra_rating > 8 ? MAX_LOOP_FILTER * 3 / 4 : MAX_LOOP_FILTER ;}else {return MAX_LOOP_FILTER ;}},2473
2400,for ( ifa1 = in_dev -> ifa_list ;if ( ifa1 == ifa ) {,if ( in_dev -> dead ) goto no_promotions ;for ( ifa1 = in_dev -> ifa_list ;if ( ifa1 == ifa ) {,2474
2401,"}if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ;","}no_promotions : if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ;",2474
2402,"if ( ! dir_emit_dots ( file , ctx ) )  return 0 ;pos = 2 ;","if ( ! dir_emit_dots ( file , ctx ) ) goto out ;pos = 2 ;",2475
2403,sysctl_head_finish ( head ) ;return 0 ;,out : sysctl_head_finish ( head ) ;return 0 ;,2475
2404,char * tmp_str ;GF_Err e ;,char * tmp_str ;Bool zfound = GF_FALSE ;GF_Err e ;,2476
2405,"if ( ! tmp_str [ i ] )  break ;}if ( i ) {int j = 0 ;tmp_strsize = ( u32 ) ptr -> size ;if ( ! tmp_str [ j ] )  break ;if ( j ) {gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ;int j = 0 ;tmp_strsize = ( u32 ) ptr -> size ;if ( ! tmp_str [ j ] )  break ;if ( j ) {gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;if ( ! tmp_str [ i ] )  break ;if ( i ) {ptr -> drm_data = gf_strdup ( tmp_str ) ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;if ( ! tmp_str [ i ] )  break ;}if ( i ) {","if ( ! tmp_str [ i ] ) {zfound = GF_TRUE ;break ;}}if ( ! zfound ) return GF_ISOM_INVALID_FILE ;if ( i ) {int j = 0 ;zfound = GF_FALSE ;tmp_strsize = ( u32 ) ptr -> size ;if ( ! tmp_str [ j ] ) {zfound = GF_TRUE ;break ;}if ( ! zfound ) return GF_ISOM_INVALID_FILE ;if ( j ) {gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ;int j = 0 ;zfound = GF_FALSE ;tmp_strsize = ( u32 ) ptr -> size ;if ( ! tmp_str [ j ] ) {zfound = GF_TRUE ;break ;}if ( ! zfound ) return GF_ISOM_INVALID_FILE ;if ( j ) {gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ;zfound = GF_FALSE ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;if ( ! tmp_str [ i ] ) {zfound = GF_TRUE ;break ;}if ( ! zfound ) return GF_ISOM_INVALID_FILE ;if ( i ) {ptr -> drm_data = gf_strdup ( tmp_str ) ;zfound = GF_FALSE ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;if ( ! tmp_str [ i ] ) {zfound = GF_TRUE ;break ;}}if ( ! zfound ) return GF_ISOM_INVALID_FILE ;if ( i ) {",2476
2406,"struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ;","struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ;",2477
2407,"for ( s = 0 ;s < ns ;tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ;","for ( s = 0 ;s < ns && row < imagelength ;tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ;",2478
2408,"if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ;","if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;if ( addr . nl_pid ) {syslog ( LOG_WARNING , ""Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u"" , addr . nl_pid ) ;continue ;}incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ;",2479
2409,"int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  {","static int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) {",2480
2410,static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx )  {if ( avctx -> bits_per_raw_sample > 8 ) {av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;return avctx -> pix_fmt ;,static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx ) {MpegEncContext * s = avctx -> priv_data ;if ( avctx -> bits_per_raw_sample > 8 ) {av_assert1 ( s -> studio_profile ) ;return avctx -> pix_fmt ;,2481
2411,"struct in6_addr * saddr = NULL , * final_p , final ;struct flowi6 fl6 ;memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;if ( np -> sndflow ) {fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ;IP6_ECN_flow_init ( fl6 . flowlabel ) ;if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) {struct ip6_flowlabel * flowlabel ;flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ;if ( flowlabel == NULL ) return - EINVAL ;fl6_sock_release ( flowlabel ) ;}}if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 1 ;addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ;if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ;if ( addr_type & IPV6_ADDR_LINKLOCAL ) {if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) {if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) return - EINVAL ;sk -> sk_bound_dev_if = usin -> sin6_scope_id ;}if ( ! sk -> sk_bound_dev_if ) return - EINVAL ;}sk -> sk_v6_daddr = usin -> sin6_addr ;np -> flow_label = fl6 . flowlabel ;if ( addr_type == IPV6_ADDR_MAPPED ) {u32 exthdrlen = icsk -> icsk_ext_hdr_len ;struct sockaddr_in sin ;SOCK_DEBUG ( sk , ""connect:<S2SV_blank>ipv4<S2SV_blank>mapped\\\if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ;sin . sin_family = AF_INET ;sin . sin_port = usin -> sin6_port ;sin . sin_addr . s_addr = usin -> sin6_addr . s6_addr32 [ 3 ] ;icsk -> icsk_af_ops = & dccp_ipv6_mapped ;sk -> sk_backlog_rcv = dccp_v4_do_rcv ;err = dccp_v4_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ;if ( err ) {icsk -> icsk_ext_hdr_len = exthdrlen ;icsk -> icsk_af_ops = & dccp_ipv6_af_ops ;sk -> sk_backlog_rcv = dccp_v6_do_rcv ;goto failure ;}np -> saddr = sk -> sk_v6_rcv_saddr ;return err ;}if ( ! ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) saddr = & sk -> sk_v6_rcv_saddr ;fl6 . flowi6_proto = IPPROTO_DCCP ;fl6 . daddr = sk -> sk_v6_daddr ;fl6 . saddr = saddr ? * saddr : np -> saddr ;fl6 . flowi6_oif = sk -> sk_bound_dev_if ;fl6 . fl6_dport = usin -> sin6_port ;fl6 . fl6_sport = inet -> inet_sport ;security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;","struct in6_addr * saddr = NULL , * final_p , final ;struct ipv6_txoptions * opt ;struct flowi6 fl6 ;memset ( & fl6 , opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",2482
